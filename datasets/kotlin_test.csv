repo,sha,file,ext,author_name,author_email,date,message,flag_security,class_name,function,sample_id,cwe_list,owasp_category,label
duckduckgo__Android,9fcccc7553fdae2627c6aad53addfd59969d116e,vpn/src/androidTest/java/com/duckduckgo/mobile/android/vpn/ui/notification/DeviceShieldWeeklyNotificationFactoryTest.kt,.kt,David González,malmstein@gmail.com,2022-01-12T16:56:16+01:00,"Update Style guide, remove old settings (#1632)",1,DeviceShieldWeeklyNotificationFactoryTest,"class DeviceShieldWeeklyNotificationFactoryTest {

    private lateinit var db: VpnDatabase
    private lateinit var vpnTrackerDao: VpnTrackerDao
    private lateinit var appTrackerBlockingStatsRepository: AppTrackerBlockingStatsRepository

    private lateinit var factory: DeviceShieldNotificationFactory

    @Before
    fun before() {
        AndroidThreeTen.init(InstrumentationRegistry.getInstrumentation().targetContext)
        db = Room.inMemoryDatabaseBuilder(InstrumentationRegistry.getInstrumentation().targetContext, VpnDatabase::class.java)
            .allowMainThreadQueries()
            .build()
        vpnTrackerDao = db.vpnTrackerDao()
        appTrackerBlockingStatsRepository = AppTrackerBlockingStatsRepository(db)

        factory = DeviceShieldNotificationFactory(InstrumentationRegistry.getInstrumentation().targetContext.resources, appTrackerBlockingStatsRepository)
    }

    @After
    fun after() {
        db.close()
    }

    @Test
    fun createsWeeklyReportNotificationWhenTrackersFoundInOneApp() = runBlocking {
        val trackerDomain = ""example.com""
        trackerFound(trackerDomain)

        val notification = factory.weeklyNotificationFactory.createWeeklyDeviceShieldNotification(0)
        notification.assertTitleEquals(""App Tracking Protection blocked 1 tracking attempt in Foo App (past week)."")
        assertFalse(notification.hidden)
    }

    @Test
    fun createsWeeklyReportNotificationWhenTrackersFoundInTwoApps() = runBlocking {
        val trackerDomain = ""example.com""
        trackerFound(trackerDomain, appContainingTracker = trackingApp1())
        trackerFound(trackerDomain, appContainingTracker = trackingApp2())

        val notification = factory.weeklyNotificationFactory.createWeeklyDeviceShieldNotification(0)
        notification.assertTitleEquals(""App Tracking Protection blocked 2 tracking attempts in app2 and 1 other app (past week)."")
        assertFalse(notification.hidden)
    }

    @Test
    fun createsWeeklyReportNotificationWhenTrackersFoundInMoreThanTwoApps() = runBlocking {
        val trackerDomain = ""example.com""
        trackerFound(trackerDomain, appContainingTracker = trackingApp1())
        trackerFound(trackerDomain, appContainingTracker = trackingApp2())
        trackerFound(trackerDomain, appContainingTracker = trackingApp3())

        val notification = factory.weeklyNotificationFactory.createWeeklyDeviceShieldNotification(0)
        notification.assertTitleEquals(""App Tracking Protection blocked 3 tracking attempts in app3 and 2 other apps (past week)."")
        assertFalse(notification.hidden)
    }

    @Test
    fun createsWeeklyReportNotificationWithCorrectSortOrder() = runBlocking {
        val trackerDomain = ""example.com""
        trackerFound(trackerDomain, appContainingTracker = trackingApp1())
        trackerFound(trackerDomain, appContainingTracker = trackingApp2())
        trackerFound(trackerDomain, appContainingTracker = trackingApp2())
        trackerFound(trackerDomain, appContainingTracker = trackingApp3())
        trackerFound(trackerDomain, appContainingTracker = trackingApp3())
        trackerFound(trackerDomain, appContainingTracker = trackingApp3())

        val notification = factory.weeklyNotificationFactory.createWeeklyDeviceShieldNotification(0)
        notification.assertTitleEquals(""App Tracking Protection blocked 6 tracking attempts in app3 and 2 other apps (past week)."")
        assertFalse(notification.hidden)
    }

    @Test
    fun createsHiddenWeeklyReportNotificationWhenNoTrackersFound() = runBlocking {
        val notification = factory.weeklyNotificationFactory.createWeeklyDeviceShieldNotification(0)
        assertTrue(notification.hidden)
    }

    @Test
    fun createsWeeklyTopTrackerCompanyNotificationWhenTrackersFoundInOneApp() = runBlocking {
        val trackerDomain = ""example.com""
        trackerFound(trackerDomain)

        val notification = factory.weeklyNotificationFactory.createWeeklyDeviceShieldNotification(1)
        notification.assertTitleEquals(""App Tracking Protection blocked Tracking LLC in 1 app, Foo App (past week)."")
        assertFalse(notification.hidden)
    }

    @Test
    fun createsWeeklyTopTrackerCompanyNotificationWhenTrackersFoundInTwoApps() = runBlocking {
        val trackerDomain = ""example.com""

        trackerFound(trackerDomain, company = ""Google"", appContainingTracker = trackingApp1())
        trackerFound(trackerDomain, company = ""Google"", appContainingTracker = trackingApp1())
        trackerFound(trackerDomain, company = ""Facebook"", appContainingTracker = trackingApp2())
        trackerFound(trackerDomain, company = ""Google"", appContainingTracker = trackingApp2())
        trackerFound(trackerDomain, company = ""Google"", appContainingTracker = trackingApp2())
        trackerFound(
            trackerDomain, company = ""Google"", appContainingTracker = trackingApp2(),
            timestamp = DatabaseDateFormatter.bucketByHour(
                LocalDateTime.now().plusHours(2)
            )
        )

        val notification = factory.weeklyNotificationFactory.createWeeklyDeviceShieldNotification(1)
        notification.assertTitleEquals(""App Tracking Protection blocked Google across 2 apps, including app2 (past week)."")
        assertFalse(notification.hidden)
    }

    @Test
    fun createsHiddenWeeklyTopTrackerCompanyNotificationWhenNoTrackersFound() = runBlocking {
        val notification = factory.weeklyNotificationFactory.createWeeklyDeviceShieldNotification(1)
        assertTrue(notification.hidden)
    }

    private fun trackerFound(
        domain: String = ""example.com"",
        trackerCompanyId: Int = -1,
        company: String = ""Tracking LLC"",
        appContainingTracker: TrackingApp = defaultApp(),
        timestamp: String = DatabaseDateFormatter.bucketByHour()
    ) {
        val tracker = VpnTracker(
            trackerCompanyId = trackerCompanyId,
            domain = domain,
            timestamp = timestamp,
            company = company,
            companyDisplayName = company,
            trackingApp = appContainingTracker
        )
        vpnTrackerDao.insert(tracker)
    }

    private fun defaultApp() = TrackingApp(""app.foo.com"", ""Foo App"")
    private fun trackingApp1() = TrackingApp(""package1"", ""app1"")
    private fun trackingApp2() = TrackingApp(""package2"", ""app2"")
    private fun trackingApp3() = TrackingApp(""package3"", ""app3"")

}",KSEC_5458,['CWE-321: Hard-coded Cryptographic Key'],"['A02: Cryptographic Failures', 'A04: Insecure Design']",1
thunderbird__thunderbird-android,7cec3184334f18f8ea570ea1f4dc39b07462929b,legacy/ui/legacy/src/main/java/com/fsck/k9/activity/compose/RecipientPresenter.kt,.kt,Wolf-Martell Montwé,wolf@thunderbird.net,2025-06-04T14:16:01+02:00,refactor(core-logging): replace timber by core logging legacy,1,,"package com.fsck.k9.activity.compose

import android.Manifest
import android.app.Activity
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.net.Uri
import android.os.AsyncTask
import android.os.Bundle
import android.view.Menu
import androidx.core.content.ContextCompat
import androidx.loader.app.LoaderManager
import com.fsck.k9.K9
import com.fsck.k9.activity.compose.ComposeCryptoStatus.AttachErrorState
import com.fsck.k9.activity.compose.ComposeCryptoStatus.SendErrorState
import com.fsck.k9.autocrypt.AutocryptDraftStateHeader
import com.fsck.k9.autocrypt.AutocryptDraftStateHeaderParser
import com.fsck.k9.helper.MailTo
import com.fsck.k9.helper.ReplyToParser
import com.fsck.k9.mail.Address
import com.fsck.k9.mail.Flag
import com.fsck.k9.mail.Message
import com.fsck.k9.mail.Message.RecipientType
import com.fsck.k9.message.AutocryptStatusInteractor
import com.fsck.k9.message.AutocryptStatusInteractor.RecipientAutocryptStatus
import com.fsck.k9.message.ComposePgpEnableByDefaultDecider
import com.fsck.k9.message.ComposePgpInlineDecider
import com.fsck.k9.message.MessageBuilder
import com.fsck.k9.message.PgpMessageBuilder
import com.fsck.k9.ui.R
import com.fsck.k9.view.RecipientSelectView.Recipient
import net.thunderbird.core.android.account.AccountDefaultsProvider.Companion.NO_OPENPGP_KEY
import net.thunderbird.core.android.account.LegacyAccount
import net.thunderbird.core.android.contact.ContactIntentHelper
import org.openintents.openpgp.OpenPgpApiManager
import org.openintents.openpgp.OpenPgpApiManager.OpenPgpApiManagerCallback
import org.openintents.openpgp.OpenPgpApiManager.OpenPgpProviderError
import org.openintents.openpgp.OpenPgpApiManager.OpenPgpProviderState
import timber.log.Timber

private const val STATE_KEY_CC_SHOWN = ""state:ccShown""
private const val STATE_KEY_BCC_SHOWN = ""state:bccShown""
private const val STATE_KEY_LAST_FOCUSED_TYPE = ""state:lastFocusedType""
private const val STATE_KEY_CURRENT_CRYPTO_MODE = ""state:currentCryptoMode""
private const val STATE_KEY_CRYPTO_ENABLE_PGP_INLINE = ""state:cryptoEnablePgpInline""

private const val CONTACT_PICKER_TO = 1
private const val CONTACT_PICKER_CC = 2
private const val CONTACT_PICKER_BCC = 3
private const val OPENPGP_USER_INTERACTION = 4
private const val REQUEST_CODE_AUTOCRYPT = 5

private const val PGP_DIALOG_DISPLAY_THRESHOLD = 2

@Suppress(""LongParameterList"")
class RecipientPresenter(
    private val context: Context,
    loaderManager: LoaderManager,
    private val openPgpApiManager: OpenPgpApiManager,
    private val recipientMvpView: RecipientMvpView,
    account: LegacyAccount,
    private val composePgpInlineDecider: ComposePgpInlineDecider,
    private val composePgpEnableByDefaultDecider: ComposePgpEnableByDefaultDecider,
    private val autocryptStatusInteractor: AutocryptStatusInteractor,
    private val replyToParser: ReplyToParser,
    private val draftStateHeaderParser: AutocryptDraftStateHeaderParser,
) {
    private var isToAddressAdded: Boolean = false
    private lateinit var account: LegacyAccount
    private var alwaysBccAddresses: Array<Address>? = null
    private var hasContactPicker: Boolean? = null
    private var isReplyToEncryptedMessage = false

    private var lastFocusedType = RecipientType.TO
    private var currentCryptoMode = CryptoMode.NO_CHOICE

    var isForceTextMessageFormat = false
        private set

    var currentCachedCryptoStatus: ComposeCryptoStatus? = null
        private set

    val toAddresses: List<Address>
        get() = recipientMvpView.toAddresses

    val ccAddresses: List<Address>
        get() = recipientMvpView.ccAddresses

    val bccAddresses: List<Address>
        get() = recipientMvpView.bccAddresses

    private val allRecipients: List<Recipient>
        get() = with(recipientMvpView) { toRecipients + ccRecipients + bccRecipients }

    private val openPgpCallback = object : OpenPgpApiManagerCallback {
        override fun onOpenPgpProviderStatusChanged() {
            if (openPgpApiManager.openPgpProviderState == OpenPgpProviderState.UI_REQUIRED) {
                recipientMvpView.showErrorOpenPgpUserInteractionRequired()
            }
            asyncUpdateCryptoStatus()
        }

        override fun onOpenPgpProviderError(error: OpenPgpProviderError) {
            when (error) {
                OpenPgpProviderError.ConnectionLost -> openPgpApiManager.refreshConnection()
                OpenPgpProviderError.VersionIncompatible -> recipientMvpView.showErrorOpenPgpIncompatible()
                OpenPgpProviderError.ConnectionFailed -> recipientMvpView.showErrorOpenPgpConnection()
                else -> recipientMvpView.showErrorOpenPgpConnection()
            }
        }
    }

    init {
        recipientMvpView.setPresenter(this)
        recipientMvpView.setLoaderManager(loaderManager)

        onSwitchAccount(account)
    }

    fun checkRecipientsOkForSending(): Boolean {
        recipientMvpView.recipientToTryPerformCompletion()
        recipientMvpView.recipientCcTryPerformCompletion()
        recipientMvpView.recipientBccTryPerformCompletion()

        if (recipientMvpView.recipientToHasUncompletedText()) {
            recipientMvpView.showToUncompletedError()
            return true
        }

        if (recipientMvpView.recipientCcHasUncompletedText()) {
            recipientMvpView.showCcUncompletedError()
            return true
        }

        if (recipientMvpView.recipientBccHasUncompletedText()) {
            recipientMvpView.showBccUncompletedError()
            return true
        }

        if (toAddresses.isEmpty() && ccAddresses.isEmpty() && bccAddresses.isEmpty()) {
            recipientMvpView.showNoRecipientsError()
            return true
        }

        return false
    }

    fun initFromReplyToMessage(message: Message?, isReplyAll: Boolean) {
        val replyToAddresses = if (isReplyAll) {
            replyToParser.getRecipientsToReplyAllTo(message, account)
        } else {
            replyToParser.getRecipientsToReplyTo(message, account)
        }

        addToAddresses(*replyToAddresses.to)
        addCcAddresses(*replyToAddresses.cc)

        val shouldSendAsPgpInline = composePgpInlineDecider.shouldReplyInline(message)
        if (shouldSendAsPgpInline) {
            isForceTextMessageFormat = true
        }

        isReplyToEncryptedMessage = composePgpEnableByDefaultDecider.shouldEncryptByDefault(message)
    }

    fun initFromTrustIdAction(trustId: String?) {
        addToAddresses(*Address.parse(trustId))
        currentCryptoMode = CryptoMode.CHOICE_ENABLED
    }

    fun initFromMailto(mailTo: MailTo) {
        addToAddresses(*mailTo.to)
        addCcAddresses(*mailTo.cc)
        addBccAddresses(*mailTo.bcc)
    }

    fun initFromSendOrViewIntent(intent: Intent) {
        val toAddresses = intent.getStringArrayExtra(Intent.EXTRA_EMAIL)?.toAddressArray()
        val ccAddresses = intent.getStringArrayExtra(Intent.EXTRA_CC)?.toAddressArray()
        val bccAddresses = intent.getStringArrayExtra(Intent.EXTRA_BCC)?.toAddressArray()

        if (toAddresses != null) {
            addToAddresses(*toAddresses)
        }

        if (ccAddresses != null) {
            addCcAddresses(*ccAddresses)
        }

        if (bccAddresses != null) {
            addBccAddresses(*bccAddresses)
        }
    }

    fun onRestoreInstanceState(savedInstanceState: Bundle) {
        recipientMvpView.setCcVisibility(savedInstanceState.getBoolean(STATE_KEY_CC_SHOWN))
        recipientMvpView.setBccVisibility(savedInstanceState.getBoolean(STATE_KEY_BCC_SHOWN))
        lastFocusedType = RecipientType.valueOf(savedInstanceState.getString(STATE_KEY_LAST_FOCUSED_TYPE)!!)
        currentCryptoMode = CryptoMode.valueOf(savedInstanceState.getString(STATE_KEY_CURRENT_CRYPTO_MODE)!!)
        isForceTextMessageFormat = savedInstanceState.getBoolean(STATE_KEY_CRYPTO_ENABLE_PGP_INLINE)

        updateRecipientExpanderVisibility()
    }

    fun onSaveInstanceState(outState: Bundle) {
        outState.putBoolean(STATE_KEY_CC_SHOWN, recipientMvpView.isCcVisible)
        outState.putBoolean(STATE_KEY_BCC_SHOWN, recipientMvpView.isBccVisible)
        outState.putString(STATE_KEY_LAST_FOCUSED_TYPE, lastFocusedType.toString())
        outState.putString(STATE_KEY_CURRENT_CRYPTO_MODE, currentCryptoMode.toString())
        outState.putBoolean(STATE_KEY_CRYPTO_ENABLE_PGP_INLINE, isForceTextMessageFormat)
    }

    fun initFromDraftMessage(message: Message) {
        initRecipientsFromDraftMessage(message)

        val draftStateHeader = message.getHeader(AutocryptDraftStateHeader.AUTOCRYPT_DRAFT_STATE_HEADER)
        if (draftStateHeader.size == 1) {
            initEncryptionStateFromDraftStateHeader(draftStateHeader.first())
        } else {
            initPgpInlineFromDraftMessage(message)
        }
    }

    private fun initEncryptionStateFromDraftStateHeader(headerValue: String) {
        val autocryptDraftStateHeader = draftStateHeaderParser.parseAutocryptDraftStateHeader(headerValue)
        if (autocryptDraftStateHeader != null) {
            initEncryptionStateFromDraftStateHeader(autocryptDraftStateHeader)
        }
    }

    private fun initRecipientsFromDraftMessage(message: Message) {
        addToAddresses(*message.getRecipients(RecipientType.TO))
        addCcAddresses(*message.getRecipients(RecipientType.CC))
        addBccAddresses(*message.getRecipients(RecipientType.BCC))
    }

    private fun initEncryptionStateFromDraftStateHeader(draftState: AutocryptDraftStateHeader) {
        isForceTextMessageFormat = draftState.isPgpInline
        isReplyToEncryptedMessage = draftState.isReply

        if (!draftState.isByChoice) {
            // TODO if it's not by choice, we're going with our defaults. should we do something here if those differ?
            return
        }

        currentCryptoMode = when {
            draftState.isSignOnly -> CryptoMode.SIGN_ONLY
            draftState.isEncrypt -> CryptoMode.CHOICE_ENABLED
            else -> CryptoMode.CHOICE_DISABLED
        }
    }

    private fun initPgpInlineFromDraftMessage(message: Message) {
        isForceTextMessageFormat = message.isSet(Flag.X_DRAFT_OPENPGP_INLINE)
    }

    private fun addToAddresses(vararg toAddresses: Address) {
        addRecipientsFromAddresses(RecipientType.TO, *toAddresses)
        isToAddressAdded = true
    }

    fun isToAddressAdded() = isToAddressAdded

    private fun addCcAddresses(vararg ccAddresses: Address) {
        if (ccAddresses.isNotEmpty()) {
            addRecipientsFromAddresses(RecipientType.CC, *ccAddresses)
            recipientMvpView.setCcVisibility(true)
            updateRecipientExpanderVisibility()
        }
    }

    private fun addBccAddresses(vararg bccRecipients: Address) {
        if (bccRecipients.isNotEmpty()) {
            addRecipientsFromAddresses(RecipientType.BCC, *bccRecipients)
            recipientMvpView.setBccVisibility(true)
            updateRecipientExpanderVisibility()
        }
    }

    private fun addAlwaysBcc() {
        val alwaysBccAddresses = Address.parse(account.alwaysBcc)
        this.alwaysBccAddresses = alwaysBccAddresses
        if (alwaysBccAddresses.isEmpty()) return

        object : RecipientLoader(context, account.openPgpProvider, *alwaysBccAddresses) {
            override fun deliverResult(result: List<Recipient>?) {
                val recipientArray = result!!.toTypedArray()
                recipientMvpView.silentlyAddBccAddresses(*recipientArray)

                stopLoading()
                abandon()
            }
        }.startLoading()
    }

    private fun removeAlwaysBcc() {
        alwaysBccAddresses?.let { alwaysBccAddresses ->
            recipientMvpView.silentlyRemoveBccAddresses(alwaysBccAddresses)
        }
    }

    fun onPrepareOptionsMenu(menu: Menu) {
        val currentCryptoStatus = currentCachedCryptoStatus

        if (currentCryptoStatus != null && currentCryptoStatus.isProviderStateOk()) {
            val isEncrypting = currentCryptoStatus.isEncryptionEnabled
            menu.findItem(R.id.openpgp_encrypt_enable).isVisible = !isEncrypting
            menu.findItem(R.id.openpgp_encrypt_disable).isVisible = isEncrypting

            val showSignOnly = !account.isOpenPgpHideSignOnly
            val isSignOnly = currentCryptoStatus.isSignOnly
            menu.findItem(R.id.openpgp_sign_only).isVisible = showSignOnly && !isSignOnly
            menu.findItem(R.id.openpgp_sign_only_disable).isVisible = showSignOnly && isSignOnly

            val pgpInlineModeEnabled = currentCryptoStatus.isPgpInlineModeEnabled
            val showPgpInlineEnable = (isEncrypting || isSignOnly) && !pgpInlineModeEnabled
            menu.findItem(R.id.openpgp_inline_enable).isVisible = showPgpInlineEnable
            menu.findItem(R.id.openpgp_inline_disable).isVisible = pgpInlineModeEnabled
        } else {
            menu.findItem(R.id.openpgp_inline_enable).isVisible = false
            menu.findItem(R.id.openpgp_inline_disable).isVisible = false
            menu.findItem(R.id.openpgp_encrypt_enable).isVisible = false
            menu.findItem(R.id.openpgp_encrypt_disable).isVisible = false
            menu.findItem(R.id.openpgp_sign_only).isVisible = false
            menu.findItem(R.id.openpgp_sign_only_disable).isVisible = false
        }

        menu.findItem(R.id.add_from_contacts).isVisible = hasContactPermission() && hasContactPicker()
    }

    fun onSwitchAccount(account: LegacyAccount) {
        this.account = account

        if (account.isAlwaysShowCcBcc) {
            recipientMvpView.setCcVisibility(true)
            recipientMvpView.setBccVisibility(true)
            updateRecipientExpanderVisibility()
        }

        removeAlwaysBcc()
        addAlwaysBcc()

        val openPgpProvider = account.openPgpProvider
        recipientMvpView.setCryptoProvider(openPgpProvider)
        openPgpApiManager.setOpenPgpProvider(openPgpProvider, openPgpCallback)
    }

    fun onSwitchIdentity() {
        // TODO decide what actually to do on identity switch?
        asyncUpdateCryptoStatus()
    }

    fun onClickToLabel() {
        recipientMvpView.requestFocusOnToField()
    }

    fun onClickCcLabel() {
        recipientMvpView.requestFocusOnCcField()
    }

    fun onClickBccLabel() {
        recipientMvpView.requestFocusOnBccField()
    }

    fun onClickRecipientExpander() {
        recipientMvpView.setCcVisibility(true)
        recipientMvpView.setBccVisibility(true)
        updateRecipientExpanderVisibility()
    }

    private fun hideEmptyExtendedRecipientFields() {
        if (recipientMvpView.ccAddresses.isEmpty() && recipientMvpView.isCcTextEmpty) {
            recipientMvpView.setCcVisibility(false)
            if (lastFocusedType == RecipientType.CC) {
                lastFocusedType = RecipientType.TO
            }
        }

        if (recipientMvpView.bccAddresses.isEmpty() && recipientMvpView.isBccTextEmpty) {
            recipientMvpView.setBccVisibility(false)
            if (lastFocusedType == RecipientType.BCC) {
                lastFocusedType = RecipientType.TO
            }
        }

        updateRecipientExpanderVisibility()
    }

    private fun updateRecipientExpanderVisibility() {
        val notBothAreVisible = !(recipientMvpView.isCcVisible && recipientMvpView.isBccVisible)
        recipientMvpView.setRecipientExpanderVisibility(notBothAreVisible)
    }

    fun asyncUpdateCryptoStatus() {
        currentCachedCryptoStatus = null

        val openPgpProviderState = openPgpApiManager.openPgpProviderState
        var accountCryptoKey: Long? = account.openPgpKey
        if (accountCryptoKey == NO_OPENPGP_KEY) {
            accountCryptoKey = null
        }

        val composeCryptoStatus = ComposeCryptoStatus(
            openPgpProviderState = openPgpProviderState,
            openPgpKeyId = accountCryptoKey,
            recipientAddresses = allRecipients,
            isPgpInlineModeEnabled = isForceTextMessageFormat,
            isSenderPreferEncryptMutual = account.autocryptPreferEncryptMutual,
            isReplyToEncrypted = isReplyToEncryptedMessage,
            isEncryptAllDrafts = account.isOpenPgpEncryptAllDrafts,
            isEncryptSubject = account.isOpenPgpEncryptSubject,
            cryptoMode = currentCryptoMode,
        )

        if (openPgpProviderState != OpenPgpProviderState.OK) {
            currentCachedCryptoStatus = composeCryptoStatus
            redrawCachedCryptoStatusIcon()
            return
        }

        val recipientAddresses = composeCryptoStatus.recipientAddressesAsArray
        object : AsyncTask<Void?, Void?, RecipientAutocryptStatus?>() {
            override fun doInBackground(vararg params: Void?): RecipientAutocryptStatus? {
                val openPgpApi = openPgpApiManager.openPgpApi ?: return null
                return autocryptStatusInteractor.retrieveCryptoProviderRecipientStatus(openPgpApi, recipientAddresses)
            }

            override fun onPostExecute(recipientAutocryptStatus: RecipientAutocryptStatus?) {
                currentCachedCryptoStatus = if (recipientAutocryptStatus != null) {
                    composeCryptoStatus.withRecipientAutocryptStatus(recipientAutocryptStatus)
                } else {
                    composeCryptoStatus
                }

                redrawCachedCryptoStatusIcon()
            }
        }.execute()
    }

    private fun redrawCachedCryptoStatusIcon() {
        val cryptoStatus = checkNotNull(currentCachedCryptoStatus) { ""must have cached crypto status to redraw it!"" }

        recipientMvpView.setRecipientTokensShowCryptoEnabled(cryptoStatus.isEncryptionEnabled)
        recipientMvpView.showCryptoStatus(cryptoStatus.displayType)
        recipientMvpView.showCryptoSpecialMode(cryptoStatus.specialModeDisplayType)
    }

    fun onToTokenAdded() {
        asyncUpdateCryptoStatus()
    }

    fun onToTokenRemoved() {
        asyncUpdateCryptoStatus()
    }

    fun onToTokenChanged() {
        asyncUpdateCryptoStatus()
    }

    fun onCcTokenAdded() {
        asyncUpdateCryptoStatus()
    }

    fun onCcTokenRemoved() {
        asyncUpdateCryptoStatus()
    }

    fun onCcTokenChanged() {
        asyncUpdateCryptoStatus()
    }

    fun onBccTokenAdded() {
        asyncUpdateCryptoStatus()
    }

    fun onBccTokenRemoved() {
        asyncUpdateCryptoStatus()
    }

    fun onBccTokenChanged() {
        asyncUpdateCryptoStatus()
    }

    fun onCryptoModeChanged(cryptoMode: CryptoMode) {
        currentCryptoMode = cryptoMode
        asyncUpdateCryptoStatus()
    }

    fun onCryptoPgpInlineChanged(enablePgpInline: Boolean) {
        isForceTextMessageFormat = enablePgpInline
        asyncUpdateCryptoStatus()
    }

    private fun addRecipientsFromAddresses(recipientType: RecipientType, vararg addresses: Address) {
        object : RecipientLoader(context, account.openPgpProvider, *addresses) {
            override fun deliverResult(result: List<Recipient>?) {
                val recipientArray = result!!.toTypedArray()
                recipientMvpView.silentlyAddRecipients(recipientType, *recipientArray)

                stopLoading()
                abandon()
            }
        }.startLoading()
    }

    private fun addRecipientFromContactUri(recipientType: RecipientType, uri: Uri?) {
        object : RecipientLoader(context, account.openPgpProvider, uri, false) {
            override fun deliverResult(result: List<Recipient>?) {
                // TODO handle multiple available mail addresses for a contact?
                if (result!!.isEmpty()) {
                    recipientMvpView.showErrorContactNoAddress()
                    return
                }

                val recipient = result[0]
                recipientMvpView.addRecipients(recipientType, recipient)

                stopLoading()
                abandon()
            }
        }.startLoading()
    }

    fun onToFocused() {
        lastFocusedType = RecipientType.TO
    }

    fun onCcFocused() {
        lastFocusedType = RecipientType.CC
    }

    fun onBccFocused() {
        lastFocusedType = RecipientType.BCC
    }

    fun onMenuAddFromContacts() {
        val requestCode = lastFocusedType.toRequestCode()
        recipientMvpView.showContactPicker(requestCode)
    }

    fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        when (requestCode) {
            CONTACT_PICKER_TO, CONTACT_PICKER_CC, CONTACT_PICKER_BCC -> {
                if (resultCode != Activity.RESULT_OK || data == null) return

                val recipientType = requestCode.toRecipientType()
                addRecipientFromContactUri(recipientType, data.data)
            }
            OPENPGP_USER_INTERACTION -> {
                openPgpApiManager.onUserInteractionResult()
            }
            REQUEST_CODE_AUTOCRYPT -> {
                asyncUpdateCryptoStatus()
            }
        }
    }

    fun onNonRecipientFieldFocused() {
        if (!account.isAlwaysShowCcBcc) {
            hideEmptyExtendedRecipientFields()
        }
    }

    fun onClickCryptoStatus() {
        when (openPgpApiManager.openPgpProviderState) {
            OpenPgpProviderState.UNCONFIGURED -> {
                Timber.e(""click on crypto status while unconfigured - this should not really happen?!"")
            }
            OpenPgpProviderState.OK -> {
                toggleEncryptionState(false)
            }
            OpenPgpProviderState.UI_REQUIRED -> {
                // TODO show openpgp settings
                val pendingIntent = openPgpApiManager.userInteractionPendingIntent
                recipientMvpView.launchUserInteractionPendingIntent(pendingIntent, OPENPGP_USER_INTERACTION)
            }
            OpenPgpProviderState.UNINITIALIZED, OpenPgpProviderState.ERROR -> {
                openPgpApiManager.refreshConnection()
            }
        }
    }

    private fun toggleEncryptionState(showGotIt: Boolean) {
        val currentCryptoStatus = currentCachedCryptoStatus
        if (currentCryptoStatus == null) {
            Timber.e(""click on crypto status while crypto status not available - should not really happen?!"")
            return
        }

        if (currentCryptoStatus.isEncryptionEnabled && !currentCryptoStatus.allRecipientsCanEncrypt()) {
            recipientMvpView.showOpenPgpEnabledErrorDialog(false)
            return
        }

        if (currentCryptoMode == CryptoMode.SIGN_ONLY) {
            recipientMvpView.showErrorIsSignOnly()
            return
        }

        val isEncryptOnNoChoice = currentCryptoStatus.canEncryptAndIsMutualDefault() ||
            currentCryptoStatus.isReplyToEncrypted

        if (currentCryptoMode == CryptoMode.NO_CHOICE) {
            if (currentCryptoStatus.hasAutocryptPendingIntent()) {
                recipientMvpView.launchUserInteractionPendingIntent(
                    currentCryptoStatus.autocryptPendingIntent,
                    REQUEST_CODE_AUTOCRYPT,
                )
            } else if (isEncryptOnNoChoice) {
                // TODO warning dialog if we override, especially from reply!
                onCryptoModeChanged(CryptoMode.CHOICE_DISABLED)
            } else {
                onCryptoModeChanged(CryptoMode.CHOICE_ENABLED)
                if (showGotIt) {
                    recipientMvpView.showOpenPgpEncryptExplanationDialog()
                }
            }
        } else if (currentCryptoMode == CryptoMode.CHOICE_DISABLED && !isEncryptOnNoChoice) {
            onCryptoModeChanged(CryptoMode.CHOICE_ENABLED)
        } else {
            onCryptoModeChanged(CryptoMode.NO_CHOICE)
        }
    }

    /**
     * Does the device actually have a Contacts application suitable for picking a contact.
     * As hard as it is to believe, some vendors ship without it.
     */
    private fun hasContactPicker(): Boolean {
        return hasContactPicker ?: isContactPickerAvailable().also { hasContactPicker = it }
    }

    private fun isContactPickerAvailable(): Boolean {
        val resolveInfoList =
            context.packageManager.queryIntentActivities(
                ContactIntentHelper.getContactPickerIntent(),
                0,
            )
        return resolveInfoList.isNotEmpty()
    }

    private fun hasContactPermission(): Boolean {
        val permissionState = ContextCompat.checkSelfPermission(context, Manifest.permission.READ_CONTACTS)
        return permissionState == PackageManager.PERMISSION_GRANTED
    }

    fun showPgpSendError(sendErrorState: SendErrorState) {
        when (sendErrorState) {
            SendErrorState.ENABLED_ERROR -> recipientMvpView.showOpenPgpEnabledErrorDialog(false)
            SendErrorState.PROVIDER_ERROR -> recipientMvpView.showErrorOpenPgpConnection()
            SendErrorState.KEY_CONFIG_ERROR -> recipientMvpView.showErrorNoKeyConfigured()
        }
    }

    fun showPgpAttachError(attachErrorState: AttachErrorState) {
        when (attachErrorState) {
            AttachErrorState.IS_INLINE -> recipientMvpView.showErrorInlineAttach()
        }
    }

    fun builderSetProperties(messageBuilder: MessageBuilder) {
        require(messageBuilder !is PgpMessageBuilder) {
            ""PpgMessageBuilder must be called with ComposeCryptoStatus argument!""
        }

        messageBuilder.setTo(toAddresses)
        messageBuilder.setCc(ccAddresses)
        messageBuilder.setBcc(bccAddresses)
    }

    fun builderSetProperties(pgpMessageBuilder: PgpMessageBuilder, cryptoStatus: ComposeCryptoStatus) {
        pgpMessageBuilder.setTo(toAddresses)
        pgpMessageBuilder.setCc(ccAddresses)
        pgpMessageBuilder.setBcc(bccAddresses)
        pgpMessageBuilder.setOpenPgpApi(openPgpApiManager.openPgpApi)
        pgpMessageBuilder.setCryptoStatus(cryptoStatus)
    }

    fun onMenuSetPgpInline(enablePgpInline: Boolean) {
        onCryptoPgpInlineChanged(enablePgpInline)

        if (enablePgpInline) {
            val shouldShowPgpInlineDialog = checkAndIncrementPgpInlineDialogCounter()
            if (shouldShowPgpInlineDialog) {
                recipientMvpView.showOpenPgpInlineDialog(true)
            }
        }
    }

    fun onMenuSetSignOnly(enableSignOnly: Boolean) {
        if (enableSignOnly) {
            onCryptoModeChanged(CryptoMode.SIGN_ONLY)

            val shouldShowPgpSignOnlyDialog = checkAndIncrementPgpSignOnlyDialogCounter()
            if (shouldShowPgpSignOnlyDialog) {
                recipientMvpView.showOpenPgpSignOnlyDialog(true)
            }
        } else {
            onCryptoModeChanged(CryptoMode.NO_CHOICE)
        }
    }

    fun onMenuToggleEncryption() {
        toggleEncryptionState(true)
    }

    fun onCryptoPgpClickDisable() {
        onCryptoModeChanged(CryptoMode.CHOICE_DISABLED)
    }

    fun onCryptoPgpSignOnlyDisabled() {
        onCryptoPgpInlineChanged(false)
        onCryptoModeChanged(CryptoMode.NO_CHOICE)
    }

    private fun checkAndIncrementPgpInlineDialogCounter(): Boolean {
        val pgpInlineDialogCounter = K9.pgpInlineDialogCounter
        if (pgpInlineDialogCounter < PGP_DIALOG_DISPLAY_THRESHOLD) {
            K9.pgpInlineDialogCounter = pgpInlineDialogCounter + 1
            K9.saveSettingsAsync()
            return true
        }

        return false
    }

    private fun checkAndIncrementPgpSignOnlyDialogCounter(): Boolean {
        val pgpSignOnlyDialogCounter = K9.pgpSignOnlyDialogCounter
        if (pgpSignOnlyDialogCounter < PGP_DIALOG_DISPLAY_THRESHOLD) {
            K9.pgpSignOnlyDialogCounter = pgpSignOnlyDialogCounter + 1
            K9.saveSettingsAsync()
            return true
        }

        return false
    }

    fun onClickCryptoSpecialModeIndicator() {
        when {
            currentCryptoMode == CryptoMode.SIGN_ONLY -> {
                recipientMvpView.showOpenPgpSignOnlyDialog(false)
            }
            isForceTextMessageFormat -> {
                recipientMvpView.showOpenPgpInlineDialog(false)
            }
            else -> {
                error(""This icon should not be clickable while no special mode is active!"")
            }
        }
    }

    private fun Array<String>.toAddressArray(): Array<Address> {
        return flatMap { addressString ->
            Address.parseUnencoded(addressString).toList()
        }.toTypedArray()
    }

    private fun RecipientType.toRequestCode(): Int = when (this) {
        RecipientType.TO -> CONTACT_PICKER_TO
        RecipientType.CC -> CONTACT_PICKER_CC
        RecipientType.BCC -> CONTACT_PICKER_BCC
        else -> throw AssertionError(""Unhandled case: $this"")
    }

    private fun Int.toRecipientType(): RecipientType = when (this) {
        CONTACT_PICKER_TO -> RecipientType.TO
        CONTACT_PICKER_CC -> RecipientType.CC
        CONTACT_PICKER_BCC -> RecipientType.BCC
        else -> throw AssertionError(""Unhandled case: $this"")
    }

    enum class CryptoMode {
        SIGN_ONLY,
        NO_CHOICE,
        CHOICE_DISABLED,
        CHOICE_ENABLED,
    }
}
",KSEC_1684,['CWE-321: Hard-coded Cryptographic Key'],"['A02: Cryptographic Failures', 'A04: Insecure Design']",1
JetBrains__kotlin,44b3754bcf7672146dcd9757d1246ad19f371042,compiler/testData/codegen/box/size/objectsOptimization.kt,.kt,Grigorii.Solnyshkin,Grigorii.Solnyshkin@jetbrains.com,2025-11-05T12:55:56+02:00,[Tests] Fix test data after adding companions to stdlib collections,1,,"// TARGET_BACKEND: WASM

// RUN_THIRD_PARTY_OPTIMIZER
// WASM_DCE_EXPECTED_OUTPUT_SIZE: wasm 61_056
// WASM_DCE_EXPECTED_OUTPUT_SIZE:  mjs  6_133
// WASM_OPT_EXPECTED_OUTPUT_SIZE:       4_822

// IGNORE_BACKEND: WASM_WASI

object Simple

object SimpleWithConstVal {
   const val MAX = 4
}

object SimpleWithPureProperty {
    val text = ""Hello""
}

object SimpleWithPropertyInitializedDurintInit {
    val text: String
    init {
        text = ""Hello""
    }
}

object SimpleWithFunctionsOnly {
    fun foo() = ""Foo""
    fun bar() = ""Bar""
}

object SimpleWithDifferentMembers {
    val foo = ""Foo""
    fun bar() = ""Bar""
}

interface Callable {
    fun call(): String
}

object SimpleWithInterface : Callable {
    override fun call() = ""OK""
}

object UsedGetFieldInside {
    val anotherText = SimpleWithPureProperty.text
}

class ClassWithCompanion {
   companion object
}

class ClassWithCompanionWithConst {
    companion object {
        const val MAX = 5
    }
}

fun box(): String {
    if (Simple !is Any) return ""Fail simple object""
    if (SimpleWithConstVal.MAX != 4) return ""Fail simple case with const val""
    if (SimpleWithPureProperty.text != ""Hello"") return ""Fail simple case with pure property""
    if (SimpleWithPropertyInitializedDurintInit.text != ""Hello"") return ""Fail simple case with pure property initialized inside init block""
    if (SimpleWithFunctionsOnly.foo() != ""Foo"" || SimpleWithFunctionsOnly.bar() != ""Bar"") return ""Fail simple case with functions only""
    if (SimpleWithInterface.call() != ""OK"") return ""Fail simple case with interface implementing""
    if (UsedGetFieldInside.anotherText != ""Hello"") return ""Fail object which used another object inside its initialization block""
    if (ClassWithCompanion.Companion !is Any) return ""Fail simple companion object""
    if (ClassWithCompanionWithConst.MAX != 5) return ""Fail simple companion object with const val""
    SimpleWithDifferentMembers
    return ""OK""
}",KOT_01088,CWE-321: Hard-coded Cryptographic Key,A02: Cryptographic Failures;A04: Insecure Design,1
JetBrains__kotlin,ee1c0b2940d2f506b9839f8b24800594e1acf50f,libraries/tools/kotlin-gradle-plugin-integration-tests/src/test/kotlin/org/jetbrains/kotlin/gradle/WasmPackageManagerGradlePluginIT.kt,.kt,Ilya Goncharov,ilya.goncharov@jetbrains.com,2025-04-15T16:45:22+02:00,[Wasm] Fix lock file upgrade in wasm integration tests,1,WasmNpmGradlePluginIT,"class WasmNpmGradlePluginIT : WasmPackageManagerGradlePluginIT() {
    override val yarn: Boolean = false

    override val lockFileName: String = PACKAGE_LOCK

    override val toolingCustomDir: String
        get() = ""npm""
}",KOT_03163,,,0
JetBrains__kotlin,482e87f7e583e1d4e00c83fd18897086f0991a19,analysis/low-level-api-fir/tests-gen/org/jetbrains/kotlin/analysis/low/level/api/fir/diagnostic/compiler/based/LLReversedBlackBoxTestGenerated.java,.java,Alexander Udalov,alexander.udalov@jetbrains.com,2025-10-22T19:25:47+02:00,Reflection: fix order of receiver/contexts in ValueClassAwareCaller,1,InlineClasses,"      public class InlineClasses {
        @Test
        public void testAllFilesPresentInInlineClasses() {
          KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File(""compiler/testData/codegen/box/reflection/call/inlineClasses""), Pattern.compile(""^(.+)\\.kt$""), null, true);
        }

        @Test
        @TestMetadata(""contextPropertyWithSameNameAsPrimary.kt"")
        public void testContextPropertyWithSameNameAsPrimary() {
          runTest(""compiler/testData/codegen/box/reflection/call/inlineClasses/contextPropertyWithSameNameAsPrimary.kt"");
        }

        @Test
        @TestMetadata(""inlineClassConstructor.kt"")
        public void testInlineClassConstructor() {
          runTest(""compiler/testData/codegen/box/reflection/call/inlineClasses/inlineClassConstructor.kt"");
        }

        @Test
        @TestMetadata(""internalPrimaryValOfInlineClass.kt"")
        public void testInternalPrimaryValOfInlineClass() {
          runTest(""compiler/testData/codegen/box/reflection/call/inlineClasses/internalPrimaryValOfInlineClass.kt"");
        }

        @Test
        @TestMetadata(""kt58887.kt"")
        public void testKt58887() {
          runTest(""compiler/testData/codegen/box/reflection/call/inlineClasses/kt58887.kt"");
        }

        @Test
        @TestMetadata(""primaryValOfInlineClass.kt"")
        public void testPrimaryValOfInlineClass() {
          runTest(""compiler/testData/codegen/box/reflection/call/inlineClasses/primaryValOfInlineClass.kt"");
        }

        @Test
        @TestMetadata(""secondaryConstructorVisibilies.kt"")
        public void testSecondaryConstructorVisibilies() {
          runTest(""compiler/testData/codegen/box/reflection/call/inlineClasses/secondaryConstructorVisibilies.kt"");
        }

        @Test
        @TestMetadata(""simpleConstructorWithInlineClassParameter.kt"")
        public void testSimpleConstructorWithInlineClassParameter() {
          runTest(""compiler/testData/codegen/box/reflection/call/inlineClasses/simpleConstructorWithInlineClassParameter.kt"");
        }

        @Test
        @TestMetadata(""unboxBothContextAndExtensionParameter.kt"")
        public void testUnboxBothContextAndExtensionParameter() {
          runTest(""compiler/testData/codegen/box/reflection/call/inlineClasses/unboxBothContextAndExtensionParameter.kt"");
        }

        @Nested
        @TestMetadata(""compiler/testData/codegen/box/reflection/call/inlineClasses/nonNullObject"")
        @TestDataPath(""$PROJECT_ROOT"")
        public class NonNullObject {
          @Test
          public void testAllFilesPresentInNonNullObject() {
            KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File(""compiler/testData/codegen/box/reflection/call/inlineClasses/nonNullObject""), Pattern.compile(""^(.+)\\.kt$""), null, true);
          }

          @Test
          @TestMetadata(""constructorWithInlineClassParameters.kt"")
          public void testConstructorWithInlineClassParameters() {
            runTest(""compiler/testData/codegen/box/reflection/call/inlineClasses/nonNullObject/constructorWithInlineClassParameters.kt"");
          }

          @Test
          @TestMetadata(""contextParameters.kt"")
          public void testContextParameters() {
            runTest(""compiler/testData/codegen/box/reflection/call/inlineClasses/nonNullObject/contextParameters.kt"");
          }

          @Test
          @TestMetadata(""fieldAccessors.kt"")
          public void testFieldAccessors() {
            runTest(""compiler/testData/codegen/box/reflection/call/inlineClasses/nonNullObject/fieldAccessors.kt"");
          }

          @Test
          @TestMetadata(""functionsWithInlineClassParameters.kt"")
          public void testFunctionsWithInlineClassParameters() {
            runTest(""compiler/testData/codegen/box/reflection/call/inlineClasses/nonNullObject/functionsWithInlineClassParameters.kt"");
          }

          @Test
          @TestMetadata(""jvmStaticFieldInObject.kt"")
          public void testJvmStaticFieldInObject() {
            runTest(""compiler/testData/codegen/box/reflection/call/inlineClasses/nonNullObject/jvmStaticFieldInObject.kt"");
          }

          @Test
          @TestMetadata(""jvmStaticFunction.kt"")
          public void testJvmStaticFunction() {
            runTest(""compiler/testData/codegen/box/reflection/call/inlineClasses/nonNullObject/jvmStaticFunction.kt"");
          }

          @Test
          @TestMetadata(""nonOverridingFunOfInlineClass.kt"")
          public void testNonOverridingFunOfInlineClass() {
            runTest(""compiler/testData/codegen/box/reflection/call/inlineClasses/nonNullObject/nonOverridingFunOfInlineClass.kt"");
          }

          @Test
          @TestMetadata(""nonOverridingVarOfInlineClass.kt"")
          public void testNonOverridingVarOfInlineClass() {
            runTest(""compiler/testData/codegen/box/reflection/call/inlineClasses/nonNullObject/nonOverridingVarOfInlineClass.kt"");
          }

          @Test
          @TestMetadata(""overridingFunOfInlineClass.kt"")
          public void testOverridingFunOfInlineClass() {
            runTest(""compiler/testData/codegen/box/reflection/call/inlineClasses/nonNullObject/overridingFunOfInlineClass.kt"");
          }

          @Test
          @TestMetadata(""overridingVarOfInlineClass.kt"")
          public void testOverridingVarOfInlineClass() {
            runTest(""compiler/testData/codegen/box/reflection/call/inlineClasses/nonNullObject/overridingVarOfInlineClass.kt"");
          }

          @Test
          @TestMetadata(""properties.kt"")
          public void testProperties() {
            runTest(""compiler/testData/codegen/box/reflection/call/inlineClasses/nonNullObject/properties.kt"");
          }

          @Test
          @TestMetadata(""suspendFunction.kt"")
          public void testSuspendFunction() {
            runTest(""compiler/testData/codegen/box/reflection/call/inlineClasses/nonNullObject/suspendFunction.kt"");
          }
        }

        @Nested
        @TestMetadata(""compiler/testData/codegen/box/reflection/call/inlineClasses/nullableObject"")
        @TestDataPath(""$PROJECT_ROOT"")
        public class NullableObject {
          @Test
          public void testAllFilesPresentInNullableObject() {
            KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File(""compiler/testData/codegen/box/reflection/call/inlineClasses/nullableObject""), Pattern.compile(""^(.+)\\.kt$""), null, true);
          }

          @Test
          @TestMetadata(""constructorWithInlineClassParameters.kt"")
          public void testConstructorWithInlineClassParameters() {
            runTest(""compiler/testData/codegen/box/reflection/call/inlineClasses/nullableObject/constructorWithInlineClassParameters.kt"");
          }

          @Test
          @TestMetadata(""contextParameters.kt"")
          public void testContextParameters() {
            runTest(""compiler/testData/codegen/box/reflection/call/inlineClasses/nullableObject/contextParameters.kt"");
          }

          @Test
          @TestMetadata(""fieldAccessors.kt"")
          public void testFieldAccessors() {
            runTest(""compiler/testData/codegen/box/reflection/call/inlineClasses/nullableObject/fieldAccessors.kt"");
          }

          @Test
          @TestMetadata(""functionsWithInlineClassParameters.kt"")
          public void testFunctionsWithInlineClassParameters() {
            runTest(""compiler/testData/codegen/box/reflection/call/inlineClasses/nullableObject/functionsWithInlineClassParameters.kt"");
          }

          @Test
          @TestMetadata(""jvmStaticFieldInObject.kt"")
          public void testJvmStaticFieldInObject() {
            runTest(""compiler/testData/codegen/box/reflection/call/inlineClasses/nullableObject/jvmStaticFieldInObject.kt"");
          }

          @Test
          @TestMetadata(""jvmStaticFunction.kt"")
          public void testJvmStaticFunction() {
            runTest(""compiler/testData/codegen/box/reflection/call/inlineClasses/nullableObject/jvmStaticFunction.kt"");
          }

          @Test
          @TestMetadata(""nonOverridingFunOfInlineClass.kt"")
          public void testNonOverridingFunOfInlineClass() {
            runTest(""compiler/testData/codegen/box/reflection/call/inlineClasses/nullableObject/nonOverridingFunOfInlineClass.kt"");
          }

          @Test
          @TestMetadata(""nonOverridingVarOfInlineClass.kt"")
          public void testNonOverridingVarOfInlineClass() {
            runTest(""compiler/testData/codegen/box/reflection/call/inlineClasses/nullableObject/nonOverridingVarOfInlineClass.kt"");
          }

          @Test
          @TestMetadata(""overridingFunOfInlineClass.kt"")
          public void testOverridingFunOfInlineClass() {
            runTest(""compiler/testData/codegen/box/reflection/call/inlineClasses/nullableObject/overridingFunOfInlineClass.kt"");
          }

          @Test
          @TestMetadata(""overridingVarOfInlineClass.kt"")
          public void testOverridingVarOfInlineClass() {
            runTest(""compiler/testData/codegen/box/reflection/call/inlineClasses/nullableObject/overridingVarOfInlineClass.kt"");
          }

          @Test
          @TestMetadata(""properties.kt"")
          public void testProperties() {
            runTest(""compiler/testData/codegen/box/reflection/call/inlineClasses/nullableObject/properties.kt"");
          }

          @Test
          @TestMetadata(""suspendFunction.kt"")
          public void testSuspendFunction() {
            runTest(""compiler/testData/codegen/box/reflection/call/inlineClasses/nullableObject/suspendFunction.kt"");
          }
        }

        @Nested
        @TestMetadata(""compiler/testData/codegen/box/reflection/call/inlineClasses/primitive"")
        @TestDataPath(""$PROJECT_ROOT"")
        public class Primitive {
          @Test
          public void testAllFilesPresentInPrimitive() {
            KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File(""compiler/testData/codegen/box/reflection/call/inlineClasses/primitive""), Pattern.compile(""^(.+)\\.kt$""), null, true);
          }

          @Test
          @TestMetadata(""constructorWithInlineClassParameters.kt"")
          public void testConstructorWithInlineClassParameters() {
            runTest(""compiler/testData/codegen/box/reflection/call/inlineClasses/primitive/constructorWithInlineClassParameters.kt"");
          }

          @Test
          @TestMetadata(""contextParameters.kt"")
          public void testContextParameters() {
            runTest(""compiler/testData/codegen/box/reflection/call/inlineClasses/primitive/contextParameters.kt"");
          }

          @Test
          @TestMetadata(""fieldAccessors.kt"")
          public void testFieldAccessors() {
            runTest(""compiler/testData/codegen/box/reflection/call/inlineClasses/primitive/fieldAccessors.kt"");
          }

          @Test
          @TestMetadata(""functionsWithInlineClassParameters.kt"")
          public void testFunctionsWithInlineClassParameters() {
            runTest(""compiler/testData/codegen/box/reflection/call/inlineClasses/primitive/functionsWithInlineClassParameters.kt"");
          }

          @Test
          @TestMetadata(""jvmStaticFieldInObject.kt"")
          public void testJvmStaticFieldInObject() {
            runTest(""compiler/testData/codegen/box/reflection/call/inlineClasses/primitive/jvmStaticFieldInObject.kt"");
          }

          @Test
          @TestMetadata(""jvmStaticFunction.kt"")
          public void testJvmStaticFunction() {
            runTest(""compiler/testData/codegen/box/reflection/call/inlineClasses/primitive/jvmStaticFunction.kt"");
          }

          @Test
          @TestMetadata(""nonOverridingFunOfInlineClass.kt"")
          public void testNonOverridingFunOfInlineClass() {
            runTest(""compiler/testData/codegen/box/reflection/call/inlineClasses/primitive/nonOverridingFunOfInlineClass.kt"");
          }

          @Test
          @TestMetadata(""nonOverridingVarOfInlineClass.kt"")
          public void testNonOverridingVarOfInlineClass() {
            runTest(""compiler/testData/codegen/box/reflection/call/inlineClasses/primitive/nonOverridingVarOfInlineClass.kt"");
          }

          @Test
          @TestMetadata(""overridingFunOfInlineClass.kt"")
          public void testOverridingFunOfInlineClass() {
            runTest(""compiler/testData/codegen/box/reflection/call/inlineClasses/primitive/overridingFunOfInlineClass.kt"");
          }

          @Test
          @TestMetadata(""overridingVarOfInlineClass.kt"")
          public void testOverridingVarOfInlineClass() {
            runTest(""compiler/testData/codegen/box/reflection/call/inlineClasses/primitive/overridingVarOfInlineClass.kt"");
          }

          @Test
          @TestMetadata(""properties.kt"")
          public void testProperties() {
            runTest(""compiler/testData/codegen/box/reflection/call/inlineClasses/primitive/properties.kt"");
          }

          @Test
          @TestMetadata(""suspendFunction.kt"")
          public void testSuspendFunction() {
            runTest(""compiler/testData/codegen/box/reflection/call/inlineClasses/primitive/suspendFunction.kt"");
          }

          @Test
          @TestMetadata(""suspendFunctionGenericSubstitutedByPrimitive.kt"")
          public void testSuspendFunctionGenericSubstitutedByPrimitive() {
            runTest(""compiler/testData/codegen/box/reflection/call/inlineClasses/primitive/suspendFunctionGenericSubstitutedByPrimitive.kt"");
          }
        }
      }",KOT_01534,,,0
square__okhttp,c1d50e371fdee18382ac813e0ec4ce23e186c14c,samples/guide/src/main/java/okhttp3/recipes/kt/AccessHeaders.kt,.kt,Jesse Wilson,jwilson@squareup.com,2020-01-11T22:24:12-05:00,Upgrade Okio and some build dependencies,1,,"/*
 * Copyright (C) 2014 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package okhttp3.recipes.kt

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.Request

class AccessHeaders {
  private val client = OkHttpClient()

  fun run() {
    val request = Request.Builder()
        .url(""https://api.github.com/repos/square/okhttp/issues"")
        .header(""User-Agent"", ""OkHttp Headers.java"")
        .addHeader(""Accept"", ""application/json; q=0.5"")
        .addHeader(""Accept"", ""application/vnd.github.v3+json"")
        .build()

    client.newCall(request).execute().use { response ->
      if (!response.isSuccessful) throw IOException(""Unexpected code $response"")

      println(""Server: ${response.header(""Server"")}"")
      println(""Date: ${response.header(""Date"")}"")
      println(""Vary: ${response.headers(""Vary"")}"")
    }
  }
}

fun main() {
  AccessHeaders().run()
}
",KOT_04915,,,0
recloudstream__cloudstream,765071ebefe7a79b9c51638516bf0b39e7517c31,app/src/main/java/com/lagradost/cloudstream3/utils/SubtitleHelper.kt,.kt,CranberrySoup,142951702+CranberrySoup@users.noreply.github.com,2023-11-15T16:30:29+00:00,Fixed flag and name for Levantine Arabic and Najdi Arabic (#770),1,Language639,"    data class Language639(
        val languageName: String,
        val nativeName: String,
        val ISO_639_1: String,
        val ISO_639_2_T: String,
        val ISO_639_2_B: String,
        val ISO_639_3: String,
        val ISO_639_6: String,
    )

    /*fun createISO() {
        val url = ""https://infogalactic.com/info/List_of_ISO_639-1_codes""
        val response = get(url).text
        val document = Jsoup.parse(response)
        val headers = document.select(""table.wikitable > tbody > tr"")

        var text = ""listOf(\n""
        for (head in headers) {
            val tds = head.select(""td"")
            if (tds.size < 8) continue
            val name = tds[2].selectFirst(""> a"").text()
            val native = tds[3].text()
            val ISO_639_1 = tds[4].ownText().replace(""+"", """").replace("" "", """")
            val ISO_639_2_T = tds[5].ownText().replace(""+"", """").replace("" "", """")
            val ISO_639_2_B = tds[6].ownText().replace(""+"", """").replace("" "", """")
            val ISO_639_3 = tds[7].ownText().replace(""+"", """").replace("" "", """")
            val ISO_639_6 = tds[8].ownText().replace(""+"", """").replace("" "", """")

            val txtAdd =
                ""Language(\""$name\"", \""$native\"", \""$ISO_639_1\"", \""$ISO_639_2_T\"", \""$ISO_639_2_B\"", \""$ISO_639_3\"", \""$ISO_639_6\""),\n""
            text += txtAdd
        }
        text += "")""
        println(""ISO CREATED:\n$text"")
    }*/",KSEC_0610,,,0
JetBrains__kotlin,49150334d2026a8ae4eceaa4a876be33117706aa,libraries/tools/kotlin-gradle-plugin/src/common/kotlin/org/jetbrains/kotlin/gradle/internal/stdlibDependencyManagement.kt,.kt,Yahor Berdnikau,yahor.berdnikau@jetbrains.com,2025-05-06T21:41:32+02:00,[Gradle] Fix eager configurations realization by stdlib dependency management,1,,"/*
 * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.gradle.internal

import org.gradle.api.Project
import org.gradle.api.artifacts.Configuration
import org.gradle.api.artifacts.ConfigurationContainer
import org.gradle.api.artifacts.ExternalDependency
import org.gradle.api.artifacts.dsl.DependencyHandler
import org.gradle.api.provider.Provider
import org.jetbrains.kotlin.gradle.dsl.*
import org.jetbrains.kotlin.gradle.plugin.KotlinPlatformType
import org.jetbrains.kotlin.gradle.plugin.KotlinSourceSet
import org.jetbrains.kotlin.gradle.plugin.KotlinTarget
import org.jetbrains.kotlin.gradle.plugin.mpp.KotlinAndroidTarget
import org.jetbrains.kotlin.gradle.plugin.mpp.internal
import org.jetbrains.kotlin.gradle.plugin.mpp.isTest
import org.jetbrains.kotlin.gradle.plugin.sources.KotlinDependencyScope
import org.jetbrains.kotlin.gradle.plugin.sources.android.AndroidBaseSourceSetName
import org.jetbrains.kotlin.gradle.plugin.sources.android.AndroidVariantType
import org.jetbrains.kotlin.gradle.plugin.sources.android.androidSourceSetInfoOrNull
import org.jetbrains.kotlin.gradle.plugin.sources.sourceSetDependencyConfigurationByScope
import org.jetbrains.kotlin.gradle.plugin.statistics.KotlinStdlibConfigurationMetrics
import org.jetbrains.kotlin.gradle.targets.js.npm.SemVer
import org.jetbrains.kotlin.gradle.utils.forAllTargets

internal const val KOTLIN_STDLIB_COMMON_MODULE_NAME = ""kotlin-stdlib-common""
internal const val KOTLIN_STDLIB_MODULE_NAME = ""kotlin-stdlib""
internal const val KOTLIN_STDLIB_JDK7_MODULE_NAME = ""kotlin-stdlib-jdk7""
internal const val KOTLIN_STDLIB_JDK8_MODULE_NAME = ""kotlin-stdlib-jdk8""
internal const val KOTLIN_STDLIB_JS_MODULE_NAME = ""kotlin-stdlib-js""
internal const val KOTLIN_STDLIB_WASM_JS_MODULE_NAME = ""kotlin-stdlib-wasm-js""
internal const val KOTLIN_STDLIB_WASM_WASI_MODULE_NAME = ""kotlin-stdlib-wasm-wasi""
internal const val KOTLIN_ANDROID_JVM_STDLIB_MODULE_NAME = KOTLIN_STDLIB_MODULE_NAME

internal fun Project.configureStdlibDefaultDependency(
    kotlinExtension: KotlinProjectExtension,
    coreLibrariesVersion: Provider<String>,
) {
    kotlinExtension.forAllTargets { target ->
        target.addStdlibDependency(
            configurations,
            dependencies,
            coreLibrariesVersion,
            isMppProject = kotlinExtension is KotlinMultiplatformExtension,
        )
    }
}

/**
 * Aligning kotlin-stdlib-jdk8 and kotlin-stdlib-jdk7 dependencies versions with kotlin-stdlib (or kotlin-stdlib-jdk7)
 * when project stdlib version is >= 1.8.0
 */
internal fun ConfigurationContainer.configureStdlibVersionAlignment() = all { configuration ->
    configuration.withDependencies { dependencySet ->
        dependencySet
            .filterIsInstance<ExternalDependency>()
            .forEach { dependency ->
                if (dependency.group == KOTLIN_MODULE_GROUP &&
                    (dependency.name == KOTLIN_STDLIB_MODULE_NAME || dependency.name == KOTLIN_STDLIB_JDK7_MODULE_NAME) &&
                    dependency.version != null &&
                    SemVer.fromGradleRichVersion(dependency.version!!).let { it >= kotlin180Version && it < kotlin1920Version }
                ) {
                    if (configuration.isCanBeResolved) configuration.alignStdlibJvmVariantVersions(dependency)

                    // dependency substitution only works for resolvable configuration,
                    // so we need to find all configuration that extends current one
                    filter {
                        it.isCanBeResolved && it.hierarchy.contains(configuration)
                    }.forEach {
                        it.alignStdlibJvmVariantVersions(dependency)
                    }
                }
            }
    }
}

private fun Configuration.alignStdlibJvmVariantVersions(
    kotlinStdlibDependency: ExternalDependency,
) {
    resolutionStrategy.dependencySubstitution {
        if (kotlinStdlibDependency.name != KOTLIN_STDLIB_JDK7_MODULE_NAME) {
            it.substitute(it.module(""org.jetbrains.kotlin:kotlin-stdlib-jdk7""))
                .using(it.module(""org.jetbrains.kotlin:kotlin-stdlib-jdk7:${kotlinStdlibDependency.version}""))
                .because(""kotlin-stdlib-jdk7 is now part of kotlin-stdlib"")
        }

        it.substitute(it.module(""org.jetbrains.kotlin:kotlin-stdlib-jdk8""))
            .using(it.module(""org.jetbrains.kotlin:kotlin-stdlib-jdk8:${kotlinStdlibDependency.version}""))
            .because(""kotlin-stdlib-jdk8 is now part of kotlin-stdlib"")
    }
}

private fun KotlinTarget.addStdlibDependency(
    configurations: ConfigurationContainer,
    dependencies: DependencyHandler,
    coreLibrariesVersion: Provider<String>,
    isMppProject: Boolean,
) {
    compilations.configureEach { compilation ->
        compilation.internal.kotlinSourceSets.forAll { kotlinSourceSet ->
            val scope = if (compilation.isTest() ||
                (this is KotlinAndroidTarget && kotlinSourceSet.isRelatedToAndroidTestSourceSet())
            ) {
                KotlinDependencyScope.IMPLEMENTATION_SCOPE
            } else {
                KotlinDependencyScope.API_SCOPE
            }
            val scopeConfiguration = configurations
                .sourceSetDependencyConfigurationByScope(kotlinSourceSet, scope)

            scopeConfiguration.withDependencies { dependencySet ->
                // Check if stdlib is directly added to SourceSet
                /*
                In case of 'kotlin-stdlib-common being added: Ensure that stdlib is added also
                This will help with substituting kotlin-stdlib-common with kotlin-stdlib:
                Currently transformed metadata dependencies will not recognise the substitution otherwise.
                */
                if (isStdlibAddedByUser(configurations, stdlibModules - KOTLIN_STDLIB_COMMON_MODULE_NAME, kotlinSourceSet))
                    return@withDependencies

                val requestedStdlibVersion = coreLibrariesVersion.get()
                val stdlibVersion = SemVer.fromGradleRichVersion(requestedStdlibVersion)

                // Since 1.9.20 in MPP projects, we should add stdlib only for common dependencies
                // except standalone compilations which as not using 'common'
                if (isMppProject &&
                    stdlibVersion >= kotlin1920Version &&
                    kotlinSourceSet.dependsOn.isNotEmpty()
                ) return@withDependencies

                val stdlibModule = compilation.platformType.stdlibPlatformType(this, kotlinSourceSet, stdlibVersion >= kotlin1920Version)
                    ?: return@withDependencies

                KotlinStdlibConfigurationMetrics.collectMetrics(project, requestedStdlibVersion)

                dependencySet.addLater(
                    coreLibrariesVersion.map {
                        dependencies.kotlinDependency(stdlibModule, it)
                    }
                )
            }
        }
    }
}

internal fun isStdlibAddedByUser(
    configurations: ConfigurationContainer,
    stdlibModules: Set<String>,
    vararg sourceSets: KotlinSourceSet,
): Boolean {
    return sourceSets
        .asSequence()
        .flatMap { sourceSet ->
            KotlinDependencyScope.values().map { scope ->
                configurations.sourceSetDependencyConfigurationByScope(sourceSet, scope)
            }.asSequence()
        }
        .flatMap { it.allNonProjectDependencies().asSequence() }
        .any { dependency ->
            dependency.group == KOTLIN_MODULE_GROUP && dependency.name in stdlibModules
        }
}

internal fun KotlinPlatformType.stdlibPlatformType(
    kotlinTarget: KotlinTarget,
    kotlinSourceSet: KotlinSourceSet,
    isVersionWithGradleMetadata: Boolean,
): String? = when (this) {
    KotlinPlatformType.jvm -> if (isVersionWithGradleMetadata) KOTLIN_STDLIB_MODULE_NAME else KOTLIN_STDLIB_JDK8_MODULE_NAME
    KotlinPlatformType.androidJvm -> {
        if (kotlinTarget is KotlinAndroidTarget &&
            kotlinSourceSet.androidSourceSetInfoOrNull?.androidSourceSetName == AndroidBaseSourceSetName.Main.name
        ) {
            if (isVersionWithGradleMetadata) KOTLIN_ANDROID_JVM_STDLIB_MODULE_NAME else KOTLIN_STDLIB_JDK8_MODULE_NAME
        } else {
            null
        }
    }

    KotlinPlatformType.js -> if (isVersionWithGradleMetadata) KOTLIN_STDLIB_MODULE_NAME else KOTLIN_STDLIB_JS_MODULE_NAME
    KotlinPlatformType.wasm -> KOTLIN_STDLIB_MODULE_NAME
    KotlinPlatformType.native -> null
    KotlinPlatformType.common -> // there's no platform compilation that the source set is default for
        if (isVersionWithGradleMetadata) KOTLIN_STDLIB_MODULE_NAME else KOTLIN_STDLIB_COMMON_MODULE_NAME
}

private val androidTestVariants = setOf(AndroidVariantType.UnitTest, AndroidVariantType.InstrumentedTest)

private val kotlin180Version = SemVer(1.toBigInteger(), 8.toBigInteger(), 0.toBigInteger())
private val kotlin1920Version = SemVer(1.toBigInteger(), 9.toBigInteger(), 20.toBigInteger())

private fun KotlinSourceSet.isRelatedToAndroidTestSourceSet(): Boolean {
    val androidVariant = androidSourceSetInfoOrNull?.androidVariantType ?: return false
    return androidVariant in androidTestVariants
}

internal val stdlibModules = setOf(
    KOTLIN_STDLIB_COMMON_MODULE_NAME,
    KOTLIN_STDLIB_MODULE_NAME,
    KOTLIN_STDLIB_JDK7_MODULE_NAME,
    KOTLIN_STDLIB_JDK8_MODULE_NAME,
    KOTLIN_STDLIB_JS_MODULE_NAME,
)
",KOT_05519,CWE-321: Hard-coded Cryptographic Key,A02: Cryptographic Failures;A04: Insecure Design,1
JetBrains__kotlin,70892f856460df5f0053927794f105405369ae9c,compiler/fir/tree/src/org/jetbrains/kotlin/fir/visitors/FirDefaultTransformer.kt,.kt,Roman Venediktov,roman.venediktov@jetbrains.com,2025-06-17T11:22:07+02:00,Fixed or suppressed most exceptions.,1,FirDefaultTransformer,"abstract class FirDefaultTransformer<D> : FirTransformer<D>() {
    override fun transformImplicitTypeRef(implicitTypeRef: FirImplicitTypeRef, data: D): FirTypeRef {
        return transformTypeRef(implicitTypeRef, data)
    }

    override fun transformResolvedTypeRef(resolvedTypeRef: FirResolvedTypeRef, data: D): FirTypeRef {
        return transformTypeRef(resolvedTypeRef, data)
    }

    override fun transformErrorTypeRef(errorTypeRef: FirErrorTypeRef, data: D): FirTypeRef {
        return transformResolvedTypeRef(errorTypeRef, data)
    }

    override fun transformUnresolvedTypeRef(unresolvedTypeRef: FirUnresolvedTypeRef, data: D): FirTypeRef {
        return transformTypeRef(unresolvedTypeRef, data)
    }

    override fun transformDynamicTypeRef(dynamicTypeRef: FirDynamicTypeRef, data: D): FirTypeRef {
        return transformUnresolvedTypeRef(dynamicTypeRef, data)
    }

    override fun transformFunctionTypeRef(functionTypeRef: FirFunctionTypeRef, data: D): FirTypeRef {
        return transformUnresolvedTypeRef(functionTypeRef, data)
    }

    override fun transformUserTypeRef(userTypeRef: FirUserTypeRef, data: D): FirTypeRef {
        return transformUnresolvedTypeRef(userTypeRef, data)
    }

    override fun transformUnionTypeRef(unionTypeRef: FirUnionTypeRef, data: D): FirTypeRef {
        return transformUnresolvedTypeRef(unionTypeRef, data)
    }

    override fun transformIntersectionTypeRef(intersectionTypeRef: FirIntersectionTypeRef, data: D): FirTypeRef {
        return transformTypeRef(intersectionTypeRef, data)
    }

    override fun transformCallableReferenceAccess(
        callableReferenceAccess: FirCallableReferenceAccess,
        data: D
    ): FirStatement {
        return transformQualifiedAccessExpression(callableReferenceAccess, data)
    }

    override fun transformComponentCall(componentCall: FirComponentCall, data: D): FirStatement {
        return transformFunctionCall(componentCall, data)
    }

    override fun transformReturnExpression(returnExpression: FirReturnExpression, data: D): FirStatement {
        return transformJump(returnExpression, data)
    }

    override fun transformContinueExpression(continueExpression: FirContinueExpression, data: D): FirStatement {
        return transformJump(continueExpression, data)
    }

    override fun transformBreakExpression(breakExpression: FirBreakExpression, data: D): FirStatement {
        return transformJump(breakExpression, data)
    }

    override fun transformSpreadArgumentExpression(spreadArgumentExpression: FirSpreadArgumentExpression, data: D): FirStatement {
        return transformWrappedArgumentExpression(spreadArgumentExpression, data)
    }

    override fun transformNamedArgumentExpression(namedArgumentExpression: FirNamedArgumentExpression, data: D): FirStatement {
        return transformWrappedArgumentExpression(namedArgumentExpression, data)
    }

    override fun transformErrorExpression(errorExpression: FirErrorExpression, data: D): FirStatement {
        return transformExpression(errorExpression, data)
    }

    override fun transformErrorLoop(errorLoop: FirErrorLoop, data: D): FirStatement {
        return transformLoop(errorLoop, data)
    }

    override fun transformErrorNamedReference(errorNamedReference: FirErrorNamedReference, data: D): FirReference {
        return transformNamedReference(errorNamedReference, data)
    }

    override fun transformErrorFunction(errorFunction: FirErrorFunction, data: D): FirStatement {
        return transformFunction(errorFunction, data)
    }

    override fun transformErrorResolvedQualifier(
        errorResolvedQualifier: FirErrorResolvedQualifier,
        data: D
    ): FirStatement {
        return transformResolvedQualifier(errorResolvedQualifier, data)
    }

    override fun transformImplicitInvokeCall(implicitInvokeCall: FirImplicitInvokeCall, data: D): FirStatement {
        return transformFunctionCall(implicitInvokeCall, data)
    }

    override fun transformConstructedClassTypeParameterRef(constructedClassTypeParameterRef: FirConstructedClassTypeParameterRef, data: D): FirTypeParameterRef {
        return transformTypeParameterRef(constructedClassTypeParameterRef, data)
    }

    override fun transformOuterClassTypeParameterRef(outerClassTypeParameterRef: FirOuterClassTypeParameterRef, data: D): FirTypeParameterRef {
        return transformTypeParameterRef(outerClassTypeParameterRef, data)
    }
}",KOT_03277,,,0
thunderbird__thunderbird-android,4ca78c9ebc94cb746d9fcac0564353e56302bd9e,legacy/core/src/main/java/com/fsck/k9/notification/NotificationSettingsUpdater.kt,.kt,Wolf-Martell Montwé,wolf@thunderbird.net,2025-09-08T15:18:57+02:00,refactor: rename LegacyAccount to LegacyAccountDto,1,,"package com.fsck.k9.notification

import android.os.Build
import androidx.annotation.RequiresApi
import com.fsck.k9.Preferences
import net.thunderbird.core.android.account.LegacyAccountDto

/**
 * Update accounts with notification settings read from their ""Messages"" `NotificationChannel`.
 */
class NotificationSettingsUpdater(
    private val preferences: Preferences,
    private val notificationChannelManager: NotificationChannelManager,
    private val notificationConfigurationConverter: NotificationConfigurationConverter,
) {
    fun updateNotificationSettings(accountUuids: Collection<String>) {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) return

        accountUuids
            .mapNotNull { accountUuid -> preferences.getAccount(accountUuid) }
            .forEach { account ->
                updateNotificationSettings(account)
                preferences.saveAccount(account)
            }
    }

    @RequiresApi(Build.VERSION_CODES.O)
    fun updateNotificationSettings(account: LegacyAccountDto) {
        val notificationConfiguration = notificationChannelManager.getNotificationConfiguration(account)
        val notificationSettings = notificationConfigurationConverter.convert(account, notificationConfiguration)

        if (notificationSettings != account.notificationSettings) {
            account.updateNotificationSettings { notificationSettings }
        }
    }
}
",KSEC_1323,,,0
bitwarden__android,ebdf5f816a27041906b08a9b7421449f82a9cb88,app/src/test/java/com/x8bit/bitwarden/data/auth/manager/util/AuthRequestTypeExtensionsTest.kt,.kt,Patrick Honkonen,1883101+SaintPatrck@users.noreply.github.com,2025-04-03T17:33:32-04:00,[PM-19854] Migrate AuthenticatedAuthRequestsApi to network module (#4984),1,,"package com.x8bit.bitwarden.data.auth.manager.util

import com.bitwarden.network.model.AuthRequestTypeJson
import com.x8bit.bitwarden.data.auth.manager.model.AuthRequestType
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Test

class AuthRequestTypeExtensionsTest {
    @Test
    fun `isSso should return the correct value for each type`() {
        mapOf(
            AuthRequestType.OTHER_DEVICE to false,
            AuthRequestType.SSO_OTHER_DEVICE to true,
            AuthRequestType.SSO_ADMIN_APPROVAL to true,
        )
            .forEach { (type, expected) ->
                assertEquals(expected, type.isSso)
            }
    }

    @Test
    fun `toAuthRequestTypeJson should return the correct value for each type`() {
        mapOf(
            AuthRequestType.OTHER_DEVICE to AuthRequestTypeJson.LOGIN_WITH_DEVICE,
            AuthRequestType.SSO_OTHER_DEVICE to AuthRequestTypeJson.LOGIN_WITH_DEVICE,
            AuthRequestType.SSO_ADMIN_APPROVAL to AuthRequestTypeJson.ADMIN_APPROVAL,
        )
            .forEach { (type, expected) ->
                assertEquals(expected, type.toAuthRequestTypeJson())
            }
    }
}
",KSEC_0366,,,0
JetBrains__kotlin,8e32194e209615c3a5f67f0aa9f6984a26cbf95d,js/js.tests/tests-gen/org/jetbrains/kotlin/js/test/fir/JsCodegenBoxTestGenerated.java,.java,Alexander Udalov,alexander.udalov@jetbrains.com,2025-10-24T10:01:10+02:00,Reflection: fix javaType for local delegated property accessors,1,LocalDelegated,"      public class LocalDelegated {
        @Test
        public void testAllFilesPresentInLocalDelegated() {
          KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File(""compiler/testData/codegen/box/reflection/properties/localDelegated""), Pattern.compile(""^(.+)\\.kt$""), null, true);
        }

        @Test
        @TestMetadata(""annotations.kt"")
        public void testAnnotations() {
          runTest(""compiler/testData/codegen/box/reflection/properties/localDelegated/annotations.kt"");
        }

        @Test
        @TestMetadata(""equals.kt"")
        public void testEquals() {
          runTest(""compiler/testData/codegen/box/reflection/properties/localDelegated/equals.kt"");
        }

        @Test
        @TestMetadata(""inInterface.kt"")
        public void testInInterface() {
          runTest(""compiler/testData/codegen/box/reflection/properties/localDelegated/inInterface.kt"");
        }

        @Test
        @TestMetadata(""inInterfaceDefaultImpls.kt"")
        public void testInInterfaceDefaultImpls() {
          runTest(""compiler/testData/codegen/box/reflection/properties/localDelegated/inInterfaceDefaultImpls.kt"");
        }

        @Test
        @TestMetadata(""inLambda.kt"")
        public void testInLambda() {
          runTest(""compiler/testData/codegen/box/reflection/properties/localDelegated/inLambda.kt"");
        }

        @Test
        @TestMetadata(""inLambdaInInline.kt"")
        public void testInLambdaInInline() {
          runTest(""compiler/testData/codegen/box/reflection/properties/localDelegated/inLambdaInInline.kt"");
        }

        @Test
        @TestMetadata(""inlineFun.kt"")
        public void testInlineFun() {
          runTest(""compiler/testData/codegen/box/reflection/properties/localDelegated/inlineFun.kt"");
        }

        @Test
        @TestMetadata(""javaType.kt"")
        public void testJavaType() {
          runTest(""compiler/testData/codegen/box/reflection/properties/localDelegated/javaType.kt"");
        }

        @Test
        @TestMetadata(""localAndNonLocal.kt"")
        public void testLocalAndNonLocal() {
          runTest(""compiler/testData/codegen/box/reflection/properties/localDelegated/localAndNonLocal.kt"");
        }

        @Test
        @TestMetadata(""localDelegatedProperty.kt"")
        public void testLocalDelegatedProperty() {
          runTest(""compiler/testData/codegen/box/reflection/properties/localDelegated/localDelegatedProperty.kt"");
        }

        @Test
        @TestMetadata(""multiFileClass.kt"")
        public void testMultiFileClass() {
          runTest(""compiler/testData/codegen/box/reflection/properties/localDelegated/multiFileClass.kt"");
        }

        @Test
        @TestMetadata(""unusedGenericType.kt"")
        public void testUnusedGenericType() {
          runTest(""compiler/testData/codegen/box/reflection/properties/localDelegated/unusedGenericType.kt"");
        }

        @Test
        @TestMetadata(""variableOfGenericType.kt"")
        public void testVariableOfGenericType() {
          runTest(""compiler/testData/codegen/box/reflection/properties/localDelegated/variableOfGenericType.kt"");
        }
      }",KOT_01368,,,0
duckduckgo__Android,9b602933431196513b34376b4dc9cf605c86c123,app/src/androidTest/java/com/duckduckgo/app/email/AppEmailManagerTest.kt,.kt,Craig Russell,CDRussell@users.noreply.github.com,2021-12-24T11:26:59+00:00,"Upgrade to Mockito 4, sort out test config problems (#1640)",1,,"/*
 * Copyright (c) 2020 DuckDuckGo
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.duckduckgo.app.email

import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import com.duckduckgo.app.CoroutineTestRule
import com.duckduckgo.app.email.AppEmailManager.Companion.DUCK_EMAIL_DOMAIN
import com.duckduckgo.app.email.AppEmailManager.Companion.UNKNOWN_COHORT
import com.duckduckgo.app.email.AppEmailManager.WaitlistState.InBeta
import com.duckduckgo.app.email.AppEmailManager.WaitlistState.JoinedQueue
import com.duckduckgo.app.email.AppEmailManager.WaitlistState.NotJoinedQueue
import com.duckduckgo.app.email.api.EmailAlias
import com.duckduckgo.app.email.api.EmailInviteCodeResponse
import com.duckduckgo.app.email.api.EmailService
import com.duckduckgo.app.email.api.WaitlistResponse
import com.duckduckgo.app.email.api.WaitlistStatusResponse
import com.duckduckgo.app.email.db.EmailDataStore
import com.nhaarman.mockitokotlin2.any
import com.nhaarman.mockitokotlin2.mock
import com.nhaarman.mockitokotlin2.never
import com.nhaarman.mockitokotlin2.verify
import com.nhaarman.mockitokotlin2.whenever
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.FlowPreview
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.test.TestScope
import kotlinx.coroutines.test.runTest
import org.junit.Assert.assertEquals
import org.junit.Assert.assertFalse
import org.junit.Assert.assertNull
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Rule
import org.junit.Test

@FlowPreview
@ExperimentalCoroutinesApi
class AppEmailManagerTest {

    @get:Rule
    var coroutineRule = CoroutineTestRule()

    @get:Rule
    var instantTaskExecutorRule = InstantTaskExecutorRule()

    private val mockEmailService: EmailService = mock()
    private val mockEmailDataStore: EmailDataStore = FakeEmailDataStore()
    lateinit var testee: AppEmailManager

    @Before
    fun setup() {
        testee = AppEmailManager(mockEmailService, mockEmailDataStore, coroutineRule.testDispatcherProvider, TestScope())
    }

    @Test
    fun whenFetchAliasFromServiceThenStoreAliasAddingDuckDomain() = runTest {
        mockEmailDataStore.emailToken = ""token""
        whenever(mockEmailService.newAlias(any())).thenReturn(EmailAlias(""test""))
        testee.getAlias()

        assertEquals(""test$DUCK_EMAIL_DOMAIN"", mockEmailDataStore.nextAlias)
    }

    @Test
    fun whenFetchAliasFromServiceAndTokenDoesNotExistThenDoNothing() = runTest {
        mockEmailDataStore.emailToken = null
        testee.getAlias()

        verify(mockEmailService, never()).newAlias(any())
    }

    @Test
    fun whenFetchAliasFromServiceAndAddressIsBlankThenStoreNull() = runTest {
        mockEmailDataStore.emailToken = ""token""
        whenever(mockEmailService.newAlias(any())).thenReturn(EmailAlias(""""))
        testee.getAlias()

        assertNull(mockEmailDataStore.nextAlias)
    }

    @Test
    fun whenGetAliasThenReturnNextAlias() = runTest {
        givenNextAliasExists()

        assertEquals(""alias"", testee.getAlias())
    }

    @Test
    fun whenGetAliasIfNextAliasDoesNotExistThenReturnNull() {
        assertNull(testee.getAlias())
    }

    @Test
    fun whenGetAliasThenClearNextAlias() {
        testee.getAlias()

        assertNull(mockEmailDataStore.nextAlias)
    }

    @Test
    fun whenIsSignedInAndTokenDoesNotExistThenReturnFalse() {
        mockEmailDataStore.emailUsername = ""username""
        mockEmailDataStore.nextAlias = ""alias""

        assertFalse(testee.isSignedIn())
    }

    @Test
    fun whenIsSignedInAndUsernameDoesNotExistThenReturnFalse() {
        mockEmailDataStore.emailToken = ""token""
        mockEmailDataStore.nextAlias = ""alias""

        assertFalse(testee.isSignedIn())
    }

    @Test
    fun whenIsSignedInAndTokenAndUsernameExistThenReturnTrue() {
        mockEmailDataStore.emailToken = ""token""
        mockEmailDataStore.emailUsername = ""username""

        assertTrue(testee.isSignedIn())
    }

    @Test
    fun whenStoreCredentialsThenGenerateNewAlias() = runTest {
        mockEmailDataStore.emailToken = ""token""
        whenever(mockEmailService.newAlias(any())).thenReturn(EmailAlias(""""))

        testee.storeCredentials(""token"", ""username"", ""cohort"")

        verify(mockEmailService).newAlias(any())
    }

    @Test
    fun whenStoreCredentialsThenCredentialsAreStoredInDataStore() {
        testee.storeCredentials(""token"", ""username"", ""cohort"")

        assertEquals(""username"", mockEmailDataStore.emailUsername)
        assertEquals(""token"", mockEmailDataStore.emailToken)
        assertEquals(""cohort"", mockEmailDataStore.cohort)
    }

    @Test
    fun whenStoreCredentialsIfCredentialsWereCorrectlyStoredThenIsSignedInChannelSendsTrue() = runTest {
        testee.storeCredentials(""token"", ""username"", ""cohort"")

        assertTrue(testee.signedInFlow().first())
    }

    @Test
    fun whenStoreCredentialsIfCredentialsAreBlankThenIsSignedInChannelSendsFalse() = runTest {
        testee.storeCredentials("""", """", ""cohort"")

        assertFalse(testee.signedInFlow().first())
    }

    @Test
    fun whenSignedOutThenClearEmailDataAndAliasIsNull() {
        testee.signOut()

        assertNull(mockEmailDataStore.emailUsername)
        assertNull(mockEmailDataStore.emailToken)
        assertNull(mockEmailDataStore.nextAlias)

        assertNull(testee.getAlias())
    }

    @Test
    fun whenSignedOutThenIsSignedInChannelSendsFalse() = runTest {
        testee.signOut()

        assertFalse(testee.signedInFlow().first())
    }

    @Test
    fun whenGetEmailAddressThenDuckEmailDomainIsAppended() {
        mockEmailDataStore.emailUsername = ""username""

        assertEquals(""username$DUCK_EMAIL_DOMAIN"", testee.getEmailAddress())
    }

    @Test
    fun whenWaitlistStateIfTimestampExistsCodeDoesNotExistAndSendNotificationIsTrueThenReturnJoinedQueueWithTrue() {
        mockEmailDataStore.waitlistTimestamp = 1234
        mockEmailDataStore.sendNotification = true

        assertEquals(JoinedQueue(true), testee.waitlistState())
    }

    @Test
    fun whenWaitlistStateIfTimestampExistsCodeDoesNotExistAndSendNotificationIsFalseThenReturnJoinedQueueWithFalse() {
        mockEmailDataStore.waitlistTimestamp = 1234
        mockEmailDataStore.sendNotification = false

        assertEquals(JoinedQueue(false), testee.waitlistState())
    }

    @Test
    fun whenWaitlistStateIfTimestampExistsAndCodeExistsThenReturnInBeta() {
        mockEmailDataStore.waitlistTimestamp = 1234
        mockEmailDataStore.inviteCode = ""abcde""

        assertEquals(InBeta, testee.waitlistState())
    }

    @Test
    fun whenWaitlistStateIfTimestampAndCodeDoesNotExistThenReturnNotJoinedQueue() {
        mockEmailDataStore.waitlistTimestamp = -1
        mockEmailDataStore.waitlistToken = null

        assertEquals(NotJoinedQueue, testee.waitlistState())
    }

    @Test
    fun whenJoinWaitlistIfTimestampAndTokenDidNotExistThenStoreTimestampAndToken() {
        mockEmailDataStore.waitlistTimestamp = -1
        mockEmailDataStore.waitlistToken = null

        testee.joinWaitlist(1234, ""abcde"")

        assertEquals(1234, mockEmailDataStore.waitlistTimestamp)
        assertEquals(""abcde"", mockEmailDataStore.waitlistToken)
    }
    @Test
    fun whenJoinWaitlistIfTimestampAndTokenDidExistThenStoreTimestampAndTokenAreNotStored() {
        mockEmailDataStore.waitlistTimestamp = 1234
        mockEmailDataStore.waitlistToken = ""abcde""

        testee.joinWaitlist(4321, ""edcba"")

        assertEquals(1234, mockEmailDataStore.waitlistTimestamp)
        assertEquals(""abcde"", mockEmailDataStore.waitlistToken)
    }

    @Test
    fun whenGetInviteCodeIfCodeExistsThenReturnCode() {
        mockEmailDataStore.inviteCode = ""abcde""
        assertEquals(""abcde"", testee.getInviteCode())
    }

    @Test
    fun whenGetInviteCodeIfCodeDoesNotExistThenReturnEmpty() {
        mockEmailDataStore.inviteCode = null
        assertEquals("""", testee.getInviteCode())
    }

    @Test
    fun whenDoesCodeAlreadyExistIfCodeExistsThenReturnTrue() {
        mockEmailDataStore.inviteCode = ""inviteCode""

        assertTrue(testee.doesCodeAlreadyExist())
    }

    @Test
    fun whenDoesCodeAlreadyExistIfCodeIsNullThenReturnFalse() {
        mockEmailDataStore.inviteCode = null

        assertFalse(testee.doesCodeAlreadyExist())
    }

    @Test
    fun whenFetchInviteCodeIfCodeAlreadyExistsThenReturnCodeExisted() = runTest {
        mockEmailDataStore.inviteCode = ""inviteCode""

        assertEquals(AppEmailManager.FetchCodeResult.CodeExisted, testee.fetchInviteCode())
    }

    @Test
    fun whenFetchInviteCodeIfTimestampIsSmallerThanQueueTimestampThenCallGetCode() = runTest {
        givenUserIsInWaitlist()
        whenever(mockEmailService.waitlistStatus()).thenReturn(WaitlistStatusResponse(12345))

        testee.fetchInviteCode()

        verify(mockEmailService).getCode(""token"")
    }

    @Test
    fun whenFetchInviteCodeIfTimestampIsEqualsThanQueueTimestampThenCallGetCode() = runTest {
        givenUserIsInWaitlist()
        whenever(mockEmailService.waitlistStatus()).thenReturn(WaitlistStatusResponse(1234))

        testee.fetchInviteCode()

        verify(mockEmailService).getCode(""token"")
    }

    @Test
    fun whenFetchInviteCodeIfUserIsTopOfQueueAndCodeAvailableThenReturnCode() = runTest {
        givenUserIsTopOfTheQueue()
        whenever(mockEmailService.getCode(any())).thenReturn(EmailInviteCodeResponse(""code""))

        assertEquals(AppEmailManager.FetchCodeResult.Code, testee.fetchInviteCode())
    }

    @Test
    fun whenFetchInviteCodeIfUserIsTopOfQueueAndCodeNotAvailableThenReturnNoCode() = runTest {
        givenUserIsTopOfTheQueue()
        whenever(mockEmailService.getCode(any())).thenReturn(EmailInviteCodeResponse(""""))

        assertEquals(AppEmailManager.FetchCodeResult.NoCode, testee.fetchInviteCode())
    }

    @Test
    fun whenFetchInviteCodeIfUserIsTopOfQueueAndCodeServiceNotAvailableThenReturnNoCode() = runTest {
        testee = AppEmailManager(TestEmailService(), mockEmailDataStore, coroutineRule.testDispatcherProvider, TestScope())
        givenUserIsTopOfTheQueue()

        assertEquals(AppEmailManager.FetchCodeResult.NoCode, testee.fetchInviteCode())
    }

    @Test
    fun whenFetchInviteCodeIfUserInTheQueueAndStatusServiceNotAvailableThenReturnNoCode() = runTest {
        testee = AppEmailManager(TestEmailService(), mockEmailDataStore, coroutineRule.testDispatcherProvider, TestScope())
        givenUserIsInWaitlist()

        assertEquals(AppEmailManager.FetchCodeResult.NoCode, testee.fetchInviteCode())
    }

    @Test
    fun whenNotifyOnJoinedWaitlistThenSendNotificationSetToTrue() {
        mockEmailDataStore.sendNotification = false
        testee.notifyOnJoinedWaitlist()
        assertTrue(mockEmailDataStore.sendNotification)
    }

    @Test
    fun whenGetCohortThenReturnCohort() {
        mockEmailDataStore.cohort = ""cohort""

        assertEquals(""cohort"", testee.getCohort())
    }

    @Test
    fun whenGetCohortIfCohortIsNullThenReturnUnknown() {
        mockEmailDataStore.cohort = null

        assertEquals(UNKNOWN_COHORT, testee.getCohort())
    }

    @Test
    fun whenGetCohortIfCohortIsEmtpyThenReturnUnknown() {
        mockEmailDataStore.cohort = """"

        assertEquals(UNKNOWN_COHORT, testee.getCohort())
    }

    @Test
    fun whenIsEmailFeatureSupportedAndEncryptionCanBeUsedThenReturnTrue() {
        (mockEmailDataStore as FakeEmailDataStore).canUseEncryption = true

        assertTrue(testee.isEmailFeatureSupported())
    }

    @Test
    fun whenGetLastUsedDateIfNullThenReturnEmpty() {
        assertEquals("""", testee.getLastUsedDate())
    }

    @Test
    fun whenGetLastUsedDateIfNotNullThenReturnValueFromStore() {
        mockEmailDataStore.lastUsedDate = ""2021-01-01""
        assertEquals(""2021-01-01"", testee.getLastUsedDate())
    }

    @Test
    fun whenIsEmailFeatureSupportedAndEncryptionCannotBeUsedThenReturnFalse() {
        (mockEmailDataStore as FakeEmailDataStore).canUseEncryption = false

        assertFalse(testee.isEmailFeatureSupported())
    }

    private fun givenUserIsInWaitlist() {
        mockEmailDataStore.waitlistTimestamp = 1234
        mockEmailDataStore.waitlistToken = ""token""
    }

    private fun givenUserIsTopOfTheQueue() = runTest {
        givenUserIsInWaitlist()
        whenever(mockEmailService.waitlistStatus()).thenReturn(WaitlistStatusResponse(1234))
    }

    private fun givenNextAliasExists() {
//        cachedAlias.set(""alias"")
        mockEmailDataStore.nextAlias = ""alias""
    }

    class TestEmailService : EmailService {
        override suspend fun newAlias(authorization: String): EmailAlias = EmailAlias(""alias"")
        override suspend fun joinWaitlist(): WaitlistResponse = WaitlistResponse(""token"", 12345)
        override suspend fun waitlistStatus(): WaitlistStatusResponse {
            throw Exception()
        }
        override suspend fun getCode(token: String): EmailInviteCodeResponse {
            throw Exception()
        }
    }
}

class FakeEmailDataStore : EmailDataStore {
    override var emailToken: String? = null
    override var nextAlias: String? = null
    override var emailUsername: String? = null
    override var inviteCode: String? = null
    override var waitlistTimestamp: Int = 0
    override var waitlistToken: String? = null
    override var sendNotification: Boolean = false
    override var cohort: String? = null
    override var lastUsedDate: String? = null

    var canUseEncryption: Boolean = false
    override fun canUseEncryption(): Boolean = canUseEncryption

}
",KSEC_5569,['CWE-321: Hard-coded Cryptographic Key'],"['A02: Cryptographic Failures', 'A04: Insecure Design']",1
JetBrains__kotlin,7f11a85dcd6c08c98a5668042c3083e60b009fca,compiler/testData/klib/syntheticAccessors/topLevelPrivate/crossFilePrivateLeak/leakingPrivateExtensionVarThroughPrivateInlineVarChain.kt,.kt,Ivan Kylchik,ivan.kylchik@jetbrains.com,2025-10-07T09:58:41+02:00,[Inline] Apply a patch to ignore broken preprocessed funs in klib,1,,"// IGNORE_KLIB_SYNTHETIC_ACCESSORS_CHECKS: JS_IR
// FILE: A.kt
class A


// FILE: B.kt
private var _privateVar = 12
private var A.privateVar: Int
    get() = _privateVar
    set(value) {
        _privateVar = value
    }

private var A.privateInlineVar1: Int
    inline get() = privateVar
    inline set(value) {
        privateVar = value
    }

private inline var A.privateInlineVar2: Int
    get() = privateInlineVar1
    set(value) {
        privateInlineVar1 = value
    }

internal inline var A.inlineVar: Int
    get() = privateInlineVar2
    set(value) {
        privateInlineVar2 = value
    }

// FILE: main.kt
fun box(): String {
    var result = 0
    A().run {
        result += inlineVar
        inlineVar = 10
        result += inlineVar
    }
    if (result != 22) return result.toString()
    return ""OK""
}
",KOT_01632,,,0
JetBrains__kotlin,c8cc09d1de03ac9d321332c9b0e95a78d4eac687,libraries/tools/kotlin-gradle-plugin-integration-tests/src/test/kotlin/org/jetbrains/kotlin/gradle/Kapt3IT.kt,.kt,Alexander Udalov,alexander.udalov@jetbrains.com,2025-04-09T14:36:14+02:00,Fir2Ir: fix start offsets of properties and default accessors,1,Kapt3IT,"open class Kapt3IT : Kapt3BaseIT() {
    override fun TestProject.customizeProject() {
        forceK1Kapt()
    }

    @DisplayName(""Kapt is skipped when no annotation processors are added"")
    @GradleTest
    fun testKaptSkipped(gradleVersion: GradleVersion) {
        project(""kaptSkipped"".withPrefix, gradleVersion) {
            build(""build"") {
                assertTasksSkipped("":kaptGenerateStubsKotlin"", "":kaptKotlin"")
                assertOutputContains(""No annotation processors provided. Skip KAPT processing."")
            }
        }
    }

    @DisplayName(""KT-63366: Adding kapt AP dependency in afterEvaluate for custom SourceSet"")
    @GradleTest
    fun testKaptCustomSourceSetDependencyAfterEvaluate(gradleVersion: GradleVersion) {
        project(""simple"".withPrefix, gradleVersion) {
            buildGradle.appendText(
                //language=groovy
                """"""
                |
                |sourceSets.create(""custom"")
                |
                |afterEvaluate {
                |    configurations.getByName(""kaptCustom"").dependencies.add(
                |        dependencies.create(""org.jetbrains.kotlin:annotation-processor-example"")
                |    )
                |}
                """""".trimMargin()
            )

            build("":kaptCustomKotlin"") {
                assertTasksExecuted("":kaptCustomKotlin"")
                assertOutputDoesNotContain(""No annotation processors provided. Skip KAPT processing."")
                assertOutputContains(""Annotation processors: example.ExampleAnnotationProcessor, example.KotlinFilerGeneratingProcessor"")
            }
        }
    }

    @DisplayName(""Kapt is not skipped when all annotation processors are declared as indirect dependencies"")
    @GradleTest
    fun testKaptNotSkippedWithIndirectDependencies(gradleVersion: GradleVersion) {
        project(""indirectDependencies"".withPrefix, gradleVersion) {
            build(""assemble"") {
                assertTasksExecuted("":kaptGenerateStubsKotlin"", "":kaptKotlin"")
            }
        }
    }

    @DisplayName(""Kapt is working with newer JDKs"")
    @JdkVersions(versions = [JavaVersion.VERSION_11, JavaVersion.VERSION_17, JavaVersion.VERSION_21])
    @GradleWithJdkTest
    fun doTestSimpleWithCustomJdk(
        gradleVersion: GradleVersion,
        jdk: JdkVersions.ProvidedJdk,
    ) {
        project(
            ""simple"".withPrefix,
            gradleVersion,
        ) {
            //language=Groovy
            buildGradle.appendText(
                """"""
                |
                |kotlin {
                |    jvmToolchain(${jdk.version.majorVersion})
                |}
                """""".trimMargin()
            )

            build(""assemble"") {
                assertTasksExecuted("":kaptGenerateStubsKotlin"", "":kaptKotlin"")
                // Check added because of https://youtrack.jetbrains.com/issue/KT-33056.
                assertOutputDoesNotContain(""javaslang.match.PatternsProcessor"")
            }
        }
    }

    @DisplayName(""KT-48402: Kapt worker classpath is using JRE classes from toolchain"")
    @JdkVersions(versions = [JavaVersion.VERSION_17])
    @GradleWithJdkTest
    fun kaptClasspathJreToolchain(
        gradleVersion: GradleVersion,
        jdk: JdkVersions.ProvidedJdk,
    ) {
        project(
            ""simple"".withPrefix,
            gradleVersion,
            buildJdk = jdk.location
        ) {
            buildGradle.modify {
                """"""
                $it
                
                kotlin {
                    jvmToolchain {
                        languageVersion.set(JavaLanguageVersion.of(""8""))
                    }
                }
                """""".trimIndent()
            }

            build(""assemble"")
        }
    }

    @DisplayName(""Additional Kapt jvm arguments are passed to the process"")
    @GradleTest
    internal fun additionalJvmArgumentsArePassed(gradleVersion: GradleVersion) {
        project(""simple"".withPrefix, gradleVersion) {
            gradleProperties.append(
                """"""
                
                kapt.workers.isolation = process
                """""".trimIndent()
            )

            buildGradle.append(
                //language=Groovy
                """"""
                
                tasks
                    .withType(org.jetbrains.kotlin.gradle.internal.KaptWithoutKotlincTask.class)
                    .configureEach {
                        it.kaptProcessJvmArgs.addAll(['-Xmx64m', '-Duser.country=DE'])
                    }
                """""".trimIndent()
            )

            build(""assemble"") {
                assertOutputContains(""Starting process 'Gradle Worker Daemon.*-Xmx64m.*-Duser.country=DE.*"".toRegex())
            }
        }
    }

    @DisplayName(""Warning is produced on additional Kapt jvm arguments and 'none' workers isolation mode"")
    @GradleTest
    internal fun warningOnNoneIsolationModeAndAdditionalJvmArguments(gradleVersion: GradleVersion) {
        project(""simple"".withPrefix, gradleVersion) {
            gradleProperties.append(
                """"""
                
                kapt.workers.isolation = none
                """""".trimIndent()
            )

            // Toolchain will force ""process"" mode
            buildGradle.modify { it.checkedReplace(""kotlin.jvmToolchain(8)"", """") }

            buildGradle.append(
                //language=Groovy
                """"""
                
                tasks
                    .withType(org.jetbrains.kotlin.gradle.internal.KaptWithoutKotlincTask.class)
                    .configureEach {
                        it.kaptProcessJvmArgs.addAll(['-Xmx64m', '-Duser.country=DE'])
                    }
                """""".trimIndent()
            )

            build(""assemble"") {
                assertOutputContains(""Kapt additional JVM arguments are ignored in 'NONE' workers isolation mode"")
            }
        }
    }

    @DisplayName(""Should find annotation processor via FQName"")
    @GradleTest
    open fun testAnnotationProcessorAsFqName(gradleVersion: GradleVersion) {
        project(
            ""annotationProcessorAsFqName"".withPrefix,
            gradleVersion,
            buildOptions = defaultBuildOptions.copy(
                kaptOptions = kaptOptions().copy(includeCompileClasspath = true)
            )
        ) {
            build(""build"") {
                assertTasksExecuted("":kaptGenerateStubsKotlin"", "":kaptKotlin"", "":compileKotlin"", "":compileJava"")
                assertKaptSuccessful()
                assertFileExists(projectPath.resolve(""build/generated/source/kapt/main/example/TestClassGenerated.java""))
                assertFileExists(kotlinClassesDir().resolve(""example/TestClass.class""))
                assertFileExists(javaClassesDir().resolve(""example/TestClassGenerated.class""))
            }
        }
    }

    @DisplayName(""Kapt tasks is up-to-date on the second run"")
    @GradleTest
    fun testSimple(gradleVersion: GradleVersion) {
        project(""simple"".withPrefix, gradleVersion) {

            build(""build"") {
                assertKaptSuccessful()
                assertTasksExecuted("":kaptGenerateStubsKotlin"", "":kaptKotlin"", "":compileKotlin"", "":compileJava"")
                assertFileExists(projectPath.resolve(""build/generated/source/kapt/main/example/TestClassGenerated.java""))
                assertFileExists(kotlinClassesDir().resolve(""example/TestClass.class""))
                assertFileExists(javaClassesDir().resolve(""example/TestClassGenerated.class""))
                assertFileExists(javaClassesDir().resolve(""example/SourceAnnotatedTestClassGenerated.class""))
                assertFileExists(javaClassesDir().resolve(""example/BinaryAnnotatedTestClassGenerated.class""))
                assertFileExists(javaClassesDir().resolve(""example/RuntimeAnnotatedTestClassGenerated.class""))
                assertFileNotExistsInTree(""build/classes"", ""ExampleSourceAnnotation.class"")
                assertOutputDoesNotContain(""warning: The following options were not recognized by any processor"")
                assertOutputContains(""Need to discovery annotation processors in the AP classpath"")
            }

            build(""build"") {
                assertTasksUpToDate("":kaptGenerateStubsKotlin"", "":kaptKotlin"", "":compileKotlin"", "":compileJava"")
            }
        }
    }

    @DisplayName(""Kapt is working with incremental compilation"")
    @GradleTest
    fun testSimpleWithIC(gradleVersion: GradleVersion) {
        project(
            ""simple"".withPrefix,
            gradleVersion,
            buildOptions = defaultBuildOptions.copy(incremental = true)
        ) {
            build(""clean"", ""build"") {
                assertTasksExecuted("":kaptGenerateStubsKotlin"", "":kaptKotlin"", "":compileKotlin"", "":compileJava"")
                assertKaptSuccessful()
                assertFileNotExistsInTree(javaClassesDir(), ""ExampleSourceAnnotation.class"")
            }

            javaSourcesDir().resolve(""test.kt"").append("" "")
            javaSourcesDir().resolve(""foo/InternalDummy.kt"").append("" "")
            build(""build"") {
                assertTasksExecuted("":kaptGenerateStubsKotlin"", "":compileKotlin"")
                // there are no actual changes in Java sources, generated sources, Kotlin classes
                assertTasksUpToDate("":kaptKotlin"", "":compileJava"")
                assertFileNotExistsInTree(javaClassesDir(), ""ExampleSourceAnnotation.class"")
            }

            // emulating wipe by android plugin's IncrementalSafeguardTask
            javaClassesDir().toFile().deleteRecursively()
            build(""build"") {
                assertTasksUpToDate("":kaptGenerateStubsKotlin"", "":kaptKotlin"", "":compileKotlin"")
                assertFileExists(kotlinClassesDir().resolve(""example/TestClass.class""))
                assertFileNotExistsInTree(javaClassesDir(), ""ExampleSourceAnnotation.class"")
            }
        }
    }

    @DisplayName(""Disabled incremental compilation should disable it also for generate stubs task"")
    @GradleTest
    fun testDisableIcForGenerateStubs(gradleVersion: GradleVersion) {
        project(
            ""simple"".withPrefix,
            gradleVersion,
            buildOptions = defaultBuildOptions.copy(incremental = false)
        ) {
            build(""build"") {
                assertTasksExecuted("":kaptGenerateStubsKotlin"")
                assertOutputDoesNotContain(USING_JVM_INCREMENTAL_COMPILATION_MESSAGE)
            }
        }
    }

    @DisplayName(""Works with inherited annotations"")
    @GradleTest
    fun testInheritedAnnotations(gradleVersion: GradleVersion) {
        project(""inheritedAnnotations"".withPrefix, gradleVersion) {
            build(""build"") {
                assertKaptSuccessful()
                assertFileExists(projectPath.resolve(""build/generated/source/kapt/main/example/TestClassGenerated.java""))
                assertFileExists(projectPath.resolve(""build/generated/source/kapt/main/example/AncestorClassGenerated.java""))
                assertFileExists(javaClassesDir().resolve(""example/TestClassGenerated.class""))
                assertFileExists(javaClassesDir().resolve(""example/AncestorClassGenerated.class""))
            }
        }
    }

    @DisplayName(""passes arguments from kapt configuration"")
    @GradleTest
    @TestMetadata(""kapt2/arguments"")
    fun testArguments(gradleVersion: GradleVersion) {
        project(""arguments"".withPrefix, gradleVersion) {
            build(""build"") {
                assertKaptSuccessful()
                assertOutputContains(
                    ""AP options: {suffix=Customized, justColon=:, justEquals==, containsColon=a:b, "" +
                            ""containsEquals=a=b, startsWithColon=:a, startsWithEquals==a, endsWithColon=a:, "" +
                            ""endsWithEquals=a:, withSpace=a b c,""
                )
                assertOutputContains(""-Xmaxerrs=500, -Xlint:all=-Xlint:all"") // Javac options test
                assertFileExists(projectPath.resolve(""build/generated/source/kapt/main/example/TestClassCustomized.java""))
                assertFileExists(kotlinClassesDir().resolve(""example/TestClass.class""))
                assertFileExists(javaClassesDir().resolve(""example/TestClassCustomized.class""))
                assertOutputContains(""Annotation processor class names are set, skip AP discovery"")
            }
        }
    }

    @DisplayName(""generated directory is up-to-date on binary annotation remove"")
    @GradleTest
    fun testGeneratedDirectoryIsUpToDate(gradleVersion: GradleVersion) {
        project(""generatedDirUpToDate"".withPrefix, gradleVersion) {

            build(""build"") {
                assertTasksExecuted("":kaptGenerateStubsKotlin"", "":kaptKotlin"", "":compileKotlin"", "":compileJava"")
                assertKaptSuccessful()
                assertFileExists(kotlinClassesDir().resolve(""example/TestClass.class""))

                assertFileExists(projectPath.resolve(""build/generated/source/kapt/main/example/TestClassGenerated.java""))
                assertFileExists(projectPath.resolve(""build/generated/source/kapt/main/example/SourceAnnotatedTestClassGenerated.java""))
                assertFileExists(projectPath.resolve(""build/generated/source/kapt/main/example/BinaryAnnotatedTestClassGenerated.java""))
                assertFileExists(projectPath.resolve(""build/generated/source/kapt/main/example/RuntimeAnnotatedTestClassGenerated.java""))

                assertFileExists(javaClassesDir().resolve(""example/TestClassGenerated.class""))
                assertFileExists(javaClassesDir().resolve(""example/SourceAnnotatedTestClassGenerated.class""))
                assertFileExists(javaClassesDir().resolve(""example/BinaryAnnotatedTestClassGenerated.class""))
                assertFileExists(javaClassesDir().resolve(""example/RuntimeAnnotatedTestClassGenerated.class""))
            }

            javaSourcesDir().resolve(""test.kt"").modify {
                it.replace(""@ExampleBinaryAnnotation"", """")
            }

            build(""build"") {
                assertTasksExecuted("":kaptGenerateStubsKotlin"", "":kaptKotlin"", "":compileKotlin"")
                assertTasksUpToDate("":compileJava"")
                assertFileExists(kotlinClassesDir().resolve(""example/TestClass.class""))

                assertFileExists(projectPath.resolve(""build/generated/source/kapt/main/example/TestClassGenerated.java""))
                assertFileExists(projectPath.resolve(""build/generated/source/kapt/main/example/SourceAnnotatedTestClassGenerated.java""))
                assertFileInProjectNotExists(""build/generated/source/kapt/main/example/BinaryAnnotatedTestClassGenerated.java"")
                assertFileExists(projectPath.resolve(""build/generated/source/kapt/main/example/RuntimeAnnotatedTestClassGenerated.java""))

                assertFileExists(javaClassesDir().resolve(""example/TestClassGenerated.class""))
                assertFileExists(javaClassesDir().resolve(""example/SourceAnnotatedTestClassGenerated.class""))
                assertFileNotExists(javaClassesDir().resolve(""example/BinaryAnnotatedTestClassGenerated.class""))
                assertFileExists(javaClassesDir().resolve(""example/RuntimeAnnotatedTestClassGenerated.class""))
            }
        }
    }

    @DisplayName(""Should incrementally rebuild on java class deletion"")
    @GradleTest
    fun testRemoveJavaClassICRebuild(gradleVersion: GradleVersion) {
        testICRebuild(gradleVersion) { project ->
            project.javaSourcesDir().resolve(""foo/Foo.java"").deleteExisting()
        }
    }

    @DisplayName(""Should incrementally rebuild on classpath change"")
    @GradleTest
    open fun testChangeClasspathICRebuild(gradleVersion: GradleVersion) {
        testICRebuild(gradleVersion) { project ->
            project.buildGradle.modify {
                ""$it\ndependencies { implementation 'org.jetbrains.kotlin:kotlin-reflect:' + kotlin_version }""
            }
        }
    }

    @DisplayName(""Should incrementally rebuild on annotation processor arguments change"")
    @GradleTest
    @TestMetadata(""kapt2/arguments"")
    fun testChangeAPArgumentsICRebuild(gradleVersion: GradleVersion) {
        project(""arguments"".withPrefix, gradleVersion) {
            build(""build"") {
                assertKaptSuccessful()
                assertOutputContains(""AP options: {suffix=Customized,"")
                assertFileInProjectExists(""build/generated/source/kapt/main/example/TestClassCustomized.java"")
                assertFileExists(kotlinClassesDir().resolve(""example/TestClass.class""))
                assertFileExists(javaClassesDir().resolve(""example/TestClassCustomized.class""))
            }

            buildGradle.modify {
                it.replace(""arg(\""suffix\"", \""Customized\"")"", ""arg(\""suffix\"", \""Changed\"")"")
            }
            javaSourcesDir().resolve(""test.kt"").modify {
                it.replace(""TestClassCustomized::class.java"", ""TestClassChanged::class.java"")
            }

            build(""build"") {
                assertKaptSuccessful()
                assertOutputContains(""AP options: {suffix=Changed,"")
                assertFileInProjectExists(""build/generated/source/kapt/main/example/TestClassChanged.java"")
                assertFileInProjectNotExists(""build/generated/source/kapt/main/example/TestClassCustomized.java"")
                assertFileExists(kotlinClassesDir().resolve(""example/TestClass.class""))
                assertFileExists(javaClassesDir().resolve(""example/TestClassChanged.class""))
                assertFileNotExists(javaClassesDir().resolve(""example/TestClassCustomized.class""))
            }
        }
    }

    // tests all output directories are cleared when IC rebuilds
    private fun testICRebuild(
        gradleVersion: GradleVersion,
        performChange: (TestProject) -> Unit,
    ) {
        project(
            ""incrementalRebuild"".withPrefix,
            gradleVersion,
            buildOptions = defaultBuildOptions.copy(incremental = true)
        ) {
            val generatedSrc = ""build/generated/source/kapt/main""

            build(""build"") {
                // generated sources
                assertFileExists(projectPath.resolve(""$generatedSrc/bar/UseBar_MembersInjector.java""))
            }

            performChange(this)

            javaSourcesDir().resolve(""bar/UseBar.kt"").modify { it.replace(""package bar"", ""package foo.bar"") }

            build(""build"") {
                assertTasksExecuted("":kaptGenerateStubsKotlin"", "":kaptKotlin"", "":compileKotlin"", "":compileJava"")

                // generated sources
                assertFileExists(projectPath.resolve(""$generatedSrc/foo/bar/UseBar_MembersInjector.java""))
                assertFileInProjectNotExists(""$generatedSrc/bar/UseBar_MembersInjector.java"")

                // classes
                assertFileExists(kotlinClassesDir().resolve(""foo/bar/UseBar.class""))
                assertFileNotExists(kotlinClassesDir().resolve(""bar/UseBar.class""))
                assertFileExists(javaClassesDir().resolve(""foo/bar/UseBar_MembersInjector.class""))
                assertFileNotExists(javaClassesDir().resolve(""bar/UseBar_MembersInjector.class""))
            }
        }
    }

    @DisplayName(""Should run processing incrementally on annotation removal"")
    @GradleTest
    fun testRemoveAnnotationIC(gradleVersion: GradleVersion) {
        project(
            ""simple"".withPrefix,
            gradleVersion,
            buildOptions = defaultBuildOptions.copy(incremental = true)
        ) {
            val internalDummyKt = javaSourcesDir().resolve(""foo/InternalDummy.kt"")

            // add annotation
            val exampleAnn = ""@example.ExampleAnnotation ""
            internalDummyKt.modify { it.addBeforeSubstring(exampleAnn, ""internal class InternalDummy"") }

            build(""classes"") {
                assertFileExists(projectPath.resolve(""build/generated/source/kapt/main/foo/InternalDummyGenerated.java""))
            }

            // remove annotation
            internalDummyKt.modify { it.replace(exampleAnn, """") }

            build(""classes"", buildOptions = buildOptions.copy(logLevel = LogLevel.DEBUG)) {
                val allMainKotlinSrc = relativeToProject(javaSourcesDir().allKotlinSources).toSet()
                assertCompiledKotlinSources(allMainKotlinSrc, output)
                assertFileInProjectNotExists(""build/generated/source/kapt/main/foo/InternalDummyGenerated.java"")
            }
        }
    }

    @DisplayName(""KT18799: generate annotation value for constant values in documented types"")
    @GradleTest
    open fun testKt18799(gradleVersion: GradleVersion) {
        project(""kt18799"".withPrefix, gradleVersion) {
            build(""kaptKotlin"")

            subProject(""app"")
                .javaSourcesDir()
                .resolve(""com.b.A.kt"")
                .modify {
                    val line = ""@Factory(factoryClass = CLASS_NAME, something = arrayOf(Test()))""
                    assert(line in it)
                    it.replace(line, ""@Factory(factoryClass = CLASS_NAME)"")
                }

            build(""kaptKotlin"")
        }
    }

    @DisplayName(""compile arguments are properly copied from compileKotlin to kaptTask"")
    @GradleTest
    fun testCopyCompileArguments(gradleVersion: GradleVersion) {
        project(
            ""simple"".withPrefix,
            gradleVersion,
            buildOptions = defaultBuildOptions.copy(logLevel = LogLevel.DEBUG)
        ) {
            val arg = ""-Xsuppress-version-warnings""
            buildGradle.modify {
                //language=Gradle
                """"""
                $it
                ${System.lineSeparator()}
                compileKotlin { kotlinOptions.freeCompilerArgs = ['$arg'] }
                """""".trimIndent()
            }

            build(""build"") {
                assertKaptSuccessful()
                val regex = ""(?m)^.*Kotlin compiler args.*-P plugin:org\\.jetbrains\\.kotlin\\.kapt3.*$"".toRegex()
                val kaptArgs = regex.find(output)?.value ?: error(""Kapt compiler arguments are not found!"")
                assert(kaptArgs.contains(arg)) { ""Kapt compiler arguments should contain '$arg': $kaptArgs"" }
            }
        }
    }

    @DisplayName(""generates Kotlin code"")
    @GradleTest
    fun testOutputKotlinCode(gradleVersion: GradleVersion) {
        project(""kaptOutputKotlinCode"".withPrefix, gradleVersion) {
            build(""build"") {
                assertKaptSuccessful()
                assertFileExists(projectPath.resolve(""build/generated/source/kapt/main/example/TestClassCustomized.java""))
                assertFileExists(projectPath.resolve(""build/generated/source/kaptKotlin/main/TestClass.kt""))
                assertFileExists(kotlinClassesDir().resolve(""example/TestClass.class""))
                assertFileExists(javaClassesDir().resolve(""example/TestClassCustomized.class""))
            }
        }
    }

    @DisplayName(""location mapping is working as expected"")
    @GradleTest
    fun testLocationMapping(gradleVersion: GradleVersion) {
        project(""locationMapping"".withPrefix, gradleVersion) {
            val regex = ""((Test\\.java)|(test\\.kt)):(\\d+): error: GenError element"".toRegex()

            fun BuildResult.getErrorMessages(): String =
                regex.findAll(output).map { it.value }.joinToString(""\n"")

            fun genJavaErrorString(vararg lines: Int) =
                lines.joinToString(""\n"") { ""Test.java:$it: error: GenError element"" }

            fun genKotlinErrorString(vararg lines: Int) =
                lines.joinToString(""\n"") { ""test.kt:$it: error: GenError element"" }

            buildAndFail(""build"") {
                val actual = getErrorMessages()
                assertEquals(
                    expected = genJavaErrorString(7, 19),
                    actual = actual
                )
            }

            buildGradle.modify {
                it.replace(""mapDiagnosticLocations = false"", ""mapDiagnosticLocations = true"")
            }

            buildAndFail(""build"") {
                val actual = getErrorMessages()
                assertEquals(expected = genKotlinErrorString(4, 7), actual = actual)
            }
        }
    }

    @DisplayName(""should fail to add dependency into 'kapt' configuration when plugin is not applied"")
    @GradleTest
    fun testNoKaptPluginApplied(gradleVersion: GradleVersion) {
        project(""nokapt"".withPrefix, gradleVersion) {

            buildAndFail(""build"") {
                assertOutputContains(""Could not find method kapt() for arguments"")
            }
        }
    }

    @DisplayName(""Should re-run kapt on changes in local annotation processor"")
    @GradleTest
    open fun testChangesInLocalAnnotationProcessor(gradleVersion: GradleVersion) {
        project(
            ""localAnnotationProcessor"".withPrefix,
            gradleVersion,
            dependencyManagement = DependencyManagement.DefaultDependencyManagement(setOf(""https://jitpack.io""))
        ) {
            build(""build"")

            val testAnnotationProcessor = subProject(""annotation-processor"").javaSourcesDir().resolve(""TestAnnotationProcessor.kt"")
            testAnnotationProcessor.modify { text ->
                val commentText = ""// print warning ""
                assert(text.contains(commentText))
                text.replace(commentText, """")
            }

            build(""build"") {
                assertTasksExecuted(
                    "":example:kaptKotlin""
                )

                assertOutputContains(""Additional warning message from AP"")
            }

            val exampleSubProjectBuildDir = subProject(""example"").projectPath.resolve(""build"")
            build(
                ""build"",
                buildOptions = defaultBuildOptions.copy(incremental = false)
            ) {
                // Java stubs should not be generated for Kotlin sources generated by annotation processors.
                assertFileNotExistsInTree(
                    exampleSubProjectBuildDir,
                    ""TestGeneratedKt.java""
                )
                assertFileNotExistsInTree(
                    exampleSubProjectBuildDir,
                    ""AnotherGenerated.java""
                )

                assertFileExistsInTree(
                    exampleSubProjectBuildDir,
                    ""TestGeneratedKt.class""
                )
                assertFileExistsInTree(
                    exampleSubProjectBuildDir,
                    ""AnotherGenerated.class""
                )
            }
        }
    }

    @DisplayName(""should not resolve 'kapt' configuration during build configuration phase"")
    @GradleTest
    fun testKaptConfigurationLazyResolution(gradleVersion: GradleVersion) {
        project(""simple"".withPrefix, gradleVersion) {
            buildGradle.append(
                ""\ndependencies { kapt project.files { throw new GradleException(\""Resolved!\"") } }""
            )
            // Check that the kapt configuration does not get resolved during the project evaluation:
            build(""tasks"") {
                assertOutputDoesNotContain(""Resolved!"")
            }
        }
    }

    @DisplayName(""Should be possible to disable discovery in compile classpath"")
    @GradleTest
    open fun testDisableDiscoveryInCompileClasspath(gradleVersion: GradleVersion) {
        project(
            ""kaptAvoidance"".withPrefix,
            gradleVersion,
            buildOptions = defaultBuildOptions.copy(
                kaptOptions = kaptOptions().copy(includeCompileClasspath = true)
            )
        ) {
            val appSubproject = subProject(""app"")

            appSubproject.buildGradle.modify {
                it.addBeforeSubstring(""//"", ""kapt \""org.jetbrains.kotlin"")
            }
            build(""assemble"") {
                assertOutputContains(""Annotation processors discovery from compile classpath is deprecated"")
            }

            appSubproject.buildGradle.modify {
                ""$it\n\nkapt.includeCompileClasspath = false""
            }
            buildAndFail(""assemble"") {
                assertOutputDoesNotContain(""Annotation processors discovery from compile classpath is deprecated"")
            }
        }
    }

    @DisplayName(""up-to-date checks are working"")
    @GradleTest
    fun testKaptAvoidance(gradleVersion: GradleVersion) {
        project(""kaptAvoidance"".withPrefix, gradleVersion) {

            subProject(""app"").buildGradle.modify {
                ""$it\n\nkapt.includeCompileClasspath = true""
            }

            build(""assemble"") {
                assertTasksExecuted(
                    "":app:kaptGenerateStubsKotlin"",
                    "":app:kaptKotlin"",
                    "":app:compileKotlin"",
                    "":app:compileJava"",
                    "":lib:compileKotlin""
                )
            }

            val original = ""fun foo() = 0""
            val replacement1 = ""fun foo() = 1""
            val replacement2 = ""fun foo() = 2""
            val libClassKt = subProject(""lib"").kotlinSourcesDir().resolve(""LibClass.kt"")
            libClassKt.modify { it.checkedReplace(original, replacement1) }

            build(""assemble"") {
                assertTasksUpToDate("":app:kaptGenerateStubsKotlin"")
                assertTasksExecuted(
                    "":lib:compileKotlin"",
                    "":app:kaptKotlin""
                )
            }

            // enable discovery
            subProject(""app"").buildGradle.modify {
                it.replace(
                    ""kapt.includeCompileClasspath = true"",
                    ""kapt.includeCompileClasspath = false""
                )
            }
            build(""assemble"") {
                assertTasksUpToDate("":lib:compileKotlin"")
                assertTasksExecuted(
                    "":app:kaptGenerateStubsKotlin"",
                    "":app:kaptKotlin""
                )
            }

            libClassKt.modify { it.checkedReplace(replacement1, replacement2) }
            build(""assemble"") {
                assertTasksExecuted("":lib:compileKotlin"")
                assertTasksUpToDate("":app:kaptKotlin"", "":app:kaptGenerateStubsKotlin"")
            }
        }
    }

    @DisplayName(""KT19179 and KT37241: kapt is not skipped and does not generate stubs for non-existent entries"")
    @GradleTest
    open fun testKt19179andKt37241(gradleVersion: GradleVersion) {
        project(""kt19179"".withPrefix, gradleVersion) {

            build(""build"") {
                val processorSubproject = subProject(""processor"")
                processorSubproject
                    .assertFileInProjectExists(""build/tmp/kapt3/classes/main/META-INF/services/javax.annotation.processing.Processor"")

                val processorJar = processorSubproject.projectPath.resolve(""build/libs/processor.jar"")
                assertFileExists(processorJar)

                val zip = ZipFile(processorJar.toFile())
                @Suppress(""ConvertTryFinallyToUseCall"")
                try {
                    assert(zip.getEntry(""META-INF/services/javax.annotation.processing.Processor"") != null) {
                        ""Generated annotation processor jar file does not contain processor service entry!""
                    }
                } finally {
                    zip.close()
                }

                assertTasksExecuted(
                    "":processor:kaptGenerateStubsKotlin"",
                    "":processor:kaptKotlin"",
                    "":app:kaptGenerateStubsKotlin"",
                    "":app:kaptKotlin""
                )

                // Test for KT-37241, check the that non-existent classpath entry is filtered out:
                assertOutputDoesNotContain(""Classpath entry points to a non-existent location"")
            }

            val testKt = subProject(""app"").kotlinSourcesDir().resolve(""Test.kt"")
            testKt.modify { text ->
                assert(""SomeClass()"" in text)
                text.replace(""SomeClass()"", ""SomeClass(); val a = 5"")
            }

            build(""build"") {
                assertTasksUpToDate(
                    "":processor:kaptGenerateStubsKotlin"",
                    "":processor:kaptKotlin"",
                    "":app:kaptKotlin""
                )
                assertTasksExecuted("":app:kaptGenerateStubsKotlin"")
            }

            testKt.modify { text ->
                ""$text\n\nfun t() {}""
            }

            build(""build"") {
                assertTasksUpToDate("":processor:kaptGenerateStubsKotlin"", "":processor:kaptKotlin"")
                assertTasksExecuted("":app:kaptGenerateStubsKotlin"", "":app:kaptKotlin"")
            }
        }
    }

    @DisplayName(""KT33847: Kapt does not included Filer-generated class files on compilation classpath"")
    @GradleTest
    open fun testKt33847(gradleVersion: GradleVersion) {
        project(""kt33847"".withPrefix, gradleVersion) {

            build(""build"") {
                val processorSubproject = subProject(""processor"")
                processorSubproject
                    .assertFileInProjectExists(""build/tmp/kapt3/classes/main/META-INF/services/javax.annotation.processing.Processor"")

                val processorJar = processorSubproject.projectPath.resolve(""build/libs/processor.jar"")
                assertFileExists(processorJar)

                ZipFile(processorJar.toFile()).use { zip ->
                    assert(zip.getEntry(""META-INF/services/javax.annotation.processing.Processor"") != null) {
                        ""Generated annotation processor jar file does not contain processor service entry!""
                    }
                }

                assertTasksExecuted(
                    "":api:compileKotlin"",
                    "":processor:compileKotlin"",
                    "":library:kaptGenerateStubsKotlin"",
                    "":library:kaptKotlin"",
                    "":library:compileKotlin"",
                    "":app:compileKotlin"",
                )
                assertKaptSuccessful()
            }
        }
    }

    @DisplayName(""Dependency on kapt module should not resolve all configurations"")
    @GradleTest
    fun testDependencyOnKaptModule(gradleVersion: GradleVersion) {
        project(
            ""simpleProject"",
            gradleVersion,
            buildOptions = defaultBuildOptions.copy(
                nativeOptions = defaultBuildOptions.nativeOptions.copy(
                    distributionDownloadFromMaven = false // TODO(Dmitrii Krasnov): this flag is off, because we try to find configuration which is not in maven yet. Could be set to true after KTI-1569 is done
                )
            )
        ) {
            includeOtherProjectAsSubmodule(""simple"", ""kapt2"")
            buildGradle.append(""\ndependencies { implementation project(':simple') }"")

            testResolveAllConfigurations()
        }
    }

    @DisplayName(""Kapt with MPP/Jvm"")
    @GradleTest
    fun testMPPKaptPresence(gradleVersion: GradleVersion) {
        project(
            ""mpp-kapt-presence"".withPrefix,
            gradleVersion,
            buildOptions = defaultBuildOptions.copy(logLevel = LogLevel.DEBUG)
        ) {
            if (!isWithJavaSupported) {
                subProject(""dac"").buildGradle.replaceText(""withJava()"", """")
            }

            build("":dac:compileKotlinJvm"") {
                assertTasksExecuted(
                    "":dac:kaptGenerateStubsKotlinJvm"",
                    "":dac:kaptKotlinJvm"",
                    "":dac:compileKotlinJvm""
                )

                val sourcesDir = subProject(""dac"").kotlinSourcesDir(""commonMain"")
                // KT-61622: checking if kapt tasks are getting common sources in default configuration
                val commonSources = arrayOf(
                    sourcesDir.resolve(""DocumentationService.kt"").toAbsolutePath().toString(),
                    sourcesDir.resolve(""Item.kt"").toAbsolutePath().toString(),
                )
                assertCompilerArguments("":dac:kaptGenerateStubsKotlinJvm"", *commonSources)
            }
        }
    }

    @DisplayName(""KT-31127: processor using Filer api does not break 'javaCompile' task"")
    @GradleTest
    fun testKotlinProcessorUsingFiler(gradleVersion: GradleVersion) {
        project(""kotlinProject"", gradleVersion) {
            buildGradle.modify {
                val subStringBeforePlugins = it.substringBefore(""}"")
                val subStringAfterPlugins = it.substringAfter(""}"")

                """"""
                |$subStringBeforePlugins
                |    id 'org.jetbrains.kotlin.kapt'
                |}
                |$subStringAfterPlugins
                |
                |dependencies {
                |   kapt ""org.jetbrains.kotlin:annotation-processor-example:${""$""}kotlin_version""
                |   implementation ""org.jetbrains.kotlin:annotation-processor-example:${""$""}kotlin_version""
                |}
                """""".trimMargin()
            }

            // The test must not contain any java sources in order to detect the issue.
            assertEquals(emptyList(), projectPath.resolve(""src"").allJavaSources)
            kotlinSourcesDir().resolve(""Dummy.kt"").modify {
                it.replace(""class Dummy"", ""@example.KotlinFilerGenerated class Dummy"")
            }

            build(""build"") {
                assertFileInProjectExists(""build/generated/source/kapt/main/demo/DummyGenerated.kt"")
                assertTasksExecuted("":compileKotlin"")
                assertTasksNoSource("":compileJava"")
            }
        }
    }

    @DisplayName(""should do annotation processing when 'sourceCompatibility = 8' and JDK is 11+"")
    @JdkVersions(versions = [JavaVersion.VERSION_17])
    @GradleWithJdkTest
    fun testSimpleWithJdk11AndSourceLevel8(
        gradleVersion: GradleVersion,
        jdk: JdkVersions.ProvidedJdk,
    ) {
        project(
            ""simple"".withPrefix,
            gradleVersion,
            buildJdk = jdk.location
        ) {
            buildGradle.modify {
                it.replace(""kotlin.jvmToolchain(8)"", """") +
                        ""\njava.sourceCompatibility = JavaVersion.VERSION_1_8""
            }

            // because Java sourceCompatibility is fixed JVM target will different with JDK 11 on Gradle 8
            // as the toolchain by default will use the Gradle JDK version
            gradleProperties.appendText(
                """"""
                |kotlin.jvm.target.validation.mode=warning
                """""".trimMargin()
            )

            build(""assemble"") {
                assertTasksExecuted("":kaptKotlin"", "":kaptGenerateStubsKotlin"")
                assertOutputContains(""Javac options: {--source=1.8}"")
            }
        }
    }

    @DisplayName(""Works with JPMS on JDK 9+"")
    @GradleTest
    fun testJpmsModule(gradleVersion: GradleVersion) {
        project(
            ""jpms-module"".withPrefix,
            gradleVersion,
        ) {
            build(""assemble"") {
                assertTasksExecuted("":kaptKotlin"", "":kaptGenerateStubsKotlin"", "":compileKotlin"", "":compileJava"")
                assertFileInProjectExists(""build/generated/source/kapt/main/lab/TestClassGenerated.java"")
                assertFileExists(kotlinClassesDir().resolve(""lab/TestClass.class""))
            }

            build(""assemble"") {
                assertTasksUpToDate("":kaptKotlin"", "":kaptGenerateStubsKotlin"", "":compileKotlin"", "":compileJava"")
            }

            kotlinSourcesDir().resolve(""dagger_example/InjectedClass.kt"").modify { text ->
                text.checkedReplace(
                    ""//placeholder"",
                    ""fun someChange() = null""
                )
            }

            build(""assemble"") {
                assertTasksExecuted("":kaptKotlin"", "":kaptGenerateStubsKotlin"", "":compileKotlin"", "":compileJava"")
            }
        }
    }

    @DisplayName(""KT-46651: kapt is tracking source files properly with configuration cache enabled"")
    @GradleTest
    open fun kaptGenerateStubsShouldNotCaptureSourcesStateInConfigurationCache(gradleVersion: GradleVersion) {
        project(
            ""incrementalRebuild"".withPrefix,
            gradleVersion,
            buildOptions = defaultBuildOptions.withConfigurationCache
        ) {
            build(""assemble"")

            javaSourcesDir().resolve(""bar/UseBar.kt"").apply {
                modify {
                    it.replace(""UseBar"", ""UseBar1"")
                }
                Files.move(this, parent.resolve(""UseBar1.kt""))
            }

            build(""assemble"")
        }
    }

    @DisplayName(""KT-47347: kapt processors should not be an input files for stub generation"")
    @GradleTest
    open fun testChangesToKaptConfigurationDoNotTriggerStubGeneration(gradleVersion: GradleVersion) {
        project(
            ""localAnnotationProcessor"".withPrefix,
            gradleVersion,
            dependencyManagement = DependencyManagement.DefaultDependencyManagement(setOf(""https://jitpack.io""))
        ) {
            build(""assemble"")

            ZipOutputStream(projectPath.resolve(""fake_processor.jar"").outputStream()).close()
            subProject(""example"").buildGradle.append(
                //language=Gradle
                """"""

                dependencies {
                    kapt files(""../fake_processor.jar"")
                }
                """""".trimIndent()
            )

            build(""assemble"") {
                assertTasksExecuted("":example:kaptKotlin"")
                assertTasksUpToDate("":example:kaptGenerateStubsKotlin"")
            }
        }
    }

    @DisplayName(""KT-52392: Setup with different windows disks does not fail configuration"")
    @GradleTest
    @OsCondition(supportedOn = [OS.WINDOWS], enabledOnCI = [OS.WINDOWS])
    fun testDifferentDisksSetupDoesNotFailConfiguration(gradleVersion: GradleVersion) {
        project(
            ""simple"".withPrefix,
            gradleVersion,
            buildOptions = defaultBuildOptions.copy(
                /*
                 * We need to set the warning mode to none and disable configuration cache
                 * because the test fails when emitting the problems report
                 * https://github.com/gradle/gradle/issues/32778
                 */
                warningMode = WarningMode.None,
                configurationCache = BuildOptions.ConfigurationCacheValue.DISABLED,
            ),
        ) {
            fun findAnotherRoot() = ('A'..'Z').first { !projectPath.root.startsWith(it.toString()) }

            //language=Gradle
            buildGradle.append(
                """"""

                allprojects {
                    buildDir = ""${findAnotherRoot()}:/gradle-build/${'$'}{rootProject.name}/${'$'}{project.name}""
                    
                    // with dry-run `BuildResult#tasks` is empty, so we emulate dry-run to use `assertTasksSkipped`
                    tasks.configureEach {
                        enabled = false
                    }
                }
                """""".trimIndent()
            )
            build(""assemble"") {
                assertTasksSkipped("":kaptGenerateStubsKotlin"")
            }
        }
    }

    @DisplayName(""Generated sources attached to KotlinSourceSet are also used by generate stubs task"")
    @GradleTest
    fun testGeneratedSourcesUsedInGenerateStubsTask(gradleVersion: GradleVersion) {
        project(""generatedSources"".withPrefix, gradleVersion) {
            build(""assemble"")
        }
    }

    @DisplayName(""KT-53135: check that JVM IR backend is enabled by default by verifying that repeatable annotations are supported"")
    @GradleTest
    open fun testRepeatableAnnotations(gradleVersion: GradleVersion) {
        project(""repeatableAnnotations"".withPrefix, gradleVersion) {
            build(""build"") {
                assertKaptSuccessful()
                assertTasksExecuted("":kaptGenerateStubsKotlin"", "":kaptKotlin"", "":compileKotlin"")
            }
        }
    }

    @DisplayName(""Kapt-generated Kotlin sources can be used in Kotlin"")
    @GradleTest
    open fun useGeneratedKotlinSource(gradleVersion: GradleVersion) {
        project(""useGeneratedKotlinSource"".withPrefix, gradleVersion) {
            build(""build"") {
                assertKaptSuccessful()
                assertTasksExecuted("":kaptGenerateStubsKotlin"", "":kaptKotlin"", "":compileKotlin"")
            }
        }
    }

    @DisplayName(""KT-58745: compiler plugin options should be passed to KaptGenerateStubs task"")
    @GradleTest
    fun kaptGenerateStubsConfiguredWithCompilerPluginOptions(gradleVersion: GradleVersion) {
        project(
            ""simple"".withPrefix,
            gradleVersion,
            buildOptions = defaultBuildOptions.copy(logLevel = LogLevel.DEBUG)
        ) {

            buildGradle.modify {
                //language=groovy
                """"""
                |${it.substringBefore(""plugins {"")}
                |plugins {
                |   id ""org.jetbrains.kotlin.plugin.noarg""
                |${it.substringAfter(""plugins {"")}
                |
                |noArg {
                |    annotation(""my.custom.Annotation"")
                |}
                """""".trimMargin()
            }

            build("":kaptGenerateStubsKotlin"") {
                assertTasksExecuted("":kaptGenerateStubsKotlin"")

                assertCompilerArgument(
                    "":kaptGenerateStubsKotlin"",
                    ""plugin:org.jetbrains.kotlin.noarg:annotation=my.custom.Annotation""
                )
            }
        }
    }

    @DisplayName(""KT-59256: kapt generated files are included into the test runtime classpath"")
    @GradleTest
    fun testKaptGeneratedInTestRuntimeClasspath(gradleVersion: GradleVersion) {
        project(""kapt-in-test-runtime-classpath"".withPrefix, gradleVersion) {
            build(""test"") {
                assertFileInProjectExists(""build/tmp/kapt3/classes/main/META-INF/services/com.example.SomeInterface"")
            }
        }
    }

    @DisplayName(""Application of annotation processors is repeated as long as new source files are generated"")
    @GradleTest
    open fun testMultipleProcessingPasses(gradleVersion: GradleVersion) {
        project(""multipass"".withPrefix, gradleVersion) {
            build(""build"") {
                assertKaptSuccessful()
                assertOutputContains(""No elements for AnnotationProcessor3"")
                assertOutputContains(""No elements for AnnotationProcessor2"")
                assertFileInProjectExists(""example/build/generated/source/kapt/main/generated/TestClass1.java"")
                assertFileInProjectExists(""example/build/generated/source/kapt/main/generated/TestClass12.java"")
                assertFileInProjectExists(""example/build/generated/source/kapt/main/generated/TestClass123.java"")
            }
        }
    }

    @DisplayName(""KT-64719 KAPT stub generation should fail on files with declaration errors"")
    @GradleTest
    open fun testFailOnTopLevelSyntaxError(gradleVersion: GradleVersion) {
        project(""simple"".withPrefix, gradleVersion) {
            javaSourcesDir().resolve(""invalid.kt"").writeText(""TopLevelDeclarationExpected"")

            buildAndFail("":kaptGenerateStubsKotlin"") {
                assertOutputContains(""invalid.kt:1:1 Expecting a top level declaration"")
            }
        }
    }

    @DisplayName(""KT-64719 KAPT stub generation should not fail on errors in bodies"")
    @GradleTest
    fun testNotFailOnBodyLevelSyntaxError(gradleVersion: GradleVersion) {
        project(""simple"".withPrefix, gradleVersion) {
            javaSourcesDir().resolve(""invalid.kt"").writeText(""fun foo() { ElementExpectedError }"")

            build("":kaptGenerateStubsKotlin"") {
                assertFileExists(projectPath.resolve(""build/tmp/kapt3/stubs/main/InvalidKt.java""))
            }
        }
    }

    @DisplayName(""KT-65006 Kapt works with the serialization plugin"")
    @GradleTest
    fun testSerializationPlugin(gradleVersion: GradleVersion) {
        project(""serialization"".withPrefix, gradleVersion) {
            build("":kaptGenerateStubsKotlin"") {
                assertFileInProjectContains(
                    ""build/tmp/kapt3/stubs/main/foo/Data.java"",
                    ""public static final class Companion"",
                    ""public static final class \$serializer implements kotlinx.serialization.internal.GeneratedSerializer<foo.Data>""
                )
            }
        }
    }

    @DisplayName(""K2 kapt cannot be enabled in K1"")
    @GradleTest
    open fun testK2KaptCannotBeEnabledInK1(gradleVersion: GradleVersion) {
        project(""simple"".withPrefix, gradleVersion) {
            buildScriptInjection {
                project.tasks.withType(KotlinCompile::class.java).configureEach {
                    it.compilerOptions {
                        languageVersion.set(KotlinVersion.KOTLIN_1_9)
                    }
                }
            }
            build(""-Pkapt.use.k2=true"", ""build"") {
                assertKaptSuccessful()
                assertTasksExecuted("":kaptGenerateStubsKotlin"", "":kaptKotlin"", "":compileKotlin"")
                assertOutputContains(""K2 kapt cannot be enabled in K1. Update language version to 2.0 or newer."")
            }
        }
    }
}",KOT_05761,CWE-22: Path Traversal;CWE-321: Hard-coded Cryptographic Key,A01: Broken Access Control;A02: Cryptographic Failures;A04: Insecure Design,1
gkd-kit__gkd,8f3dca8aa06959a28a4255c715524e30ff1eac22,app/src/main/kotlin/li/songe/gkd/util/Ext.kt,.kt,lisonge,i@songe.li,2024-01-13T22:45:48+08:00,fix: 使用系统默认 toast (#404),1,Ext,"object Ext {
    fun PackageManager.getApplicationInfoExt(
        packageName: String,
        value: Int = PackageManager.GET_META_DATA,
    ): ApplicationInfo {
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            getApplicationInfo(
                packageName, PackageManager.ApplicationInfoFlags.of(value.toLong())
            )
        } else {
            getApplicationInfo(
                packageName, value
            )
        }
    }

    fun Bitmap.isEmptyBitmap(): Boolean {
        val emptyBitmap = Bitmap.createBitmap(width, height, config)
        return this.sameAs(emptyBitmap)
    }

    fun getIpAddressInLocalNetwork(): Sequence<String> {
        val networkInterfaces = try {
            // android.system.ErrnoException: getifaddrs failed: EACCES (Permission denied)
            NetworkInterface.getNetworkInterfaces().iterator().asSequence()
        } catch (e: Exception) {
            toast(""获取host失败:"" + e.message)
            emptySequence()
        }
        val localAddresses = networkInterfaces.flatMap {
            it.inetAddresses.asSequence().filter { inetAddress ->
                inetAddress.isSiteLocalAddress && !(inetAddress.hostAddress?.contains("":"")
                    ?: false) && inetAddress.hostAddress != ""127.0.0.1""
            }.map { inetAddress -> inetAddress.hostAddress }
        }
        return localAddresses
    }

    fun PackageManager.getDefaultLauncherAppId(): String? {
        val intent = Intent(Intent.ACTION_MAIN)
        intent.addCategory(Intent.CATEGORY_HOME)
        val defaultLauncher = this.resolveActivity(intent, PackageManager.MATCH_DEFAULT_ONLY)
        return defaultLauncher?.activityInfo?.packageName
    }

}",KOT_00809,,,0
bitwarden__android,6340c2dd04f6407c4cf6c9c57d83779eefac4ad2,app/src/main/java/com/x8bit/bitwarden/data/platform/util/StringExtensions.kt,.kt,Patrick Honkonen,1883101+SaintPatrck@users.noreply.github.com,2025-03-27T17:11:53-04:00,[PM-19616] Move OmitFromCoverage annotation to core module (#4928),1,,"package com.x8bit.bitwarden.data.platform.util

import com.x8bit.bitwarden.data.platform.annotation.OmitFromCoverage
import com.x8bit.bitwarden.data.platform.manager.ResourceCacheManager
import java.net.URI
import java.net.URISyntaxException

/**
 * The protocol for and Android app URI.
 */
private const val ANDROID_APP_PROTOCOL: String = ""androidapp://""

/**
 * Try creating a [URI] out of this [String]. If it fails, return null.
 */
fun String.toUriOrNull(): URI? =
    try {
        URI(this)
    } catch (e: URISyntaxException) {
        null
    }

/**
 * Whether this [String] represents an android app URI.
 */
fun String.isAndroidApp(): Boolean =
    this.startsWith(ANDROID_APP_PROTOCOL)

/**
 * Whether this [String] starts with an http or https protocol.
 */
fun String.hasHttpProtocol(): Boolean =
    this.startsWith(prefix = ""http://"") || this.startsWith(prefix = ""https://"")

/**
 * Try and extract the web host from this [String] if it represents an Android app.
 */
fun String.getWebHostFromAndroidUriOrNull(): String? =
    if (this.isAndroidApp()) {
        val components = this
            .replace(ANDROID_APP_PROTOCOL, """")
            .split('.')

        if (components.size > 1) {
            ""${components[1]}.${components[0]}""
        } else {
            null
        }
    } else {
        null
    }

/**
 * Extract the domain name from this [String] if possible, otherwise return null.
 */
fun String.getDomainOrNull(resourceCacheManager: ResourceCacheManager): String? =
    this
        .toUriOrNull()
        ?.addSchemeToUriIfNecessary()
        ?.parseDomainOrNull(resourceCacheManager = resourceCacheManager)

/**
 * Returns `true` if the [String] uri has a port, `false` otherwise.
 */
@OmitFromCoverage
fun String.hasPort(): Boolean {
    val uri = this
        .toUriOrNull()
        ?.addSchemeToUriIfNecessary()
        ?: return false
    return uri.port != -1
}

/**
 * Extract the host from this [String] if possible, otherwise return null.
 */
@OmitFromCoverage
fun String.getHostOrNull(): String? = this.toUriOrNull()
    ?.addSchemeToUriIfNecessary()
    ?.host

/**
 * Extract the host with optional port from this [String] if possible, otherwise return null.
 */
@OmitFromCoverage
fun String.getHostWithPortOrNull(): String? {
    val uri = this
        .toUriOrNull()
        ?.addSchemeToUriIfNecessary()
        ?: return null
    return uri.host?.let { host ->
        val port = uri.port
        if (port != -1) {
            ""$host:$port""
        } else {
            host
        }
    }
}

/**
 * Find the indices of the last occurrences of [substring] within this [String]. Return null if no
 * occurrences are found.
 */
fun String.findLastSubstringIndicesOrNull(substring: String): IntRange? {
    val lastIndex = this.lastIndexOf(substring)

    return if (lastIndex != -1) {
        val endIndex = lastIndex + substring.length - 1
        IntRange(lastIndex, endIndex)
    } else {
        null
    }
}
",KSEC_0443,['CWE-319: Cleartext Transmission of Sensitive Information'];['CWE-321: Hard-coded Cryptographic Key'],"['A02: Cryptographic Failures', 'A04: Insecure Design'];['A02: Cryptographic Failures']",1
recloudstream__cloudstream,8be8e5474647e5aeb31cb1026fe2e350dbf3c139,library/src/commonMain/kotlin/com/lagradost/cloudstream3/extractors/SobreatsesuypExtractor.kt,.kt,firelight,147925818+fire-light42@users.noreply.github.com,2024-07-08T23:17:25+02:00,Fixed log,1,Sobreatsesuyp,"// ! Bu araç @keyiflerolsun tarafından | @KekikAkademi için yazılmıştır.

package com.lagradost.cloudstream3.extractors

import android.util.Log
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.*
import com.fasterxml.jackson.annotation.JsonProperty

open class Sobreatsesuyp : ExtractorApi() {
    override val name            = ""Sobreatsesuyp""
    override val mainUrl         = ""https://sobreatsesuyp.com""
    override val requiresReferer = true

    override suspend fun getUrl(url: String, referer: String?, subtitleCallback: (SubtitleFile) -> Unit, callback: (ExtractorLink) -> Unit) {
        val extRef = referer ?: """"

        val videoReq = app.get(url, referer = extRef).text

        val file     = Regex(""""""file\"":\""([^\""]+)"""""").find(videoReq)?.groupValues?.get(1) ?: throw ErrorLoadingException(""File not found"")
        val postLink = ""${mainUrl}/"" + file.replace(""\\"", """")
        val rawList  = app.post(postLink, referer = extRef).parsedSafe<List<Any>>() ?: throw ErrorLoadingException(""Post link not found"")

        val postJson: List<SobreatsesuypVideoData> = rawList.drop(1).map { item ->
            val mapItem = item as Map<*, *>
            SobreatsesuypVideoData(
                title = mapItem[""title""] as? String,
                file  = mapItem[""file""]  as? String
            )
        }
        Log.d(""Kekik_${this.name}"", ""postJson » ${postJson}"")

        for (item in postJson) {
            if (item.file == null || item.title == null) continue

            val fileUrl   = ""${mainUrl}/playlist/${item.file.substring(1)}.txt""
            val videoData = app.post(fileUrl, referer = extRef).text

	        callback.invoke(
                ExtractorLink(
                    source  = this.name,
                    name    = ""${this.name} - ${item.title}"",
                    url     = videoData,
                    referer = extRef,
                    quality = Qualities.Unknown.value,
                    type    = INFER_TYPE
                )
            )
        }
    }

    data class SobreatsesuypVideoData(
        @JsonProperty(""title"") val title: String? = null,
        @JsonProperty(""file"")  val file: String?  = null
    )
}",KSEC_0584,['CWE-321: Hard-coded Cryptographic Key'],"['A02: Cryptographic Failures', 'A04: Insecure Design']",1
JetBrains__kotlin,aeb6402ce8b4efe74ccea6b387f5a94bd26541b0,compiler/testData/diagnostics/klibSerializationTests/privateTypeUsageInsideNonPrivateInlineFunction/topLevelPrivate/leakingPrivateClassThroughtTypecheckError.kt,.kt,Kirill Rakhman,kirill.rakhman@jetbrains.com,2025-05-06T14:24:30+02:00,[FIR] Move exposed type checkers to regular checkers and fix some false positives,1,Private,"private class Private

internal inline fun isPrivate(obj: Any): String = when (obj) {
    <!IR_PRIVATE_TYPE_USED_IN_NON_PRIVATE_INLINE_FUNCTION_ERROR!>is <!LESS_VISIBLE_TYPE_ACCESS_IN_INLINE_WARNING!>Private<!><!> -> ""isPrivate""
    else -> ""OK1""
}",KOT_03570,,,0
thunderbird__thunderbird-android,4ca78c9ebc94cb746d9fcac0564353e56302bd9e,legacy/core/src/main/java/com/fsck/k9/controller/NotificationOperations.kt,.kt,Wolf-Martell Montwé,wolf@thunderbird.net,2025-09-08T15:18:57+02:00,refactor: rename LegacyAccount to LegacyAccountDto,1,,"package com.fsck.k9.controller

import app.k9mail.legacy.mailstore.MessageStoreManager
import com.fsck.k9.notification.NotificationController
import com.fsck.k9.search.isNewMessages
import com.fsck.k9.search.isSingleFolder
import com.fsck.k9.search.isUnifiedFolders
import net.thunderbird.core.android.account.AccountManager
import net.thunderbird.core.android.account.LegacyAccountDto
import net.thunderbird.feature.search.legacy.LocalMessageSearch

internal class NotificationOperations(
    private val notificationController: NotificationController,
    private val accountManager: AccountManager,
    private val messageStoreManager: MessageStoreManager,
) {
    fun clearNotifications(search: LocalMessageSearch) {
        if (search.isUnifiedFolders) {
            clearUnifiedFoldersNotifications()
        } else if (search.isNewMessages) {
            clearAllNotifications()
        } else if (search.isSingleFolder) {
            val account = search.firstAccount() ?: return
            val folderId = search.folderIds.first()
            clearNotifications(account, folderId)
        } else {
            // TODO: Remove notifications when updating the message list. That way we can easily remove only
            //  notifications for messages that are currently displayed in the list.
        }
    }

    private fun clearUnifiedFoldersNotifications() {
        for (account in accountManager.getAccounts()) {
            val messageStore = messageStoreManager.getMessageStore(account)

            val folderIds = messageStore.getFolders(excludeLocalOnly = true) { folderDetails ->
                if (folderDetails.isIntegrate) folderDetails.id else null
            }.filterNotNull().toSet()

            if (folderIds.isNotEmpty()) {
                notificationController.clearNewMailNotifications(account) { messageReferences ->
                    messageReferences.filter { messageReference -> messageReference.folderId in folderIds }
                }
            }
        }
    }

    private fun clearAllNotifications() {
        for (account in accountManager.getAccounts()) {
            notificationController.clearNewMailNotifications(account, clearNewMessageState = false)
        }
    }

    private fun clearNotifications(account: LegacyAccountDto, folderId: Long) {
        notificationController.clearNewMailNotifications(account) { messageReferences ->
            messageReferences.filter { messageReference -> messageReference.folderId == folderId }
        }
    }

    private fun LocalMessageSearch.firstAccount(): LegacyAccountDto? {
        return accountManager.getAccount(accountUuids.first())
    }
}
",KSEC_1299,,,0
duckduckgo__Android,c935424df2b06b8f6188a35ac6440ef9019bd478,app-tracking-protection/vpn-impl/src/main/java/com/duckduckgo/mobile/android/vpn/bugreport/VpnAppTrackerListInfoCollector.kt,.kt,Aitor Viana,aitorvs@gmail.com,2022-10-29T15:40:30+01:00,Avoid reconfiguring VPN when game is installed (#2453),1,VpnAppTrackerListInfoCollector,"class VpnAppTrackerListInfoCollector @Inject constructor(
    private val vpnDatabase: VpnDatabase,
    private val appTrackerRepository: AppTrackerRepository,
    private val appCategoryDetector: AppCategoryDetector,
) : VpnStateCollectorPlugin {

    override val collectorName: String
        get() = ""vpnTrackerLists""

    override suspend fun collectVpnRelatedState(appPackageId: String?): JSONObject {
        return JSONObject().apply {
            put(APP_TRACKER_BLOCKLIST, vpnDatabase.vpnAppTrackerBlockingDao().getTrackerBlocklistMetadata()?.eTag.orEmpty())
            put(APP_EXCLUSION_LIST, vpnDatabase.vpnAppTrackerBlockingDao().getExclusionListMetadata()?.eTag.orEmpty())
            put(APP_EXCEPTION_RULE_LIST, vpnDatabase.vpnAppTrackerBlockingDao().getTrackerExceptionRulesMetadata()?.eTag.orEmpty())
            appPackageId?.let {
                put(PACKAGE_ID_IS_PROTECTED, isUnprotectedByDefault(appPackageId).toString())
                put(PACKAGE_ID_PROTECTION_OVERRIDEN, isProtectionOverriden(appPackageId).toString())
            }
        }
    }

    private fun isUnprotectedByDefault(appPackageId: String): Boolean {
        return appCategoryDetector.getAppCategory(appPackageId) is AppCategory.Game ||
            appTrackerRepository.getAppExclusionList().any { it.packageId == appPackageId }
    }

    private fun isProtectionOverriden(appPackageId: String): Boolean {
        return appTrackerRepository.getManualAppExclusionList().firstOrNull { it.packageId == appPackageId } != null
    }

    companion object {
        private const val APP_TRACKER_BLOCKLIST = ""appTrackerListEtag""
        private const val APP_EXCLUSION_LIST = ""appExclusionListEtag""
        private const val APP_EXCEPTION_RULE_LIST = ""appExceptionRuleListEtag""
        private const val PACKAGE_ID_IS_PROTECTED = ""reportedAppUnprotectedByDefault""
        private const val PACKAGE_ID_PROTECTION_OVERRIDEN = ""overridenDefaultProtection""
    }
}",KSEC_4840,['CWE-321: Hard-coded Cryptographic Key'],"['A02: Cryptographic Failures', 'A04: Insecure Design']",1
duckduckgo__Android,9fcccc7553fdae2627c6aad53addfd59969d116e,vpn/src/main/java/com/duckduckgo/mobile/android/vpn/ui/notification/DeviceShieldEnabledNotificationBuilder.kt,.kt,David González,malmstein@gmail.com,2022-01-12T16:56:16+01:00,"Update Style guide, remove old settings (#1632)",1,DeviceShieldEnabledNotificationBuilder,"class DeviceShieldEnabledNotificationBuilder {

    companion object {

        private const val VPN_FOREGROUND_SERVICE_NOTIFICATION_CHANNEL_ID = ""TrackerProtectionVPN""

        private fun registerOngoingNotificationChannel(context: Context) {
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                val channel =
                    NotificationChannel(VPN_FOREGROUND_SERVICE_NOTIFICATION_CHANNEL_ID, ""Tracker Protection Running"", NotificationManager.IMPORTANCE_MIN)
                val notificationManager = context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
                notificationManager.createNotificationChannel(channel)
            }
        }

        fun buildDeviceShieldEnabledNotification(
            context: Context,
            deviceShieldNotification: DeviceShieldNotificationFactory.DeviceShieldNotification,
            notificationPressHandler: OngoingNotificationPressedHandler
        ): Notification {

            registerOngoingNotificationChannel(context)

            val privacyReportIntent = DeviceShieldTrackerActivity.intent(context = context, onLaunchCallback = notificationPressHandler)
            val vpnShowDashboardPendingIntent: PendingIntent? = TaskStackBuilder.create(context).run {
                addNextIntentWithParentStack(privacyReportIntent)
                getPendingIntent(0, PendingIntent.FLAG_UPDATE_CURRENT)
            }

            val notificationLayout = RemoteViews(context.packageName, R.layout.notification_device_shield_enabled)
            notificationLayout.setTextViewText(R.id.deviceShieldNotificationHeader, deviceShieldNotification.title)

            return NotificationCompat.Builder(context, VPN_FOREGROUND_SERVICE_NOTIFICATION_CHANNEL_ID)
                .setSmallIcon(R.drawable.ic_device_shield_notification_logo)
                .setStyle(NotificationCompat.DecoratedCustomViewStyle())
                .setContentIntent(vpnShowDashboardPendingIntent)
                .setCustomContentView(notificationLayout)
                .setOngoing(true)
                .setPriority(NotificationCompat.PRIORITY_MIN)
                .setChannelId(VPN_FOREGROUND_SERVICE_NOTIFICATION_CHANNEL_ID)
                .build()
        }

        fun buildTrackersBlockedNotification(
            context: Context,
            deviceShieldNotification: DeviceShieldNotificationFactory.DeviceShieldNotification,
            notificationPressHandler: OngoingNotificationPressedHandler
        ): Notification {

            registerOngoingNotificationChannel(context)

            val privacyReportIntent = DeviceShieldTrackerActivity.intent(context = context, onLaunchCallback = notificationPressHandler)
            val vpnShowDashboardPendingIntent: PendingIntent? = TaskStackBuilder.create(context).run {
                addNextIntentWithParentStack(privacyReportIntent)
                getPendingIntent(0, PendingIntent.FLAG_UPDATE_CURRENT)
            }

            val notificationLayout = RemoteViews(context.packageName, R.layout.notification_device_shield_trackers)
            notificationLayout.setTextViewText(R.id.deviceShieldNotificationHeader, deviceShieldNotification.title)
            notificationLayout.setTextViewText(R.id.deviceShieldNotificationMessage, deviceShieldNotification.message)

            return NotificationCompat.Builder(context, VPN_FOREGROUND_SERVICE_NOTIFICATION_CHANNEL_ID)
                .setSmallIcon(R.drawable.ic_device_shield_notification_logo)
                .setStyle(NotificationCompat.DecoratedCustomViewStyle())
                .setContentIntent(vpnShowDashboardPendingIntent)
                .setCustomContentView(notificationLayout)
                .setPriority(NotificationCompat.PRIORITY_MIN)
                .setOngoing(true)
                .addAction(NotificationActionReportIssue.reportIssueNotificationAction(context))
                .setChannelId(VPN_FOREGROUND_SERVICE_NOTIFICATION_CHANNEL_ID)
                .build()
        }

    }
}",KSEC_5502,['CWE-321: Hard-coded Cryptographic Key'],"['A02: Cryptographic Failures', 'A04: Insecure Design']",1
thunderbird__thunderbird-android,31f4c4e3c2c32fbfb0e1f48d2d908380b0eddecb,mail/protocols/imap/src/test/java/com/fsck/k9/mail/store/imap/ImapServerSettingsValidatorTest.kt,.kt,Rafael Tonholo,rafael@tonholo.dev,2025-09-19T09:51:51-03:00,fix(smtp): outlook smtp not authenticating when enterprise or educational accounts,1,FakeOAuth2TokenProvider,"class FakeOAuth2TokenProvider(override val usernames: Set<String> = emptySet()) : OAuth2TokenProvider {
    override fun getToken(timeoutMillis: Long): String {
        return AUTHORIZATION_TOKEN
    }

    override fun invalidateToken() {
        throw UnsupportedOperationException(""not implemented"")
    }
}",KSEC_1150,,,0
JetBrains__kotlin,984cfc4e94fa3edcb4e48ecc175b565f2d0f96b3,analysis/low-level-api-fir/tests-gen/org/jetbrains/kotlin/analysis/low/level/api/fir/diagnostic/compiler/based/LLReversedDiagnosticsFe10TestGenerated.java,.java,Kirill Rakhman,kirill.rakhman@jetbrains.com,2025-07-08T15:26:10+02:00,[FIR] Fix false positive inline diagnostics in annotation call,1,Inline,"    public class Inline {
      @Test
      @TestMetadata(""accessingLessVisibleInAnnotation.kt"")
      public void testAccessingLessVisibleInAnnotation() {
        runTest(""compiler/testData/diagnostics/tests/inline/accessingLessVisibleInAnnotation.kt"");
      }

      @Test
      public void testAllFilesPresentInInline() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File(""compiler/testData/diagnostics/tests/inline""), Pattern.compile(""^(.+)\\.(kt|kts)$""), Pattern.compile(""^(.+)\\.(reversed|partialBody|fir|ll|latestLV)\\.kts?$""), true);
      }

      @Test
      @TestMetadata(""anonymousObjects.kt"")
      public void testAnonymousObjects() {
        runTest(""compiler/testData/diagnostics/tests/inline/anonymousObjects.kt"");
      }

      @Test
      @TestMetadata(""approximateReturnedAnonymousObjects.kt"")
      public void testApproximateReturnedAnonymousObjects() {
        runTest(""compiler/testData/diagnostics/tests/inline/approximateReturnedAnonymousObjects.kt"");
      }

      @Test
      @TestMetadata(""assignment.kt"")
      public void testAssignment() {
        runTest(""compiler/testData/diagnostics/tests/inline/assignment.kt"");
      }

      @Test
      @TestMetadata(""callableReferenceOnInlineParameter.kt"")
      public void testCallableReferenceOnInlineParameter() {
        runTest(""compiler/testData/diagnostics/tests/inline/callableReferenceOnInlineParameter.kt"");
      }

      @Test
      @TestMetadata(""capture.kt"")
      public void testCapture() {
        runTest(""compiler/testData/diagnostics/tests/inline/capture.kt"");
      }

      @Test
      @TestMetadata(""constructor.kt"")
      public void testConstructor() {
        runTest(""compiler/testData/diagnostics/tests/inline/constructor.kt"");
      }

      @Test
      @TestMetadata(""default.kt"")
      public void testDefault() {
        runTest(""compiler/testData/diagnostics/tests/inline/default.kt"");
      }

      @Test
      @TestMetadata(""defaultLambdaInlineSuspend.kt"")
      public void testDefaultLambdaInlineSuspend() {
        runTest(""compiler/testData/diagnostics/tests/inline/defaultLambdaInlineSuspend.kt"");
      }

      @Test
      @TestMetadata(""defaultLambdaInlining.kt"")
      public void testDefaultLambdaInlining() {
        runTest(""compiler/testData/diagnostics/tests/inline/defaultLambdaInlining.kt"");
      }

      @Test
      @TestMetadata(""exposingInternalTypesInProtected.kt"")
      public void testExposingInternalTypesInProtected() {
        runTest(""compiler/testData/diagnostics/tests/inline/exposingInternalTypesInProtected.kt"");
      }

      @Test
      @TestMetadata(""exposingInternalTypesInProtectedAfter.kt"")
      public void testExposingInternalTypesInProtectedAfter() {
        runTest(""compiler/testData/diagnostics/tests/inline/exposingInternalTypesInProtectedAfter.kt"");
      }

      @Test
      @TestMetadata(""exposingObjects.kt"")
      public void testExposingObjects() {
        runTest(""compiler/testData/diagnostics/tests/inline/exposingObjects.kt"");
      }

      @Test
      @TestMetadata(""exposingObjectsAfter.kt"")
      public void testExposingObjectsAfter() {
        runTest(""compiler/testData/diagnostics/tests/inline/exposingObjectsAfter.kt"");
      }

      @Test
      @TestMetadata(""exposingPrivateCallableReferenceInInternal.kt"")
      public void testExposingPrivateCallableReferenceInInternal() {
        runTest(""compiler/testData/diagnostics/tests/inline/exposingPrivateCallableReferenceInInternal.kt"");
      }

      @Test
      @TestMetadata(""exposingPrivateCallableReferenceInInternalAfter.kt"")
      public void testExposingPrivateCallableReferenceInInternalAfter() {
        runTest(""compiler/testData/diagnostics/tests/inline/exposingPrivateCallableReferenceInInternalAfter.kt"");
      }

      @Test
      @TestMetadata(""exposingPrivateCallableReferenceInPublic.kt"")
      public void testExposingPrivateCallableReferenceInPublic() {
        runTest(""compiler/testData/diagnostics/tests/inline/exposingPrivateCallableReferenceInPublic.kt"");
      }

      @Test
      @TestMetadata(""exposingPrivateTypeInInternal.kt"")
      public void testExposingPrivateTypeInInternal() {
        runTest(""compiler/testData/diagnostics/tests/inline/exposingPrivateTypeInInternal.kt"");
      }

      @Test
      @TestMetadata(""exposingPrivateTypeInInternalAfter.kt"")
      public void testExposingPrivateTypeInInternalAfter() {
        runTest(""compiler/testData/diagnostics/tests/inline/exposingPrivateTypeInInternalAfter.kt"");
      }

      @Test
      @TestMetadata(""exposingPrivateTypeInPublic.kt"")
      public void testExposingPrivateTypeInPublic() {
        runTest(""compiler/testData/diagnostics/tests/inline/exposingPrivateTypeInPublic.kt"");
      }

      @Test
      @TestMetadata(""exposingPrivateTypeInPublicAfter.kt"")
      public void testExposingPrivateTypeInPublicAfter() {
        runTest(""compiler/testData/diagnostics/tests/inline/exposingPrivateTypeInPublicAfter.kt"");
      }

      @Test
      @TestMetadata(""extensionOnFunction.kt"")
      public void testExtensionOnFunction() {
        runTest(""compiler/testData/diagnostics/tests/inline/extensionOnFunction.kt"");
      }

      @Test
      @TestMetadata(""forbidExtensionCallsOnInlineFunctionalParameters_after.kt"")
      public void testForbidExtensionCallsOnInlineFunctionalParameters_after() {
        runTest(""compiler/testData/diagnostics/tests/inline/forbidExtensionCallsOnInlineFunctionalParameters_after.kt"");
      }

      @Test
      @TestMetadata(""forbidExtensionCallsOnInlineFunctionalParameters_before.kt"")
      public void testForbidExtensionCallsOnInlineFunctionalParameters_before() {
        runTest(""compiler/testData/diagnostics/tests/inline/forbidExtensionCallsOnInlineFunctionalParameters_before.kt"");
      }

      @Test
      @TestMetadata(""fromInlineToNoInline.kt"")
      public void testFromInlineToNoInline() {
        runTest(""compiler/testData/diagnostics/tests/inline/fromInlineToNoInline.kt"");
      }

      @Test
      @TestMetadata(""functions.kt"")
      public void testFunctions() {
        runTest(""compiler/testData/diagnostics/tests/inline/functions.kt"");
      }

      @Test
      @TestMetadata(""inlineCallsPrivateInline.kt"")
      public void testInlineCallsPrivateInline() {
        runTest(""compiler/testData/diagnostics/tests/inline/inlineCallsPrivateInline.kt"");
      }

      @Test
      @TestMetadata(""inlineCallsStaticMethod.kt"")
      public void testInlineCallsStaticMethod() {
        runTest(""compiler/testData/diagnostics/tests/inline/inlineCallsStaticMethod.kt"");
      }

      @Test
      @TestMetadata(""inlineCallsStaticMethodFromOtherPackage.kt"")
      public void testInlineCallsStaticMethodFromOtherPackage() {
        runTest(""compiler/testData/diagnostics/tests/inline/inlineCallsStaticMethodFromOtherPackage.kt"");
      }

      @Test
      @TestMetadata(""inlineLambdaInDefaultInlineParameter.kt"")
      public void testInlineLambdaInDefaultInlineParameter() {
        runTest(""compiler/testData/diagnostics/tests/inline/inlineLambdaInDefaultInlineParameter.kt"");
      }

      @Test
      @TestMetadata(""inlineReified.kt"")
      public void testInlineReified() {
        runTest(""compiler/testData/diagnostics/tests/inline/inlineReified.kt"");
      }

      @Test
      @TestMetadata(""inlinedReturnInBranch.kt"")
      public void testInlinedReturnInBranch() {
        runTest(""compiler/testData/diagnostics/tests/inline/inlinedReturnInBranch.kt"");
      }

      @Test
      @TestMetadata(""invoke.kt"")
      public void testInvoke() {
        runTest(""compiler/testData/diagnostics/tests/inline/invoke.kt"");
      }

      @Test
      @TestMetadata(""isCheck.kt"")
      public void testIsCheck() {
        runTest(""compiler/testData/diagnostics/tests/inline/isCheck.kt"");
      }

      @Test
      @TestMetadata(""kt15410.kt"")
      public void testKt15410() {
        runTest(""compiler/testData/diagnostics/tests/inline/kt15410.kt"");
      }

      @Test
      @TestMetadata(""kt19679.kt"")
      public void testKt19679() {
        runTest(""compiler/testData/diagnostics/tests/inline/kt19679.kt"");
      }

      @Test
      @TestMetadata(""kt21177.kt"")
      public void testKt21177() {
        runTest(""compiler/testData/diagnostics/tests/inline/kt21177.kt"");
      }

      @Test
      @TestMetadata(""kt21177Warning.kt"")
      public void testKt21177Warning() {
        runTest(""compiler/testData/diagnostics/tests/inline/kt21177Warning.kt"");
      }

      @Test
      @TestMetadata(""kt4869.kt"")
      public void testKt4869() {
        runTest(""compiler/testData/diagnostics/tests/inline/kt4869.kt"");
      }

      @Test
      @TestMetadata(""labeled.kt"")
      public void testLabeled() {
        runTest(""compiler/testData/diagnostics/tests/inline/labeled.kt"");
      }

      @Test
      @TestMetadata(""labelsAndNonInlineUsage.kt"")
      public void testLabelsAndNonInlineUsage() {
        runTest(""compiler/testData/diagnostics/tests/inline/labelsAndNonInlineUsage.kt"");
      }

      @Test
      @TestMetadata(""lambdaCast.kt"")
      public void testLambdaCast() {
        runTest(""compiler/testData/diagnostics/tests/inline/lambdaCast.kt"");
      }

      @Test
      @TestMetadata(""localFun.kt"")
      public void testLocalFun() {
        runTest(""compiler/testData/diagnostics/tests/inline/localFun.kt"");
      }

      @Test
      @TestMetadata(""messagesForUnsupportedInInline.kt"")
      public void testMessagesForUnsupportedInInline() {
        runTest(""compiler/testData/diagnostics/tests/inline/messagesForUnsupportedInInline.kt"");
      }

      @Test
      @TestMetadata(""nonVirtualMembersWithInline.kt"")
      public void testNonVirtualMembersWithInline() {
        runTest(""compiler/testData/diagnostics/tests/inline/nonVirtualMembersWithInline.kt"");
      }

      @Test
      @TestMetadata(""notExposingPrivateInNoInlineDefault.kt"")
      public void testNotExposingPrivateInNoInlineDefault() {
        runTest(""compiler/testData/diagnostics/tests/inline/notExposingPrivateInNoInlineDefault.kt"");
      }

      @Test
      @TestMetadata(""notInlinableWithLabel.kt"")
      public void testNotInlinableWithLabel() {
        runTest(""compiler/testData/diagnostics/tests/inline/notInlinableWithLabel.kt"");
      }

      @Test
      @TestMetadata(""nothingToInline.kt"")
      public void testNothingToInline() {
        runTest(""compiler/testData/diagnostics/tests/inline/nothingToInline.kt"");
      }

      @Test
      @TestMetadata(""nullabilityOperations.kt"")
      public void testNullabilityOperations() {
        runTest(""compiler/testData/diagnostics/tests/inline/nullabilityOperations.kt"");
      }

      @Test
      @TestMetadata(""nullableFunction.kt"")
      public void testNullableFunction() {
        runTest(""compiler/testData/diagnostics/tests/inline/nullableFunction.kt"");
      }

      @Test
      @TestMetadata(""overrideWithInline.kt"")
      public void testOverrideWithInline() {
        runTest(""compiler/testData/diagnostics/tests/inline/overrideWithInline.kt"");
      }

      @Test
      @TestMetadata(""parenthesized.kt"")
      public void testParenthesized() {
        runTest(""compiler/testData/diagnostics/tests/inline/parenthesized.kt"");
      }

      @Test
      @TestMetadata(""privateClass.kt"")
      public void testPrivateClass() {
        runTest(""compiler/testData/diagnostics/tests/inline/privateClass.kt"");
      }

      @Test
      @TestMetadata(""privateOperatorsInInlineAfter.kt"")
      public void testPrivateOperatorsInInlineAfter() {
        runTest(""compiler/testData/diagnostics/tests/inline/privateOperatorsInInlineAfter.kt"");
      }

      @Test
      @TestMetadata(""privateOperatorsInInlineBefore.kt"")
      public void testPrivateOperatorsInInlineBefore() {
        runTest(""compiler/testData/diagnostics/tests/inline/privateOperatorsInInlineBefore.kt"");
      }

      @Test
      @TestMetadata(""propagation.kt"")
      public void testPropagation() {
        runTest(""compiler/testData/diagnostics/tests/inline/propagation.kt"");
      }

      @Test
      @TestMetadata(""protectedCallError.kt"")
      public void testProtectedCallError() {
        runTest(""compiler/testData/diagnostics/tests/inline/protectedCallError.kt"");
      }

      @Test
      @TestMetadata(""protectedJavaFieldInInline.kt"")
      public void testProtectedJavaFieldInInline() {
        runTest(""compiler/testData/diagnostics/tests/inline/protectedJavaFieldInInline.kt"");
      }

      @Test
      @TestMetadata(""protectedMembers.kt"")
      public void testProtectedMembers() {
        runTest(""compiler/testData/diagnostics/tests/inline/protectedMembers.kt"");
      }

      @Test
      @TestMetadata(""protectedMembersFromSuper.kt"")
      public void testProtectedMembersFromSuper() {
        runTest(""compiler/testData/diagnostics/tests/inline/protectedMembersFromSuper.kt"");
      }

      @Test
      @TestMetadata(""protectedStaticAndInline.kt"")
      public void testProtectedStaticAndInline() {
        runTest(""compiler/testData/diagnostics/tests/inline/protectedStaticAndInline.kt"");
      }

      @Test
      @TestMetadata(""publishedApi.kt"")
      public void testPublishedApi() {
        runTest(""compiler/testData/diagnostics/tests/inline/publishedApi.kt"");
      }

      @Test
      @TestMetadata(""publishedApiSubstitutionOverride.kt"")
      public void testPublishedApiSubstitutionOverride() {
        runTest(""compiler/testData/diagnostics/tests/inline/publishedApiSubstitutionOverride.kt"");
      }

      @Test
      @TestMetadata(""recursion.kt"")
      public void testRecursion() {
        runTest(""compiler/testData/diagnostics/tests/inline/recursion.kt"");
      }

      @Test
      @TestMetadata(""recursiveTypeInPrivateInlineFunction.kt"")
      public void testRecursiveTypeInPrivateInlineFunction() {
        runTest(""compiler/testData/diagnostics/tests/inline/recursiveTypeInPrivateInlineFunction.kt"");
      }

      @Test
      @TestMetadata(""returnedAnonymousObjects_2.kt"")
      public void testReturnedAnonymousObjects_2() {
        runTest(""compiler/testData/diagnostics/tests/inline/returnedAnonymousObjects_2.kt"");
      }

      @Test
      @TestMetadata(""returns.kt"")
      public void testReturns() {
        runTest(""compiler/testData/diagnostics/tests/inline/returns.kt"");
      }

      @Test
      @TestMetadata(""sam.kt"")
      public void testSam() {
        runTest(""compiler/testData/diagnostics/tests/inline/sam.kt"");
      }

      @Test
      @TestMetadata(""stringTemplate.kt"")
      public void testStringTemplate() {
        runTest(""compiler/testData/diagnostics/tests/inline/stringTemplate.kt"");
      }

      @Test
      @TestMetadata(""superCall.kt"")
      public void testSuperCall() {
        runTest(""compiler/testData/diagnostics/tests/inline/superCall.kt"");
      }

      @Test
      @TestMetadata(""superCallDepecation.kt"")
      public void testSuperCallDepecation() {
        runTest(""compiler/testData/diagnostics/tests/inline/superCallDepecation.kt"");
      }

      @Test
      @TestMetadata(""superCallDepecationWarning.kt"")
      public void testSuperCallDepecationWarning() {
        runTest(""compiler/testData/diagnostics/tests/inline/superCallDepecationWarning.kt"");
      }

      @Test
      @TestMetadata(""superCallFromMultipleSubclasses.kt"")
      public void testSuperCallFromMultipleSubclasses() {
        runTest(""compiler/testData/diagnostics/tests/inline/superCallFromMultipleSubclasses.kt"");
      }

      @Test
      @TestMetadata(""superProperty.kt"")
      public void testSuperProperty() {
        runTest(""compiler/testData/diagnostics/tests/inline/superProperty.kt"");
      }

      @Test
      @TestMetadata(""usageIsNotInlinable.kt"")
      public void testUsageIsNotInlinable() {
        runTest(""compiler/testData/diagnostics/tests/inline/usageIsNotInlinable.kt"");
      }

      @Test
      @TestMetadata(""valueClasses.kt"")
      public void testValueClasses() {
        runTest(""compiler/testData/diagnostics/tests/inline/valueClasses.kt"");
      }

      @Test
      @TestMetadata(""valueOfKFunctionTypeAsArgumentOfInlineFunction.kt"")
      public void testValueOfKFunctionTypeAsArgumentOfInlineFunction() {
        runTest(""compiler/testData/diagnostics/tests/inline/valueOfKFunctionTypeAsArgumentOfInlineFunction.kt"");
      }

      @Test
      @TestMetadata(""vararg.kt"")
      public void testVararg() {
        runTest(""compiler/testData/diagnostics/tests/inline/vararg.kt"");
      }

      @Test
      @TestMetadata(""virtualMemberInEnum.kt"")
      public void testVirtualMemberInEnum() {
        runTest(""compiler/testData/diagnostics/tests/inline/virtualMemberInEnum.kt"");
      }

      @Test
      @TestMetadata(""virtualValInEnum.kt"")
      public void testVirtualValInEnum() {
        runTest(""compiler/testData/diagnostics/tests/inline/virtualValInEnum.kt"");
      }

      @Test
      @TestMetadata(""when.kt"")
      public void testWhen() {
        runTest(""compiler/testData/diagnostics/tests/inline/when.kt"");
      }

      @Test
      @TestMetadata(""wrongUsage.kt"")
      public void testWrongUsage() {
        runTest(""compiler/testData/diagnostics/tests/inline/wrongUsage.kt"");
      }

      @Nested
      @TestMetadata(""compiler/testData/diagnostics/tests/inline/binaryExpressions"")
      @TestDataPath(""$PROJECT_ROOT"")
      public class BinaryExpressions {
        @Test
        public void testAllFilesPresentInBinaryExpressions() {
          KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File(""compiler/testData/diagnostics/tests/inline/binaryExpressions""), Pattern.compile(""^(.+)\\.(kt|kts)$""), Pattern.compile(""^(.+)\\.(reversed|partialBody|fir|ll|latestLV)\\.kts?$""), true);
        }

        @Test
        @TestMetadata(""andOr.kt"")
        public void testAndOr() {
          runTest(""compiler/testData/diagnostics/tests/inline/binaryExpressions/andOr.kt"");
        }

        @Test
        @TestMetadata(""arrayAccess.kt"")
        public void testArrayAccess() {
          runTest(""compiler/testData/diagnostics/tests/inline/binaryExpressions/arrayAccess.kt"");
        }

        @Test
        @TestMetadata(""assignment.kt"")
        public void testAssignment() {
          runTest(""compiler/testData/diagnostics/tests/inline/binaryExpressions/assignment.kt"");
        }

        @Test
        @TestMetadata(""comparison.kt"")
        public void testComparison() {
          runTest(""compiler/testData/diagnostics/tests/inline/binaryExpressions/comparison.kt"");
        }

        @Test
        @TestMetadata(""componentAccess.kt"")
        public void testComponentAccess() {
          runTest(""compiler/testData/diagnostics/tests/inline/binaryExpressions/componentAccess.kt"");
        }

        @Test
        @TestMetadata(""contains.kt"")
        public void testContains() {
          runTest(""compiler/testData/diagnostics/tests/inline/binaryExpressions/contains.kt"");
        }

        @Test
        @TestMetadata(""mathOperations.kt"")
        public void testMathOperations() {
          runTest(""compiler/testData/diagnostics/tests/inline/binaryExpressions/mathOperations.kt"");
        }

        @Test
        @TestMetadata(""rangeTo.kt"")
        public void testRangeTo() {
          runTest(""compiler/testData/diagnostics/tests/inline/binaryExpressions/rangeTo.kt"");
        }
      }

      @Nested
      @TestMetadata(""compiler/testData/diagnostics/tests/inline/nonLocalBreakContinue"")
      @TestDataPath(""$PROJECT_ROOT"")
      public class NonLocalBreakContinue {
        @Test
        public void testAllFilesPresentInNonLocalBreakContinue() {
          KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File(""compiler/testData/diagnostics/tests/inline/nonLocalBreakContinue""), Pattern.compile(""^(.+)\\.(kt|kts)$""), Pattern.compile(""^(.+)\\.(reversed|partialBody|fir|ll|latestLV)\\.kts?$""), true);
        }

        @Test
        @TestMetadata(""baseFeatureInteractions.kt"")
        public void testBaseFeatureInteractions() {
          runTest(""compiler/testData/diagnostics/tests/inline/nonLocalBreakContinue/baseFeatureInteractions.kt"");
        }

        @Test
        @TestMetadata(""defaultLambdaInline.kt"")
        public void testDefaultLambdaInline() {
          runTest(""compiler/testData/diagnostics/tests/inline/nonLocalBreakContinue/defaultLambdaInline.kt"");
        }

        @Test
        @TestMetadata(""inlineExtensionFunction.kt"")
        public void testInlineExtensionFunction() {
          runTest(""compiler/testData/diagnostics/tests/inline/nonLocalBreakContinue/inlineExtensionFunction.kt"");
        }

        @Test
        @TestMetadata(""lambdaAsGeneric.kt"")
        public void testLambdaAsGeneric() {
          runTest(""compiler/testData/diagnostics/tests/inline/nonLocalBreakContinue/lambdaAsGeneric.kt"");
        }

        @Test
        @TestMetadata(""lambdaAsNonFunction.kt"")
        public void testLambdaAsNonFunction() {
          runTest(""compiler/testData/diagnostics/tests/inline/nonLocalBreakContinue/lambdaAsNonFunction.kt"");
        }

        @Test
        @TestMetadata(""lambdaCallWithSuper.kt"")
        public void testLambdaCallWithSuper() {
          runTest(""compiler/testData/diagnostics/tests/inline/nonLocalBreakContinue/lambdaCallWithSuper.kt"");
        }

        @Test
        @TestMetadata(""lambdaWithReceiver.kt"")
        public void testLambdaWithReceiver() {
          runTest(""compiler/testData/diagnostics/tests/inline/nonLocalBreakContinue/lambdaWithReceiver.kt"");
        }

        @Test
        @TestMetadata(""nestedLambdas.kt"")
        public void testNestedLambdas() {
          runTest(""compiler/testData/diagnostics/tests/inline/nonLocalBreakContinue/nestedLambdas.kt"");
        }

        @Test
        @TestMetadata(""withGuards.kt"")
        public void testWithGuards() {
          runTest(""compiler/testData/diagnostics/tests/inline/nonLocalBreakContinue/withGuards.kt"");
        }

        @Test
        @TestMetadata(""withOverrideByInline.kt"")
        public void testWithOverrideByInline() {
          runTest(""compiler/testData/diagnostics/tests/inline/nonLocalBreakContinue/withOverrideByInline.kt"");
        }
      }

      @Nested
      @TestMetadata(""compiler/testData/diagnostics/tests/inline/nonLocalReturns"")
      @TestDataPath(""$PROJECT_ROOT"")
      public class NonLocalReturns {
        @Test
        public void testAllFilesPresentInNonLocalReturns() {
          KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File(""compiler/testData/diagnostics/tests/inline/nonLocalReturns""), Pattern.compile(""^(.+)\\.(kt|kts)$""), Pattern.compile(""^(.+)\\.(reversed|partialBody|fir|ll|latestLV)\\.kts?$""), true);
        }

        @Test
        @TestMetadata(""anonymousObjects.kt"")
        public void testAnonymousObjects() {
          runTest(""compiler/testData/diagnostics/tests/inline/nonLocalReturns/anonymousObjects.kt"");
        }

        @Test
        @TestMetadata(""anonymousObjectsNested.kt"")
        public void testAnonymousObjectsNested() {
          runTest(""compiler/testData/diagnostics/tests/inline/nonLocalReturns/anonymousObjectsNested.kt"");
        }

        @Test
        @TestMetadata(""explicitReturnType.kt"")
        public void testExplicitReturnType() {
          runTest(""compiler/testData/diagnostics/tests/inline/nonLocalReturns/explicitReturnType.kt"");
        }

        @Test
        @TestMetadata(""fromOnlyLocal.kt"")
        public void testFromOnlyLocal() {
          runTest(""compiler/testData/diagnostics/tests/inline/nonLocalReturns/fromOnlyLocal.kt"");
        }

        @Test
        @TestMetadata(""inlineLambda.kt"")
        public void testInlineLambda() {
          runTest(""compiler/testData/diagnostics/tests/inline/nonLocalReturns/inlineLambda.kt"");
        }

        @Test
        @TestMetadata(""labeledReturn.kt"")
        public void testLabeledReturn() {
          runTest(""compiler/testData/diagnostics/tests/inline/nonLocalReturns/labeledReturn.kt"");
        }

        @Test
        @TestMetadata(""lambdaAsGeneric.kt"")
        public void testLambdaAsGeneric() {
          runTest(""compiler/testData/diagnostics/tests/inline/nonLocalReturns/lambdaAsGeneric.kt"");
        }

        @Test
        @TestMetadata(""lambdaAsNonFunction.kt"")
        public void testLambdaAsNonFunction() {
          runTest(""compiler/testData/diagnostics/tests/inline/nonLocalReturns/lambdaAsNonFunction.kt"");
        }

        @Test
        @TestMetadata(""lambdaWithGlobalReturnsInsideOnlyLocalOne.kt"")
        public void testLambdaWithGlobalReturnsInsideOnlyLocalOne() {
          runTest(""compiler/testData/diagnostics/tests/inline/nonLocalReturns/lambdaWithGlobalReturnsInsideOnlyLocalOne.kt"");
        }

        @Test
        @TestMetadata(""localFun.kt"")
        public void testLocalFun() {
          runTest(""compiler/testData/diagnostics/tests/inline/nonLocalReturns/localFun.kt"");
        }

        @Test
        @TestMetadata(""nestedNonLocals.kt"")
        public void testNestedNonLocals() {
          runTest(""compiler/testData/diagnostics/tests/inline/nonLocalReturns/nestedNonLocals.kt"");
        }

        @Test
        @TestMetadata(""noInlineAnnotation.kt"")
        public void testNoInlineAnnotation() {
          runTest(""compiler/testData/diagnostics/tests/inline/nonLocalReturns/noInlineAnnotation.kt"");
        }

        @Test
        @TestMetadata(""noInlineLambda.kt"")
        public void testNoInlineLambda() {
          runTest(""compiler/testData/diagnostics/tests/inline/nonLocalReturns/noInlineLambda.kt"");
        }

        @Test
        @TestMetadata(""nonInlinedClass.kt"")
        public void testNonInlinedClass() {
          runTest(""compiler/testData/diagnostics/tests/inline/nonLocalReturns/nonInlinedClass.kt"");
        }

        @Test
        @TestMetadata(""nonLocalReturnInSubstitutionOverride.kt"")
        public void testNonLocalReturnInSubstitutionOverride() {
          runTest(""compiler/testData/diagnostics/tests/inline/nonLocalReturns/nonLocalReturnInSubstitutionOverride.kt"");
        }

        @Test
        @TestMetadata(""onlyLocalReturnLambda.kt"")
        public void testOnlyLocalReturnLambda() {
          runTest(""compiler/testData/diagnostics/tests/inline/nonLocalReturns/onlyLocalReturnLambda.kt"");
        }

        @Test
        @TestMetadata(""onlyLocalReturnLambdaBinaryExpr.kt"")
        public void testOnlyLocalReturnLambdaBinaryExpr() {
          runTest(""compiler/testData/diagnostics/tests/inline/nonLocalReturns/onlyLocalReturnLambdaBinaryExpr.kt"");
        }

        @Test
        @TestMetadata(""propertyAccessorsAndConstructor.kt"")
        public void testPropertyAccessorsAndConstructor() {
          runTest(""compiler/testData/diagnostics/tests/inline/nonLocalReturns/propertyAccessorsAndConstructor.kt"");
        }

        @Test
        @TestMetadata(""toOnlyLocal.kt"")
        public void testToOnlyLocal() {
          runTest(""compiler/testData/diagnostics/tests/inline/nonLocalReturns/toOnlyLocal.kt"");
        }
      }

      @Nested
      @TestMetadata(""compiler/testData/diagnostics/tests/inline/nonPublicMember"")
      @TestDataPath(""$PROJECT_ROOT"")
      public class NonPublicMember {
        @Test
        public void testAllFilesPresentInNonPublicMember() {
          KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File(""compiler/testData/diagnostics/tests/inline/nonPublicMember""), Pattern.compile(""^(.+)\\.(kt|kts)$""), Pattern.compile(""^(.+)\\.(reversed|partialBody|fir|ll|latestLV)\\.kts?$""), true);
        }

        @Test
        @TestMetadata(""delegatedConstructorOfPrivateClass.kt"")
        public void testDelegatedConstructorOfPrivateClass() {
          runTest(""compiler/testData/diagnostics/tests/inline/nonPublicMember/delegatedConstructorOfPrivateClass.kt"");
        }

        @Test
        @TestMetadata(""enumMemberInAnnotation.kt"")
        public void testEnumMemberInAnnotation() {
          runTest(""compiler/testData/diagnostics/tests/inline/nonPublicMember/enumMemberInAnnotation.kt"");
        }

        @Test
        @TestMetadata(""inAnnotation.kt"")
        public void testInAnnotation() {
          runTest(""compiler/testData/diagnostics/tests/inline/nonPublicMember/inAnnotation.kt"");
        }

        @Test
        @TestMetadata(""inNonPublicClass.kt"")
        public void testInNonPublicClass() {
          runTest(""compiler/testData/diagnostics/tests/inline/nonPublicMember/inNonPublicClass.kt"");
        }

        @Test
        @TestMetadata(""inNonPublicInnerClass.kt"")
        public void testInNonPublicInnerClass() {
          runTest(""compiler/testData/diagnostics/tests/inline/nonPublicMember/inNonPublicInnerClass.kt"");
        }

        @Test
        @TestMetadata(""inPackage.kt"")
        public void testInPackage() {
          runTest(""compiler/testData/diagnostics/tests/inline/nonPublicMember/inPackage.kt"");
        }

        @Test
        @TestMetadata(""inPublicClass.kt"")
        public void testInPublicClass() {
          runTest(""compiler/testData/diagnostics/tests/inline/nonPublicMember/inPublicClass.kt"");
        }

        @Test
        @TestMetadata(""kt14887.kt"")
        public void testKt14887() {
          runTest(""compiler/testData/diagnostics/tests/inline/nonPublicMember/kt14887.kt"");
        }

        @Test
        @TestMetadata(""kt55179.kt"")
        public void testKt55179() {
          runTest(""compiler/testData/diagnostics/tests/inline/nonPublicMember/kt55179.kt"");
        }

        @Test
        @TestMetadata(""localClass.kt"")
        public void testLocalClass() {
          runTest(""compiler/testData/diagnostics/tests/inline/nonPublicMember/localClass.kt"");
        }

        @Test
        @TestMetadata(""localClass2.kt"")
        public void testLocalClass2() {
          runTest(""compiler/testData/diagnostics/tests/inline/nonPublicMember/localClass2.kt"");
        }

        @Test
        @TestMetadata(""localFun.kt"")
        public void testLocalFun() {
          runTest(""compiler/testData/diagnostics/tests/inline/nonPublicMember/localFun.kt"");
        }

        @Test
        @TestMetadata(""protectedInlineInsideInternal.kt"")
        public void testProtectedInlineInsideInternal() {
          runTest(""compiler/testData/diagnostics/tests/inline/nonPublicMember/protectedInlineInsideInternal.kt"");
        }

        @Test
        @TestMetadata(""publishedApi.kt"")
        public void testPublishedApi() {
          runTest(""compiler/testData/diagnostics/tests/inline/nonPublicMember/publishedApi.kt"");
        }
      }

      @Nested
      @TestMetadata(""compiler/testData/diagnostics/tests/inline/property"")
      @TestDataPath(""$PROJECT_ROOT"")
      public class Property {
        @Test
        public void testAllFilesPresentInProperty() {
          KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File(""compiler/testData/diagnostics/tests/inline/property""), Pattern.compile(""^(.+)\\.(kt|kts)$""), Pattern.compile(""^(.+)\\.(reversed|partialBody|fir|ll|latestLV)\\.kts?$""), true);
        }

        @Test
        @TestMetadata(""invoke.kt"")
        public void testInvoke() {
          runTest(""compiler/testData/diagnostics/tests/inline/property/invoke.kt"");
        }

        @Test
        @TestMetadata(""propertyWithBackingField.kt"")
        public void testPropertyWithBackingField() {
          runTest(""compiler/testData/diagnostics/tests/inline/property/propertyWithBackingField.kt"");
        }

        @Test
        @TestMetadata(""unsupportedConstruction.kt"")
        public void testUnsupportedConstruction() {
          runTest(""compiler/testData/diagnostics/tests/inline/property/unsupportedConstruction.kt"");
        }

        @Test
        @TestMetadata(""virtualProperty.kt"")
        public void testVirtualProperty() {
          runTest(""compiler/testData/diagnostics/tests/inline/property/virtualProperty.kt"");
        }
      }

      @Nested
      @TestMetadata(""compiler/testData/diagnostics/tests/inline/regressions"")
      @TestDataPath(""$PROJECT_ROOT"")
      public class Regressions {
        @Test
        public void testAllFilesPresentInRegressions() {
          KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File(""compiler/testData/diagnostics/tests/inline/regressions""), Pattern.compile(""^(.+)\\.(kt|kts)$""), Pattern.compile(""^(.+)\\.(reversed|partialBody|fir|ll|latestLV)\\.kts?$""), true);
        }

        @Test
        @TestMetadata(""kt4341.kt"")
        public void testKt4341() {
          runTest(""compiler/testData/diagnostics/tests/inline/regressions/kt4341.kt"");
        }
      }

      @Nested
      @TestMetadata(""compiler/testData/diagnostics/tests/inline/unaryExpressions"")
      @TestDataPath(""$PROJECT_ROOT"")
      public class UnaryExpressions {
        @Test
        public void testAllFilesPresentInUnaryExpressions() {
          KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File(""compiler/testData/diagnostics/tests/inline/unaryExpressions""), Pattern.compile(""^(.+)\\.(kt|kts)$""), Pattern.compile(""^(.+)\\.(reversed|partialBody|fir|ll|latestLV)\\.kts?$""), true);
        }

        @Test
        @TestMetadata(""mathOperation.kt"")
        public void testMathOperation() {
          runTest(""compiler/testData/diagnostics/tests/inline/unaryExpressions/mathOperation.kt"");
        }

        @Test
        @TestMetadata(""notOnCall.kt"")
        public void testNotOnCall() {
          runTest(""compiler/testData/diagnostics/tests/inline/unaryExpressions/notOnCall.kt"");
        }

        @Test
        @TestMetadata(""notOperation.kt"")
        public void testNotOperation() {
          runTest(""compiler/testData/diagnostics/tests/inline/unaryExpressions/notOperation.kt"");
        }
      }
    }",KOT_02988,,,0
duckduckgo__Android,79a7e0108c1e1d25bd9fad2d810f24af56e232c9,app-tracking-protection/vpn-internal/src/main/java/com/duckduckgo/vpn/internal/feature/trackers/DeleteTrackersDebugReceiver.kt,.kt,Aitor Viana,aitorvs@gmail.com,2023-05-02T12:53:20+01:00,Support changes in the tracker entities (#3115),1,,"/*
 * Copyright (c) 2021 DuckDuckGo
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.duckduckgo.vpn.internal.feature.trackers

import android.content.Context
import android.content.Intent
import com.duckduckgo.app.di.AppCoroutineScope
import com.duckduckgo.di.scopes.VpnScope
import com.duckduckgo.mobile.android.vpn.service.VpnServiceCallbacks
import com.duckduckgo.mobile.android.vpn.state.VpnStateMonitor.VpnStopReason
import com.duckduckgo.mobile.android.vpn.store.VpnDatabase
import com.duckduckgo.vpn.internal.feature.InternalFeatureReceiver
import com.squareup.anvil.annotations.ContributesMultibinding
import javax.inject.Inject
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.launch
import logcat.logcat

/**
 * This receiver allows deletion of previously seen trackers.
 *
 * $ adb shell am broadcast -a delete-trackers
 *
 */
class DeleteTrackersDebugReceiver(
    context: Context,
    receiver: (Intent) -> Unit,
) : InternalFeatureReceiver(context, receiver) {

    override fun intentAction(): String = ACTION

    companion object {
        private const val ACTION = ""delete-trackers""

        fun createIntent(): Intent = Intent(ACTION)
    }
}

@ContributesMultibinding(VpnScope::class)
class DeleteTrackersDebugReceiverRegister @Inject constructor(
    private val context: Context,
    private val vpnDatabase: VpnDatabase,
    @AppCoroutineScope private val appCoroutineScope: CoroutineScope,
) : VpnServiceCallbacks {
    private val className: String
        get() = DeleteTrackersDebugReceiver::class.java.simpleName

    private var receiver: DeleteTrackersDebugReceiver? = null

    override fun onVpnStarted(coroutineScope: CoroutineScope) {
        logcat { ""Debug receiver $className registered"" }

        receiver?.unregister()

        receiver = DeleteTrackersDebugReceiver(context) {
            appCoroutineScope.launch {
                vpnDatabase.vpnTrackerDao().deleteAllTrackers()
            }
        }.apply { register() }
    }

    override fun onVpnStopped(
        coroutineScope: CoroutineScope,
        vpnStopReason: VpnStopReason,
    ) {
        receiver?.unregister()
    }
}
",KSEC_3804,['CWE-321: Hard-coded Cryptographic Key'],"['A02: Cryptographic Failures', 'A04: Insecure Design']",1
JetBrains__kotlin,f23be1c7bfe1e6093fdc4e8eb970ec343cd44a17,compiler/fir/fir2ir/src/org/jetbrains/kotlin/fir/backend/Fir2IrCommonMemberStorage.kt,.kt,Yan Zhulanow,yan.zhulanow@jetbrains.com,2025-05-15T19:31:18+09:00,[Analysis API] Fix handling of code fragments referencing local classes,1,Fir2IrCommonMemberStorage,"class Fir2IrCommonMemberStorage {
    val lock: IrLock = IrLock()

    val classCache: MutableMap<FirRegularClass, IrClassSymbol> = mutableMapOf()
    val notFoundClassCache: ConcurrentHashMap<ConeClassLikeLookupTag, IrClass> = ConcurrentHashMap()

    val typeParameterCache: MutableMap<FirTypeParameter, IrTypeParameter> = mutableMapOf()

    val enumEntryCache: MutableMap<FirEnumEntry, IrEnumEntrySymbol> = mutableMapOf()

    val localClassCache: MutableMap<FirClass, IrClass> = mutableMapOf()
    val localCallableCache: MutableList<Fir2IrScopeCache> = mutableListOf()

    val functionCache: ConcurrentHashMap<FirFunction, IrSimpleFunctionSymbol> = ConcurrentHashMap()
    val dataClassGeneratedFunctionsCache: ConcurrentHashMap<FirClass, Fir2IrDeclarationStorage.DataClassGeneratedFunctionsStorage> =
        ConcurrentHashMap()

    val constructorCache: ConcurrentHashMap<FirConstructor, IrConstructorSymbol> = ConcurrentHashMap()

    val propertyCache: ConcurrentHashMap<FirProperty, IrPropertySymbol> = ConcurrentHashMap()
    val syntheticPropertyCache: ConcurrentHashMap<SyntheticPropertyKey, IrPropertySymbol> = ConcurrentHashMap()
    val getterForPropertyCache: ConcurrentHashMap<IrSymbol, IrSimpleFunctionSymbol> = ConcurrentHashMap()
    val setterForPropertyCache: ConcurrentHashMap<IrSymbol, IrSimpleFunctionSymbol> = ConcurrentHashMap()
    val backingFieldForPropertyCache: ConcurrentHashMap<IrPropertySymbol, IrFieldSymbol> = ConcurrentHashMap()
    val propertyForBackingFieldCache: ConcurrentHashMap<IrFieldSymbol, IrPropertySymbol> = ConcurrentHashMap()
    val delegateVariableForPropertyCache: ConcurrentHashMap<IrLocalDelegatedPropertySymbol, IrVariableSymbol> = ConcurrentHashMap()

    val irForFirSessionDependantDeclarationMap: MutableMap<Fir2IrDeclarationStorage.FakeOverrideIdentifier, IrSymbol> = mutableMapOf()

    /**
     * This map contains information about classes, which implement interfaces by delegation
     *
     * ```
     * class Some(val a: A, b: B) : A by a, B by b
     * ```
     *
     * delegatedClassesMap = {
     *     Some -> {
     *         A -> backingField of val a,
     *         B -> field for delegate b
     *     }
     * }
     */
    val delegatedClassesInfo: MutableMap<IrClassSymbol, MutableMap<IrClassSymbol, IrFieldSymbol>> = mutableMapOf()
    val firClassesWithInheritanceByDelegation: MutableSet<FirClass> = mutableSetOf()

    /**
     * Contains information about synthetic methods generated for data and value classes
     * It will be used to generate bodies of those methods after fir2ir conversion is over
     */
    val generatedDataValueClassSyntheticFunctions: MutableMap<IrClass, DataValueClassGeneratedMembersInfo> = mutableMapOf()

    data class DataValueClassGeneratedMembersInfo(
        val components: Fir2IrComponents,
        val firClass: FirRegularClass,
        val origin: IrDeclarationOrigin,
        val generatedFunctions: MutableList<IrSimpleFunction>
    )
}",KOT_03236,,,0
square__leakcanary,6f88c425a9d262c31133d0f2ab4bcb7230c25517,shark/shark/src/main/java/shark/internal/GcRootProvider.kt,.kt,Pierre-Yves Ricau,py@squareup.com,2023-05-19T11:40:54-07:00,Update to AGP 8 and Kotlin 1.8,1,GcRootProvider,"internal class GcRootProvider(
  private val graph: HeapGraph,
  referenceMatchers: List<ReferenceMatcher>
) {

  private val jniGlobalReferenceMatchers: Map<String, ReferenceMatcher>

  init {
    val jniGlobals = mutableMapOf<String, ReferenceMatcher>()
    referenceMatchers.filterFor(graph).forEach { referenceMatcher ->
      val pattern = referenceMatcher.pattern
      if (pattern is NativeGlobalVariablePattern) {
        jniGlobals[pattern.className] = referenceMatcher
      }
    }
    this.jniGlobalReferenceMatchers = jniGlobals
  }

  class GcRootReference(
    val gcRoot: GcRoot,
    val isLowPriority: Boolean,
    val matchedLibraryLeak: LibraryLeakReferenceMatcher?,
  )

  fun provideGcRoots(): Sequence<GcRootReference> {
    return sortedGcRoots().asSequence().mapNotNull { (heapObject, gcRoot) ->
      when (gcRoot) {
        // Note: in sortedGcRoots we already filter out any java frame that has an associated
        // thread. These are the remaining ones (shouldn't be any, this is just in case).
        is JavaFrame -> {
          GcRootReference(
            gcRoot,
            isLowPriority = true,
            matchedLibraryLeak = null
          )
        }
        is JniGlobal -> {
          val referenceMatcher = when (heapObject) {
            is HeapClass -> jniGlobalReferenceMatchers[heapObject.name]
            is HeapInstance -> jniGlobalReferenceMatchers[heapObject.instanceClassName]
            is HeapObjectArray -> jniGlobalReferenceMatchers[heapObject.arrayClassName]
            is HeapPrimitiveArray -> jniGlobalReferenceMatchers[heapObject.arrayClassName]
          }
          if (referenceMatcher !is IgnoredReferenceMatcher) {
            if (referenceMatcher is LibraryLeakReferenceMatcher) {
              GcRootReference(
                gcRoot,
                isLowPriority = true,
                matchedLibraryLeak = referenceMatcher
              )
            } else {
              GcRootReference(
                gcRoot,
                isLowPriority = false,
                matchedLibraryLeak = null
              )
            }
          } else {
            null
          }
        }
        else -> {
          GcRootReference(
            gcRoot,
            isLowPriority = false,
            matchedLibraryLeak = null
          )
        }
      }
    }
  }

  /**
   * Sorting GC roots to get stable shortest path
   * Once sorted all ThreadObject Gc Roots are located before JavaLocalPattern Gc Roots.
   * This ensures ThreadObjects are visited before JavaFrames, and threadsBySerialNumber can be
   * built before JavaFrames.
   */
  private fun sortedGcRoots(): List<Pair<HeapObject, GcRoot>> {
    val rootClassName: (HeapObject) -> String = { graphObject ->
      when (graphObject) {
        is HeapClass -> {
          graphObject.name
        }
        is HeapInstance -> {
          graphObject.instanceClassName
        }
        is HeapObjectArray -> {
          graphObject.arrayClassName
        }
        is HeapPrimitiveArray -> {
          graphObject.arrayClassName
        }
      }
    }

    val threadSerialNumbers =
      ThreadObjects.getThreadObjects(graph).map { it.threadSerialNumber }.toSet()

    return graph.gcRoots
      .filter { gcRoot ->
        // GC roots sometimes reference objects that don't exist in the heap dump
        // See https://github.com/square/leakcanary/issues/1516
        graph.objectExists(gcRoot.id) &&
          // Only include java frames that do not have a corresponding ThreadObject.
          // JavaLocalReferenceReader will insert the other java frames.
          !(gcRoot is JavaFrame && gcRoot.threadSerialNumber in threadSerialNumbers)
      }
      .map { graph.findObjectById(it.id) to it }
      .sortedWith { (graphObject1, root1), (graphObject2, root2) ->
        // Sorting based on pattern name first, but we want ThreadObjects to be first because
        // they'll later enqueue java frames via JavaLocalReferenceReader in the low priority queue
        // and we want those java frames at the head of the low priority queue.
        if (root1 is ThreadObject && root2 !is ThreadObject) {
          return@sortedWith -1
        } else if (root1 !is ThreadObject && root2 is ThreadObject) {
          return@sortedWith 1
        }
        val gcRootTypeComparison = root2::class.java.name.compareTo(root1::class.java.name)
        if (gcRootTypeComparison != 0) {
          gcRootTypeComparison
        } else {
          rootClassName(graphObject1).compareTo(rootClassName(graphObject2))
        }
      }
  }
}",KOT_04082,,,0
JetBrains__kotlin,54afc5731f4eb44a78a3ab4de76e986c476edb9c,libraries/stdlib/test/collections/CollectionTest.kt,.kt,Ivan Kochurkin,ivan.kochurkin@jetbrains.com,2025-09-09T21:26:08+02:00,Fix misc code to get rid of useless type conversions or suppress `REDUNDANT_CALL_OF_CONVERSION_METHOD`,1,CollectionTest,"class CollectionTest {

    @Test fun createListWithInit() {
        val list = List(3) { index -> ""x"".repeat(index + 1) }
        assertEquals(3, list.size)
        assertEquals(listOf(""x"", ""xx"", ""xxx""), list)
    }

    @Test fun joinTo() {
        val data = listOf(""foo"", ""bar"")
        val buffer = StringBuilder()
        data.joinTo(buffer, ""-"", ""{"", ""}"")
        assertEquals(""{foo-bar}"", buffer.toString())
    }

    @Test fun joinToString() {
        val data = listOf(""foo"", ""bar"")
        val text = data.joinToString(""-"", ""<"", "">"")
        assertEquals(""<foo-bar>"", text)

        val mixed = listOf('a', ""b"", StringBuilder(""c""), null, ""d"", 'e', 'f')
        val text2 = mixed.joinToString(limit = 4, truncated = ""*"")
        assertEquals(""a, b, c, null, *"", text2)
    }

    @Test fun filterNotNull() {
        val data = listOf(null, ""foo"", null, ""bar"")
        val foo = data.filterNotNull()

        assertEquals(2, foo.size)
        assertEquals(listOf(""foo"", ""bar""), foo)

        assertStaticAndRuntimeTypeIs<List<String>>(foo)
    }


    @Test fun flatMap() {
        val source = listOf(null, ""foo"", ""bar"")
        val result1 = source.flatMap { it.orEmpty().asSequence() }
        val result2 = source.flatMap { it.orEmpty().asIterable() }

        val expected = ""foobar"".toList()
        assertEquals(expected, result1)
        assertEquals(expected, result2)
    }

    @Test fun flatMapIndexed() {
        val source = listOf(null, ""foo"", ""bar"")
        val result1 = source.flatMapIndexed { index, it -> it.orEmpty().take(index + 1).asSequence() }
        val result2 = source.flatMapIndexed { index, it -> it.orEmpty().take(index + 1).asIterable() }

        val expected = ""fobar"".toList()
        assertEquals(expected, result1)
        assertEquals(expected, result2)
    }

    /*
    @Test fun mapNotNull() {
        val data = listOf(null, ""foo"", null, ""bar"")
        val foo = data.mapNotNull { it.length() }
        assertEquals(2, foo.size())
        assertEquals(listOf(3, 3), foo)

        assertTrue {
            foo is List<Int>
        }
    }
    */

    @Test fun listOfNotNull() {
        val l1: List<Int> = listOfNotNull(null)
        assertTrue(l1.isEmpty())

        val s: String? = ""value""
        val l2: List<String> = listOfNotNull(s)
        assertEquals(s, l2.single())

        val l3: List<String> = listOfNotNull(""value1"", null, ""value2"")
        assertEquals(listOf(""value1"", ""value2""), l3)
    }

    @Test fun setOfNotNull() {
        val l1: Set<Int> = setOfNotNull(null)
        assertTrue(l1.isEmpty())

        val s: String? = ""value""
        val l2: Set<String> = setOfNotNull(s)
        assertEquals(s, l2.single())

        val l3: Set<String> = setOfNotNull(""value1"", null, ""value2"")
        assertEquals(setOf(""value1"", ""value2""), l3)
    }

    @Test fun filterIntoSet() {
        val data = listOf(""foo"", ""bar"")
        val foo = data.filterTo(hashSetOf<String>()) { it.startsWith(""f"") }

        assertTrue {
            foo.all { it.startsWith(""f"") }
        }
        assertEquals(1, foo.size)
        assertEquals(hashSetOf(""foo""), foo)

        assertStaticAndRuntimeTypeIs<HashSet<String>>(foo)
    }

    @Test fun filterIsInstanceList() {
        val values: List<Any> = listOf(1, 2, 3.0, ""abc"", ""cde"")

        val numberValues: List<Number> = values.filterIsInstance<Number>()
        assertEquals(listOf(1, 2, 3.0), numberValues)

        // doesn't distinguish double from int in JS
//        val doubleValues: List<Double> = values.filterIsInstance<Double>()
//        assertEquals(listOf(3.0), doubleValues)

        val stringValues: List<String> = values.filterIsInstance<String>()
        assertEquals(listOf(""abc"", ""cde""), stringValues)

        // is Any doesn't work in JS, see KT-7665
//        val anyValues: List<Any> = values.filterIsInstance<Any>()
//        assertEquals(values.toList(), anyValues)

        val charValues: List<Char> = values.filterIsInstance<Char>()
        assertEquals(0, charValues.size)
    }

    @Test fun filterIsInstanceArray() {
        val src: Array<Any> = arrayOf(1, 2, 3.0, ""abc"", ""cde"")

        val numberValues: List<Number> = src.filterIsInstance<Number>()
        assertEquals(listOf(1, 2, 3.0), numberValues)

        // doesn't distinguish double from int in JS
//        val doubleValues: List<Double> = src.filterIsInstance<Double>()
//        assertEquals(listOf(3.0), doubleValues)

        val stringValues: List<String> = src.filterIsInstance<String>()
        assertEquals(listOf(""abc"", ""cde""), stringValues)

        // is Any doesn't work in JS, see KT-7665
//        val anyValues: List<Any> = src.filterIsInstance<Any>()
//        assertEquals(src.toList(), anyValues)

        val charValues: List<Char> = src.filterIsInstance<Char>()
        assertEquals(0, charValues.size)
    }

    @Test fun foldIndexed() {
        expect(42) {
            val numbers = listOf(1, 2, 3, 4)
            numbers.foldIndexed(0) { index, a, b -> index * (a + b) }
        }

        expect(0) {
            val numbers = arrayListOf<Int>()
            numbers.foldIndexed(0) { index, a, b -> index * (a + b) }
        }

        expect(""11234"") {
            val numbers = listOf(1, 2, 3, 4)
            numbers.map { it.toString() }.foldIndexed("""") { index, a, b -> if (index == 0) a + b + b else a + b }
        }
    }

    @Test fun foldIndexedWithDifferentTypes() {
        expect(10) {
            val numbers = listOf(""a"", ""ab"", ""abc"")
            numbers.foldIndexed(1) { index, a, b -> a + b.length + index }
        }

        expect(""11223344"") {
            val numbers = listOf(1, 2, 3, 4)
            numbers.foldIndexed("""") { index, a, b -> a + b + (index + 1) }
        }
    }

    @Test fun foldIndexedWithNonCommutativeOperation() {
        expect(4) {
            val numbers = listOf(1, 2, 3)
            numbers.foldIndexed(7) { index, a, b -> index + a - b }
        }
    }

    @Test fun foldRightIndexed() {
        expect(""12343210"") {
            val numbers = listOf(1, 2, 3, 4)
            numbers.map { it.toString() }.foldRightIndexed("""") { index, a, b -> a + b + index }
        }
    }

    @Test fun foldRightIndexedWithDifferentTypes() {
        expect(""12343210"") {
            val numbers = listOf(1, 2, 3, 4)
            numbers.foldRightIndexed("""") { index, a, b -> """" + a + b + index }
        }
    }

    @Test fun foldRightIndexedWithNonCommutativeOperation() {
        expect(-4) {
            val numbers = listOf(1, 2, 3)
            numbers.foldRightIndexed(7) { index, a, b -> index + a - b }
        }
    }

    @Test fun fold() {
        // lets calculate the sum of some numbers
        expect(10) {
            val numbers = listOf(1, 2, 3, 4)
            numbers.fold(0) { a, b -> a + b }
        }

        expect(0) {
            val numbers = arrayListOf<Int>()
            numbers.fold(0) { a, b -> a + b }
        }

        // lets concatenate some strings
        expect(""1234"") {
            val numbers = listOf(1, 2, 3, 4)
            numbers.map { it.toString() }.fold("""") { a, b -> a + b }
        }
    }

    @Test fun foldWithDifferentTypes() {
        expect(7) {
            val numbers = listOf(""a"", ""ab"", ""abc"")
            numbers.fold(1) { a, b -> a + b.length }
        }

        expect(""1234"") {
            val numbers = listOf(1, 2, 3, 4)
            numbers.fold("""") { a, b -> a + b }
        }
    }

    @Test fun foldWithNonCommutativeOperation() {
        expect(1) {
            val numbers = listOf(1, 2, 3)
            numbers.fold(7) { a, b -> a - b }
        }
    }

    @Test fun foldRight() {
        expect(""1234"") {
            val numbers = listOf(1, 2, 3, 4)
            numbers.map { it.toString() }.foldRight("""") { a, b -> a + b }
        }
    }

    @Test fun foldRightWithDifferentTypes() {
        expect(""1234"") {
            val numbers = listOf(1, 2, 3, 4)
            numbers.foldRight("""") { a, b -> """" + a + b }
        }
    }

    @Test fun foldRightWithNonCommutativeOperation() {
        expect(-5) {
            val numbers = listOf(1, 2, 3)
            numbers.foldRight(7) { a, b -> a - b }
        }
    }

    @Test
    fun zipTransform() {
        expect(listOf(""ab"", ""bc"", ""cd"")) {
            listOf(""a"", ""b"", ""c"").zip(listOf(""b"", ""c"", ""d"")) { a, b -> a + b }
        }
    }

    @Test
    fun zip() {
        expect(listOf(""a"" to ""b"", ""b"" to ""c"", ""c"" to ""d"")) {
            listOf(""a"", ""b"", ""c"").zip(listOf(""b"", ""c"", ""d""))
        }
    }

    @Test fun partition() {
        val data = listOf(""foo"", ""bar"", ""something"", ""xyz"")
        val pair = data.partition { it.length == 3 }

        assertEquals(listOf(""foo"", ""bar"", ""xyz""), pair.first, ""pair.first"")
        assertEquals(listOf(""something""), pair.second, ""pair.second"")
    }

    @Test fun reduceIndexed() {
        expect(""123"") {
            val list = listOf(""1"", ""2"", ""3"", ""4"")
            list.reduceIndexed { index, a, b -> if (index == 3) a else a + b }
        }

        expect(5) {
            listOf(2, 3).reduceIndexed { index, acc: Number, e ->
                assertEquals(1, index)
                assertEquals(2, acc)
                assertEquals(3, e)
                acc.toInt() + e
            }
        }

        assertFailsWith<UnsupportedOperationException> {
            arrayListOf<Int>().reduceIndexed { index, a, b -> index + a + b }
        }
    }

    @Test fun reduceIndexedOrNull() {
        expect(""123"") {
            val list = listOf(""1"", ""2"", ""3"", ""4"")
            list.reduceIndexedOrNull { index, a, b -> if (index == 3) a else a + b }
        }

        expect(5) {
            listOf(2, 3).reduceIndexedOrNull { index, acc: Number, e ->
                assertEquals(1, index)
                assertEquals(2, acc)
                assertEquals(3, e)
                acc.toInt() + e
            }
        }

        expect(null, { arrayListOf<Int>().reduceIndexedOrNull { index, a, b -> index + a + b } })
    }

    @Test fun reduceRightIndexed() {
        expect(""234"") {
            val list = listOf(""1"", ""2"", ""3"", ""4"")
            list.reduceRightIndexed { index, a, b -> if (index == 0) b else a + b }
        }

        expect(1) {
            listOf(2, 3).reduceRightIndexed { index, e, acc: Number ->
                assertEquals(0, index)
                assertEquals(3, acc)
                assertEquals(2, e)
                acc.toInt() - e
            }
        }

        assertFailsWith<UnsupportedOperationException> {
            arrayListOf<Int>().reduceRightIndexed { index, a, b -> index + a + b }
        }
    }

    @Test fun reduceRightIndexedOrNull() {
        expect(""234"") {
            val list = listOf(""1"", ""2"", ""3"", ""4"")
            list.reduceRightIndexedOrNull { index, a, b -> if (index == 0) b else a + b }
        }

        expect(1) {
            listOf(2, 3).reduceRightIndexedOrNull { index, e, acc: Number ->
                assertEquals(0, index)
                assertEquals(3, acc)
                assertEquals(2, e)
                acc.toInt() - e
            }
        }

        expect(null, { arrayListOf<Int>().reduceRightIndexedOrNull { index, a, b -> index + a + b } })
    }

    @Test fun reduce() {
        expect(""1234"") {
            val list = listOf(""1"", ""2"", ""3"", ""4"")
            list.reduce { a, b -> a + b }
        }

        assertFailsWith<UnsupportedOperationException> {
            arrayListOf<Int>().reduce { a, b -> a + b }
        }
    }

    @Test fun reduceOrNull() {
        expect(""1234"") {
            val list = listOf(""1"", ""2"", ""3"", ""4"")
            list.reduceOrNull { a, b -> a + b }
        }

        expect(null, { arrayListOf<Int>().reduceOrNull { a, b -> a + b } })
    }

    @Test fun reduceRight() {
        expect(""1234"") {
            val list = listOf(""1"", ""2"", ""3"", ""4"")
            list.reduceRight { a, b -> a + b }
        }

        assertFailsWith<UnsupportedOperationException> {
            arrayListOf<Int>().reduceRight { a, b -> a + b }
        }
    }

    @Test fun reduceRightOrNull() {
        expect(""1234"") {
            val list = listOf(""1"", ""2"", ""3"", ""4"")
            list.reduceRightOrNull { a, b -> a + b }
        }

        expect(null, { arrayListOf<Int>().reduceRightOrNull { a, b -> a + b } })
    }

    @Test
    fun scan() {
        for (size in 0 until 4) {
            val expected = listOf("""", ""0"", ""01"", ""012"", ""0123"").take(size + 1)
            assertEquals(expected, List(size) { it }.scan("""") { acc, e -> acc + e })
            assertEquals(expected, List(size) { it }.runningFold("""") { acc, e -> acc + e })
        }
    }

    @Test
    fun scanIndexed() {
        for (size in 0 until 4) {
            val expected = listOf(""+"", ""+[0: a]"", ""+[0: a][1: b]"", ""+[0: a][1: b][2: c]"", ""+[0: a][1: b][2: c][3: d]"").take(size + 1)
            assertEquals(expected, List(size) { 'a' + it }.scanIndexed(""+"") { index, acc, e -> ""$acc[$index: $e]"" })
            assertEquals(expected, List(size) { 'a' + it }.runningFoldIndexed(""+"") { index, acc, e -> ""$acc[$index: $e]"" })
        }
    }

    @Test
    fun runningReduce() {
        for (size in 0 until 4) {
            val expected = listOf(0, 1, 3, 6).take(size)
            assertEquals(expected, List(size) { it }.runningReduce { acc, e -> acc + e })
        }
    }

    @Test
    fun runningReduceIndexed() {
        for (size in 0 until 4) {
            val expected = listOf(0, 1, 6, 27).take(size)
            assertEquals(expected, List(size) { it }.runningReduceIndexed { index, acc, e -> index * (acc + e) })
        }
    }

    @Test fun groupBy() {
        val words = listOf(""a"", ""abc"", ""ab"", ""def"", ""abcd"")
        val byLength = words.groupBy { it.length }
        assertEquals(4, byLength.size)

        // verify that order of keys is preserved
        assertEquals(listOf(
                1 to listOf(""a""),
                3 to listOf(""abc"", ""def""),
                2 to listOf(""ab""),
                4 to listOf(""abcd"")
        ), byLength.toList())

        val l3 = byLength[3].orEmpty()
        assertEquals(listOf(""abc"", ""def""), l3)
    }

    @Test fun groupByKeysAndValues() {
        val nameToTeam = listOf(""Alice"" to ""Marketing"", ""Bob"" to ""Sales"", ""Carol"" to ""Marketing"")
        val namesByTeam = nameToTeam.groupBy({ it.second }, { it.first })
        assertEquals(
                listOf(
                    ""Marketing"" to listOf(""Alice"", ""Carol""),
                    ""Sales"" to listOf(""Bob"")
                ),
                namesByTeam.toList())


        val mutableNamesByTeam = nameToTeam.groupByTo(HashMap(), { it.second }, { it.first })
        assertEquals(namesByTeam, mutableNamesByTeam)
    }

    @Test fun associateWith() {
        val items = listOf(""Alice"", ""Bob"", ""Carol"")
        val itemsWithTheirLength = items.associateWith { it.length }

        assertEquals(mapOf(""Alice"" to 5, ""Bob"" to 3, ""Carol"" to 5), itemsWithTheirLength)

        val updatedLength =
            items.drop(1).associateWithTo(itemsWithTheirLength.toMutableMap()) { name -> name.lowercase().count { it in ""aeuio"" }}

        assertEquals(mapOf(""Alice"" to 5, ""Bob"" to 1, ""Carol"" to 2), updatedLength)
    }

    @Test fun plusRanges() {
        val range1 = 1..3
        val range2 = 4..7
        val combined = range1 + range2
        assertEquals((1..7).toList(), combined)
    }

    @Test fun mapRanges() {
        val range = (1..3).map { it * 2 }
        assertEquals(listOf(2, 4, 6), range)
    }

    fun testPlus(doPlus: (List<String>) -> List<String>) {
        val list = listOf(""foo"", ""bar"")
        val list2: List<String> = doPlus(list)
        assertEquals(listOf(""foo"", ""bar""), list)
        assertEquals(listOf(""foo"", ""bar"", ""cheese"", ""wine""), list2)
    }

    @Test fun plusElement() = testPlus { it + ""cheese"" + ""wine"" }
    @Test fun plusCollection() = testPlus { it + listOf(""cheese"", ""wine"") }
    @Test fun plusArray() = testPlus { it + arrayOf(""cheese"", ""wine"") }
    @Test fun plusSequence() = testPlus { it + sequenceOf(""cheese"", ""wine"") }

    @Test fun plusCollectionBug() {
        val list = listOf(""foo"", ""bar"") + listOf(""cheese"", ""wine"")
        assertEquals(listOf(""foo"", ""bar"", ""cheese"", ""wine""), list)
    }

    @Test fun plusCollectionInference() {
        val listOfLists = listOf(listOf(""s""))
        val elementList = listOf(""a"")
        val result: List<List<String>> = listOfLists.plusElement(elementList)
        assertEquals(listOf(listOf(""s""), listOf(""a"")), result, ""should be list + element"")

        val listOfAny = listOf<Any>(""a"") + listOf<Any>(""b"")
        assertEquals(listOf(""a"", ""b""), listOfAny,  ""should be list + list"")

        val listOfAnyAndList = listOf<Any>(""a"") + listOf<Any>(""b"") as Any
        assertEquals(listOf(""a"", listOf(""b"")), listOfAnyAndList, ""should be list + Any"")
    }

    @Test fun plusAssign() {
        // lets use a mutable variable of readonly list
        var l: List<String> = listOf(""cheese"")
        val lOriginal = l
        l += ""foo""
        l += listOf(""beer"")
        l += arrayOf(""cheese"", ""wine"")
        l += sequenceOf(""bar"", ""foo"")
        assertEquals(listOf(""cheese"", ""foo"", ""beer"", ""cheese"", ""wine"", ""bar"", ""foo""), l)
        assertTrue(l !== lOriginal)

        val ml = arrayListOf(""cheese"")
        ml += ""foo""
        ml += listOf(""beer"")
        ml += arrayOf(""cheese"", ""wine"")
        ml += sequenceOf(""bar"", ""foo"")
        assertEquals(l, ml)
    }


    private fun testMinus(expected: List<String>? = null, doMinus: (List<String>) -> List<String>) {
        val a = listOf(""foo"", ""bar"", ""bar"")
        val b: List<String> = doMinus(a)
        val expected_ = expected ?: listOf(""foo"")
        assertEquals(expected_, b.toList())
    }

    @Test fun minusElement() = testMinus(expected = listOf(""foo"", ""bar"")) { it - ""bar"" - ""zoo"" }
    @Test fun minusCollection() = testMinus { it - listOf(""bar"", ""zoo"") }
    @Test fun minusArray() = testMinus { it - arrayOf(""bar"", ""zoo"") }
    @Test fun minusSequence() = testMinus { it - sequenceOf(""bar"", ""zoo"") }

    @Test fun minusIsEager() {
        val source = listOf(""foo"", ""bar"")
        val list = arrayListOf<String>()
        val result = source - list

        list += ""foo""
        assertEquals(source, result)
        list += ""bar""
        assertEquals(source, result)
    }

    @Test fun minusAssign() {
        // lets use a mutable variable of readonly list
        val data: List<String> = listOf(""cheese"", ""foo"", ""beer"", ""cheese"", ""wine"")
        var l = data
        l -= ""cheese""
        assertEquals(listOf(""foo"", ""beer"", ""cheese"", ""wine""), l)
        l = data
        l -= listOf(""cheese"", ""beer"")
        assertEquals(listOf(""foo"", ""wine""), l)
        l -= arrayOf(""wine"", ""bar"")
        assertEquals(listOf(""foo""), l)

        val ml = arrayListOf(""cheese"", ""cheese"", ""foo"", ""beer"", ""cheese"", ""wine"")
        ml -= ""cheese""
        assertEquals(listOf(""cheese"", ""foo"", ""beer"", ""cheese"", ""wine""), ml)
        ml -= listOf(""cheese"", ""beer"")
        assertEquals(listOf(""foo"", ""wine""), ml)
        ml -= arrayOf(""wine"", ""bar"")
        assertEquals(listOf(""foo""), ml)
    }



    @Test fun requireNoNulls() {
        val data = arrayListOf<String?>(""foo"", ""bar"")
        val notNull = data.requireNoNulls()
        assertEquals(listOf(""foo"", ""bar""), notNull)

        val hasNulls = listOf(""foo"", null, ""bar"")

        assertFailsWith<IllegalArgumentException> {
            // should throw an exception as we have a null
            hasNulls.requireNoNulls()
        }
    }

    @Test fun reverseInPlace() {
        val data = arrayListOf<String>()
        data.reverse()
        assertTrue(data.isEmpty())

        data.add(""foo"")
        data.reverse()
        assertEquals(listOf(""foo""), data)

        data.add(""bar"")
        data.reverse()
        assertEquals(listOf(""bar"", ""foo""), data)

        data.add(""zoo"")
        data.reverse()
        assertEquals(listOf(""zoo"", ""foo"", ""bar""), data)
    }

    @Test fun reversed() {
        val data = listOf(""foo"", ""bar"")
        val rev = data.reversed()
        assertEquals(listOf(""bar"", ""foo""), rev)
        assertNotEquals(data, rev)
    }


    @Test fun drop() {
        val coll = listOf(""foo"", ""bar"", ""abc"")
        assertEquals(listOf(""bar"", ""abc""), coll.drop(1))
        assertEquals(listOf(""abc""), coll.drop(2))
    }

    @Test fun dropWhile() {
        val coll = listOf(""foo"", ""bar"", ""abc"")
        assertEquals(listOf(""bar"", ""abc""), coll.dropWhile { it.startsWith(""f"") })
    }

    @Test fun dropLast() {
        val coll = listOf(""foo"", ""bar"", ""abc"")
        assertEquals(coll, coll.dropLast(0))
        assertEquals(emptyList<String>(), coll.dropLast(coll.size))
        assertEquals(emptyList<String>(), coll.dropLast(coll.size + 1))
        assertEquals(listOf(""foo"", ""bar""), coll.dropLast(1))
        assertEquals(listOf(""foo""), coll.dropLast(2))

        assertFails { coll.dropLast(-1) }
    }

    @Test fun dropLastWhile() {
        val coll = listOf(""Foo"", ""bare"", ""abc"" )
        assertEquals(coll, coll.dropLastWhile { false })
        assertEquals(listOf<String>(), coll.dropLastWhile { true })
        assertEquals(listOf(""Foo"", ""bare""), coll.dropLastWhile { it.length < 4 })
        assertEquals(listOf(""Foo""), coll.dropLastWhile { it.all { it in 'a'..'z' } })
    }

    @Test fun take() {
        val coll = listOf(""foo"", ""bar"", ""abc"")
        assertEquals(emptyList<String>(), coll.take(0))
        assertEquals(listOf(""foo""), coll.take(1))
        assertEquals(listOf(""foo"", ""bar""), coll.take(2))
        assertEquals(coll, coll.take(coll.size))
        assertEquals(coll, coll.take(coll.size + 1))

        assertFails { coll.take(-1) }
    }

    @Test fun takeWhile() {
        val coll = listOf(""foo"", ""bar"", ""abc"")
        assertEquals(emptyList<String>(), coll.takeWhile { false })
        assertEquals(coll, coll.takeWhile { true })
        assertEquals(listOf(""foo""), coll.takeWhile { it.startsWith(""f"") })
        assertEquals(listOf(""foo"", ""bar"", ""abc""), coll.takeWhile { it.length == 3 })
    }

    @Test fun takeLast() {
        val coll = listOf(""foo"", ""bar"", ""abc"")

        assertEquals(emptyList<String>(), coll.takeLast(0))
        assertEquals(listOf(""abc""), coll.takeLast(1))
        assertEquals(listOf(""bar"", ""abc""), coll.takeLast(2))
        assertEquals(coll, coll.takeLast(coll.size))
        assertEquals(coll, coll.takeLast(coll.size + 1))

        assertFails { coll.takeLast(-1) }

        val collWithoutRandomAccess = object : List<String> by coll {}
        assertEquals(listOf(""abc""), collWithoutRandomAccess.takeLast(1))
        assertEquals(listOf(""bar"", ""abc""), collWithoutRandomAccess.takeLast(2))
    }

    @Test fun takeLastWhile() {
        val coll = listOf(""foo"", ""bar"", ""abc"")
        assertEquals(emptyList<String>(), coll.takeLastWhile { false })
        assertEquals(coll, coll.takeLastWhile { true })
        assertEquals(listOf(""abc""), coll.takeLastWhile { it.startsWith(""a"") })
        assertEquals(listOf(""bar"", ""abc""), coll.takeLastWhile { it[0] < 'c' })
    }

    @Test fun copyToArray() {
        val data = listOf(""foo"", ""bar"")
        val arr = data.toTypedArray()
        println(""Got array ${arr}"")
        assertEquals(2, arr.size)
    }

    @Test fun count() {
        val data = listOf(""foo"", ""bar"")
        assertEquals(2, data.count())
        assertEquals(3, hashSetOf(12, 14, 15).count())
        assertEquals(0, ArrayList<Double>().count())
    }

    @Test fun first() {
        val data = listOf(""foo"", ""bar"")
        assertEquals(""foo"", data.first())
        assertEquals(15, listOf(15, 19, 20, 25).first())
        assertEquals('a', listOf('a').first())
        assertFails { arrayListOf<Int>().first() }
    }

    @Test fun last() {
        val data = listOf(""foo"", ""bar"")
        assertEquals(""bar"", data.last())
        assertEquals(25, listOf(15, 19, 20, 25).last())
        assertEquals('a', listOf('a').last())
        assertFails { arrayListOf<Int>().last() }
    }

    @Test fun random() {
        val list = List(100) { it }
        val set = list.toSet()
        listOf(list, set).forEach { collection: Collection<Int> ->
            val tosses = List(10) { collection.random() }
            assertTrue(tosses.distinct().size > 1, ""Should be some distinct elements in $tosses"")

            val seed = Random.nextInt()
            val random1 = Random(seed)
            val random2 = Random(seed)

            val tosses1 = List(10) { collection.random(random1) }
            val tosses2 = List(10) { collection.random(random2) }

            assertEquals(tosses1, tosses2)
        }

        listOf(""x"").let { singletonList ->
            val tosses = List(10) { singletonList.random() }
            assertEquals(singletonList, tosses.distinct())
        }

        assertFailsWith<NoSuchElementException> { emptyList<Any>().random() }
    }

    @Test fun randomOrNull() {
        val list = List(100) { it }
        val set = list.toSet()
        listOf(list, set).forEach { collection: Collection<Int> ->
            val tosses = List(10) { collection.randomOrNull() }
            assertTrue(tosses.distinct().size > 1, ""Should be some distinct elements in $tosses"")

            val seed = Random.nextInt()
            val random1 = Random(seed)
            val random2 = Random(seed)

            val tosses1 = List(10) { collection.randomOrNull(random1) }
            val tosses2 = List(10) { collection.randomOrNull(random2) }

            assertEquals(tosses1, tosses2)
        }

        listOf(""x"").let { singletonList ->
            val tosses = List(10) { singletonList.randomOrNull() }
            assertEquals(singletonList, tosses.distinct())
        }

        assertNull(emptyList<Any>().randomOrNull())
    }

    @Test fun subscript() {
        val list = arrayListOf(""foo"", ""bar"")
        assertEquals(""foo"", list[0])
        assertEquals(""bar"", list[1])

        // lists throw an exception if out of range
        assertFails {
            @Suppress(""UNUSED_VARIABLE"")
            val outOfBounds = list[2]
        }

        // lets try update the list
        list[0] = ""new""
        list[1] = ""thing""

        // lists don't allow you to set past the end of the list
        assertFails {
            list[2] = ""works""
        }

        list.add(""works"")
        assertEquals(listOf(""new"", ""thing"", ""works""), list)
    }

    @Test fun indices() {
        val data = listOf(""foo"", ""bar"")
        val indices = data.indices
        assertEquals(0, indices.start)
        assertEquals(1, indices.endInclusive)
        assertEquals(0..data.size - 1, indices)
    }

    @Test fun contains() {
        assertFalse(hashSetOf<Int>().contains(12))
        assertTrue(listOf(15, 19, 20).contains(15))

        assertTrue(hashSetOf(45, 14, 13).toIterable().contains(14))
    }

    @Test fun minOrNull() {
        expect(null, { listOf<Int>().minOrNull() })
        expect(1, { listOf(1).minOrNull() })
        expect(2, { listOf(2, 3).minOrNull() })
        expect(2000000000000, { listOf(3000000000000, 2000000000000).minOrNull() })
        expect('a', { listOf('a', 'b').minOrNull() })
        expect(""a"", { listOf(""a"", ""b"").minOrNull() })
        expect(null, { listOf<Int>().asSequence().minOrNull() })
        expect(2, { listOf(2, 3).asSequence().minOrNull() })

        assertIsNegativeZero(listOf(0.0, -0.0).shuffled().minOrNull()!!)
        assertIsNegativeZero(listOf(0.0F, -0.0F).shuffled().minOrNull()!!.toDouble())
    }

    @Test fun max() {
        expect(null, { listOf<Int>().maxOrNull() })
        expect(1, { listOf(1).maxOrNull() })
        expect(3, { listOf(2, 3).maxOrNull() })
        expect(3000000000000, { listOf(3000000000000, 2000000000000).maxOrNull() })
        expect('b', { listOf('a', 'b').maxOrNull() })
        expect(""b"", { listOf(""a"", ""b"").maxOrNull() })
        expect(null, { listOf<Int>().asSequence().maxOrNull() })
        expect(3, { listOf(2, 3).asSequence().maxOrNull() })

        assertIsPositiveZero(listOf(0.0, -0.0).shuffled().maxOrNull()!!)
        assertIsPositiveZero(listOf(0.0F, -0.0F).shuffled().maxOrNull()!!.toDouble())
    }

    @Test fun minWithOrNull() {
        expect(null, { listOf<Int>().minWithOrNull(naturalOrder()) })
        expect(1, { listOf(1).minWithOrNull(naturalOrder()) })
        expect(""a"", { listOf(""a"", ""B"").minWithOrNull(STRING_CASE_INSENSITIVE_ORDER) })
        expect(""a"", { listOf(""a"", ""B"").asSequence().minWithOrNull(STRING_CASE_INSENSITIVE_ORDER) })
    }

    @Test fun maxWithOrNull() {
        expect(null, { listOf<Int>().maxWithOrNull(naturalOrder()) })
        expect(1, { listOf(1).maxWithOrNull(naturalOrder()) })
        expect(""B"", { listOf(""a"", ""B"").maxWithOrNull(STRING_CASE_INSENSITIVE_ORDER) })
        expect(""B"", { listOf(""a"", ""B"").asSequence().maxWithOrNull(STRING_CASE_INSENSITIVE_ORDER) })
    }

    @Test fun minByOrNull() {
        expect(null, { listOf<Int>().minByOrNull { it } })
        expect(1, { listOf(1).minByOrNull { it } })
        expect(3, { listOf(2, 3).minByOrNull { -it } })
        expect('a', { listOf('a', 'b').minByOrNull { ""x$it"" } })
        expect(""b"", { listOf(""b"", ""abc"").minByOrNull { it.length } })
        expect(null, { listOf<Int>().asSequence().minByOrNull { it } })
        expect(3, { listOf(2, 3).asSequence().minByOrNull { -it } })
    }

    @Test fun maxByOrNull() {
        expect(null, { listOf<Int>().maxByOrNull { it } })
        expect(1, { listOf(1).maxByOrNull { it } })
        expect(2, { listOf(2, 3).maxByOrNull { -it } })
        expect('b', { listOf('a', 'b').maxByOrNull { ""x$it"" } })
        expect(""abc"", { listOf(""b"", ""abc"").maxByOrNull { it.length } })
        expect(null, { listOf<Int>().asSequence().maxByOrNull { it } })
        expect(2, { listOf(2, 3).asSequence().maxByOrNull { -it } })
    }

    @Test fun minByOrNullEvaluateOnce() {
        var c = 0
        expect(1, { listOf(5, 4, 3, 2, 1).minByOrNull { c++; it * it } })
        assertEquals(5, c)
        c = 0
        expect(1, { listOf(5, 4, 3, 2, 1).asSequence().minByOrNull { c++; it * it } })
        assertEquals(5, c)
    }

    @Test fun maxByOrNullEvaluateOnce() {
        var c = 0
        expect(5, { listOf(5, 4, 3, 2, 1).maxByOrNull { c++; it * it } })
        assertEquals(5, c)
        c = 0
        expect(5, { listOf(5, 4, 3, 2, 1).asSequence().maxByOrNull { c++; it * it } })
        assertEquals(5, c)
    }

    @Test fun minOf() {
        assertEquals(null, emptyList<Int>().minOfOrNull { it } )
        assertFailsWith<NoSuchElementException> { emptyList<Int>().minOf { it } }

        assertEquals(1, listOf(1).minOf { it })
        assertEquals(-3, listOf(2, 3).minOf { -it })
        assertEquals(""xa"", listOf('a', 'b').minOf { ""x$it"" })
        assertEquals(1, listOf(""b"", ""abc"").minOf { it.length })

        assertEquals(-32.0, listOf(1, 2, 3, 4, 5).minOf { (-2.0).pow(it) })
        assertEquals(-32.0F, listOf(1, 2, 3, 4, 5).minOf { (-2.0F).pow(it) })

        assertEquals(Double.NaN, listOf(1, -1, 0).minOf { it.toDouble().pow(0.5) })
        assertEquals(Float.NaN, listOf(1, -1, 0).minOf { it.toFloat().pow(0.5F) })

        assertIsNegativeZero(listOf(1.0, -1.0).shuffled().minOf { it * 0.0 })
        assertIsNegativeZero(listOf(1.0F, -1.0F).shuffled().minOf { it * 0.0F }.toDouble())
    }

    @Test fun minOfWith() {
        val data = listOf(""abca"", ""bcaa"", ""cabb"")
        val result = data.minOfWith(compareBy { it.reversed() }) { it.take(3) }
        val resultOrNull = data.minOfWithOrNull(compareBy { it.reversed() }) { it.take(3) }
        assertEquals(""bca"", result)
        assertEquals(result, resultOrNull)

        assertEquals(null, emptyList<Int>().minOfWithOrNull(naturalOrder()) { it })
        // TODO: investigate why no unit-coercion happens here and an explicit 'Unit' is required
        assertFailsWith<NoSuchElementException> { emptyList<Int>().minOfWith(naturalOrder()) { it }; Unit }
    }

    @Test fun maxOf() {
        assertEquals(null, emptyList<Int>().maxOfOrNull { it } )
        assertFailsWith<NoSuchElementException> { emptyList<Int>().maxOf { it } }

        assertEquals(1, listOf(1).maxOf { it })
        assertEquals(-2, listOf(2, 3).maxOf { -it })
        assertEquals(""xb"", listOf('a', 'b').maxOf { ""x$it"" })
        assertEquals(3, listOf(""b"", ""abc"").maxOf { it.length })

        assertEquals(16.0, listOf(1, 2, 3, 4, 5).maxOf { (-2.0).pow(it) })
        assertEquals(16.0F, listOf(1, 2, 3, 4, 5).maxOf { (-2.0F).pow(it) })

        assertIsPositiveZero(listOf(1.0, -1.0).shuffled().maxOf { it * 0.0 })
        assertIsPositiveZero(listOf(1.0F, -1.0F).shuffled().maxOf { it * 0.0F }.toDouble())
    }

    @Test fun maxOfWith() {
        val data = listOf(""abca"", ""bcaa"", ""cabb"")
        val result = data.maxOfWith(compareBy { it.reversed() }) { it.take(3) }
        val resultOrNull = data.maxOfWithOrNull(compareBy { it.reversed() }) { it.take(3) }
        assertEquals(""abc"", result)
        assertEquals(result, resultOrNull)

        assertEquals(null, emptyList<Int>().maxOfWithOrNull(naturalOrder()) { it })
        // TODO: investigate why no unit-coercion happens here and an explicit 'Unit' is required
        assertFailsWith<NoSuchElementException> { emptyList<Int>().maxOfWith(naturalOrder()) { it }; Unit }
    }


    @Test fun sum() {
        expect(0) { arrayListOf<Int>().sum() }
        expect(14) { listOf(2, 3, 9).sum() }
        expect(3.0) { listOf(1.0, 2.0).sum() }
        expect(3000000000000) { arrayListOf<Long>(1000000000000, 2000000000000).sum() }
        expect(3.0.toFloat()) { arrayListOf<Float>(1.0.toFloat(), 2.0.toFloat()).sum() }
        expect(3.0.toFloat()) { sequenceOf<Float>(1.0.toFloat(), 2.0.toFloat()).sum() }
    }

    @Test fun sumOf() {
        assertEquals(0, emptyList<Nothing>().sumOf { 1.toInt() })
        assertEquals(0L, emptyList<Nothing>().sumOf { 1L })
        assertEquals(0U, emptyList<Nothing>().sumOf { 1U.toUInt() })
        assertEquals(0UL, emptyList<Nothing>().sumOf { 1UL })
        assertEquals(0.0, emptyList<Nothing>().sumOf { 1.0 })

        val items = listOf("""", ""a"", ""bc"", ""de"", ""fgh"", ""klmnop"")
        assertEquals(items.size + 14, items.sumOf { it.length + 1 })
        assertEquals(14L, items.sumOf { it.length.toLong() })
        assertEquals(0, items.sumOf { if (it.any { c -> c in ""aeiou"" }) 1 else -1 })
        assertEquals(items.size.toUInt(), items.sumOf { 1U })
        assertEquals(14UL, items.sumOf { it.length.toULong() })
        assertEquals(14.0, items.sumOf { it.length.toDouble() })
        assertEquals(Double.NaN, items.sumOf { 0.0 / it.length })
    }

    @Test fun average() {
        assertTrue { arrayListOf<Int>().average().isNaN() }
        expect(3.8) { listOf(1, 2, 5, 8, 3).average() }
        expect(2.1) { sequenceOf(1.6, 2.6, 3.6, 0.6).average() }
        expect(100.0) { arrayListOf<Byte>(100, 100, 100, 100, 100, 100).average() }
        val n = 100
        val range = 0..n
        expect(n.toDouble()/2) { range.average() }
    }

    @Test fun takeReturnsFirstNElements() {
        expect(listOf(1, 2, 3, 4, 5)) { (1..10).take(5) }
        expect(listOf(1, 2, 3, 4, 5)) { (1..10).toList().take(5) }
        expect(listOf(1, 2)) { (1..10).take(2) }
        expect(listOf(1, 2)) { (1..10).toList().take(2) }
        expect(true) { (0L..5L).take(0).none() }
        expect(true) { listOf(1L).take(0).none() }
        expect(listOf(1)) { (1..1).take(10) }
        expect(listOf(1)) { listOf(1).take(10) }
    }

    @Test fun sortInPlace() {
        val data = listOf(11, 3, 7)

        val asc = data.toMutableList()
        asc.sort()
        assertEquals(listOf(3, 7, 11), asc)

        val desc = data.toMutableList()
        desc.sortDescending()
        assertEquals(listOf(11, 7, 3), desc)
    }

    @Test fun sorted() {
        val data = listOf(11, 3, 7)
        assertEquals(listOf(3, 7, 11), data.sorted())
        assertEquals(listOf(11, 7, 3), data.sortedDescending())

        assertEquals(listOf(-0.0, 0.0), listOf(0.0, -0.0).sorted())
        assertNotEquals(listOf(0.0, -0.0), listOf(0.0, -0.0).sorted())

        val dataDouble = listOf(Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.MIN_VALUE, -Double.MIN_VALUE,
                                1.0, -1.0, Double.MAX_VALUE, -Double.MAX_VALUE, Double.NaN, 0.0, -0.0)
        assertEquals(listOf(Double.NEGATIVE_INFINITY, -Double.MAX_VALUE, -1.0, -Double.MIN_VALUE, -0.0,
                            0.0, Double.MIN_VALUE, 1.0, Double.MAX_VALUE, Double.POSITIVE_INFINITY, Double.NaN), dataDouble.sorted())
        assertEquals(listOf(Double.NaN, Double.POSITIVE_INFINITY, Double.MAX_VALUE, 1.0, Double.MIN_VALUE, 0.0,
                            -0.0, -Double.MIN_VALUE, -1.0, -Double.MAX_VALUE, Double.NEGATIVE_INFINITY), dataDouble.sortedDescending())
    }

    @Test fun sortByInPlace() {
        val data = arrayListOf(""aa"" to 20, ""ab"" to 3, ""aa"" to 3)
        data.sortBy { it.second }
        assertEquals(listOf(""ab"" to 3, ""aa"" to 3, ""aa"" to 20), data)

        data.sortBy { it.first }
        assertEquals(listOf(""aa"" to 3, ""aa"" to 20, ""ab"" to 3), data)

        data.sortByDescending { (it.first + it.second).length }
        assertEquals(listOf(""aa"" to 20, ""aa"" to 3, ""ab"" to 3), data)
    }

    @Test fun sortStable() {
        val keyRange = 'A'..'D'
        for (size in listOf(10, 100, 2000)) {
            val list = MutableList(size) { index -> Sortable(keyRange.random(), index) }

            list.sorted().assertStableSorted()
            list.sortedDescending().assertStableSorted(descending = true)

            list.sort()
            list.assertStableSorted()
            list.sortDescending()
            list.assertStableSorted(descending = true)
        }
    }

    @Test fun sortedBy() {
        assertEquals(listOf(""two"" to 3, ""three"" to 20), listOf(""three"" to 20, ""two"" to 3).sortedBy { it.second })
        assertEquals(listOf(""three"" to 20, ""two"" to 3), listOf(""three"" to 20, ""two"" to 3).sortedBy { it.first })
        assertEquals(listOf(""three"", ""two""), listOf(""two"", ""three"").sortedByDescending { it.length })
    }

    @Test fun sortedNullableBy() {
        fun String.nullIfEmpty() = if (isEmpty()) null else this
        listOf(null, """", ""a"").let {
            expect(listOf(null, """", ""a"")) { it.sortedWith(nullsFirst(compareBy { it })) }
            expect(listOf(""a"", """", null)) { it.sortedWith(nullsLast(compareByDescending { it })) }
            expect(listOf(null, ""a"", """")) { it.sortedWith(nullsFirst(compareByDescending { it.nullIfEmpty() })) }
        }
    }

    @Test fun sortedByNullable() {
        fun String.nonEmptyLength() = if (isEmpty()) null else length
        listOf("""", ""sort"", ""abc"").let {
            assertEquals(listOf("""", ""abc"", ""sort""), it.sortedBy { it.nonEmptyLength() })
            assertEquals(listOf(""sort"", ""abc"", """"), it.sortedByDescending { it.nonEmptyLength() })
            assertEquals(listOf(""abc"", ""sort"", """"), it.sortedWith(compareBy(nullsLast<Int>()) { it.nonEmptyLength()}))
        }
    }

    @Test fun sortedWith() {
        val comparator = compareBy<String> { it.uppercase().reversed() }
        val data = listOf(""cat"", ""dad"", ""BAD"")

        expect(listOf(""BAD"", ""dad"", ""cat"")) { data.sortedWith(comparator) }
        expect(listOf(""cat"", ""dad"", ""BAD"")) { data.sortedWith(comparator.reversed()) }
        expect(listOf(""BAD"", ""dad"", ""cat"")) { data.sortedWith(comparator.reversed().reversed()) }
    }

    @Test fun sortByStable() {
        val keyRange = 'A'..'D'
        for (size in listOf(10, 100, 2000)) {
            val list = MutableList(size) { index -> Sortable(keyRange.random(), index) }

            list.sortedBy { it.key }.assertStableSorted()
            list.sortedByDescending { it.key }.assertStableSorted(descending = true)

            list.sortBy { it.key }
            list.assertStableSorted()

            list.sortByDescending { it.key }
            list.assertStableSorted(descending = true)
        }
    }

    @Test fun shuffled() {
        val data = List(100) { it }
        val list = data.toMutableList()
        val shuffled = list.shuffled()

        assertEquals(data, list)
        assertNotEquals(list, shuffled)
        assertEquals(list.toSet(), shuffled.toSet())
        assertEquals(list.size, shuffled.distinct().size)
    }

    @Test fun shuffledPredictably() {
        val data = List(10) { it }
        val list = data.toMutableList()
        val shuffled1 = list.shuffled(Random(1))
        val shuffled11 = list.shuffled(Random(1))

        assertEquals(data, list)

        assertEquals(shuffled1, shuffled11)
        assertEquals(""[1, 4, 0, 6, 2, 8, 9, 7, 3, 5]"", shuffled1.toString())

        val shuffled2 = list.shuffled(Random(42))
        assertEquals(""[5, 0, 4, 9, 2, 8, 1, 7, 6, 3]"", shuffled2.toString())
    }

    @Test fun decomposeFirst() {
        val (first) = listOf(1, 2)
        assertEquals(first, 1)
    }

    @Test fun decomposeSplit() {
        val (key, value) = ""key = value"".split(""="").map { it.trim() }
        assertEquals(key, ""key"")
        assertEquals(value, ""value"")
    }

    @Test fun decomposeList() {
        val (a, b, c, d, e) = listOf(1, 2, 3, 4, 5)
        assertEquals(a, 1)
        assertEquals(b, 2)
        assertEquals(c, 3)
        assertEquals(d, 4)
        assertEquals(e, 5)
    }

    @Test fun decomposeArray() {
        val (a, b, c, d, e) = arrayOf(1, 2, 3, 4, 5)
        assertEquals(a, 1)
        assertEquals(b, 2)
        assertEquals(c, 3)
        assertEquals(d, 4)
        assertEquals(e, 5)
    }

    @Test fun decomposeIntArray() {
        val (a, b, c, d, e) = intArrayOf(1, 2, 3, 4, 5)
        assertEquals(a, 1)
        assertEquals(b, 2)
        assertEquals(c, 3)
        assertEquals(d, 4)
        assertEquals(e, 5)
    }

    @Test fun unzipList() {
        val list = listOf(1 to 'a', 2 to 'b', 3 to 'c')
        val (ints, chars) = list.unzip()
        assertEquals(listOf(1, 2, 3), ints)
        assertEquals(listOf('a', 'b', 'c'), chars)
    }

    @Test fun unzipArray() {
        val array = arrayOf(1 to 'a', 2 to 'b', 3 to 'c')
        val (ints, chars) = array.unzip()
        assertEquals(listOf(1, 2, 3), ints)
        assertEquals(listOf('a', 'b', 'c'), chars)
    }

    @Test fun specialLists() {
        compare(arrayListOf<Int>(), listOf<Int>()) { listBehavior() }
        compare(arrayListOf<Double>(), emptyList<Double>()) { listBehavior() }
        compare(arrayListOf(""value""), listOf(""value"")) { listBehavior() }
    }

    @Test fun specialSets() {
        compare(linkedSetOf<Int>(), setOf<Int>()) { setBehavior() }
        compare(hashSetOf<Double>(), emptySet<Double>()) { setBehavior() }
        compare(listOf(""value"").toMutableSet(), setOf(""value"")) { setBehavior() }
        compare(stringSetOf(""value""), setOf(""value"")) { setBehavior() }
        compare(linkedStringSetOf(""value""), setOf(""value"")) { setBehavior() }
    }

    @Test fun specialMaps() {
        compare(hashMapOf<String, Int>(), mapOf<String, Int>()) { mapBehavior() }
        compare(linkedMapOf<Int, String>(), emptyMap<Int, String>()) { mapBehavior() }
        compare(linkedMapOf(2 to 3), mapOf(2 to 3)) { mapBehavior() }
        compare(stringMapOf(""2"" to 3), mapOf(""2"" to 3)) { mapBehavior() }
        compare(linkedStringMapOf(""2"" to 3), mapOf(""2"" to 3)) { mapBehavior() }
    }

    @Test fun toStringTest() {
        // we need toString() inside pattern because of KT-8666
        assertEquals(""[1, a, null, ${Long.MAX_VALUE.toString()}]"", listOf(1, ""a"", null, Long.MAX_VALUE).toString())
    }

    @Test fun toStringContainingThis() = testExceptOn(TestPlatform.Js) {
        // resulting string is platform-dependent, but shouldn't throw
        arrayOf<Any>(""a"", ""b"", ""c"").apply { this[1] = this }.toString()

        assertEquals(
            ""[a, (this Collection), c]"",
            arrayListOf<Any>(""a"", ""b"", ""c"").apply { this[1] = this }.toString()
        )
        assertEquals(
            ""[a, (this Collection), c]"",
            buildList<Any> {
                addAll(listOf(""a"", ""b"", ""c""))
                this[1] = this
            }.toString()
        )

        assertEquals(
            ""[a, (this Collection), c]"",
            linkedSetOf<Any>().apply {
                add(""a"")
                add(this)
                add(""c"")
            }.toString()
        )
        assertEquals(
            ""[a, (this Collection), c]"",
            buildSet<Any> {
                add(""a"")
                add(this)
                add(""c"")
            }.toString()
        )

        assertEquals(
            ""{a=1, (this Map)=(this Map), c=3}"",
            linkedMapOf<Any, Any>().apply {
                put(""a"", ""1"")
                put(this, this)
                put(""c"", ""3"")
            }.toString()
        )
        assertEquals(
            ""{a=1, (this Map)=(this Map), c=3}"",
            buildMap<Any, Any> {
                put(""a"", ""1"")
                put(this, this)
                put(""c"", ""3"")
            }.toString()
        )
    }

    @Test fun randomAccess() {
        assertStaticAndRuntimeTypeIs<RandomAccess>(arrayListOf(1))
        assertTrue(listOf(1, 2) is RandomAccess, ""Default read-only list implementation is RandomAccess"")
        assertTrue(listOf(1) is RandomAccess, ""Default singleton list is RandomAccess"")
        assertTrue(emptyList<Int>() is RandomAccess, ""Empty list is RandomAccess"")
    }

    @Test fun abstractCollectionToArray() {
        class TestCollection<out E>(val data: Collection<E>) : AbstractCollection<E>() {
            val invocations = mutableListOf<String>()
            override val size get() = data.size
            override fun iterator() = data.iterator()

            override fun toArray(): Array<Any?> {
                invocations += ""toArray1""
                return data.toTypedArray()
            }
            public override fun <T> toArray(array: Array<T>): Array<T> {
                invocations += ""toArray2""
                return super.toArray(array)
            }
        }
        val data = listOf(""abc"", ""def"")
        val coll = TestCollection(data)

        val arr1 = coll.toTypedArray()
        assertEquals(data, arr1.asList())
        assertTrue(""toArray1"" in coll.invocations || ""toArray2"" in coll.invocations)

        val arr2: Array<String> = coll.toArray(Array(coll.size + 1) { """" })
        testOnlyOn(TestPlatform.Jvm) {
            assertEquals(data + listOf(null), arr2.asList())
        }
        testExceptOn(TestPlatform.Jvm) {
            assertEquals(data + listOf(""""), arr2.asList())
        }
    }

    @Test
    fun ensureCapacity() {
        ArrayList<String>().ensureCapacity(-1) // negative argument is ignored
    }

    @Test
    fun constructorWithCapacity() {
        assertFailsWith<IllegalArgumentException> {
            ArrayList<String>(/*initialCapacity = */-1)
        }
        assertEquals(0, ArrayList<String>(/*initialCapacity = */0).size)
        assertEquals(0, ArrayList<String>(/*initialCapacity = */10).size)

        assertFailsWith<IllegalArgumentException> {
            HashSet<String>(/*initialCapacity = */-1)
        }
        assertFailsWith<IllegalArgumentException> {
            HashSet<String>(/*initialCapacity = */-1, /*loadFactor = */0.5f)
        }
        assertFailsWith<IllegalArgumentException> {
            HashSet<String>(/*initialCapacity = */10, /*loadFactor = */0.0f)
        }
        assertFailsWith<IllegalArgumentException> {
            HashSet<String>(/*initialCapacity = */10, /*loadFactor = */Float.NaN)
        }
        assertEquals(0, HashSet<String>(/*initialCapacity = */0).size)
        assertEquals(0, HashSet<String>(/*initialCapacity = */10).size)
        assertEquals(0, HashSet<String>(/*initialCapacity = */0, /*loadFactor = */0.5f).size)
        assertEquals(0, HashSet<String>(/*initialCapacity = */10, /*loadFactor = */1.5f).size)

        assertFailsWith<IllegalArgumentException> {
            LinkedHashSet<String>(/*initialCapacity = */-1)
        }
        assertFailsWith<IllegalArgumentException> {
            LinkedHashSet<String>(/*initialCapacity = */-1, /*loadFactor = */0.5f)
        }
        assertFailsWith<IllegalArgumentException> {
            LinkedHashSet<String>(/*initialCapacity = */10, /*loadFactor = */0.0f)
        }
        assertFailsWith<IllegalArgumentException> {
            LinkedHashSet<String>(/*initialCapacity = */10, /*loadFactor = */Float.NaN)
        }
        assertEquals(0, LinkedHashSet<String>(/*initialCapacity = */0).size)
        assertEquals(0, LinkedHashSet<String>(/*initialCapacity = */10).size)
        assertEquals(0, LinkedHashSet<String>(/*initialCapacity = */0, /*loadFactor = */0.5f).size)
        assertEquals(0, LinkedHashSet<String>(/*initialCapacity = */10, /*loadFactor = */1.5f).size)
    }
}",KOT_02061,CWE-321: Hard-coded Cryptographic Key;CWE-330: Use of Insufficiently Random Values,A02: Cryptographic Failures;A04: Insecure Design,1
JetBrains__kotlin,e640dfda1da3e7f252087d55cb5145d0955eaaa2,compiler/ir/backend.js/src/org/jetbrains/kotlin/ir/backend/js/ir/IrBuilder.kt,.kt,Francesco Protopapa,francesco.protopapa@jetbrains.com,2025-10-07T10:47:33+02:00,[IR] Fix invalid offsets in `IrBranch`,1,JsIrBuilder,"object JsIrBuilder {
    val SYNTHESIZED_DECLARATION by IrDeclarationOriginImpl.Regular

    fun buildCall(
        target: IrSimpleFunctionSymbol,
        type: IrType? = null,
        typeArguments: List<IrType>? = null,
        origin: IrStatementOrigin = JsStatementOrigins.SYNTHESIZED_STATEMENT,
        superQualifierSymbol: IrClassSymbol? = null,
        startOffset: Int = UNDEFINED_OFFSET,
        endOffset: Int = UNDEFINED_OFFSET
    ): IrCall {
        val owner = target.owner
        return IrCallImpl(
            startOffset,
            endOffset,
            type ?: owner.returnType,
            target,
            superQualifierSymbol = superQualifierSymbol,
            typeArgumentsCount = owner.typeParameters.size,
            origin = origin
        ).apply {
            typeArguments?.let {
                assert(typeArguments.size == this.typeArguments.size)
                it.withIndex().forEach { (i, t) ->
                    this.typeArguments[i] = t
                }
            }
        }
    }

    fun buildArray(elements: List<IrExpression>, type: IrType, elementType: IrType): IrExpression {
        return IrVarargImpl(
            UNDEFINED_OFFSET,
            UNDEFINED_OFFSET,
            type,
            elementType,
            elements
        )
    }

    fun buildDelegatingConstructorCall(
        target: IrConstructorSymbol,
        typeArguments: List<IrType?>? = null,
        startOffset: Int = UNDEFINED_OFFSET,
        endOffset: Int = UNDEFINED_OFFSET,
    ): IrDelegatingConstructorCall {
        val owner = target.owner
        val irClass = owner.parentAsClass

        return IrDelegatingConstructorCallImpl(
            startOffset,
            endOffset,
            owner.returnType,
            target,
            typeArgumentsCount = irClass.typeParameters.size,
        ).apply {
            typeArguments?.let {
                assert(it.size == this.typeArguments.size)
                it.withIndex().forEach { (i, t) ->
                    this.typeArguments[i] = t
                }
            }
        }
    }

    fun buildConstructorCall(
        target: IrConstructorSymbol,
        typeArguments: List<IrType?>? = null,
        constructorTypeArguments: List<IrType?>? = null,
        origin: IrStatementOrigin = JsStatementOrigins.SYNTHESIZED_STATEMENT,
        startOffset: Int = UNDEFINED_OFFSET,
        endOffset: Int = UNDEFINED_OFFSET,
    ): IrConstructorCall {
        val owner = target.owner
        val irClass = owner.parentAsClass

        return IrConstructorCallImpl(
            startOffset,
            endOffset,
            owner.returnType,
            target,
            typeArgumentsCount = irClass.typeParameters.size,
            constructorTypeArgumentsCount = owner.typeParameters.size,
            origin = origin
        ).apply {
            typeArguments?.let {
                assert(it.size == this.typeArguments.size)
                it.withIndex().forEach { (i, t) ->
                    this.typeArguments[i] = t
                }
            }

            constructorTypeArguments?.let {
                assert(it.size == this.typeArguments.size)
                it.withIndex().forEach { (i, t) ->
                    this.typeArguments[i] = t
                }
            }
        }
    }

    fun buildDynamicMemberExpression(dispatchReceiver: IrExpression, memberName: String, type: IrType): IrExpression =
        IrDynamicMemberExpressionImpl(
            UNDEFINED_OFFSET, UNDEFINED_OFFSET,
            type,
            memberName,
            dispatchReceiver
        )

    fun buildFunctionExpression(type: IrType, function: IrSimpleFunction) =
        IrFunctionExpressionImpl(
            startOffset = UNDEFINED_OFFSET,
            endOffset = UNDEFINED_OFFSET,
            type = type,
            function = function,
            origin = IrStatementOrigin.LAMBDA,
        )

    fun buildRawReference(targetSymbol: IrFunctionSymbol, type: IrType): IrRawFunctionReference =
        IrRawFunctionReferenceImpl(UNDEFINED_OFFSET, UNDEFINED_OFFSET, type, targetSymbol)

    fun buildReturn(targetSymbol: IrFunctionSymbol, value: IrExpression, type: IrType) =
        IrReturnImpl(UNDEFINED_OFFSET, UNDEFINED_OFFSET, type, targetSymbol, value)

    fun buildThrow(type: IrType, value: IrExpression) = IrThrowImpl(UNDEFINED_OFFSET, UNDEFINED_OFFSET, type, value)

    fun buildValueParameter(
        parent: IrFunction,
        name: String,
        type: IrType,
        isAssignable: Boolean = false,
        origin: IrDeclarationOrigin = SYNTHESIZED_DECLARATION,
        kind: IrParameterKind = IrParameterKind.Regular,
    ): IrValueParameter =
        buildValueParameter(parent) {
            this.origin = origin
            this.name = Name.identifier(name)
            this.type = type
            this.isAssignable = isAssignable
            this.kind = kind
        }

    fun buildGetObjectValue(type: IrType, classSymbol: IrClassSymbol) =
        IrGetObjectValueImpl(UNDEFINED_OFFSET, UNDEFINED_OFFSET, type, classSymbol)

    fun buildGetValue(symbol: IrValueSymbol, origin: IrStatementOrigin = JsStatementOrigins.SYNTHESIZED_STATEMENT) =
        IrGetValueImpl(UNDEFINED_OFFSET, UNDEFINED_OFFSET, symbol.owner.type, symbol, origin)

    fun buildSetValue(
        symbol: IrValueSymbol,
        value: IrExpression,
        startOffset: Int = UNDEFINED_OFFSET,
        endOffset: Int = UNDEFINED_OFFSET,
    ) =
        IrSetValueImpl(startOffset, endOffset, symbol.owner.type, symbol, value, JsStatementOrigins.SYNTHESIZED_STATEMENT)

    fun buildSetVariable(symbol: IrVariableSymbol, value: IrExpression, type: IrType) =
        IrSetValueImpl(UNDEFINED_OFFSET, UNDEFINED_OFFSET, type, symbol, value, JsStatementOrigins.SYNTHESIZED_STATEMENT)

    fun buildGetField(
        symbol: IrFieldSymbol,
        receiver: IrExpression? = null,
        superQualifierSymbol: IrClassSymbol? = null,
        type: IrType? = null,
        startOffset: Int = UNDEFINED_OFFSET,
        endOffset: Int = UNDEFINED_OFFSET,
        origin: IrStatementOrigin? = JsStatementOrigins.SYNTHESIZED_STATEMENT
    ) =
        IrGetFieldImpl(
            startOffset,
            endOffset,
            symbol,
            type ?: symbol.owner.type,
            receiver,
            origin,
            superQualifierSymbol
        )

    fun buildSetField(
        symbol: IrFieldSymbol,
        receiver: IrExpression?,
        value: IrExpression,
        type: IrType,
        superQualifierSymbol: IrClassSymbol? = null
    ) =
        IrSetFieldImpl(UNDEFINED_OFFSET, UNDEFINED_OFFSET, symbol, receiver, value, type,
                       JsStatementOrigins.SYNTHESIZED_STATEMENT, superQualifierSymbol)

    fun buildBlock(type: IrType) = IrBlockImpl(UNDEFINED_OFFSET, UNDEFINED_OFFSET, type, JsStatementOrigins.SYNTHESIZED_STATEMENT)
    fun buildBlock(type: IrType, statements: List<IrStatement>) =
        IrBlockImpl(UNDEFINED_OFFSET, UNDEFINED_OFFSET, type, JsStatementOrigins.SYNTHESIZED_STATEMENT, statements)

    fun buildComposite(type: IrType, statements: List<IrStatement> = emptyList()) =
        IrCompositeImpl(UNDEFINED_OFFSET, UNDEFINED_OFFSET, type, JsStatementOrigins.SYNTHESIZED_STATEMENT, statements)

    fun buildVar(
        type: IrType,
        parent: IrDeclarationParent?,
        name: String = ""tmp"",
        isVar: Boolean = false,
        isConst: Boolean = false,
        isLateinit: Boolean = false,
        initializer: IrExpression? = null,
        origin: IrDeclarationOrigin = SYNTHESIZED_DECLARATION
    ): IrVariable = buildVariable(
        parent,
        UNDEFINED_OFFSET,
        UNDEFINED_OFFSET,
        origin,
        Name.identifier(name),
        type,
        isVar,
        isConst,
        isLateinit,
    ).also {
        it.initializer = initializer
    }

    fun buildBreak(type: IrType, loop: IrLoop) = IrBreakImpl(UNDEFINED_OFFSET, UNDEFINED_OFFSET, type, loop)
    fun buildContinue(type: IrType, loop: IrLoop) = IrContinueImpl(UNDEFINED_OFFSET, UNDEFINED_OFFSET, type, loop)

    fun buildIfElse(
        type: IrType,
        cond: IrExpression,
        thenBranch: IrExpression,
        elseBranch: IrExpression? = null,
        thenBranchStartOffset: Int = thenBranch.startOffset,
        thenBranchEndOffset: Int = thenBranch.endOffset,
        elseBranchStartOffset: Int = elseBranch?.startOffset ?: UNDEFINED_OFFSET,
        elseBranchEndOffset: Int = elseBranch?.endOffset ?: UNDEFINED_OFFSET,
    ): IrWhen =
        buildIfElse(
            startOffset = UNDEFINED_OFFSET,
            endOffset = UNDEFINED_OFFSET,
            type = type,
            cond = cond,
            thenBranch = thenBranch,
            elseBranch = elseBranch,
            origin = JsStatementOrigins.SYNTHESIZED_STATEMENT,
            thenBranchStartOffset = thenBranchStartOffset,
            thenBranchEndOffset = thenBranchEndOffset,
            elseBranchStartOffset = elseBranchStartOffset,
            elseBranchEndOffset = elseBranchEndOffset
        )

    fun buildIfElse(
        startOffset: Int,
        endOffset: Int,
        type: IrType,
        cond: IrExpression,
        thenBranch: IrExpression,
        elseBranch: IrExpression? = null,
        origin: IrStatementOrigin? = null,
        thenBranchStartOffset: Int = thenBranch.startOffset,
        thenBranchEndOffset: Int = thenBranch.endOffset,
        elseBranchStartOffset: Int = elseBranch?.startOffset ?: UNDEFINED_OFFSET,
        elseBranchEndOffset: Int = elseBranch?.endOffset ?: UNDEFINED_OFFSET,
    ): IrWhen {
        val element = IrWhenImpl(startOffset, endOffset, type, origin)
        element.branches.add(IrBranchImpl(thenBranchStartOffset, thenBranchEndOffset, cond, thenBranch))
        if (elseBranch != null) {
            val irTrue = IrConstImpl.constTrue(UNDEFINED_OFFSET, UNDEFINED_OFFSET, cond.type)
            element.branches.add(IrElseBranchImpl(elseBranchStartOffset, elseBranchEndOffset, irTrue, elseBranch))
        }

        return element
    }

    fun buildWhen(type: IrType, branches: List<IrBranch>, origin: IrStatementOrigin = JsStatementOrigins.SYNTHESIZED_STATEMENT) =
        IrWhenImpl(UNDEFINED_OFFSET, UNDEFINED_OFFSET, type, origin, branches)

    fun buildTypeOperator(type: IrType, operator: IrTypeOperator, argument: IrExpression, toType: IrType) =
        IrTypeOperatorCallImpl(UNDEFINED_OFFSET, UNDEFINED_OFFSET, type, operator, toType, argument)

    fun buildImplicitCast(value: IrExpression, toType: IrType) =
        buildTypeOperator(toType, IrTypeOperator.IMPLICIT_CAST, value, toType)

    fun buildReinterpretCast(value: IrExpression, toType: IrType) =
        buildTypeOperator(toType, IrTypeOperator.REINTERPRET_CAST, value, toType)

    fun buildNull(type: IrType) = IrConstImpl.constNull(UNDEFINED_OFFSET, UNDEFINED_OFFSET, type)
    fun buildBoolean(type: IrType, v: Boolean) = IrConstImpl.boolean(UNDEFINED_OFFSET, UNDEFINED_OFFSET, type, v)
    fun buildInt(type: IrType, v: Int) = IrConstImpl.int(UNDEFINED_OFFSET, UNDEFINED_OFFSET, type, v)
    fun buildString(type: IrType, s: String) = IrConstImpl.string(UNDEFINED_OFFSET, UNDEFINED_OFFSET, type, s)
    fun buildTry(type: IrType) = IrTryImpl(UNDEFINED_OFFSET, UNDEFINED_OFFSET, type)
    fun buildCatch(ex: IrVariable, block: IrBlockImpl) = IrCatchImpl(UNDEFINED_OFFSET, UNDEFINED_OFFSET, ex, block)
}",KOT_01188,,,0
duckduckgo__Android,2c8b0fe26e98bf43902a2c1ca9404943e95e5af9,network-protection/network-protection-impl/src/main/java/com/duckduckgo/networkprotection/impl/cohort/NetpCohortPixelInterceptor.kt,.kt,Josh Leibstein,joshliebe@gmail.com,2023-11-15T09:34:39+00:00,Update to AGP 8.1.2 (#3812),1,,"/*
 * Copyright (c) 2023 DuckDuckGo
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.duckduckgo.networkprotection.impl.cohort

import androidx.annotation.VisibleForTesting
import com.duckduckgo.app.global.plugins.pixel.PixelInterceptorPlugin
import com.duckduckgo.di.scopes.AppScope
import com.squareup.anvil.annotations.ContributesMultibinding
import javax.inject.Inject
import logcat.logcat
import okhttp3.Interceptor
import okhttp3.Protocol
import okhttp3.Response
import okhttp3.ResponseBody.Companion.toResponseBody

@ContributesMultibinding(
    scope = AppScope::class,
    boundType = PixelInterceptorPlugin::class,
)
class NetpCohortPixelInterceptor @Inject constructor(
    private val cohortStore: NetpCohortStore,
) : PixelInterceptorPlugin, Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        val request = chain.request().newBuilder()
        val pixel = chain.request().url.pathSegments.last()

        val url = if (pixel.startsWith(PIXEL_PREFIX) && !EXCEPTIONS.any { exception -> pixel.startsWith(exception) }) {
            // IF there is no cohort for NetP we just drop the pixel request
            cohortStore.cohortLocalDate?.let {
                chain.request().url.newBuilder().build()
            } ?: return dummyResponse(chain)
        } else {
            chain.request().url
        }

        return chain.proceed(request.url(url).build())
    }

    private fun dummyResponse(chain: Interceptor.Chain): Response {
        logcat { ""Pixel URL request dropped: ${chain.request()}"" }

        return Response.Builder()
            .code(200)
            .protocol(Protocol.HTTP_2)
            .body(""NetP pixel dropped"".toResponseBody())
            .message(""Dropped NetP pixel because no cohort is assigned"")
            .request(chain.request())
            .build()
    }

    override fun getInterceptor(): Interceptor {
        return this
    }

    companion object {
        @VisibleForTesting
        private const val PIXEL_PREFIX = ""m_netp""
        private val EXCEPTIONS = listOf(
            ""m_netp_ev_backend_api_error"",
            ""m_netp_ev_wireguard_error"",
            ""m_netp_imp_vpn_conflict_dialog"",
            ""m_netp_imp_always_on_conflict_dialog"",
            ""m_netp_imp_info_vpn"",
            ""m_netp_imp_faqs"",
            ""m_netp_imp_terms"",
            ""m_netp_ev_waitlist_notification_shown"",
            ""m_netp_ev_waitlist_notification_cancelled"",
            ""m_netp_ev_waitlist_notification_launched"",
            ""m_netp_ev_waitlist_enabled"",
            ""m_netp_ev_terms_accepted"",
            ""m_netp_imp_geoswitching"",
            ""m_netp_ev_geoswitching"",
        )
    }
}
",KSEC_3163,['CWE-321: Hard-coded Cryptographic Key'],"['A02: Cryptographic Failures', 'A04: Insecure Design']",1
JetBrains__kotlin,1c5dd2fb04514c713c4a6a346599223a45153262,js/js.tests/tests-gen/org/jetbrains/kotlin/js/test/fir/JsCodegenWasmJsInteropTestGenerated.java,.java,Andrey Mogilev,andrey.mogilev@jetbrains.com,2025-10-22T20:50:57+02:00,[Wasm/Js] fix external instanceof in singleModule mode,1,JsCodegenWasmJsInteropTestGenerated,"public class JsCodegenWasmJsInteropTestGenerated extends AbstractJsCodegenWasmJsInteropTest {
  @Test
  public void testAllFilesPresentInBoxWasmJsInterop() {
    KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File(""compiler/testData/codegen/boxWasmJsInterop""), Pattern.compile(""^(.+)\\.kt$""), null, true);
  }

  @Test
  @TestMetadata(""associatedExternalObject.kt"")
  public void testAssociatedExternalObject() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/associatedExternalObject.kt"");
  }

  @Test
  @TestMetadata(""callingWasmDirectly.kt"")
  public void testCallingWasmDirectly() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/callingWasmDirectly.kt"");
  }

  @Test
  @TestMetadata(""closureAdapterCaching.kt"")
  public void testClosureAdapterCaching() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/closureAdapterCaching.kt"");
  }

  @Test
  @TestMetadata(""defaultValues.kt"")
  public void testDefaultValues() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/defaultValues.kt"");
  }

  @Test
  @TestMetadata(""exceptionFromGlobalInitializer.kt"")
  public void testExceptionFromGlobalInitializer() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/exceptionFromGlobalInitializer.kt"");
  }

  @Test
  @TestMetadata(""exceptionFromGlobalInitializerNewProposal.kt"")
  public void testExceptionFromGlobalInitializerNewProposal() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/exceptionFromGlobalInitializerNewProposal.kt"");
  }

  @Test
  @TestMetadata(""exceptionFromGlobalInitializerNoJsTag.kt"")
  public void testExceptionFromGlobalInitializerNoJsTag() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/exceptionFromGlobalInitializerNoJsTag.kt"");
  }

  @Test
  @TestMetadata(""exceptionFromMain.kt"")
  public void testExceptionFromMain() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/exceptionFromMain.kt"");
  }

  @Test
  @TestMetadata(""exceptionFromMainJsCustomName.kt"")
  public void testExceptionFromMainJsCustomName() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/exceptionFromMainJsCustomName.kt"");
  }

  @Test
  @TestMetadata(""exceptionFromMainJsNull.kt"")
  public void testExceptionFromMainJsNull() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/exceptionFromMainJsNull.kt"");
  }

  @Test
  @TestMetadata(""exceptionFromMainJsNumber.kt"")
  public void testExceptionFromMainJsNumber() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/exceptionFromMainJsNumber.kt"");
  }

  @Test
  @TestMetadata(""exceptionFromMainJsString.kt"")
  public void testExceptionFromMainJsString() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/exceptionFromMainJsString.kt"");
  }

  @Test
  @TestMetadata(""exceptionFromMainJsTypeError.kt"")
  public void testExceptionFromMainJsTypeError() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/exceptionFromMainJsTypeError.kt"");
  }

  @Test
  @TestMetadata(""exceptionFromMainNewProposal.kt"")
  public void testExceptionFromMainNewProposal() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/exceptionFromMainNewProposal.kt"");
  }

  @Test
  @TestMetadata(""exceptionFromMainNewProposalJsCustomName.kt"")
  public void testExceptionFromMainNewProposalJsCustomName() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/exceptionFromMainNewProposalJsCustomName.kt"");
  }

  @Test
  @TestMetadata(""exceptionFromMainNewProposalJsNull.kt"")
  public void testExceptionFromMainNewProposalJsNull() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/exceptionFromMainNewProposalJsNull.kt"");
  }

  @Test
  @TestMetadata(""exceptionFromMainNewProposalJsNumber.kt"")
  public void testExceptionFromMainNewProposalJsNumber() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/exceptionFromMainNewProposalJsNumber.kt"");
  }

  @Test
  @TestMetadata(""exceptionFromMainNewProposalJsString.kt"")
  public void testExceptionFromMainNewProposalJsString() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/exceptionFromMainNewProposalJsString.kt"");
  }

  @Test
  @TestMetadata(""exceptionFromMainNewProposalJsTypeError.kt"")
  public void testExceptionFromMainNewProposalJsTypeError() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/exceptionFromMainNewProposalJsTypeError.kt"");
  }

  @Test
  @TestMetadata(""exceptionFromMainNoJsTag.kt"")
  public void testExceptionFromMainNoJsTag() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/exceptionFromMainNoJsTag.kt"");
  }

  @Test
  @TestMetadata(""exceptionFromMainNoJsTagJsCustomName.kt"")
  public void testExceptionFromMainNoJsTagJsCustomName() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/exceptionFromMainNoJsTagJsCustomName.kt"");
  }

  @Test
  @TestMetadata(""exceptionFromMainNoJsTagJsNull.kt"")
  public void testExceptionFromMainNoJsTagJsNull() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/exceptionFromMainNoJsTagJsNull.kt"");
  }

  @Test
  @TestMetadata(""exceptionFromMainNoJsTagJsNumber.kt"")
  public void testExceptionFromMainNoJsTagJsNumber() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/exceptionFromMainNoJsTagJsNumber.kt"");
  }

  @Test
  @TestMetadata(""exceptionFromMainNoJsTagJsString.kt"")
  public void testExceptionFromMainNoJsTagJsString() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/exceptionFromMainNoJsTagJsString.kt"");
  }

  @Test
  @TestMetadata(""exceptionFromMainNoJsTagJsTypeError.kt"")
  public void testExceptionFromMainNoJsTagJsTypeError() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/exceptionFromMainNoJsTagJsTypeError.kt"");
  }

  @Test
  @TestMetadata(""externalCast.kt"")
  public void testExternalCast() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/externalCast.kt"");
  }

  @Test
  @TestMetadata(""externalTypeOperators.kt"")
  public void testExternalTypeOperators() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/externalTypeOperators.kt"");
  }

  @Test
  @TestMetadata(""externals.kt"")
  public void testExternals() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/externals.kt"");
  }

  @Test
  @TestMetadata(""externalsWithUnsigned.kt"")
  public void testExternalsWithUnsigned() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/externalsWithUnsigned.kt"");
  }

  @Test
  @TestMetadata(""functionTypes.kt"")
  public void testFunctionTypes() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/functionTypes.kt"");
  }

  @Test
  @TestMetadata(""genericReturnsExternal.kt"")
  public void testGenericReturnsExternal() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/genericReturnsExternal.kt"");
  }

  @Test
  @TestMetadata(""imperativeWrapperInitialised.kt"")
  public void testImperativeWrapperInitialised() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/imperativeWrapperInitialised.kt"");
  }

  @Test
  @TestMetadata(""imperativeWrapperUninitialised.kt"")
  public void testImperativeWrapperUninitialised() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/imperativeWrapperUninitialised.kt"");
  }

  @Test
  @TestMetadata(""invariantLambdaAdapters.kt"")
  public void testInvariantLambdaAdapters() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/invariantLambdaAdapters.kt"");
  }

  @Test
  @TestMetadata(""jsCode.kt"")
  public void testJsCode() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/jsCode.kt"");
  }

  @Test
  @TestMetadata(""jsCustomException.kt"")
  public void testJsCustomException() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/jsCustomException.kt"");
  }

  @Test
  @TestMetadata(""jsCustomExceptionNoJsTag.kt"")
  public void testJsCustomExceptionNoJsTag() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/jsCustomExceptionNoJsTag.kt"");
  }

  @Test
  @TestMetadata(""jsDelayedRuntimeQualifier.kt"")
  public void testJsDelayedRuntimeQualifier() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/jsDelayedRuntimeQualifier.kt"");
  }

  @Test
  @TestMetadata(""jsDelayedRuntimeQualifierOnDeclaration.kt"")
  public void testJsDelayedRuntimeQualifierOnDeclaration() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/jsDelayedRuntimeQualifierOnDeclaration.kt"");
  }

  @Test
  @TestMetadata(""jsException.kt"")
  public void testJsException() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/jsException.kt"");
  }

  @Test
  @TestMetadata(""jsExceptionInSuspendFunction.kt"")
  public void testJsExceptionInSuspendFunction() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/jsExceptionInSuspendFunction.kt"");
  }

  @Test
  @TestMetadata(""jsExceptionInSuspendFunctionNewProposal.kt"")
  public void testJsExceptionInSuspendFunctionNewProposal() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/jsExceptionInSuspendFunctionNewProposal.kt"");
  }

  @Test
  @TestMetadata(""jsExceptionInSuspendFunctionNoJsTag.kt"")
  public void testJsExceptionInSuspendFunctionNoJsTag() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/jsExceptionInSuspendFunctionNoJsTag.kt"");
  }

  @Test
  @TestMetadata(""jsExceptionJsKJsK.kt"")
  public void testJsExceptionJsKJsK() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/jsExceptionJsKJsK.kt"");
  }

  @Test
  @TestMetadata(""jsExceptionJsKJsKNewProposal.kt"")
  public void testJsExceptionJsKJsKNewProposal() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/jsExceptionJsKJsKNewProposal.kt"");
  }

  @Test
  @TestMetadata(""jsExceptionNewProposal.kt"")
  public void testJsExceptionNewProposal() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/jsExceptionNewProposal.kt"");
  }

  @Test
  @TestMetadata(""jsExceptionNewProposalNoJsTag.kt"")
  public void testJsExceptionNewProposalNoJsTag() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/jsExceptionNewProposalNoJsTag.kt"");
  }

  @Test
  @TestMetadata(""jsExceptionNoJsTag.kt"")
  public void testJsExceptionNoJsTag() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/jsExceptionNoJsTag.kt"");
  }

  @Test
  @TestMetadata(""jsExceptionPromise.kt"")
  public void testJsExceptionPromise() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/jsExceptionPromise.kt"");
  }

  @Test
  @TestMetadata(""jsExceptionThroughKotlin.kt"")
  public void testJsExceptionThroughKotlin() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/jsExceptionThroughKotlin.kt"");
  }

  @Test
  @TestMetadata(""jsExceptionThroughKotlinNewProposal.kt"")
  public void testJsExceptionThroughKotlinNewProposal() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/jsExceptionThroughKotlinNewProposal.kt"");
  }

  @Test
  @TestMetadata(""jsExceptionThroughKotlinNoJsTag.kt"")
  public void testJsExceptionThroughKotlinNoJsTag() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/jsExceptionThroughKotlinNoJsTag.kt"");
  }

  @Test
  @TestMetadata(""jsExceptionWithRunCatching.kt"")
  public void testJsExceptionWithRunCatching() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/jsExceptionWithRunCatching.kt"");
  }

  @Test
  @TestMetadata(""jsExceptionWithRunCatchingNewProposal.kt"")
  public void testJsExceptionWithRunCatchingNewProposal() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/jsExceptionWithRunCatchingNewProposal.kt"");
  }

  @Test
  @TestMetadata(""jsExceptionWithRunCatchingNoJsTag.kt"")
  public void testJsExceptionWithRunCatchingNoJsTag() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/jsExceptionWithRunCatchingNoJsTag.kt"");
  }

  @Test
  @TestMetadata(""jsExport.kt"")
  public void testJsExport() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/jsExport.kt"");
  }

  @Test
  @TestMetadata(""jsExportParameterWithDefaultValue.kt"")
  public void testJsExportParameterWithDefaultValue() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/jsExportParameterWithDefaultValue.kt"");
  }

  @Test
  @TestMetadata(""jsExternalLibrariesImport.kt"")
  public void testJsExternalLibrariesImport() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/jsExternalLibrariesImport.kt"");
  }

  @Test
  @TestMetadata(""jsModule.kt"")
  public void testJsModule() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/jsModule.kt"");
  }

  @Test
  @TestMetadata(""jsModuleWithQualifier.kt"")
  public void testJsModuleWithQualifier() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/jsModuleWithQualifier.kt"");
  }

  @Test
  @TestMetadata(""jsModuleWithQualifierOnDeclaration.kt"")
  public void testJsModuleWithQualifierOnDeclaration() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/jsModuleWithQualifierOnDeclaration.kt"");
  }

  @Test
  @TestMetadata(""jsQualifier.kt"")
  public void testJsQualifier() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/jsQualifier.kt"");
  }

  @Test
  @TestMetadata(""jsQualifierOnDeclaration.kt"")
  public void testJsQualifierOnDeclaration() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/jsQualifierOnDeclaration.kt"");
  }

  @Test
  @TestMetadata(""jsToKotlinAdapters.kt"")
  public void testJsToKotlinAdapters() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/jsToKotlinAdapters.kt"");
  }

  @Test
  @TestMetadata(""jsTypes.kt"")
  public void testJsTypes() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/jsTypes.kt"");
  }

  @Test
  @TestMetadata(""kotlinToJsAdapters.kt"")
  public void testKotlinToJsAdapters() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/kotlinToJsAdapters.kt"");
  }

  @Test
  @TestMetadata(""kt59082.kt"")
  public void testKt59082() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/kt59082.kt"");
  }

  @Test
  @TestMetadata(""kt59084.kt"")
  public void testKt59084() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/kt59084.kt"");
  }

  @Test
  @TestMetadata(""lambdaAdapterNameClash.kt"")
  public void testLambdaAdapterNameClash() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/lambdaAdapterNameClash.kt"");
  }

  @Test
  @TestMetadata(""longStrings.kt"")
  public void testLongStrings() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/longStrings.kt"");
  }

  @Test
  @TestMetadata(""nameClash.kt"")
  public void testNameClash() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/nameClash.kt"");
  }

  @Test
  @TestMetadata(""nativeInvoke.kt"")
  public void testNativeInvoke() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/nativeInvoke.kt"");
  }

  @Test
  @TestMetadata(""noExceptions.kt"")
  public void testNoExceptions() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/noExceptions.kt"");
  }

  @Test
  @TestMetadata(""noKotlinCastForUnsafeCast.kt"")
  public void testNoKotlinCastForUnsafeCast() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/noKotlinCastForUnsafeCast.kt"");
  }

  @Test
  @TestMetadata(""nullableExternRefs.kt"")
  public void testNullableExternRefs() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/nullableExternRefs.kt"");
  }

  @Test
  @TestMetadata(""reflectionOnExternals.kt"")
  public void testReflectionOnExternals() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/reflectionOnExternals.kt"");
  }

  @Test
  @TestMetadata(""types.kt"")
  public void testTypes() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/types.kt"");
  }

  @Test
  @TestMetadata(""vararg.kt"")
  public void testVararg() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/vararg.kt"");
  }

  @Test
  @TestMetadata(""wasmExport.kt"")
  public void testWasmExport() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/wasmExport.kt"");
  }

  @Test
  @TestMetadata(""wasmExportWithChainExceptions.kt"")
  public void testWasmExportWithChainExceptions() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/wasmExportWithChainExceptions.kt"");
  }

  @Test
  @TestMetadata(""wasmExportWithChainExceptionsNewProposal.kt"")
  public void testWasmExportWithChainExceptionsNewProposal() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/wasmExportWithChainExceptionsNewProposal.kt"");
  }

  @Test
  @TestMetadata(""wasmExportWithChainExceptionsNoJsTag.kt"")
  public void testWasmExportWithChainExceptionsNoJsTag() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/wasmExportWithChainExceptionsNoJsTag.kt"");
  }

  @Test
  @TestMetadata(""wasmExportWithExceptions.kt"")
  public void testWasmExportWithExceptions() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/wasmExportWithExceptions.kt"");
  }

  @Test
  @TestMetadata(""wasmExportWithExceptionsJsCustom.kt"")
  public void testWasmExportWithExceptionsJsCustom() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/wasmExportWithExceptionsJsCustom.kt"");
  }

  @Test
  @TestMetadata(""wasmExportWithExceptionsNewProposal.kt"")
  public void testWasmExportWithExceptionsNewProposal() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/wasmExportWithExceptionsNewProposal.kt"");
  }

  @Test
  @TestMetadata(""wasmExportWithExceptionsNewProposalJsCustom.kt"")
  public void testWasmExportWithExceptionsNewProposalJsCustom() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/wasmExportWithExceptionsNewProposalJsCustom.kt"");
  }

  @Test
  @TestMetadata(""wasmExportWithExceptionsNoJsTag.kt"")
  public void testWasmExportWithExceptionsNoJsTag() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/wasmExportWithExceptionsNoJsTag.kt"");
  }

  @Test
  @TestMetadata(""wasmExportWithExceptionsNoJsTagJsCustom.kt"")
  public void testWasmExportWithExceptionsNoJsTagJsCustom() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/wasmExportWithExceptionsNoJsTagJsCustom.kt"");
  }

  @Test
  @TestMetadata(""wasmImport.kt"")
  public void testWasmImport() {
    runTest(""compiler/testData/codegen/boxWasmJsInterop/wasmImport.kt"");
  }

  @Nested
  @TestMetadata(""compiler/testData/codegen/boxWasmJsInterop/escapedIdentifiers"")
  @TestDataPath(""$PROJECT_ROOT"")
  public class EscapedIdentifiers {
    @Test
    public void testAllFilesPresentInEscapedIdentifiers() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File(""compiler/testData/codegen/boxWasmJsInterop/escapedIdentifiers""), Pattern.compile(""^(.+)\\.kt$""), null, true);
    }

    @Test
    @TestMetadata(""externalEscapedClassFields.kt"")
    public void testExternalEscapedClassFields() {
      runTest(""compiler/testData/codegen/boxWasmJsInterop/escapedIdentifiers/externalEscapedClassFields.kt"");
    }

    @Test
    @TestMetadata(""externalEscapedTopLevel.kt"")
    public void testExternalEscapedTopLevel() {
      runTest(""compiler/testData/codegen/boxWasmJsInterop/escapedIdentifiers/externalEscapedTopLevel.kt"");
    }

    @Test
    @TestMetadata(""topLevelExportedFunction.kt"")
    public void testTopLevelExportedFunction() {
      runTest(""compiler/testData/codegen/boxWasmJsInterop/escapedIdentifiers/topLevelExportedFunction.kt"");
    }

    @Test
    @TestMetadata(""topLevelLocalClassMangling.kt"")
    public void testTopLevelLocalClassMangling() {
      runTest(""compiler/testData/codegen/boxWasmJsInterop/escapedIdentifiers/topLevelLocalClassMangling.kt"");
    }

    @Test
    @TestMetadata(""topLevelLocalCompanionMangling.kt"")
    public void testTopLevelLocalCompanionMangling() {
      runTest(""compiler/testData/codegen/boxWasmJsInterop/escapedIdentifiers/topLevelLocalCompanionMangling.kt"");
    }

    @Test
    @TestMetadata(""topLevelLocalFunctionMangling.kt"")
    public void testTopLevelLocalFunctionMangling() {
      runTest(""compiler/testData/codegen/boxWasmJsInterop/escapedIdentifiers/topLevelLocalFunctionMangling.kt"");
    }

    @Test
    @TestMetadata(""topLevelLocalVariableMangling.kt"")
    public void testTopLevelLocalVariableMangling() {
      runTest(""compiler/testData/codegen/boxWasmJsInterop/escapedIdentifiers/topLevelLocalVariableMangling.kt"");
    }
  }
}",KOT_01509,,,0
JetBrains__kotlin,981855092ac4fb73eed609384379dff6419457de,analysis/low-level-api-fir/tests-gen/org/jetbrains/kotlin/analysis/low/level/api/fir/diagnostic/compiler/based/LLPartialDiagnosticsFe10TestGenerated.java,.java,Ilya Chernikov,ilya.chernikov@jetbrains.com,2025-10-15T15:11:00+02:00,FIR: fix secondary resolution of contracts with errors,1,Errors,"        public class Errors {
          @Test
          @TestMetadata(""accessToOuterThis.kt"")
          public void testAccessToOuterThis() {
            runTest(""compiler/testData/diagnostics/testsWithStdLib/contracts/dsl/errors/accessToOuterThis.kt"");
          }

          @Test
          @TestMetadata(""accessorsErrorsInK2.kt"")
          public void testAccessorsErrorsInK2() {
            runTest(""compiler/testData/diagnostics/testsWithStdLib/contracts/dsl/errors/accessorsErrorsInK2.kt"");
          }

          @Test
          public void testAllFilesPresentInErrors() {
            KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File(""compiler/testData/diagnostics/testsWithStdLib/contracts/dsl/errors""), Pattern.compile(""^(.+)\\.(kt|kts)$""), Pattern.compile(""^(.+)\\.(reversed|partialBody|fir|ll|latestLV)\\.kts?$""), true);
          }

          @Test
          @TestMetadata(""booleanComparisons.kt"")
          public void testBooleanComparisons() {
            runTest(""compiler/testData/diagnostics/testsWithStdLib/contracts/dsl/errors/booleanComparisons.kt"");
          }

          @Test
          @TestMetadata(""callInContractDescription.kt"")
          public void testCallInContractDescription() {
            runTest(""compiler/testData/diagnostics/testsWithStdLib/contracts/dsl/errors/callInContractDescription.kt"");
          }

          @Test
          @TestMetadata(""contractCallSites.1.4.kt"")
          public void testContractCallSites_1_4() {
            runTest(""compiler/testData/diagnostics/testsWithStdLib/contracts/dsl/errors/contractCallSites.1.4.kt"");
          }

          @Test
          @TestMetadata(""emptyContract.kt"")
          public void testEmptyContract() {
            runTest(""compiler/testData/diagnostics/testsWithStdLib/contracts/dsl/errors/emptyContract.kt"");
          }

          @Test
          @TestMetadata(""illegalConstructionInContractBlock.kt"")
          public void testIllegalConstructionInContractBlock() {
            runTest(""compiler/testData/diagnostics/testsWithStdLib/contracts/dsl/errors/illegalConstructionInContractBlock.kt"");
          }

          @Test
          @TestMetadata(""illegalEqualsCondition.kt"")
          public void testIllegalEqualsCondition() {
            runTest(""compiler/testData/diagnostics/testsWithStdLib/contracts/dsl/errors/illegalEqualsCondition.kt"");
          }

          @Test
          @TestMetadata(""missingArgumentsInEffectDeclarations.kt"")
          public void testMissingArgumentsInEffectDeclarations() {
            runTest(""compiler/testData/diagnostics/testsWithStdLib/contracts/dsl/errors/missingArgumentsInEffectDeclarations.kt"");
          }

          @Test
          @TestMetadata(""missingImport.kt"")
          public void testMissingImport() {
            runTest(""compiler/testData/diagnostics/testsWithStdLib/contracts/dsl/errors/missingImport.kt"");
          }

          @Test
          @TestMetadata(""nestedConditionalEffects.kt"")
          public void testNestedConditionalEffects() {
            runTest(""compiler/testData/diagnostics/testsWithStdLib/contracts/dsl/errors/nestedConditionalEffects.kt"");
          }

          @Test
          @TestMetadata(""nonLambdaLiteralAsArgument.kt"")
          public void testNonLambdaLiteralAsArgument() {
            runTest(""compiler/testData/diagnostics/testsWithStdLib/contracts/dsl/errors/nonLambdaLiteralAsArgument.kt"");
          }

          @Test
          @TestMetadata(""notFirstStatement.kt"")
          public void testNotFirstStatement() {
            runTest(""compiler/testData/diagnostics/testsWithStdLib/contracts/dsl/errors/notFirstStatement.kt"");
          }

          @Test
          @TestMetadata(""operatorsErrorsInK2.kt"")
          public void testOperatorsErrorsInK2() {
            runTest(""compiler/testData/diagnostics/testsWithStdLib/contracts/dsl/errors/operatorsErrorsInK2.kt"");
          }

          @Test
          @TestMetadata(""recursiveContract.kt"")
          public void testRecursiveContract() {
            runTest(""compiler/testData/diagnostics/testsWithStdLib/contracts/dsl/errors/recursiveContract.kt"");
          }

          @Test
          @TestMetadata(""recursiveContractCustomContractFunction.kt"")
          public void testRecursiveContractCustomContractFunction() {
            runTest(""compiler/testData/diagnostics/testsWithStdLib/contracts/dsl/errors/recursiveContractCustomContractFunction.kt"");
          }

          @Test
          @TestMetadata(""referenceToProperty.1.4.kt"")
          public void testReferenceToProperty_1_4() {
            runTest(""compiler/testData/diagnostics/testsWithStdLib/contracts/dsl/errors/referenceToProperty.1.4.kt"");
          }

          @Test
          @TestMetadata(""reverseImpliesReturnsDisabled.kt"")
          public void testReverseImpliesReturnsDisabled() {
            runTest(""compiler/testData/diagnostics/testsWithStdLib/contracts/dsl/errors/reverseImpliesReturnsDisabled.kt"");
          }

          @Test
          @TestMetadata(""reverseImpliesReturnsDslDisabled.kt"")
          public void testReverseImpliesReturnsDslDisabled() {
            runTest(""compiler/testData/diagnostics/testsWithStdLib/contracts/dsl/errors/reverseImpliesReturnsDslDisabled.kt"");
          }

          @Test
          @TestMetadata(""typeReferences.1.4.kt"")
          public void testTypeReferences_1_4() {
            runTest(""compiler/testData/diagnostics/testsWithStdLib/contracts/dsl/errors/typeReferences.1.4.kt"");
          }

          @Test
          @TestMetadata(""unlabeledReceiver.kt"")
          public void testUnlabeledReceiver() {
            runTest(""compiler/testData/diagnostics/testsWithStdLib/contracts/dsl/errors/unlabeledReceiver.kt"");
          }
        }",KOT_01708,,,0
duckduckgo__Android,f5fab295c83d4ae996a4d5c978a2d185190b2e48,anrs/anrs-impl/src/main/java/com/duckduckgo/app/anr/AnrOfflinePixelSender.kt,.kt,Marcos,marcosh@duckduckgo.com,2024-09-26T15:21:02+01:00,Convert enum to data class and store tag/pixel name (#5057),1,,"/*
 * Copyright (c) 2021 DuckDuckGo
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.duckduckgo.app.anr

import android.util.Base64
import com.duckduckgo.anrs.api.AnrRepository
import com.duckduckgo.app.statistics.api.OfflinePixel
import com.duckduckgo.app.statistics.api.PixelSender
import com.duckduckgo.app.statistics.pixels.Pixel
import com.duckduckgo.app.statistics.pixels.Pixel.PixelType.COUNT
import com.duckduckgo.di.scopes.AppScope
import com.squareup.anvil.annotations.ContributesMultibinding
import io.reactivex.Completable
import io.reactivex.Completable.complete
import io.reactivex.Completable.defer
import javax.inject.Inject

@ContributesMultibinding(AppScope::class)
class AnrOfflinePixelSender @Inject constructor(
    private val anrRepository: AnrRepository,
    private val pixelSender: PixelSender,
) : OfflinePixel {
    override fun send(): Completable {
        return defer {
            val anr = anrRepository.peekMostRecentAnr()
            anr?.let {
                val ss = Base64.encodeToString(it.stackTrace.joinToString(""\n"").toByteArray(), Base64.NO_WRAP or Base64.NO_PADDING or Base64.URL_SAFE)
                return@defer pixelSender.sendPixel(
                    AnrPixelName.ANR_PIXEL.pixelName,
                    mapOf(
                        ANR_STACKTRACE to ss,
                        ANR_WEBVIEW_VERSION to it.webView,
                        ANR_CUSTOM_TAB to it.customTab.toString(),
                    ),
                    mapOf(),
                    COUNT,
                ).ignoreElement().doOnComplete {
                    anrRepository.removeMostRecentAnr()
                }
            }
            return@defer complete()
        }
    }

    companion object {
        private const val ANR_STACKTRACE = ""stackTrace""
        private const val ANR_WEBVIEW_VERSION = ""webView""
        private const val ANR_CUSTOM_TAB = ""customTab""
    }
}

enum class AnrPixelName(override val pixelName: String) : Pixel.PixelName {
    ANR_PIXEL(""m_anr_exception""),
}
",KSEC_2086,['CWE-321: Hard-coded Cryptographic Key'],"['A02: Cryptographic Failures', 'A04: Insecure Design']",1
JetBrains__kotlin,335284041043d2f6e6a51f233b3694670afbe341,js/js.translator/testData/box/esModules/escapedIdentifiers/topLevelExportedClass.kt,.kt,Artem Kobzar,artem.kobzar@jetbrains.com,2025-08-15T13:33:19+02:00,[K/JS] Fix exporting declarations with escaped identifier in ES modules,1,,"// ES_MODULES
// LANGUAGE: +JsAllowInvalidCharsIdentifiersEscaping

// MODULE: lib
// FILE: lib.kt

@JsExport
class `invalid@class-name `() {
    fun foo(): Int = 42
}

// FILE: test.mjs
// ENTRY_ES_MODULE
import { ""invalid@class-name "" as  InvalidClass } from ""./topLevelExportedClass-lib_v5.mjs"";

export function box() {
    var instance = new InvalidClass()
    var value = instance.foo()

    if (value !== 42)
        return ""false: expect exproted class function to return 42 but it equals "" + value

    return ""OK""
}",KOT_02458,,,0
JetBrains__kotlin,16322eb20fdbfc989013c016d61cc41ae6388a88,compiler/cli/src/org/jetbrains/kotlin/cli/common/arguments.kt,.kt,Simon Ogorodnik,simon.ogorodnik@jetbrains.com,2021-07-14T18:19:39+03:00,Fix case when `DUMP_MODEL` variable was not set,1,,"/*
 * Copyright 2010-2025 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.cli.common

import com.intellij.ide.highlighter.JavaFileType
import org.jetbrains.kotlin.cli.common.arguments.CommonCompilerArguments
import org.jetbrains.kotlin.cli.common.arguments.CommonToolArguments
import org.jetbrains.kotlin.cli.common.arguments.ManualLanguageFeatureSetting
import org.jetbrains.kotlin.cli.common.arguments.toLanguageVersionSettings
import org.jetbrains.kotlin.cli.common.messages.CompilerMessageSeverity
import org.jetbrains.kotlin.cli.common.messages.MessageCollector
import org.jetbrains.kotlin.config.*
import org.jetbrains.kotlin.metadata.deserialization.BinaryVersion
import org.jetbrains.kotlin.types.AbstractTypeChecker
import org.jetbrains.kotlin.types.FlexibleTypeImpl
import org.jetbrains.kotlin.utils.DFS
import org.jetbrains.kotlin.utils.KotlinPaths
import org.jetbrains.kotlin.utils.KotlinPathsFromHomeDir
import org.jetbrains.kotlin.utils.PathUtil
import java.io.File

fun CompilerConfiguration.setupCommonArguments(
    arguments: CommonCompilerArguments,
    createMetadataVersion: ((IntArray) -> BinaryVersion)? = null
) {
    val messageCollector = getNotNull(CommonConfigurationKeys.MESSAGE_COLLECTOR_KEY)

    put(CommonConfigurationKeys.DISABLE_INLINE, arguments.noInline)
    put(CommonConfigurationKeys.USE_FIR_EXTRA_CHECKERS, arguments.extraWarnings)
    put(CommonConfigurationKeys.USE_FIR_EXPERIMENTAL_CHECKERS, arguments.useFirExperimentalCheckers)
    put(CommonConfigurationKeys.METADATA_KLIB, arguments.metadataKlib)
    putIfNotNull(CommonConfigurationKeys.DUMP_MODEL, arguments.dumpArgumentsDir)
    putIfNotNull(CommonConfigurationKeys.DUMP_MODEL, System.getenv(""KOTLIN_DUMP_MODEL"").takeUnless { it.isEmpty() })
    putIfNotNull(CLIConfigurationKeys.INTELLIJ_PLUGIN_ROOT, arguments.intellijPluginRoot)
    put(CommonConfigurationKeys.REPORT_OUTPUT_FILES, arguments.reportOutputFiles)
    put(CommonConfigurationKeys.INCREMENTAL_COMPILATION, incrementalCompilationIsEnabled(arguments))
    put(CommonConfigurationKeys.ALLOW_ANY_SCRIPTS_IN_SOURCE_ROOTS, arguments.allowAnyScriptsInSourceRoots)
    put(CommonConfigurationKeys.IGNORE_CONST_OPTIMIZATION_ERRORS, arguments.ignoreConstOptimizationErrors)

    val irVerificationMode = arguments.verifyIr?.let { verifyIrString ->
        IrVerificationMode.resolveMode(verifyIrString).also {
            if (it == null) {
                messageCollector.report(CompilerMessageSeverity.ERROR, ""Unsupported IR verification mode $verifyIrString"")
            }
        }
    } ?: IrVerificationMode.NONE
    put(CommonConfigurationKeys.VERIFY_IR, irVerificationMode)

    if (arguments.verifyIrVisibility) {
        put(CommonConfigurationKeys.ENABLE_IR_VISIBILITY_CHECKS, true)
        if (irVerificationMode == IrVerificationMode.NONE) {
            messageCollector.report(
                CompilerMessageSeverity.WARNING,
                ""'-Xverify-ir-visibility' has no effect unless '-Xverify-ir=warning' or '-Xverify-ir=error' is specified""
            )
        }
    }

    setupMetadataVersion(arguments, createMetadataVersion)

    setupLanguageVersionSettings(arguments)

    val usesK2 = languageVersionSettings.languageVersion.usesK2
    put(CommonConfigurationKeys.USE_FIR, usesK2)
    put(CommonConfigurationKeys.USE_LIGHT_TREE, arguments.useFirLT)
    buildHmppModuleStructure(arguments)?.let { put(CommonConfigurationKeys.HMPP_MODULE_STRUCTURE, it) }

    if (arguments.debugLevelCompilerChecks) {
        FlexibleTypeImpl.RUN_SLOW_ASSERTIONS = true
        AbstractTypeChecker.RUN_SLOW_ASSERTIONS = true
    }
}

fun CompilerConfiguration.setupMetadataVersion(
    arguments: CommonCompilerArguments,
    createMetadataVersion: ((IntArray) -> BinaryVersion)?,
) {
    val metadataVersionString = arguments.metadataVersion
    if (metadataVersionString != null) {
        val versionArray = BinaryVersion.parseVersionArray(metadataVersionString)
        when {
            versionArray == null -> messageCollector.report(
                CompilerMessageSeverity.ERROR, ""Invalid metadata version: $metadataVersionString"", null
            )
            createMetadataVersion == null -> throw IllegalStateException(""Unable to create metadata version: missing argument"")
            else -> put(CommonConfigurationKeys.METADATA_VERSION, createMetadataVersion(versionArray))
        }
    }
}

fun CompilerConfiguration.setupLanguageVersionSettings(arguments: CommonCompilerArguments) {
    languageVersionSettings = arguments.toLanguageVersionSettings(getNotNull(CommonConfigurationKeys.MESSAGE_COLLECTOR_KEY))
}

const val KOTLIN_HOME_PROPERTY = ""kotlin.home""

fun computeKotlinPaths(messageCollector: MessageCollector, arguments: CommonCompilerArguments): KotlinPaths? {
    val kotlinHomeProperty = System.getProperty(KOTLIN_HOME_PROPERTY)
    val kotlinHome = when {
        arguments.kotlinHome != null -> File(arguments.kotlinHome!!)
        kotlinHomeProperty != null -> File(kotlinHomeProperty)
        else -> null
    }

    return when {
        kotlinHome == null -> PathUtil.kotlinPathsForCompiler
        kotlinHome.isDirectory -> KotlinPathsFromHomeDir(kotlinHome)
        else -> {
            messageCollector.report(CompilerMessageSeverity.ERROR, ""Kotlin home does not exist or is not a directory: $kotlinHome"", null)
            null
        }
    }?.also {
        messageCollector.report(CompilerMessageSeverity.LOGGING, ""Using Kotlin home directory "" + it.homePath, null)
    }
}

fun MessageCollector.reportArgumentParseProblems(arguments: CommonToolArguments) {
    val errors = arguments.errors ?: return
    for (flag in errors.unknownExtraFlags) {
        report(CompilerMessageSeverity.STRONG_WARNING, ""Flag is not supported by this version of the compiler: $flag"")
    }
    for (argument in errors.extraArgumentsPassedInObsoleteForm) {
        report(
            CompilerMessageSeverity.STRONG_WARNING,
            ""Advanced option value is passed in an obsolete form. Please use the '=' character to specify the value: $argument=...""
        )
    }
    for ((key, value) in errors.duplicateArguments) {
        report(CompilerMessageSeverity.STRONG_WARNING, ""Argument $key is passed multiple times. Only the last value will be used: $value"")
    }
    for ((deprecatedName, newName) in errors.deprecatedArguments) {
        report(CompilerMessageSeverity.STRONG_WARNING, ""Argument $deprecatedName is deprecated. Please use $newName instead"")
    }
    for (argfileError in errors.argfileErrors) {
        report(CompilerMessageSeverity.STRONG_WARNING, argfileError)
    }

    reportUnsafeInternalArgumentsIfAny(arguments)

    for ((severity, internalArgumentsProblem) in errors.internalArgumentsParsingProblems) {
        report(severity, internalArgumentsProblem)
    }
}

private fun MessageCollector.reportUnsafeInternalArgumentsIfAny(arguments: CommonToolArguments) {
    val unsafeArguments = arguments.internalArguments.filterNot {
        // -XXLanguage which turns on BUG_FIX considered safe
        it is ManualLanguageFeatureSetting && it.languageFeature.kind == LanguageFeature.Kind.BUG_FIX && it.state == LanguageFeature.State.ENABLED
    }

    if (unsafeArguments.isNotEmpty()) {
        val unsafeArgumentsString = unsafeArguments.joinToString(prefix = ""\n"", postfix = ""\n\n"", separator = ""\n"") {
            it.stringRepresentation
        }

        report(
            CompilerMessageSeverity.STRONG_WARNING,
            ""ATTENTION!\n"" +
                    ""This build uses unsafe internal compiler arguments:\n"" +
                    unsafeArgumentsString +
                    ""This mode is not recommended for production use,\n"" +
                    ""as no stability/compatibility guarantees are given on\n"" +
                    ""compiler or generated code. Use it at your own risk!\n""
        )
    }
}

private fun CompilerConfiguration.buildHmppModuleStructure(arguments: CommonCompilerArguments): HmppCliModuleStructure? {
    val rawFragments = arguments.fragments
    val rawFragmentSources = arguments.fragmentSources
    val rawFragmentRefines = arguments.fragmentRefines

    val messageCollector = getNotNull(CommonConfigurationKeys.MESSAGE_COLLECTOR_KEY)

    fun reportError(message: String) {
        messageCollector.report(CompilerMessageSeverity.ERROR, message)
    }

    fun reportWarning(message: String) {
        messageCollector.report(CompilerMessageSeverity.WARNING, message)
    }

    if (rawFragments == null) {
        if (rawFragmentRefines != null) {
            reportError(""-Xfragment-refines flag can not be used without -Xfragments"")
        }
        return null
    }

    if (!languageVersionSettings.languageVersion.usesK2) {
        reportWarning(""-Xfragments flag is not supported for language version < 2.0"")
        return null
    }


    val sourcesByFragmentName: Map<String, Set<String>> = rawFragments.associateWith { mutableSetOf<String>() }.apply {
        rawFragmentSources.orEmpty().forEach { rawFragmentSourceArg ->
            val split = rawFragmentSourceArg.split("":"", limit = 2)
            if (split.size < 2) {
                reportError(
                    ""Incorrect syntax for -Xfragment-sources argument. "" +
                            ""`<module name>:<source file>` expected but got `$rawFragmentSourceArg`""
                )
                return@forEach
            }
            val fragmentName = split[0]
            val fragmentSource = split[1]

            getOrElse(fragmentName) {
                reportError(
                    ""Passed $rawFragmentSourceArg, "" +
                            ""but fragment `$fragmentName` of source file $fragmentSource is not specified in -Xfragments""
                )
                return@forEach
            }.add(fragmentSource)
        }
    }

    var modules = sourcesByFragmentName.map { (fragmentName, sources) -> HmppCliModule(fragmentName, sources) }

    var wasError = false
    // check sources mapping
    for (i in modules.indices) {
        val m1 = modules[i]
        for (j in (i + 1) until modules.size) {
            val m2 = modules[j]
            val commonFiles = m1.sources.intersect(m2.sources)
            if (commonFiles.isNotEmpty()) {
                val message = buildString {
                    if (commonFiles.size == 1) {
                        append(""File '${commonFiles.single()}'"")
                    } else {
                        append(""Files "")
                        append(commonFiles.joinToString("", "") { ""'$it'"" })
                    }
                    append(
                        "" can be a part of only one module, but is listed as a source for both `${m1.name}` and `${m2.name}`, "" +
                                ""please check you -Xfragment-sources options.""
                    )
                }
                reportError(message)
                wasError = true
            }
        }
    }

    for (source in arguments.freeArgs) {
        if (source.endsWith(JavaFileType.DOT_DEFAULT_EXTENSION)) continue
        if (modules.none { source in it.sources }) {
            reportError(""Source '$source' does not belong to any module"")
            wasError = true
        }
    }

    if (wasError) {
        return null
    }

    if (modules.size == 1) {
        if (rawFragmentRefines?.isNotEmpty() == true) {
            reportError(""-Xfragment-refines flag is specified but there is only one module declared"")
        }
        return HmppCliModuleStructure(modules, emptyMap())
    }

    val duplicatedModules = modules.filter { module -> modules.count { it.name == module.name } > 1 }

    if (duplicatedModules.isNotEmpty()) {
        reportError(""There are multiple modules with same name(s): ${duplicatedModules.distinct().joinToString("", "") { it.name }}"")
        return null
    }

    val moduleByName = modules.associateBy { it.name }

    val dependenciesMap = rawFragmentRefines.orEmpty().mapNotNull { rawFragmentRefinesEdge ->
        val split = rawFragmentRefinesEdge.split("":"")
        if (split.size != 2) {
            reportError(
                ""Incorrect syntax for -Xfragment-refines argument. "" +
                        ""Expected <fromModuleName>:<onModuleName> but got `$rawFragmentRefines`""
            )
            return@mapNotNull null
        }
        val moduleName1 = split[0]
        val moduleName2 = split[1]

        fun findModule(name: String): HmppCliModule? {
            return moduleByName[name].also { module ->
                if (module == null) {
                    reportError(""`-Xfragment-refines=$rawFragmentRefinesEdge` Fragment `$name` not found in -Xfragments arguments"")
                }
            }
        }

        val module1 = findModule(moduleName1)
        val module2 = findModule(moduleName2)
        if (module1 == null || module2 == null) return@mapNotNull null
        module1 to module2
    }.groupBy(
        keySelector = { it.first },
        valueTransform = { it.second }
    )

    modules = DFS.topologicalOrder(modules) { dependenciesMap[it].orEmpty() }.asReversed()

    modules.forEachIndexed { i, module ->
        val dependencies = dependenciesMap[module].orEmpty()
        val previousModules = modules.subList(0, i)
        if (dependencies.any { it !in previousModules }) {
            reportError(""There is a cycle in dependencies of module `${module.name}`"")
        }
    }

    return HmppCliModuleStructure(modules, dependenciesMap)
}
",KOT_02171,CWE-321: Hard-coded Cryptographic Key,A02: Cryptographic Failures;A04: Insecure Design,1
thunderbird__thunderbird-android,44eb34ac13503d89d90822b6b1752c624037b638,feature/navigation/drawer/siderail/src/main/kotlin/net/thunderbird/feature/navigation/drawer/siderail/ui/DrawerContract.kt,.kt,Wolf-Martell Montwé,wolf@thunderbird.net,2025-05-13T17:55:47+02:00,fix(drawer): openFolder must be called with accountId and folderId,1,OpenFolder,"        data class OpenFolder(val accountId: String, val folderId: Long) : Effect
        data object OpenUnifiedFolder : Effect
        data object OpenManageFolders : Effect
        data object OpenSettings : Effect
        data object CloseDrawer : Effect
    }
}",KSEC_2107,,,0
square__okhttp,fa2de5413d42eb49d030656e849f9fbd97c625ee,android-test/src/androidTest/java/okhttp/android/test/OkHttpTest.kt,.kt,Yuri Schimke,yuri@schimke.ee,2023-05-27T14:58:52+01:00,Fix android test (#7862),1,OkHttpTest,"class OkHttpTest {

  @Suppress(""RedundantVisibilityModifier"")
  @JvmField
  @RegisterExtension public val platform = PlatformRule()

  @Suppress(""RedundantVisibilityModifier"")
  @JvmField
  @RegisterExtension public val clientTestRule = OkHttpClientTestRule().apply {
    logger = Logger.getLogger(OkHttpTest::class.java.name)
  }

  private var client: OkHttpClient = clientTestRule.newClient()

  private val moshi = Moshi.Builder()
    .add(KotlinJsonAdapterFactory())
    .build()

  private val handshakeCertificates = localhost()

  private lateinit var server: MockWebServer

  @BeforeEach
  fun setup(server: MockWebServer) {
    this.server = server
  }

  @Test
  fun testPlatform() {
    assertTrue(Platform.isAndroid)

    if (Build.VERSION.SDK_INT >= 29) {
      assertTrue(Platform.get() is Android10Platform)
    } else {
      assertTrue(Platform.get() is AndroidPlatform)
    }
  }

  @Test
  fun testRequest() {
    assumeNetwork()

    val request = Request.Builder().url(""https://api.twitter.com/robots.txt"").build()

    val clientCertificates = HandshakeCertificates.Builder()
      .addPlatformTrustedCertificates()
      .apply {
        if (Build.VERSION.SDK_INT >= 24) {
          addInsecureHost(server.hostName)
        }
      }
      .build()

    client = client.newBuilder()
      .sslSocketFactory(clientCertificates.sslSocketFactory(), clientCertificates.trustManager)
      .build()

    val response = client.newCall(request).execute()

    response.use {
      assertEquals(404, response.code)
    }

    if (Build.VERSION.SDK_INT >= 24) {
      localhostInsecureRequest()
    }
  }

  @Test
  fun testRequestWithSniRequirement() {
    assumeNetwork()

    val request = Request.Builder().url(""https://docs.fabric.io/android/changelog.html"").build()

    val response = client.newCall(request).execute()

    response.use {
      assertEquals(200, response.code)
    }
  }

  @Test
  fun testConscryptRequest() {
    assumeNetwork()

    try {
      Security.insertProviderAt(Conscrypt.newProviderBuilder().build(), 1)

      val request = Request.Builder().url(""https://facebook.com/robots.txt"").build()

      var socketClass: String? = null

      val clientCertificates = HandshakeCertificates.Builder()
        .addPlatformTrustedCertificates()
        .addInsecureHost(server.hostName)
        .build()

      // Need fresh client to reset sslSocketFactoryOrNull
      client = OkHttpClient.Builder()
        .eventListenerFactory(
          clientTestRule.wrap(object : EventListener() {
            override fun connectionAcquired(call: Call, connection: Connection) {
              socketClass = connection.socket().javaClass.name
            }
          })
        )
        .sslSocketFactory(clientCertificates.sslSocketFactory(), clientCertificates.trustManager)
        .build()

      val response = client.newCall(request).execute()

      response.use {
        assertEquals(Protocol.HTTP_2, response.protocol)
        assertEquals(200, response.code)
        // see https://github.com/google/conscrypt/blob/b9463b2f74df42d85c73715a5f19e005dfb7b802/android/src/main/java/org/conscrypt/Platform.java#L613
        when {
          Build.VERSION.SDK_INT >= 24 -> {
            // Conscrypt 2.5+ defaults to SSLEngine-based SSLSocket
            assertEquals(""org.conscrypt.Java8EngineSocket"", socketClass)
          }
          Build.VERSION.SDK_INT < 22 -> {
            assertEquals(""org.conscrypt.KitKatPlatformOpenSSLSocketImplAdapter"", socketClass)
          }
          else -> {
            assertEquals(""org.conscrypt.ConscryptFileDescriptorSocket"", socketClass)
          }
        }
        assertEquals(TlsVersion.TLS_1_3, response.handshake?.tlsVersion)
      }

      localhostInsecureRequest()
    } finally {
      Security.removeProvider(""Conscrypt"")
      client.close()
    }
  }

  @Test
  fun testRequestUsesPlayProvider() {
    assumeNetwork()

    try {
      try {
        ProviderInstaller.installIfNeeded(InstrumentationRegistry.getInstrumentation().targetContext)
      } catch (gpsnae: GooglePlayServicesNotAvailableException) {
        throw TestAbortedException(""Google Play Services not available"", gpsnae)
      }

      val clientCertificates = HandshakeCertificates.Builder()
        .addPlatformTrustedCertificates()
        .addInsecureHost(server.hostName)
        .build()

      val request = Request.Builder().url(""https://facebook.com/robots.txt"").build()

      var socketClass: String? = null

      // Need fresh client to reset sslSocketFactoryOrNull
      client = OkHttpClient.Builder()
        .eventListenerFactory(
          clientTestRule.wrap(object : EventListener() {
            override fun connectionAcquired(call: Call, connection: Connection) {
              socketClass = connection.socket().javaClass.name
            }
          })
        )
        .sslSocketFactory(clientCertificates.sslSocketFactory(), clientCertificates.trustManager)
        .build()

      val response = client.newCall(request).execute()

      response.use {
        assertEquals(Protocol.HTTP_2, response.protocol)
        assertEquals(200, response.code)
        assertEquals(""com.google.android.gms.org.conscrypt.Java8FileDescriptorSocket"", socketClass)
        assertEquals(TlsVersion.TLS_1_2, response.handshake?.tlsVersion)
      }

      localhostInsecureRequest()
    } finally {
      Security.removeProvider(""GmsCore_OpenSSL"")
      client.close()
    }
  }

  private fun localhostInsecureRequest() {
    server.useHttps(handshakeCertificates.sslSocketFactory())

    server.enqueue(MockResponse())

    val request = Request.Builder().url(server.url(""/"")).build()

    client.newCall(request).execute().use {
      assertEquals(200, it.code)
      assertEquals(listOf<Certificate>(), it.handshake?.peerCertificates)
    }
  }

  @Test
  fun testRequestUsesAndroidConscrypt() {
    assumeNetwork()

    val request = Request.Builder().url(""https://facebook.com/robots.txt"").build()

    var socketClass: String? = null

    val clientCertificates = HandshakeCertificates.Builder()
      .addPlatformTrustedCertificates().apply {
        if (Build.VERSION.SDK_INT >= 24) {
          addInsecureHost(server.hostName)
        }
      }
      .build()

    client = client.newBuilder()
      .eventListenerFactory(
        clientTestRule.wrap(object : EventListener() {
          override fun connectionAcquired(call: Call, connection: Connection) {
            socketClass = connection.socket().javaClass.name
          }
        })
      )
      .sslSocketFactory(clientCertificates.sslSocketFactory(), clientCertificates.trustManager)
      .build()

    val response = client.newCall(request).execute()

    response.use {
      assertEquals(Protocol.HTTP_2, response.protocol)
      if (Build.VERSION.SDK_INT >= 29) {
        assertEquals(TlsVersion.TLS_1_3, response.handshake?.tlsVersion)
      } else {
        assertEquals(TlsVersion.TLS_1_2, response.handshake?.tlsVersion)
      }
      assertEquals(200, response.code)
      assertTrue(socketClass?.startsWith(""com.android.org.conscrypt."") == true)
    }

    if (Build.VERSION.SDK_INT >= 24) {
      localhostInsecureRequest()
    }
  }

  @Test
  fun testHttpRequestNotBlockedOnLegacyAndroid() {
    assumeTrue(Build.VERSION.SDK_INT < 23)

    val request = Request.Builder().url(""http://squareup.com/robots.txt"").build()

    val response = client.newCall(request).execute()

    response.use {
      assertEquals(200, response.code)
    }
  }

  @Test
  @Disabled(""cleartext required for additional okhttp wide tests"")
  fun testHttpRequestBlocked() {
    assumeTrue(Build.VERSION.SDK_INT >= 23)

    val request = Request.Builder().url(""http://squareup.com/robots.txt"").build()

    try {
      client.newCall(request).execute()
      fail<Any>(""expected cleartext blocking"")
    } catch (_: java.net.UnknownServiceException) {
    }
  }

  data class HowsMySslResults(
    val unknown_cipher_suite_supported: Boolean,
    val beast_vuln: Boolean,
    val session_ticket_supported: Boolean,
    val tls_compression_supported: Boolean,
    val ephemeral_keys_supported: Boolean,
    val rating: String,
    val tls_version: String,
    val able_to_detect_n_minus_one_splitting: Boolean,
    val insecure_cipher_suites: Map<String, List<String>>,
    val given_cipher_suites: List<String>?
  )

  @Test
  @Disabled
  fun testSSLFeatures() {
    assumeNetwork()

    val request = Request.Builder().url(""https://www.howsmyssl.com/a/check"").build()

    val response = client.newCall(request).execute()

    val results = response.use {
      moshi.adapter(HowsMySslResults::class.java).fromJson(response.body.string())!!
    }

    Platform.get().log(""results $results"", Platform.WARN)

    assertTrue(results.session_ticket_supported)
    assertEquals(""Probably Okay"", results.rating)
    // TODO map to expected versions automatically, test ignored for now.  Run manually.
    assertEquals(""TLS 1.3"", results.tls_version)
    assertEquals(0, results.insecure_cipher_suites.size)

    assertEquals(TlsVersion.TLS_1_3, response.handshake?.tlsVersion)
    assertEquals(Protocol.HTTP_2, response.protocol)
  }

  @Test
  fun testMockWebserverRequest() {
    enableTls()

    server.enqueue(MockResponse(body = ""abc""))

    val request = Request.Builder().url(server.url(""/"")).build()

    val response = client.newCall(request).execute()

    response.use {
      assertEquals(200, response.code)
      assertEquals(Protocol.HTTP_2, response.protocol)
      val tlsVersion = response.handshake?.tlsVersion
      assertTrue(tlsVersion == TlsVersion.TLS_1_2 || tlsVersion == TlsVersion.TLS_1_3)
      assertEquals(
        ""CN=localhost"",
        (response.handshake!!.peerCertificates.first() as X509Certificate).subjectDN.name
      )
    }
  }

  @Test
  fun testCertificatePinningFailure() {
    enableTls()

    val certificatePinner = CertificatePinner.Builder()
      .add(server.hostName, ""sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="")
      .build()
    client = client.newBuilder().certificatePinner(certificatePinner).build()

    server.enqueue(MockResponse(body = ""abc""))

    val request = Request.Builder().url(server.url(""/"")).build()

    try {
      client.newCall(request).execute()
      fail<Any>("""")
    } catch (_: SSLPeerUnverifiedException) {
    }
  }

  @Test
  fun testCertificatePinningSuccess() {
    enableTls()

    val certificatePinner = CertificatePinner.Builder()
      .add(
        server.hostName,
        CertificatePinner.pin(handshakeCertificates.trustManager.acceptedIssuers[0])
      )
      .build()
    client = client.newBuilder().certificatePinner(certificatePinner).build()

    server.enqueue(MockResponse(body = ""abc""))

    val request = Request.Builder().url(server.url(""/"")).build()

    val response = client.newCall(request).execute()

    response.use {
      assertEquals(200, response.code)
    }
  }

  @Test
  fun testEventListener() {
    val eventListener = RecordingEventListener()

    enableTls()

    client = client.newBuilder().eventListenerFactory(clientTestRule.wrap(eventListener)).build()

    server.enqueue(MockResponse(body = ""abc1""))
    server.enqueue(MockResponse(body = ""abc2""))

    val request = Request.Builder().url(server.url(""/"")).build()

    client.newCall(request).execute().use { response ->
      assertEquals(200, response.code)
    }

    assertEquals(
      listOf(
        ""CallStart"", ""ProxySelectStart"", ""ProxySelectEnd"", ""DnsStart"", ""DnsEnd"",
        ""ConnectStart"", ""SecureConnectStart"", ""SecureConnectEnd"", ""ConnectEnd"",
        ""ConnectionAcquired"", ""RequestHeadersStart"", ""RequestHeadersEnd"", ""ResponseHeadersStart"",
        ""ResponseHeadersEnd"", ""ResponseBodyStart"", ""ResponseBodyEnd"", ""ConnectionReleased"",
        ""CallEnd""
      ),
      eventListener.recordedEventTypes()
    )

    eventListener.clearAllEvents()

    client.newCall(request).execute().use { response ->
      assertEquals(200, response.code)
    }

    assertEquals(
      listOf(
        ""CallStart"",
        ""ConnectionAcquired"", ""RequestHeadersStart"", ""RequestHeadersEnd"", ""ResponseHeadersStart"",
        ""ResponseHeadersEnd"", ""ResponseBodyStart"", ""ResponseBodyEnd"", ""ConnectionReleased"",
        ""CallEnd""
      ),
      eventListener.recordedEventTypes()
    )
  }

  @Test
  fun testSessionReuse() {
    val sessionIds = mutableListOf<String>()

    enableTls()

    client = client.newBuilder().eventListenerFactory(
      clientTestRule.wrap(object : EventListener() {
        override fun connectionAcquired(call: Call, connection: Connection) {
          val sslSocket = connection.socket() as SSLSocket

          sessionIds.add(sslSocket.session.id.toByteString().hex())
        }
      })
    ).build()

    server.enqueue(MockResponse(body = ""abc1""))
    server.enqueue(MockResponse(body = ""abc2""))

    val request = Request.Builder().url(server.url(""/"")).build()

    client.newCall(request).execute().use { response ->
      assertEquals(200, response.code)
    }

    client.connectionPool.evictAll()
    assertEquals(0, client.connectionPool.connectionCount())

    client.newCall(request).execute().use { response ->
      assertEquals(200, response.code)
    }

    assertEquals(2, sessionIds.size)
    assertEquals(sessionIds[0], sessionIds[1])
  }

  @Test
  fun testDnsOverHttps() {
    assumeNetwork()

    client = client.newBuilder()
      .eventListenerFactory(clientTestRule.wrap(LoggingEventListener.Factory()))
      .build()

    val dohDns = buildCloudflareIp(client)
    val dohEnabledClient =
      client.newBuilder().eventListener(EventListener.NONE).dns(dohDns).build()

    dohEnabledClient.get(""https://www.twitter.com/robots.txt"")
    dohEnabledClient.get(""https://www.facebook.com/robots.txt"")
  }

  @Test
  fun testCustomTrustManager() {
    assumeNetwork()

    val trustManager = object : X509TrustManager {
      override fun checkClientTrusted(chain: Array<out X509Certificate>?, authType: String?) {}

      override fun checkServerTrusted(chain: Array<out X509Certificate>?, authType: String?) {}

      override fun getAcceptedIssuers(): Array<X509Certificate> = arrayOf()
    }

    val sslContext = Platform.get().newSSLContext().apply {
      init(null, arrayOf(trustManager), null)
    }
    val sslSocketFactory = sslContext.socketFactory

    val hostnameVerifier = HostnameVerifier { _, _ -> true }

    client = client.newBuilder()
      .sslSocketFactory(sslSocketFactory, trustManager)
      .hostnameVerifier(hostnameVerifier)
      .build()

    client.get(""https://www.facebook.com/robots.txt"")
  }

  @Test
  fun testCustomSSLSocketFactoryWithoutALPN() {
    enableTls()

    server.enqueue(MockResponse(body = ""abc""))

    val sslSocketFactory = client.sslSocketFactory
    val trustManager = client.x509TrustManager!!

    val delegatingSocketFactory = object : DelegatingSSLSocketFactory(sslSocketFactory) {
      override fun configureSocket(sslSocket: SSLSocket): SSLSocket {
        return object : DelegatingSSLSocket(sslSocket) {
          override fun getApplicationProtocol(): String {
            throw UnsupportedOperationException()
          }
        }
      }
    }

    client = client.newBuilder()
      .sslSocketFactory(delegatingSocketFactory, trustManager)
      .build()

    val request = Request.Builder().url(server.url(""/"").toString()).build()
    val response = client.newCall(request).execute()
    response.use {
      assertEquals(200, response.code)
      assertEquals(Protocol.HTTP_1_1, response.protocol)
    }
  }

  @Test
  fun testCustomTrustManagerWithAndroidCheck() {
    assumeNetwork()

    var withHostCalled = false
    var withoutHostCalled = false
    val trustManager = object : X509TrustManager {
      override fun checkClientTrusted(chain: Array<out X509Certificate>?, authType: String?) {}

      override fun checkServerTrusted(chain: Array<out X509Certificate>?, authType: String?) {
        withoutHostCalled = true
      }

      @Suppress(""unused"", ""UNUSED_PARAMETER"")
      // called by Android via reflection in X509TrustManagerExtensions
      fun checkServerTrusted(chain: Array<out X509Certificate>, authType: String, hostname: String): List<X509Certificate> {
        withHostCalled = true
        return chain.toList()
      }

      override fun getAcceptedIssuers(): Array<X509Certificate> = arrayOf()
    }

    val sslContext = Platform.get().newSSLContext().apply {
      init(null, arrayOf(trustManager), null)
    }
    val sslSocketFactory = sslContext.socketFactory

    val hostnameVerifier = HostnameVerifier { _, _ -> true }

    client = client.newBuilder()
      .sslSocketFactory(sslSocketFactory, trustManager)
      .hostnameVerifier(hostnameVerifier)
      .build()

    client.get(""https://www.facebook.com/robots.txt"")

    if (Build.VERSION.SDK_INT < 24) {
      assertFalse(withHostCalled)
      assertTrue(withoutHostCalled)
    } else {
      assertTrue(withHostCalled)
      assertFalse(withoutHostCalled)
    }
  }

  @Test
  fun testUnderscoreRequest() {
    assumeNetwork()

    val request =
      Request.Builder().url(""https://example_underscore_123.s3.amazonaws.com/"").build()

    try {
      client.newCall(request).execute().close()
      // Hopefully this passes
    } catch (ioe: IOException) {
      // https://github.com/square/okhttp/issues/5840
      when (ioe.cause) {
        is IllegalArgumentException -> {
          assertEquals(""Android internal error"", ioe.message)
        }
        is CertificateException -> {
          assertTrue(ioe.cause?.cause is IllegalArgumentException)
          assertEquals(true, ioe.cause?.cause?.message?.startsWith(""Invalid input to toASCII""))
        }
        else -> throw ioe
      }
    }
  }

  @Test
  @Disabled(""breaks conscrypt test"")
  fun testBouncyCastleRequest() {
    assumeNetwork()

    try {
      Security.insertProviderAt(BouncyCastleProvider(), 1)
      Security.insertProviderAt(BouncyCastleJsseProvider(), 2)

      var socketClass: String? = null

      val trustManager = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()).apply {
        init(null as KeyStore?)
      }.trustManagers.first() as X509TrustManager

      val sslContext = Platform.get().newSSLContext().apply {
        // TODO remove most of this code after https://github.com/bcgit/bc-java/issues/686
        init(null, arrayOf(trustManager), SecureRandom())
      }

      client = client.newBuilder()
        .sslSocketFactory(sslContext.socketFactory, trustManager)
        .eventListenerFactory(
          clientTestRule.wrap(object : EventListener() {
            override fun connectionAcquired(call: Call, connection: Connection) {
              socketClass = connection.socket().javaClass.name
            }
          })
        )
        .build()

      val request = Request.Builder().url(""https://facebook.com/robots.txt"").build()

      val response = client.newCall(request).execute()

      response.use {
        assertEquals(Protocol.HTTP_2, response.protocol)
        assertEquals(200, response.code)
        assertEquals(""org.bouncycastle.jsse.provider.ProvSSLSocketWrap"", socketClass)
        assertEquals(TlsVersion.TLS_1_2, response.handshake?.tlsVersion)
      }
    } finally {
      Security.removeProvider(""BCJSSE"")
      Security.removeProvider(""BC"")
    }
  }

  @Test
  @Disabled(""TODO: currently logging okhttp3.internal.concurrent.TaskRunner, okhttp3.internal.http2.Http2"")
  fun testLoggingLevels() {
    enableTls()

    val testHandler = object : Handler() {
      val calls = mutableMapOf<String, AtomicInteger>()

      override fun publish(record: LogRecord) {
        calls.getOrPut(record.loggerName) { AtomicInteger(0) }
          .incrementAndGet()
      }

      override fun flush() {
      }

      override fun close() {
      }
    }.apply {
      level = Level.FINEST
    }

    Logger.getLogger("""")
      .addHandler(testHandler)
    Logger.getLogger(""okhttp3"")
      .addHandler(testHandler)
    Logger.getLogger(Http2::class.java.name)
      .addHandler(testHandler)
    Logger.getLogger(TaskRunner::class.java.name)
      .addHandler(testHandler)
    Logger.getLogger(OkHttpClient::class.java.name)
      .addHandler(testHandler)

    server.enqueue(MockResponse(body = ""abc""))

    val request = Request.Builder()
      .url(server.url(""/""))
      .build()

    val response = client.newCall(request)
      .execute()

    response.use {
      assertEquals(200, response.code)
      assertEquals(Protocol.HTTP_2, response.protocol)
    }

    // Only logs to the test logger above
    // Will fail if ""adb shell setprop log.tag.okhttp.Http2 DEBUG"" is called
    assertEquals(setOf(OkHttpTest::class.java.name), testHandler.calls.keys)
  }

  fun testCachedRequest() {
    enableTls()

    server.enqueue(MockResponse(body = ""abc"", headers = Headers.headersOf(""cache-control"", ""public, max-age=3"")))
    server.enqueue(MockResponse(body = ""abc""))

    val ctxt = InstrumentationRegistry.getInstrumentation().targetContext.applicationContext

    val cacheSize = 1L * 1024 * 1024 // 1MB
    val cache = Cache(ctxt.cacheDir.resolve(""testCache""), cacheSize)

    try {
      client = client.newBuilder()
        .cache(cache)
        .build()

      val request = Request.Builder()
        .url(server.url(""/""))
        .build()

      client.newCall(request)
        .execute()
        .use {
          assertEquals(200, it.code)
          assertNull(it.cacheResponse)
          assertNotNull(it.networkResponse)

          assertEquals(3, it.cacheControl.maxAgeSeconds)
          assertTrue(it.cacheControl.isPublic)
        }

      client.newCall(request)
        .execute()
        .use {
          assertEquals(200, it.code)
          assertNotNull(it.cacheResponse)
          assertNull(it.networkResponse)
        }

      assertEquals(1, cache.hitCount())
      assertEquals(1, cache.networkCount())
      assertEquals(2, cache.requestCount())
    } finally {
      cache.delete()
    }
  }

  private fun OkHttpClient.get(url: String) {
    val request = Request.Builder().url(url).build()
    val response = this.newCall(request).execute()

    response.use {
      assertEquals(200, response.code)
    }
  }

  fun buildCloudflareIp(bootstrapClient: OkHttpClient): DnsOverHttps {
    return DnsOverHttps.Builder().client(bootstrapClient)
      .url(""https://1.1.1.1/dns-query"".toHttpUrl())
      .build()
  }

  private fun enableTls() {
    client = client.newBuilder()
      .sslSocketFactory(
        handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager
      )
      .build()
    server.useHttps(handshakeCertificates.sslSocketFactory())
  }

  private fun assumeNetwork() {
    try {
      InetAddress.getByName(""www.google.com"")
    } catch (uhe: UnknownHostException) {
      throw TestAbortedException(uhe.message, uhe)
    }
  }

  fun OkHttpClient.close() {
    dispatcher.executorService.shutdown()
    connectionPool.evictAll()
  }
}",KOT_04620,CWE-295: Improper Certificate Validation;CWE-297: Improper Validation of Certificate with Host Mismatch;CWE-319: Cleartext Transmission of Sensitive Information,A02: Cryptographic Failures;A05: Security Misconfiguration,1
JetBrains__kotlin,0d2fc800522e350f07242723c1ef82b59c5e1710,libraries/tools/kotlin-gradle-plugin-integration-tests/src/test/kotlin/org/jetbrains/kotlin/gradle/testbase/testGradleBuildInjection.kt,.kt,Vladimir Iakunin,vladimir.iakunin@jetbrains.com,2025-05-23T13:40:02+02:00,"[Gradle] explicitly disable isolated projects or fix tests in `Kapt3AndroidIT`, `MppDslAssociateCompilationsIT`, `MppDslLibWithTestsIt`, `MppDslSourceSetsIT` and `MppDslSourcesJarIT`",1,,"/*
 * Copyright 2010-2024 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.gradle.testbase

import com.android.build.api.dsl.CommonExtension
import com.android.build.api.dsl.LibraryExtension
import org.gradle.api.Project
import org.gradle.api.flow.*
import org.gradle.api.initialization.Settings
import org.gradle.api.initialization.dsl.ScriptHandler
import org.gradle.api.plugins.JavaPluginExtension
import org.gradle.api.provider.Property
import org.gradle.api.provider.Provider
import org.gradle.api.publish.PublishingExtension
import org.gradle.api.tasks.Input
import org.gradle.internal.exceptions.MultiCauseException
import org.gradle.internal.extensions.core.serviceOf
import org.gradle.kotlin.dsl.create
import org.gradle.plugin.use.PluginDependenciesSpec
import org.gradle.plugin.use.PluginDependencySpec
import org.gradle.plugin.use.PluginId
import org.gradle.plugins.signing.SigningExtension
import org.gradle.util.GradleVersion
import org.jetbrains.kotlin.gradle.dsl.KotlinJvmProjectExtension
import org.jetbrains.kotlin.gradle.plugin.cocoapods.CocoapodsExtension
import org.jetbrains.kotlin.gradle.dsl.KotlinMultiplatformExtension
import org.jetbrains.kotlin.gradle.plugin.extraProperties
import org.jetbrains.kotlin.gradle.plugin.mpp.apple.swiftexport.SwiftExportExtension
import java.io.File
import java.io.ObjectInputStream
import java.io.ObjectOutputStream
import java.io.Serializable
import java.lang.reflect.Field
import java.nio.file.Path
import kotlin.io.path.*
import kotlin.jvm.optionals.getOrNull

interface GradleBuildScriptInjection<T> : Serializable {
    fun inject(target: T)
}

/**
 * This injection executes as soon as it is injected with its target
 */
class UndispatchedInjection<Context, Target>(
    val instantiateInjectionContext: (Target) -> Context,
    val executeInjection: Context.() -> Unit,
) : GradleBuildScriptInjection<Target> {
    override fun inject(target: Target) = instantiateInjectionContext(target).executeInjection()
}

/**
 * Serializes returned value on build completion that wraps the returned value in a Provider for CC safety.
 *
 * The injection in general executes at:
 * - Provider serialization time with CC
 * - Build completion without CC
 */
class OnBuildCompletionSerializingInjection<Return>(
    val serializedReturnPath: File,
    val returnValueInjection: GradleProjectBuildScriptInjectionContext.() -> Provider<Return>,
) : GradleBuildScriptInjection<Project> {
    class ExecuteOnBuildFinish : FlowAction<ExecuteOnBuildFinish.Parameters> {
        interface Parameters : FlowParameters {
            @get:Input
            val onBuildFinish: Property<() -> Unit>
        }

        override fun execute(parameters: Parameters) {
            parameters.onBuildFinish.get().invoke()
        }
    }

    override fun inject(target: Project) {
        val returnEvaluationProvider = GradleProjectBuildScriptInjectionContext(target).returnValueInjection()
        val serializeOutput = {
            val returnValue = returnEvaluationProvider.orNull
            serializedReturnPath.outputStream().use {
                ObjectOutputStream(it).writeObject(returnValue)
            }
        }
        if (GradleVersion.current() < GradleVersion.version(""8.1"")) {
            @Suppress(""DEPRECATION"")
            target.gradle.buildFinished {
                serializeOutput()
            }
        } else {
            target.serviceOf<FlowScope>().always(
                ExecuteOnBuildFinish::class.java
            ) {
                it.parameters.onBuildFinish.set(serializeOutput)
            }
        }
    }
}

/**
 * Serializes build failure as [CaughtBuildFailure] (or [CaughtBuildFailure.UnexpectedMissingBuildFailure] is there was no failure) upon build completion
 */
class FindMatchingBuildFailureInjection<ExpectedException : Exception>(
    val serializedReturnPath: File,
    val expectedExceptionClass: Class<ExpectedException>,
) : GradleBuildScriptInjection<Project> {
    class CatchBuildFailure : FlowAction<CatchBuildFailure.Parameters> {
        interface Parameters : FlowParameters {
            @get:Input
            val onBuildFinish: Property<(Throwable?) -> Unit>

            @get:Input
            val buildWorkResult: Property<BuildWorkResult>
        }

        override fun execute(parameters: Parameters) {
            parameters.onBuildFinish.get().invoke(
                parameters.buildWorkResult.get().failure.getOrNull()
            )
        }
    }

    override fun inject(target: Project) {
        val serializeOutput: (Throwable?) -> Unit = { topLevelException ->
            val toSerialize = if (topLevelException == null) {
                CaughtBuildFailure.UnexpectedMissingBuildFailure()
            } else {
                val matchingExceptions = findMatchingExceptions(
                    topLevelException,
                    expectedExceptionClass
                )
                if (matchingExceptions.isNotEmpty()) {
                    CaughtBuildFailure.Expected(matchingExceptions)
                } else {
                    CaughtBuildFailure.Unexpected(topLevelException.fullMessage)
                }
            }

            serializedReturnPath.outputStream().use {
                ObjectOutputStream(it).writeObject(toSerialize)
            }
        }

        // Catch the errors caused directly by the build failure
        if (GradleVersion.current() < GradleVersion.version(""8.1"")) {
            @Suppress(""DEPRECATION"")
            target.gradle.buildFinished {
                serializeOutput(it.failure)
            }
        } else {
            val result = target.serviceOf<FlowProviders>().buildWorkResult
            target.serviceOf<FlowScope>().always(CatchBuildFailure::class.java) {
                it.parameters.onBuildFinish.set(serializeOutput)
                it.parameters.buildWorkResult.set(result)
            }
        }
    }

    private fun <T : Throwable> findMatchingExceptions(
        topLevelException: Throwable,
        targetClass: Class<T>,
    ): Set<T> {
        val exceptionsStack = mutableListOf(topLevelException)
        val walkedExceptions = mutableSetOf<Throwable>()
        val matchingExceptions = mutableSetOf<T>()
        while (exceptionsStack.isNotEmpty()) {
            val current = exceptionsStack.removeLast()
            if (current in walkedExceptions) continue
            walkedExceptions.add(current)
            if (targetClass.isInstance(current)) {
                @Suppress(""UNCHECKED_CAST"")
                matchingExceptions.add(current as T)
            }
            exceptionsStack.addAll(
                when (current) {
                    is MultiCauseException -> current.causes.mapNotNull { it }
                    else -> listOfNotNull(current.cause)
                }
            )
        }
        return matchingExceptions
    }
}

private const val buildScriptInjectionsMarker = ""// MARKER: GradleBuildScriptInjections Enabled""
private const val buildScriptInjectionsClasspathProperty = ""buildScriptInjectionsClasspath""

private fun GradleProject.enableBuildScriptInjectionsIfNecessary(
    buildScript: Path,
    buildScriptKts: Path,
) {
    if (buildScript.exists()) {
        if (buildScript.readText().contains(buildScriptInjectionsMarker)) return
        buildScript.modify {
            it.insertBlockToBuildScriptAfterImports(
                """"""
                $buildScriptInjectionsMarker
                buildscript {
                    println(""⚠️ GradleBuildScriptInjections Enabled. Classes from kotlin-gradle-plugin-integration-tests injected to buildscript"")               
                    dependencies {
                        classpath(
                            files(
                                ${escapedBuildScriptClasspathUrlsGroovy()}
                            )
                        )
                    }
                }
                
                """""".trimIndent()
            )
        }
        return
    }

    if (buildScriptKts.exists()) {
        if (buildScriptKts.readText().contains(buildScriptInjectionsMarker)) return
        buildScriptKts.modify {
            it.insertBlockToBuildScriptAfterImports(""""""
                $buildScriptInjectionsMarker
                buildscript {
                    println(""⚠️ GradleBuildScriptInjections Enabled. Classes from kotlin-gradle-plugin-integration-tests injected to buildscript"")               
                    val classes = files(
                        ${escapedBuildScriptClasspathUrls()}
                    )
                    dependencies {
                        classpath(classes)
                    }
                }
            
                """""".trimIndent()
            )
        }
        return
    }

    error(""build.gradle.kts nor build.gradle files not found in Test Project '$projectName'. Please check if it is a valid gradle project"")
}

class InjectionLoader {
    @Suppress(""unused"")
    fun invokeBuildScriptInjection(project: Project, serializedInjectionPath: File) {
        serializedInjectionPath.inputStream().use {
            @Suppress(""UNCHECKED_CAST"")
            (ObjectInputStream(it).readObject() as GradleBuildScriptInjection<Project>).inject(project)
        }
    }

    @Suppress(""unused"")
    fun invokeBuildScriptPluginsInjection(project: Project, serializedInjectionPath: File) {
        serializedInjectionPath.inputStream().use {
            @Suppress(""UNCHECKED_CAST"")
            (ObjectInputStream(it).readObject() as GradleBuildScriptInjection<Pair<ScriptHandler, Project>>).inject(
                Pair(project.buildscript, project)
            )
        }
    }

    @Suppress(""unused"")
    fun invokeSettingsBuildScriptInjection(settings: Settings, serializedInjectionName: File) {
        serializedInjectionName.inputStream().use {
            @Suppress(""UNCHECKED_CAST"")
            (ObjectInputStream(it).readObject() as GradleBuildScriptInjection<Settings>).inject(settings)
        }
    }
}

@DslMarker
annotation class BuildGradleKtsInjectionScope

@BuildGradleKtsInjectionScope
class GradleProjectBuildScriptInjectionContext(
    val project: Project,
) {
    val java get() = project.extensions.getByName(""java"") as JavaPluginExtension
    val kotlinMultiplatform get() = project.extensions.getByName(""kotlin"") as KotlinMultiplatformExtension
    val kotlinJvm get() = project.extensions.getByName(""kotlin"") as KotlinJvmProjectExtension
    val cocoapods get() = kotlinMultiplatform.extensions.getByName(""cocoapods"") as CocoapodsExtension
    val swiftExport get() = kotlinMultiplatform.extensions.getByName(""swiftExport"") as SwiftExportExtension
    val androidLibrary get() = project.extensions.getByName(""android"") as LibraryExtension
    val androidBase get() = project.extensions.getByName(""android"") as CommonExtension<*, *, *, *>
    val publishing get() = project.extensions.getByName(""publishing"") as PublishingExtension
    val signing get() = project.extensions.getByName(""signing"") as SigningExtension
    val dependencies get() = project.dependencies
}

@BuildGradleKtsInjectionScope
class GradleSettingsBuildScriptInjectionContext(
    val settings: Settings,
)

@BuildGradleKtsInjectionScope
class GradleBuildScriptBuildscriptInjectionContext(
    val buildscript: ScriptHandler,
    val project: Project,
)

typealias BuildAction = TestProject.(buildArguments: Array<String>, buildOptions: BuildOptions) -> Unit

class ReturnFromBuildScriptAfterExecution<T>(
    val returnContainingGradleProject: TestProject,
    val serializedReturnPath: File,
    val injectionLoadProperty: String,
    val defaultEvaluationTask: String = ""tasks"",
    val defaultBuildAction: BuildAction = build,
) {
    /**
     * Return values to the test by serializing the return after the execution. The benefit of serializing after execution is that we can
     * query anything from relevant tasks since they have executed. However, we have to disable CC, so that the returning closure can reach
     * out for configuration entities.
     */
    fun buildAndReturn(
        vararg buildArguments: String = arrayOf(defaultEvaluationTask),
        executingProject: TestProject = returnContainingGradleProject,
        /**
         * FIXME: With enabled CC and ""configuration-cache.problems=fail"" if build fails due to CC serialization, Gradle will not report an
         * error in the FlowScope and it will not be caught in [catchBuildFailures]. With ""configuration-cache.problems=warn"" Gradle
         * always forces CC deserialization before task execution and will therefore produce a catchable build failure, but only if the
         * violating task actually executes
         */
        configurationCache: BuildOptions.ConfigurationCacheValue = BuildOptions.ConfigurationCacheValue.AUTO,
        configurationCacheProblems: BuildOptions.ConfigurationCacheProblems = BuildOptions.ConfigurationCacheProblems.FAIL,
        deriveBuildOptions: TestProject.() -> BuildOptions = { buildOptions },
        buildAction: BuildAction = defaultBuildAction,
    ): T {
        executingProject.buildAction(
            arrayOf(
                *buildArguments,
                ""-P${injectionLoadProperty}=true"",
            ),
            executingProject.deriveBuildOptions().copy(
                configurationCache = configurationCache,
                configurationCacheProblems = configurationCacheProblems,
            )
        )
        ObjectInputStream(serializedReturnPath.inputStream()).use {
            @Suppress(""UNCHECKED_CAST"")
            return it.readObject() as T
        }
    }

    companion object {
        val build: BuildAction = { args, options ->
            build(
                buildArguments = args,
                buildOptions = options,
                forwardBuildOutput = false,
            )
        }
        val buildAndFail: BuildAction = { args, options ->
            buildAndFail(
                buildArguments = args,
                buildOptions = options,
                forwardBuildOutput = false,
            )
        }
    }
}

/**
 * Inject build script with a return lambda that serializes the return value at build completion.
 *
 * The [returnFromProject] by default executes without CC and at build completion. If you enable CC it will execute eagerly at CC
 * serialization time.
 *
 * @see org.jetbrains.kotlin.gradle.BuildScriptInjectionIT.consumeProjectDependencyViaSettingsInjection
 */
internal fun <T> TestProject.buildScriptReturn(
    returnFromProject: GradleProjectBuildScriptInjectionContext.() -> T,
): ReturnFromBuildScriptAfterExecution<T> = providerBuildScriptReturn {
    project.provider {
        returnFromProject()
    }
}

/**
 * Inject build script with a return lambda that serializes the return value from a [org.gradle.api.provider.Provider] at build completion.
 *
 * The [returnFromProject] by default executes without CC and at build completion. If you enable CC the closure will execute whenever Gradle
 * serializes the Provider value; in most cases this happens before execution, but for example if you flatMap the task output or derive
 * Provider from [providers.environmentVariable] it might execute at build completion time.
 *
 * @see org.jetbrains.kotlin.gradle.BuildScriptInjectionIT.buildScriptReturnIsCCFriendly
 */
internal fun <T> TestProject.providerBuildScriptReturn(
    returnFromProject: GradleProjectBuildScriptInjectionContext.() -> Provider<T>,
): ReturnFromBuildScriptAfterExecution<T> {
    return buildScriptReturnInjection(
        insertInjection = String::plus,
        injectionProvider = { serializedReturnPath ->
            OnBuildCompletionSerializingInjection(
                serializedReturnPath,
                returnFromProject,
            )
        },
        returnObjectProvider = { serializedReturnPath, injectionIdentifier ->
            ReturnFromBuildScriptAfterExecution(
                this,
                serializedReturnPath,
                injectionIdentifier,
            )
        }
    )
}

sealed class CaughtBuildFailure<ExpectedException : Throwable> : Serializable {
    data class Expected<ExpectedException : Throwable>(val matchedExceptions: Set<ExpectedException>) :
        CaughtBuildFailure<ExpectedException>()

    data class Unexpected<ExpectedException : Throwable>(val stackTraceDump: String) : CaughtBuildFailure<ExpectedException>()
    class UnexpectedMissingBuildFailure<ExpectedException : Throwable> : CaughtBuildFailure<ExpectedException>()

    fun unwrap(): Set<ExpectedException> {
        return when (this) {
            is Expected<ExpectedException> -> matchedExceptions
            is Unexpected<ExpectedException> -> error(stackTraceDump)
            is UnexpectedMissingBuildFailure<ExpectedException> -> error(
                """"""
                Build completion handler executed, but there were no failures. This likely means either:
                - Build succeeded
                - There was a CC serialization error; these are currently not caught
                """""".trimIndent()
            )
        }
    }
}

/**
 * Catch all build failures of type [T] thrown at configuration or execution time. This function returns one of the following:
 * - [CaughtBuildFailure.Expected]: The caught exception of type [T] thrown some time during the build
 * - [CaughtBuildFailure.Unexpected]: The backtrace of the top level exception caught by the build when [T] wasn't found in the exception cause graph
 * - [CaughtBuildFailure.UnexpectedMissingBuildFailure]: Build was expected to fail, but no failure was reported by Gradle
 *
 * FIXME: Currently CC serialization failures are not caught - KT-74367
 */
internal inline fun <reified T : Exception> TestProject.catchBuildFailures(): ReturnFromBuildScriptAfterExecution<CaughtBuildFailure<T>> {
    return buildScriptReturnInjection(
        insertInjection = String::insertBlockToBuildScriptAfterPluginsAndImports,
        injectionProvider = { serializedReturnPath ->
            FindMatchingBuildFailureInjection(
                serializedReturnPath,
                T::class.java,
            )
        },
        returnObjectProvider = { serializedReturnPath, injectionIdentifier ->
            ReturnFromBuildScriptAfterExecution(
                this,
                serializedReturnPath,
                injectionIdentifier,
                defaultBuildAction = ReturnFromBuildScriptAfterExecution.buildAndFail,
            )
        }
    )
}

private fun <T> GradleProject.buildScriptReturnInjection(
    insertInjection: String.(insertion: String) -> String,
    injectionProvider: (serializedReturnPath: File) -> GradleBuildScriptInjection<Project>,
    returnObjectProvider: (serializedReturnPath: File, injectionIdentifier: String) -> ReturnFromBuildScriptAfterExecution<T>,
): ReturnFromBuildScriptAfterExecution<T> {
    markAsUsingInjections()
    enableBuildScriptInjectionsIfNecessary(
        buildGradle,
        buildGradleKts,
    )
    val injectionIdentifier = generateIdentifier()
    val serializedReturnPath = projectPath.resolve(""serializedReturnConfiguration_${injectionIdentifier}"").toFile()
    val injection = injectionProvider(serializedReturnPath)

    val serializedInjectionPath = projectPath.resolve(""serializedInjection_${injectionIdentifier}"").toFile()
    serializedInjectionPath.outputStream().use {
        ObjectOutputStream(it).writeObject(injection)
    }

    fun whenPropertySpecified(
        property: String,
        execute: String,
    ): String = """"""
    
        if (project.hasProperty(""${property}"")) {
            ${execute}
        }
        
    """""".trimIndent()

    when {
        buildGradleKts.exists() -> buildGradleKts.modify {
            it.insertInjection(
                whenPropertySpecified(
                    injectionIdentifier,
                    injectionLoadProject(serializedInjectionPath)
                )
            )
        }
        buildGradle.exists() -> buildGradle.modify {
            it.insertInjection(
                whenPropertySpecified(
                    injectionIdentifier,
                    injectionLoadProjectGroovy(serializedInjectionPath)
                )
            )
        }
        else -> error(""Can't find the build script to append the return injection"")
    }

    return returnObjectProvider(serializedReturnPath, injectionIdentifier)
}

/**
 * Inject build script with a lambda that will be executed by the build script at configuration time.
 *
 * The [code] closure is going to be serialized to a file using Java serialization. This allows the instance of the lambda to capture
 * serializable parameters from the test. When the build script executes, it deserializes the lambda instance and executes it.
 *
 * @see org.jetbrains.kotlin.gradle.BuildScriptInjectionIT.publishAndConsumeProject
 */

fun GradleProject.buildScriptInjection(
    code: GradleProjectBuildScriptInjectionContext.() -> Unit,
) {
    markAsUsingInjections()
    enableBuildScriptInjectionsIfNecessary(
        buildGradle,
        buildGradleKts,
    )
    loadInjectionDuringEvaluation<GradleProjectBuildScriptInjectionContext, Project>(
        buildGradle,
        buildGradleKts,
        ::injectionLoadProject,
        ::injectionLoadProjectGroovy,
        { GradleProjectBuildScriptInjectionContext(it) },
        code,
    )
}

/**
 * Add KGP to the build script classpath by transferring repositories from settings pluginManagement into project build script's buildscript
 * repositories and inject the buildscript block with KGP (without applying any plugins)
 *
 * @see org.jetbrains.kotlin.gradle.BuildScriptInjectionIT
 */
fun TestProject.addKgpToBuildScriptCompilationClasspath() {
    val kotlinVersion = buildOptions.kotlinVersion
    transferPluginRepositoriesIntoBuildScript()
    buildScriptBuildscriptBlockInjection {
        buildscript.configurations.getByName(""classpath"").dependencies.add(
            buildscript.dependencies.create(""org.jetbrains.kotlin:kotlin-gradle-plugin:${kotlinVersion}"")
        )
    }
}

fun TestProject.addAgpToBuildScriptCompilationClasspath(androidVersion: String) {
    transferPluginRepositoriesIntoBuildScript()
    buildScriptBuildscriptBlockInjection {
        buildscript.configurations.getByName(""classpath"").dependencies.add(
            buildscript.dependencies.create(""com.android.tools.build:gradle:${androidVersion}"")
        )
    }
}

/**
 * This helper method works similar to ""plugins {}"" block in the build script; it resolves the POM pointer to the plugin jar and applies the plugin
 */
fun TestProject.plugins(build: PluginDependenciesSpec.() -> Unit) {
    val spec = TestPluginDependenciesSpec()
    spec.build()
    transferPluginRepositoriesIntoBuildScript()
    transferPluginDependencyConstraintsIntoBuildscriptClasspathDependencyConstraints()
    buildScriptBuildscriptBlockInjection {
        spec.plugins.filter {
            // filter out Gradle's embedded plugins
            !it.id.startsWith(""org.gradle"")
        }.forEach {
            val pluginPointer = buildscript.dependencies.create(
                group = it.id,
                name = ""${it.id}.gradle.plugin"",
                version = it.version,
            )
            buildscript.configurations.getByName(""classpath"").dependencies.add(pluginPointer)
        }
    }
    buildScriptInjection {
        spec.plugins.filter { it.shouldBeApplied }.forEach {
            project.plugins.apply(it.id)
        }
    }
}

private class TestPluginDependencySpec(
    val id: String,
): PluginDependencySpec, Serializable {
    var version: String? = null
    var shouldBeApplied = true

    override fun version(version: String?): PluginDependencySpec {
        this.version = version
        return this
    }

    override fun apply(apply: Boolean): PluginDependencySpec {
        shouldBeApplied = apply
        return this
    }
}

private class TestPluginDependenciesSpec : PluginDependenciesSpec, Serializable {
    val plugins = mutableListOf<TestPluginDependencySpec>()
    override fun id(id: String): PluginDependencySpec = TestPluginDependencySpec(id).also { plugins.add(it) }
}

private fun Class<*>.getPrivateField(fieldName: String): Field {
    var clazz: Class<*>? = this
    while (clazz != null) {
        try {
            val field = clazz.getDeclaredField(fieldName)
            return field
        } catch (e: NoSuchFieldException) {
            clazz = clazz.superclass
        }
    }
    throw NoSuchFieldException(""Field '$fieldName' not found in class hierarchy"")
}

/**
 * Inject the [buildscript] block of the project build script. The primary use case for this injection is the configuration of the build
 * script classpath before plugin application
 */
fun GradleProject.buildScriptBuildscriptBlockInjection(
    code: GradleBuildScriptBuildscriptInjectionContext.() -> Unit
) {
    markAsUsingInjections()
    enableBuildScriptInjectionsIfNecessary(
        buildGradle,
        buildGradleKts,
    )
    val buildscriptBlockInjection = serializeInjection<GradleBuildScriptBuildscriptInjectionContext, Pair<ScriptHandler, Project>>(
        instantiateInjectionContext = { GradleBuildScriptBuildscriptInjectionContext(it.first, it.second) },
        code = code,
    )
    when {
        buildGradle.exists() -> buildGradle.prependToOrCreateBuildscriptBlock(
            scriptIsolatedInjectionLoadGroovy(
                ""invokeBuildScriptPluginsInjection"",
                ""project"",
                Project::class.java.name,
                buildscriptBlockInjection,
            )
        )
        buildGradleKts.exists() -> buildGradleKts.prependToOrCreateBuildscriptBlock(
            scriptIsolatedInjectionLoad(
                ""invokeBuildScriptPluginsInjection"",
                ""project"",
                Project::class.java.name,
                buildscriptBlockInjection,
            )
        )
        else -> error(""Can't find the build script to append the injection"")
    }
}

/**
 * Allow [buildscript] configurations (classpath) to see the same set of repositories that are normally visible to the [plugins] block in
 * build.gradle.kts
 */
private const val transferPluginRepositoriesIntoProjectRepositories = ""transferPluginRepositoriesIntoProjectRepositories""
fun GradleProject.transferPluginRepositoriesIntoBuildScript() {
    markAsUsingInjections()
    settingsBuildScriptInjection {
        if (!settings.extraProperties.has(transferPluginRepositoriesIntoProjectRepositories)) {
            settings.extraProperties.set(transferPluginRepositoriesIntoProjectRepositories, true)
            settings.pluginManagement.repositories.all { rep ->
                settings.gradle.beforeProject { project ->
                    project.buildscript.repositories.add(rep)
                }
            }
        }
    }
}

/**
 * Allow [buildscript] classpath configuration to resolve the versions of plugins declared in the settings.pluginManagement.plugins
 * dependency constraints
 */
private const val transferPluginDependencyConstraintsIntoProjectRepositories = ""transferPluginDependencyConstraintsIntoProjectBuildscriptClasspathConfiguration""
fun GradleProject.transferPluginDependencyConstraintsIntoBuildscriptClasspathDependencyConstraints() {
    markAsUsingInjections()
    settingsBuildScriptInjection {
        val pluginVersionsField = settings.pluginManagement.resolutionStrategy.javaClass.getPrivateField(""pluginVersions"")
        pluginVersionsField.isAccessible = true
        @Suppress(""UNCHECKED_CAST"")
        val pluginVersions = pluginVersionsField.get(settings.pluginManagement.resolutionStrategy) as Map<PluginId, String>
        if (!settings.extraProperties.has(transferPluginDependencyConstraintsIntoProjectRepositories)) {
            settings.extraProperties.set(transferPluginDependencyConstraintsIntoProjectRepositories, true)
            settings.gradle.beforeProject { project ->
                pluginVersions.forEach {
                    val pluginId = it.key.id
                    val pluginVersion = it.value
                    project.buildscript.configurations.getByName(""classpath"").dependencyConstraints.add(
                        project.buildscript.dependencies.constraints.create(
                            ""${pluginId}:${pluginId}.gradle.plugin:${pluginVersion}"",
                        )
                    )
                }
            }
        }
    }
}

/**
 * Transfer dependencyResolutionManagement into project for compatibility with Gradle <8.1 because we emit repositories in the
 * build script there
 */
private const val transferDependencyResolutionRepositoriesIntoProjectRepositories =
    ""transferDependencyResolutionRepositoriesIntoProjectRepositories""

fun GradleProject.transferDependencyResolutionRepositoriesIntoProjectRepositories() {
    settingsBuildScriptInjection {
        if (!settings.extraProperties.has(transferDependencyResolutionRepositoriesIntoProjectRepositories)) {
            settings.extraProperties.set(transferDependencyResolutionRepositoriesIntoProjectRepositories, true)
            settings.gradle.beforeProject { project ->
                settings.dependencyResolutionManagement.repositories.all { rep ->
                    project.repositories.add(rep)
                }
            }
        }
    }
}

private val buildscriptBlockStartPattern = Regex(""""""buildscript\s*\{.*"""""")
private fun Path.prependToOrCreateBuildscriptBlock(code: String) = modify {
    it.prependToOrCreateBuildscriptBlock(code)
}

internal fun String.prependToOrCreateBuildscriptBlock(code: String): String {
    val content = this
    val match = buildscriptBlockStartPattern.find(content)
    return if (match != null) {
        buildString {
            appendLine(content.substring(0, match.range.last + 1))
            appendLine(code)
            append(content.substring(match.range.last + 1, content.length))
        }
    } else {
        content.insertBlockToBuildScriptAfterImports(
            buildString {
                appendLine(""buildscript {"")
                appendLine(code)
                appendLine(""}"")
            }
        )
    }
}

/**
 * Inject settings build script with a lambda that will be executed by at configuration time. This injection can be used for arbitrary
 * settings logic: multi-project setups, dependency management, etc.
 *
 * @see org.jetbrains.kotlin.gradle.BuildScriptInjectionIT.consumeProjectDependencyViaSettingsInjection
 */
fun GradleProject.settingsBuildScriptInjection(
    code: GradleSettingsBuildScriptInjectionContext.() -> Unit,
) {
    loadInjectionDuringEvaluation<GradleSettingsBuildScriptInjectionContext, Settings>(
        settingsGradle,
        settingsGradleKts,
        ::injectionLoadSettings,
        ::injectionLoadSettingsGroovy,
        { GradleSettingsBuildScriptInjectionContext(it) },
        code,
    )
}

private fun <Context, Target> GradleProject.loadInjectionDuringEvaluation(
    buildScript: Path,
    buildScriptKts: Path,
    injectionLoad: (File) -> String,
    injectionLoadGroovy: (File) -> String,
    instantiateInjectionContext: (Target) -> Context,
    code: Context.() -> Unit,
) {
    val serializedInjectionPath = serializeInjection(instantiateInjectionContext, code)
    when {
        buildScriptKts.exists() -> buildScriptKts.appendText(injectionLoad(serializedInjectionPath))
        buildScript.exists() -> buildScript.appendText(injectionLoadGroovy(serializedInjectionPath))
        else -> error(""Can't find the build script to append the injection"")
    }
}

private fun <Context, Target> GradleProject.serializeInjection(
    instantiateInjectionContext: (Target) -> Context,
    code: Context.() -> Unit,
): File {
    val injection = UndispatchedInjection(instantiateInjectionContext, code)
    val serializedInjectionPath = projectPath
        .resolve(""serializedConfiguration_${generateIdentifier()}"")
        .toFile()
    serializedInjectionPath.outputStream().use {
        ObjectOutputStream(it).writeObject(injection)
    }
    return serializedInjectionPath
}

/**
 * Settings injections must use [scriptIsolatedInjectionLoad] instead of the [enableBuildScriptInjectionsIfNecessary] mechanism. This is
 * because [GradleProjectBuildScriptInjectionContext] must be loaded by the build script's classloader to
 *  - be able to see KGP classes loaded by the build script classloader
 *  - be visible to the execution-time classloader in runs with CC
 *
 * Settings injections only run at configuration time and must therefore prevent Gradle from loading any classes into the settings
 * classloader. Gradle disposes of the settings classloader before execution and complains if the project build script referenced anything
 * captured for execution from this classloader
 */
private fun scriptIsolatedInjectionLoad(
    targetMethodName: String,
    targetPropertyName: String,
    targetPropertyClassName: String,
    serializedInjectionPath: File,
): String {
    val lambdaName = ""invokeInjection${serializedInjectionPath.name.replace(""-"", ""_"")}""

    return """"""
        
        val $lambdaName = {
            val testClasses = arrayOf(
                ${escapedBuildScriptClasspathUrls()}
            )
            val injectionLoaderClass = java.net.URLClassLoader(
                testClasses, 
                this.javaClass.classLoader
            ).loadClass(""${InjectionLoader::class.java.name}"")
            injectionLoaderClass.getMethod(
                ""$targetMethodName"",
                Class.forName(""$targetPropertyClassName""),
                Class.forName(""java.io.File"")
            ).invoke(
                injectionLoaderClass.getConstructor().newInstance(), 
                ${targetPropertyName},
                File(""${serializedInjectionPath.path.normalizePath()}"")
            )
        }
        ${lambdaName}()
    """""".trimIndent()
}

private fun scriptIsolatedInjectionLoadGroovy(
    targetMethodName: String,
    targetPropertyName: String,
    targetPropertyClassName: String,
    serializedInjectionPath: File,
): String {
    val lambdaName = ""invokeInjection${serializedInjectionPath.name.replace(""-"", ""_"")}""

    return """"""
        
        def ${lambdaName} = {
            URL[] testClasses = [
                ${escapedBuildScriptClasspathUrlsGroovy()}
            ]
            def injectionLoaderClass = new URLClassLoader(
                testClasses, 
                this.getClass().classLoader
            ).loadClass('${InjectionLoader::class.java.name}')
            injectionLoaderClass.getMethod(
                '${targetMethodName}',
                Class.forName('${targetPropertyClassName}'),
                Class.forName('java.io.File')
            ).invoke(
                injectionLoaderClass.getConstructor().newInstance(), 
                ${targetPropertyName},
                new java.io.File('${serializedInjectionPath.path.normalizePath()}')
            )
        }
        ${lambdaName}()
    """""".trimIndent()
}

private fun injectionLoadSettings(
    serializedInjectionPath: File,
): String = scriptIsolatedInjectionLoad(
    ""invokeSettingsBuildScriptInjection"",
    ""settings"",
    Settings::class.java.name,
    serializedInjectionPath,
)

private fun injectionLoadSettingsGroovy(
    serializedInjectionPath: File,
): String = scriptIsolatedInjectionLoadGroovy(
    ""invokeSettingsBuildScriptInjection"",
    ""settings"",
    Settings::class.java.name,
    serializedInjectionPath,
)

private fun injectionLoadProject(
    serializedInjectionPath: File,
): String = """"""
    
    org.jetbrains.kotlin.gradle.testbase.InjectionLoader().invokeBuildScriptInjection(project, File(""${serializedInjectionPath.path.normalizePath()}""))
"""""".trimIndent()

private fun injectionLoadProjectGroovy(
    serializedInjectionPath: File,
): String = """"""
    
    new org.jetbrains.kotlin.gradle.testbase.InjectionLoader().invokeBuildScriptInjection(project, new java.io.File('${serializedInjectionPath.path.normalizePath()}'))
"""""".trimIndent()

private fun escapedBuildScriptClasspath(): List<String> {
    val injectionClasses = System.getProperty(buildScriptInjectionsClasspathProperty)
        ?: error(""Missing required system property '${buildScriptInjectionsClasspathProperty}'"")
    return injectionClasses.split("":"").map { path ->
        path.replace(""\\"", ""\\\\"").replace(""$"", ""\\$"")
    }
}

private fun escapedBuildScriptClasspathUrlsGroovy() = escapedBuildScriptClasspath().joinToString(""\n"") { ""new File('${it}').toURI().toURL(),"" }
private fun escapedBuildScriptClasspathUrls() = escapedBuildScriptClasspath().joinToString(""\n"") { ""File(\""$it\"").toURI().toURL(),"" }
",KOT_03471,CWE-321: Hard-coded Cryptographic Key;CWE-502: Deserialization of Untrusted Data,A02: Cryptographic Failures;A04: Insecure Design;A08: Software and Data Integrity Failures,1
square__okhttp,a228fd64cc6a4f92318b42d9bef4c34f32c57b3b,okhttp-testing-support/src/main/kotlin/okhttp3/internal/http/RecordingProxySelector.kt,.kt,Jesse Wilson,jwilson@squareup.com,2024-01-07T20:13:22-05:00,Reformat with Spotless (#8180),1,RecordingProxySelector,"/*
 * Copyright (C) 2014 Square, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
@file:Suppress(""INVISIBLE_MEMBER"", ""INVISIBLE_REFERENCE"")

package okhttp3.internal.http

import assertk.assertThat
import assertk.assertions.containsExactly
import java.io.IOException
import java.net.InetSocketAddress
import java.net.Proxy
import java.net.ProxySelector
import java.net.SocketAddress
import java.net.URI
import okhttp3.internal.format

class RecordingProxySelector : ProxySelector() {
  @JvmField val proxies = mutableListOf<Proxy>()

  private val requestedUris = mutableListOf<URI>()
  private val failures = mutableListOf<String>()

  override fun select(uri: URI): List<Proxy> {
    requestedUris.add(uri)
    return proxies
  }

  fun assertRequests(vararg expectedUris: URI?) {
    assertThat(requestedUris).containsExactly(*expectedUris)
    requestedUris.clear()
  }

  override fun connectFailed(
    uri: URI,
    sa: SocketAddress,
    ioe: IOException,
  ) {
    val socketAddress = sa as InetSocketAddress
    failures.add(format(""%s %s:%d %s"", uri, socketAddress, socketAddress.port, ioe.message!!))
  }

  override fun toString() = ""RecordingProxySelector""
}
",KOT_04537,,,0
signalapp__Signal-Android,feb37eea2d4b1586b948ed16fa005b2382a33719,app/src/main/java/org/thoughtcrime/securesms/components/settings/app/BioRecipientState.kt,.kt,Alex Hart,alex@signal.org,2025-10-15T09:22:02-03:00,Fix BioRecipientState if recipient does not have an e164.,1,BioRecipientState,"class BioRecipientState(
  val recipient: Recipient
) {
  val username: String = recipient.username.orElse("""")
  val featuredBadge: Badge? = recipient.featuredBadge
  val profileName: ProfileName = recipient.profileName
  val e164: String = recipient.e164.orElse("""")
  val combinedAboutAndEmoji: String? = recipient.combinedAboutAndEmoji

  override fun equals(other: Any?): Boolean {
    if (other !is Recipient) return false
    return recipient.hasSameContent(other)
  }

  override fun hashCode(): Int {
    return Objects.hashCode(
      recipient,
      username,
      featuredBadge,
      profileName,
      e164,
      combinedAboutAndEmoji
    )
  }
}",KSEC_0731,,,0
thunderbird__thunderbird-android,f8d355e921686bc883ef1de4e88734d8dac3e829,core/ui/compose/designsystem/src/debug/kotlin/app/k9mail/core/ui/compose/designsystem/PreviewWithThemeLightDark.kt,.kt,Rafael Tonholo,rafael@tonholo.dev,2025-07-02T11:05:37-03:00,fix(preview): composable PreviewWithThemesLightDark render issue caused by using MainTheme outside the composition local context,1,,"package app.k9mail.core.ui.compose.designsystem

import androidx.compose.foundation.background
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.padding
import androidx.compose.runtime.Composable
import androidx.compose.runtime.movableContentOf
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import app.k9mail.core.ui.compose.theme2.MainTheme

/**
 * A Composable function that displays a preview of the content in both Thunderbird and K-9 Mail themes.
 *
 * It uses the current system theme (light or dark) for both previews.
 *
 * @param modifier The modifier to be applied to the layout.
 * @param useRow Whether to display the previews in a row or column. Defaults to `false` (column).
 * @param useScrim Whether to display a scrim behind the content. Defaults to `false`.
 * @param scrimAlpha The alpha value for the scrim. Defaults to `0.8f`.
 * @param scrimPadding The padding for the scrim. Defaults to `MainTheme.spacings.triple`.
 * @param arrangement The arrangement for the previews. Defaults to `Arrangement.spacedBy(MainTheme.spacings.triple)`.
 * @param content The content to be displayed in the previews.
 *
 * @see app.k9mail.core.ui.compose.theme2.default.defaultThemeSpacings for MainTheme.spacings
 */
@Composable
fun PreviewWithThemeLightDark(
    modifier: Modifier = Modifier,
    useRow: Boolean = false,
    useScrim: Boolean = false,
    scrimAlpha: Float = 0.8f,
    scrimPadding: PaddingValues = PaddingValues(24.dp),
    arrangement: Arrangement.HorizontalOrVertical = Arrangement.spacedBy(24.dp),
    content: @Composable () -> Unit,
) {
    val movableContent = remember {
        movableContentOf {
            ThemePreview(
                themeType = PreviewThemeType.THUNDERBIRD,
                useScrim = useScrim,
                scrimAlpha = scrimAlpha,
                scrimPadding = scrimPadding,
                content = content,
            )
            ThemePreview(
                themeType = PreviewThemeType.K9MAIL,
                useScrim = useScrim,
                scrimAlpha = scrimAlpha,
                scrimPadding = scrimPadding,
                content = content,
            )
        }
    }

    if (useRow) {
        Row(
            horizontalArrangement = arrangement,
            modifier = modifier,
        ) {
            movableContent()
        }
    } else {
        Column(
            verticalArrangement = arrangement,
            modifier = modifier,
        ) {
            movableContent()
        }
    }
}

@Composable
private fun ThemePreview(
    themeType: PreviewThemeType,
    useScrim: Boolean,
    scrimAlpha: Float,
    scrimPadding: PaddingValues,
    content: @Composable (() -> Unit),
) {
    val movableContent = remember { movableContentOf { content() } }
    PreviewWithTheme(
        themeType = themeType,
        isDarkTheme = isSystemInDarkTheme(),
    ) {
        PreviewSurface {
            if (useScrim) {
                Box(
                    modifier = Modifier
                        .background(MainTheme.colors.scrim.copy(alpha = scrimAlpha))
                        .padding(scrimPadding),
                ) {
                    movableContent()
                }
            } else {
                movableContent()
            }
            PreviewHeader(themeName = themeType.name)
        }
    }
}
",KSEC_1536,,,0
square__okhttp,c8dbccea5e8e724a799eea4dcf5abde511f4750c,okhttp-tests/src/main/java/okhttp3/AutobahnTester.java,.java,jwilson,jwilson@squareup.com,2016-11-21T12:29:14-05:00,Fix some Autobahn tests.,1,AutobahnTester,"public final class AutobahnTester {
  private static final String HOST = ""ws://localhost:9099"";

  public static void main(String... args) throws IOException {
    new AutobahnTester().run();
  }

  final OkHttpClient client = new OkHttpClient();

  private WebSocket newWebSocket(String path, WebSocketListener listener) {
    Request request = new Request.Builder().url(HOST + path).build();
    return client.newWebSocket(request, listener);
  }

  public void run() throws IOException {
    try {
      long count = getTestCount();
      System.out.println(""Test count: "" + count);

      for (long number = 1; number <= count; number++) {
        runTest(number, count);
      }

      updateReports();
    } finally {
      client.dispatcher().executorService().shutdown();
    }
  }

  private void runTest(final long number, final long count) {
    final CountDownLatch latch = new CountDownLatch(1);
    final AtomicLong startNanos = new AtomicLong();
    newWebSocket(""/runCase?case="" + number + ""&agent=okhttp"", new WebSocketListener() {
      @Override public void onOpen(WebSocket webSocket, Response response) {
        System.out.println(""Executing test case "" + number + ""/"" + count);
        startNanos.set(System.nanoTime());
      }

      @Override public void onMessage(final WebSocket webSocket, final ByteString bytes) {
        webSocket.send(bytes);
      }

      @Override public void onMessage(final WebSocket webSocket, final String text) {
        webSocket.send(text);
      }

      @Override public void onClosing(WebSocket webSocket, int code, String reason) {
        webSocket.close(1000, null);
        latch.countDown();
      }

      @Override public void onFailure(WebSocket webSocket, Throwable t, Response response) {
        t.printStackTrace(System.out);
        latch.countDown();
      }
    });
    try {
      if (!latch.await(30, TimeUnit.SECONDS)) {
        throw new IllegalStateException(""Timed out waiting for test "" + number + "" to finish."");
      }
    } catch (InterruptedException e) {
      throw new AssertionError();
    }

    long endNanos = System.nanoTime();
    long tookMs = TimeUnit.NANOSECONDS.toMillis(endNanos - startNanos.get());
    System.out.println(""Took "" + tookMs + ""ms"");
  }

  private long getTestCount() throws IOException {
    final CountDownLatch latch = new CountDownLatch(1);
    final AtomicLong countRef = new AtomicLong();
    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
    newWebSocket(""/getCaseCount"", new WebSocketListener() {
      @Override public void onMessage(WebSocket webSocket, String text) {
        countRef.set(Long.parseLong(text));
      }

      @Override public void onClosing(WebSocket webSocket, int code, String reason) {
        webSocket.close(1000, null);
        latch.countDown();
      }

      @Override public void onFailure(WebSocket webSocket, Throwable t, Response response) {
        failureRef.set(t);
        latch.countDown();
      }
    });
    try {
      if (!latch.await(10, TimeUnit.SECONDS)) {
        throw new IllegalStateException(""Timed out waiting for count."");
      }
    } catch (InterruptedException e) {
      throw new AssertionError();
    }
    Throwable failure = failureRef.get();
    if (failure != null) {
      throw new RuntimeException(failure);
    }
    return countRef.get();
  }

  private void updateReports() {
    final CountDownLatch latch = new CountDownLatch(1);
    newWebSocket(""/updateReports?agent="" + Version.userAgent(), new WebSocketListener() {
      @Override public void onClosing(WebSocket webSocket, int code, String reason) {
        webSocket.close(1000, null);
        latch.countDown();
      }

      @Override public void onFailure(WebSocket webSocket, Throwable t, Response response) {
        latch.countDown();
      }
    });
    try {
      if (!latch.await(10, TimeUnit.SECONDS)) {
        throw new IllegalStateException(""Timed out waiting for count."");
      }
    } catch (InterruptedException e) {
      throw new AssertionError();
    }
  }
}",KOT_05099,,,0
JetBrains__kotlin,7e56cdfd09ae9eef4a2d802acde1253143e6b015,wasm/wasm.tests/tests-gen/org/jetbrains/kotlin/wasm/test/FirWasmJsCodegenBoxWithInlinedFunInKlibTestGenerated.java,.java,Alexander Udalov,alexander.udalov@jetbrains.com,2025-10-24T10:01:10+02:00,Reflection: fix javaType for local delegated property accessors,1,LocalDelegated,"        public class LocalDelegated {
          @Test
          public void testAllFilesPresentInLocalDelegated() {
            KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File(""compiler/testData/codegen/box/reflection/properties/localDelegated""), Pattern.compile(""^([^_](.+))\\.kt$""), null, true);
          }

          @Test
          @TestMetadata(""annotations.kt"")
          public void testAnnotations() {
            runTest(""compiler/testData/codegen/box/reflection/properties/localDelegated/annotations.kt"");
          }

          @Test
          @TestMetadata(""equals.kt"")
          public void testEquals() {
            runTest(""compiler/testData/codegen/box/reflection/properties/localDelegated/equals.kt"");
          }

          @Test
          @TestMetadata(""inInterface.kt"")
          public void testInInterface() {
            runTest(""compiler/testData/codegen/box/reflection/properties/localDelegated/inInterface.kt"");
          }

          @Test
          @TestMetadata(""inInterfaceDefaultImpls.kt"")
          public void testInInterfaceDefaultImpls() {
            runTest(""compiler/testData/codegen/box/reflection/properties/localDelegated/inInterfaceDefaultImpls.kt"");
          }

          @Test
          @TestMetadata(""inLambda.kt"")
          public void testInLambda() {
            runTest(""compiler/testData/codegen/box/reflection/properties/localDelegated/inLambda.kt"");
          }

          @Test
          @TestMetadata(""inLambdaInInline.kt"")
          public void testInLambdaInInline() {
            runTest(""compiler/testData/codegen/box/reflection/properties/localDelegated/inLambdaInInline.kt"");
          }

          @Test
          @TestMetadata(""inlineFun.kt"")
          public void testInlineFun() {
            runTest(""compiler/testData/codegen/box/reflection/properties/localDelegated/inlineFun.kt"");
          }

          @Test
          @TestMetadata(""javaType.kt"")
          public void testJavaType() {
            runTest(""compiler/testData/codegen/box/reflection/properties/localDelegated/javaType.kt"");
          }

          @Test
          @TestMetadata(""localAndNonLocal.kt"")
          public void testLocalAndNonLocal() {
            runTest(""compiler/testData/codegen/box/reflection/properties/localDelegated/localAndNonLocal.kt"");
          }

          @Test
          @TestMetadata(""localDelegatedProperty.kt"")
          public void testLocalDelegatedProperty() {
            runTest(""compiler/testData/codegen/box/reflection/properties/localDelegated/localDelegatedProperty.kt"");
          }

          @Test
          @TestMetadata(""multiFileClass.kt"")
          public void testMultiFileClass() {
            runTest(""compiler/testData/codegen/box/reflection/properties/localDelegated/multiFileClass.kt"");
          }

          @Test
          @TestMetadata(""unusedGenericType.kt"")
          public void testUnusedGenericType() {
            runTest(""compiler/testData/codegen/box/reflection/properties/localDelegated/unusedGenericType.kt"");
          }

          @Test
          @TestMetadata(""variableOfGenericType.kt"")
          public void testVariableOfGenericType() {
            runTest(""compiler/testData/codegen/box/reflection/properties/localDelegated/variableOfGenericType.kt"");
          }
        }",KOT_01272,,,0
duckduckgo__Android,db728523240e377277deb88af71d751eb8bdb5dd,app/src/androidTest/java/com/duckduckgo/app/global/HashUtilitiesTest.kt,.kt,Craig Russell,CDRussell@users.noreply.github.com,2020-05-19T12:26:24+01:00,Feature/craig/lint checking (#833),1,HashUtilitiesTest,"class HashUtilitiesTest {

    @Test
    fun whenSha1HashCalledOnStringThenResultIsCorrect() {
        val result = helloWorldText.sha1
        assertEquals(helloWorldSha1, result)
    }

    @Test
    fun whenSha256HashCalledOnBytesThenResultIsCorrect() {
        val result = helloWorldText.toByteArray().sha256
        assertEquals(helloWorldSha256, result)
    }

    @Test
    fun whenCorrectSha256HashUsedThenVerifyIsTrue() {
        assertTrue(helloWorldText.toByteArray().verifySha256(helloWorldSha256))
    }

    @Test
    fun whenIncorrectByteSha256HashUsedThenVerifyIsFalse() {
        assertFalse(helloWorldText.toByteArray().verifySha256(otherSha256))
    }

    companion object {
        const val helloWorldText = ""Hello World!""
        const val helloWorldSha256 = ""7f83b1657ff1fc53b92dc18148a1d65dfc2d4b1fa3d677284addd200126d9069""
        const val helloWorldSha1 = ""2ef7bde608ce5404e97d5f042f95f89f1c232871""
        const val otherSha256 = ""f97e9da0e3b879f0a9df979ae260a5f7e1371edb127c1862d4f861981166cdc1""
    }
}",KSEC_5935,['CWE-321: Hard-coded Cryptographic Key'],"['A02: Cryptographic Failures', 'A04: Insecure Design']",1
JetBrains__kotlin,0dbb366f57c7d1b2ea9b535dc7e123412b7ca907,core/reflection.jvm/src/kotlin/reflect/jvm/internal/ReflectKCallable.kt,.kt,vladislav.grechko,vladislav.grechko@jetbrains.com,2025-10-27T09:56:41+01:00,[Reflection] Fix calls of functions with default + context parameters,1,ReflectKFunction,"internal interface ReflectKFunction : ReflectKCallable<Any?>, KFunction<Any?> {
    val signature: String
}",KOT_00903,,,0
JetBrains__kotlin,f939aae1c5a3ac434c21c03eeef8badd1699088f,analysis/low-level-api-fir/tests-gen/org/jetbrains/kotlin/analysis/low/level/api/fir/diagnostic/compiler/based/LLBlackBoxTestGenerated.java,.java,Igor Yakovlev,igor.yakovlev@jetbrains.com,2025-07-21T15:33:46+02:00,[Wasm] Fix and add test for CCE,1,Casts,"  public class Casts {
    @Test
    public void testAllFilesPresentInCasts() {
      KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File(""compiler/testData/codegen/box/casts""), Pattern.compile(""^(.+)\\.kt$""), null, true);
    }

    @Test
    @TestMetadata(""arrayDowncastingContravariant.kt"")
    public void testArrayDowncastingContravariant() {
      runTest(""compiler/testData/codegen/box/casts/arrayDowncastingContravariant.kt"");
    }

    @Test
    @TestMetadata(""arrayDowncatingInvariant.kt"")
    public void testArrayDowncatingInvariant() {
      runTest(""compiler/testData/codegen/box/casts/arrayDowncatingInvariant.kt"");
    }

    @Test
    @TestMetadata(""arrayDownctingCovariant.kt"")
    public void testArrayDownctingCovariant() {
      runTest(""compiler/testData/codegen/box/casts/arrayDownctingCovariant.kt"");
    }

    @Test
    @TestMetadata(""as.kt"")
    public void testAs() {
      runTest(""compiler/testData/codegen/box/casts/as.kt"");
    }

    @Test
    @TestMetadata(""asForConstants.kt"")
    public void testAsForConstants() {
      runTest(""compiler/testData/codegen/box/casts/asForConstants.kt"");
    }

    @Test
    @TestMetadata(""asSafe.kt"")
    public void testAsSafe() {
      runTest(""compiler/testData/codegen/box/casts/asSafe.kt"");
    }

    @Test
    @TestMetadata(""asSafeFail.kt"")
    public void testAsSafeFail() {
      runTest(""compiler/testData/codegen/box/casts/asSafeFail.kt"");
    }

    @Test
    @TestMetadata(""asSafeForConstants.kt"")
    public void testAsSafeForConstants() {
      runTest(""compiler/testData/codegen/box/casts/asSafeForConstants.kt"");
    }

    @Test
    @TestMetadata(""asThrowsNpe_1_4.kt"")
    public void testAsThrowsNpe_1_4() {
      runTest(""compiler/testData/codegen/box/casts/asThrowsNpe_1_4.kt"");
    }

    @Test
    @TestMetadata(""asToNothing.kt"")
    public void testAsToNothing() {
      runTest(""compiler/testData/codegen/box/casts/asToNothing.kt"");
    }

    @Test
    @TestMetadata(""asUnit.kt"")
    public void testAsUnit() {
      runTest(""compiler/testData/codegen/box/casts/asUnit.kt"");
    }

    @Test
    @TestMetadata(""asWithGeneric.kt"")
    public void testAsWithGeneric() {
      runTest(""compiler/testData/codegen/box/casts/asWithGeneric.kt"");
    }

    @Test
    @TestMetadata(""castGenericNull.kt"")
    public void testCastGenericNull() {
      runTest(""compiler/testData/codegen/box/casts/castGenericNull.kt"");
    }

    @Test
    @TestMetadata(""castToDefinitelyNotNullType.kt"")
    public void testCastToDefinitelyNotNullType() {
      runTest(""compiler/testData/codegen/box/casts/castToDefinitelyNotNullType.kt"");
    }

    @Test
    @TestMetadata(""dontCreateInconsistentTypeDuringStarProjectionSubstitution.kt"")
    public void testDontCreateInconsistentTypeDuringStarProjectionSubstitution() {
      runTest(""compiler/testData/codegen/box/casts/dontCreateInconsistentTypeDuringStarProjectionSubstitution.kt"");
    }

    @Test
    @TestMetadata(""genericReturnCast.kt"")
    public void testGenericReturnCast() {
      runTest(""compiler/testData/codegen/box/casts/genericReturnCast.kt"");
    }

    @Test
    @TestMetadata(""intersectionTypeMultipleBounds.kt"")
    public void testIntersectionTypeMultipleBounds() {
      runTest(""compiler/testData/codegen/box/casts/intersectionTypeMultipleBounds.kt"");
    }

    @Test
    @TestMetadata(""intersectionTypeMultipleBoundsImplicitReceiver.kt"")
    public void testIntersectionTypeMultipleBoundsImplicitReceiver() {
      runTest(""compiler/testData/codegen/box/casts/intersectionTypeMultipleBoundsImplicitReceiver.kt"");
    }

    @Test
    @TestMetadata(""intersectionTypeSmartcast.kt"")
    public void testIntersectionTypeSmartcast() {
      runTest(""compiler/testData/codegen/box/casts/intersectionTypeSmartcast.kt"");
    }

    @Test
    @TestMetadata(""intersectionTypeWithMultipleBoundsAsReceiver.kt"")
    public void testIntersectionTypeWithMultipleBoundsAsReceiver() {
      runTest(""compiler/testData/codegen/box/casts/intersectionTypeWithMultipleBoundsAsReceiver.kt"");
    }

    @Test
    @TestMetadata(""intersectionTypeWithoutGenericsAsReceiver.kt"")
    public void testIntersectionTypeWithoutGenericsAsReceiver() {
      runTest(""compiler/testData/codegen/box/casts/intersectionTypeWithoutGenericsAsReceiver.kt"");
    }

    @Test
    @TestMetadata(""is.kt"")
    public void testIs() {
      runTest(""compiler/testData/codegen/box/casts/is.kt"");
    }

    @Test
    @TestMetadata(""isNullablePrimitive.kt"")
    public void testIsNullablePrimitive() {
      runTest(""compiler/testData/codegen/box/casts/isNullablePrimitive.kt"");
    }

    @Test
    @TestMetadata(""kt22714.kt"")
    public void testKt22714() {
      runTest(""compiler/testData/codegen/box/casts/kt22714.kt"");
    }

    @Test
    @TestMetadata(""kt48927_privateMethodOnDerivedCastToBase.kt"")
    public void testKt48927_privateMethodOnDerivedCastToBase() {
      runTest(""compiler/testData/codegen/box/casts/kt48927_privateMethodOnDerivedCastToBase.kt"");
    }

    @Test
    @TestMetadata(""kt50577.kt"")
    public void testKt50577() {
      runTest(""compiler/testData/codegen/box/casts/kt50577.kt"");
    }

    @Test
    @TestMetadata(""kt53146.kt"")
    public void testKt53146() {
      runTest(""compiler/testData/codegen/box/casts/kt53146.kt"");
    }

    @Test
    @TestMetadata(""kt53677.kt"")
    public void testKt53677() {
      runTest(""compiler/testData/codegen/box/casts/kt53677.kt"");
    }

    @Test
    @TestMetadata(""kt54318.kt"")
    public void testKt54318() {
      runTest(""compiler/testData/codegen/box/casts/kt54318.kt"");
    }

    @Test
    @TestMetadata(""kt54581.kt"")
    public void testKt54581() {
      runTest(""compiler/testData/codegen/box/casts/kt54581.kt"");
    }

    @Test
    @TestMetadata(""kt54707.kt"")
    public void testKt54707() {
      runTest(""compiler/testData/codegen/box/casts/kt54707.kt"");
    }

    @Test
    @TestMetadata(""kt54802.kt"")
    public void testKt54802() {
      runTest(""compiler/testData/codegen/box/casts/kt54802.kt"");
    }

    @Test
    @TestMetadata(""kt55005.kt"")
    public void testKt55005() {
      runTest(""compiler/testData/codegen/box/casts/kt55005.kt"");
    }

    @Test
    @TestMetadata(""kt58707.kt"")
    public void testKt58707() {
      runTest(""compiler/testData/codegen/box/casts/kt58707.kt"");
    }

    @Test
    @TestMetadata(""kt59022.kt"")
    public void testKt59022() {
      runTest(""compiler/testData/codegen/box/casts/kt59022.kt"");
    }

    @Test
    @TestMetadata(""kt65197.kt"")
    public void testKt65197() {
      runTest(""compiler/testData/codegen/box/casts/kt65197.kt"");
    }

    @Test
    @TestMetadata(""kt68509.kt"")
    public void testKt68509() {
      runTest(""compiler/testData/codegen/box/casts/kt68509.kt"");
    }

    @Test
    @TestMetadata(""kt73931.kt"")
    public void testKt73931() {
      runTest(""compiler/testData/codegen/box/casts/kt73931.kt"");
    }

    @Test
    @TestMetadata(""lambdaToUnitCast.kt"")
    public void testLambdaToUnitCast() {
      runTest(""compiler/testData/codegen/box/casts/lambdaToUnitCast.kt"");
    }

    @Test
    @TestMetadata(""notIs.kt"")
    public void testNotIs() {
      runTest(""compiler/testData/codegen/box/casts/notIs.kt"");
    }

    @Test
    @TestMetadata(""nullableSafeCastToTypeParameterWithInterfaceUpperBound.kt"")
    public void testNullableSafeCastToTypeParameterWithInterfaceUpperBound() {
      runTest(""compiler/testData/codegen/box/casts/nullableSafeCastToTypeParameterWithInterfaceUpperBound.kt"");
    }

    @Test
    @TestMetadata(""objectToPrimitiveWithAssertion.kt"")
    public void testObjectToPrimitiveWithAssertion() {
      runTest(""compiler/testData/codegen/box/casts/objectToPrimitiveWithAssertion.kt"");
    }

    @Test
    @TestMetadata(""parallelHierarchy.kt"")
    public void testParallelHierarchy() {
      runTest(""compiler/testData/codegen/box/casts/parallelHierarchy.kt"");
    }

    @Test
    @TestMetadata(""toNativePointers.kt"")
    public void testToNativePointers() {
      runTest(""compiler/testData/codegen/box/casts/toNativePointers.kt"");
    }

    @Test
    @TestMetadata(""unitAsAny.kt"")
    public void testUnitAsAny() {
      runTest(""compiler/testData/codegen/box/casts/unitAsAny.kt"");
    }

    @Test
    @TestMetadata(""unitAsInt.kt"")
    public void testUnitAsInt() {
      runTest(""compiler/testData/codegen/box/casts/unitAsInt.kt"");
    }

    @Test
    @TestMetadata(""unitAsSafeAny.kt"")
    public void testUnitAsSafeAny() {
      runTest(""compiler/testData/codegen/box/casts/unitAsSafeAny.kt"");
    }

    @Test
    @TestMetadata(""unitNullableCast.kt"")
    public void testUnitNullableCast() {
      runTest(""compiler/testData/codegen/box/casts/unitNullableCast.kt"");
    }

    @Test
    @TestMetadata(""wasmCastMessages.kt"")
    public void testWasmCastMessages() {
      runTest(""compiler/testData/codegen/box/casts/wasmCastMessages.kt"");
    }

    @Nested
    @TestMetadata(""compiler/testData/codegen/box/casts/functions"")
    @TestDataPath(""$PROJECT_ROOT"")
    public class Functions {
      @Test
      public void testAllFilesPresentInFunctions() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File(""compiler/testData/codegen/box/casts/functions""), Pattern.compile(""^(.+)\\.kt$""), null, true);
      }

      @Test
      @TestMetadata(""asFunKBig.kt"")
      public void testAsFunKBig() {
        runTest(""compiler/testData/codegen/box/casts/functions/asFunKBig.kt"");
      }

      @Test
      @TestMetadata(""asFunKSmall.kt"")
      public void testAsFunKSmall() {
        runTest(""compiler/testData/codegen/box/casts/functions/asFunKSmall.kt"");
      }

      @Test
      @TestMetadata(""isFunKBig.kt"")
      public void testIsFunKBig() {
        runTest(""compiler/testData/codegen/box/casts/functions/isFunKBig.kt"");
      }

      @Test
      @TestMetadata(""isFunKSmall.kt"")
      public void testIsFunKSmall() {
        runTest(""compiler/testData/codegen/box/casts/functions/isFunKSmall.kt"");
      }

      @Test
      @TestMetadata(""isFunKSmallJS.kt"")
      public void testIsFunKSmallJS() {
        runTest(""compiler/testData/codegen/box/casts/functions/isFunKSmallJS.kt"");
      }

      @Test
      @TestMetadata(""isFunKSmallJVM.kt"")
      public void testIsFunKSmallJVM() {
        runTest(""compiler/testData/codegen/box/casts/functions/isFunKSmallJVM.kt"");
      }

      @Test
      @TestMetadata(""isFunKSmallNonJS.kt"")
      public void testIsFunKSmallNonJS() {
        runTest(""compiler/testData/codegen/box/casts/functions/isFunKSmallNonJS.kt"");
      }

      @Test
      @TestMetadata(""javaTypeIsFunK.kt"")
      public void testJavaTypeIsFunK() {
        runTest(""compiler/testData/codegen/box/casts/functions/javaTypeIsFunK.kt"");
      }

      @Test
      @TestMetadata(""reifiedAsFunKBig.kt"")
      public void testReifiedAsFunKBig() {
        runTest(""compiler/testData/codegen/box/casts/functions/reifiedAsFunKBig.kt"");
      }

      @Test
      @TestMetadata(""reifiedAsFunKSmall.kt"")
      public void testReifiedAsFunKSmall() {
        runTest(""compiler/testData/codegen/box/casts/functions/reifiedAsFunKSmall.kt"");
      }

      @Test
      @TestMetadata(""reifiedIsFunKBig.kt"")
      public void testReifiedIsFunKBig() {
        runTest(""compiler/testData/codegen/box/casts/functions/reifiedIsFunKBig.kt"");
      }

      @Test
      @TestMetadata(""reifiedIsFunKSmall.kt"")
      public void testReifiedIsFunKSmall() {
        runTest(""compiler/testData/codegen/box/casts/functions/reifiedIsFunKSmall.kt"");
      }

      @Test
      @TestMetadata(""reifiedSafeAsFunKBig.kt"")
      public void testReifiedSafeAsFunKBig() {
        runTest(""compiler/testData/codegen/box/casts/functions/reifiedSafeAsFunKBig.kt"");
      }

      @Test
      @TestMetadata(""reifiedSafeAsFunKSmall.kt"")
      public void testReifiedSafeAsFunKSmall() {
        runTest(""compiler/testData/codegen/box/casts/functions/reifiedSafeAsFunKSmall.kt"");
      }

      @Test
      @TestMetadata(""safeAsFunKBig.kt"")
      public void testSafeAsFunKBig() {
        runTest(""compiler/testData/codegen/box/casts/functions/safeAsFunKBig.kt"");
      }

      @Test
      @TestMetadata(""safeAsFunKSmall.kt"")
      public void testSafeAsFunKSmall() {
        runTest(""compiler/testData/codegen/box/casts/functions/safeAsFunKSmall.kt"");
      }
    }

    @Nested
    @TestMetadata(""compiler/testData/codegen/box/casts/javaInterop"")
    @TestDataPath(""$PROJECT_ROOT"")
    public class JavaInterop {
      @Test
      public void testAllFilesPresentInJavaInterop() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File(""compiler/testData/codegen/box/casts/javaInterop""), Pattern.compile(""^(.+)\\.kt$""), null, true);
      }

      @Test
      @TestMetadata(""castWithWrongType.kt"")
      public void testCastWithWrongType() {
        runTest(""compiler/testData/codegen/box/casts/javaInterop/castWithWrongType.kt"");
      }

      @Test
      @TestMetadata(""implicitNotNullWithWrongType.kt"")
      public void testImplicitNotNullWithWrongType() {
        runTest(""compiler/testData/codegen/box/casts/javaInterop/implicitNotNullWithWrongType.kt"");
      }

      @Test
      @TestMetadata(""instanceOfWithWrongType.kt"")
      public void testInstanceOfWithWrongType() {
        runTest(""compiler/testData/codegen/box/casts/javaInterop/instanceOfWithWrongType.kt"");
      }

      @Test
      @TestMetadata(""noNullCheckOnCollectionContains.kt"")
      public void testNoNullCheckOnCollectionContains() {
        runTest(""compiler/testData/codegen/box/casts/javaInterop/noNullCheckOnCollectionContains.kt"");
      }

      @Test
      @TestMetadata(""noNullCheckOnCollectionRemove.kt"")
      public void testNoNullCheckOnCollectionRemove() {
        runTest(""compiler/testData/codegen/box/casts/javaInterop/noNullCheckOnCollectionRemove.kt"");
      }

      @Test
      @TestMetadata(""noNullCheckOnListIndexOf.kt"")
      public void testNoNullCheckOnListIndexOf() {
        runTest(""compiler/testData/codegen/box/casts/javaInterop/noNullCheckOnListIndexOf.kt"");
      }

      @Test
      @TestMetadata(""noNullCheckOnListLastIndexOf.kt"")
      public void testNoNullCheckOnListLastIndexOf() {
        runTest(""compiler/testData/codegen/box/casts/javaInterop/noNullCheckOnListLastIndexOf.kt"");
      }

      @Test
      @TestMetadata(""noNullCheckOnMapContainsKey.kt"")
      public void testNoNullCheckOnMapContainsKey() {
        runTest(""compiler/testData/codegen/box/casts/javaInterop/noNullCheckOnMapContainsKey.kt"");
      }

      @Test
      @TestMetadata(""noNullCheckOnMapContainsValue.kt"")
      public void testNoNullCheckOnMapContainsValue() {
        runTest(""compiler/testData/codegen/box/casts/javaInterop/noNullCheckOnMapContainsValue.kt"");
      }

      @Test
      @TestMetadata(""noNullCheckOnMapGet.kt"")
      public void testNoNullCheckOnMapGet() {
        runTest(""compiler/testData/codegen/box/casts/javaInterop/noNullCheckOnMapGet.kt"");
      }

      @Test
      @TestMetadata(""noNullCheckOnMapRemove.kt"")
      public void testNoNullCheckOnMapRemove() {
        runTest(""compiler/testData/codegen/box/casts/javaInterop/noNullCheckOnMapRemove.kt"");
      }

      @Test
      @TestMetadata(""nullCheckOnMapGetOrDefault.kt"")
      public void testNullCheckOnMapGetOrDefault() {
        runTest(""compiler/testData/codegen/box/casts/javaInterop/nullCheckOnMapGetOrDefault.kt"");
      }

      @Test
      @TestMetadata(""nullCheckOnMapRemove2.kt"")
      public void testNullCheckOnMapRemove2() {
        runTest(""compiler/testData/codegen/box/casts/javaInterop/nullCheckOnMapRemove2.kt"");
      }

      @Test
      @TestMetadata(""safeCastWithWrongType.kt"")
      public void testSafeCastWithWrongType() {
        runTest(""compiler/testData/codegen/box/casts/javaInterop/safeCastWithWrongType.kt"");
      }
    }

    @Nested
    @TestMetadata(""compiler/testData/codegen/box/casts/literalExpressionAsGenericArgument"")
    @TestDataPath(""$PROJECT_ROOT"")
    public class LiteralExpressionAsGenericArgument {
      @Test
      public void testAllFilesPresentInLiteralExpressionAsGenericArgument() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File(""compiler/testData/codegen/box/casts/literalExpressionAsGenericArgument""), Pattern.compile(""^(.+)\\.kt$""), null, true);
      }

      @Test
      @TestMetadata(""binaryExpressionCast.kt"")
      public void testBinaryExpressionCast() {
        runTest(""compiler/testData/codegen/box/casts/literalExpressionAsGenericArgument/binaryExpressionCast.kt"");
      }

      @Test
      @TestMetadata(""javaBox.kt"")
      public void testJavaBox() {
        runTest(""compiler/testData/codegen/box/casts/literalExpressionAsGenericArgument/javaBox.kt"");
      }

      @Test
      @TestMetadata(""labeledExpressionCast.kt"")
      public void testLabeledExpressionCast() {
        runTest(""compiler/testData/codegen/box/casts/literalExpressionAsGenericArgument/labeledExpressionCast.kt"");
      }

      @Test
      @TestMetadata(""parenthesizedExpressionCast.kt"")
      public void testParenthesizedExpressionCast() {
        runTest(""compiler/testData/codegen/box/casts/literalExpressionAsGenericArgument/parenthesizedExpressionCast.kt"");
      }

      @Test
      @TestMetadata(""superConstructor.kt"")
      public void testSuperConstructor() {
        runTest(""compiler/testData/codegen/box/casts/literalExpressionAsGenericArgument/superConstructor.kt"");
      }

      @Test
      @TestMetadata(""unaryExpressionCast.kt"")
      public void testUnaryExpressionCast() {
        runTest(""compiler/testData/codegen/box/casts/literalExpressionAsGenericArgument/unaryExpressionCast.kt"");
      }

      @Test
      @TestMetadata(""vararg.kt"")
      public void testVararg() {
        runTest(""compiler/testData/codegen/box/casts/literalExpressionAsGenericArgument/vararg.kt"");
      }
    }

    @Nested
    @TestMetadata(""compiler/testData/codegen/box/casts/mutableCollections"")
    @TestDataPath(""$PROJECT_ROOT"")
    public class MutableCollections {
      @Test
      public void testAllFilesPresentInMutableCollections() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File(""compiler/testData/codegen/box/casts/mutableCollections""), Pattern.compile(""^(.+)\\.kt$""), null, true);
      }

      @Test
      @TestMetadata(""asWithMutable.kt"")
      public void testAsWithMutable() {
        runTest(""compiler/testData/codegen/box/casts/mutableCollections/asWithMutable.kt"");
      }

      @Test
      @TestMetadata(""isWithMutable.kt"")
      public void testIsWithMutable() {
        runTest(""compiler/testData/codegen/box/casts/mutableCollections/isWithMutable.kt"");
      }

      @Test
      @TestMetadata(""mutabilityMarkerInterfaces.kt"")
      public void testMutabilityMarkerInterfaces() {
        runTest(""compiler/testData/codegen/box/casts/mutableCollections/mutabilityMarkerInterfaces.kt"");
      }

      @Test
      @TestMetadata(""reifiedAsWithMutable.kt"")
      public void testReifiedAsWithMutable() {
        runTest(""compiler/testData/codegen/box/casts/mutableCollections/reifiedAsWithMutable.kt"");
      }

      @Test
      @TestMetadata(""reifiedIsWithMutable.kt"")
      public void testReifiedIsWithMutable() {
        runTest(""compiler/testData/codegen/box/casts/mutableCollections/reifiedIsWithMutable.kt"");
      }

      @Test
      @TestMetadata(""reifiedSafeAsWithMutable.kt"")
      public void testReifiedSafeAsWithMutable() {
        runTest(""compiler/testData/codegen/box/casts/mutableCollections/reifiedSafeAsWithMutable.kt"");
      }

      @Test
      @TestMetadata(""safeAsWithMutable.kt"")
      public void testSafeAsWithMutable() {
        runTest(""compiler/testData/codegen/box/casts/mutableCollections/safeAsWithMutable.kt"");
      }

      @Test
      @TestMetadata(""weirdMutableCasts.kt"")
      public void testWeirdMutableCasts() {
        runTest(""compiler/testData/codegen/box/casts/mutableCollections/weirdMutableCasts.kt"");
      }
    }

    @Nested
    @TestMetadata(""compiler/testData/codegen/box/casts/nativeCCEMessage"")
    @TestDataPath(""$PROJECT_ROOT"")
    public class NativeCCEMessage {
      @Test
      public void testAllFilesPresentInNativeCCEMessage() {
        KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File(""compiler/testData/codegen/box/casts/nativeCCEMessage""), Pattern.compile(""^(.+)\\.kt$""), null, true);
      }

      @Test
      @TestMetadata(""castAnonymousClass.kt"")
      public void testCastAnonymousClass() {
        runTest(""compiler/testData/codegen/box/casts/nativeCCEMessage/castAnonymousClass.kt"");
      }

      @Test
      @TestMetadata(""castGlobalClass.kt"")
      public void testCastGlobalClass() {
        runTest(""compiler/testData/codegen/box/casts/nativeCCEMessage/castGlobalClass.kt"");
      }

      @Test
      @TestMetadata(""castLocalClass.kt"")
      public void testCastLocalClass() {
        runTest(""compiler/testData/codegen/box/casts/nativeCCEMessage/castLocalClass.kt"");
      }

      @Test
      @TestMetadata(""castToLocalClass.kt"")
      public void testCastToLocalClass() {
        runTest(""compiler/testData/codegen/box/casts/nativeCCEMessage/castToLocalClass.kt"");
      }
    }
  }",KOT_02849,,,0
duckduckgo__Android,06e95f7814f0486085321bf6825dce4e91ba563d,app/src/androidTest/java/com/duckduckgo/app/notification/model/AppFeatureNotificationTest.kt,.kt,David González,malmstein@gmail.com,2022-11-18T11:57:35+01:00,Replace Spotless with Kotlinter and applying KtLint (#2419),1,,"/*
 * Copyright (c) 2020 DuckDuckGo
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

@file:Suppress(""RemoveExplicitTypeArguments"")

package com.duckduckgo.app.notification.model

import androidx.test.platform.app.InstrumentationRegistry
import com.duckduckgo.app.browser.R
import com.duckduckgo.app.notification.db.NotificationDao
import org.mockito.kotlin.any
import org.mockito.kotlin.mock
import org.mockito.kotlin.whenever
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runTest
import org.junit.Assert.assertEquals
import org.junit.Assert.assertFalse
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Test

@ExperimentalCoroutinesApi
class AppFeatureNotificationTest {

    private val context = InstrumentationRegistry.getInstrumentation().targetContext
    private val notificationsDao: NotificationDao = mock()
    private lateinit var testee: AppFeatureNotification

    @Before
    fun before() {
        testee = AppFeatureNotification(context, notificationsDao, R.string.yes, R.string.no, PIXEL)
    }

    @Test
    fun whenNotificationNotSeenThenCanShowIsTrue() = runTest {
        whenever(notificationsDao.exists(any())).thenReturn(false)
        assertTrue(testee.canShow())
    }

    @Test
    fun whenNotificationAlreadySeenThenCanShowIsFalse() = runTest {
        whenever(notificationsDao.exists(any())).thenReturn(true)
        assertFalse(testee.canShow())
    }

    @Test
    fun whenBuildSpecificationSetCorrectPixelSuffix() = runTest {
        val spec = testee.buildSpecification()
        assertEquals(PIXEL, spec.pixelSuffix)
    }

    companion object {
        private const val PIXEL = ""pixel""
    }
}
",KSEC_4219,['CWE-321: Hard-coded Cryptographic Key'],"['A02: Cryptographic Failures', 'A04: Insecure Design']",1
shadowsocks__shadowsocks-android,7e9652ed6eaa9c539805328c9408b9aa5b03de89,mobile/src/main/java/com/github/shadowsocks/ProfileConfigFragment.kt,.kt,Mygod,contact-git@mygod.be,2020-02-08T03:01:18+08:00,Fix handling of missing plugin,1,DeleteConfirmationDialogFragment,"    class DeleteConfirmationDialogFragment : AlertDialogFragment<ProfileIdArg, Empty>() {
        override fun AlertDialog.Builder.prepare(listener: DialogInterface.OnClickListener) {
            setTitle(R.string.delete_confirm_prompt)
            setPositiveButton(R.string.yes) { _, _ ->
                ProfileManager.delProfile(arg.profileId)
                requireActivity().finish()
            }
            setNegativeButton(R.string.no, null)
        }
    }",KOT_03738,,,0
duckduckgo__Android,f98184d29b07f74924fda561f0b661f907a688b0,duckchat/duckchat-impl/src/test/kotlin/com/duckduckgo/duckchat/impl/messaging/DuckChatContentScopeJsMessageHandlerTest.kt,.kt,David González,malmstein@gmail.com,2025-06-23T15:50:43+02:00,Duck.ai: Session pixels (#6253),1,DuckChatContentScopeJsMessageHandlerTest,"class DuckChatContentScopeJsMessageHandlerTest {
    private val handler = DuckChatContentScopeJsMessageHandler().getJsMessageHandler()

    @Test
    fun `when message sent then callback called`() {
        val message = JsMessage(
            context = ""contentScopeScripts"",
            featureName = ""aiChat"",
            id = ""myId"",
            method = ""getAIChatNativeHandoffData"",
            params = JSONObject(),
        )

        handler.process(message, ""secret"", callback)

        assertEquals(1, callback.counter)
    }

    @Test
    fun `only allow duckduckgo dot com domains`() {
        val domains = handler.allowedDomains
        assertTrue(domains.size == 1)
        assertTrue(domains.first() == ""duckduckgo.com"")
    }

    @Test
    fun `feature name is ai chat`() {
        assertTrue(handler.featureName == ""aiChat"")
    }

    @Test
    fun `only contains valid methods`() {
        val methods = handler.methods
        assertTrue(methods.size == 8)
        assertTrue(methods[0] == ""getAIChatNativeHandoffData"")
        assertTrue(methods[1] == ""getAIChatNativeConfigValues"")
        assertTrue(methods[2] == ""openAIChat"")
        assertTrue(methods[3] == ""closeAIChat"")
        assertTrue(methods[4] == ""openAIChatSettings"")
        assertTrue(methods[5] == ""responseState"")
        assertTrue(methods[6] == ""hideChatInput"")
        assertTrue(methods[7] == ""showChatInput"")
    }

    private val callback = object : JsMessageCallback() {
        var counter = 0
        override fun process(featureName: String, method: String, id: String?, data: JSONObject?) {
            counter++
        }
    }
}",KSEC_1510,['CWE-321: Hard-coded Cryptographic Key'],"['A02: Cryptographic Failures', 'A04: Insecure Design']",1
JetBrains__kotlin,6eb46220ffe5ba95264e0093a43bbfd3dc175ff0,compiler/testData/klib/syntheticAccessors/privateMember/crossModulePrivateLeak/reflectionViaReferenceToLeakingPrivateMethod.kt,.kt,Ivan Kylchik,ivan.kylchik@jetbrains.com,2025-10-07T09:58:41+02:00,[Inline] Apply a patch to ignore broken preprocessed funs in klib,1,,"// IGNORE_KLIB_SYNTHETIC_ACCESSORS_CHECKS: JS_IR
// TARGET_BACKEND: NATIVE, JS_IR, WASM
// ^^^ JVM has a similar but distinct behavior w.r.t. references to unreferencable callables

// Synthetic accessors are generated only to allow ""calling"" a declaration, they are not quite sufficient to provide
// reflection information (such as .name). So a request for it is supposed to fail at runtime with a PL linage error.
// However, because of techical limitation, the original declaration (with a correct information) may still slip
// through sometimes. So we expect either a valid answare or a runtime error.

// MODULE: lib
// FILE: A.kt
class A {
    private fun privateMethod() = ""OK""

    @Suppress(""NON_PUBLIC_CALL_FROM_PUBLIC_INLINE"")
    public inline fun publicInlineFunction() = ::privateMethod
}

// MODULE: main(lib)
// FILE: main.kt
fun box(): String {
    try {
        return A().publicInlineFunction().name.let { if (it == ""privateMethod"") ""OK"" else it }
    } catch (linkageError: Error) {
        return if (linkageError::class.simpleName == ""IrLinkageError"") ""OK"" else linkageError.toString()
    }
}
",KOT_01879,,,0
shadowsocks__shadowsocks-android,a755b669c8e23ad4fee2dbbcd45f06c9eac0ede0,mobile/src/main/java/com/github/shadowsocks/bg/TrafficMonitorThread.kt,.kt,Mygod,contact-git@mygod.be,2018-02-04T15:07:38-08:00,Fix code style issues,1,TrafficMonitorThread,"class TrafficMonitorThread : LocalSocketListener(""TrafficMonitorThread"") {
    override val socketFile = File(app.deviceContext.filesDir, ""stat_path"")

    override fun accept(socket: LocalSocket) {
        try {
            val buffer = ByteArray(16)
            if (socket.inputStream.read(buffer) != 16) throw IOException(""Unexpected traffic stat length"")
            val stat = ByteBuffer.wrap(buffer).order(ByteOrder.LITTLE_ENDIAN)
            TrafficMonitor.update(stat.getLong(0), stat.getLong(8))
            socket.outputStream.write(0)
        } catch (e: IOException) {
            Log.e(tag, ""Error when recv traffic stat"", e)
            app.track(e)
        }
    }
}",KOT_03963,,,0
JetBrains__kotlin,76ece530e36e9f109e28a07ace90cb75bbd172d8,compiler/fir/semantics/src/org/jetbrains/kotlin/fir/resolve/dfa/DfaVariables.kt,.kt,Kirill Rakhman,kirill.rakhman@jetbrains.com,2025-08-05T11:50:31+02:00,[FIR] Unify and fix check for internal visibility,1,SyntheticVariable,"data class SyntheticVariable(val fir: FirExpression) : DataFlowVariable() {
    override val originalType: ConeKotlinType get() = fir.resolvedType
}",KOT_02585,,,0
JetBrains__kotlin,1e7ada66c402e526448e4827049382317064e4e8,js/js.translator/testData/typescript-export/js/collections/collections.kt,.kt,Artem Kobzar,artem.kobzar@jetbrains.com,2025-07-14T10:29:31Z,[K/JS] Fix problem with the collection exportability in type arguments,1,,"// CHECK_TYPESCRIPT_DECLARATIONS
// RUN_PLAIN_BOX_FUNCTION
// WITH_STDLIB
// SKIP_NODE_JS
// INFER_MAIN_MODULE

// TODO fix statics export in DCE-driven mode
// SKIP_DCE_DRIVEN

// MODULE: JS_TESTS
// FILE: f1.kt

import kotlin.js.Promise

@JsExport
fun provideList(): List<Int> = listOf(1, 2, 3)

@JsExport
fun provideMutableList(): MutableList<Int> = mutableListOf(4, 5, 6)

@JsExport
fun provideSet(): Set<Int> = setOf(1, 2, 3)

@JsExport
fun provideMutableSet(): MutableSet<Int> = mutableSetOf(4, 5, 6)

@JsExport
fun provideMap(): Map<String, Int> = mapOf(""a"" to 1, ""b"" to 2, ""c"" to 3)

@JsExport
fun provideMutableMap(): MutableMap<String, Int> = mutableMapOf(""d"" to 4, ""e"" to 5, ""f"" to 6)

@JsExport
fun consumeList(list: List<Int>) = list.toString() == ""[1, 2, 3]""

@JsExport
fun consumeMutableList(list: MutableList<Int>): Boolean {
    list.add(7)
    return list.toString() == ""[4, 5, 6, 7]""
}

@JsExport
fun consumeSet(list: Set<Int>) = list.toString() == ""[1, 2, 3]""

@JsExport
fun consumeMutableSet(list: MutableSet<Int>): Boolean {
    list.add(7)
    return list.toString() == ""[4, 5, 6, 7]""
}

@JsExport
fun consumeMap(map: Map<String, Int>) = map.toString() == ""{a=1, b=2, c=3}""

@JsExport
fun consumeMutableMap(map: MutableMap<String, Int>): Boolean {
    map[""g""] = 7
    return map.toString() == ""{d=4, e=5, f=6, g=7}""
}

@JsExport
fun provideListAsync(): Promise<List<Int>> = Promise.resolve(listOf(1, 2, 3))
",KOT_02958,,,0
2dust__v2rayNG,6914b9ee1bce6a57bf26737d7565d49648e913a1,V2rayNG/app/src/main/kotlin/com/v2ray/ang/fmt/SocksFmt.kt,.kt,2dust,31833384+2dust@users.noreply.github.com,2024-11-09T17:32:13+08:00,Bug fix,1,SocksFmt,"object SocksFmt : FmtBase() {
    fun parse(str: String): ProfileItem? {
        val config = ProfileItem.create(EConfigType.SOCKS)

        val uri = URI(Utils.fixIllegalUrl(str))
        if (uri.idnHost.isEmpty()) return null
        if (uri.port <= 0) return null

        config.remarks = Utils.urlDecode(uri.fragment.orEmpty())
        config.server = uri.idnHost
        config.serverPort = uri.port.toString()

        if (uri.userInfo?.isEmpty() == false) {
            val result = Utils.decode(uri.userInfo).split("":"", limit = 2)
            if (result.count() == 2) {
                config.username = result.first()
                config.password = result.last()
            }
        }

        return config
    }

    fun toUri(config: ProfileItem): String {
        val pw =
            if (config.username.isNotNullEmpty())
                ""${config.username}:${config.password}""
            else
                "":""

        return toUri(config, Utils.encode(pw), null)
    }

    fun toOutbound(profileItem: ProfileItem): OutboundBean? {
        val outboundBean = OutboundBean.create(EConfigType.SOCKS)

        outboundBean?.settings?.servers?.first()?.let { server ->
            server.address = profileItem.server.orEmpty()
            server.port = profileItem.serverPort.orEmpty().toInt()
            if (profileItem.username.isNotNullEmpty()) {
                val socksUsersBean = OutboundBean.OutSettingsBean.ServersBean.SocksUsersBean()
                socksUsersBean.user = profileItem.username.orEmpty()
                socksUsersBean.pass = profileItem.password.orEmpty()
                server.users = listOf(socksUsersBean)
            }
        }

        return outboundBean
    }

}",KOT_00067,,,0
JetBrains__kotlin,6eb46220ffe5ba95264e0093a43bbfd3dc175ff0,compiler/testData/klib/syntheticAccessors/privateMember/crossFilePrivateLeak/leakingPrivateExtensionMember.kt,.kt,Ivan Kylchik,ivan.kylchik@jetbrains.com,2025-10-07T09:58:41+02:00,[Inline] Apply a patch to ignore broken preprocessed funs in klib,1,,"// IGNORE_KLIB_SYNTHETIC_ACCESSORS_CHECKS: JS_IR
// FILE: A.kt
class A {
    internal inline fun internalInlineMethodA() = 21.privateExtensionMethod()
    internal inline fun internalInlineMethodB() = 21.privateExtensionVar

    private fun Int.privateExtensionMethod() = this
    private val Int.privateExtensionVar
        get() = this
}

// FILE: main.kt
fun box(): String {
    var result = 0
    A().run {
        result += internalInlineMethodA()
        result += internalInlineMethodB()
    }
    if (result != 42) return result.toString()
    return ""OK""
}
",KOT_01852,,,0
duckduckgo__Android,9a6b40b3a0e2fa8663dc993f0f4a67e85b0a6b89,autofill/autofill-impl/src/main/java/com/duckduckgo/autofill/impl/importing/settings/ImportGooglePasswordMainAppSettings.kt,.kt,Mike Scamell,mikescamell@users.noreply.github.com,2025-10-01T17:04:53+01:00,Rollback Ktlint update (#6865),1,,"/*
 * Copyright (c) 2025 DuckDuckGo
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.duckduckgo.autofill.impl.importing.settings

import android.content.Context
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import androidx.appcompat.app.AppCompatActivity
import androidx.lifecycle.findViewTreeLifecycleOwner
import androidx.lifecycle.lifecycleScope
import com.duckduckgo.anvil.annotations.PriorityKey
import com.duckduckgo.app.statistics.pixels.Pixel
import com.duckduckgo.autofill.api.AutofillImportLaunchSource.MainAppSettings
import com.duckduckgo.autofill.impl.R
import com.duckduckgo.autofill.impl.importing.InSettingsPasswordImportPromoRules
import com.duckduckgo.autofill.impl.pixel.AutofillPixelNames.AUTOFILL_IMPORT_GOOGLE_PASSWORDS_EMPTY_STATE_CTA_BUTTON_TAPPED
import com.duckduckgo.autofill.impl.pixel.AutofillPixelNames.AUTOFILL_IMPORT_GOOGLE_PASSWORDS_MAIN_APP_SETTINGS_HIDDEN
import com.duckduckgo.autofill.impl.store.InternalAutofillStore
import com.duckduckgo.autofill.impl.ui.credential.management.importpassword.google.ImportFromGooglePasswordsDialog
import com.duckduckgo.autofill.impl.ui.credential.management.importpassword.google.ImportFromGooglePasswordsDialog.ImportPasswordsDialog
import com.duckduckgo.autofill.impl.ui.credential.management.importpassword.google.ImportFromGooglePasswordsDialog.ImportPasswordsDialog.Companion.KEY_IMPORT_SUCCESS
import com.duckduckgo.common.ui.menu.PopupMenu
import com.duckduckgo.common.ui.view.gone
import com.duckduckgo.common.ui.view.listitem.OneLineListItem
import com.duckduckgo.common.ui.view.show
import com.duckduckgo.common.utils.DispatcherProvider
import com.duckduckgo.di.scopes.ActivityScope
import com.duckduckgo.settings.api.CompleteSetupSettingsPlugin
import com.squareup.anvil.annotations.ContributesMultibinding
import javax.inject.Inject
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import logcat.logcat

@ContributesMultibinding(ActivityScope::class)
@PriorityKey(100)
class ImportGooglePasswordMainAppSettings @Inject constructor(
    private val pixel: Pixel,
    private val autofillStore: InternalAutofillStore,
    private val dispatchers: DispatcherProvider,
    private val promoRules: InSettingsPasswordImportPromoRules,
    private val activity: AppCompatActivity,
) : CompleteSetupSettingsPlugin {

    override fun getView(context: Context): View {
        return OneLineListItem(activity).apply {
            setLeadingIconResource(R.drawable.key_color_import_24)

            setPrimaryText(activity.getString(R.string.passwords_import_promo_in_settings_title))
            setOnClickListener {
                onLaunchImportFlow(activity, this)
            }

            configureOverflowMenu()

            gone()
        }.also {
            it.showIfPermitted()
        }
    }

    private fun OneLineListItem.showIfPermitted() {
        activity.lifecycleScope.launch {
            if (promoRules.canShowPromo()) {
                show()
            }
        }
    }

    private fun onLaunchImportFlow(activity: AppCompatActivity, rootView: View) {
        listenForImportResult(activity, rootView)

        val dialog = ImportFromGooglePasswordsDialog.instance(importSource = MainAppSettings, tabId = DIALOG_TAG)
        dialog.show(activity.supportFragmentManager, DIALOG_TAG)

        val params = mapOf(""source"" to MainAppSettings.value)
        pixel.fire(AUTOFILL_IMPORT_GOOGLE_PASSWORDS_EMPTY_STATE_CTA_BUTTON_TAPPED, params)
    }

    private fun listenForImportResult(activity: AppCompatActivity, rootView: View) {
        val resultKey = ImportPasswordsDialog.resultKey(tabId = DIALOG_TAG)

        activity.supportFragmentManager.setFragmentResultListener(resultKey, activity) { _: String, result: Bundle ->
            logcat { ""Autofill-import: Got import passwords result: $result"" }
            if (result.getBoolean(KEY_IMPORT_SUCCESS)) {
                rootView.gone()
            }
        }
    }

    private fun OneLineListItem.configureOverflowMenu() {
        showTrailingIcon()
        setTrailingIconClickListener { overflowView ->
            val layoutInflater = LayoutInflater.from(context)
            val popupMenu = buildPopupMenu(this, layoutInflater)
            popupMenu.show(this, overflowView)
        }
    }

    private fun buildPopupMenu(
        rootView: View,
        layoutInflater: LayoutInflater,
    ): PopupMenu {
        val popupMenu = PopupMenu(layoutInflater, R.layout.popup_window_import_passwords_menu)
        val hideButton = popupMenu.contentView.findViewById<View>(R.id.hide)

        popupMenu.apply {
            onMenuItemClicked(hideButton) {
                rootView.findViewTreeLifecycleOwner()?.lifecycleScope?.launch(dispatchers.main()) {
                    rootView.gone()
                    withContext(dispatchers.io()) {
                        autofillStore.hasDismissedMainAppSettingsPromo = true
                        pixel.fire(AUTOFILL_IMPORT_GOOGLE_PASSWORDS_MAIN_APP_SETTINGS_HIDDEN)
                    }
                }
            }
        }

        return popupMenu
    }

    private companion object {
        private const val DIALOG_TAG = ""ImportGooglePasswordsDialog""
    }
}
",KSEC_0787,['CWE-321: Hard-coded Cryptographic Key'],"['A02: Cryptographic Failures', 'A04: Insecure Design']",1
JetBrains__kotlin,acbf61577ccfe6a4402b7a7c37bccc6f9c204a1f,native/utils/src/org/jetbrains/kotlin/konan/target/KonanTarget.kt,.kt,Artem Olkov,artem.olkov@jetbrains.com,2025-10-09T16:53:52+02:00,KT-81596: mark x86 apple family deprecated ^KT-81596 fixed,1,LINUX_ARM32_HFP,"    object LINUX_ARM32_HFP : KonanTarget(""linux_arm32_hfp"", Family.LINUX, Architecture.ARM32)

    override fun toString() = name

    companion object {
        // TODO: need a better way to enumerated predefined targets.
        val predefinedTargets: Map<String, KonanTarget> by lazy {
            listOf(
                ANDROID_X64, ANDROID_X86, ANDROID_ARM32, ANDROID_ARM64,
                IOS_ARM64, IOS_X64, IOS_SIMULATOR_ARM64,
                WATCHOS_ARM32, WATCHOS_ARM64, WATCHOS_X64,
                WATCHOS_SIMULATOR_ARM64, WATCHOS_DEVICE_ARM64,
                TVOS_ARM64, TVOS_X64, TVOS_SIMULATOR_ARM64,
                LINUX_X64,
                MINGW_X64,
                MACOS_X64, MACOS_ARM64,
                LINUX_ARM64, LINUX_ARM32_HFP
            ).associateBy { it.name }
        }

        val deprecatedTargets = setOf(LINUX_ARM32_HFP, IOS_X64, WATCHOS_X64, TVOS_X64, MACOS_X64)
        val toleratedDeprecatedTargets = setOf(LINUX_ARM32_HFP, IOS_X64, WATCHOS_X64, TVOS_X64, MACOS_X64)
    }",KOT_01341,,,0
gedoor__legado,c882265de2c5f96f0f147efe34c31d378d5f0929,app/src/main/java/io/legado/app/service/BaseReadAloudService.kt,.kt,Horis,8674809+821938089@users.noreply.github.com,2025-01-10T17:29:13+08:00,Fix notification wake screen on,1,BaseReadAloudService,"@file:Suppress(""DEPRECATION"")

package io.legado.app.service

import android.annotation.SuppressLint
import android.app.PendingIntent
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.media.AudioManager
import android.net.wifi.WifiManager
import android.os.Bundle
import android.os.PowerManager
import android.support.v4.media.session.MediaSessionCompat
import android.support.v4.media.session.PlaybackStateCompat
import android.telephony.PhoneStateListener
import android.telephony.TelephonyManager
import androidx.annotation.CallSuper
import androidx.core.app.NotificationCompat
import androidx.lifecycle.lifecycleScope
import androidx.media.AudioFocusRequestCompat
import androidx.media.AudioManagerCompat
import io.legado.app.R
import io.legado.app.base.BaseService
import io.legado.app.constant.AppConst
import io.legado.app.constant.AppLog
import io.legado.app.constant.EventBus
import io.legado.app.constant.IntentAction
import io.legado.app.constant.NotificationId
import io.legado.app.constant.PreferKey
import io.legado.app.constant.Status
import io.legado.app.help.MediaHelp
import io.legado.app.help.config.AppConfig
import io.legado.app.help.coroutine.Coroutine
import io.legado.app.help.glide.ImageLoader
import io.legado.app.lib.permission.Permissions
import io.legado.app.lib.permission.PermissionsCompat
import io.legado.app.model.ReadAloud
import io.legado.app.model.ReadBook
import io.legado.app.receiver.MediaButtonReceiver
import io.legado.app.ui.book.read.ReadBookActivity
import io.legado.app.ui.book.read.page.entities.TextChapter
import io.legado.app.utils.LogUtils
import io.legado.app.utils.activityPendingIntent
import io.legado.app.utils.broadcastPendingIntent
import io.legado.app.utils.getPrefBoolean
import io.legado.app.utils.isVivoDevice
import io.legado.app.utils.observeEvent
import io.legado.app.utils.observeSharedPreferences
import io.legado.app.utils.postEvent
import io.legado.app.utils.toastOnUi
import kotlinx.coroutines.Dispatchers.IO
import kotlinx.coroutines.Dispatchers.Main
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import kotlinx.coroutines.isActive
import kotlinx.coroutines.launch
import splitties.init.appCtx
import splitties.systemservices.audioManager
import splitties.systemservices.notificationManager
import splitties.systemservices.powerManager
import splitties.systemservices.telephonyManager
import splitties.systemservices.wifiManager

/**
 * 朗读服务
 */
abstract class BaseReadAloudService : BaseService(),
    AudioManager.OnAudioFocusChangeListener {

    companion object {
        @JvmStatic
        var isRun = false
            private set

        @JvmStatic
        var pause = true
            private set

        @JvmStatic
        var timeMinute: Int = 0
            private set

        fun isPlay(): Boolean {
            return isRun && !pause
        }

        private const val TAG = ""BaseReadAloudService""

    }

    private val useWakeLock = appCtx.getPrefBoolean(PreferKey.readAloudWakeLock, false)
    private val wakeLock by lazy {
        powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, ""legado:ReadAloudService"")
            .apply {
                this.setReferenceCounted(false)
            }
    }
    private val wifiLock by lazy {
        @Suppress(""DEPRECATION"")
        wifiManager?.createWifiLock(WifiManager.WIFI_MODE_FULL_HIGH_PERF, ""legado:AudioPlayService"")
            ?.apply {
                setReferenceCounted(false)
            }
    }
    private val mFocusRequest: AudioFocusRequestCompat by lazy {
        MediaHelp.buildAudioFocusRequestCompat(this)
    }
    private val mediaSessionCompat: MediaSessionCompat by lazy {
        MediaSessionCompat(this, ""readAloud"")
    }
    private val phoneStateListener by lazy {
        ReadAloudPhoneStateListener()
    }
    internal var contentList = emptyList<String>()
    internal var nowSpeak: Int = 0
    internal var readAloudNumber: Int = 0
    internal var textChapter: TextChapter? = null
    internal var pageIndex = 0
    private var needResumeOnAudioFocusGain = false
    private var needResumeOnCallStateIdle = false
    private var registeredPhoneStateListener = false
    private var dsJob: Job? = null
    private var upNotificationJob: Coroutine<*>? = null
    private var cover: Bitmap =
        BitmapFactory.decodeResource(appCtx.resources, R.drawable.icon_read_book)
    var pageChanged = false
    private var toLast = false
    var paragraphStartPos = 0
    var readAloudByPage = false
        private set

    private val broadcastReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context, intent: Intent) {
            if (AudioManager.ACTION_AUDIO_BECOMING_NOISY == intent.action) {
                pauseReadAloud()
            }
        }
    }

    @SuppressLint(""WakelockTimeout"")
    override fun onCreate() {
        super.onCreate()
        isRun = true
        pause = false
        observeLiveBus()
        initMediaSession()
        initBroadcastReceiver()
        initPhoneStateListener()
        upMediaSessionPlaybackState(PlaybackStateCompat.STATE_PLAYING)
        setTimer(AppConfig.ttsTimer)
        if (AppConfig.ttsTimer > 0) {
            toastOnUi(""朗读定时 ${AppConfig.ttsTimer} 分钟"")
        }
        execute {
            @Suppress(""BlockingMethodInNonBlockingContext"")
            ImageLoader
                .loadBitmap(this@BaseReadAloudService, ReadBook.book?.getDisplayCover())
                .submit()
                .get()
        }.onSuccess {
            cover = it
            upReadAloudNotification()
        }
    }

    fun observeLiveBus() {
        observeEvent<Bundle>(EventBus.READ_ALOUD_PLAY) {
            val play = it.getBoolean(""play"")
            val pageIndex = it.getInt(""pageIndex"")
            val startPos = it.getInt(""startPos"")
            newReadAloud(play, pageIndex, startPos)
        }
        observeSharedPreferences { _, key ->
            when (key) {
                PreferKey.ignoreAudioFocus,
                PreferKey.pauseReadAloudWhilePhoneCalls -> {
                    initPhoneStateListener()
                }
            }
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        if (useWakeLock) {
            wakeLock.release()
            wifiLock?.release()
        }
        isRun = false
        pause = true
        abandonFocus()
        unregisterReceiver(broadcastReceiver)
        postEvent(EventBus.ALOUD_STATE, Status.STOP)
        notificationManager.cancel(NotificationId.ReadAloudService)
        upMediaSessionPlaybackState(PlaybackStateCompat.STATE_STOPPED)
        mediaSessionCompat.release()
        ReadBook.uploadProgress()
        unregisterPhoneStateListener(phoneStateListener)
        upNotificationJob?.invokeOnCompletion {
            notificationManager.cancel(NotificationId.ReadAloudService)
        }
    }

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        when (intent?.action) {
            IntentAction.play -> newReadAloud(
                intent.getBooleanExtra(""play"", true),
                intent.getIntExtra(""pageIndex"", ReadBook.durPageIndex),
                intent.getIntExtra(""startPos"", 0)
            )

            IntentAction.pause -> pauseReadAloud()
            IntentAction.resume -> resumeReadAloud()
            IntentAction.upTtsSpeechRate -> upSpeechRate(true)
            IntentAction.prevParagraph -> prevP()
            IntentAction.nextParagraph -> nextP()
            IntentAction.prev -> prevChapter()
            IntentAction.next -> nextChapter()
            IntentAction.addTimer -> addTimer()
            IntentAction.setTimer -> setTimer(intent.getIntExtra(""minute"", 0))
            IntentAction.stop -> stopSelf()
        }
        return super.onStartCommand(intent, flags, startId)
    }

    private fun newReadAloud(play: Boolean, pageIndex: Int, startPos: Int) {
        execute(executeContext = IO) {
            this@BaseReadAloudService.pageIndex = pageIndex
            textChapter = ReadBook.curTextChapter
            val textChapter = textChapter ?: return@execute
            if (!textChapter.isCompleted) {
                return@execute
            }
            readAloudNumber = textChapter.getReadLength(pageIndex) + startPos
            readAloudByPage = getPrefBoolean(PreferKey.readAloudByPage)
            contentList = textChapter.getNeedReadAloud(0, readAloudByPage, 0)
                .split(""\n"")
                .filter { it.isNotEmpty() }
            var pos = startPos
            val page = textChapter.getPage(pageIndex)!!
            if (pos > 0) {
                for (paragraph in page.paragraphs) {
                    val tmp = pos - paragraph.length - 1
                    if (tmp < 0) break
                    pos = tmp
                }
            }
            nowSpeak = textChapter.getParagraphNum(readAloudNumber + 1, readAloudByPage) - 1
            if (!readAloudByPage && startPos == 0 && !toLast) {
                pos = page.chapterPosition -
                        textChapter.paragraphs[nowSpeak].chapterPosition
            }
            if (toLast) {
                toLast = false
                readAloudNumber = textChapter.getLastParagraphPosition()
                nowSpeak = contentList.lastIndex
                if (page.paragraphs.size == 1) {
                    pos = page.chapterPosition -
                            textChapter.paragraphs[nowSpeak].chapterPosition
                }
            }
            paragraphStartPos = pos
            launch(Main) {
                if (play) play() else pageChanged = true
            }
        }.onError {
            AppLog.put(""启动朗读出错\n${it.localizedMessage}"", it, true)
        }
    }

    @SuppressLint(""WakelockTimeout"")
    open fun play() {
        if (useWakeLock) {
            wakeLock.acquire()
            wifiLock?.acquire()
        }
        isRun = true
        pause = false
        needResumeOnAudioFocusGain = false
        needResumeOnCallStateIdle = false
        upReadAloudNotification()
        postEvent(EventBus.ALOUD_STATE, Status.PLAY)
    }

    abstract fun playStop()

    @CallSuper
    open fun pauseReadAloud(abandonFocus: Boolean = true) {
        if (useWakeLock) {
            wakeLock.release()
            wifiLock?.release()
        }
        pause = true
        if (abandonFocus) {
            abandonFocus()
        }
        upReadAloudNotification()
        upMediaSessionPlaybackState(PlaybackStateCompat.STATE_PAUSED)
        postEvent(EventBus.ALOUD_STATE, Status.PAUSE)
        ReadBook.uploadProgress()
        doDs()
    }

    @SuppressLint(""WakelockTimeout"")
    @CallSuper
    open fun resumeReadAloud() {
        pause = false
        needResumeOnAudioFocusGain = false
        needResumeOnCallStateIdle = false
        upReadAloudNotification()
        upMediaSessionPlaybackState(PlaybackStateCompat.STATE_PLAYING)
        postEvent(EventBus.ALOUD_STATE, Status.PLAY)
    }

    abstract fun upSpeechRate(reset: Boolean = false)

    fun upTtsProgress(progress: Int) {
        postEvent(EventBus.TTS_PROGRESS, progress)
    }

    private fun prevP() {
        if (nowSpeak > 0) {
            playStop()
            nowSpeak--
            readAloudNumber -= contentList[nowSpeak].length + 1 + paragraphStartPos
            paragraphStartPos = 0
            textChapter?.let {
                if (readAloudByPage) {
                    val paragraphs = it.getParagraphs(true)
                    if (!paragraphs[nowSpeak].isParagraphEnd) readAloudNumber++
                }
                if (readAloudNumber < it.getReadLength(pageIndex)) {
                    pageIndex--
                    ReadBook.moveToPrevPage()
                }
            }
            upTtsProgress(readAloudNumber + 1)
            play()
        } else {
            toLast = true
            ReadBook.moveToPrevChapter(true)
        }
    }

    private fun nextP() {
        if (nowSpeak < contentList.size - 1) {
            playStop()
            readAloudNumber += contentList[nowSpeak].length.plus(1) - paragraphStartPos
            paragraphStartPos = 0
            nowSpeak++
            textChapter?.let {
                if (readAloudByPage) {
                    val paragraphs = it.getParagraphs(true)
                    if (!paragraphs[nowSpeak].isParagraphEnd) readAloudNumber--
                }
                if (readAloudNumber >= it.getReadLength(pageIndex + 1)) {
                    pageIndex++
                    ReadBook.moveToNextPage()
                }
            }
            upTtsProgress(readAloudNumber + 1)
            play()
        } else {
            nextChapter()
        }
    }

    private fun setTimer(minute: Int) {
        timeMinute = minute
        doDs()
    }

    private fun addTimer() {
        if (timeMinute == 180) {
            timeMinute = 0
        } else {
            timeMinute += 10
            if (timeMinute > 180) timeMinute = 180
        }
        doDs()
    }

    /**
     * 定时
     */
    @Synchronized
    private fun doDs() {
        postEvent(EventBus.READ_ALOUD_DS, timeMinute)
        upReadAloudNotification()
        dsJob?.cancel()
        dsJob = lifecycleScope.launch {
            while (isActive) {
                delay(60000)
                if (!pause) {
                    if (timeMinute >= 0) {
                        timeMinute--
                    }
                    if (timeMinute == 0) {
                        ReadAloud.stop(this@BaseReadAloudService)
                        postEvent(EventBus.READ_ALOUD_DS, timeMinute)
                        break
                    }
                }
                postEvent(EventBus.READ_ALOUD_DS, timeMinute)
                upReadAloudNotification()
            }
        }
    }

    /**
     * 请求音频焦点
     * @return 音频焦点
     */
    fun requestFocus(): Boolean {
        if (AppConfig.ignoreAudioFocus) {
            return true
        }
        val requestFocus = MediaHelp.requestFocus(mFocusRequest)
        if (!requestFocus) {
            pauseReadAloud(false)
            toastOnUi(""未获取到音频焦点"")
        }
        return requestFocus
    }

    /**
     * 放弃音频焦点
     */
    private fun abandonFocus() {
        AudioManagerCompat.abandonAudioFocusRequest(audioManager, mFocusRequest)
    }

    /**
     * 更新媒体状态
     */
    private fun upMediaSessionPlaybackState(state: Int) {
        mediaSessionCompat.setPlaybackState(
            PlaybackStateCompat.Builder()
                .setActions(MediaHelp.MEDIA_SESSION_ACTIONS)
                .setState(state, nowSpeak.toLong(), 1f)
                .build()
        )
    }

    /**
     * 初始化MediaSession, 注册多媒体按钮
     */
    @SuppressLint(""UnspecifiedImmutableFlag"")
    private fun initMediaSession() {
        mediaSessionCompat.setCallback(object : MediaSessionCompat.Callback() {
            override fun onMediaButtonEvent(mediaButtonEvent: Intent): Boolean {
                return MediaButtonReceiver.handleIntent(this@BaseReadAloudService, mediaButtonEvent)
            }
        })
        mediaSessionCompat.setMediaButtonReceiver(
            broadcastPendingIntent<MediaButtonReceiver>(Intent.ACTION_MEDIA_BUTTON)
        )
        mediaSessionCompat.isActive = true
    }

    /**
     * 注册多媒体按钮监听
     */
    private fun initBroadcastReceiver() {
        val intentFilter = IntentFilter(AudioManager.ACTION_AUDIO_BECOMING_NOISY)
        registerReceiver(broadcastReceiver, intentFilter)
    }

    /**
     * 音频焦点变化
     */
    override fun onAudioFocusChange(focusChange: Int) {
        if (AppConfig.ignoreAudioFocus) {
            AppLog.put(""忽略音频焦点处理(TTS)"")
            return
        }
        when (focusChange) {
            AudioManager.AUDIOFOCUS_GAIN -> {
                if (needResumeOnAudioFocusGain) {
                    AppLog.put(""音频焦点获得,继续朗读"")
                    resumeReadAloud()
                } else {
                    AppLog.put(""音频焦点获得"")
                }
            }

            AudioManager.AUDIOFOCUS_LOSS -> {
                AppLog.put(""音频焦点丢失,暂停朗读"")
                pauseReadAloud()
            }

            AudioManager.AUDIOFOCUS_LOSS_TRANSIENT -> {
                AppLog.put(""音频焦点暂时丢失并会很快再次获得,暂停朗读"")
                if (!pause) {
                    needResumeOnAudioFocusGain = true
                    pauseReadAloud(false)
                }
            }

            AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK -> {
                // 短暂丢失焦点，这种情况是被其他应用申请了短暂的焦点希望其他声音能压低音量（或者关闭声音）凸显这个声音（比如短信提示音），
                AppLog.put(""音频焦点短暂丢失,不做处理"")
            }
        }
    }

    private fun upReadAloudNotification() {
        upNotificationJob = execute {
            try {
                val notification = createNotification()
                notificationManager.notify(NotificationId.ReadAloudService, notification.build())
            } catch (e: Exception) {
                AppLog.put(""创建朗读通知出错,${e.localizedMessage}"", e, true)
            }
        }
    }

    private fun choiceMediaStyle(): androidx.media.app.NotificationCompat.MediaStyle {
        val mediaStyle = androidx.media.app.NotificationCompat.MediaStyle()
            .setShowActionsInCompactView(1, 2, 4)
        if (isVivoDevice) {
            //fix #4090 android 14 can not show play control in lock screen
            mediaStyle.setMediaSession(mediaSessionCompat.sessionToken)
        }
        return mediaStyle
    }

    private fun createNotification(): NotificationCompat.Builder {
        var nTitle: String = when {
            pause -> getString(R.string.read_aloud_pause)
            timeMinute > 0 -> getString(
                R.string.read_aloud_timer,
                timeMinute
            )

            else -> getString(R.string.read_aloud_t)
        }
        nTitle += "": ${ReadBook.book?.name}""
        var nSubtitle = ReadBook.curTextChapter?.title
        if (nSubtitle.isNullOrBlank())
            nSubtitle = getString(R.string.read_aloud_s)
        val builder = NotificationCompat
            .Builder(this@BaseReadAloudService, AppConst.channelIdReadAloud)
            .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)
            .setForegroundServiceBehavior(NotificationCompat.FOREGROUND_SERVICE_IMMEDIATE)
            .setCategory(NotificationCompat.CATEGORY_TRANSPORT)
            .setSmallIcon(R.drawable.ic_volume_up)
            .setSubText(getString(R.string.read_aloud))
            .setOngoing(true)
            .setContentTitle(nTitle)
            .setContentText(nSubtitle)
            .setContentIntent(
                activityPendingIntent<ReadBookActivity>(""activity"")
            )
            .setVibrate(null)
            .setSound(null)
            .setLights(0, 0, 0)
        builder.setLargeIcon(cover)
        // 按钮定义：上一章、播放、停止、下一章、定时
        builder.addAction(
            R.drawable.ic_skip_previous,
            getString(R.string.previous_chapter),
            aloudServicePendingIntent(IntentAction.prev)
        )
        if (pause) {
            builder.addAction(
                R.drawable.ic_play_24dp,
                getString(R.string.resume),
                aloudServicePendingIntent(IntentAction.resume)
            )
        } else {
            builder.addAction(
                R.drawable.ic_pause_24dp,
                getString(R.string.pause),
                aloudServicePendingIntent(IntentAction.pause)
            )
        }
        builder.addAction(
            R.drawable.ic_stop_black_24dp,
            getString(R.string.stop),
            aloudServicePendingIntent(IntentAction.stop)
        )
        builder.addAction(
            R.drawable.ic_skip_next,
            getString(R.string.next_chapter),
            aloudServicePendingIntent(IntentAction.next)
        )
        builder.addAction(
            R.drawable.ic_time_add_24dp,
            getString(R.string.set_timer),
            aloudServicePendingIntent(IntentAction.addTimer)
        )
        builder.setStyle(choiceMediaStyle())
        return builder
    }

    /**
     * 更新通知
     */
    override fun startForegroundNotification() {
        execute {
            try {
                val notification = createNotification()
                startForeground(NotificationId.ReadAloudService, notification.build())
            } catch (e: Exception) {
                AppLog.put(""创建朗读通知出错,${e.localizedMessage}"", e, true)
                //创建通知出错不结束服务就会崩溃,服务必须绑定通知
                stopSelf()
            }
        }
    }

    abstract fun aloudServicePendingIntent(actionStr: String): PendingIntent?

    open fun prevChapter() {
        toLast = false
        ReadBook.moveToPrevChapter(true, toLast = false)
    }

    open fun nextChapter() {
        ReadBook.upReadTime()
        AppLog.putDebug(""${ReadBook.curTextChapter?.chapter?.title} 朗读结束跳转下一章并朗读"")
        if (!ReadBook.moveToNextChapter(true)) {
            stopSelf()
        }
    }

    private fun initPhoneStateListener() {
        val needRegister = AppConfig.ignoreAudioFocus && AppConfig.pauseReadAloudWhilePhoneCalls
        if (needRegister && registeredPhoneStateListener) {
            return
        }
        if (needRegister) {
            registerPhoneStateListener(phoneStateListener)
        } else {
            unregisterPhoneStateListener(phoneStateListener)
        }
    }

    private fun unregisterPhoneStateListener(l: PhoneStateListener) {
        if (registeredPhoneStateListener) {
            withReadPhoneStatePermission {
                telephonyManager.listen(l, PhoneStateListener.LISTEN_NONE)
                registeredPhoneStateListener = false
            }
        }
    }

    private fun registerPhoneStateListener(l: PhoneStateListener) {
        withReadPhoneStatePermission {
            telephonyManager.listen(l, PhoneStateListener.LISTEN_CALL_STATE)
            registeredPhoneStateListener = true
        }
    }

    private fun withReadPhoneStatePermission(block: () -> Unit) {
        try {
            block.invoke()
        } catch (_: SecurityException) {
            PermissionsCompat.Builder()
                .addPermissions(Permissions.READ_PHONE_STATE)
                .rationale(R.string.read_aloud_read_phone_state_permission_rationale)
                .onGranted {
                    try {
                        block.invoke()
                    } catch (_: SecurityException) {
                        LogUtils.d(TAG, ""Grant read phone state permission fail."")
                    }
                }
                .request()
        }
    }

    @Suppress(""OVERRIDE_DEPRECATION"")
    inner class ReadAloudPhoneStateListener : PhoneStateListener() {
        override fun onCallStateChanged(state: Int, phoneNumber: String?) {
            super.onCallStateChanged(state, phoneNumber)
            when (state) {
                TelephonyManager.CALL_STATE_IDLE -> {
                    if (needResumeOnCallStateIdle) {
                        AppLog.put(""来电结束,继续朗读"")
                        resumeReadAloud()
                    } else {
                        AppLog.put(""来电结束"")
                    }
                }

                TelephonyManager.CALL_STATE_RINGING -> {
                    if (!pause) {
                        AppLog.put(""来电响铃,暂停朗读"")
                        needResumeOnCallStateIdle = true
                        pauseReadAloud()
                    } else {
                        AppLog.put(""来电响铃"")
                    }
                }

                TelephonyManager.CALL_STATE_OFFHOOK -> {
                    AppLog.put(""来电接听,不做处理"")
                }
            }
        }
    }

}
",KOT_00401,CWE-321: Hard-coded Cryptographic Key,A02: Cryptographic Failures;A04: Insecure Design,1
thunderbird__thunderbird-android,103ef9ba74679c6e8a84c80aa7f9c9809ff84fcc,feature/navigation/drawer/dropdown/src/test/kotlin/net/thunderbird/feature/navigation/drawer/dropdown/domain/usecase/GetDisplayFoldersForAccountTest.kt,.kt,Rafael Tonholo,rafael@tonholo.dev,2025-09-05T10:03:36-03:00,Merge pull request #9710 from rafaeltonholo/fix/9691/subfolder-hardcoded-path-separator,1,GetDisplayFoldersForAccountTest,"internal class GetDisplayFoldersForAccountTest {

    @Test
    fun `should return account folders when account id is regular`() = runTest {
        val accountId = ACCOUNT_ID_RAW
        val legacyDisplayFolderFlow = MutableStateFlow(LEGACY_DISPLAY_FOLDERS)
        val displayFolderRepository = FakeDisplayFolderRepository(legacyDisplayFolderFlow)
        val unifiedFolderFlow = MutableStateFlow(DISPLAY_UNIFIED_FOLDER)
        val unifiedFolderRepository = FakeUnifiedFolderRepository(unifiedFolderFlow)
        val testSubject = GetDisplayFoldersForAccount(
            displayFolderRepository = displayFolderRepository,
            unifiedFolderRepository = unifiedFolderRepository,
        )

        val result = testSubject(accountId).first()

        assertThat(result).isEqualTo(DISPLAY_ACCOUNT_FOLDERS)
    }

    @Test
    fun `should return unifed account folders when account id is unified`() = runTest {
        val accountId = UnifiedDisplayAccount.UNIFIED_ACCOUNT_ID
        val legacyDisplayFolderFlow = MutableStateFlow(LEGACY_DISPLAY_FOLDERS)
        val displayFolderRepository = FakeDisplayFolderRepository(legacyDisplayFolderFlow)
        val unifiedFolderFlow = MutableStateFlow(DISPLAY_UNIFIED_FOLDER)
        val unifiedFolderRepository = FakeUnifiedFolderRepository(unifiedFolderFlow)
        val testSubject = GetDisplayFoldersForAccount(
            displayFolderRepository = displayFolderRepository,
            unifiedFolderRepository = unifiedFolderRepository,
        )

        val result = testSubject(accountId).first()

        assertThat(result).isEqualTo(DISPLAY_UNIFIED_FOLDERS)
    }

    @Test
    fun `should only emit new list when account folders emit new items`() = runTest {
        val accountId = ACCOUNT_ID_RAW
        val legacyDisplayFolderFlow = MutableStateFlow(LEGACY_DISPLAY_FOLDERS)
        val displayFolderRepository = FakeDisplayFolderRepository(legacyDisplayFolderFlow)
        val unifiedFolderFlow = MutableStateFlow(DISPLAY_UNIFIED_FOLDER)
        val unifiedFolderRepository = FakeUnifiedFolderRepository(unifiedFolderFlow)
        val testSubject = GetDisplayFoldersForAccount(
            displayFolderRepository = displayFolderRepository,
            unifiedFolderRepository = unifiedFolderRepository,
        )

        testSubject(accountId).test {
            assertThat(awaitItem()).isEqualTo(DISPLAY_ACCOUNT_FOLDERS)

            legacyDisplayFolderFlow.emit(LEGACY_DISPLAY_FOLDERS_2)

            assertThat(awaitItem()).isEqualTo(DISPLAY_ACCOUNT_FOLDERS_2)

            unifiedFolderFlow.emit(DISPLAY_UNIFIED_FOLDER_2)
        }
    }

    @Test
    fun `should only emit new list when unified account folders emit new items`() = runTest {
        val accountId = UnifiedDisplayAccount.UNIFIED_ACCOUNT_ID
        val legacyDisplayFolderFlow = MutableStateFlow(LEGACY_DISPLAY_FOLDERS)
        val displayFolderRepository = FakeDisplayFolderRepository(legacyDisplayFolderFlow)
        val unifiedFolderFlow = MutableStateFlow(DISPLAY_UNIFIED_FOLDER)
        val unifiedFolderRepository = FakeUnifiedFolderRepository(unifiedFolderFlow)
        val testSubject = GetDisplayFoldersForAccount(
            displayFolderRepository = displayFolderRepository,
            unifiedFolderRepository = unifiedFolderRepository,
        )

        testSubject(accountId).test {
            assertThat(awaitItem()).isEqualTo(DISPLAY_UNIFIED_FOLDERS)

            legacyDisplayFolderFlow.emit(LEGACY_DISPLAY_FOLDERS_2)
            unifiedFolderFlow.emit(DISPLAY_UNIFIED_FOLDER_2)

            assertThat(awaitItem()).isEqualTo(listOf(DISPLAY_UNIFIED_FOLDER_2))
        }
    }

    private companion object {
        val LEGACY_DISPLAY_FOLDERS = listOf(
            LegacyDisplayFolder(
                folder = FakeData.FOLDER,
                isInTopGroup = false,
                unreadMessageCount = 0,
                starredMessageCount = 0,
                pathDelimiter = ""/"",
            ),
            LegacyDisplayFolder(
                folder = FakeData.FOLDER.copy(
                    id = 2,
                    name = ""Folder 2"",
                ),
                isInTopGroup = false,
                unreadMessageCount = 1,
                starredMessageCount = 0,
                pathDelimiter = ""/"",
            ),
        )

        val LEGACY_DISPLAY_FOLDERS_2 = LEGACY_DISPLAY_FOLDERS + LegacyDisplayFolder(
            folder = FakeData.FOLDER.copy(
                id = 3,
                name = ""Folder 3"",
            ),
            isInTopGroup = false,
            unreadMessageCount = 0,
            starredMessageCount = 0,
            pathDelimiter = ""/"",
        )

        val DISPLAY_UNIFIED_FOLDER = UnifiedDisplayFolder(
            id = ""unified_inbox"",
            unifiedType = UnifiedDisplayFolderType.INBOX,
            unreadMessageCount = 2,
            starredMessageCount = 2,
        )

        val DISPLAY_UNIFIED_FOLDER_2 = UnifiedDisplayFolder(
            id = ""unified_inbox"",
            unifiedType = UnifiedDisplayFolderType.INBOX,
            unreadMessageCount = 3,
            starredMessageCount = 3,
        )

        val DISPLAY_UNIFIED_FOLDERS = listOf(DISPLAY_UNIFIED_FOLDER)

        val DISPLAY_ACCOUNT_FOLDERS = listOf<DisplayFolder>(
            MailDisplayFolder(
                accountId = ACCOUNT_ID_RAW,
                folder = FakeData.FOLDER,
                isInTopGroup = false,
                unreadMessageCount = 0,
                starredMessageCount = 0,
                pathDelimiter = ""/"",
            ),
            MailDisplayFolder(
                accountId = ACCOUNT_ID_RAW,
                folder = FakeData.FOLDER.copy(
                    id = 2,
                    name = ""Folder 2"",
                ),
                isInTopGroup = false,
                unreadMessageCount = 1,
                starredMessageCount = 0,
                pathDelimiter = ""/"",
            ),
        )

        val DISPLAY_ACCOUNT_FOLDERS_2 = DISPLAY_ACCOUNT_FOLDERS + MailDisplayFolder(
            accountId = ACCOUNT_ID_RAW,
            folder = FakeData.FOLDER.copy(
                id = 3,
                name = ""Folder 3"",
            ),
            isInTopGroup = false,
            unreadMessageCount = 0,
            starredMessageCount = 0,
            pathDelimiter = ""/"",
        )
    }
}",KSEC_1233,,,0
duckduckgo__Android,b5485b4ce45c5bc76f091c63578c3ce8a8e569e5,app/src/androidTest/java/com/duckduckgo/app/trackerdetection/TrackerDetectorListTest.kt,.kt,Craig Russell,CDRussell@users.noreply.github.com,2018-12-13T15:17:21+00:00,Feature/automatically clear data options (#405),1,,"/*
 * Copyright (c) 2017 DuckDuckGo
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.duckduckgo.app.trackerdetection


import com.duckduckgo.app.privacy.store.PrivacySettingsStore
import com.duckduckgo.app.trackerdetection.Client.ClientName.*
import com.duckduckgo.app.trackerdetection.model.ResourceType
import com.duckduckgo.app.trackerdetection.model.TrackerNetworks
import com.duckduckgo.app.trackerdetection.model.TrackingEvent
import com.nhaarman.mockito_kotlin.mock
import com.nhaarman.mockito_kotlin.whenever
import org.junit.Assert.assertEquals
import org.junit.Assert.assertNull
import org.junit.Before
import org.junit.Test


class TrackerDetectorListTest {

    companion object {
        private const val documentUrl = ""http://example.com""
        private val resourceType = ResourceType.UNKNOWN
    }

    private lateinit var mockTrackerNetworks: TrackerNetworks
    private lateinit var blockingOnlyTestee: TrackerDetector
    private lateinit var testeeWithWhitelist: TrackerDetector
    private lateinit var settingStore: PrivacySettingsStore


    @Before
    fun before() {
        val easylistAdblock = adblockClient(EASYLIST, ""binary/easylist_sample"")
        val easyprivacyAdblock = adblockClient(EASYPRIVACY, ""binary/easyprivacy_sample"")

        // re-using blocking sample as a whitelist to hammer the point home
        val trackersWhitelistAdblocks = adblockClient(TRACKERSWHITELIST, ""binary/easylist_sample"")

        settingStore = mock()
        mockTrackerNetworks = mock()

        whenever(settingStore.privacyOn).thenReturn(true)

        blockingOnlyTestee = TrackerDetectorImpl(mockTrackerNetworks, settingStore)
        blockingOnlyTestee.addClient(easyprivacyAdblock)
        blockingOnlyTestee.addClient(easylistAdblock)

        testeeWithWhitelist = TrackerDetectorImpl(mockTrackerNetworks, settingStore)
        testeeWithWhitelist.addClient(trackersWhitelistAdblocks)
        testeeWithWhitelist.addClient(easyprivacyAdblock)
        testeeWithWhitelist.addClient(easylistAdblock)
    }

    @Test
    fun whenUrlIsInWhitelistThenEvaluateReturnsNull() {
        val url = ""http://imasdk.googleapis.com/js/sdkloader/ima3.js""
        assertNull(testeeWithWhitelist.evaluate(url, documentUrl, resourceType))
    }

    @Test
    fun whenUrlIsInEasyListThenEvaluateReturnsTrackingEvent() {
        val url = ""http://imasdk.googleapis.com/js/sdkloader/ima3.js""
        val expected = TrackingEvent(documentUrl, url, null, true)
        assertEquals(expected, blockingOnlyTestee.evaluate(url, documentUrl, resourceType))
    }

    @Test
    fun whenUrlIsInEasyPrivacyListThenEvaluateReturnsTrackingEvent() {
        val url = ""http://cdn.tagcommander.com/1705/tc_catalog.css""
        val expected = TrackingEvent(documentUrl, url, null, true)
        assertEquals(expected, blockingOnlyTestee.evaluate(url, documentUrl, resourceType))
    }

    @Test
    fun whenUrlIsNotInAnyTrackerListsThenEvaluateReturnsNull() {
        val url = ""https://duckduckgo.com/index.html""
        assertNull(blockingOnlyTestee.evaluate(url, documentUrl, resourceType))
    }

    private fun adblockClient(name: Client.ClientName, dataFile: String): Client {
        val data = javaClass.classLoader!!.getResource(dataFile).readBytes()
        val initialAdBlock = AdBlockClient(name)
        initialAdBlock.loadBasicData(data)
        val adblockWithProcessedData = AdBlockClient(name)
        adblockWithProcessedData.loadProcessedData(initialAdBlock.getProcessedData())
        return adblockWithProcessedData
    }

}",KSEC_6243,['CWE-319: Cleartext Transmission of Sensitive Information'];['CWE-321: Hard-coded Cryptographic Key'],"['A02: Cryptographic Failures', 'A04: Insecure Design'];['A02: Cryptographic Failures']",1
JetBrains__kotlin,8bf77c20b046052d20644430b71e94126e0b5b51,compiler/testData/codegen/box/properties/backingField/charSequenceWithBackingField5.kt,.kt,Vladimir Sukharev,Vladimir.Sukharev@jetbrains.com,2025-10-29T14:04:16+01:00,fixup! [JS][Tests] Fix forward compatibility tests,1,,"// LANGUAGE: +ExplicitBackingFields
// TARGET_BACKEND: JVM_IR
// TARGET_BACKEND: JS_IR
// TARGET_BACKEND: JS_IR_ES6
// TARGET_BACKEND: WASM
// IGNORE_BACKEND_K1: JVM_IR, JS_IR, JS_IR_ES6, WASM

open class Base {
    open val x: CharSequence = ""BASE""
         // field = ""BASE""
}

class Ok : Base() {
    override val x: CharSequence
        @Suppress(""WRONG_MODIFIER_TARGET"", ""NON_FINAL_PROPERTY_WITH_EXPLICIT_BACKING_FIELD"")
        internal field: String = ""OK""
}

fun box(): String {
    return Ok().x
}
",KOT_01351,CWE-321: Hard-coded Cryptographic Key,A02: Cryptographic Failures;A04: Insecure Design,1
duckduckgo__Android,4d47ef5abceb92f59ce8f5c60100a5c470b08379,app/src/main/java/com/duckduckgo/app/browser/session/WebViewSessionStorage.kt,.kt,Aitor Viana,aitorvs@gmail.com,2021-04-30T11:32:44+02:00,Bump the compile SDK to 30 (#1209),1,WebViewSessionInMemoryStorage,"class WebViewSessionInMemoryStorage : WebViewSessionStorage {

    private val cache = object : LruCache<String, Bundle>(CACHE_SIZE_BYTES) {

        /**
         * Size (in bytes) of a single entry in the cache for the given key.
         * We specify the max cache size in bytes, so we need to calculate an approximate size of the cache entry in bytes.
         */
        override fun sizeOf(key: String, bundle: Bundle) = bundle.sizeInBytes()

        override fun entryRemoved(evicted: Boolean, key: String?, oldValue: Bundle?, newValue: Bundle?) {
            if (evicted) {
                Timber.v(""Evicted $key from WebView session storage"")
            }
        }
    }

    override fun saveSession(webView: WebView?, tabId: String) {
        if (webView == null) {
            Timber.w(""WebView is null; cannot save session"")
            return
        }

        Timber.i(""Saving WebView session for $tabId"")

        val webViewBundle = createWebViewBundle(webView)

        val bundle = Bundle()
        bundle.putBundle(CACHE_KEY_WEBVIEW, webViewBundle)
        bundle.putInt(CACHE_KEY_SCROLL_POSITION, webView.scrollY)
        cache.put(tabId, bundle)

        Timber.d(""Stored ${bundle.sizeInBytes()} bytes for WebView $webView"")
        logCacheSize()
    }

    private fun createWebViewBundle(webView: WebView): Bundle {
        return Bundle().also {
            webView.saveState(it)
        }
    }

    override fun restoreSession(webView: WebView?, tabId: String): Boolean {
        if (webView == null) {
            Timber.w(""WebView is null; cannot restore session"")
            return false
        }

        Timber.i(""Restoring WebView session for $tabId"")

        val bundle = cache[tabId]
        if (bundle == null) {
            Timber.v(""No saved bundle for tab $tabId"")
            return false
        }

        val webViewBundle = bundle.getBundle(CACHE_KEY_WEBVIEW)
        webView.restoreState(webViewBundle)
        webView.scrollY = bundle.getInt(CACHE_KEY_SCROLL_POSITION)
        cache.remove(tabId)

        logCacheSize()

        return true
    }

    override fun deleteSession(tabId: String) {
        cache.remove(tabId)
        Timber.i(""Deleted web session for $tabId"")
        logCacheSize()
    }

    override fun deleteAllSessions() {
        cache.evictAll()
        logCacheSize()
    }

    private fun logCacheSize() {
        Timber.v(""Cache size is now ~${cache.size()} bytes out of a max size of ${cache.maxSize()} bytes"")
    }

    private fun Bundle.sizeInBytes(): Int {
        val parcel = Parcel.obtain()
        parcel.writeValue(this)

        val bytes = parcel.marshall()
        parcel.recycle()

        return bytes.size
    }

    companion object {
        private const val CACHE_SIZE_BYTES = 10 * 1024 * 1024 // 10 MiB

        private const val CACHE_KEY_WEBVIEW = ""webview""
        private const val CACHE_KEY_SCROLL_POSITION = ""scroll-position""

    }

}",KSEC_5870,['CWE-321: Hard-coded Cryptographic Key'],"['A02: Cryptographic Failures', 'A04: Insecure Design']",1
JetBrains__kotlin,98b34a3618aa98ef4eaa33b0e1c55a8b2666b294,compiler/testData/codegen/box/coroutines/tailCallOptimizations/wrapContinuation/locals.kt,.kt,Ilmir Usmanov,ilmir.usmanov@jetbrains.com,2025-10-30T00:41:29+01:00,Minor. Ignore tests on Android until KT-66761 is fixed,1,,"// TARGET_BACKEND: JVM
// FULL_JDK
// WITH_STDLIB
// WITH_COROUTINES
// CHECK_TAIL_CALL_OPTIMIZATION
// API_VERSION: LATEST

// Using internal ModuleNameRetriever in stdlib replacement
// DISABLE_IR_VISIBILITY_CHECKS: JVM_IR
// PREFER_IN_TEST_OVER_STDLIB

// FILE: TailCallAsyncStackTraceEntry.kt

package kotlin.coroutines.jvm.internal

import kotlin.coroutines.*

@Suppress(""INVISIBLE_REFERENCE"", ""INVISIBLE_MEMBER"")
internal fun <T> wrapContinuation(
    declaringClass: String, methodName: String, fileName: String, lineNumber: Int,
    spilledVariables: Array<Any?>,
    continuation: T,
): T where T : Continuation<Any?>, T : CoroutineStackFrame {
    return TailCallBaseContinuationImpl(
        declaringClass, methodName, fileName, lineNumber, spilledVariables, continuation
    ) as T
}

// FILE: test.kt
@file:Suppress(""INVISIBLE_MEMBER"", ""INVISIBLE_REFERENCE"")

import helpers.*
import kotlin.coroutines.*
import kotlin.coroutines.intrinsics.*
import kotlin.coroutines.jvm.internal.*

private suspend fun foo(): Int {
    suspendThere()
    //Breakpoint!
    return 42
}

suspend fun first(): Int { // tail-call opt, no state machine, wrapContinuation is invoked
    val i = 0
    val a = ""OK""
    return foo()
}

var c: Continuation<Any?>? = null

suspend fun suspendThere(): Any? = suspendCoroutineUninterceptedOrReturn { x ->
    c = x
    TailCallOptimizationChecker.saveStackTrace(x)
    COROUTINE_SUSPENDED
}

fun builder(c: suspend () -> Unit) {
    c.startCoroutine(Continuation(EmptyCoroutineContext) {
        it.getOrThrow()
    })
}

fun box(): String {
    builder {
        first()
    }
    TailCallOptimizationChecker.checkStateMachineIn(""first"")

    var firstHit = false

    while (c != null) {
        val cc = c
        if (cc is TailCallBaseContinuationImpl && cc.methodName == ""first"") {
            firstHit = true
            if (cc.spilledVariables[0] != ""i"") return ""FAIL 0 ${cc.spilledVariables[0]}""
            if (cc.spilledVariables[1] != 0) return ""FAIL 1 ${cc.spilledVariables[1]}""
            if (cc.spilledVariables[2] != ""a"") return ""FAIL 2 ${cc.spilledVariables[2]}""
            if (cc.spilledVariables[3] != ""OK"") return ""FAIL 3 ${cc.spilledVariables[3]}""
        }
        c = (c as? BaseContinuationImpl)?.completion
    }

    if (!firstHit) return ""FAIL 4 'first' is not present in completion chain""

    return ""OK""
}
",KOT_01197,CWE-321: Hard-coded Cryptographic Key,A02: Cryptographic Failures;A04: Insecure Design,1
thunderbird__thunderbird-android,4ca78c9ebc94cb746d9fcac0564353e56302bd9e,legacy/core/src/main/java/com/fsck/k9/notification/NotificationStoreProvider.kt,.kt,Wolf-Martell Montwé,wolf@thunderbird.net,2025-09-08T15:18:57+02:00,refactor: rename LegacyAccount to LegacyAccountDto,1,,"package com.fsck.k9.notification

import net.thunderbird.core.android.account.LegacyAccountDto

interface NotificationStoreProvider {
    fun getNotificationStore(account: LegacyAccountDto): NotificationStore
}
",KSEC_1324,,,0
duckduckgo__Android,0b66bf4fc07bc37a8e47c7ce9389cda381cb4dd6,app/src/androidTest/java/com/duckduckgo/app/browser/logindetection/NextPageLoginDetectionTest.kt,.kt,Josh Leibstein,joshliebe@gmail.com,2021-05-27T16:55:48+02:00,Replace GlobalScope with AppCoroutineScope (#1251),1,NextPageLoginDetectionTest,"class NextPageLoginDetectionTest {

    @get:Rule
    var coroutineRule = CoroutineTestRule()

    @get:Rule
    @Suppress(""unused"")
    var instantTaskExecutorRule = InstantTaskExecutorRule()

    private val mockSettingsDataStore: SettingsDataStore = mock()
    private val loginDetector = NextPageLoginDetection(mockSettingsDataStore)

    private val loginObserver = mock<Observer<LoginDetected>>()
    private val loginEventCaptor = argumentCaptor<LoginDetected>()

    @Before
    fun setup() {
        loginDetector.loginEventLiveData.observeForever(loginObserver)
    }

    @Test
    fun whenLoginAttemptedAndUserForwardedToNewPageThenLoginDetected() = coroutineRule.runBlocking {
        givenLoginDetector(enabled = true)
        loginDetector.onEvent(NavigationEvent.LoginAttempt(""http://example.com/login""))

        redirectTo(""http://example.com"")
        giveLoginDetectorChanceToExecute()

        assertEvent<LoginDetected>()
    }

    @Test
    fun whenLoginAttemptedInsideOAuthFlowThenLoginDetectedWhenUserForwardedToDifferentDomain() = coroutineRule.runBlocking {
        givenLoginDetector(enabled = true)
        redirectTo(""https://accounts.google.com/o/oauth2/v2/auth"")
        giveLoginDetectorChanceToExecute()
        redirectTo(""https://accounts.google.com/signin/v2/challenge/pwd"")
        giveLoginDetectorChanceToExecute()
        loginDetector.onEvent(NavigationEvent.LoginAttempt(""https://accounts.google.com/signin/v2/challenge""))
        redirectTo(""https://accounts.google.com/signin/v2/challenge/az?client_id"")
        giveLoginDetectorChanceToExecute()
        redirectTo(""https://accounts.google.com/randomPath"")
        giveLoginDetectorChanceToExecute()
        redirectTo(""http://example.com"")
        giveLoginDetectorChanceToExecute()

        assertEvent<LoginDetected> {
            assertEquals(""example.com"", this.forwardedToDomain)
        }
    }

    @Test
    fun whenLoginAttemptedInsideSSOFlowThenLoginDetectedWhenUserForwardedToDifferentDomain() = coroutineRule.runBlocking {
        givenLoginDetector(enabled = true)
        fullyLoadSite(""https://app.asana.com/-/login"")
        giveLoginDetectorChanceToExecute()
        redirectTo(""https://sso.host.com/saml2/idp/SSOService.php"")
        giveLoginDetectorChanceToExecute()
        fullyLoadSite(""https://sso.host.com/module.php/core/loginuserpass.php"")
        giveLoginDetectorChanceToExecute()
        loginDetector.onEvent(NavigationEvent.LoginAttempt(""https://sso.host.com/module.php/core/loginuserpass.php""))
        redirectTo(""https://sso.host.com/module.php/duosecurity/getduo.php"")
        giveLoginDetectorChanceToExecute()
        redirectTo(""https://app.asana.com/"")
        giveLoginDetectorChanceToExecute()

        assertEvent<LoginDetected> {
            assertEquals(""app.asana.com"", this.forwardedToDomain)
        }
    }

    @Test
    fun whenLoginAttemptedSkip2FAUrlsThenLoginDetectedForLatestOne() = coroutineRule.runBlocking {
        givenLoginDetector(enabled = true)
        fullyLoadSite(""https://accounts.google.com/ServiceLogin"")
        giveLoginDetectorChanceToExecute()
        fullyLoadSite(""https://accounts.google.com/signin/v2/challenge/pwd"")
        giveLoginDetectorChanceToExecute()
        loginDetector.onEvent(NavigationEvent.LoginAttempt(""https://accounts.google.com/signin/v2/challenge/pwd""))
        redirectTo(""https://accounts.google.com/signin/v2/challenge/az"")
        giveLoginDetectorChanceToExecute()
        redirectTo(""https://mail.google.com/mail"")
        giveLoginDetectorChanceToExecute()

        assertEvent<LoginDetected> {
            assertEquals(""mail.google.com"", this.forwardedToDomain)
        }
    }

    @Test
    fun whenLoginAttemptedAndUserForwardedToMultipleNewPagesThenLoginDetectedForLatestOne() = coroutineRule.runBlocking {
        givenLoginDetector(enabled = true)
        loginDetector.onEvent(NavigationEvent.LoginAttempt(""http://example.com/login""))

        fullyLoadSite(""http://example.com"")
        fullyLoadSite(""http://example2.com"")
        fullyLoadSite(""http://example3.com"")
        giveLoginDetectorChanceToExecute()

        assertEvent<LoginDetected> {
            assertEquals(""example3.com"", this.forwardedToDomain)
        }
    }

    @Test
    fun whenLoginAttemptedAndUserForwardedToSamePageThenLoginNotDetected() = coroutineRule.runBlocking {
        givenLoginDetector(enabled = true)
        loginDetector.onEvent(NavigationEvent.LoginAttempt(""http://example.com/login""))

        fullyLoadSite(""http://example.com/login"")
        giveLoginDetectorChanceToExecute()

        assertEventNotIssued<LoginDetected>()
    }

    @Test
    fun whenNotDetectedLoginAttemptAndForwardedToNewPageThenLoginNotDetected() = coroutineRule.runBlocking {
        givenLoginDetector(enabled = true)
        fullyLoadSite(""http://example.com"")
        giveLoginDetectorChanceToExecute()

        assertEventNotIssued<LoginDetected>()
    }

    @Test
    fun whenLoginAttemptedAndUserForwardedToNewUrlThenLoginDetected() = coroutineRule.runBlocking {
        givenLoginDetector(enabled = true)
        loginDetector.onEvent(NavigationEvent.LoginAttempt(""http://example.com/login""))

        loginDetector.onEvent(NavigationEvent.WebNavigationEvent(WebNavigationStateChange.UrlUpdated(url = ""http://example.com"")))
        loginDetector.onEvent(NavigationEvent.PageFinished)
        giveLoginDetectorChanceToExecute()

        assertEvent<LoginDetected>()
    }

    @Test
    fun whenLoginAttemptedAndUserForwardedToSameUrlThenLoginNotDetected() = coroutineRule.runBlocking {
        givenLoginDetector(enabled = true)
        loginDetector.onEvent(NavigationEvent.LoginAttempt(""http://example.com/login""))

        loginDetector.onEvent(NavigationEvent.WebNavigationEvent(WebNavigationStateChange.UrlUpdated(url = ""http://example.com/login"")))
        loginDetector.onEvent(NavigationEvent.PageFinished)
        giveLoginDetectorChanceToExecute()

        assertEventNotIssued<LoginDetected>()
    }

    @Test
    fun whenNotDetectedLoginAttemptAndForwardedToNewUrlThenLoginNotDetected() = coroutineRule.runBlocking {
        givenLoginDetector(enabled = true)
        loginDetector.onEvent(NavigationEvent.WebNavigationEvent(WebNavigationStateChange.UrlUpdated(url = ""http://example.com"")))
        loginDetector.onEvent(NavigationEvent.PageFinished)
        giveLoginDetectorChanceToExecute()

        assertEventNotIssued<LoginDetected>()
    }

    @Test
    fun whenLoginAttemptedAndNextPageFinishedThenLoadingNewPageDoesNotDetectLogin() = coroutineRule.runBlocking {
        givenLoginDetector(enabled = true)
        loginDetector.onEvent(NavigationEvent.LoginAttempt(""http://example.com/login""))
        loginDetector.onEvent(NavigationEvent.PageFinished)

        loginDetector.onEvent(NavigationEvent.WebNavigationEvent(NewPage(url = ""http://another.example.com"", title = """")))
        loginDetector.onEvent(NavigationEvent.PageFinished)
        giveLoginDetectorChanceToExecute()

        assertEventNotIssued<LoginDetected>()
    }

    @Test
    fun whenLoginAttemptedAndUserNavigatesBackThenNewPageDoesNotDetectLogin() = coroutineRule.runBlocking {
        givenLoginDetector(enabled = true)
        loginDetector.onEvent(NavigationEvent.LoginAttempt(""http://example.com/login""))
        loginDetector.onEvent(NavigationEvent.UserAction.NavigateBack)

        fullyLoadSite(""http://another.example.com"")
        giveLoginDetectorChanceToExecute()

        assertEventNotIssued<LoginDetected>()
    }

    @Test
    fun whenLoginAttemptedAndUserNavigatesForwardThenNewPageDoesNotDetectLogin() = coroutineRule.runBlocking {
        givenLoginDetector(enabled = true)
        loginDetector.onEvent(NavigationEvent.LoginAttempt(""http://example.com/login""))
        loginDetector.onEvent(NavigationEvent.UserAction.NavigateForward)

        fullyLoadSite(""http://another.example.com"")
        giveLoginDetectorChanceToExecute()

        assertEventNotIssued<LoginDetected>()
    }

    @Test
    fun whenLoginAttemptedAndUserReloadsWebsiteThenNewPageDoesNotDetectLogin() = coroutineRule.runBlocking {
        givenLoginDetector(enabled = true)
        loginDetector.onEvent(NavigationEvent.LoginAttempt(""http://example.com/login""))
        loginDetector.onEvent(NavigationEvent.UserAction.Refresh)

        fullyLoadSite(""http://another.example.com"")
        giveLoginDetectorChanceToExecute()

        assertEventNotIssued<LoginDetected>()
    }

    @Test
    fun whenLoginAttemptedAndUserSubmitsNewQueryThenNewPageDoesNotDetectLogin() = coroutineRule.runBlocking {
        givenLoginDetector(enabled = true)
        loginDetector.onEvent(NavigationEvent.LoginAttempt(""http://example.com/login""))
        loginDetector.onEvent(NavigationEvent.UserAction.NewQuerySubmitted)

        fullyLoadSite(""http://another.example.com"")
        giveLoginDetectorChanceToExecute()

        assertEventNotIssued<LoginDetected>()
    }

    @Test
    fun whenLoginAttemptedHasInvalidURLThenNewPageDoesNotDetectLogin() = coroutineRule.runBlocking {
        givenLoginDetector(enabled = true)
        loginDetector.onEvent(NavigationEvent.LoginAttempt(""""))

        fullyLoadSite(""http://example.com"")
        giveLoginDetectorChanceToExecute()

        assertEventNotIssued<LoginDetected>()
    }

    @Test
    fun whenLoginAttemptedAndUserForwardedToInvalidNewPageThenLoginDetected() = coroutineRule.runBlocking {
        givenLoginDetector(enabled = true)
        loginDetector.onEvent(NavigationEvent.LoginAttempt(""http://example.com/login""))

        fullyLoadSite("""")
        giveLoginDetectorChanceToExecute()

        assertEventNotIssued<LoginDetected>()
    }

    private suspend fun giveLoginDetectorChanceToExecute() {
        delay(LOGIN_DETECTOR_JOB_DELAY)
    }

    private inline fun <reified T> assertEvent(instanceAssertions: T.() -> Unit = {}) {
        verify(loginObserver, atLeastOnce()).onChanged(loginEventCaptor.capture())
        val issuedCommand = loginEventCaptor.allValues.find { it is T }
        assertNotNull(issuedCommand)
        (issuedCommand as T).apply { instanceAssertions() }
    }

    private inline fun <reified T> assertEventNotIssued() {
        val issuedCommand = loginEventCaptor.allValues.find { it is T }
        assertNull(issuedCommand)
    }

    private fun fullyLoadSite(url: String) {
        loginDetector.onEvent(NavigationEvent.WebNavigationEvent(NewPage(url = url, title = """")))
        loginDetector.onEvent(NavigationEvent.PageFinished)
    }

    private fun redirectTo(url: String) {
        loginDetector.onEvent(NavigationEvent.Redirect(url = url))
        loginDetector.onEvent(NavigationEvent.WebNavigationEvent(NewPage(url = url, title = """")))
        loginDetector.onEvent(NavigationEvent.PageFinished)
    }

    private fun givenLoginDetector(enabled: Boolean) {
        whenever(mockSettingsDataStore.appLoginDetection).thenReturn(enabled)
    }

    companion object {
        const val LOGIN_DETECTOR_JOB_DELAY = 1000L
    }
}",KSEC_5861,['CWE-319: Cleartext Transmission of Sensitive Information'],['A02: Cryptographic Failures'],1
square__okhttp,733a58a247d734eb17bf600e43048eb9b6be3dd3,okhttp/src/test/java/okhttp3/EventListenerTest.java,.java,monkey-mas,monkey-mas@users.noreply.github.com,2020-02-19T23:17:13-05:00,Refactor OkHttpClient#xxxTimeout(...) to fix errorprone PreferJavaTimeOverload in tests (#5797),1,EventListenerTest,"public final class EventListenerTest {
  public static final Matcher<Response> anyResponse = CoreMatchers.any(Response.class);

  @Rule public final PlatformRule platform = new PlatformRule();
  @Rule public final MockWebServer server = new MockWebServer();
  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
  @Rule public final Timeout timeoutRule = new Timeout(20, TimeUnit.SECONDS);

  private final RecordingEventListener listener = new RecordingEventListener();
  private final HandshakeCertificates handshakeCertificates = localhost();

  private OkHttpClient client = clientTestRule.newClientBuilder()
      .eventListenerFactory(clientTestRule.wrap(listener))
      .build();
  private SocksProxy socksProxy;

  @Before public void setUp() {
    platform.assumeNotOpenJSSE();

    listener.forbidLock(RealConnectionPool.Companion.get(client.connectionPool()));
    listener.forbidLock(client.dispatcher());
  }

  @After public void tearDown() throws Exception {
    if (socksProxy != null) {
      socksProxy.shutdown();
    }
  }

  @Test public void successfulCallEventSequence() throws IOException {
    server.enqueue(new MockResponse()
        .setBody(""abc""));

    Call call = client.newCall(new Request.Builder()
        .url(server.url(""/""))
        .build());
    Response response = call.execute();
    assertThat(response.code()).isEqualTo(200);
    assertThat(response.body().string()).isEqualTo(""abc"");
    response.body().close();

    assertThat(listener.recordedEventTypes()).containsExactly(""CallStart"",
        ""ProxySelectStart"", ""ProxySelectEnd"", ""DnsStart"", ""DnsEnd"",
        ""ConnectStart"", ""ConnectEnd"", ""ConnectionAcquired"", ""RequestHeadersStart"",
        ""RequestHeadersEnd"", ""ResponseHeadersStart"", ""ResponseHeadersEnd"", ""ResponseBodyStart"",
        ""ResponseBodyEnd"", ""ConnectionReleased"", ""CallEnd"");
  }

  @Test public void successfulCallEventSequenceForEnqueue() throws Exception {
    server.enqueue(new MockResponse()
        .setBody(""abc""));

    Call call = client.newCall(new Request.Builder()
        .url(server.url(""/""))
        .build());

    final CountDownLatch completionLatch = new CountDownLatch(1);
    Callback callback = new Callback() {
      @Override public void onFailure(Call call, IOException e) {
        completionLatch.countDown();
      }

      @Override public void onResponse(Call call, Response response) {
        response.close();
        completionLatch.countDown();
      }
    };

    call.enqueue(callback);

    completionLatch.await();

    assertThat(listener.recordedEventTypes()).containsExactly(""CallStart"",
        ""ProxySelectStart"", ""ProxySelectEnd"", ""DnsStart"", ""DnsEnd"",
        ""ConnectStart"", ""ConnectEnd"", ""ConnectionAcquired"", ""RequestHeadersStart"",
        ""RequestHeadersEnd"", ""ResponseHeadersStart"", ""ResponseHeadersEnd"", ""ResponseBodyStart"",
        ""ResponseBodyEnd"", ""ConnectionReleased"", ""CallEnd"");
  }

  @Test public void failedCallEventSequence() {
    server.enqueue(new MockResponse()
        .setHeadersDelay(2, TimeUnit.SECONDS));

    client = client.newBuilder()
        .readTimeout(250, TimeUnit.MILLISECONDS)
        .build();

    Call call = client.newCall(new Request.Builder()
        .url(server.url(""/""))
        .build());
    try {
      call.execute();
      fail();
    } catch (IOException expected) {
      assertThat(expected.getMessage()).isIn(""timeout"", ""Read timed out"");
    }

    assertThat(listener.recordedEventTypes()).containsExactly(""CallStart"",
        ""ProxySelectStart"", ""ProxySelectEnd"", ""DnsStart"", ""DnsEnd"",
        ""ConnectStart"", ""ConnectEnd"", ""ConnectionAcquired"", ""RequestHeadersStart"",
        ""RequestHeadersEnd"", ""ResponseFailed"", ""ConnectionReleased"", ""CallFailed"");
  }

  @Test public void failedDribbledCallEventSequence() throws IOException {
    server.enqueue(new MockResponse().setBody(""0123456789"")
        .throttleBody(2, 100, TimeUnit.MILLISECONDS)
        .setSocketPolicy(SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY));

    client = client.newBuilder()
        .protocols(Collections.singletonList(Protocol.HTTP_1_1))
        .readTimeout(250, TimeUnit.MILLISECONDS)
        .build();

    Call call = client.newCall(new Request.Builder()
        .url(server.url(""/""))
        .build());

    Response response = call.execute();
    try {
      response.body().string();
      fail();
    } catch (IOException expected) {
      assertThat(expected.getMessage()).isEqualTo(""unexpected end of stream"");
    }

    assertThat(listener.recordedEventTypes()).containsExactly(""CallStart"",
        ""ProxySelectStart"", ""ProxySelectEnd"", ""DnsStart"", ""DnsEnd"",
        ""ConnectStart"", ""ConnectEnd"", ""ConnectionAcquired"", ""RequestHeadersStart"",
        ""RequestHeadersEnd"", ""ResponseHeadersStart"", ""ResponseHeadersEnd"", ""ResponseBodyStart"",
        ""ResponseFailed"", ""ConnectionReleased"", ""CallFailed"");
    ResponseFailed responseFailed = listener.removeUpToEvent(ResponseFailed.class);
    assertThat(responseFailed.getIoe().getMessage()).isEqualTo(""unexpected end of stream"");
  }

  @Test public void canceledCallEventSequence() {
    Call call = client.newCall(new Request.Builder()
        .url(server.url(""/""))
        .build());
    call.cancel();
    try {
      call.execute();
      fail();
    } catch (IOException expected) {
      assertThat(expected.getMessage()).isEqualTo(""Canceled"");
    }

    assertThat(listener.recordedEventTypes()).containsExactly(
        ""Canceled"", ""CallStart"", ""CallFailed"");
  }

  @Test public void cancelAsyncCall() throws IOException {
    server.enqueue(new MockResponse()
        .setBody(""abc""));

    Call call = client.newCall(new Request.Builder()
        .url(server.url(""/""))
        .build());
    call.enqueue(new Callback() {
      @Override public void onFailure(Call call, IOException e) {
      }

      @Override public void onResponse(Call call, Response response) throws IOException {
        response.close();
      }
    });
    call.cancel();

    assertThat(listener.recordedEventTypes()).contains(""Canceled"");
  }

  @Test public void multipleCancelsEmitsOnlyOneEvent() throws IOException {
    server.enqueue(new MockResponse()
        .setBody(""abc""));

    Call call = client.newCall(new Request.Builder()
        .url(server.url(""/""))
        .build());
    call.cancel();
    call.cancel();

    assertThat(listener.recordedEventTypes()).containsExactly(""Canceled"");
  }

  private void assertSuccessfulEventOrder(Matcher<Response> responseMatcher) throws IOException {
    Call call = client.newCall(new Request.Builder()
        .url(server.url(""/""))
        .build());
    Response response = call.execute();
    assertThat(response.code()).isEqualTo(200);
    response.body().string();
    response.body().close();

    assumeThat(response, responseMatcher);

    assertThat(listener.recordedEventTypes()).containsExactly(
        ""CallStart"", ""ProxySelectStart"", ""ProxySelectEnd"",
        ""DnsStart"", ""DnsEnd"", ""ConnectStart"",
        ""SecureConnectStart"", ""SecureConnectEnd"", ""ConnectEnd"", ""ConnectionAcquired"",
        ""RequestHeadersStart"", ""RequestHeadersEnd"", ""ResponseHeadersStart"", ""ResponseHeadersEnd"",
        ""ResponseBodyStart"", ""ResponseBodyEnd"", ""ConnectionReleased"", ""CallEnd"");
  }

  @Test public void secondCallEventSequence() throws IOException {
    enableTlsWithTunnel(false);
    server.setProtocols(asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
    server.enqueue(new MockResponse());
    server.enqueue(new MockResponse());

    client.newCall(new Request.Builder()
        .url(server.url(""/""))
        .build()).execute().close();

    listener.removeUpToEvent(CallEnd.class);

    Call call = client.newCall(new Request.Builder()
        .url(server.url(""/""))
        .build());
    Response response = call.execute();
    response.close();

    assertThat(listener.recordedEventTypes()).containsExactly(""CallStart"", ""ConnectionAcquired"",
        ""RequestHeadersStart"", ""RequestHeadersEnd"", ""ResponseHeadersStart"", ""ResponseHeadersEnd"",
        ""ResponseBodyStart"", ""ResponseBodyEnd"", ""ConnectionReleased"", ""CallEnd"");
  }

  private void assertBytesReadWritten(RecordingEventListener listener,
      @Nullable Matcher<Long> requestHeaderLength, @Nullable Matcher<Long> requestBodyBytes,
      @Nullable Matcher<Long> responseHeaderLength, @Nullable Matcher<Long> responseBodyBytes) {

    if (requestHeaderLength != null) {
      RequestHeadersEnd responseHeadersEnd = listener.removeUpToEvent(RequestHeadersEnd.class);
      Assert.assertThat(""request header length"", responseHeadersEnd.getHeaderLength(),
          requestHeaderLength);
    } else {
      assertThat(listener.recordedEventTypes()).doesNotContain(""RequestHeadersEnd"");
    }

    if (requestBodyBytes != null) {
      RequestBodyEnd responseBodyEnd = listener.removeUpToEvent(RequestBodyEnd.class);
      Assert.assertThat(""request body bytes"", responseBodyEnd.getBytesWritten(), requestBodyBytes);
    } else {
      assertThat(listener.recordedEventTypes()).doesNotContain(""RequestBodyEnd"");
    }

    if (responseHeaderLength != null) {
      ResponseHeadersEnd responseHeadersEnd = listener.removeUpToEvent(ResponseHeadersEnd.class);
      Assert.assertThat(""response header length"", responseHeadersEnd.getHeaderLength(),
          responseHeaderLength);
    } else {
      assertThat(listener.recordedEventTypes()).doesNotContain(""ResponseHeadersEnd"");
    }

    if (responseBodyBytes != null) {
      ResponseBodyEnd responseBodyEnd = listener.removeUpToEvent(ResponseBodyEnd.class);
      Assert.assertThat(""response body bytes"", responseBodyEnd.getBytesRead(), responseBodyBytes);
    } else {
      assertThat(listener.recordedEventTypes()).doesNotContain(""ResponseBodyEnd"");
    }
  }

  private Matcher<Long> greaterThan(final long value) {
    return new BaseMatcher<Long>() {
      @Override public void describeTo(Description description) {
        description.appendText(""> "" + value);
      }

      @Override public boolean matches(Object o) {
        return ((Long) o) > value;
      }
    };
  }

  private Matcher<Response> matchesProtocol(final Protocol protocol) {
    return new BaseMatcher<Response>() {
      @Override public void describeTo(Description description) {
        description.appendText(""is HTTP/2"");
      }

      @Override public boolean matches(Object o) {
        return ((Response) o).protocol() == protocol;
      }
    };
  }

  @Test public void successfulEmptyH2CallEventSequence() throws IOException {
    enableTlsWithTunnel(false);
    server.setProtocols(asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
    server.enqueue(new MockResponse());

    assertSuccessfulEventOrder(matchesProtocol(Protocol.HTTP_2));

    assertBytesReadWritten(listener, any(Long.class), null, greaterThan(0L),
        equalTo(0L));
  }

  @Test public void successfulEmptyHttpsCallEventSequence() throws IOException {
    enableTlsWithTunnel(false);
    server.setProtocols(asList(Protocol.HTTP_1_1));
    server.enqueue(new MockResponse()
        .setBody(""abc""));

    assertSuccessfulEventOrder(anyResponse);

    assertBytesReadWritten(listener, any(Long.class), null, greaterThan(0L),
        equalTo(3L));
  }

  @Test public void successfulChunkedHttpsCallEventSequence() throws IOException {
    enableTlsWithTunnel(false);
    server.setProtocols(asList(Protocol.HTTP_1_1));
    server.enqueue(
        new MockResponse().setBodyDelay(100, TimeUnit.MILLISECONDS).setChunkedBody(""Hello!"", 2));

    assertSuccessfulEventOrder(anyResponse);

    assertBytesReadWritten(listener, any(Long.class), null, greaterThan(0L),
        equalTo(6L));
  }

  @Test public void successfulChunkedH2CallEventSequence() throws IOException {
    enableTlsWithTunnel(false);
    server.setProtocols(asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
    server.enqueue(
        new MockResponse().setBodyDelay(100, TimeUnit.MILLISECONDS).setChunkedBody(""Hello!"", 2));

    assertSuccessfulEventOrder(matchesProtocol(Protocol.HTTP_2));

    assertBytesReadWritten(listener, any(Long.class), null, equalTo(0L),
        greaterThan(6L));
  }

  @Test public void successfulDnsLookup() throws IOException {
    server.enqueue(new MockResponse());

    Call call = client.newCall(new Request.Builder()
        .url(server.url(""/""))
        .build());
    Response response = call.execute();
    assertThat(response.code()).isEqualTo(200);
    response.body().close();

    DnsStart dnsStart = listener.removeUpToEvent(DnsStart.class);
    assertThat(dnsStart.getCall()).isSameAs(call);
    assertThat(dnsStart.getDomainName()).isEqualTo(server.getHostName());

    DnsEnd dnsEnd = listener.removeUpToEvent(DnsEnd.class);
    assertThat(dnsEnd.getCall()).isSameAs(call);
    assertThat(dnsEnd.getDomainName()).isEqualTo(server.getHostName());
    assertThat(dnsEnd.getInetAddressList().size()).isEqualTo(1);
  }

  @Test public void noDnsLookupOnPooledConnection() throws IOException {
    server.enqueue(new MockResponse());
    server.enqueue(new MockResponse());

    // Seed the pool.
    Call call1 = client.newCall(new Request.Builder()
        .url(server.url(""/""))
        .build());
    Response response1 = call1.execute();
    assertThat(response1.code()).isEqualTo(200);
    response1.body().close();

    listener.clearAllEvents();

    Call call2 = client.newCall(new Request.Builder()
        .url(server.url(""/""))
        .build());
    Response response2 = call2.execute();
    assertThat(response2.code()).isEqualTo(200);
    response2.body().close();

    List<String> recordedEvents = listener.recordedEventTypes();
    assertThat(recordedEvents).doesNotContain(""DnsStart"");
    assertThat(recordedEvents).doesNotContain(""DnsEnd"");
  }

  @Test public void multipleDnsLookupsForSingleCall() throws IOException {
    server.enqueue(new MockResponse()
        .setResponseCode(301)
        .setHeader(""Location"", ""http://www.fakeurl:"" + server.getPort()));
    server.enqueue(new MockResponse());

    FakeDns dns = new FakeDns();
    dns.set(""fakeurl"", client.dns().lookup(server.getHostName()));
    dns.set(""www.fakeurl"", client.dns().lookup(server.getHostName()));

    client = client.newBuilder()
        .dns(dns)
        .build();

    Call call = client.newCall(new Request.Builder()
        .url(""http://fakeurl:"" + server.getPort())
        .build());
    Response response = call.execute();
    assertThat(response.code()).isEqualTo(200);
    response.body().close();

    listener.removeUpToEvent(DnsStart.class);
    listener.removeUpToEvent(DnsEnd.class);
    listener.removeUpToEvent(DnsStart.class);
    listener.removeUpToEvent(DnsEnd.class);
  }

  @Test public void failedDnsLookup() {
    client = client.newBuilder()
        .dns(new FakeDns())
        .build();
    Call call = client.newCall(new Request.Builder()
        .url(""http://fakeurl/"")
        .build());
    try {
      call.execute();
      fail();
    } catch (IOException expected) {
    }

    listener.removeUpToEvent(DnsStart.class);

    CallFailed callFailed = listener.removeUpToEvent(CallFailed.class);
    assertThat(callFailed.getCall()).isSameAs(call);
    assertThat(callFailed.getIoe()).isInstanceOf(UnknownHostException.class);
  }

  @Test public void emptyDnsLookup() {
    Dns emptyDns = hostname -> Collections.emptyList();

    client = client.newBuilder()
        .dns(emptyDns)
        .build();
    Call call = client.newCall(new Request.Builder()
        .url(""http://fakeurl/"")
        .build());
    try {
      call.execute();
      fail();
    } catch (IOException expected) {
    }

    listener.removeUpToEvent(DnsStart.class);

    CallFailed callFailed = listener.removeUpToEvent(CallFailed.class);
    assertThat(callFailed.getCall()).isSameAs(call);
    assertThat(callFailed.getIoe()).isInstanceOf(UnknownHostException.class);
  }

  @Test public void successfulConnect() throws IOException {
    server.enqueue(new MockResponse());

    Call call = client.newCall(new Request.Builder()
        .url(server.url(""/""))
        .build());
    Response response = call.execute();
    assertThat(response.code()).isEqualTo(200);
    response.body().close();

    InetAddress address = client.dns().lookup(server.getHostName()).get(0);
    InetSocketAddress expectedAddress = new InetSocketAddress(address, server.getPort());

    ConnectStart connectStart = listener.removeUpToEvent(ConnectStart.class);
    assertThat(connectStart.getCall()).isSameAs(call);
    assertThat(connectStart.getInetSocketAddress()).isEqualTo(expectedAddress);
    assertThat(connectStart.getProxy()).isEqualTo(Proxy.NO_PROXY);

    ConnectEnd connectEnd = listener.removeUpToEvent(ConnectEnd.class);
    assertThat(connectEnd.getCall()).isSameAs(call);
    assertThat(connectEnd.getInetSocketAddress()).isEqualTo(expectedAddress);
    assertThat(connectEnd.getProtocol()).isEqualTo(Protocol.HTTP_1_1);
  }

  @Test public void failedConnect() throws UnknownHostException {
    enableTlsWithTunnel(false);
    server.enqueue(new MockResponse()
        .setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));

    Call call = client.newCall(new Request.Builder()
        .url(server.url(""/""))
        .build());
    try {
      call.execute();
      fail();
    } catch (IOException expected) {
    }

    InetAddress address = client.dns().lookup(server.getHostName()).get(0);
    InetSocketAddress expectedAddress = new InetSocketAddress(address, server.getPort());

    ConnectStart connectStart = listener.removeUpToEvent(ConnectStart.class);
    assertThat(connectStart.getCall()).isSameAs(call);
    assertThat(connectStart.getInetSocketAddress()).isEqualTo(expectedAddress);
    assertThat(connectStart.getProxy()).isEqualTo(Proxy.NO_PROXY);

    ConnectFailed connectFailed = listener.removeUpToEvent(ConnectFailed.class);
    assertThat(connectFailed.getCall()).isSameAs(call);
    assertThat(connectFailed.getInetSocketAddress()).isEqualTo(expectedAddress);
    assertThat(connectFailed.getProtocol()).isNull();
    assertThat(connectFailed.getIoe()).isNotNull();
  }

  @Test public void multipleConnectsForSingleCall() throws IOException {
    enableTlsWithTunnel(false);
    server.enqueue(new MockResponse()
        .setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
    server.enqueue(new MockResponse());

    client = client.newBuilder()
        .dns(new DoubleInetAddressDns())
        .build();

    Call call = client.newCall(new Request.Builder()
        .url(server.url(""/""))
        .build());
    Response response = call.execute();
    assertThat(response.code()).isEqualTo(200);
    response.body().close();

    listener.removeUpToEvent(ConnectStart.class);
    listener.removeUpToEvent(ConnectFailed.class);
    listener.removeUpToEvent(ConnectStart.class);
    listener.removeUpToEvent(ConnectEnd.class);
  }

  @Test public void successfulHttpProxyConnect() throws IOException {
    server.enqueue(new MockResponse());

    client = client.newBuilder()
        .proxy(server.toProxyAddress())
        .build();

    Call call = client.newCall(new Request.Builder()
        .url(""http://www.fakeurl"")
        .build());
    Response response = call.execute();
    assertThat(response.code()).isEqualTo(200);
    response.body().close();

    InetAddress address = client.dns().lookup(server.getHostName()).get(0);
    InetSocketAddress expectedAddress = new InetSocketAddress(address, server.getPort());

    ConnectStart connectStart = listener.removeUpToEvent(ConnectStart.class);
    assertThat(connectStart.getCall()).isSameAs(call);
    assertThat(connectStart.getInetSocketAddress()).isEqualTo(expectedAddress);
    assertThat(connectStart.getProxy()).isEqualTo(server.toProxyAddress());

    ConnectEnd connectEnd = listener.removeUpToEvent(ConnectEnd.class);
    assertThat(connectEnd.getCall()).isSameAs(call);
    assertThat(connectEnd.getInetSocketAddress()).isEqualTo(expectedAddress);
    assertThat(connectEnd.getProtocol()).isEqualTo(Protocol.HTTP_1_1);
  }

  @Test public void successfulSocksProxyConnect() throws Exception {
    server.enqueue(new MockResponse());

    socksProxy = new SocksProxy();
    socksProxy.play();
    Proxy proxy = socksProxy.proxy();

    client = client.newBuilder()
        .proxy(proxy)
        .build();

    Call call = client.newCall(new Request.Builder()
        .url(""http://"" + SocksProxy.HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS + "":"" + server.getPort())
        .build());
    Response response = call.execute();
    assertThat(response.code()).isEqualTo(200);
    response.body().close();

    InetSocketAddress expectedAddress = InetSocketAddress.createUnresolved(
        SocksProxy.HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS, server.getPort());

    ConnectStart connectStart = listener.removeUpToEvent(ConnectStart.class);
    assertThat(connectStart.getCall()).isSameAs(call);
    assertThat(connectStart.getInetSocketAddress()).isEqualTo(expectedAddress);
    assertThat(connectStart.getProxy()).isEqualTo(proxy);

    ConnectEnd connectEnd = listener.removeUpToEvent(ConnectEnd.class);
    assertThat(connectEnd.getCall()).isSameAs(call);
    assertThat(connectEnd.getInetSocketAddress()).isEqualTo(expectedAddress);
    assertThat(connectEnd.getProtocol()).isEqualTo(Protocol.HTTP_1_1);
  }

  @Test public void authenticatingTunnelProxyConnect() throws IOException {
    enableTlsWithTunnel(true);
    server.enqueue(new MockResponse()
        .setResponseCode(407)
        .addHeader(""Proxy-Authenticate: Basic realm=\""localhost\"""")
        .addHeader(""Connection: close""));
    server.enqueue(new MockResponse()
        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END));
    server.enqueue(new MockResponse());

    client = client.newBuilder()
        .proxy(server.toProxyAddress())
        .proxyAuthenticator(new RecordingOkAuthenticator(""password"", ""Basic""))
        .build();

    Call call = client.newCall(new Request.Builder()
        .url(server.url(""/""))
        .build());
    Response response = call.execute();
    assertThat(response.code()).isEqualTo(200);
    response.body().close();

    listener.removeUpToEvent(ConnectStart.class);

    ConnectEnd connectEnd = listener.removeUpToEvent(ConnectEnd.class);
    assertThat(connectEnd.getProtocol()).isNull();

    listener.removeUpToEvent(ConnectStart.class);
    listener.removeUpToEvent(ConnectEnd.class);
  }

  @Test public void successfulSecureConnect() throws IOException {
    enableTlsWithTunnel(false);
    server.enqueue(new MockResponse());

    Call call = client.newCall(new Request.Builder()
        .url(server.url(""/""))
        .build());
    Response response = call.execute();
    assertThat(response.code()).isEqualTo(200);
    response.body().close();

    SecureConnectStart secureStart = listener.removeUpToEvent(SecureConnectStart.class);
    assertThat(secureStart.getCall()).isSameAs(call);

    SecureConnectEnd secureEnd = listener.removeUpToEvent(SecureConnectEnd.class);
    assertThat(secureEnd.getCall()).isSameAs(call);
    assertThat(secureEnd.getHandshake()).isNotNull();
  }

  @Test public void failedSecureConnect() {
    enableTlsWithTunnel(false);
    server.enqueue(new MockResponse()
        .setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));

    Call call = client.newCall(new Request.Builder()
        .url(server.url(""/""))
        .build());
    try {
      call.execute();
      fail();
    } catch (IOException expected) {
    }

    SecureConnectStart secureStart = listener.removeUpToEvent(SecureConnectStart.class);
    assertThat(secureStart.getCall()).isSameAs(call);

    CallFailed callFailed = listener.removeUpToEvent(CallFailed.class);
    assertThat(callFailed.getCall()).isSameAs(call);
    assertThat(callFailed.getIoe()).isNotNull();
  }

  @Test public void secureConnectWithTunnel() throws IOException {
    enableTlsWithTunnel(true);
    server.enqueue(new MockResponse()
        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END));
    server.enqueue(new MockResponse());

    client = client.newBuilder()
        .proxy(server.toProxyAddress())
        .build();

    Call call = client.newCall(new Request.Builder()
        .url(server.url(""/""))
        .build());
    Response response = call.execute();
    assertThat(response.code()).isEqualTo(200);
    response.body().close();

    SecureConnectStart secureStart = listener.removeUpToEvent(SecureConnectStart.class);
    assertThat(secureStart.getCall()).isSameAs(call);

    SecureConnectEnd secureEnd = listener.removeUpToEvent(SecureConnectEnd.class);
    assertThat(secureEnd.getCall()).isSameAs(call);
    assertThat(secureEnd.getHandshake()).isNotNull();
  }

  @Test public void multipleSecureConnectsForSingleCall() throws IOException {
    enableTlsWithTunnel(false);
    server.enqueue(new MockResponse()
        .setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
    server.enqueue(new MockResponse());

    client = client.newBuilder()
        .dns(new DoubleInetAddressDns())
        .build();

    Call call = client.newCall(new Request.Builder()
        .url(server.url(""/""))
        .build());
    Response response = call.execute();
    assertThat(response.code()).isEqualTo(200);
    response.body().close();

    listener.removeUpToEvent(SecureConnectStart.class);
    listener.removeUpToEvent(ConnectFailed.class);

    listener.removeUpToEvent(SecureConnectStart.class);
    listener.removeUpToEvent(SecureConnectEnd.class);
  }

  @Test public void noSecureConnectsOnPooledConnection() throws IOException {
    enableTlsWithTunnel(false);
    server.enqueue(new MockResponse());
    server.enqueue(new MockResponse());

    client = client.newBuilder()
        .dns(new DoubleInetAddressDns())
        .build();

    // Seed the pool.
    Call call1 = client.newCall(new Request.Builder()
        .url(server.url(""/""))
        .build());
    Response response1 = call1.execute();
    assertThat(response1.code()).isEqualTo(200);
    response1.body().close();

    listener.clearAllEvents();

    Call call2 = client.newCall(new Request.Builder()
        .url(server.url(""/""))
        .build());
    Response response2 = call2.execute();
    assertThat(response2.code()).isEqualTo(200);
    response2.body().close();

    List<String> recordedEvents = listener.recordedEventTypes();
    assertThat(recordedEvents).doesNotContain(""SecureConnectStart"");
    assertThat(recordedEvents).doesNotContain(""SecureConnectEnd"");
  }

  @Test public void successfulConnectionFound() throws IOException {
    server.enqueue(new MockResponse());

    Call call = client.newCall(new Request.Builder()
        .url(server.url(""/""))
        .build());
    Response response = call.execute();
    assertThat(response.code()).isEqualTo(200);
    response.body().close();

    ConnectionAcquired connectionAcquired = listener.removeUpToEvent(ConnectionAcquired.class);
    assertThat(connectionAcquired.getCall()).isSameAs(call);
    assertThat(connectionAcquired.getConnection()).isNotNull();
  }

  @Test public void noConnectionFoundOnFollowUp() throws IOException {
    server.enqueue(new MockResponse()
        .setResponseCode(301)
        .addHeader(""Location"", ""/foo""));
    server.enqueue(new MockResponse()
        .setBody(""ABC""));

    Call call = client.newCall(new Request.Builder()
        .url(server.url(""/""))
        .build());
    Response response = call.execute();
    assertThat(response.body().string()).isEqualTo(""ABC"");

    listener.removeUpToEvent(ConnectionAcquired.class);

    List<String> remainingEvents = listener.recordedEventTypes();
    assertThat(remainingEvents).doesNotContain(""ConnectionAcquired"");
  }

  @Test public void pooledConnectionFound() throws IOException {
    server.enqueue(new MockResponse());
    server.enqueue(new MockResponse());

    // Seed the pool.
    Call call1 = client.newCall(new Request.Builder()
        .url(server.url(""/""))
        .build());
    Response response1 = call1.execute();
    assertThat(response1.code()).isEqualTo(200);
    response1.body().close();

    ConnectionAcquired connectionAcquired1 = listener.removeUpToEvent(ConnectionAcquired.class);
    listener.clearAllEvents();

    Call call2 = client.newCall(new Request.Builder()
        .url(server.url(""/""))
        .build());
    Response response2 = call2.execute();
    assertThat(response2.code()).isEqualTo(200);
    response2.body().close();

    ConnectionAcquired connectionAcquired2 = listener.removeUpToEvent(ConnectionAcquired.class);
    assertThat(connectionAcquired2.getConnection()).isSameAs(
        connectionAcquired1.getConnection());
  }

  @Test public void multipleConnectionsFoundForSingleCall() throws IOException {
    server.enqueue(new MockResponse()
        .setResponseCode(301)
        .addHeader(""Location"", ""/foo"")
        .addHeader(""Connection"", ""Close""));
    server.enqueue(new MockResponse()
        .setBody(""ABC""));

    Call call = client.newCall(new Request.Builder()
        .url(server.url(""/""))
        .build());
    Response response = call.execute();
    assertThat(response.body().string()).isEqualTo(""ABC"");

    listener.removeUpToEvent(ConnectionAcquired.class);
    listener.removeUpToEvent(ConnectionAcquired.class);
  }

  @Test public void responseBodyFailHttp1OverHttps() throws IOException {
    enableTlsWithTunnel(false);
    server.setProtocols(asList(Protocol.HTTP_1_1));
    responseBodyFail(Protocol.HTTP_1_1);
  }

  @Test public void responseBodyFailHttp2OverHttps() throws IOException {
    platform.assumeHttp2Support();

    enableTlsWithTunnel(false);
    server.setProtocols(asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
    responseBodyFail(Protocol.HTTP_2);
  }

  @Test public void responseBodyFailHttp() throws IOException {
    responseBodyFail(Protocol.HTTP_1_1);
  }

  private void responseBodyFail(Protocol expectedProtocol) throws IOException {
    // Use a 2 MiB body so the disconnect won't happen until the client has read some data.
    int responseBodySize = 2 * 1024 * 1024; // 2 MiB
    server.enqueue(new MockResponse()
        .setBody(new Buffer().write(new byte[responseBodySize]))
        .setSocketPolicy(SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY));

    Call call = client.newCall(new Request.Builder()
        .url(server.url(""/""))
        .build());
    Response response = call.execute();
    if (expectedProtocol == Protocol.HTTP_2) {
      // soft failure since client may not support depending on Platform
      assumeThat(response, matchesProtocol(Protocol.HTTP_2));
    }
    assertThat(response.protocol()).isEqualTo(expectedProtocol);
    try {
      response.body().string();
      fail();
    } catch (IOException expected) {
    }

    CallFailed callFailed = listener.removeUpToEvent(CallFailed.class);
    assertThat(callFailed.getIoe()).isNotNull();
  }

  @Test public void emptyResponseBody() throws IOException {
    server.enqueue(new MockResponse()
        .setBody("""")
        .setBodyDelay(1, TimeUnit.SECONDS)
        .setSocketPolicy(SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY));

    Call call = client.newCall(new Request.Builder()
        .url(server.url(""/""))
        .build());
    Response response = call.execute();
    response.body().close();

    assertThat(listener.recordedEventTypes()).containsExactly(""CallStart"",
        ""ProxySelectStart"", ""ProxySelectEnd"", ""DnsStart"", ""DnsEnd"",
        ""ConnectStart"", ""ConnectEnd"", ""ConnectionAcquired"", ""RequestHeadersStart"",
        ""RequestHeadersEnd"", ""ResponseHeadersStart"", ""ResponseHeadersEnd"", ""ResponseBodyStart"",
        ""ResponseBodyEnd"", ""ConnectionReleased"", ""CallEnd"");
  }

  @Test public void emptyResponseBodyConnectionClose() throws IOException {
    server.enqueue(new MockResponse()
        .addHeader(""Connection"", ""close"")
        .setBody(""""));

    Call call = client.newCall(new Request.Builder()
        .url(server.url(""/""))
        .build());
    Response response = call.execute();
    response.body().close();

    assertThat(listener.recordedEventTypes()).containsExactly(""CallStart"",
        ""ProxySelectStart"", ""ProxySelectEnd"", ""DnsStart"", ""DnsEnd"",
        ""ConnectStart"", ""ConnectEnd"", ""ConnectionAcquired"", ""RequestHeadersStart"",
        ""RequestHeadersEnd"", ""ResponseHeadersStart"", ""ResponseHeadersEnd"", ""ResponseBodyStart"",
        ""ResponseBodyEnd"", ""ConnectionReleased"", ""CallEnd"");
  }

  @Test public void responseBodyClosedClosedWithoutReadingAllData() throws IOException {
    server.enqueue(new MockResponse()
        .setBody(""abc"")
        .setBodyDelay(1, TimeUnit.SECONDS)
        .setSocketPolicy(SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY));

    Call call = client.newCall(new Request.Builder()
        .url(server.url(""/""))
        .build());
    Response response = call.execute();
    response.body().close();

    assertThat(listener.recordedEventTypes()).containsExactly(""CallStart"",
        ""ProxySelectStart"", ""ProxySelectEnd"", ""DnsStart"", ""DnsEnd"",
        ""ConnectStart"", ""ConnectEnd"", ""ConnectionAcquired"", ""RequestHeadersStart"",
        ""RequestHeadersEnd"", ""ResponseHeadersStart"", ""ResponseHeadersEnd"", ""ResponseBodyStart"",
        ""ResponseBodyEnd"", ""ConnectionReleased"", ""CallEnd"");
  }

  @Test public void requestBodyFailHttp1OverHttps() {
    enableTlsWithTunnel(false);
    server.setProtocols(asList(Protocol.HTTP_1_1));

    requestBodyFail(Protocol.HTTP_1_1);
  }

  @Test public void requestBodyFailHttp2OverHttps() {
    platform.assumeHttp2Support();

    enableTlsWithTunnel(false);
    server.setProtocols(asList(Protocol.HTTP_2, Protocol.HTTP_1_1));

    requestBodyFail(Protocol.HTTP_2);
  }

  @Test public void requestBodyFailHttp() {
    requestBodyFail(null);
  }

  private void requestBodyFail(@Nullable Protocol expectedProtocol) {
    server.enqueue(new MockResponse()
        .setSocketPolicy(SocketPolicy.DISCONNECT_DURING_REQUEST_BODY));

    NonCompletingRequestBody request = new NonCompletingRequestBody();
    Call call = client.newCall(new Request.Builder()
        .url(server.url(""/""))
        .post(request)
        .build());
    try {
      call.execute();
      fail();
    } catch (IOException expected) {
    }

    if (expectedProtocol != null) {
      ConnectionAcquired connectionAcquired = listener.removeUpToEvent(ConnectionAcquired.class);
      assertThat(connectionAcquired.getConnection().protocol()).isEqualTo(expectedProtocol);
    }

    CallFailed callFailed = listener.removeUpToEvent(CallFailed.class);
    assertThat(callFailed.getIoe()).isNotNull();

    assertThat(request.ioe).isNotNull();
  }

  private class NonCompletingRequestBody extends RequestBody {
    IOException ioe;

    @Override public MediaType contentType() {
      return MediaType.get(""text/plain"");
    }

    @Override public long contentLength() {
      return 1024 * 1024 * 4;
    }

    @Override public void writeTo(BufferedSink sink) throws IOException {
      try {
        writeChunk(sink);
        writeChunk(sink);
        writeChunk(sink);
        writeChunk(sink);
        Thread.sleep(1000);
        writeChunk(sink);
        writeChunk(sink);
      } catch (IOException e) {
        ioe = e;
      } catch (InterruptedException e) {
      }
    }

    private void writeChunk(BufferedSink sink) throws IOException {
      sink.write(new byte[1024 * 512]);
      sink.flush();
    }
  }

  @Test public void requestBodyMultipleFailuresReportedOnlyOnce() {
    RequestBody requestBody = new RequestBody() {
      @Override public MediaType contentType() {
        return MediaType.get(""text/plain"");
      }

      @Override public long contentLength() {
        return 1024 * 1024 * 256;
      }

      @Override public void writeTo(BufferedSink sink) throws IOException {
        int failureCount = 0;
        for (int i = 0; i < 1024; i++) {
          try {
            sink.write(new byte[1024 * 256]);
            sink.flush();
          } catch (IOException e) {
            failureCount++;
            if (failureCount == 3) throw e;
          }
        }
      }
    };

    server.enqueue(new MockResponse()
        .setSocketPolicy(SocketPolicy.DISCONNECT_DURING_REQUEST_BODY));

    Call call = client.newCall(new Request.Builder()
        .url(server.url(""/""))
        .post(requestBody)
        .build());
    try {
      call.execute();
      fail();
    } catch (IOException expected) {
    }

    assertThat(listener.recordedEventTypes()).containsExactly(
        ""CallStart"", ""ProxySelectStart"", ""ProxySelectEnd"", ""DnsStart"", ""DnsEnd"", ""ConnectStart"",
        ""ConnectEnd"", ""ConnectionAcquired"", ""RequestHeadersStart"", ""RequestHeadersEnd"",
        ""RequestBodyStart"", ""RequestFailed"", ""ConnectionReleased"", ""CallFailed"");
  }

  @Test public void requestBodySuccessHttp1OverHttps() throws IOException {
    enableTlsWithTunnel(false);
    server.setProtocols(asList(Protocol.HTTP_1_1));
    requestBodySuccess(RequestBody.create(""Hello"", MediaType.get(""text/plain"")), equalTo(5L),
        equalTo(19L));
  }

  @Test public void requestBodySuccessHttp2OverHttps() throws IOException {
    platform.assumeHttp2Support();

    enableTlsWithTunnel(false);
    server.setProtocols(asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
    requestBodySuccess(RequestBody.create(""Hello"", MediaType.get(""text/plain"")), equalTo(5L),
        equalTo(19L));
  }

  @Test public void requestBodySuccessHttp() throws IOException {
    requestBodySuccess(RequestBody.create(""Hello"", MediaType.get(""text/plain"")), equalTo(5L),
        equalTo(19L));
  }

  @Test public void requestBodySuccessStreaming() throws IOException {
    RequestBody requestBody = new RequestBody() {
      @Override public MediaType contentType() {
        return MediaType.get(""text/plain"");
      }

      @Override public void writeTo(BufferedSink sink) throws IOException {
        sink.write(new byte[8192]);
        sink.flush();
      }
    };

    requestBodySuccess(requestBody, equalTo(8192L), equalTo(19L));
  }

  @Test public void requestBodySuccessEmpty() throws IOException {
    requestBodySuccess(RequestBody.create("""", MediaType.get(""text/plain"")), equalTo(0L),
        equalTo(19L));
  }

  @Test public void successfulCallEventSequenceWithListener() throws IOException {
    server.enqueue(new MockResponse().setBody(""abc""));

    client = client.newBuilder()
        .addNetworkInterceptor(new HttpLoggingInterceptor()
            .setLevel(HttpLoggingInterceptor.Level.BODY))
        .build();
    Call call = client.newCall(new Request.Builder()
        .url(server.url(""/""))
        .build());
    Response response = call.execute();
    assertThat(response.code()).isEqualTo(200);
    assertThat(response.body().string()).isEqualTo(""abc"");
    response.body().close();

    assertThat(listener.recordedEventTypes()).containsExactly(""CallStart"",
        ""ProxySelectStart"", ""ProxySelectEnd"", ""DnsStart"", ""DnsEnd"",
        ""ConnectStart"", ""ConnectEnd"", ""ConnectionAcquired"", ""RequestHeadersStart"",
        ""RequestHeadersEnd"", ""ResponseHeadersStart"", ""ResponseHeadersEnd"", ""ResponseBodyStart"",
        ""ResponseBodyEnd"", ""ConnectionReleased"", ""CallEnd"");
  }

  private void requestBodySuccess(RequestBody body, Matcher<Long> requestBodyBytes,
      Matcher<Long> responseHeaderLength) throws IOException {
    server.enqueue(new MockResponse()
        .setResponseCode(200)
        .setBody(""World!""));

    Call call = client.newCall(new Request.Builder()
        .url(server.url(""/""))
        .post(body)
        .build());
    Response response = call.execute();
    assertThat(response.body().string()).isEqualTo(""World!"");

    assertBytesReadWritten(listener, any(Long.class), requestBodyBytes, responseHeaderLength,
        equalTo(6L));
  }

  @Test public void timeToFirstByteHttp1OverHttps() throws IOException {
    enableTlsWithTunnel(false);
    server.setProtocols(asList(Protocol.HTTP_1_1));

    timeToFirstByte();
  }

  @Test public void timeToFirstByteHttp2OverHttps() throws IOException {
    platform.assumeHttp2Support();
    enableTlsWithTunnel(false);
    server.setProtocols(asList(Protocol.HTTP_2, Protocol.HTTP_1_1));

    timeToFirstByte();
  }

  /**
   * Test to confirm that events are reported at the time they occur and no earlier and no later.
   * This inserts a bunch of synthetic 250 ms delays into both client and server and confirms that
   * the same delays make it back into the events.
   *
   * We've had bugs where we report an event when we request data rather than when the data actually
   * arrives. https://github.com/square/okhttp/issues/5578
   */
  private void timeToFirstByte() throws IOException {
    long applicationInterceptorDelay = 250L;
    long networkInterceptorDelay = 250L;
    long requestBodyDelay = 250L;
    long responseHeadersStartDelay = 250L;
    long responseBodyStartDelay = 250L;
    long responseBodyEndDelay = 250L;

    // Warm up the client so the timing part of the test gets a pooled connection.
    server.enqueue(new MockResponse());
    Call warmUpCall = client.newCall(new Request.Builder()
        .url(server.url(""/""))
        .build());
    try (Response warmUpResponse = warmUpCall.execute()) {
      warmUpResponse.body().string();
    }
    listener.clearAllEvents();

    // Create a client with artificial delays.
    client = client.newBuilder()
        .addInterceptor(chain -> {
          try {
            Thread.sleep(applicationInterceptorDelay);
            return chain.proceed(chain.request());
          } catch (InterruptedException e) {
            throw new InterruptedIOException();
          }
        })
        .addNetworkInterceptor(chain -> {
          try {
            Thread.sleep(networkInterceptorDelay);
            return chain.proceed(chain.request());
          } catch (InterruptedException e) {
            throw new InterruptedIOException();
          }
        })
        .build();

    // Create a request body with artificial delays.
    Call call = client.newCall(new Request.Builder()
        .url(server.url(""/""))
        .post(new RequestBody() {
          @Override public @Nullable MediaType contentType() {
            return null;
          }

          @Override public void writeTo(BufferedSink sink) throws IOException {
            try {
              Thread.sleep(requestBodyDelay);
              sink.writeUtf8(""abc"");
            } catch (InterruptedException e) {
              throw new InterruptedIOException();
            }
          }
        })
        .build());

    // Create a response with artificial delays.
    server.enqueue(new MockResponse()
        .setHeadersDelay(responseHeadersStartDelay, TimeUnit.MILLISECONDS)
        .setBodyDelay(responseBodyStartDelay, TimeUnit.MILLISECONDS)
        .throttleBody(5, responseBodyEndDelay, TimeUnit.MILLISECONDS)
        .setBody(""fghijk""));

    // Make the call.
    try (Response response = call.execute()) {
      assertThat(response.body().string()).isEqualTo(""fghijk"");
    }

    // Confirm the events occur when expected.
    listener.takeEvent(CallStart.class, 0L);
    listener.takeEvent(ConnectionAcquired.class, applicationInterceptorDelay);
    listener.takeEvent(RequestHeadersStart.class, networkInterceptorDelay);
    listener.takeEvent(RequestHeadersEnd.class, 0L);
    listener.takeEvent(RequestBodyStart.class, 0L);
    listener.takeEvent(RequestBodyEnd.class, requestBodyDelay);
    listener.takeEvent(ResponseHeadersStart.class, responseHeadersStartDelay);
    listener.takeEvent(ResponseHeadersEnd.class, 0L);
    listener.takeEvent(ResponseBodyStart.class, responseBodyStartDelay);
    listener.takeEvent(ResponseBodyEnd.class, responseBodyEndDelay);
    listener.takeEvent(ConnectionReleased.class, 0L);
    listener.takeEvent(CallEnd.class, 0L);
  }

  private void enableTlsWithTunnel(boolean tunnelProxy) {
    client = client.newBuilder()
        .sslSocketFactory(
            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
        .hostnameVerifier(new RecordingHostnameVerifier())
        .build();
    server.useHttps(handshakeCertificates.sslSocketFactory(), tunnelProxy);
  }

  @Test public void redirectUsingSameConnectionEventSequence() throws IOException {
    server.enqueue(new MockResponse()
        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
        .addHeader(""Location: /foo""));
    server.enqueue(new MockResponse());

    Call call = client.newCall(new Request.Builder().url(server.url(""/"")).build());
    call.execute();

    assertThat(listener.recordedEventTypes()).containsExactly(""CallStart"",
        ""ProxySelectStart"", ""ProxySelectEnd"", ""DnsStart"", ""DnsEnd"",
        ""ConnectStart"", ""ConnectEnd"", ""ConnectionAcquired"", ""RequestHeadersStart"",
        ""RequestHeadersEnd"", ""ResponseHeadersStart"", ""ResponseHeadersEnd"", ""ResponseBodyStart"",
        ""ResponseBodyEnd"", ""RequestHeadersStart"", ""RequestHeadersEnd"", ""ResponseHeadersStart"",
        ""ResponseHeadersEnd"", ""ResponseBodyStart"", ""ResponseBodyEnd"", ""ConnectionReleased"",
        ""CallEnd"");
  }

  @Test
  public void redirectUsingNewConnectionEventSequence() throws IOException {
    MockWebServer otherServer = new MockWebServer();
    server.enqueue(
        new MockResponse()
            .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
            .addHeader(""Location: "" + otherServer.url(""/foo"")));
    otherServer.enqueue(new MockResponse());

    Call call = client.newCall(new Request.Builder().url(server.url(""/"")).build());
    call.execute();

    assertThat(listener.recordedEventTypes()).containsExactly(""CallStart"",
        ""ProxySelectStart"", ""ProxySelectEnd"", ""DnsStart"", ""DnsEnd"",
        ""ConnectStart"", ""ConnectEnd"", ""ConnectionAcquired"", ""RequestHeadersStart"",
        ""RequestHeadersEnd"", ""ResponseHeadersStart"", ""ResponseHeadersEnd"", ""ResponseBodyStart"",
        ""ResponseBodyEnd"", ""ConnectionReleased"", ""ProxySelectStart"", ""ProxySelectEnd"",
        ""DnsStart"", ""DnsEnd"", ""ConnectStart"", ""ConnectEnd"",
        ""ConnectionAcquired"", ""RequestHeadersStart"", ""RequestHeadersEnd"", ""ResponseHeadersStart"",
        ""ResponseHeadersEnd"", ""ResponseBodyStart"", ""ResponseBodyEnd"", ""ConnectionReleased"",
        ""CallEnd"");
  }

  @Test public void applicationInterceptorProceedsMultipleTimes() throws Exception {
    server.enqueue(new MockResponse().setBody(""a""));
    server.enqueue(new MockResponse().setBody(""b""));

    client = client.newBuilder()
        .addInterceptor(chain -> {
          try (Response a = chain.proceed(chain.request())) {
            assertThat(a.body().string()).isEqualTo(""a"");
          }
          return chain.proceed(chain.request());
        })
        .build();

    Call call = client.newCall(new Request.Builder().url(server.url(""/"")).build());
    Response response = call.execute();
    assertThat(response.body().string()).isEqualTo(""b"");

    assertThat(listener.recordedEventTypes()).containsExactly(""CallStart"",
        ""ProxySelectStart"", ""ProxySelectEnd"", ""DnsStart"", ""DnsEnd"",
        ""ConnectStart"", ""ConnectEnd"", ""ConnectionAcquired"", ""RequestHeadersStart"",
        ""RequestHeadersEnd"", ""ResponseHeadersStart"", ""ResponseHeadersEnd"", ""ResponseBodyStart"",
        ""ResponseBodyEnd"", ""RequestHeadersStart"", ""RequestHeadersEnd"", ""ResponseHeadersStart"",
        ""ResponseHeadersEnd"", ""ResponseBodyStart"", ""ResponseBodyEnd"", ""ConnectionReleased"",
        ""CallEnd"");

    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
  }

  @Test public void applicationInterceptorShortCircuit() throws Exception {
    client = client.newBuilder()
        .addInterceptor(chain -> new Response.Builder()
            .request(chain.request())
            .protocol(Protocol.HTTP_1_1)
            .code(200)
            .message(""OK"")
            .body(ResponseBody.create(""a"", null))
            .build())
        .build();

    Call call = client.newCall(new Request.Builder().url(server.url(""/"")).build());
    Response response = call.execute();
    assertThat(response.body().string()).isEqualTo(""a"");

    assertThat(listener.recordedEventTypes()).containsExactly(""CallStart"", ""CallEnd"");
  }

  /** Response headers start, then the entire request body, then response headers end. */
  @Test public void expectContinueStartsResponseHeadersEarly() throws Exception {
    server.enqueue(new MockResponse()
        .setSocketPolicy(SocketPolicy.EXPECT_CONTINUE));

    Request request = new Request.Builder()
        .url(server.url(""/""))
        .header(""Expect"", ""100-continue"")
        .post(RequestBody.create(""abc"", MediaType.get(""text/plain"")))
        .build();

    Call call = client.newCall(request);
    call.execute();

    assertThat(listener.recordedEventTypes()).containsExactly(
        ""CallStart"", ""ProxySelectStart"", ""ProxySelectEnd"", ""DnsStart"", ""DnsEnd"", ""ConnectStart"",
        ""ConnectEnd"", ""ConnectionAcquired"", ""RequestHeadersStart"", ""RequestHeadersEnd"",
        ""ResponseHeadersStart"", ""RequestBodyStart"", ""RequestBodyEnd"", ""ResponseHeadersEnd"",
        ""ResponseBodyStart"", ""ResponseBodyEnd"", ""ConnectionReleased"", ""CallEnd"");
  }

  @Test public void timeToFirstByteGapBetweenResponseHeaderStartAndEnd() throws IOException {
    long responseHeadersStartDelay = 250L;
    server.enqueue(new MockResponse()
        .setSocketPolicy(SocketPolicy.EXPECT_CONTINUE)
        .setHeadersDelay(responseHeadersStartDelay, TimeUnit.MILLISECONDS));

    Request request = new Request.Builder()
        .url(server.url(""/""))
        .header(""Expect"", ""100-continue"")
        .post(RequestBody.create(""abc"", MediaType.get(""text/plain"")))
        .build();

    Call call = client.newCall(request);
    try (Response response = call.execute()) {
      assertThat(response.body().string()).isEqualTo("""");
    }

    listener.removeUpToEvent(ResponseHeadersStart.class);
    listener.takeEvent(RequestBodyStart.class, 0L);
    listener.takeEvent(RequestBodyEnd.class, 0L);
    listener.takeEvent(ResponseHeadersEnd.class, responseHeadersStartDelay);
  }
}",KOT_04807,CWE-319: Cleartext Transmission of Sensitive Information;CWE-321: Hard-coded Cryptographic Key,A02: Cryptographic Failures;A04: Insecure Design,1
JetBrains__kotlin,bc3924c939e067246a0f021c428617506ef5e74e,libraries/tools/kotlin-gradle-plugin-integration-tests/src/test/kotlin/org/jetbrains/kotlin/gradle/android/Kapt3AndroidIncrementalIT.kt,.kt,Alexander.Likhachev,Alexander.Likhachev@jetbrains.com,2025-09-04T17:25:13+02:00,[Gradle] Fix IC assertion in testAndroidDaggerIC,1,Utils,"                class Utils {
                    public String oneMethod() {
                        return ""fake!"";
                    }
                    
                    public void anotherMethod() {
                        int one = 1;
                    }
                }",KOT_02068,,,0
duckduckgo__Android,9fcccc7553fdae2627c6aad53addfd59969d116e,app/src/androidTest/java/com/duckduckgo/app/location/data/LocationPermissionEntityTest.kt,.kt,David González,malmstein@gmail.com,2022-01-12T16:56:16+01:00,"Update Style guide, remove old settings (#1632)",1,LocationPermissionEntityTest,"class LocationPermissionEntityTest {

    @Test
    fun whenDomainStartsWithHttpsThenDropPrefix() {
        val locationPermissionEntity = LocationPermissionEntity(""https://www.example.com/"", LocationPermissionType.ALLOW_ONCE)
        val host = locationPermissionEntity.forFireproofing()
        Assert.assertEquals(""www.example.com"", host)
    }

    @Test
    fun whenDomainStartsWithHttpsUppercaseThenDropPrefix() {
        val locationPermissionEntity = LocationPermissionEntity(""HTTPS://www.example.com/"", LocationPermissionType.ALLOW_ONCE)
        val host = locationPermissionEntity.forFireproofing()
        Assert.assertEquals(""www.example.com"", host)
    }

    @Test
    fun whenDomainDoesNotStartWithHttpsThenDomainUnchanged() {
        val locationPermissionEntity = LocationPermissionEntity(""mobile.example.com/"", LocationPermissionType.ALLOW_ONCE)
        val host = locationPermissionEntity.forFireproofing()
        Assert.assertEquals(""mobile.example.com/"", host)
    }

    @Test
    fun whenDomainIsReturnedAsPermissionOriginThenDomainMatches() {
        val domain = ""www.example.com""
        val host = domain.asLocationPermissionOrigin()
        Assert.assertEquals(""https://www.example.com/"", host)
    }

}",KSEC_5283,['CWE-321: Hard-coded Cryptographic Key'],"['A02: Cryptographic Failures', 'A04: Insecure Design']",1
duckduckgo__Android,15db73acfa8eb1755b90f37093c85697a77db103,app/src/main/java/com/duckduckgo/app/httpsupgrade/model/HttpsBloomFilterSpec.kt,.kt,Craig Russell,CDRussell@users.noreply.github.com,2018-11-12T11:13:24+00:00,Feature/migrate to androidx (#394),1,,"/*
 * Copyright (c) 2018 DuckDuckGo
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.duckduckgo.app.httpsupgrade.model

import android.arch.persistence.room.Entity
import android.arch.persistence.room.PrimaryKey


@Entity(tableName = ""https_bloom_filter_spec"")
data class HttpsBloomFilterSpec(
    @PrimaryKey val id: Int = 1,
    val errorRate: Double,
    val totalEntries: Int,
    val sha256: String
) {
    companion object {
        const val HTTPS_BINARY_FILE = ""HTTPS_BINARY_FILE""
    }
}",KSEC_6292,['CWE-321: Hard-coded Cryptographic Key'],"['A02: Cryptographic Failures', 'A04: Insecure Design']",1
duckduckgo__Android,93166b6925037c498ae363f78dbb1a813cdc2b1c,broken-site/broken-site-impl/src/test/java/com/duckduckgo/brokensite/impl/RealBrokenSiteLastSentReportTest.kt,.kt,Craig Russell,CDRussell@users.noreply.github.com,2023-12-08T00:47:36+00:00,"Remove @ExperimentCoroutinesApi usage from most tests, now unnecessary (#3982)",1,,"/*
 * Copyright (c) 2023 DuckDuckGo
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.duckduckgo.brokensite.impl

import com.duckduckgo.brokensite.api.BrokenSiteLastSentReport
import com.duckduckgo.common.test.CoroutineTestRule
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.test.runTest
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.mockito.kotlin.mock
import org.mockito.kotlin.verify

@OptIn(ExperimentalCoroutinesApi::class)
class RealBrokenSiteLastSentReportTest {

    @get:Rule
    var coroutineRule = CoroutineTestRule()

    private val mockBrokenSiteReportRepository: BrokenSiteReportRepository = mock()
    private lateinit var testee: BrokenSiteLastSentReport

    @Before
    fun before() {
        testee = RealBrokenSiteLastSentReport(mockBrokenSiteReportRepository)
    }

    @Test
    fun whenGetLastSentDayCalledWithHostnameThenGetLastSentDayFromRepositoryIsCalled() = runTest {
        val hostname = ""www.example.com""

        testee.getLastSentDay(hostname)

        verify(mockBrokenSiteReportRepository).getLastSentDay(hostname)
    }

    @Test
    fun whenSetLastSentDayCalledWithHostnameThenSetLastSentDayFromRepositoryIsCalled() = runTest {
        val hostname = ""www.example.com""

        testee.setLastSentDay(hostname)

        verify(mockBrokenSiteReportRepository).setLastSentDay(hostname)
    }
}
",KSEC_2672,['CWE-321: Hard-coded Cryptographic Key'],"['A02: Cryptographic Failures', 'A04: Insecure Design']",1
duckduckgo__Android,06e95f7814f0486085321bf6825dce4e91ba563d,cookies/cookies-impl/src/test/java/com/duckduckgo/cookies/impl/WebViewCookieManagerTest.kt,.kt,David González,malmstein@gmail.com,2022-11-18T11:57:35+01:00,Replace Spotless with Kotlinter and applying KtLint (#2419),1,,"/*
 * Copyright (c) 2022 DuckDuckGo
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.duckduckgo.cookies.impl

import android.webkit.CookieManager
import android.webkit.ValueCallback
import com.duckduckgo.app.CoroutineTestRule
import com.duckduckgo.cookies.api.CookieManagerProvider
import com.duckduckgo.cookies.api.RemoveCookiesStrategy
import kotlinx.coroutines.test.runTest
import org.mockito.kotlin.*
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.withContext
import org.junit.Before
import org.junit.Rule
import org.junit.Test

private data class Cookie(
    val url: String,
    val value: String
)

@ExperimentalCoroutinesApi
class WebViewCookieManagerTest {
    @get:Rule
    @Suppress(""unused"")
    val coroutineRule = CoroutineTestRule()

    private val removeCookieStrategy = mock<RemoveCookiesStrategy>()
    private val cookieManagerProvider = mock<CookieManagerProvider>()
    private val cookieManager = mock<CookieManager>()
    private val ddgCookie = Cookie(DDG_HOST, ""da=abc"")
    private val externalHostCookie = Cookie(""example.com"", ""dz=zyx"")
    private val testee: WebViewCookieManager = WebViewCookieManager(
        cookieManagerProvider,
        removeCookieStrategy,
        coroutineRule.testDispatcherProvider
    )

    @Before
    fun setup() {
        whenever(cookieManagerProvider.get()).thenReturn(cookieManager)
        whenever(cookieManager.setCookie(any(), any(), any())).then {
            (it.getArgument(2) as ValueCallback<Boolean>).onReceiveValue(true)
        }
    }

    @Test
    fun whenCookiesRemovedThenInternalCookiesRecreated() = runTest {
        givenCookieManagerWithCookies(ddgCookie, externalHostCookie)

        withContext(Dispatchers.Main) {
            testee.removeExternalCookies()
        }

        verify(cookieManager).setCookie(eq(ddgCookie.url), eq(ddgCookie.value), any())
    }

    @Test
    fun whenCookiesStoredThenRemoveCookiesExecuted() = runTest {
        givenCookieManagerWithCookies(ddgCookie, externalHostCookie)

        withContext(Dispatchers.Main) {
            testee.removeExternalCookies()
        }

        verify(removeCookieStrategy).removeCookies()
    }

    @Test
    fun whenCookiesStoredThenFlushBeforeAndAfterInteractingWithCookieManager() = runTest {
        givenCookieManagerWithCookies(ddgCookie, externalHostCookie)

        withContext(Dispatchers.Main) {
            testee.removeExternalCookies()
        }

        cookieManager.inOrder {
            verify().flush()
            verify().getCookie(DDG_HOST)
            verify().hasCookies()
            verify().setCookie(eq(DDG_HOST), any(), any())
            verify().flush()
        }
    }

    @Test
    fun whenNoCookiesThenRemoveProcessNotExecuted() = runTest {
        givenCookieManagerWithCookies()

        withContext(Dispatchers.Main) {
            testee.removeExternalCookies()
        }

        verifyNoInteractions(removeCookieStrategy)
    }

    private fun givenCookieManagerWithCookies(vararg cookies: Cookie) {
        if (cookies.isEmpty()) {
            whenever(cookieManager.hasCookies()).thenReturn(false)
        } else {
            whenever(cookieManager.hasCookies()).thenReturn(true)
            cookies.forEach { cookie ->
                whenever(cookieManager.getCookie(cookie.url)).thenReturn(cookie.value)
            }
        }
    }

    companion object {
        private const val DDG_HOST = ""https://duckduckgo.com""
    }
}
",KSEC_4600,['CWE-321: Hard-coded Cryptographic Key'],"['A02: Cryptographic Failures', 'A04: Insecure Design']",1
gedoor__legado,289641b7d5b5804d4436dd08b58a428d5a024ac0,app/src/main/java/io/legado/app/model/localBook/TextFile.kt,.kt,Xwite,1797350009@qq.com,2023-03-07T18:56:21+08:00,fix(TextFile): throw meaningful Exception,1,,"package io.legado.app.model.localBook

import io.legado.app.data.appDb
import io.legado.app.data.entities.Book
import io.legado.app.data.entities.BookChapter
import io.legado.app.data.entities.TxtTocRule
import io.legado.app.help.DefaultData
import io.legado.app.utils.EncodingDetect
import io.legado.app.utils.MD5Utils
import io.legado.app.utils.StringUtils
import io.legado.app.utils.Utf8BomUtils
import java.io.FileNotFoundException
import java.lang.IllegalArgumentException
import java.nio.charset.Charset
import java.util.regex.Matcher
import java.util.regex.Pattern
import kotlin.math.min

class TextFile(private val book: Book) {

    companion object {
        private val padRegex = ""^[\\n\\s]+"".toRegex()
        private const val bufferSize = 8 * 1024 * 1024
        var txtBuffer: ByteArray? = null
        var bufferStart = -1
        var bufferEnd = -1
        var bookUrl = """"

        @Throws(FileNotFoundException::class)
        fun getChapterList(book: Book): ArrayList<BookChapter> {
            return TextFile(book).getChapterList()
        }

        @Synchronized
        @Throws(FileNotFoundException::class)
        fun getContent(book: Book, bookChapter: BookChapter): String {
            if (txtBuffer == null
                || bookUrl != book.bookUrl
                || bookChapter.start!! > bufferEnd
                || bookChapter.end!! < bufferStart
            ) {
                bookUrl = book.bookUrl
                LocalBook.getBookInputStream(book).use { bis ->
                    bufferStart = bufferSize * (bookChapter.start!! / bufferSize).toInt()
                    txtBuffer = ByteArray(min(bufferSize, bis.available() - bufferStart))
                    bufferEnd = bufferStart + txtBuffer!!.size
                    bis.skip(bufferStart.toLong())
                    bis.read(txtBuffer)
                }
            }

            val count = (bookChapter.end!! - bookChapter.start!!).toInt()
            val buffer = ByteArray(count)

            if (bookChapter.start!! < bufferEnd && bookChapter.end!! > bufferEnd
                || bookChapter.start!! < bufferStart && bookChapter.end!! > bufferStart
            ) {
                /** 章节内容在缓冲区交界处 */
                LocalBook.getBookInputStream(book).use { bis ->
                    bis.skip(bookChapter.start!!)
                    bis.read(buffer)
                }
            } else {
                /** 章节内容在缓冲区内 */
                txtBuffer!!.copyInto(
                    buffer,
                    0,
                    (bookChapter.start!! - bufferStart).toInt(),
                    (bookChapter.end!! - bufferStart).toInt()
                )
            }

            return String(buffer, book.fileCharset())
                .substringAfter(bookChapter.title)
                .replace(padRegex, ""　　"")
        }

    }

    private val blank: Byte = 0x0a

    //默认从文件中获取数据的长度
    private val bufferSize = 512000

    //没有标题的时候，每个章节的最大长度
    private val maxLengthWithNoToc = 10 * 1024

    //使用正则划分目录，每个章节的最大允许长度
    private val maxLengthWithToc = 102400

    private var charset: Charset = book.fileCharset()

    /**
     * 获取目录
     */
    @Throws(FileNotFoundException::class)
    fun getChapterList(): ArrayList<BookChapter> {
        if (book.charset == null || book.tocUrl.isBlank()) {
            LocalBook.getBookInputStream(book).use { bis ->
                val buffer = ByteArray(bufferSize)
                val length = bis.read(buffer)
                if (length == -1) throw IllegalArgumentException(""Unexpected Empty Txt File"")
                if (book.charset.isNullOrBlank()) {
                    book.charset = EncodingDetect.getEncode(buffer.copyOf(length))
                }
                charset = book.fileCharset()
                if (book.tocUrl.isBlank()) {
                    val blockContent = String(buffer, 0, length, charset)
                    book.tocUrl = getTocRule(blockContent)?.pattern() ?: """"
                }
            }
        }
        val toc = analyze(book.tocUrl.toPattern(Pattern.MULTILINE))
        toc.forEachIndexed { index, bookChapter ->
            bookChapter.index = index
            bookChapter.bookUrl = book.bookUrl
            bookChapter.url = MD5Utils.md5Encode16(book.originName + index + bookChapter.title)
        }
        return toc
    }

    /**
     * 按规则解析目录
     */
    private fun analyze(pattern: Pattern?): ArrayList<BookChapter> {
        if (pattern?.pattern().isNullOrEmpty()) {
            return analyze()
        }
        pattern ?: return analyze()
        val toc = arrayListOf<BookChapter>()
        LocalBook.getBookInputStream(book).use { bis ->
            var blockContent: String
            //加载章节
            var curOffset: Long = 0
            //读取的长度
            var length: Int
            val buffer = ByteArray(bufferSize)
            var bufferStart = 3
            bis.read(buffer, 0, 3)
            if (Utf8BomUtils.hasBom(buffer)) {
                bufferStart = 0
                curOffset = 3
            }
            //获取文件中的数据到buffer，直到没有数据为止
            while (
                bis.read(
                    buffer,
                    bufferStart,
                    bufferSize - bufferStart
                ).also { length = it } > 0
            ) {
                var end = bufferStart + length
                if (end == bufferSize) {
                    for (i in bufferStart + length - 1 downTo 0) {
                        if (buffer[i] == blank) {
                            end = i
                            break
                        }
                    }
                }
                //将数据转换成String, 不能超过length
                blockContent = String(buffer, 0, end, charset)
                buffer.copyInto(buffer, 0, end, bufferStart + length)
                bufferStart = bufferStart + length - end
                length = end
                //当前Block下使过的String的指针
                var seekPos = 0
                //进行正则匹配
                val matcher: Matcher = pattern.matcher(blockContent)
                //如果存在相应章节
                while (matcher.find()) { //获取匹配到的字符在字符串中的起始位置
                    val chapterStart = matcher.start()
                    //获取章节内容
                    val chapterContent = blockContent.substring(seekPos, chapterStart)
                    val chapterLength = chapterContent.toByteArray(charset).size
                    val lastStart = toc.lastOrNull()?.start ?: curOffset
                    if (book.getSplitLongChapter()
                        && curOffset + chapterLength - lastStart > maxLengthWithToc
                    ) {
                        toc.lastOrNull()?.let {
                            it.end = it.start
                        }
                        //章节字数太多进行拆分
                        val lastTitle = toc.lastOrNull()?.title
                        val lastTitleLength = lastTitle?.toByteArray(charset)?.size ?: 0
                        val chapters = analyze(
                            lastStart + lastTitleLength,
                            curOffset + chapterLength
                        )
                        lastTitle?.let {
                            chapters.forEachIndexed { index, bookChapter ->
                                bookChapter.title = ""$lastTitle(${index + 1})""
                            }
                        }
                        toc.addAll(chapters)
                        //创建当前章节
                        val curChapter = BookChapter()
                        curChapter.title = matcher.group()
                        curChapter.start = curOffset + chapterLength
                        toc.add(curChapter)
                    } else if (seekPos == 0 && chapterStart != 0) {
                        /*
                         * 如果 seekPos == 0 && chapterStart != 0 表示当前block处前面有一段内容
                         * 第一种情况一定是序章 第二种情况是上一个章节的内容
                         */
                        if (toc.isEmpty()) { //如果当前没有章节，那么就是序章
                            //加入简介
                            if (StringUtils.trim(chapterContent).isNotEmpty()) {
                                val qyChapter = BookChapter()
                                qyChapter.title = ""前言""
                                qyChapter.start = curOffset
                                qyChapter.end = curOffset + chapterLength.toLong()
                                toc.add(qyChapter)
                            }
                            //创建当前章节
                            val curChapter = BookChapter()
                            curChapter.title = matcher.group()
                            curChapter.start = curOffset + chapterLength.toLong()
                            toc.add(curChapter)
                        } else { //否则就block分割之后，上一个章节的剩余内容
                            //获取上一章节
                            val lastChapter = toc.last()
                            lastChapter.isVolume =
                                chapterContent.substringAfter(lastChapter.title).isBlank()
                            //将当前段落添加上一章去
                            lastChapter.end =
                                lastChapter.end!! + chapterLength.toLong()
                            //创建当前章节
                            val curChapter = BookChapter()
                            curChapter.title = matcher.group()
                            curChapter.start = lastChapter.end
                            toc.add(curChapter)
                        }
                    } else {
                        if (toc.isNotEmpty()) { //获取章节内容
                            //获取上一章节
                            val lastChapter = toc.last()
                            lastChapter.isVolume =
                                chapterContent.substringAfter(lastChapter.title).isBlank()
                            lastChapter.end =
                                lastChapter.start!! + chapterContent.toByteArray(charset).size.toLong()
                            //创建当前章节
                            val curChapter = BookChapter()
                            curChapter.title = matcher.group()
                            curChapter.start = lastChapter.end
                            toc.add(curChapter)
                        } else { //如果章节不存在则创建章节
                            val curChapter = BookChapter()
                            curChapter.title = matcher.group()
                            curChapter.start = curOffset
                            curChapter.end = curOffset
                            toc.add(curChapter)
                        }
                    }
                    //设置指针偏移
                    seekPos += chapterContent.length
                }
                //block的偏移点
                curOffset += length.toLong()
                //设置上一章的结尾
                toc.lastOrNull()?.end = curOffset
            }
        }
        System.gc()
        System.runFinalization()
        return toc
    }

    /**
     * 无规则拆分目录
     */
    private fun analyze(
        fileStart: Long = 0L,
        fileEnd: Long = Long.MAX_VALUE
    ): ArrayList<BookChapter> {
        val toc = arrayListOf<BookChapter>()
        LocalBook.getBookInputStream(book).use { bis ->
            //block的个数
            var blockPos = 0
            //加载章节
            var curOffset: Long = 0
            var chapterPos = 0
            //读取的长度
            var length = 0
            val buffer = ByteArray(bufferSize)
            var bufferStart = 3
            if (fileStart == 0L) {
                bis.read(buffer, 0, 3)
                if (Utf8BomUtils.hasBom(buffer)) {
                    bufferStart = 0
                    curOffset = 3
                }
            } else {
                bis.skip(fileStart)
                curOffset = fileStart
                bufferStart = 0
            }
            //获取文件中的数据到buffer，直到没有数据为止
            while (
                fileEnd - curOffset - bufferStart > 0 &&
                bis.read(
                    buffer,
                    bufferStart,
                    min(
                        (bufferSize - bufferStart).toLong(),
                        fileEnd - curOffset - bufferStart
                    ).toInt()
                ).also { length = it } > 0
            ) {
                blockPos++
                //章节在buffer的偏移量
                var chapterOffset = 0
                //当前剩余可分配的长度
                length += bufferStart
                var strLength = length
                //分章的位置
                chapterPos = 0
                while (strLength > 0) {
                    chapterPos++
                    //是否长度超过一章
                    if (strLength > maxLengthWithNoToc) { //在buffer中一章的终止点
                        var end = length
                        //寻找换行符作为终止点
                        for (i in chapterOffset + maxLengthWithNoToc until length) {
                            if (buffer[i] == blank) {
                                end = i
                                break
                            }
                        }
                        val chapter = BookChapter()
                        chapter.title = ""第${blockPos}章($chapterPos)""
                        chapter.start = toc.lastOrNull()?.end ?: curOffset
                        chapter.end = chapter.start!! + end - chapterOffset
                        toc.add(chapter)
                        //减去已经被分配的长度
                        strLength -= (end - chapterOffset)
                        //设置偏移的位置
                        chapterOffset = end
                    } else {
                        buffer.copyInto(buffer, 0, length - strLength, length)
                        length -= strLength
                        bufferStart = strLength
                        strLength = 0
                    }
                }
                //block的偏移点
                curOffset += length.toLong()
            }
            //设置结尾章节
            if (bufferStart > 100 || toc.isEmpty()) {
                val chapter = BookChapter()
                chapter.title = ""第${blockPos}章(${chapterPos})""
                chapter.start = toc.lastOrNull()?.end ?: curOffset
                chapter.end = chapter.start!! + bufferStart
                toc.add(chapter)
            } else {
                toc.lastOrNull()?.let {
                    it.end = it.end!! + bufferStart
                }
            }
        }
        return toc
    }

    /**
     * 获取所有匹配次数大于1的目录规则
     */
    private fun getTocRule(content: String): Pattern? {
        val rules = getTocRules().reversed()
        var maxCs = 1
        var tocPattern: Pattern? = null
        for (tocRule in rules) {
            val pattern = tocRule.rule.toPattern(Pattern.MULTILINE)
            val matcher = pattern.matcher(content)
            var cs = 0
            while (matcher.find()) {
                cs++
            }
            if (cs >= maxCs) {
                maxCs = cs
                tocPattern = pattern
            }
        }
        return tocPattern
    }

    /**
     * 获取启用的目录规则
     */
    private fun getTocRules(): List<TxtTocRule> {
        var rules = appDb.txtTocRuleDao.enabled
        if (rules.isEmpty()) {
            rules = DefaultData.txtTocRules.apply {
                appDb.txtTocRuleDao.insert(*this.toTypedArray())
            }.filter {
                it.enable
            }
        }
        return rules
    }

}",KOT_00496,,,0
bitwarden__android,c4f54ee93c276c916562636392a82e4bdcb491e1,app/src/test/java/com/x8bit/bitwarden/data/auth/datasource/network/service/NewAuthRequestServiceTest.kt,.kt,Patrick Honkonen,1883101+SaintPatrck@users.noreply.github.com,2025-04-04T13:33:55-04:00,[PM-19860] Migrate UnauthenticateAuthRequestsApi and models to `network` module (#4990),1,,"package com.x8bit.bitwarden.data.auth.datasource.network.service

import com.bitwarden.core.data.util.asSuccess
import com.bitwarden.network.api.AuthenticatedAuthRequestsApi
import com.bitwarden.network.base.BaseServiceTest
import com.bitwarden.network.model.AuthRequestTypeJson
import com.bitwarden.network.model.AuthRequestsResponseJson
import com.x8bit.bitwarden.data.auth.datasource.network.api.UnauthenticatedAuthRequestsApi
import kotlinx.coroutines.test.runTest
import okhttp3.mockwebserver.MockResponse
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.Test
import retrofit2.create
import java.time.ZonedDateTime

class NewAuthRequestServiceTest : BaseServiceTest() {

    private val authenticatedAuthRequestsApi: AuthenticatedAuthRequestsApi = retrofit.create()
    private val unauthenticatedAuthRequestsApi: UnauthenticatedAuthRequestsApi = retrofit.create()
    private val service = NewAuthRequestServiceImpl(
        authenticatedAuthRequestsApi = authenticatedAuthRequestsApi,
        unauthenticatedAuthRequestsApi = unauthenticatedAuthRequestsApi,
    )

    @Test
    fun `createAuthRequest when LOGIN_WITH_DEVICE and request is Failure should return Failure`() =
        runTest {
            val response = MockResponse().setResponseCode(400)
            server.enqueue(response)
            val deviceIdentifier = ""4321""
            val actual = service.createAuthRequest(
                email = ""test@gmail.com"",
                publicKey = ""1234"",
                deviceId = deviceIdentifier,
                accessCode = ""accessCode"",
                fingerprint = ""fingerprint"",
                authRequestType = AuthRequestTypeJson.LOGIN_WITH_DEVICE,
            )

            val request = server.takeRequest()
            assertEquals(deviceIdentifier, request.getHeader(""Device-Identifier""))
            assertEquals(""$urlPrefix/auth-requests"", request.requestUrl.toString())
            assertTrue(actual.isFailure)
        }

    @Test
    fun `createAuthRequest when LOGIN_WITH_DEVICE and request is Success should return Success`() =
        runTest {
            val response = MockResponse().setBody(AUTH_REQUEST_RESPONSE_JSON).setResponseCode(200)
            server.enqueue(response)
            val deviceIdentifier = ""4321""
            val actual = service.createAuthRequest(
                email = ""test@gmail.com"",
                publicKey = ""1234"",
                deviceId = deviceIdentifier,
                accessCode = ""accessCode"",
                fingerprint = ""fingerprint"",
                authRequestType = AuthRequestTypeJson.LOGIN_WITH_DEVICE,
            )
            val request = server.takeRequest()
            assertEquals(deviceIdentifier, request.getHeader(""Device-Identifier""))
            assertEquals(""$urlPrefix/auth-requests"", request.requestUrl.toString())
            assertEquals(AUTH_REQUEST_RESPONSE.asSuccess(), actual)
        }

    @Test
    fun `createAuthRequest when ADMIN_APPROVAL and request is Failure should return Failure`() =
        runTest {
            val response = MockResponse().setResponseCode(400)
            server.enqueue(response)
            val deviceIdentifier = ""4321""
            val actual = service.createAuthRequest(
                email = ""test@gmail.com"",
                publicKey = ""1234"",
                deviceId = deviceIdentifier,
                accessCode = ""accessCode"",
                fingerprint = ""fingerprint"",
                authRequestType = AuthRequestTypeJson.ADMIN_APPROVAL,
            )

            val request = server.takeRequest()
            assertEquals(deviceIdentifier, request.getHeader(""Device-Identifier""))
            assertEquals(""$urlPrefix/auth-requests/admin-request"", request.requestUrl.toString())
            assertTrue(actual.isFailure)
        }

    @Test
    fun `createAuthRequest when ADMIN_APPROVAL and request is Success should return Success`() =
        runTest {
            val response = MockResponse().setBody(AUTH_REQUEST_RESPONSE_JSON).setResponseCode(200)
            server.enqueue(response)
            val deviceIdentifier = ""4321""
            val actual = service.createAuthRequest(
                email = ""test@gmail.com"",
                publicKey = ""1234"",
                deviceId = deviceIdentifier,
                accessCode = ""accessCode"",
                fingerprint = ""fingerprint"",
                authRequestType = AuthRequestTypeJson.ADMIN_APPROVAL,
            )
            val request = server.takeRequest()
            assertEquals(deviceIdentifier, request.getHeader(""Device-Identifier""))
            assertEquals(""$urlPrefix/auth-requests/admin-request"", request.requestUrl.toString())
            assertEquals(AUTH_REQUEST_RESPONSE.asSuccess(), actual)
        }

    @Test
    fun `createAuthRequest when UNLOCK should return Failure`() = runTest {
        val deviceIdentifier = ""4321""
        val actual = service.createAuthRequest(
            email = ""test@gmail.com"",
            publicKey = ""1234"",
            deviceId = deviceIdentifier,
            accessCode = ""accessCode"",
            fingerprint = ""fingerprint"",
            authRequestType = AuthRequestTypeJson.UNLOCK,
        )
        assertTrue(actual.isFailure)
    }

    @Test
    fun `getAuthRequestUpdate when not SSO and response is Failure should return Failure`() =
        runTest {
            val response = MockResponse().setResponseCode(400)
            server.enqueue(response)
            val requestId = ""1""
            val accessCode = ""accessCode""
            val actual = service.getAuthRequestUpdate(
                requestId = requestId,
                accessCode = accessCode,
                isSso = false,
            )
            val request = server.takeRequest()
            assertEquals(
                ""$urlPrefix/auth-requests/$requestId/response?code=$accessCode"",
                request.requestUrl.toString(),
            )
            assertTrue(actual.isFailure)
        }

    @Test
    fun `getAuthRequestUpdate when not SSO and response is Success should return Success`() =
        runTest {
            val response = MockResponse().setBody(AUTH_REQUEST_RESPONSE_JSON).setResponseCode(200)
            server.enqueue(response)
            val requestId = ""1""
            val accessCode = ""accessCode""
            val actual = service.getAuthRequestUpdate(
                requestId = requestId,
                accessCode = accessCode,
                isSso = false,
            )
            val request = server.takeRequest()
            assertEquals(
                ""$urlPrefix/auth-requests/$requestId/response?code=$accessCode"",
                request.requestUrl.toString(),
            )
            assertEquals(AUTH_REQUEST_RESPONSE.asSuccess(), actual)
        }

    @Test
    fun `getAuthRequestUpdate when SSO and response is Failure should return Failure`() =
        runTest {
            val response = MockResponse().setResponseCode(400)
            server.enqueue(response)
            val requestId = ""1""
            val actual = service.getAuthRequestUpdate(
                requestId = requestId,
                accessCode = ""accessCode"",
                isSso = true,
            )
            val request = server.takeRequest()
            assertEquals(""$urlPrefix/auth-requests/$requestId"", request.requestUrl.toString())
            assertTrue(actual.isFailure)
        }

    @Test
    fun `getAuthRequestUpdate when SSO and response is Success should return Success`() =
        runTest {
            val response = MockResponse().setBody(AUTH_REQUEST_RESPONSE_JSON).setResponseCode(200)
            server.enqueue(response)
            val requestId = ""1""
            val actual = service.getAuthRequestUpdate(
                requestId = requestId,
                accessCode = ""accessCode"",
                isSso = true,
            )
            val request = server.takeRequest()
            assertEquals(""$urlPrefix/auth-requests/$requestId"", request.requestUrl.toString())
            assertEquals(AUTH_REQUEST_RESPONSE.asSuccess(), actual)
        }
}

private const val AUTH_REQUEST_RESPONSE_JSON = """"""
{
  ""id"": ""1"",
  ""publicKey"": ""2"",
  ""requestDeviceType"": ""Android"",
  ""requestIpAddress"": ""1.0.0.1"",
  ""key"": ""key"",
  ""masterPasswordHash"": ""verySecureHash"",
  ""creationDate"": ""2024-09-13T01:00:00.00Z"",
  ""requestApproved"": true,
  ""origin"": ""www.bitwarden.com""
}
""""""

private val AUTH_REQUEST_RESPONSE = AuthRequestsResponseJson.AuthRequest(
    id = ""1"",
    publicKey = ""2"",
    platform = ""Android"",
    ipAddress = ""1.0.0.1"",
    key = ""key"",
    masterPasswordHash = ""verySecureHash"",
    creationDate = ZonedDateTime.parse(""2024-09-13T01:00:00.00Z""),
    responseDate = null,
    requestApproved = true,
    originUrl = ""www.bitwarden.com"",
)
",KSEC_0312,['CWE-321: Hard-coded Cryptographic Key'],"['A02: Cryptographic Failures', 'A04: Insecure Design']",1
bitwarden__android,6340c2dd04f6407c4cf6c9c57d83779eefac4ad2,app/src/main/java/com/x8bit/bitwarden/data/tiles/BitwardenAutofillTileService.kt,.kt,Patrick Honkonen,1883101+SaintPatrck@users.noreply.github.com,2025-03-27T17:11:53-04:00,[PM-19616] Move OmitFromCoverage annotation to core module (#4928),1,,"package com.x8bit.bitwarden.data.tiles

import android.annotation.SuppressLint
import android.app.AlertDialog
import android.app.Dialog
import android.app.PendingIntent
import android.content.Intent
import android.os.Build
import android.service.quicksettings.TileService
import androidx.annotation.Keep
import com.bitwarden.core.annotation.OmitFromCoverage
import com.x8bit.bitwarden.AccessibilityActivity
import com.x8bit.bitwarden.R
import com.x8bit.bitwarden.data.autofill.accessibility.manager.AccessibilityAutofillManager
import com.x8bit.bitwarden.data.autofill.accessibility.model.AccessibilityAction
import com.x8bit.bitwarden.data.autofill.accessibility.util.isAccessibilityServiceEnabled
import com.x8bit.bitwarden.data.platform.util.isBuildVersionBelow
import dagger.hilt.android.AndroidEntryPoint
import javax.inject.Inject

/**
 * A service for handling the Autofill quick settings tile.
 */
@AndroidEntryPoint
@Keep
@OmitFromCoverage
class BitwardenAutofillTileService : TileService() {
    @Inject
    lateinit var accessibilityAutofillManager: AccessibilityAutofillManager

    override fun onClick() {
        if (isLocked) {
            unlockAndRun { launchAutofill() }
        } else {
            launchAutofill()
        }
    }

    @SuppressLint(""StartActivityAndCollapseDeprecated"")
    private fun launchAutofill() {
        if (!applicationContext.isAccessibilityServiceEnabled) {
            showDialog(getAccessibilityServiceRequiredDialog())
            return
        }
        accessibilityAutofillManager.accessibilityAction = AccessibilityAction.AttemptParseUri
        val intent = Intent(applicationContext, AccessibilityActivity::class.java)
            .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK)
        if (isBuildVersionBelow(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)) {
            @Suppress(""DEPRECATION"")
            startActivityAndCollapse(intent)
        } else {
            startActivityAndCollapse(
                PendingIntent.getActivity(
                    applicationContext,
                    0,
                    intent,
                    PendingIntent.FLAG_IMMUTABLE,
                ),
            )
        }
    }

    private fun getAccessibilityServiceRequiredDialog(): Dialog =
        AlertDialog.Builder(this)
            .setMessage(R.string.autofill_tile_accessibility_required)
            .setCancelable(true)
            .setPositiveButton(R.string.ok) { dialog, _ -> dialog.cancel() }
            .create()
}
",KSEC_0444,,,0
square__leakcanary,3920d0a403dc564fc3bde3bfaab86f549d65e846,shark-android/src/main/java/shark/AndroidReferenceMatchers.kt,.kt,PY,pyricau@users.noreply.github.com,2020-06-17T18:00:45-07:00,SemAppIconSolution leak happens on API 29,1,AndroidReferenceMatchers,"enum class AndroidReferenceMatchers {

  // ######## Android Framework known leaks ########

  IREQUEST_FINISH_CALLBACK {
      override fun add(
          references: MutableList<ReferenceMatcher>
      ) {
          references += instanceFieldLeak(""android.app.Activity\$1"", ""this\$0"",
              description = ""Android Q added a new android.app.IRequestFinishCallback\$Stub "" +
                  ""class. android.app.Activity creates an implementation of that interface as an "" +
                  ""anonymous subclass. That anonymous subclass has a reference to the activity. "" +
                  ""Another process is keeping the android.app.IRequestFinishCallback\$Stub "" +
                  ""reference alive long after Activity.onDestroyed() has been called, "" +
                  ""causing the activity to leak."" +
                  ""Fix: You can \""fix\"" this leak by overriding Activity.onBackPressed() and calling "" +
                  ""Activity.finishAfterTransition(); instead of super if the activity is task root and the "" +
                  ""fragment stack is empty."" +
                  ""Tracked here: https://issuetracker.google.com/issues/139738913""
          ) {
              sdkInt == 29
          }
      }
  },

  ACTIVITY_CLIENT_RECORD__NEXT_IDLE {
    override fun add(
      references: MutableList<ReferenceMatcher>
    ) {
      references += instanceFieldLeak(
          ""android.app.ActivityThread\$ActivityClientRecord"", ""nextIdle"",
          description = ""Android AOSP sometimes keeps a reference to a destroyed activity as a""
              + "" nextIdle client record in the android.app.ActivityThread.mActivities map.""
              + "" Not sure what's going on there, input welcome.""
      ) {
        sdkInt in 19..27
      }
    }
  },

  SPAN_CONTROLLER {
    override fun add(
      references: MutableList<ReferenceMatcher>
    ) {
      val description =
        (""Editor inserts a special span, which has a reference to the EditText. That span is a""
            + "" NoCopySpan, which makes sure it gets dropped when creating a new""
            + "" SpannableStringBuilder from a given CharSequence.""
            + "" TextView.onSaveInstanceState() does a copy of its mText before saving it in the""
            + "" bundle. Prior to KitKat, that copy was done using the SpannableString""
            + "" constructor, instead of SpannableStringBuilder. The SpannableString constructor""
            + "" does not drop NoCopySpan spans. So we end up with a saved state that holds a""
            + "" reference to the textview and therefore the entire view hierarchy & activity""
            + "" context. Fix: https://github.com/android/platform_frameworks_base/commit""
            + ""/af7dcdf35a37d7a7dbaad7d9869c1c91bce2272b .""
            + "" To fix this, you could override TextView.onSaveInstanceState(), and then use""
            + "" reflection to access TextView.SavedState.mText and clear the NoCopySpan spans."")

      references += instanceFieldLeak(
          ""android.widget.Editor\$SpanController"", ""this$0"", description
      ) {
        sdkInt <= 19
      }

      references += instanceFieldLeak(
          ""android.widget.Editor\$EasyEditSpanController"", ""this$0"", description
      ) {
        sdkInt <= 19
      }
    }
  },

  MEDIA_SESSION_LEGACY_HELPER__SINSTANCE {
    override fun add(
      references: MutableList<ReferenceMatcher>
    ) {
      references +=
        staticFieldLeak(
            ""android.media.session.MediaSessionLegacyHelper"", ""sInstance"",
            description = ""MediaSessionLegacyHelper is a static singleton that is lazily instantiated and""
                + "" keeps a reference to the context it's given the first time""
                + "" MediaSessionLegacyHelper.getHelper() is called.""
                + "" This leak was introduced in android-5.0.1_r1 and fixed in Android 5.1.0_r1 by""
                + "" calling context.getApplicationContext().""
                + "" Fix: https://github.com/android/platform_frameworks_base/commit""
                + ""/9b5257c9c99c4cb541d8e8e78fb04f008b1a9091""
                + "" To fix this, you could call MediaSessionLegacyHelper.getHelper() early""
                + "" in Application.onCreate() and pass it the application context.""
        ) {
          sdkInt == 21
        }
    }
  },

  TEXT_LINE__SCACHED {
    override fun add(
      references: MutableList<ReferenceMatcher>
    ) {
      references += staticFieldLeak(
          ""android.text.TextLine"", ""sCached"",
          description = ""TextLine.sCached is a pool of 3 TextLine instances. TextLine.recycle() has had""
              + "" at least two bugs that created memory leaks by not correctly clearing the""
              + "" recycled TextLine instances. The first was fixed in android-5.1.0_r1:""
              + "" https://github.com/android/platform_frameworks_base/commit""
              + ""/893d6fe48d37f71e683f722457bea646994a10""
              + "" The second was fixed, not released yet:""
              + "" https://github.com/android/platform_frameworks_base/commit""
              + ""/b3a9bc038d3a218b1dbdf7b5668e3d6c12be5e""
              + "" To fix this, you could access TextLine.sCached and clear the pool every now""
              + "" and then (e.g. on activity destroy).""
      ) {
        sdkInt <= 22
      }
    }
  },

  BLOCKING_QUEUE {
    override fun add(
      references: MutableList<ReferenceMatcher>
    ) {
      val description = (""A thread waiting on a blocking queue will leak the last""
          + "" dequeued object as a stack local reference. So when a HandlerThread becomes idle, it""
          + "" keeps a local reference to the last message it received. That message then gets""
          + "" recycled and can be used again. As long as all messages are recycled after being""
          + "" used, this won't be a problem, because these references are cleared when being""
          + "" recycled. However, dialogs create template Message instances to be copied when a""
          + "" message needs to be sent. These Message templates holds references to the dialog""
          + "" listeners, which most likely leads to holding a reference onto the activity in some""
          + "" way. Dialogs never recycle their template Message, assuming these Message instances""
          + "" will get GCed when the dialog is GCed.""
          + "" The combination of these two things creates a high potential for memory leaks as soon""
          + "" as you use dialogs. These memory leaks might be temporary, but some handler threads""
          + "" sleep for a long time.""
          + "" To fix this, you could post empty messages to the idle handler threads from time to""
          + "" time. This won't be easy because you cannot access all handler threads, but a library""
          + "" that is widely used should consider doing this for its own handler threads. This leaks""
          + "" has been shown to happen in both Dalvik and ART."")

      references += instanceFieldLeak(""android.os.Message"", ""obj"", description)
      references += instanceFieldLeak(""android.os.Message"", ""next"", description)
      references += instanceFieldLeak(""android.os.Message"", ""target"", description)
    }
  },

  INPUT_METHOD_MANAGER_IS_TERRIBLE {
    override fun add(
      references: MutableList<ReferenceMatcher>
    ) {
      val description =
        (""When we detach a view that receives keyboard input, the InputMethodManager""
            + "" leaks a reference to it until a new view asks for keyboard input.""
            + "" Tracked here: https://code.google.com/p/android/issues/detail?id=171190""
            + "" Hack: https://gist.github.com/pyricau/4df64341cc978a7de414"")

      references += instanceFieldLeak(
          ""android.view.inputmethod.InputMethodManager"", ""mNextServedView"", description
      ) {
        sdkInt in 15..27
      }

      references += instanceFieldLeak(
          ""android.view.inputmethod.InputMethodManager"", ""mServedView"", description
      ) {
        sdkInt in 15..27
      }

      references += instanceFieldLeak(
          ""android.view.inputmethod.InputMethodManager"", ""mServedInputConnection"", description
      ) {
        sdkInt in 15..27
      }

      references += instanceFieldLeak(
          ""android.view.inputmethod.InputMethodManager"", ""mLastSrvView""
          ,
          description =
          ""HUAWEI added a mLastSrvView field to InputMethodManager"" + "" that leaks a reference to the last served view.""
      ) {
        manufacturer == HUAWEI && sdkInt in 23..28
      }

      references += instanceFieldLeak(
          ""android.view.inputmethod.InputMethodManager"", ""mCurRootView"",
          description = ""The singleton InputMethodManager is holding a reference to mCurRootView long""
              + "" after the activity has been destroyed.""
              + "" Observed on ICS MR1: https://github.com/square/leakcanary/issues/1""
              + ""#issuecomment-100579429""
              + "" Hack: https://gist.github.com/pyricau/4df64341cc978a7de414""
      ) {
        sdkInt in 15..28
      }

      references += instanceFieldLeak(
          ""android.view.inputmethod.InputMethodManager"", ""mImeInsetsConsumer"",
          description = """"""
              Android Q Beta has a leak where InputMethodManager.mImeInsetsConsumer isn't set to
              null when the activity is destroyed.
            """""".trimIndent()
      ) {
        sdkInt == 28
      }

      references += instanceFieldLeak(
          ""android.view.inputmethod.InputMethodManager"", ""mCurrentInputConnection"",
          description = """"""
              In Android Q Beta InputMethodManager keeps its EditableInputConnection after the
              activity has been destroyed.
            """""".trimIndent()
      ) {
        sdkInt == 28
      }
    }
  },

  LAYOUT_TRANSITION {
    override fun add(
      references: MutableList<ReferenceMatcher>
    ) {
      references += instanceFieldLeak(
          ""android.animation.LayoutTransition$1"", ""val\$parent"",
          description = ""LayoutTransition leaks parent ViewGroup through""
              + "" ViewTreeObserver.OnPreDrawListener When triggered, this leaks stays until the""
              + "" window is destroyed. Tracked here:""
              + "" https://code.google.com/p/android/issues/detail?id=171830""
      ) {
        sdkInt in 14..22
      }
    }
  },

  SPELL_CHECKER_SESSION {
    override fun add(
      references: MutableList<ReferenceMatcher>
    ) {
      references += instanceFieldLeak(
          ""android.view.textservice.SpellCheckerSession$1"", ""this$0"",
          description = ""SpellCheckerSessionListenerImpl.mHandler is leaking destroyed Activity when the""
              + "" SpellCheckerSession is closed before the service is connected.""
              + "" Tracked here: https://code.google.com/p/android/issues/detail?id=172542""
      ) {
        sdkInt in 16..24
      }
    }
  },

  SPELL_CHECKER {
    override fun add(
      references: MutableList<ReferenceMatcher>
    ) {
      references += instanceFieldLeak(
          ""android.widget.SpellChecker$1"", ""this$0"",
          description = ""SpellChecker holds on to a detached view that points to a destroyed activity.""
              + "" mSpellRunnable is being enqueued, and that callback should be removed when ""
              + "" closeSession() is called. Maybe closeSession() wasn't called, or maybe it was ""
              + "" called after the view was detached.""
      ) {
        sdkInt == 22
      }
    }
  },

  ACTIVITY_CHOOSE_MODEL {
    override fun add(
      references: MutableList<ReferenceMatcher>
    ) {
      val description = (""ActivityChooserModel holds a static reference to the last set""
          + "" ActivityChooserModelPolicy which can be an activity context.""
          + "" Tracked here: https://code.google.com/p/android/issues/detail?id=172659""
          + "" Hack: https://gist.github.com/andaag/b05ab66ed0f06167d6e0"")


      references += instanceFieldLeak(
          ""android.support.v7.internal.widget.ActivityChooserModel"",
          ""mActivityChoserModelPolicy"",
          description = description
      ) {
        sdkInt in 15..22
      }

      references += instanceFieldLeak(
          ""android.widget.ActivityChooserModel"", ""mActivityChoserModelPolicy"",
          description = description
      )
    }
  },

  MEDIA_PROJECTION_CALLBACK {
    override fun add(references: MutableList<ReferenceMatcher>) {
      references += instanceFieldLeak(
          ""android.media.projection.MediaProjection\$MediaProjectionCallback"",
          ""this$0"", description = """"""
              MediaProjectionCallback is held by another process, and holds on to MediaProjection
              which has an activity as its context.
            """""".trimIndent()
      ) {
        sdkInt in 22..28
      }
    }

  },

  SPEECH_RECOGNIZER {
    override fun add(
      references: MutableList<ReferenceMatcher>
    ) {
      references += instanceFieldLeak(
          ""android.speech.SpeechRecognizer\$InternalListener"", ""this$0""
          ,
          description = ""Prior to Android 5, SpeechRecognizer.InternalListener was a non static inner""
              + "" class and leaked the SpeechRecognizer which leaked an activity context.""
              + "" Fixed in AOSP: https://github.com/android/platform_frameworks_base/commit""
              + "" /b37866db469e81aca534ff6186bdafd44352329b""
      ) {
        sdkInt < 21
      }
    }
  },

  ACCOUNT_MANAGER {
    override fun add(
      references: MutableList<ReferenceMatcher>
    ) {
      references += instanceFieldLeak(
          ""android.accounts.AccountManager\$AmsTask\$Response"", ""this$1""
          ,
          description =
          ""AccountManager\$AmsTask\$Response is a stub and is held in memory by native code,""
              + "" probably because the reference to the response in the other process hasn't been""
              + "" cleared.""
              + "" AccountManager\$AmsTask is holding on to the activity reference to use for""
              + "" launching a new sub- Activity.""
              + "" Tracked here: https://code.google.com/p/android/issues/detail?id=173689""
              + "" Fix: Pass a null activity reference to the AccountManager methods and then deal""
              + "" with the returned future to to get the result and correctly start an activity""
              + "" when it's available.""
      ) {
        sdkInt <= 27
      }
    }
  },

  MEDIA_SCANNER_CONNECTION {
    override fun add(
      references: MutableList<ReferenceMatcher>
    ) {
      references += instanceFieldLeak(
          ""android.media.MediaScannerConnection"", ""mContext"",

          description =
          ""The static method MediaScannerConnection.scanFile() takes an activity context""
              + "" but the service might not disconnect after the activity has been destroyed.""
              + "" Tracked here: https://code.google.com/p/android/issues/detail?id=173788""
              + "" Fix: Create an instance of MediaScannerConnection yourself and pass in the""
              + "" application context. Call connect() and disconnect() manually.""
      ) {
        sdkInt <= 22
      }
    }
  },

  USER_MANAGER__SINSTANCE {
    override fun add(
      references: MutableList<ReferenceMatcher>
    ) {
      references += instanceFieldLeak(
          ""android.os.UserManager"", ""mContext"",
          description =
          ""UserManager has a static sInstance field that creates an instance and caches it""
              + "" the first time UserManager.get() is called. This instance is created with the""
              + "" outer context (which is an activity base context).""
              + "" Tracked here: https://code.google.com/p/android/issues/detail?id=173789""
              + "" Introduced by: https://github.com/android/platform_frameworks_base/commit""
              + ""/27db46850b708070452c0ce49daf5f79503fbde6""
              + "" Fix: trigger a call to UserManager.get() in Application.onCreate(), so that the""
              + "" UserManager instance gets cached with a reference to the application context.""
      ) {
        sdkInt in 18..25
      }
    }
  },

  APP_WIDGET_HOST_CALLBACKS {
    override fun add(
      references: MutableList<ReferenceMatcher>
    ) {
      references += instanceFieldLeak(
          ""android.appwidget.AppWidgetHost\$Callbacks"", ""this$0""
          ,
          description =
          ""android.appwidget.AppWidgetHost\$Callbacks is a stub and is held in memory native""
              + "" code. The reference to the `mContext` was not being cleared, which caused the""
              + "" Callbacks instance to retain this reference""
              + "" Fixed in AOSP: https://github.com/android/platform_frameworks_base/commit""
              + ""/7a96f3c917e0001ee739b65da37b2fadec7d7765""
      ) {
        sdkInt < 22
      }
    }
  },

  AUDIO_MANAGER {
    override fun add(
      references: MutableList<ReferenceMatcher>
    ) {
      references += instanceFieldLeak(
          ""android.media.AudioManager$1"", ""this$0"",
          description =
          ""Prior to Android M, VideoView required audio focus from AudioManager and""
              + "" never abandoned it, which leaks the Activity context through the AudioManager.""
              + "" The root of the problem is that AudioManager uses whichever""
              + "" context it receives, which in the case of the VideoView example is an Activity,""
              + "" even though it only needs the application's context. The issue is fixed in""
              + "" Android M, and the AudioManager now uses the application's context.""
              + "" Tracked here: https://code.google.com/p/android/issues/detail?id=152173""
              + "" Fix: https://gist.github.com/jankovd/891d96f476f7a9ce24e2""
      ) {
        sdkInt <= 22
      }
    }
  },

  EDITTEXT_BLINK_MESSAGEQUEUE {
    override fun add(
      references: MutableList<ReferenceMatcher>
    ) {
      references += instanceFieldLeak(
          ""android.widget.Editor\$Blink"", ""this$0"",
          description =
          ""The EditText Blink of the Cursor is implemented using a callback and Messages,""
              + "" which trigger the display of the Cursor. If an AlertDialog or DialogFragment that""
              + "" contains a blinking cursor is detached, a message is posted with a delay after the""
              + "" dialog has been closed and as a result leaks the Activity.""
              + "" This can be fixed manually by calling TextView.setCursorVisible(false) in the""
              + "" dismiss() method of the dialog.""
              + "" Tracked here: https://code.google.com/p/android/issues/detail?id=188551""
              + "" Fixed in AOSP: https://android.googlesource.com/platform/frameworks/base/+""
              + ""/5b734f2430e9f26c769d6af8ea5645e390fcf5af%5E%21/""
      ) {
        sdkInt <= 23
      }
    }
  },

  CONNECTIVITY_MANAGER__SINSTANCE {
    override fun add(
      references: MutableList<ReferenceMatcher>
    ) {
      references += instanceFieldLeak(
          ""android.net.ConnectivityManager"", ""sInstance"",
          description =
          ""ConnectivityManager has a sInstance field that is set when the first""
              + "" ConnectivityManager instance is created. ConnectivityManager has a mContext field.""
              + "" When calling activity.getSystemService(Context.CONNECTIVITY_SERVICE) , the first""
              + "" ConnectivityManager instance is created with the activity context and stored in""
              + "" sInstance. That activity context then leaks forever.""
              + "" Until this is fixed, app developers can prevent this leak by making sure the""
              + "" ConnectivityManager is first created with an App Context. E.g. in some static""
              + "" init do: context.getApplicationContext()""
              + "".getSystemService(Context.CONNECTIVITY_SERVICE)""
              + "" Tracked here: https://code.google.com/p/android/issues/detail?id=198852""
              + "" Introduced here: https://github.com/android/platform_frameworks_base/commit/""
              + ""e0bef71662d81caaaa0d7214fb0bef5d39996a69""
      ) {
        sdkInt <= 23
      }
    }
  },

  ACCESSIBILITY_NODE_INFO__MORIGINALTEXT {
    override fun add(
      references: MutableList<ReferenceMatcher>
    ) {
      references += instanceFieldLeak(
          ""android.view.accessibility.AccessibilityNodeInfo"", ""mOriginalText""
          ,
          description =
          ""AccessibilityNodeInfo has a static sPool of AccessibilityNodeInfo. When""
              + "" AccessibilityNodeInfo instances are released back in the pool,""
              + "" AccessibilityNodeInfo.clear() does not clear the mOriginalText field, which""
              + "" causes spans to leak which in turns causes TextView.ChangeWatcher to leak and the""
              + "" whole view hierarchy. Introduced here: https://android.googlesource.com/platform/""
              + ""frameworks/base/+/193520e3dff5248ddcf8435203bf99d2ba667219%5E%21/core/java/""
              + ""android/view/accessibility/AccessibilityNodeInfo.java""
      ) {
        sdkInt in 26..27
      }
    }
  },

  ASSIST_STRUCTURE {
    override fun add(references: MutableList<ReferenceMatcher>) {
      references += instanceFieldLeak(
          ""android.app.assist.AssistStructure\$ViewNodeText"", ""mText""
          ,
          description = ""AssistStructure (google assistant / autofill) holds on to text spannables"" +
              "" on the screen. TextView.ChangeWatcher and android.widget.Editor end up in spans and"" +
              "" typically hold on to the view hierarchy""
      ) {
        sdkInt in 24..29
      }
    }
  },

  ACCESSIBILITY_ITERATORS {
    override fun add(references: MutableList<ReferenceMatcher>) {
      references += instanceFieldLeak(
          ""android.widget.AccessibilityIterators\$LineTextSegmentIterator"", ""mLayout""
          ,
          description = ""AccessibilityIterators holds on to text layouts which can hold on to spans"" +
              "" TextView.ChangeWatcher and android.widget.Editor end up in spans and"" +
              "" typically hold on to the view hierarchy""
      ) {
        sdkInt == 27
      }
    }
  },

  BIOMETRIC_PROMPT {
    override fun add(references: MutableList<ReferenceMatcher>) {
      references += instanceFieldLeak(
          ""android.hardware.biometrics.BiometricPrompt"", ""mFingerprintManager""
          ,
          description = ""BiometricPrompt holds on to a FingerprintManager which holds on to a "" +
              ""destroyed activity.""
      ) {
        sdkInt == 28
      }
    }
  },

  MAGNIFIER {
    override fun add(references: MutableList<ReferenceMatcher>) {
      references += instanceFieldLeak(
          ""android.widget.Magnifier\$InternalPopupWindow"", ""mCallback""
          ,
          description = ""android.widget.Magnifier.InternalPopupWindow registers a frame callback"" +
              "" on android.view.ThreadedRenderer.SimpleRenderer which holds it as a native"" +
              "" reference. android.widget.Editor\$InsertionHandleView registers an"" +
              "" OnOperationCompleteCallback on Magnifier.InternalPopupWindow. These references are"" +
              "" held after the activity has been destroyed.""
      ) {
        sdkInt == 28
      }
    }
  },

  BACKDROP_FRAME_RENDERER__MDECORVIEW {
    override fun add(
      references: MutableList<ReferenceMatcher>
    ) {
      references += instanceFieldLeak(
          ""com.android.internal.policy.BackdropFrameRenderer"", ""mDecorView""
          ,
          description =
          ""When BackdropFrameRenderer.releaseRenderer() is called, there's an unknown case""
              + "" where mRenderer becomes null but mChoreographer doesn't and the thread doesn't""
              + "" stop and ends up leaking mDecorView which itself holds on to a destroyed""
              + "" activity""
      ) {
        sdkInt in 24..26
      }
    }
  },

  VIEWLOCATIONHOLDER_ROOT {
    override fun add(
      references: MutableList<ReferenceMatcher>
    ) {
      references += instanceFieldLeak(
          ""android.view.ViewGroup\$ViewLocationHolder"",
          ""mRoot""
          ,
          description = ""In Android P, ViewLocationHolder has an mRoot field that is not cleared "" +
              ""in its clear() method. Introduced in https://github.com/aosp-mirror"" +
              ""/platform_frameworks_base/commit/86b326012813f09d8f1de7d6d26c986a909d Bug "" +
              ""report: https://issuetracker.google.com/issues/112792715""
      ) {
        sdkInt == 28
      }
    }
  },

  ACCESSIBILITY_NODE_ID_MANAGER {
    override fun add(references: MutableList<ReferenceMatcher>) {
      references += instanceFieldLeak(
          ""android.view.accessibility.AccessibilityNodeIdManager"", ""mIdsToViews""
          ,
          description = """"""
              Android Q Beta added AccessibilityNodeIdManager which stores all views from their
              onAttachedToWindow() call, until detached. Unfortunately it's possible to trigger
              the view framework to call detach before attach (by having a view removing itself
              from its parent in onAttach, which then causes AccessibilityNodeIdManager to keep
              children view forever. Future releases of Q will hold weak references.
            """""".trimIndent()
      ) {
        sdkInt in 28..29
      }
    }
  },

  TEXT_TO_SPEECH {
    override fun add(
      references: MutableList<ReferenceMatcher>
    ) {
      val description =
        (""TextToSpeech.shutdown() does not release its references to context objects."" +
            "" Furthermore, TextToSpeech instances cannot be garbage collected due to other process"" +
            "" keeping the references, resulting the context objects leaked."" +
            "" Developers might be able to mitigate the issue by passing application context"" +
            "" to TextToSpeech constructor."" +
            "" Tracked at: https://github.com/square/leakcanary/issues/1210 and"" +
            "" https://issuetracker.google.com/issues/129250419"")
      references += instanceFieldLeak(
          ""android.speech.tts.TextToSpeech"", ""mContext"",
          description = description
      ) {
        sdkInt == 24
      }

      references += instanceFieldLeak(
          ""android.speech.tts.TtsEngines"", ""mContext"",
          description = description
      ) {
        sdkInt == 24
      }
    }
  },

  WINDOW_MANAGER_GLOBAL {
    override fun add(references: MutableList<ReferenceMatcher>) {
      references += instanceFieldLeak(
          ""android.view.WindowManagerGlobal"", ""mRoots""
          ,
          description = """"""
              ViewRootImpl references a destroyed activity yet it's not detached (still has a view)
               and WindowManagerGlobal still references it.
            """""".trimIndent()
      ) {
        sdkInt == 27
      }
    }
  },

  CONTROLLED_INPUT_CONNECTION_WRAPPER {
    override fun add(references: MutableList<ReferenceMatcher>) {
      references += nativeGlobalVariableLeak(
          ""android.view.inputmethod.InputMethodManager\$ControlledInputConnectionWrapper"",
          description = """"""
        ControlledInputConnectionWrapper is held by a global variable in native code. 
      """""".trimIndent()
      )
    }
  },

  TOAST_TN {
    override fun add(references: MutableList<ReferenceMatcher>) {
      references += nativeGlobalVariableLeak(
          ""android.widget.Toast\$TN"",
          description = """"""
        Toast.TN is held by a global variable in native code due to an IPC call to show the toast.
      """""".trimIndent()
      )
    }
  },

  // ######## Manufacturer specific known leaks ########

  // SAMSUNG

  SPEN_GESTURE_MANAGER {
    override fun add(
      references: MutableList<ReferenceMatcher>
    ) {
      references += staticFieldLeak(
          ""com.samsung.android.smartclip.SpenGestureManager"", ""mContext""
          ,
          description =
          ""SpenGestureManager has a static mContext field that leaks a reference to the"" + "" activity. Yes, a STATIC mContext field.""
      ) {
        manufacturer == SAMSUNG && sdkInt == 19
      }
    }
  },

  CLIPBOARD_UI_MANAGER__SINSTANCE {
    override fun add(
      references: MutableList<ReferenceMatcher>
    ) {
      references += instanceFieldLeak(
          ""android.sec.clipboard.ClipboardUIManager"", ""mContext""
          ,
          description =
          ""ClipboardUIManager is a static singleton that leaks an activity context.""
              + "" Fix: trigger a call to ClipboardUIManager.getInstance() in Application.onCreate()""
              + "" , so that the ClipboardUIManager instance gets cached with a reference to the""
              + "" application context. Example: https://gist.github.com/cypressious/""
              + ""91c4fb1455470d803a602838dfcd5774""
      ) {
        manufacturer == SAMSUNG && sdkInt in 19..21
      }
    }
  },

  SEM_CLIPBOARD_MANAGER__MCONTEXT {
    override fun add(
      references: MutableList<ReferenceMatcher>
    ) {
      val description = """"""
         SemClipboardManager inner classes are held by native references due to IPC calls 
      """""".trimIndent()
      references += nativeGlobalVariableLeak(
          ""com.samsung.android.content.clipboard.SemClipboardManager$1"", description
      ) {
        manufacturer == SAMSUNG && sdkInt in 19..28
      }
      references += nativeGlobalVariableLeak(
          ""com.samsung.android.content.clipboard.SemClipboardManager$3"", description
      ) {
        manufacturer == SAMSUNG && sdkInt in 19..28
      }
    }
  },

  CLIPBOARD_EX_MANAGER {
    override fun add(
      references: MutableList<ReferenceMatcher>
    ) {
      references += instanceFieldLeak(
          ""android.sec.clipboard.ClipboardExManager"", ""mContext"",
          description = ""android.sec.clipboard.ClipboardExManager\$IClipboardDataPasteEventImpl\$1"" +
              "" is a native callback that holds IClipboardDataPasteEventImpl which holds"" +
              "" ClipboardExManager which has a destroyed activity as mContext""
      ) {
        manufacturer == SAMSUNG && sdkInt == 23
      }
      references += instanceFieldLeak(
          ""android.sec.clipboard.ClipboardExManager"", ""mPersonaManager"",
          description = ""android.sec.clipboard.ClipboardExManager\$IClipboardDataPasteEventImpl\$1"" +
              "" is a native callback that holds IClipboardDataPasteEventImpl which holds"" +
              "" ClipboardExManager which holds PersonaManager which has a destroyed activity as"" +
              "" mContext""
      ) {
        manufacturer == SAMSUNG && sdkInt == 23
      }
      references += instanceFieldLeak(
          ""android.widget.TextView\$IClipboardDataPasteEventImpl"", ""this\$0"",
          description = ""TextView\$IClipboardDataPasteEventImpl\$1 is held by a native ref, and"" +
              "" IClipboardDataPasteEventImpl ends up leaking a detached textview""
      ) {
        manufacturer == SAMSUNG && sdkInt == 22
      }
    }
  },

  SEM_EMERGENCY_MANAGER__MCONTEXT {
    override fun add(
      references: MutableList<ReferenceMatcher>
    ) {
      references += instanceFieldLeak(
          ""com.samsung.android.emergencymode.SemEmergencyManager"", ""mContext""
          ,
          description =
          ""SemEmergencyManager is a static singleton that leaks a DecorContext."" +
              "" Fix: https://gist.github.com/jankovd/a210460b814c04d500eb12025902d60d""
      ) {
        manufacturer == SAMSUNG && sdkInt in 19..24
      }
    }
  },

  SEM_PERSONA_MANAGER {
    override fun add(references: MutableList<ReferenceMatcher>) {
      references += instanceFieldLeak(
          ""com.samsung.android.knox.SemPersonaManager"", ""mContext""
      ) {
        manufacturer == SAMSUNG && sdkInt == 24
      }
    }
  },

  SEM_APP_ICON_SOLUTION {
    override fun add(references: MutableList<ReferenceMatcher>) {
      references += instanceFieldLeak(
          ""android.app.SemAppIconSolution"", ""mContext""
      ) {
        manufacturer == SAMSUNG && sdkInt == 28
      }
    }
  },

  AW_RESOURCE__SRESOURCES {
    override fun add(
      references: MutableList<ReferenceMatcher>
    ) {
      // AwResource#setResources() is called with resources that hold a reference to the
      // activity context (instead of the application context) and doesn't clear it.
      // Not sure what's going on there, input welcome.
      references += staticFieldLeak(
          ""com.android.org.chromium.android_webview.AwResource"", ""sResources""
      ) {
        manufacturer == SAMSUNG && sdkInt == 19
      }
    }
  },

  TEXT_VIEW__MLAST_HOVERED_VIEW {
    override fun add(
      references: MutableList<ReferenceMatcher>
    ) {
      references += staticFieldLeak(
          ""android.widget.TextView"", ""mLastHoveredView"",
          description =
          ""mLastHoveredView is a static field in TextView that leaks the last hovered"" + "" view.""
      ) {
        manufacturer == SAMSUNG && sdkInt in 19..28
      }
    }
  },

  PERSONA_MANAGER {
    override fun add(
      references: MutableList<ReferenceMatcher>
    ) {
      references += instanceFieldLeak(
          ""android.os.PersonaManager"", ""mContext"",
          description =
          ""android.app.LoadedApk.mResources has a reference to""
              + "" android.content.res.Resources.mPersonaManager which has a reference to""
              + "" android.os.PersonaManager.mContext which is an activity.""
      ) {
        manufacturer == SAMSUNG && sdkInt == 19
      }
    }
  },

  RESOURCES__MCONTEXT {
    override fun add(
      references: MutableList<ReferenceMatcher>
    ) {
      references += instanceFieldLeak(
          ""android.content.res.Resources"", ""mContext"",
          description =
          ""In AOSP the Resources class does not have a context.""
              + "" Here we have ZygoteInit.mResources (static field) holding on to a Resources""
              + "" instance that has a context that is the activity.""
              + "" Observed here: https://github.com/square/leakcanary/issues/1#issue-74450184""
      ) {
        manufacturer == SAMSUNG && sdkInt == 19
      }
    }
  },

  VIEW_CONFIGURATION__MCONTEXT {
    override fun add(
      references: MutableList<ReferenceMatcher>
    ) {
      references += instanceFieldLeak(
          ""android.view.ViewConfiguration"", ""mContext"",
          description =
          ""In AOSP the ViewConfiguration class does not have a context.""
              + "" Here we have ViewConfiguration.sConfigurations (static field) holding on to a""
              + "" ViewConfiguration instance that has a context that is the activity.""
              + "" Observed here: https://github.com/square/leakcanary/issues""
              + ""/1#issuecomment-100324683""
      ) {
        manufacturer == SAMSUNG && sdkInt == 19
      }
    }
  },

  AUDIO_MANAGER__MCONTEXT_STATIC {
    override fun add(
      references: MutableList<ReferenceMatcher>
    ) {
      references += staticFieldLeak(
          ""android.media.AudioManager"", ""mContext_static"",
          description =
          ""Samsung added a static mContext_static field to AudioManager, holds a reference""
              + "" to the activity.""
              + "" Observed here: https://github.com/square/leakcanary/issues/32""
      ) {
        manufacturer == SAMSUNG && sdkInt == 19
      }
    }
  },

  ACTIVITY_MANAGER_MCONTEXT {
    override fun add(
      references: MutableList<ReferenceMatcher>
    ) {
      references += staticFieldLeak(
          ""android.app.ActivityManager"", ""mContext"",
          description =
          ""Samsung added a static mContext field to ActivityManager, holds a reference""
              + "" to the activity.""
              + "" Observed here: https://github.com/square/leakcanary/issues/177 Fix in comment:""
              + "" https://github.com/square/leakcanary/issues/177#issuecomment-222724283""
      ) {
        manufacturer == SAMSUNG && sdkInt in 22..23
      }
    }
  },

  STATIC_MTARGET_VIEW {
    override fun add(
      references: MutableList<ReferenceMatcher>
    ) {
      references += staticFieldLeak(
          ""android.widget.TextView"", ""mTargetView"",
          description =
          ""Samsung added a static mTargetView field to TextView which holds on to detached views.""
      ) {
        manufacturer == SAMSUNG && sdkInt == 27
      }
    }
  },

  MULTI_WINDOW_DECOR_SUPPORT__MWINDOW {
    override fun add(
      references: MutableList<ReferenceMatcher>
    ) {
      references += instanceFieldLeak(
          ""com.android.internal.policy.MultiWindowDecorSupport"", ""mWindow"",
          description = """"""DecorView isn't leaking but its mDecorViewSupport field holds
            |a MultiWindowDecorSupport which has a mWindow field which holds a leaking PhoneWindow.
            |DecorView.mDecorViewSupport doesn't exist in AOSP.
            |Filed here: https://github.com/square/leakcanary/issues/1819
          """""".trimMargin()
      ) {
        manufacturer == SAMSUNG && sdkInt in 26..29
      }
    }
  },

  // OTHER MANUFACTURERS

  GESTURE_BOOST_MANAGER {
    override fun add(
      references: MutableList<ReferenceMatcher>
    ) {
      references += staticFieldLeak(
          ""android.gestureboost.GestureBoostManager"", ""mContext""
          ,
          description =
          ""GestureBoostManager is a static singleton that leaks an activity context."" +
              "" Fix: https://github.com/square/leakcanary/issues/696#issuecomment-296420756""
      ) {
        manufacturer == HUAWEI && sdkInt in 24..25
      }
    }
  },

  BUBBLE_POPUP_HELPER__SHELPER {
    override fun add(
      references: MutableList<ReferenceMatcher>
    ) {
      references += staticFieldLeak(
          ""android.widget.BubblePopupHelper"", ""sHelper"",
          description =
          ""A static helper for EditText bubble popups leaks a reference to the latest"" + "" focused view.""
      ) {
        manufacturer == LG && sdkInt in 19..22
      }
    }
  },

  LGCONTEXT__MCONTEXT {
    override fun add(
      references: MutableList<ReferenceMatcher>
    ) {
      references += instanceFieldLeak(
          ""com.lge.systemservice.core.LGContext"", ""mContext"",
          description = ""LGContext is a static singleton that leaks an activity context.""
      ) {
        manufacturer == LG && sdkInt == 21
      }
    }
  },

  SMART_COVER_MANAGER {
    override fun add(
      references: MutableList<ReferenceMatcher>
    ) {
      references += instanceFieldLeak(
          ""com.lge.systemservice.core.SmartCoverManager"", ""mContext"",
          description = ""SmartCoverManager\$CallbackRegister is a callback held by a native ref,"" +
              "" and SmartCoverManager ends up leaking an activity context.""
      ) {
        manufacturer == LG && sdkInt == 27
      }
    }
  },

  MAPPER_CLIENT {
    override fun add(
      references: MutableList<ReferenceMatcher>
    ) {
      references += instanceFieldLeak(
          ""com.nvidia.ControllerMapper.MapperClient\$ServiceClient"", ""this$0""
          ,
          description =
          ""Not sure exactly what ControllerMapper is about, but there is an anonymous""
              + "" Handler in ControllerMapper.MapperClient.ServiceClient, which leaks""
              + "" ControllerMapper.MapperClient which leaks the activity context.""
      ) {
        manufacturer == NVIDIA && sdkInt == 19
      }
    }
  },

  SYSTEM_SENSOR_MANAGER__MAPPCONTEXTIMPL {
    override fun add(
      references: MutableList<ReferenceMatcher>
    ) {
      references += staticFieldLeak(
          ""android.hardware.SystemSensorManager"", ""mAppContextImpl""
          ,
          description =
          ""SystemSensorManager stores a reference to context""
              + "" in a static field in its constructor.""
              + "" Fix: use application context to get SensorManager""
      ) {
        (manufacturer == LENOVO && sdkInt == 19) || (manufacturer == VIVO && sdkInt == 22)
      }
    }
  },

  INSTRUMENTATION_RECOMMEND_ACTIVITY {
    override fun add(
      references: MutableList<ReferenceMatcher>
    ) {
      references += staticFieldLeak(
          ""android.app.Instrumentation"", ""mRecommendActivity"",
          description =
          ""Instrumentation would leak com.android.internal.app.RecommendActivity (in""
              + "" framework.jar) in Meizu FlymeOS 4.5 and above, which is based on Android 5.0 and ""
              + "" above""
      ) {
        manufacturer == MEIZU && sdkInt in 21..22
      }
    }
  },

  DEVICE_POLICY_MANAGER__SETTINGS_OBSERVER {
    override fun add(
      references: MutableList<ReferenceMatcher>
    ) {
      references += instanceFieldLeak(
          ""android.app.admin.DevicePolicyManager\$SettingsObserver"", ""this$0""
          ,
          description =
          ""DevicePolicyManager keeps a reference to the context it has been created with""
              + "" instead of extracting the application context. In this Motorola build,""
              + "" DevicePolicyManager has an inner SettingsObserver class that is a content""
              + "" observer, which is held into memory by a binder transport object.""
      ) {
        manufacturer == MOTOROLA && sdkInt in 19..22
      }
    }
  },

  EXTENDED_STATUS_BAR_MANAGER {
    override fun add(
      references: MutableList<ReferenceMatcher>
    ) {
      references += staticFieldLeak(
          ""android.app.ExtendedStatusBarManager"", ""sInstance""
          ,
          description =
          """"""
            ExtendedStatusBarManager is held in a static sInstance field and has a mContext
            field which references a decor context which references a destroyed activity.
          """""".trimIndent()
      ) {
        manufacturer == SHARP && sdkInt == 28
      }
    }
  },

  OEM_SCENE_CALL_BLOCKER {
    override fun add(
      references: MutableList<ReferenceMatcher>
    ) {
      references += staticFieldLeak(
          ""com.oneplus.util.OemSceneCallBlocker"", ""sContext"",
          description =
          """"""
            OemSceneCallBlocker has a sContext static field which holds on to an activity instance.
          """""".trimIndent()
      ) {
        manufacturer == ONE_PLUS && sdkInt == 28
      }
    }
  },

  // ######## Ignored references (not leaks) ########

  REFERENCES {
    override fun add(
      references: MutableList<ReferenceMatcher>
    ) {
      references += ignoredInstanceField(WeakReference::class.java.name, ""referent"")
      references += ignoredInstanceField(""leakcanary.KeyedWeakReference"", ""referent"")
      references += ignoredInstanceField(SoftReference::class.java.name, ""referent"")
      references += ignoredInstanceField(PhantomReference::class.java.name, ""referent"")
      references += ignoredInstanceField(""java.lang.ref.Finalizer"", ""prev"")
      references += ignoredInstanceField(""java.lang.ref.Finalizer"", ""element"")
      references += ignoredInstanceField(""java.lang.ref.Finalizer"", ""next"")
      references += ignoredInstanceField(""java.lang.ref.FinalizerReference"", ""prev"")
      references += ignoredInstanceField(""java.lang.ref.FinalizerReference"", ""element"")
      references += ignoredInstanceField(""java.lang.ref.FinalizerReference"", ""next"")
      references += ignoredInstanceField(""sun.misc.Cleaner"", ""prev"")
      references += ignoredInstanceField(""sun.misc.Cleaner"", ""next"")
    }
  },

  FINALIZER_WATCHDOG_DAEMON {
    override fun add(
      references: MutableList<ReferenceMatcher>
    ) {
      // If the FinalizerWatchdogDaemon thread is on the shortest path, then there was no other
      // reference to the object and it was about to be GCed.
      references += ignoredJavaLocal(""FinalizerWatchdogDaemon"")
    }
  },

  MAIN {
    override fun add(
      references: MutableList<ReferenceMatcher>
    ) {
      // The main thread stack is ever changing so local variables aren't likely to hold references
      // for long. If this is on the shortest path, it's probably that there's a longer path with
      // a real leak.
      references += ignoredJavaLocal(""main"")
    }
  },

  LEAK_CANARY_THREAD {
    override fun add(
      references: MutableList<ReferenceMatcher>
    ) {
      references += ignoredJavaLocal(LEAK_CANARY_THREAD_NAME)
    }
  },

  LEAK_CANARY_HEAP_DUMPER {
    override fun add(references: MutableList<ReferenceMatcher>) {
      // Holds on to the resumed activity (which is never destroyed), so this will not cause leaks
      // but may surface on the path when a resumed activity holds on to destroyed objects.
      // Would have a path that doesn't include LeakCanary instead.
      references += ignoredInstanceField(""leakcanary.internal.AndroidHeapDumper"", ""resumedActivity"")
    }
  },

  LEAK_CANARY_INTERNAL {
    override fun add(references: MutableList<ReferenceMatcher>) {
      references += ignoredInstanceField(""leakcanary.internal.InternalLeakCanary"", ""application"")
    }
  },

  EVENT_RECEIVER__MMESSAGE_QUEUE {
    override fun add(
      references: MutableList<ReferenceMatcher>
    ) {
      //  DisplayEventReceiver keeps a reference message queue object so that it is not GC'd while
      // the native peer of the receiver is using them.
      // The main thread message queue is held on by the main Looper, but that might be a longer
      // path. Let's not confuse people with a shorter path that is less meaningful.
      references += ignoredInstanceField(
          ""android.view.Choreographer\$FrameDisplayEventReceiver"", ""mMessageQueue""
      )
    }
  },

  ;

  internal abstract fun add(references: MutableList<ReferenceMatcher>)

  companion object {
    private const val LEAK_CANARY_THREAD_NAME = ""LeakCanary-Heap-Dump""
    const val SAMSUNG = ""samsung""
    const val MOTOROLA = ""motorola""
    const val LENOVO = ""LENOVO""
    const val LG = ""LGE""
    const val NVIDIA = ""NVIDIA""
    const val MEIZU = ""Meizu""
    const val ONE_PLUS = ""OnePlus""
    const val HUAWEI = ""HUAWEI""
    const val VIVO = ""vivo""
    const val SHARP = ""SHARP""

    /**
     * Returns a list of [ReferenceMatcher] that only contains [IgnoredReferenceMatcher] and no
     * [LibraryLeakReferenceMatcher].
     */
    val ignoredReferencesOnly: List<ReferenceMatcher>
      get() = buildKnownReferences(
          EnumSet.of(
              REFERENCES,
              FINALIZER_WATCHDOG_DAEMON,
              MAIN,
              LEAK_CANARY_THREAD,
              EVENT_RECEIVER__MMESSAGE_QUEUE
          )
      )

    /**
     * @see [AndroidReferenceMatchers]
     */
    val appDefaults: List<ReferenceMatcher>
      get() = buildKnownReferences(EnumSet.allOf(AndroidReferenceMatchers::class.java))

    /**
     * Builds a list of [ReferenceMatcher] from the [referenceMatchers] set of
     * [AndroidReferenceMatchers].
     */
    fun buildKnownReferences(referenceMatchers: Set<AndroidReferenceMatchers>): List<ReferenceMatcher> {
      val resultSet = mutableListOf<ReferenceMatcher>()
      referenceMatchers.forEach {
        it.add(resultSet)
      }
      return resultSet
    }

    private val ALWAYS: AndroidBuildMirror.() -> Boolean = {
      true
    }

    /**
     * Creates a [LibraryLeakReferenceMatcher] that matches a [StaticFieldPattern].
     * [description] should convey what we know about this library leak.
     */
    fun staticFieldLeak(
      className: String,
      fieldName: String,
      description: String = """",
      patternApplies: AndroidBuildMirror.() -> Boolean = ALWAYS
    ): LibraryLeakReferenceMatcher {
      return libraryLeak(StaticFieldPattern(className, fieldName), description, patternApplies)
    }

    /**
     * Creates a [LibraryLeakReferenceMatcher] that matches a [InstanceFieldPattern].
     * [description] should convey what we know about this library leak.
     */
    fun instanceFieldLeak(
      className: String,
      fieldName: String,
      description: String = """",
      patternApplies: AndroidBuildMirror.() -> Boolean = ALWAYS
    ): LibraryLeakReferenceMatcher {
      return libraryLeak(InstanceFieldPattern(className, fieldName), description, patternApplies)
    }

    fun nativeGlobalVariableLeak(
      className: String,
      description: String = """",
      patternApplies: AndroidBuildMirror.() -> Boolean = ALWAYS
    ): LibraryLeakReferenceMatcher {
      return libraryLeak(NativeGlobalVariablePattern(className), description, patternApplies)
    }

    private fun libraryLeak(
      referencePattern: ReferencePattern,
      description: String,
      patternApplies: AndroidBuildMirror.() -> Boolean
    ): LibraryLeakReferenceMatcher {
      return LibraryLeakReferenceMatcher(
          pattern = referencePattern,
          description = description,
          patternApplies = { graph ->
            AndroidBuildMirror.fromHeapGraph(graph)
                .patternApplies()
          }
      )
    }

    /**
     * Creates a [IgnoredReferenceMatcher] that matches a [InstanceFieldPattern].
     */
    fun ignoredInstanceField(
      className: String,
      fieldName: String
    ): IgnoredReferenceMatcher {
      return IgnoredReferenceMatcher(pattern = InstanceFieldPattern(className, fieldName))
    }

    /**
     * Creates a [IgnoredReferenceMatcher] that matches a [JavaLocalPattern].
     */
    fun ignoredJavaLocal(
      threadName: String
    ): IgnoredReferenceMatcher {
      return IgnoredReferenceMatcher(pattern = JavaLocalPattern(threadName))
    }
  }

}",KOT_04141,CWE-321: Hard-coded Cryptographic Key,A02: Cryptographic Failures;A04: Insecure Design,1
duckduckgo__Android,9a6b40b3a0e2fa8663dc993f0f4a67e85b0a6b89,autofill/autofill-impl/src/test/java/com/duckduckgo/autofill/impl/securestorage/RealL2DataTransformerTest.kt,.kt,Mike Scamell,mikescamell@users.noreply.github.com,2025-10-01T17:04:53+01:00,Rollback Ktlint update (#6865),1,,"/*
 * Copyright (c) 2023 DuckDuckGo
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.duckduckgo.securestorage

import androidx.test.ext.junit.runners.AndroidJUnit4
import com.duckduckgo.autofill.impl.securestorage.RealL2DataTransformer
import com.duckduckgo.autofill.impl.securestorage.SecureStorageKeyProvider
import com.duckduckgo.common.test.CoroutineTestRule
import java.security.Key
import kotlinx.coroutines.test.runTest
import org.junit.Assert.assertEquals
import org.junit.Assert.assertFalse
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith
import org.mockito.Mockito.mock
import org.mockito.MockitoAnnotations
import org.mockito.kotlin.whenever

@RunWith(AndroidJUnit4::class)
class RealL2DataTransformerTest {
    @get:Rule
    var coroutineRule = CoroutineTestRule()

    private lateinit var testee: RealL2DataTransformer
    private lateinit var encryptionHelper: FakeEncryptionHelper

    private val secureStorageKeyProvider: SecureStorageKeyProvider = mock()

    @Before
    fun setUp() = runTest {
        MockitoAnnotations.openMocks(this)
        val key = mock(Key::class.java)
        whenever(secureStorageKeyProvider.getl2Key()).thenReturn(key)
        encryptionHelper = FakeEncryptionHelper(expectedEncryptedData, expectedEncryptedIv, expectedDecryptedData)
        testee = RealL2DataTransformer(encryptionHelper, secureStorageKeyProvider, coroutineRule.testScope, coroutineRule.testDispatcherProvider)
    }

    @Test
    fun whenCanProcessDataThenReturnCanAccessKeyStoreTrue() = runTest {
        whenever(secureStorageKeyProvider.canAccessKeyStore()).thenReturn(true)

        assertTrue(testee.canProcessData())
    }

    @Test
    fun whenCanProcessDataFalseThenReturnCanAccessKeyStoreFalse() = runTest {
        whenever(secureStorageKeyProvider.canAccessKeyStore()).thenReturn(false)

        assertFalse(testee.canProcessData())
    }

    @Test
    fun whenDataIsEncryptedThenDelegateEncryptionToEncryptionHelper() = runTest {
        val result = testee.encrypt(""test123"")

        assertEquals(expectedEncryptedData, result.data)
        assertEquals(expectedEncryptedIv, result.iv)
    }

    @Test
    fun whenDataIsDecryptedThenDelegateDecryptionToEncryptionHelper() = runTest {
        val result = testee.decrypt(""test123"", ""iv"")

        assertEquals(decodedDecryptedData, result)
    }

    companion object {
        private const val expectedEncryptedData: String = ""ZXhwZWN0ZWRFbmNyeXB0ZWREYXRh""
        private const val expectedEncryptedIv: String = ""ZXhwZWN0ZWRFbmNyeXB0ZWRJVg==""
        private const val expectedDecryptedData: String = ""ZXhwZWN0ZWREZWNyeXB0ZWREYXRh""
        private const val decodedDecryptedData: String = ""expectedDecryptedData""
    }
}
",KSEC_0874,['CWE-321: Hard-coded Cryptographic Key'],"['A02: Cryptographic Failures', 'A04: Insecure Design']",1
bitwarden__android,dd0f08d75953ba4d6ed0445594594eefc03610b2,app/src/test/java/com/x8bit/bitwarden/data/auth/datasource/network/service/OrganizationServiceTest.kt,.kt,Patrick Honkonen,1883101+SaintPatrck@users.noreply.github.com,2025-04-10T16:42:26-04:00,[PM-19864] Migrate UnauthenticatedOrganizationApi to `network` module (#5019),1,,"package com.x8bit.bitwarden.data.auth.datasource.network.service

import com.bitwarden.core.data.util.asSuccess
import com.bitwarden.network.api.AuthenticatedOrganizationApi
import com.bitwarden.network.base.BaseServiceTest
import com.bitwarden.network.model.OrganizationAutoEnrollStatusResponseJson
import com.bitwarden.network.model.OrganizationKeysResponseJson
import com.x8bit.bitwarden.data.auth.datasource.network.api.UnauthenticatedOrganizationApi
import com.x8bit.bitwarden.data.auth.datasource.network.model.OrganizationDomainSsoDetailsResponseJson
import com.x8bit.bitwarden.data.auth.datasource.network.model.VerifiedOrganizationDomainSsoDetailsResponse
import kotlinx.coroutines.test.runTest
import okhttp3.mockwebserver.MockResponse
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.Test
import retrofit2.create
import java.time.ZonedDateTime

class OrganizationServiceTest : BaseServiceTest() {
    private val authenticatedOrganizationApi: AuthenticatedOrganizationApi = retrofit.create()
    private val unauthenticatedOrganizationApi: UnauthenticatedOrganizationApi = retrofit.create()

    private val organizationService = OrganizationServiceImpl(
        authenticatedOrganizationApi = authenticatedOrganizationApi,
        unauthenticatedOrganizationApi = unauthenticatedOrganizationApi,
    )

    @Test
    fun `organizationResetPasswordEnroll when response is success should return Unit as success`() =
        runTest {
            server.enqueue(MockResponse().setResponseCode(200))
            val result = organizationService.organizationResetPasswordEnroll(
                organizationId = ""orgId"",
                userId = ""userId"",
                passwordHash = ""passwordHash"",
                resetPasswordKey = ""resetPasswordKey"",
            )
            assertEquals(Unit.asSuccess(), result)
        }

    @Test
    fun `organizationResetPasswordEnroll when response is an error should return an error`() =
        runTest {
            server.enqueue(MockResponse().setResponseCode(400))
            val result = organizationService.organizationResetPasswordEnroll(
                organizationId = ""orgId"",
                userId = ""userId"",
                passwordHash = ""passwordHash"",
                resetPasswordKey = ""resetPasswordKey"",
            )
            assertTrue(result.isFailure)
        }

    @Suppress(""MaxLineLength"")
    @Test
    fun `getOrganizationDomainSsoDetails when response is success should return PrevalidateSsoResponseJson`() =
        runTest {
            val email = ""test@gmail.com""
            server.enqueue(
                MockResponse()
                    .setResponseCode(200)
                    .setBody(ORGANIZATION_DOMAIN_SSO_DETAILS_JSON),
            )
            val result = organizationService.getOrganizationDomainSsoDetails(email)
            assertEquals(ORGANIZATION_DOMAIN_SSO_BODY.asSuccess(), result)
        }

    @Test
    fun `getOrganizationDomainSsoDetails when response is an error should return an error`() =
        runTest {
            val email = ""test@gmail.com""
            server.enqueue(MockResponse().setResponseCode(400))
            val result = organizationService.getOrganizationDomainSsoDetails(email)
            assertTrue(result.isFailure)
        }

    @Test
    fun `getOrganizationAutoEnrollStatus when response is success should return valid response`() =
        runTest {
            server.enqueue(
                MockResponse()
                    .setResponseCode(200)
                    .setBody(ORGANIZATION_AUTO_ENROLL_STATUS_JSON),
            )
            val result = organizationService.getOrganizationAutoEnrollStatus(""orgId"")
            assertEquals(ORGANIZATION_AUTO_ENROLL_STATUS_RESPONSE.asSuccess(), result)
        }

    @Test
    fun `getOrganizationAutoEnrollStatus when response is an error should return an error`() =
        runTest {
            server.enqueue(MockResponse().setResponseCode(400))
            val result = organizationService.getOrganizationAutoEnrollStatus(""orgId"")
            assertTrue(result.isFailure)
        }

    @Test
    fun `getOrganizationKeys when response is success should return valid response`() = runTest {
        server.enqueue(
            MockResponse()
                .setResponseCode(200)
                .setBody(ORGANIZATION_KEYS_JSON),
        )
        val result = organizationService.getOrganizationKeys(""orgId"")
        assertEquals(ORGANIZATION_KEYS_RESPONSE.asSuccess(), result)
    }

    @Test
    fun `getOrganizationKeys when response is an error should return an error`() = runTest {
        server.enqueue(MockResponse().setResponseCode(400))
        val result = organizationService.getOrganizationKeys(""orgId"")
        assertTrue(result.isFailure)
    }

    @Suppress(""MaxLineLength"")
    @Test
    fun `getVerifiedOrganizationDomainSsoDetails when response is success should return valid response`() =
        runTest {
            server.enqueue(
                MockResponse()
                    .setResponseCode(200)
                    .setBody(ORGANIZATION_VERIFIED_DOMAIN_SSO_DETAILS_JSON),
            )
            val result =
                organizationService.getVerifiedOrganizationDomainSsoDetails(""example@bitwarden.com"")
            assertEquals(ORGANIZATION_VERIFIED_DOMAIN_SSO_DETAILS_RESPONSE.asSuccess(), result)
        }

    @Suppress(""MaxLineLength"")
    @Test
    fun `getVerifiedOrganizationDomainSsoDetails when response is an error should return an error`() =
        runTest {
            server.enqueue(MockResponse().setResponseCode(400))
            val result =
                organizationService.getVerifiedOrganizationDomainSsoDetails(""example@bitwarden.com"")
            assertTrue(result.isFailure)
        }
}

private const val ORGANIZATION_AUTO_ENROLL_STATUS_JSON = """"""
{
  ""id"": ""orgId"",
  ""resetPasswordEnabled"": true
}
""""""

private val ORGANIZATION_AUTO_ENROLL_STATUS_RESPONSE = OrganizationAutoEnrollStatusResponseJson(
    organizationId = ""orgId"",
    isResetPasswordEnabled = true,
)

private const val ORGANIZATION_DOMAIN_SSO_DETAILS_JSON = """"""
{
  ""ssoAvailable"": true,
  ""domainName"": ""bitwarden.com"",
  ""organizationIdentifier"": ""Test Org"",
  ""ssoRequired"": false,
  ""verifiedDate"": ""2024-09-13T00:00:00.000Z""
}
""""""

private val ORGANIZATION_DOMAIN_SSO_BODY = OrganizationDomainSsoDetailsResponseJson(
    isSsoAvailable = true,
    organizationIdentifier = ""Test Org"",
    verifiedDate = ZonedDateTime.parse(""2024-09-13T00:00:00.000Z""),
)

private const val ORGANIZATION_KEYS_JSON = """"""
{
  ""privateKey"": ""privateKey"",
  ""publicKey"": ""publicKey""
}
""""""

private val ORGANIZATION_KEYS_RESPONSE = OrganizationKeysResponseJson(
    privateKey = ""privateKey"",
    publicKey = ""publicKey"",
)

private const val ORGANIZATION_VERIFIED_DOMAIN_SSO_DETAILS_JSON = """"""
{
  ""data"": [
    {
      ""organizationIdentifier"": ""Test Identifier"",
      ""organizationName"": ""Bitwarden"",
      ""domainName"": ""bitwarden.com""
    }
  ]
}
""""""

private val ORGANIZATION_VERIFIED_DOMAIN_SSO_DETAILS_RESPONSE =
    VerifiedOrganizationDomainSsoDetailsResponse(
        verifiedOrganizationDomainSsoDetails = listOf(
            VerifiedOrganizationDomainSsoDetailsResponse.VerifiedOrganizationDomainSsoDetail(
                organizationIdentifier = ""Test Identifier"",
                organizationName = ""Bitwarden"",
                domainName = ""bitwarden.com"",
            ),
        ),
    )
",KSEC_0288,['CWE-321: Hard-coded Cryptographic Key'],"['A02: Cryptographic Failures', 'A04: Insecure Design']",1
Kunzisoft__KeePassDX,404fb9b39f433b3aadfb18c907d2dd49d1371cba,app/src/androidTest/java/com/kunzisoft/keepass/tests/PwDateTest.kt,.kt,J-Jamet,jeremy.jamet@kunzisoft.com,2019-07-22T11:53:12+02:00,Change licence in XML and .kt files,1,,"/*
 * Copyright 2019 Jeremy Jamet / Kunzisoft.
 *
 * This file is part of KeePass DX.
 *
 *  KeePass DX is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  KeePass DX is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePass DX.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.kunzisoft.keepass.tests

import junit.framework.TestCase

import com.kunzisoft.keepass.database.element.PwDate
import org.junit.Assert

class PwDateTest : TestCase() {

    fun testDate() {
        val jDate = PwDate(System.currentTimeMillis())
        val intermediate = PwDate(jDate)
        val cDate = PwDate(intermediate.byteArrayDate!!, 0)

        Assert.assertTrue(""jDate and intermediate not equal"", jDate == intermediate)
        Assert.assertTrue(""jDate and cDate not equal"", cDate == jDate)
    }
}
",KSEC_0373,,,0
duckduckgo__Android,23d248737c29091c415e3db55b42fb08f3aa7ed4,fingerprint-protection/fingerprint-protection-store/src/main/java/com/duckduckgo/fingerprintprotection/store/features/fingerprintingtemporarystorage/FingerprintingTemporaryStorageRepository.kt,.kt,Aitor Viana,aitorvs@gmail.com,2024-02-19T16:31:20+00:00,load privacy plugins data into memory just for main process (#4189),1,RealFingerprintingTemporaryStorageRepository,"class RealFingerprintingTemporaryStorageRepository constructor(
    val database: FingerprintProtectionDatabase,
    val coroutineScope: CoroutineScope,
    val dispatcherProvider: DispatcherProvider,
) : FingerprintingTemporaryStorageRepository {

    private val fingerprintingTemporaryStorageDao: FingerprintingTemporaryStorageDao = database.fingerprintingTemporaryStorageDao()
    override var fingerprintingTemporaryStorageEntity = FingerprintingTemporaryStorageEntity(json = EMPTY_JSON)

    init {
        coroutineScope.launch(dispatcherProvider.io()) {
            loadToMemory()
        }
    }

    override fun updateAll(fingerprintingTemporaryStorageEntity: FingerprintingTemporaryStorageEntity) {
        fingerprintingTemporaryStorageDao.updateAll(fingerprintingTemporaryStorageEntity)
        loadToMemory()
    }

    private fun loadToMemory() {
        fingerprintingTemporaryStorageEntity =
            fingerprintingTemporaryStorageDao.get() ?: FingerprintingTemporaryStorageEntity(json = EMPTY_JSON)
    }

    companion object {
        const val EMPTY_JSON = ""{}""
    }
}",KSEC_2379,['CWE-321: Hard-coded Cryptographic Key'],"['A02: Cryptographic Failures', 'A04: Insecure Design']",1
duckduckgo__Android,9a6b40b3a0e2fa8663dc993f0f4a67e85b0a6b89,app/src/test/java/com/duckduckgo/app/browser/defaultbrowsing/prompts/store/DefaultBrowserPromptsAppUsageRepositoryImplTest.kt,.kt,Mike Scamell,mikescamell@users.noreply.github.com,2025-10-01T17:04:53+01:00,Rollback Ktlint update (#6865),1,,"/*
 * Copyright (c) 2025 DuckDuckGo
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.duckduckgo.app.browser.defaultbrowsing.prompts.store

import com.duckduckgo.common.test.CoroutineTestRule
import java.time.ZoneId
import java.time.ZonedDateTime
import java.time.format.DateTimeFormatter
import java.time.format.DateTimeParseException
import java.time.temporal.ChronoUnit
import kotlinx.coroutines.test.runTest
import org.junit.Assert
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.mockito.Mock
import org.mockito.MockitoAnnotations
import org.mockito.kotlin.verify
import org.mockito.kotlin.whenever

class DefaultBrowserPromptsAppUsageRepositoryImplTest {

    @get:Rule
    var coroutinesTestRule = CoroutineTestRule()

    @Mock private lateinit var defaultBrowserPromptsAppUsageDaoMock: DefaultBrowserPromptsAppUsageDao

    @Before
    fun setup() {
        MockitoAnnotations.openMocks(this)
    }

    @Test
    fun `when record usage, then insert ET time`() = runTest {
        val expected = DefaultBrowserPromptsAppUsageEntity(
            isoDateET = ZonedDateTime.now(ZoneId.of(""America/New_York""))
                .truncatedTo(ChronoUnit.DAYS)
                .format(DateTimeFormatter.ISO_LOCAL_DATE),
        )
        val testee = DefaultBrowserPromptsAppUsageRepositoryImpl(
            dispatchers = coroutinesTestRule.testDispatcherProvider,
            defaultBrowserPromptsAppUsageDao = defaultBrowserPromptsAppUsageDaoMock,
        )

        testee.recordAppUsedNow()

        verify(defaultBrowserPromptsAppUsageDaoMock).insert(expected)
    }

    @Test
    fun `when active days since enrollment queried and first day is null, return failure`() = runTest {
        whenever(defaultBrowserPromptsAppUsageDaoMock.getFirstDay()).thenReturn(null)
        val testee = DefaultBrowserPromptsAppUsageRepositoryImpl(
            dispatchers = coroutinesTestRule.testDispatcherProvider,
            defaultBrowserPromptsAppUsageDao = defaultBrowserPromptsAppUsageDaoMock,
        )

        val result = testee.getActiveDaysUsedSinceStart()

        assertTrue(result.isFailure)
        assertTrue(result.exceptionOrNull() is IllegalStateException)
    }

    @Test
    fun `when active days since enrollment queried and first day is malformed date, return failure`() = runTest {
        val invalidDate = ""not-a-valid-date""
        whenever(defaultBrowserPromptsAppUsageDaoMock.getFirstDay()).thenReturn(invalidDate)
        val testee = DefaultBrowserPromptsAppUsageRepositoryImpl(
            dispatchers = coroutinesTestRule.testDispatcherProvider,
            defaultBrowserPromptsAppUsageDao = defaultBrowserPromptsAppUsageDaoMock,
        )

        val result = testee.getActiveDaysUsedSinceStart()

        assertTrue(result.isFailure)
        assertTrue(result.exceptionOrNull() is DateTimeParseException)
    }

    @Test
    fun `when active days since enrollment queried and first day is correct, return success`() = runTest {
        val validDate = ""2023-01-01""
        val expectedDaysUsed = 2L
        whenever(defaultBrowserPromptsAppUsageDaoMock.getFirstDay()).thenReturn(validDate)
        whenever(defaultBrowserPromptsAppUsageDaoMock.getNumberOfDaysAppUsedSinceDateET(validDate)).thenReturn(expectedDaysUsed)

        val testee = DefaultBrowserPromptsAppUsageRepositoryImpl(
            dispatchers = coroutinesTestRule.testDispatcherProvider,
            defaultBrowserPromptsAppUsageDao = defaultBrowserPromptsAppUsageDaoMock,
        )

        val result = testee.getActiveDaysUsedSinceStart()

        assertTrue(result.isSuccess)
        Assert.assertEquals(expectedDaysUsed, result.getOrThrow())
    }
}
",KSEC_0725,['CWE-321: Hard-coded Cryptographic Key'],"['A02: Cryptographic Failures', 'A04: Insecure Design']",1
JetBrains__kotlin,21176c2005dc474b35d92ea738e147a1b741d272,compiler/fir/dump/src/org/jetbrains/kotlin/fir/dump/HtmlFirDump.kt,.kt,Fedor Tolstonozhenko,fedor.tolstonozhenko@jetbrains.com,2025-08-31T12:19:34+02:00,Fix deprecation in HtmlFirDump.kt,1,,"/*
 * Copyright 2010-2022 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.fir.dump

import kotlinx.html.*
import kotlinx.html.stream.appendHTML
import org.apache.commons.lang3.StringEscapeUtils
import org.jetbrains.kotlin.descriptors.ClassKind
import org.jetbrains.kotlin.descriptors.Modality
import org.jetbrains.kotlin.descriptors.Visibilities
import org.jetbrains.kotlin.descriptors.Visibility
import org.jetbrains.kotlin.fir.*
import org.jetbrains.kotlin.fir.backend.left
import org.jetbrains.kotlin.fir.backend.right
import org.jetbrains.kotlin.fir.declarations.*
import org.jetbrains.kotlin.fir.declarations.impl.FirDefaultPropertyAccessor
import org.jetbrains.kotlin.fir.declarations.utils.classId
import org.jetbrains.kotlin.fir.declarations.utils.expandedConeType
import org.jetbrains.kotlin.fir.diagnostics.ConeDiagnostic
import org.jetbrains.kotlin.fir.expressions.*
import org.jetbrains.kotlin.fir.expressions.impl.FirElseIfTrueCondition
import org.jetbrains.kotlin.fir.expressions.impl.FirUnitExpression
import org.jetbrains.kotlin.fir.references.*
import org.jetbrains.kotlin.fir.references.impl.FirSimpleNamedReference
import org.jetbrains.kotlin.fir.resolve.diagnostics.ConeAmbiguityError
import org.jetbrains.kotlin.fir.resolve.diagnostics.ConeInapplicableCandidateError
import org.jetbrains.kotlin.fir.resolve.directExpansionType
import org.jetbrains.kotlin.fir.resolve.fullyExpandedType
import org.jetbrains.kotlin.fir.resolve.toSymbol
import org.jetbrains.kotlin.fir.symbols.FirBasedSymbol
import org.jetbrains.kotlin.fir.symbols.impl.FirCallableSymbol
import org.jetbrains.kotlin.fir.symbols.impl.FirClassLikeSymbol
import org.jetbrains.kotlin.fir.symbols.impl.FirTypeAliasSymbol
import org.jetbrains.kotlin.fir.symbols.impl.FirTypeParameterSymbol
import org.jetbrains.kotlin.fir.types.*
import org.jetbrains.kotlin.fir.visitors.FirVisitorVoid
import org.jetbrains.kotlin.name.ClassId
import org.jetbrains.kotlin.name.FqName
import org.jetbrains.kotlin.name.Name
import org.jetbrains.kotlin.resolve.calls.inference.model.NewConstraintError
import org.jetbrains.kotlin.types.AbstractStrictEqualityTypeChecker
import org.jetbrains.kotlin.types.ConstantValueKind
import org.jetbrains.kotlin.types.Variance
import java.io.File
import java.io.Writer


internal interface FirLinkResolver {
    fun nearPackage(fqName: FqName): String?

    fun symbolSignature(symbol: FirBasedSymbol<*>): String
    fun nearSymbolLocation(symbol: FirBasedSymbol<*>): String?

    fun classLocation(classId: ClassId): String?

    fun HEAD.supplementary()
}


private const val PACKAGE_INDEX = ""package-index.html""
private const val MODULE_INDEX = ""module-index.html""
private const val ROOT_INDEX = ""root-index.html""


private fun HEAD.commonHead() {
    meta { charset = ""utf-8"" }
    script(src = ""https://code.jquery.com/jquery-3.4.0.slim.min.js"") {
        integrity = ""sha256-ZaXnYkHGqIhqTbJ6MB4l9Frs/r7U4jlx7ir8PJYBqbI=""
        @Suppress(""SpellCheckingInspection"")
        attributes[""crossorigin""] = ""anonymous""
    }
}


private class PackageInfo(val fqName: FqName, val moduleInfo: ModuleInfo) {
    val contents = LinkedHashSet<String>()
    val packageRoot = fqName.pathSegments().fold(moduleInfo.moduleRoot) { dir, segment -> dir.resolve(segment.asString()) }.also {
        it.mkdirs()
    }
    val errors = mutableMapOf<String, Int>().withDefault { 0 }
    val implicits = mutableMapOf<String, Int>().withDefault { 0 }
    val unresolved = mutableMapOf<String, Int>().withDefault { 0 }
}

private class ModuleInfo(val name: String, outputRoot: File) {
    val packages = mutableMapOf<FqName, PackageInfo>()
    val moduleRoot = outputRoot.resolve(name).also {
        it.mkdirs()
    }
    val errors: Map<FqName, Int> by lazy {
        packages.mapValues { (_, packageInfo) -> packageInfo.errors.values.sum() }.withDefault { 0 }
    }
    val implicits: Map<FqName, Int> by lazy {
        packages.mapValues { (_, packageInfo) -> packageInfo.implicits.values.sum() }.withDefault { 0 }
    }
    val unresolved: Map<FqName, Int> by lazy {
        packages.mapValues { (_, packageInfo) -> packageInfo.unresolved.values.sum() }.withDefault { 0 }
    }
}

private class SupplementaryGenerator(val outputRoot: File) {
    fun generateIndex(moduleInfo: ModuleInfo, writer: Writer) {
        writer.appendHTML().html {
            head {
                title { +moduleInfo.name }
                commonHead()
                supplementary(this, moduleInfo.moduleRoot)
            }
            body {
                h4 {
                    a(
                        href = linkToRootIndex(moduleInfo.moduleRoot),
                        classes = ""container-ref""
                    ) {
                        +""back to root""
                    }
                }
                h2 { +moduleInfo.name }
                ul {
                    for (packageInfo in moduleInfo.packages.values) {
                        li {
                            a(
                                href = linkToIndex(packageInfo, moduleInfo.moduleRoot),
                                classes = ""container-ref""
                            ) {
                                +packageInfo.fqName.asString()
                            }
                            addErrors(
                                moduleInfo.errors.getValue(packageInfo.fqName),
                                moduleInfo.implicits.getValue(packageInfo.fqName),
                                moduleInfo.unresolved.getValue(packageInfo.fqName)
                            )
                        }
                    }
                }
            }
        }
    }

    fun LI.addErrors(errors: Int, implicits: Int, unresolved: Int) {
        if (errors > 0) {
            span(classes = ""error-counter"") { +(errors.toString()) }
        }
        if (implicits > 0) {
            span(classes = ""implicit-counter"") { +(implicits.toString()) }
        }
        if (unresolved > 0) {
            span(classes = ""unresolved-counter"") { +(unresolved.toString()) }
        }
    }

    fun linkToIndex(moduleInfo: ModuleInfo, from: File): String {
        return moduleInfo.moduleRoot.resolve(MODULE_INDEX).relativeTo(from).path
    }

    fun linkToIndex(packageInfo: PackageInfo, from: File): String {
        return packageInfo.packageRoot.resolve(PACKAGE_INDEX).relativeTo(from).path
    }

    fun linkToRootIndex(from: File): String {
        return outputRoot.resolve(ROOT_INDEX).relativeTo(from).path
    }

    fun generateIndex(packageInfo: PackageInfo, writer: Writer) {
        writer.appendHTML().html {
            head {
                title { +packageInfo.fqName.asString() }
                commonHead()
                supplementary(this, packageInfo.packageRoot)
            }
            body {
                h4 {
                    +""In module: ""
                    a(
                        href = linkToIndex(packageInfo.moduleInfo, packageInfo.packageRoot),
                        classes = ""container-ref""
                    ) {
                        +packageInfo.moduleInfo.name
                    }
                }
                h2 { +packageInfo.fqName.asString() }

                ul {
                    for (file in packageInfo.contents) {
                        li {
                            a(href = ""./$file.fir.html"", classes = ""container-ref"") { +file }
                            addErrors(
                                packageInfo.errors.getValue(file),
                                packageInfo.implicits.getValue(file),
                                packageInfo.unresolved.getValue(file)
                            )
                        }
                    }
                }
            }
        }
    }

    fun generateIndex(modules: List<ModuleInfo>, writer: Writer) {
        val title = ""Root dump index""
        writer.appendHTML().html {
            head {
                title { +title }
                commonHead()
                supplementary(this, outputRoot)
            }
            body {
                h2 { +title }

                ul {
                    for (module in modules) {
                        li {
                            a(href = linkToIndex(module, outputRoot), classes = ""container-ref"") { +module.name }
                            addErrors(
                                module.errors.values.sum(),
                                module.implicits.values.sum(),
                                module.unresolved.values.sum()
                            )
                        }
                    }
                }
            }
        }
    }


    fun supplementary(head: HEAD, originDir: File) = with(head) {
        for (file in jsFiles) {
            script(src = outputRoot.resolve(file).relativeTo(originDir).path) {}
        }
        for (styleSheet in cssFiles) {
            styleLink(outputRoot.resolve(styleSheet).relativeTo(originDir).path)
        }
    }
}


private val jsFiles = listOf(""logic.js"")
private val cssFiles = listOf(""style.css"", ""colors.white.css"", ""colors.dark.css"")


class MultiModuleHtmlFirDump(private val outputRoot: File) {

    private val modules = LinkedHashMap<String, ModuleInfo>()

    private lateinit var currentModule: ModuleInfo
    private var inModule = false
    private var finished = false
    private var index = Index()

    fun module(module: String, block: () -> Unit) {
        require(!finished)
        inModule = true
        currentModule = modules.getOrPut(module) {
            ModuleInfo(module, outputRoot)
        }

        block()
        inModule = false
        index = Index()
    }

    private val supplementaryGenerator = SupplementaryGenerator(outputRoot)

    fun finish() {
        require(!finished)
        finished = true
        outputRoot.resolve(ROOT_INDEX).writer().use {
            supplementaryGenerator.generateIndex(modules.values.toList(), it)
        }
        for (module in modules.values) {
            module.moduleRoot.resolve(MODULE_INDEX).writer().use {
                supplementaryGenerator.generateIndex(module, it)
            }
            for (packageInfo in module.packages.values) {
                packageInfo.packageRoot.resolve(PACKAGE_INDEX).writer().use {
                    supplementaryGenerator.generateIndex(packageInfo, it)
                }
            }
        }
        val supplementaryFiles = jsFiles + cssFiles

        for (file in supplementaryFiles) {
            val stream = this::class.java.getResourceAsStream(file)
            outputRoot.resolve(file).outputStream().use { outputStream ->
                stream.copyTo(outputStream)
            }
        }
    }

    private fun locationForFile(firFile: FirFile, packageInfo: PackageInfo = packageForFile(firFile)): File {
        var name = firFile.name
        var index = 0
        while (!packageInfo.contents.add(name)) {
            name = firFile.name + "".${index++}""
        }
        return packageInfo.packageRoot.resolve(""$name.fir.html"")
    }

    private fun packageForFile(firFile: FirFile): PackageInfo {
        val packageFqName = firFile.packageFqName
        return currentModule.packages.getOrPut(packageFqName) {
            PackageInfo(packageFqName, currentModule)
        }
    }

    fun indexFile(file: FirFile) {
        val location = locationForFile(file)
        index.files[file] = location
        file.accept(index.visitor(location))
    }

    fun generateFile(file: FirFile) {
        require(inModule)

        val dumpOutput = index.files[file] ?: error(""No location for ${file.name}"")
        val dumper = HtmlFirDump(LinkResolver(dumpOutput), file.moduleData.session)
        val builder = StringBuilder()
        dumper.generate(file, builder)

        dumpOutput.writeText(builder.toString())
        packageForFile(file).apply {
            errors[file.name] = dumper.errors
            implicits[file.name] = dumper.implicits
            unresolved[file.name] = dumper.unresolved
        }
    }


    private inner class LinkResolver(origin: File) : FirLinkResolver {

        override fun HEAD.supplementary() {
            supplementaryGenerator.supplementary(this, originDir)
        }

        override fun symbolSignature(symbol: FirBasedSymbol<*>): String {
            val id = index.symbolIds[symbol] ?: error(""Not found $symbol"")
            return ""id$id""
        }

        private val originDir = origin.parentFile

        override fun nearPackage(fqName: FqName): String? {
            val packageInfo = currentModule.packages[fqName] ?: return null
            return packageInfo.packageRoot.resolve(PACKAGE_INDEX).relativeTo(originDir).path
        }

        override fun classLocation(classId: ClassId): String? {
            val location = index.classes[classId] ?: return null
            return location.relativeTo(originDir).path + ""#$classId""
        }

        override fun nearSymbolLocation(symbol: FirBasedSymbol<*>): String? {
            val location = index.symbols[symbol] ?: return null
            return location.relativeTo(originDir).path + ""#${symbolSignature(symbol)}""
        }
    }

    private inner class Index {
        val files = mutableMapOf<FirFile, File>()
        val classes = mutableMapOf<ClassId, File>()
        val symbols = mutableMapOf<FirBasedSymbol<*>, File>()
        val symbolIds = mutableMapOf<FirBasedSymbol<*>, Int>()
        private var symbolCounter = 0

        fun visitor(location: File): FirVisitorVoid {
            return object : FirVisitorVoid() {
                override fun visitElement(element: FirElement) {
                    element.acceptChildren(this)
                }

                override fun visitRegularClass(regularClass: FirRegularClass) {
                    classes[regularClass.classId] = location
                    visitElement(regularClass)
                }

                fun indexDeclaration(declaration: FirDeclaration) {
                    symbols[declaration.symbol] = location
                    symbolIds[declaration.symbol] = symbolCounter++
                }

                override fun visitVariable(variable: FirVariable) {
                    indexDeclaration(variable)
                    visitElement(variable)
                }

                override fun visitValueParameter(valueParameter: FirValueParameter) {
                    indexDeclaration(valueParameter)
                    visitElement(valueParameter)
                }

                override fun visitSimpleFunction(simpleFunction: FirSimpleFunction) {
                    indexDeclaration(simpleFunction)
                    visitElement(simpleFunction)
                }

                override fun visitTypeParameter(typeParameter: FirTypeParameter) {
                    indexDeclaration(typeParameter)
                    visitElement(typeParameter)
                }

                override fun visitProperty(property: FirProperty) {
                    indexDeclaration(property)
                    visitElement(property)
                }

                override fun visitConstructor(constructor: FirConstructor) {
                    indexDeclaration(constructor)
                    visitElement(constructor)
                }
            }
        }

    }
}

@Suppress(""DEPRECATION"")
class HtmlFirDump internal constructor(private var linkResolver: FirLinkResolver, private val session: FirSession) {
    var errors: Int = 0
        private set

    var implicits: Int = 0
        private set

    var unresolved: Int = 0
        private set

    fun generate(element: FirFile, builder: StringBuilder) {
        errors = 0
        implicits = 0
        unresolved = 0
        builder.appendHTML().html {
            generate(element)
        }
    }

    private fun FlowContent.keyword(text: String) {
        span(classes = ""keyword"") { +text }
    }

    private fun FlowContent.line(block: FlowContent.() -> Unit) {
        nl()
        block()
        br
    }

    private fun FlowContent.nl(block: FlowContent.() -> Unit = {}) {
        span(classes = ""line"") { block() }
    }

    private fun FlowContent.inl() {
        nl()
        ident()
    }

    private fun FlowContent.simpleName(name: Name) {
        span(classes = ""simple-name"") {
            +name.asString()
        }
    }

    private fun FlowContent.unresolved(block: FlowContent.() -> Unit) {
        span(classes = ""unresolved"") {
            block()
        }
    }

    private fun FlowContent.resolved(block: FlowContent.() -> Unit) {
        span(classes = ""resolved"") {
            block()
        }
    }

    private fun FlowContent.error(block: SPAN.() -> Unit) {
        errors++
        span(classes = ""error"") {
            block()
        }
    }

    private fun FlowContent.packageName(fqName: FqName) {
        line {
            keyword(""package"")
            ws
            val link = linkResolver.nearPackage(fqName)!!
            a(href = link, classes = ""package-fqn"") { +fqName.asString() }
        }
    }

    private val FlowContent.ws get() = +"" ""

    private fun FlowContent.fqn(name: FqName) {
        +name.asString()
    }

    private fun FlowContent.inlineUnsupported(element: Any) {
        span(classes = ""fold-container"") {
            span(classes = ""error unsupported"") {
                +""Unsupported: ${element::class}""
            }
            span(""fold-region"") {
                val content = when (element) {
                    is FirElement -> element.render()
                    else -> element.toString()
                }
                +""\n""
                +content
                +""\n""
            }
        }
    }

    private fun FlowContent.unsupported(element: FirElement) {
        line {
            inlineUnsupported(element)
        }
    }

    private fun FlowContent.modality(modality: Modality?) {
        if (modality == null) return
        keyword(modality.name.lowercase())
    }

    private fun FlowContent.visibility(visibility: Visibility) {
        if (visibility == Visibilities.Unknown)
            return unresolved { keyword(""public?"") }
        return keyword(visibility.toString())
    }

    private fun FlowContent.declarationStatus(status: FirDeclarationStatus) {
        visibility(status.visibility)
        ws
        modality(status.modality)
        ws
        if (status.isExpect) {
            keyword(""expect "")
        }
        if (status.isActual) {
            keyword(""actual "")
        }
        if (status.isOverride) {
            keyword(""override "")
        }
        if (status.isInner) {
            keyword(""inner "")
        }
        if (status.isCompanion) {
            keyword(""companion "")
        }
        if (status.isInline) {
            keyword(""inline "")
        }
        if (status.isValue) {
            keyword(""value "")
        }
        if (status.isInfix) {
            keyword(""infix "")
        }
        if (status.isExternal) {
            keyword(""external "")
        }
        if (status.isTailRec) {
            keyword(""tailrec "")
        }
        if (status.isOperator) {
            keyword(""operator "")
        }
        if (status.isConst) {
            keyword(""const "")
        }
        if (status.isLateInit) {
            keyword(""lateinit "")
        }
        if (status.isData) {
            keyword(""data "")
        }
        if (status.isSuspend) {
            keyword(""suspend "")
        }
        if (status.isStatic) {
            keyword(""static "")
        }
    }


    private fun FlowContent.anchoredName(name: Name, signature: String) {
        span(classes = ""declaration"") {
            id = signature
            simpleName(name)
        }
    }

    private var currentIdent = 0

    private fun FlowContent.ident(level: Int = currentIdent) {
        +"" "".repeat(level * 4)
    }

    @Suppress(""SpellCheckingInspection"")
    private fun FlowContent.iline(block: FlowContent.() -> Unit) {
        inl()
        block()
        br
    }

    private fun FlowContent.withIdentLevel(block: FlowContent.() -> Unit) {
        currentIdent++
        block()
        currentIdent--
    }

    private fun <E> FlowContent.generateList(list: List<E>, separator: String = "", "", generate: FlowContent.(E) -> Unit) {
        if (list.isEmpty()) return
        generate(list.first())
        for (element in list.drop(1)) {
            +separator
            generate(element)
        }
    }

    private fun FlowContent.classKind(kind: ClassKind) {
        when (kind) {
            ClassKind.CLASS -> keyword(""class"")
            ClassKind.INTERFACE -> keyword(""interface"")
            ClassKind.ENUM_CLASS -> keyword(""enum class"")
            ClassKind.ENUM_ENTRY -> Unit // ?
            ClassKind.ANNOTATION_CLASS -> keyword(""annotation class"")
            ClassKind.OBJECT -> keyword(""object"")
        }
    }

    private fun FlowContent.generate(klass: FirRegularClass) {
        inl()

        declarationStatus(klass.status)
        classKind(klass.classKind)
        ws
        anchoredName(klass.name, klass.classId.asString())
        generateTypeParameters(klass)
        if (klass.superTypeRefs.isNotEmpty()) {
            +"": ""
            generateList(klass.superTypeRefs) {
                generate(it)
            }
        }

        generateDeclarations(klass.declarations)
        br

    }

    private fun FlowContent.generate(typeAlias: FirTypeAlias) {
        inl()

        declarationStatus(typeAlias.status)

        keyword(""typealias"")
        ws
        anchoredName(typeAlias.name, typeAlias.symbol.classId.asString())
        generateTypeParameters(typeAlias)

        +"" = ""

        val type = typeAlias.expandedConeType
        if (type != null) {
            generate(type as ConeKotlinType)
        } else {
            +""<error expanded type>""
        }

        br
    }

    private fun FlowContent.generate(flexibleType: ConeFlexibleType) {
        if (!flexibleType.lowerBound.isMarkedNullable &&
            flexibleType.upperBound.isMarkedNullable &&
            AbstractStrictEqualityTypeChecker.strictEqualTypes(
                session.typeContext,
                flexibleType.lowerBound,
                flexibleType.upperBound.withNullability(nullable = false, session.typeContext)
            )
        ) {
            generate(flexibleType.lowerBound)
            +""!""
        } else {
            generate(flexibleType.lowerBound)
            +""..""
            generate(flexibleType.upperBound)
        }
    }

    private fun FlowContent.generate(intersectionType: ConeIntersectionType) {
        +""(""
        generateList(intersectionType.intersectedTypes.toList(), "" & "") { generate(it) }
        +"")""
    }

    private fun FlowContent.generate(type: ConeClassLikeType) {
        resolved {
            when (val symbol = type.lookupTag.toSymbol(session)) {
                is FirTypeAliasSymbol -> {
                    symbolRef(symbol) {
                        simpleName(type.lookupTag.name)
                    }
                    generateTypeArguments(type)
                    if (type.isMarkedNullable) {
                        +""?""
                    }
                    +"" = ""
                    val directlyExpanded = type.directExpansionType(session)
                    if (directlyExpanded != null) {
                        generate(directlyExpanded.fullyExpandedType(session))
                    } else {
                        error { +""No expansion for type-alias"" }
                    }
                }
                else -> {
                    symbolRef(symbol) {
                        fqn(type.lookupTag.classId.relativeClassName)
                    }
                    generateTypeArguments(type)
                    if (type.isMarkedNullable) {
                        +""?""
                    }
                }
            }
        }
    }

    private fun FlowContent.generate(variableAssignment: FirVariableAssignment) {
        generate(variableAssignment.lValue)
        +"" = ""
        generate(variableAssignment.rValue)
    }

    private fun FlowContent.generate(projection: ConeTypeProjection) {
        when (projection) {
            is ConeStarProjection -> +""*""
            is ConeKotlinTypeProjection -> {
                when (projection.kind) {
                    ProjectionKind.IN -> keyword(""in "")
                    ProjectionKind.OUT -> keyword(""out "")
                    else -> {
                    }
                }

                generate(projection.type)
            }
        }
    }

    private fun FlowContent.stringLiteral(value: Any?) {
        val text = StringEscapeUtils.escapeJava(value.toString())
        span(""string-literal"") {
            when (value) {
                is String -> +""\""$text\""""
                is Char -> +""'$text'""
                else -> error(""Unknown string literal: \""$value\"" ${value?.let { it::class }}"")
            }
        }
    }

    private fun FlowContent.generate(expression: FirLiteralExpression) {
        val value = expression.value
        if (value == null && expression.kind != ConstantValueKind.Null) {
            return error {
                +""null value""
            }
        }

        @OptIn(ExperimentalUnsignedTypes::class)
        when (expression.kind) {
            ConstantValueKind.Null -> keyword(""null"")
            ConstantValueKind.Boolean -> keyword(value.toString())
            ConstantValueKind.String, ConstantValueKind.Char ->
                stringLiteral(value)
            ConstantValueKind.Byte -> {
                +value.toString()
                keyword(""B"")
            }
            ConstantValueKind.Short -> {
                +value.toString()
                keyword(""S"")
            }
            ConstantValueKind.Int -> {
                +value.toString()
                keyword(""I"")
            }
            ConstantValueKind.Long -> {
                +value.toString()
                keyword(""L"")
            }
            ConstantValueKind.UnsignedByte -> {
                +(value as Long).toUByte().toString()
                keyword(""uB"")
            }
            ConstantValueKind.UnsignedShort -> {
                +(value as Long).toUShort().toString()
                keyword(""uS"")
            }
            ConstantValueKind.UnsignedInt -> {
                +(value as Long).toUInt().toString()
                keyword(""uI"")
            }
            ConstantValueKind.UnsignedLong -> {
                +(value as Long).toULong().toString()
                keyword(""uL"")
            }
            ConstantValueKind.Float -> {
                +value.toString()
                keyword(""F"")
            }
            ConstantValueKind.Double -> {
                +value.toString()
                keyword(""D"")
            }
            ConstantValueKind.IntegerLiteral -> {
                +""IL<""
                +value.toString()
                +"">""
            }
            ConstantValueKind.UnsignedIntegerLiteral -> {
                +""UIL<""
                +value.toString()
                +"">""
            }
            ConstantValueKind.Error -> {
                +""ERROR_CONSTANT""
            }
        }

    }

    private fun FlowContent.generateTypeArguments(type: ConeKotlinType) {
        if (type.typeArguments.isNotEmpty()) {
            +""<""
            generateList(type.typeArguments.toList()) {
                generate(it)
            }
            +"">""
        }
    }

    private fun FlowContent.generate(type: ConeKotlinType) {
        when (type) {
            is ConeErrorType -> error { +type.diagnostic.reason }
            is ConeClassLikeType -> return generate(type)
            is ConeTypeParameterType -> resolved {
                symbolRef(type.lookupTag.symbol) {
                    simpleName(type.lookupTag.name)
                }
            }
            is ConeTypeVariableType -> resolved { +type.typeConstructor.name.asString() }
            is ConeFlexibleType -> resolved { generate(type) }
            is ConeCapturedType -> inlineUnsupported(type)
            is ConeDefinitelyNotNullType -> resolved {
                generate(type.original)
                +"" & Any""
            }
            is ConeIntersectionType -> resolved { generate(type) }
            is ConeIntegerLiteralType -> inlineUnsupported(type)
            is ConeLookupTagBasedType,
            is ConeStubType -> {}
        }
        generateTypeArguments(type)
        if (type.isMarkedNullable) {
            +""?""
        }
    }

    private fun FlowContent.generate(typeProjection: FirTypeProjection) {
        when (typeProjection) {
            is FirTypeProjectionWithVariance -> {
                generate(typeProjection.variance)
                generate(typeProjection.typeRef)
            }
            is FirStarProjection -> +""*""
            is FirPlaceholderProjection -> +""_""
        }
    }

    private fun FlowContent.generate(variance: Variance) {
        when (variance) {
            Variance.INVARIANT -> Unit
            Variance.IN_VARIANCE -> keyword(""in "")
            Variance.OUT_VARIANCE -> keyword(""out "")
        }
    }

    private fun FlowContent.generateTypeProjections(typeProjections: List<FirTypeProjection>) {
        if (typeProjections.isEmpty()) return
        +""<""
        generateList(typeProjections) {
            generate(it)
        }
        +"">""
    }

    private fun FlowContent.generate(typeRef: FirTypeRef) {
        when (typeRef) {
            is FirErrorTypeRef -> error { +typeRef.diagnostic.reason }
            is FirResolvedTypeRef -> generate(typeRef.coneType)
            is FirImplicitTypeRef -> unresolved {
                implicits++
                keyword(""<implicit>"")
            }
            is FirUserTypeRef -> unresolved {
                unresolved++
                generateList(typeRef.qualifier, separator = ""."") {
                    simpleName(it.name)
                    generateTypeProjections(it.typeArgumentList.typeArguments)
                }
                if (typeRef.isMarkedNullable) {
                    +""?""
                }
            }
            else -> inlineUnsupported(typeRef)
        }
    }

    private fun FlowContent.generate(memberDeclaration: FirMemberDeclaration) {
        when (memberDeclaration) {
            is FirEnumEntry -> generate(memberDeclaration)
            is FirRegularClass -> generate(memberDeclaration)
            is FirSimpleFunction -> generate(memberDeclaration)
            is FirProperty -> if (memberDeclaration.isLocal) generate(memberDeclaration as FirVariable) else generate(memberDeclaration)
            is FirConstructor -> generate(memberDeclaration)
            is FirTypeAlias -> generate(memberDeclaration)
            else -> unsupported(memberDeclaration)
        }
    }

    private fun FlowContent.generateTypeParameters(typeParameterContainer: FirTypeParameterRefsOwner, describe: Boolean = false) {
        if (typeParameterContainer.typeParameters.isEmpty()) return
        +""<""
        fun generateTypeParameter(typeParameter: FirTypeParameter, describe: Boolean) {
            generate(typeParameter.variance)
            if (typeParameter.isReified) {
                keyword(""reified "")
            }
            if (describe)
                symbolRef(typeParameter.symbol) {
                    simpleName(typeParameter.name)
                }
            else
                symbolAnchor(typeParameter.symbol) {
                    simpleName(typeParameter.name)
                }
            if (typeParameter.bounds.isNotEmpty()) {
                +"": ""
                generateList(typeParameter.bounds) { bound ->
                    generate(bound)
                }
            }
        }
        generateList(typeParameterContainer.typeParameters) {
            if (it is FirTypeParameter) {
                generateTypeParameter(it, describe)
            } else {
                symbolRef(it.symbol) {
                    +""^""
                    simpleName(it.symbol.fir.name)
                }
            }
        }
        +""> ""
    }

    private fun FlowContent.generateReceiver(declaration: FirCallableDeclaration) {
        generateReceiver(declaration.receiverParameter)
    }

    private fun FlowContent.generateReceiver(receiverParameter: FirReceiverParameter?) {
        receiverParameter ?: return
        generate(receiverParameter.typeRef)
        +"".""
    }

    private fun FlowContent.generate(accessor: FirPropertyAccessor) {
        if (accessor is FirDefaultPropertyAccessor) return
        iline {
            declarationStatus(accessor.status)
            if (accessor.isGetter) {
                keyword(""get"")
            } else if (accessor.isSetter) {
                keyword(""set"")
            }
            +""(""
            generateList(accessor.valueParameters) {
                generate(it)
            }
            +"")""
            generateBlockIfAny(accessor.body)
        }
    }

    private fun FlowContent.generate(property: FirProperty) {
        //anchor
        iline {
            declarationStatus(property.status)
            if (property.isVal) {
                keyword(""val "")
            } else {
                keyword(""var "")
            }
            generateTypeParameters(property)
            generateReceiver(property)
            symbolAnchor(property.symbol) {
                simpleName(property.name)
            }
            +"": ""
            generate(property.returnTypeRef)


            val initializer = property.initializer
            if (initializer != null) {
                +"" = ""
                generate(initializer)
            }

            val delegate = property.delegate
            if (delegate != null) {
                keyword("" by "")
                generate(delegate)
            }
        }

        withIdentLevel {
            property.getter?.let { generate(it) }
            property.setter?.let { generate(it) }
        }
    }


    private fun FlowContent.exprType(type: FirTypeRef, block: SPAN.() -> Unit) {
        span(classes = ""typed-expression fold-container"") {
            block()
            span(classes = ""expression-type fold-region"") {
                +"": ""
                generate(type)
            }
        }
    }

    private fun FlowContent.generate(statement: FirStatement) {
        when (statement) {
            is FirSimpleFunction -> generate(statement)
            is FirAnonymousObject -> generate(statement, isStatement = true)
            is FirAnonymousFunction -> generate(statement, isStatement = true)
            is FirWhileLoop -> generate(statement)
            is FirWhenExpression -> generate(statement, isStatement = true)
            is FirTryExpression -> generate(statement, isStatement = true)
            is FirExpression -> iline { generate(statement) }
            is FirVariable -> iline { generate(statement) }
            is FirVariableAssignment -> iline { generate(statement) }
            else -> unsupported(statement)
        }
    }

    private fun FlowContent.generate(delegatedConstructorCall: FirDelegatedConstructorCall) {
        generateMultiLineExpression(isStatement = true) {
            iline {
                exprType(delegatedConstructorCall.constructedTypeRef) {
                    if (delegatedConstructorCall.isSuper) keyword(""super"")
                    if (delegatedConstructorCall.isThis) keyword(""this"")
                    +""<""
                    generate(delegatedConstructorCall.calleeReference)
                    +"">""
                    +""(""
                    generateList(delegatedConstructorCall.arguments) {
                        generate(it)
                    }
                    +"")""
                }
            }
        }
    }

    private fun FlowContent.generate(variable: FirVariable) {
        if (variable.isVal) {
            keyword(""val "")
        } else {
            keyword(""var "")
        }

        symbolAnchor(variable.symbol) { simpleName(variable.name) }
        +"": ""
        generate(variable.returnTypeRef)
        val initializer = variable.initializer
        if (initializer != null) {
            +"" = ""
            generate(initializer)
        }
    }

    private fun FlowContent.declarationRef(
        href: String?,
        classes: Set<String> = emptySet(),
        body: A.() -> Unit
    ) {
        a(href = href, classes = ""ref"") {
            this.classes += classes
            if (href == null) {
                this.classes += ""external""
            }
            body()
        }
    }

    private fun FirBasedSymbol<*>.describe(): String {
        return when (this) {
            is FirClassLikeSymbol<*> -> classId.asString()
            is FirCallableSymbol<*> -> callableId.toString()
            is FirTypeParameterSymbol -> name.asString()
            else -> """"
        }
    }

    private fun FlowContent.describeVerbose(symbol: FirCallableSymbol<*>, fir: FirFunction) {
        describeTypeParameters(fir)

        fir.receiverParameter?.typeRef?.let {
            +""(""
            generate(it)
            +"").""
        }
        symbolRef(symbol) {
            +symbol.callableIdAsString()
        }
        +""(""
        generateList(fir.valueParameters) {
            generate(it.returnTypeRef)
        }
        +""): ""
        generate(fir.returnTypeRef)
    }

    private fun FlowContent.describeVerbose(symbol: FirCallableSymbol<*>, fir: FirVariable) {
        if (fir is FirTypeParametersOwner) describeTypeParameters(fir)

        fir.receiverParameter?.typeRef?.let {
            +""(""
            generate(it)
            +"").""
        }
        symbolRef(symbol) {
            +symbol.callableId.toString()
        }
        +"":""
        generate(fir.returnTypeRef)
    }

    private fun FlowContent.describeTypeParameters(typeParameterContainer: FirTypeParameterRefsOwner) =
        generateTypeParameters(typeParameterContainer, describe = true)

    private fun FlowContent.describeVerbose(symbol: FirBasedSymbol<*>) {
        when (symbol) {
            is FirClassLikeSymbol<*> ->
                when (val fir = symbol.fir) {
                    is FirRegularClass -> {
                        declarationStatus(fir.status)
                        classKind(fir.classKind)
                        ws
                        symbolRef(symbol) {
                            +fir.classId.asString()
                        }
                        describeTypeParameters(fir)
                    }
                    is FirTypeAlias -> {
                        keyword(""typealias "")
                        symbolRef(symbol) {
                            +symbol.classId.asString()
                        }
                        describeTypeParameters(fir)
                    }
                    else -> +symbol.describe()
                }
            is FirCallableSymbol<*> -> {
                when (val fir = symbol.fir) {
                    is FirSimpleFunction -> {
                        declarationStatus(fir.status)
                        keyword(""fun "")
                        describeVerbose(symbol, fir)
                    }
                    is FirConstructor -> {
                        declarationStatus(fir.status)
                        keyword(""constructor "")
                        describeVerbose(symbol, fir)
                    }
                    is FirField -> {
                        declarationStatus(fir.status)
                        keyword(""field "")
                        describeVerbose(symbol, fir)
                    }
                    is FirProperty -> {
                        declarationStatus(fir.status)
                        if (fir.isVal)
                            keyword(""val "")
                        else if (fir.isVar)
                            keyword(""var "")
                        describeVerbose(symbol, fir)
                    }
                    is FirAnonymousFunction,
                    is FirErrorFunction,
                    is FirPropertyAccessor,
                    is FirBackingField,
                    is FirEnumEntry,
                    is FirValueParameter -> {}
                }
            }
            else -> +symbol.describe()
        }
    }

    private fun FlowContent.symbolRef(symbol: FirBasedSymbol<*>?, body: FlowContent.() -> Unit) {
        val (link, classes) = when (symbol) {
            null -> null to setOf()
            is FirClassLikeSymbol<*> -> linkResolver.classLocation(symbol.classId) to setOf(""class-fqn"")
            else -> linkResolver.nearSymbolLocation(symbol) to setOf(""symbol"")
        }
        declarationRef(link, classes) {
            if (symbol != null) {
                title = symbol.describe()
            }
            body()
        }
    }

    private fun FlowContent.diagnosticHover(body: FlowContent.() -> Unit) {
        span(classes = ""diagnostic-hover"") {
            body()
        }
    }

    private fun FlowContent.errorWithDiagnostic(body: FlowContent.() -> Unit) {
        error {
            classes = classes + ""diagnostic-hover-container""
            body()
        }
    }

    private fun FlowContent.generate(diagnostic: ConeDiagnostic) {
        when (diagnostic) {
            is ConeInapplicableCandidateError -> {
                describeVerbose(diagnostic.candidate.symbol)
                br
                diagnostic.candidate.errors.forEach { callDiagnostic ->
                    when (callDiagnostic) {
                        is NewConstraintError -> {
                            ident()

                            generate(callDiagnostic.lowerType as ConeKotlinType)

                            ws
                            span(classes = ""subtype-error"") { +""<:"" }
                            ws
                            generate(callDiagnostic.upperType as ConeKotlinType)
                        }
                        else -> {
                            ident()
                            callDiagnostic::class.qualifiedName?.let { +it }
                            Unit
                        }
                    }
                    br
                }
            }
            is ConeAmbiguityError -> {
                +""Ambiguity: ""
                br
                for (candidate in diagnostic.candidates) {
                    describeVerbose(candidate.symbol)
                    br
                }
            }
            else -> +diagnostic.reason
        }
    }

    private fun FlowContent.generate(reference: FirReference) {
        when (reference) {
            is FirSuperReference -> keyword(""super"")
            is FirThisReference -> {
                keyword(""this"")
                val label = reference.labelName ?: """"
                span(""label"") {
                    +""@""
                    +label
                }
            }
            is FirErrorNamedReference -> {
                errorWithDiagnostic {
                    simpleName(reference.name)
                    diagnosticHover {
                        generate(reference.diagnostic)
                    }
                }
            }
            is FirSimpleNamedReference -> {
                unresolved {
                    simpleName(reference.name)
                }
            }
            is FirResolvedErrorReference -> {
                errorWithDiagnostic {
                    resolved {
                        symbolRef(reference.resolvedSymbol) {
                            simpleName(reference.name)
                        }
                    }
                    diagnosticHover {
                        generate(reference.diagnostic)
                    }
                }
            }
            is FirResolvedNamedReference -> {
                resolved {
                    symbolRef(reference.resolvedSymbol) {
                        simpleName(reference.name)
                    }
                }
            }
        }
    }

    private fun FlowContent.generateReceiver(access: FirQualifiedAccessExpression) {
        val explicitReceiver = access.explicitReceiver
        if (explicitReceiver != null) {
            generate(explicitReceiver)
            +"".""
        }
    }

    private fun FlowContent.generate(functionCall: FirFunctionCall, skipReceiver: Boolean = false) {

        if (!skipReceiver) {
            generateReceiver(functionCall)
        }

        generate(functionCall.calleeReference)
        generateTypeProjections(functionCall.typeArguments)
        +""(""
        generateList(functionCall.arguments) {
            generate(it)
        }
        +"")""
    }

    private fun FlowContent.generateBinary(first: FirExpression, second: FirExpression, operation: FirOperation) {
        generate(first)
        ws
        unresolved { +operation.operator }
        ws
        generate(second)
    }

    private fun FlowContent.generate(typeOperatorCall: FirTypeOperatorCall) {
        generate(typeOperatorCall.argument)
        ws
        keyword(typeOperatorCall.operation.operator)
        ws
        generate(typeOperatorCall.conversionTypeRef)
    }

    private fun FlowContent.generate(equalityOperatorCall: FirEqualityOperatorCall) {
        generateBinary(equalityOperatorCall.arguments[0], equalityOperatorCall.arguments[1], equalityOperatorCall.operation)
    }

    private fun FlowContent.generate(checkNotNullCall: FirCheckNotNullCall) {
        generate(checkNotNullCall.argument)
        +""!!""
    }

    private fun FlowContent.generate(elvisExpression: FirElvisExpression) {
        generate(elvisExpression.lhs)
        +"" ?: ""
        generate(elvisExpression.rhs)
    }

    @Suppress(""UNUSED_PARAMETER"")
    private fun FlowContent.generate(elseIfTrueCondition: FirElseIfTrueCondition) {
        keyword(""else"")
    }

    @Suppress(""UNUSED_PARAMETER"")
    private fun FlowContent.generate(whenSubjectExpression: FirWhenSubjectExpression) {
        +""<subj>""
    }

    private fun FlowContent.generateMultiLineExpression(isStatement: Boolean, body: FlowContent.() -> Unit) {
        if (!isStatement) {
            br
            currentIdent++
        }
        body()
        if (!isStatement) {
            currentIdent--
            inl()
        }
    }

    private fun FlowContent.generate(tryExpression: FirTryExpression, isStatement: Boolean) {
        generateMultiLineExpression(isStatement) {
            iline {
                keyword(""try "")
                generateBlockIfAny(tryExpression.tryBlock)

                for (catch in tryExpression.catches) {
                    keyword("" catch "")
                    +""(""
                    generate(catch.parameter)
                    +"") ""
                    generateBlockIfAny(catch.block)
                }
                val finallyBlock = tryExpression.finallyBlock
                if (finallyBlock != null) {
                    keyword("" finally "")
                    generateBlockIfAny(finallyBlock)
                }
            }
        }
    }

    private fun FlowContent.generate(whileLoop: FirWhileLoop) {
        iline {
            generateLabel(whileLoop.label)
            keyword(""while "")
            +""(""
            generate(whileLoop.condition)
            +"") ""
            generateBlockIfAny(whileLoop.block)
        }
    }

    private fun FlowContent.generate(whenExpression: FirWhenExpression, isStatement: Boolean) {
        generateMultiLineExpression(isStatement) {
            iline {
                keyword(""when"")
                +"" (""
                whenExpression.subjectVariable?.let { generate(it) }
                    ?: whenExpression.subjectVariable?.initializer?.let { generate(it) }
                +"") {""
            }
            withIdentLevel {
                for (branch in whenExpression.branches) {
                    inl()
                    generate(branch.condition)
                    +"" -> {""
                    if (branch.result.statements.isNotEmpty()) {
                        br
                        withIdentLevel {
                            generateBlockContent(branch.result)
                        }
                        inl()
                    }
                    +""}""
                    br
                }
            }
            iline {
                +""}""
            }
        }
    }

    private fun FlowContent.generate(throwExpression: FirThrowExpression) {
        keyword(""throw "")
        generate(throwExpression.exception)
    }

    private fun FlowContent.generate(unitExpression: FirUnitExpression) {
        generate(unitExpression.resolvedType)
    }

    private fun FlowContent.generate(breakExpression: FirBreakExpression) {
        keyword(""break"")
        span(""label"") {
            +""@""
            +(breakExpression.target.labelName ?: """")
        }
    }

    private fun FlowContent.generate(continueExpression: FirContinueExpression) {
        keyword(""continue"")
        span(""label"") {
            +""@""
            +(continueExpression.target.labelName ?: """")
        }
    }


    private fun FlowContent.generate(initializer: FirAnonymousInitializer) {
        iline {
            keyword(""init"")
            generateBlockIfAny(initializer.body)
        }
    }

    private fun FlowContent.generate(stringConcatenationCall: FirStringConcatenationCall) {
        generateList(stringConcatenationCall.arguments, separator = "" + "") {
            generate(it)
        }
    }

    private fun FlowContent.generateLabel(label: FirLabel?) {
        if (label == null) return
        span(""label"") {
            +label.name
            +""@""
        }
    }

    private fun FlowContent.generate(getClassCall: FirGetClassCall) {
        generate(getClassCall.argument)
        +""::""
        keyword(""class"")
    }

    private fun FlowContent.generate(resolvedQualifier: FirResolvedQualifier) {
        resolved {
            val symbol = resolvedQualifier.symbol
            if (symbol != null) {
                symbolRef(symbol) {
                    fqn(resolvedQualifier.classId?.relativeClassName ?: FqName(""<???>""))
                }
            } else {
                fqn(resolvedQualifier.packageFqName)
            }
        }
    }

    private fun FlowContent.generate(expression: FirExpression) {
        exprType(expression.resolvedType.toFirResolvedTypeRef()) {
            when (expression) {
                is FirBlock -> generateBlockIfAny(expression)
                is FirGetClassCall -> generate(expression)
                is FirContinueExpression -> generate(expression)
                is FirBreakExpression -> generate(expression)
                is FirAnonymousObjectExpression -> generate(expression.anonymousObject)
                is FirAnonymousFunctionExpression -> generate(expression.anonymousFunction, isStatement = false)
                is FirUnitExpression -> generate(expression)
                is FirStringConcatenationCall -> generate(expression)
                is FirThrowExpression -> generate(expression)
                is FirWhenSubjectExpression -> generate(expression)
                is FirElseIfTrueCondition -> generate(expression)
                is FirWhenExpression -> generate(expression, isStatement = false)
                is FirTryExpression -> generate(expression, isStatement = false)
                is FirLiteralExpression -> generate(expression)
                is FirReturnExpression -> {
                    span(""return-label"") {
                        symbolRef(expression.target.labeledElement.symbol) {
                            +""^""
                            +(expression.target.labelName ?: """")
                        }
                    }
                    generate(expression.result)
                }
                is FirFunctionCall -> {
                    generate(expression)
                }
                is FirResolvedQualifier -> generate(expression)
                is FirQualifiedAccessExpression -> generate(expression)
                is FirNamedArgumentExpression -> {
                    simpleName(expression.name)
                    +"" = ""
                    if (expression.isSpread) {
                        +""*""
                    }
                    generate(expression.expression)
                }
                is FirSpreadArgumentExpression -> {
                    +""*""
                    generate(expression.expression)

                }
                is FirTypeOperatorCall -> generate(expression)
                is FirEqualityOperatorCall -> generate(expression)
                is FirBooleanOperatorExpression -> generate(expression)
                is FirCheckNotNullCall -> generate(expression)
                is FirElvisExpression -> generate(expression)
                is FirVarargArgumentsExpression -> generate(expression)
                is FirResolvedReifiedParameterReference -> generate(expression)
                is FirComparisonExpression -> generate(expression)
                is FirSafeCallExpression -> generate(expression)
                is FirCheckedSafeCallSubject -> {
                    +""\$subj\$""
                }
                is FirSmartCastExpression -> generate(expression)
                else -> inlineUnsupported(expression)
            }
        }
    }

    private fun FlowContent.generate(comparisonExpression: FirComparisonExpression) {
        generate(comparisonExpression.left)
        +"" ${comparisonExpression.operation.operator} ""
        generate(comparisonExpression.right)
    }

    private fun FlowContent.generate(smartCastExpression: FirSmartCastExpression) {
        span(classes = ""smart-cast"") {
            generate(smartCastExpression.originalExpression)
        }
    }

    private fun FlowContent.generate(safeCallExpression: FirSafeCallExpression) {
        generate(safeCallExpression.receiver)

        +""?.""

        val selector = safeCallExpression.selector
        if (selector is FirQualifiedAccessExpression && selector.explicitReceiver == safeCallExpression.checkedSubjectRef.value) {
            return when (selector) {
                is FirFunctionCall -> generate(selector, skipReceiver = true)
                else -> generate(selector, skipReceiver = true)
            }
        }

        +""{ ""

        generate(selector)

        +"" }""
    }

    private fun FlowContent.generate(resolvedReifiedParameterReference: FirResolvedReifiedParameterReference) {
        val typeParameter = resolvedReifiedParameterReference.symbol.fir
        +typeParameter.name.identifier
    }

    private fun FlowContent.generate(varargArgumentExpression: FirVarargArgumentsExpression) {
        generateList(varargArgumentExpression.arguments, separator = "","") { generate(it) }
    }

    private fun FlowContent.generate(booleanOperatorExpression: FirBooleanOperatorExpression) {
        generate(booleanOperatorExpression.leftOperand)
        +"" ${booleanOperatorExpression.kind.token} ""
        generate(booleanOperatorExpression.rightOperand)
    }

    private fun FlowContent.generate(qualifiedAccessExpression: FirQualifiedAccessExpression, skipReceiver: Boolean = false) {
        if (!skipReceiver) {
            generateReceiver(qualifiedAccessExpression)
        }
        generate(qualifiedAccessExpression.calleeReference)
    }

    private fun FlowContent.generateBlockContent(block: FirBlock) {
        for (statement in block.statements) {
            generate(statement)
        }
    }

    private fun FlowContent.symbolAnchor(symbol: FirBasedSymbol<*>, body: FlowContent.() -> Unit) {
        span(classes = ""declaration"") {
            id = linkResolver.symbolSignature(symbol)
            body()
        }
    }

    private fun FlowContent.generate(valueParameter: FirValueParameter) {
        if (valueParameter.isVararg) {
            keyword(""vararg "")
        }
        if (valueParameter.isCrossinline) {
            keyword(""crossinline "")
        }
        if (valueParameter.isNoinline) {
            keyword(""noinline "")
        }
        symbolAnchor(valueParameter.symbol) { simpleName(valueParameter.name) }
        +"": ""
        generate(valueParameter.returnTypeRef)
        val defaultValue = valueParameter.defaultValue
        if (defaultValue != null) {
            +"" = ""
            generate(defaultValue)
        }
    }

    private fun FlowContent.generateBlockIfAny(block: FirBlock?) {
        if (block == null) return
        +"" {""
        generateMultiLineExpression(isStatement = false) {
            generateBlockContent(block)
        }
        +""}""
    }

    private fun FlowContent.generate(anonymousObject: FirAnonymousObject, isStatement: Boolean = false) {
        generateMultiLineExpression(isStatement) {
            iline {
                keyword(""object "")
                val superTypeRefs = anonymousObject.superTypeRefs
                if (superTypeRefs.isNotEmpty()) {
                    +"": ""
                    generateList(superTypeRefs) {
                        generate(it)
                    }
                }
                generateDeclarations(anonymousObject.declarations)
            }
        }
    }

    private fun FlowContent.generateDeclarations(declarations: List<FirDeclaration>) {
        if (declarations.isNotEmpty()) {
            +"" {""
            br

            withIdentLevel {
                for (declaration in declarations) {
                    generate(declaration)
                    line {}
                }
            }

            inl()
            +""}""
        }
    }

    private fun FlowContent.generate(function: FirSimpleFunction) {
        generateMultiLineExpression(isStatement = true) {
            iline {
                declarationStatus(function.status)
                keyword(""fun "")
                generateTypeParameters(function)
                generateReceiver(function)
                symbolAnchor(function.symbol) {
                    simpleName(function.name)
                }
                +""(""
                generateList(function.valueParameters) {
                    generate(it)
                }
                +""): ""
                generate(function.returnTypeRef)
                generateBlockIfAny(function.body)
            }
        }
    }

    private fun FlowContent.generate(function: FirConstructor) {
        iline {
            declarationStatus(function.status)
            symbolAnchor(function.symbol) {
                keyword(""constructor"")
            }
            generateTypeParameters(function)
            +""(""
            generateList(function.valueParameters) {
                generate(it)
            }
            +""): ""
            generate(function.returnTypeRef)

            val delegatedConstructorCall = function.delegatedConstructor
            val body = function.body
            if (delegatedConstructorCall != null || body != null) {
                +"" {""
                generateMultiLineExpression(isStatement = false) {
                    if (delegatedConstructorCall != null) {
                        generate(delegatedConstructorCall)
                    }
                    if (body != null) generateBlockContent(body)
                }
                +""}""
            }
        }
    }

    private fun FlowContent.generate(anonymousFunction: FirAnonymousFunction, isStatement: Boolean) {
        generateMultiLineExpression(isStatement) {
            iline {
                generateLabel(anonymousFunction.label)
                keyword(""fun "")
                generateReceiver(anonymousFunction.receiverParameter)

                +""(""
                generateList(anonymousFunction.valueParameters) {
                    generate(it)
                }
                +""): ""
                generate(anonymousFunction.returnTypeRef)
                generateBlockIfAny(anonymousFunction.body)
            }
        }
    }

    private fun FlowContent.generate(declaration: FirDeclaration) {
        when (declaration) {
            is FirAnonymousInitializer -> generate(declaration)
            is FirMemberDeclaration -> generate(declaration)
            else -> unsupported(declaration)
        }
    }

    private fun FlowContent.generate(import: FirImport) {
        fun simpleRender() {
            val fqName = import.importedFqName
            if (fqName != null) {
                fqn(fqName)
                if (import.isAllUnder)
                    +"".""
            }
            if (import.isAllUnder) {
                +""*""
            }
        }

        line {
            keyword(""import"")
            ws
            when (import) {
                is FirResolvedImport -> {
                    val classId = import.resolvedParentClassId
                    if (classId == null) {
                        val importedFqName = import.importedFqName
                        if (importedFqName != null) {
                            fqn(importedFqName)
                        } else {
                            error { +""no fqn"" }
                        }
                    } else {
                        +classId.asString()
                    }
                    if (import.isAllUnder) {
                        +"".*""
                    }
                }
                else -> {
                    unresolved {
                        simpleRender()
                    }
                }
            }
            val alias = import.aliasName
            if (alias != null) {
                ws
                keyword(""as"")
                ws
                simpleName(alias)
            }
        }
    }

    private fun FlowContent.generate(enumEntry: FirEnumEntry) {
        iline {
            simpleName(enumEntry.name)
        }
    }

    private fun HTML.generate(file: FirFile) {
        head {
            title { +file.name }
            commonHead()
            with(linkResolver) {
                supplementary()
            }
        }
        body {
            h4 {
                +""Source: ""
                val vFile = file.psi?.containingFile?.virtualFile
                if (vFile != null) {
                    a(href = vFile.url, classes = ""container-ref"") {
                        +vFile.path
                    }
                } else {
                    +""No source""
                }
            }
            h2 {
                +file.name
            }
            pre {
                packageName(file.packageFqName)
                line {}
                for (import in file.imports) {
                    generate(import)
                }
                line {}
                for (declaration in file.declarations) {
                    generate(declaration)
                    line {}
                }
            }
        }
    }

}
",KOT_02245,CWE-321: Hard-coded Cryptographic Key,A02: Cryptographic Failures;A04: Insecure Design,1
shadowsocks__shadowsocks-android,4624424629ecb50bd810251ffbf2d2427bd885fe,mobile/src/main/java/com/github/shadowsocks/MainActivity.kt,.kt,Mygod,contact-git@mygod.be,2019-08-22T01:57:12+08:00,Fix landscape stats,1,MainActivity,"class MainActivity : AppCompatActivity(), ShadowsocksConnection.Callback, OnPreferenceDataStoreChangeListener,
        NavigationView.OnNavigationItemSelectedListener {
    companion object {
        private const val TAG = ""ShadowsocksMainActivity""
        private const val REQUEST_CONNECT = 1

        var stateListener: ((BaseService.State) -> Unit)? = null
    }

    // UI
    private lateinit var fab: ServiceButton
    private lateinit var stats: StatsBar
    internal lateinit var drawer: DrawerLayout
    private lateinit var navigation: NavigationView

    val snackbar by lazy { findViewById<CoordinatorLayout>(R.id.snackbar) }
    fun snackbar(text: CharSequence = """") = Snackbar.make(snackbar, text, Snackbar.LENGTH_LONG).apply {
        anchorView = fab
    }

    private val customTabsIntent by lazy {
        CustomTabsIntent.Builder().apply {
            setColorScheme(CustomTabsIntent.COLOR_SCHEME_SYSTEM)
            setColorSchemeParams(CustomTabsIntent.COLOR_SCHEME_LIGHT, CustomTabColorSchemeParams.Builder().apply {
                setToolbarColor(ContextCompat.getColor(this@MainActivity, R.color.light_color_primary))
            }.build())
            setColorSchemeParams(CustomTabsIntent.COLOR_SCHEME_DARK, CustomTabColorSchemeParams.Builder().apply {
                setToolbarColor(ContextCompat.getColor(this@MainActivity, R.color.dark_color_primary))
            }.build())
        }.build()
    }
    fun launchUrl(uri: String) = try {
        customTabsIntent.launchUrl(this, uri.toUri())
    } catch (_: ActivityNotFoundException) {
        snackbar(uri).show()
    }

    // service
    var state = BaseService.State.Idle
    override fun stateChanged(state: BaseService.State, profileName: String?, msg: String?) =
            changeState(state, msg, true)
    override fun trafficUpdated(profileId: Long, stats: TrafficStats) {
        if (profileId == 0L) this@MainActivity.stats.updateTraffic(
                stats.txRate, stats.rxRate, stats.txTotal, stats.rxTotal)
        if (state != BaseService.State.Stopping) {
            (supportFragmentManager.findFragmentById(R.id.fragment_holder) as? ToolbarFragment)
                    ?.onTrafficUpdated(profileId, stats)
        }
    }
    override fun trafficPersisted(profileId: Long) {
        ProfilesFragment.instance?.onTrafficPersisted(profileId)
    }

    private fun changeState(state: BaseService.State, msg: String? = null, animate: Boolean = false) {
        fab.changeState(state, this.state, animate)
        stats.changeState(state)
        if (msg != null) snackbar(getString(R.string.vpn_error, msg)).show()
        this.state = state
        ProfilesFragment.instance?.profilesAdapter?.notifyDataSetChanged()  // refresh button enabled state
        stateListener?.invoke(state)
    }

    private fun toggle() = when {
        state.canStop -> Core.stopService()
        DataStore.serviceMode == Key.modeVpn -> {
            val intent = VpnService.prepare(this)
            if (intent != null) startActivityForResult(intent, REQUEST_CONNECT)
            else onActivityResult(REQUEST_CONNECT, Activity.RESULT_OK, null)
        }
        else -> Core.startService()
    }

    private val handler = Handler()
    private val connection = ShadowsocksConnection(handler, true)
    override fun onServiceConnected(service: IShadowsocksService) = changeState(try {
        BaseService.State.values()[service.state]
    } catch (_: RemoteException) {
        BaseService.State.Idle
    })
    override fun onServiceDisconnected() = changeState(BaseService.State.Idle)
    override fun onBinderDied() {
        connection.disconnect(this)
        connection.connect(this, this)
    }

    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        when {
            requestCode != REQUEST_CONNECT -> super.onActivityResult(requestCode, resultCode, data)
            resultCode == Activity.RESULT_OK -> Core.startService()
            else -> {
                snackbar().setText(R.string.vpn_permission_denied).show()
                Crashlytics.log(Log.ERROR, TAG, ""Failed to start VpnService from onActivityResult: $data"")
            }
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        SingleInstanceActivity.register(this) ?: return
        setContentView(R.layout.layout_main)
        stats = findViewById(R.id.stats)
        stats.setOnClickListener { if (state == BaseService.State.Connected) stats.testConnection() }
        drawer = findViewById(R.id.drawer)
        drawer.systemUiVisibility = View.SYSTEM_UI_FLAG_LAYOUT_STABLE or View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
        navigation = findViewById(R.id.navigation)
        navigation.setNavigationItemSelectedListener(this)
        if (savedInstanceState == null) {
            navigation.menu.findItem(R.id.profiles).isChecked = true
            displayFragment(ProfilesFragment())
        }

        fab = findViewById(R.id.fab)
        fab.setOnClickListener { toggle() }
        fab.setOnApplyWindowInsetsListener { view, insets ->
            view.updateLayoutParams<ViewGroup.MarginLayoutParams> {
                bottomMargin = insets.systemWindowInsetBottom +
                        resources.getDimensionPixelOffset(R.dimen.mtrl_bottomappbar_fab_bottom_margin)
            }
            insets
        }

        changeState(BaseService.State.Idle) // reset everything to init state
        connection.connect(this, this)
        DataStore.publicStore.registerChangeListener(this)
    }

    override fun onPreferenceDataStoreChanged(store: PreferenceDataStore, key: String) {
        when (key) {
            Key.serviceMode -> handler.post {
                connection.disconnect(this)
                connection.connect(this, this)
            }
        }
    }

    private fun displayFragment(fragment: ToolbarFragment) {
        supportFragmentManager.beginTransaction().replace(R.id.fragment_holder, fragment).commitAllowingStateLoss()
        drawer.closeDrawers()
    }

    override fun onNavigationItemSelected(item: MenuItem): Boolean {
        if (item.isChecked) drawer.closeDrawers() else {
            when (item.itemId) {
                R.id.profiles -> displayFragment(ProfilesFragment())
                R.id.globalSettings -> displayFragment(GlobalSettingsFragment())
                R.id.about -> {
                    Core.analytics.logEvent(""about"", Bundle())
                    displayFragment(AboutFragment())
                }
                R.id.faq -> {
                    launchUrl(getString(R.string.faq_url))
                    return true
                }
                R.id.customRules -> displayFragment(CustomRulesFragment())
                else -> return false
            }
            item.isChecked = true
        }
        return true
    }

    override fun onStart() {
        super.onStart()
        connection.bandwidthTimeout = 500
    }

    override fun onBackPressed() {
        if (drawer.isDrawerOpen(GravityCompat.START)) drawer.closeDrawers() else {
            val currentFragment = supportFragmentManager.findFragmentById(R.id.fragment_holder) as ToolbarFragment
            if (!currentFragment.onBackPressed()) {
                if (currentFragment is ProfilesFragment) super.onBackPressed() else {
                    navigation.menu.findItem(R.id.profiles).isChecked = true
                    displayFragment(ProfilesFragment())
                }
            }
        }
    }

    override fun onKeyShortcut(keyCode: Int, event: KeyEvent) = when {
        keyCode == KeyEvent.KEYCODE_G && event.hasModifiers(KeyEvent.META_CTRL_ON) -> {
            toggle()
            true
        }
        keyCode == KeyEvent.KEYCODE_T && event.hasModifiers(KeyEvent.META_CTRL_ON) -> {
            stats.testConnection()
            true
        }
        else -> (supportFragmentManager.findFragmentById(R.id.fragment_holder) as ToolbarFragment).toolbar.menu.let {
            it.setQwertyMode(KeyCharacterMap.load(event.deviceId).keyboardType != KeyCharacterMap.NUMERIC)
            it.performShortcut(keyCode, event, 0)
        }
    }

    override fun onStop() {
        connection.bandwidthTimeout = 0
        super.onStop()
    }

    override fun onDestroy() {
        super.onDestroy()
        DataStore.publicStore.unregisterChangeListener(this)
        connection.disconnect(this)
        BackupManager(this).dataChanged()
        handler.removeCallbacksAndMessages(null)
    }
}",KOT_03753,CWE-321: Hard-coded Cryptographic Key,A02: Cryptographic Failures;A04: Insecure Design,1
Kunzisoft__KeePassDX,200881278cf1808b8756e3f0a8bb5138fdd6cbd9,app/src/main/java/com/kunzisoft/keepass/credentialprovider/passkey/data/ClientDataBuildResponse.kt,.kt,J-Jamet,jeremy.jamet@kunzisoft.com,2025-09-01T14:48:36+02:00,fix: Change Android origin,1,,"/*
 * Copyright 2025 Jeremy Jamet / Kunzisoft.
 *
 * This file is part of KeePassDX.
 *
 *  KeePassDX is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  KeePassDX is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with KeePassDX.  If not, see <http://www.gnu.org/licenses/>.
 *
 */
package com.kunzisoft.keepass.credentialprovider.passkey.data

import com.kunzisoft.encrypt.HashManager
import com.kunzisoft.encrypt.Base64Helper.Companion.b64Encode
import org.json.JSONObject

open class ClientDataBuildResponse(
    type: Type,
    challenge: ByteArray,
    origin: String,
    crossOrigin: Boolean? = false,
    topOrigin: String? = null,
): AuthenticatorResponse, ClientDataResponse {
    override var clientJson = JSONObject()

    init {
        // https://w3c.github.io/webauthn/#client-data
        clientJson.put(""type"", type.value)
        clientJson.put(""challenge"", b64Encode(challenge))
        clientJson.put(""origin"", origin)
        crossOrigin?.let {
            clientJson.put(""crossOrigin"", it)
        }
        topOrigin?.let {
            clientJson.put(""topOrigin"", it)
        }
    }

    override fun json(): JSONObject {
        return clientJson
    }

    enum class Type(val value: String) {
        GET(""webauthn.get""), CREATE(""webauthn.create"")
    }

    override fun buildResponse(): String {
        return b64Encode(json().toString().toByteArray())
    }

    override fun hashData(): ByteArray {
        return HashManager.hashSha256(json().toString().toByteArray())
    }
}",KSEC_0020,,,0
square__okhttp,f2461183e8a70bae2362a5237772844a48e16100,samples/guide/src/main/java/okhttp3/recipes/PostForm.java,.java,jwilson,jwilson@squareup.com,2015-12-31T02:31:17-05:00,Refactor towards an OkHttpClient.Builder.,1,PostForm,"public final class PostForm {
  private final OkHttpClient client = new OkHttpClient.Builder().build();

  public void run() throws Exception {
    RequestBody formBody = new FormBody.Builder()
        .add(""search"", ""Jurassic Park"")
        .build();
    Request request = new Request.Builder()
        .url(""https://en.wikipedia.org/w/index.php"")
        .post(formBody)
        .build();

    Response response = client.newCall(request).execute();
    if (!response.isSuccessful()) throw new IOException(""Unexpected code "" + response);

    System.out.println(response.body().string());
  }

  public static void main(String... args) throws Exception {
    new PostForm().run();
  }
}",KOT_05230,,,0
thunderbird__thunderbird-android,5ab8497bc2c4844c86d9571b4b5f744302e95590,feature/notification/impl/src/commonMain/kotlin/net/thunderbird/feature/notification/impl/receiver/InAppNotificationEventBus.kt,.kt,Rafael Tonholo,rafael@tonholo.dev,2025-09-25T12:04:37-03:00,fix(notifications): in-app notification events getting lost by not having listeners,1,InAppNotificationEventBus,"internal interface InAppNotificationEventBus : InAppNotificationReceiver {
    /**
     * Publishes an in-app notification event to the event bus.
     *
     * @param event The [InAppNotificationEvent] to be published.
     */
    suspend fun publish(event: InAppNotificationEvent)
}",KSEC_1115,,,0
gedoor__legado,34083b6765409452f798328e8c8db74605f59548,app/src/main/java/io/legado/app/ui/rss/read/ReadRssActivity.kt,.kt,Xwite,1797350009@qq.com,2023-03-09T13:59:05+08:00,fix: viewModel hold activity may cause memory leak,1,ReadRssActivity,"class ReadRssActivity : VMBaseActivity<ActivityRssReadBinding, ReadRssViewModel>(false),
    ReadRssViewModel.CallBack {

    override val binding by viewBinding(ActivityRssReadBinding::inflate)
    override val viewModel by viewModels<ReadRssViewModel>()
    private var starMenuItem: MenuItem? = null
    private var ttsMenuItem: MenuItem? = null
    private var customWebViewCallback: WebChromeClient.CustomViewCallback? = null
    private val selectImageDir = registerForActivityResult(HandleFileContract()) {
        it.uri?.let { uri ->
            ACache.get().put(imagePathKey, uri.toString())
            viewModel.saveImage(it.value, uri)
        }
    }

    override fun onActivityCreated(savedInstanceState: Bundle?) {
        viewModel.callBack = this
        binding.titleBar.title = intent.getStringExtra(""title"")
        initWebView()
        initLiveData()
        viewModel.initData(intent)
    }

    @Suppress(""DEPRECATION"")
    @SuppressLint(""SwitchIntDef"")
    override fun onConfigurationChanged(newConfig: Configuration) {
        super.onConfigurationChanged(newConfig)
        when (newConfig.orientation) {
            Configuration.ORIENTATION_LANDSCAPE -> {
                window.clearFlags(WindowManager.LayoutParams.FLAG_FORCE_NOT_FULLSCREEN)
                window.addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN)
            }
            Configuration.ORIENTATION_PORTRAIT -> {
                window.clearFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN)
                window.addFlags(WindowManager.LayoutParams.FLAG_FORCE_NOT_FULLSCREEN)
            }
        }
    }

    override fun onCompatCreateOptionsMenu(menu: Menu): Boolean {
        menuInflater.inflate(R.menu.rss_read, menu)
        return super.onCompatCreateOptionsMenu(menu)
    }

    override fun onPrepareOptionsMenu(menu: Menu): Boolean {
        starMenuItem = menu.findItem(R.id.menu_rss_star)
        ttsMenuItem = menu.findItem(R.id.menu_aloud)
        upStarMenu()
        return super.onPrepareOptionsMenu(menu)
    }

    override fun onMenuOpened(featureId: Int, menu: Menu): Boolean {
        menu.findItem(R.id.menu_login)?.isVisible = !viewModel.rssSource?.loginUrl.isNullOrBlank()
        return super.onMenuOpened(featureId, menu)
    }

    override fun onCompatOptionsItemSelected(item: MenuItem): Boolean {
        when (item.itemId) {
            R.id.menu_rss_refresh -> viewModel.refresh {
                binding.webView.reload()
            }
            R.id.menu_rss_star -> viewModel.favorite()
            R.id.menu_share_it -> {
                binding.webView.url?.let {
                    share(it)
                } ?: viewModel.rssArticle?.let {
                    share(it.link)
                } ?: toastOnUi(R.string.null_url)
            }
            R.id.menu_aloud -> readAloud()
            R.id.menu_login -> startActivity<SourceLoginActivity> {
                putExtra(""type"", ""rssSource"")
                putExtra(""key"", viewModel.rssSource?.loginUrl)
            }
            R.id.menu_browser_open -> binding.webView.url?.let {
                openUrl(it)
            } ?: toastOnUi(""url null"")
        }
        return super.onCompatOptionsItemSelected(item)
    }

    @JavascriptInterface
    fun isNightTheme(): Boolean {
        return AppConfig.isNightTheme(this)
    }

    @SuppressLint(""SetJavaScriptEnabled"")
    private fun initWebView() {
        binding.progressBar.fontColor = accentColor
        binding.webView.webChromeClient = CustomWebChromeClient()
        binding.webView.webViewClient = CustomWebViewClient()
        binding.webView.settings.apply {
            mixedContentMode = WebSettings.MIXED_CONTENT_ALWAYS_ALLOW
            domStorageEnabled = true
            allowContentAccess = true
            builtInZoomControls = true
            displayZoomControls = false
            setDarkeningAllowed(AppConfig.isNightTheme)
        }
        binding.webView.addJavascriptInterface(this, ""thisActivity"")
        viewModel.rssSource?.let {
            binding.webView.addJavascriptInterface(it, ""thisSource"")
        }
        binding.webView.setOnLongClickListener {
            val hitTestResult = binding.webView.hitTestResult
            if (hitTestResult.type == WebView.HitTestResult.IMAGE_TYPE ||
                hitTestResult.type == WebView.HitTestResult.SRC_IMAGE_ANCHOR_TYPE
            ) {
                hitTestResult.extra?.let { webPic ->
                    selector(
                        arrayListOf(
                            SelectItem(getString(R.string.action_save), ""save""),
                            SelectItem(getString(R.string.select_folder), ""selectFolder"")
                        )
                    ) { _, charSequence, _ ->
                        when (charSequence.value) {
                            ""save"" -> saveImage(webPic)
                            ""selectFolder"" -> selectSaveFolder(null)
                        }
                    }
                    return@setOnLongClickListener true
                }
            }
            return@setOnLongClickListener false
        }
        binding.webView.setDownloadListener { url, _, contentDisposition, _, _ ->
            var fileName = URLUtil.guessFileName(url, contentDisposition, null)
            fileName = URLDecoder.decode(fileName, ""UTF-8"")
            binding.llView.longSnackbar(fileName, getString(R.string.action_download)) {
                Download.start(this, url, fileName)
            }
        }

    }

    private fun saveImage(webPic: String) {
        val path = ACache.get().getAsString(imagePathKey)
        if (path.isNullOrEmpty()) {
            selectSaveFolder(webPic)
        } else {
            viewModel.saveImage(webPic, Uri.parse(path))
        }
    }

    private fun selectSaveFolder(webPic: String?) {
        val default = arrayListOf<SelectItem<Int>>()
        val path = ACache.get().getAsString(imagePathKey)
        if (!path.isNullOrEmpty()) {
            default.add(SelectItem(path, -1))
        }
        selectImageDir.launch {
            otherActions = default
            value = webPic
        }
    }

    @SuppressLint(""SetJavaScriptEnabled"")
    private fun initLiveData() {
        viewModel.contentLiveData.observe(this) { content ->
            viewModel.rssArticle?.let {
                upJavaScriptEnable()
                val url = NetworkUtils.getAbsoluteURL(it.origin, it.link)
                val html = viewModel.clHtml(content)
                binding.webView.settings.userAgentString =
                    viewModel.rssSource?.getHeaderMap()?.get(AppConst.UA_NAME, true)
                        ?: AppConfig.userAgent
                if (viewModel.rssSource?.loadWithBaseUrl == true) {
                    binding.webView
                        .loadDataWithBaseURL(url, html, ""text/html"", ""utf-8"", url)//不想用baseUrl进else
                } else {
                    binding.webView
                        .loadDataWithBaseURL(null, html, ""text/html;charset=utf-8"", ""utf-8"", url)
                }
            }
        }
        viewModel.urlLiveData.observe(this) {
            upJavaScriptEnable()
            binding.webView.settings.userAgentString = it.getUserAgent()
            binding.webView.loadUrl(it.url, it.headerMap)
        }
    }

    @SuppressLint(""SetJavaScriptEnabled"")
    private fun upJavaScriptEnable() {
        if (viewModel.rssSource?.enableJs == true) {
            binding.webView.settings.javaScriptEnabled = true
        }
    }

    override fun upStarMenu() {
        starMenuItem?.isVisible = viewModel.rssArticle != null
        if (viewModel.rssStar != null) {
            starMenuItem?.setIcon(R.drawable.ic_star)
            starMenuItem?.setTitle(R.string.in_favorites)
        } else {
            starMenuItem?.setIcon(R.drawable.ic_star_border)
            starMenuItem?.setTitle(R.string.out_favorites)
        }
        starMenuItem?.icon?.setTintMutate(primaryTextColor)
    }

    override fun upTtsMenu(isPlaying: Boolean) {
        launch {
            if (isPlaying) {
                ttsMenuItem?.setIcon(R.drawable.ic_stop_black_24dp)
                ttsMenuItem?.setTitle(R.string.aloud_stop)
            } else {
                ttsMenuItem?.setIcon(R.drawable.ic_volume_up)
                ttsMenuItem?.setTitle(R.string.read_aloud)
            }
            ttsMenuItem?.icon?.setTintMutate(primaryTextColor)
        }
    }

    override fun onKeyLongPress(keyCode: Int, event: KeyEvent?): Boolean {
        when (keyCode) {
            KeyEvent.KEYCODE_BACK -> {
                finish()
                return true
            }
        }
        return super.onKeyLongPress(keyCode, event)
    }

    override fun onKeyUp(keyCode: Int, event: KeyEvent?): Boolean {
        event?.let {
            when (keyCode) {
                KeyEvent.KEYCODE_BACK -> if (event.isTracking && !event.isCanceled && binding.webView.canGoBack()) {
                    if (binding.customWebView.size > 0) {
                        customWebViewCallback?.onCustomViewHidden()
                        return true
                    } else if (binding.webView.copyBackForwardList().size > 1) {
                        binding.webView.goBack()
                        return true
                    }
                }
            }
        }
        return super.onKeyUp(keyCode, event)
    }

    @SuppressLint(""SetJavaScriptEnabled"")
    private fun readAloud() {
        if (viewModel.tts?.isSpeaking == true) {
            viewModel.tts?.stop()
            upTtsMenu(false)
        } else {
            binding.webView.settings.javaScriptEnabled = true
            binding.webView.evaluateJavascript(""document.documentElement.outerHTML"") {
                val html = StringEscapeUtils.unescapeJson(it)
                    .replace(""^\""|\""$"".toRegex(), """")
                viewModel.readAloud(
                    Jsoup.parse(html)
                        .textArray()
                        .joinToString(""\n"")
                )
            }
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        binding.webView.destroy()
    }

    inner class CustomWebChromeClient : WebChromeClient() {

        override fun onProgressChanged(view: WebView?, newProgress: Int) {
            super.onProgressChanged(view, newProgress)
            binding.progressBar.setDurProgress(newProgress)
            binding.progressBar.gone(newProgress == 100)
        }

        override fun onShowCustomView(view: View?, callback: CustomViewCallback?) {
            requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_SENSOR
            binding.llView.invisible()
            binding.customWebView.addView(view)
            customWebViewCallback = callback
        }

        override fun onHideCustomView() {
            binding.customWebView.removeAllViews()
            binding.llView.visible()
            requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED
        }
    }

    inner class CustomWebViewClient : WebViewClient() {

        override fun shouldOverrideUrlLoading(
            view: WebView,
            request: WebResourceRequest
        ): Boolean {
            return shouldOverrideUrlLoading(request.url)
        }

        @Suppress(""DEPRECATION"", ""OVERRIDE_DEPRECATION"", ""KotlinRedundantDiagnosticSuppress"")
        override fun shouldOverrideUrlLoading(view: WebView, url: String): Boolean {
            return shouldOverrideUrlLoading(Uri.parse(url))
        }

        /**
         * 如果有黑名单,黑名单匹配返回空白,
         * 没有黑名单再判断白名单,在白名单中的才通过,
         * 都没有不做处理
         */
        override fun shouldInterceptRequest(
            view: WebView,
            request: WebResourceRequest
        ): WebResourceResponse? {
            val url = request.url.toString()
            viewModel.rssSource?.let { source ->
                val blacklist = source.contentBlacklist?.splitNotBlank("","")
                if (!blacklist.isNullOrEmpty()) {
                    blacklist.forEach {
                        if (url.startsWith(it) || url.matches(it.toRegex())) {
                            return createEmptyResource()
                        }
                    }
                } else {
                    val whitelist = source.contentWhitelist?.splitNotBlank("","")
                    if (!whitelist.isNullOrEmpty()) {
                        whitelist.forEach {
                            if (url.startsWith(it) || url.matches(it.toRegex())) {
                                return super.shouldInterceptRequest(view, request)
                            }
                        }
                        return createEmptyResource()
                    }
                }
            }
            return super.shouldInterceptRequest(view, request)
        }

        override fun onPageFinished(view: WebView, url: String?) {
            super.onPageFinished(view, url)
            view.title?.let { title ->
                if (title != url && title != view.url && title.isNotBlank() && url != ""about:blank"") {
                    binding.titleBar.title = title
                } else {
                    binding.titleBar.title = intent.getStringExtra(""title"")
                }
            }
            viewModel.rssSource?.injectJs?.let {
                if (it.isNotBlank()) {
                    view.evaluateJavascript(it, null)
                }
            }
        }

        private fun createEmptyResource(): WebResourceResponse {
            return WebResourceResponse(
                ""text/plain"",
                ""utf-8"",
                ByteArrayInputStream("""".toByteArray())
            )
        }

        private fun shouldOverrideUrlLoading(url: Uri): Boolean {
            when (url.scheme) {
                ""http"", ""https"", ""jsbridge"" -> {
                    return false
                }
                ""legado"", ""yuedu"" -> {
                    startActivity<OnLineImportActivity> {
                        data = url
                    }
                    return true
                }
                else -> {
                    binding.root.longSnackbar(R.string.jump_to_another_app, R.string.confirm) {
                        openUrl(url)
                    }
                    return true
                }
            }
        }

    }

}",KOT_00493,CWE-749: Exposed Dangerous Method or Function;CWE-79: Cross-site Scripting (XSS),MSTG-PLATFORM-3,1
JetBrains__kotlin,7f11a85dcd6c08c98a5668042c3083e60b009fca,compiler/testData/klib/syntheticAccessors/privateMember/crossModulePrivateLeak/leakingPrivateVarThroughReferenceInInternalInlineFun.kt,.kt,Ivan Kylchik,ivan.kylchik@jetbrains.com,2025-10-07T09:58:41+02:00,[Inline] Apply a patch to ignore broken preprocessed funs in klib,1,,"// IGNORE_KLIB_SYNTHETIC_ACCESSORS_CHECKS: JS_IR
// MODULE: lib
// FILE: A.kt
class A {
    private var privateVar = 22

    internal inline fun internalInlineFunction() = ::privateVar
}

// MODULE: main()(lib)
// FILE: main.kt
fun box(): String {
    var result = 0
    A().run {
        result += internalInlineFunction().get()
        internalInlineFunction().set(20)
        result += internalInlineFunction().get()
    }
    if (result != 42) return result.toString()
    return ""OK""
}
",KOT_01620,,,0
JetBrains__kotlin,4980ea9ea84b5e486091e2c439037a4a8c10377e,analysis/analysis-api/testData/symbols/symbolByPsi/valueClassWithImplicitlyActualConstructorAndProperty.kt,.kt,Azat Abdullin,azat.abdullin@jetbrains.com,2025-08-21T17:27:19+02:00,"[Analysis API] Fix isActual for implicitly actual members of annotation, value, and inline classes",1,,"// KT-80234
// DO_NOT_CHECK_SYMBOL_RESTORE_K1

// LANGUAGE: +MultiPlatformProjects
// MODULE: common
// FILE: common.kt

expect value class A(val name: String)

expect inline class B(val s: String)

// MODULE: jvm()()(common)
// FILE: main.kt

actual value class A(val name: String)

actual inline class B(val s: String)
",KOT_02355,,,0
thunderbird__thunderbird-android,f3436f093218ca6dfacdef85a559a6a876895f14,feature/account/server/settings/src/main/kotlin/app/k9mail/feature/account/server/settings/domain/ServerSettingsDomainContract.kt,.kt,Wolf-Martell Montwé,wolf@thunderbird.net,2025-05-16T18:02:54+02:00,refactor(core-common): change to kmp,1,,"package app.k9mail.feature.account.server.settings.domain

import net.thunderbird.core.common.domain.usecase.validation.ValidationResult

interface ServerSettingsDomainContract {

    interface UseCase {

        fun interface ValidatePassword {
            fun execute(password: String): ValidationResult
        }

        fun interface ValidateServer {
            fun execute(server: String): ValidationResult
        }

        fun interface ValidatePort {
            fun execute(port: Long?): ValidationResult
        }

        fun interface ValidateUsername {
            fun execute(username: String): ValidationResult
        }

        fun interface ValidateImapPrefix {
            fun execute(imapPrefix: String): ValidationResult
        }
    }
}
",KSEC_1738,,,0
duckduckgo__Android,9a6b40b3a0e2fa8663dc993f0f4a67e85b0a6b89,network-protection/network-protection-impl/src/main/java/com/duckduckgo/networkprotection/impl/exclusion/systemapps/SystemAppsExclusionRepository.kt,.kt,Mike Scamell,mikescamell@users.noreply.github.com,2025-10-01T17:04:53+01:00,Rollback Ktlint update (#6865),1,,"/*
 * Copyright (c) 2024 DuckDuckGo
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.duckduckgo.networkprotection.impl.exclusion.systemapps

import android.content.SharedPreferences
import android.content.pm.ApplicationInfo
import android.content.pm.PackageManager
import androidx.core.content.edit
import com.duckduckgo.common.utils.DispatcherProvider
import com.duckduckgo.data.store.api.SharedPreferencesProvider
import com.duckduckgo.di.scopes.AppScope
import com.duckduckgo.feature.toggles.api.Toggle.State
import com.duckduckgo.mobile.android.vpn.exclusion.SystemAppOverridesProvider
import com.duckduckgo.networkprotection.impl.exclusion.isSystemApp
import com.duckduckgo.networkprotection.impl.exclusion.systemapps.SystemAppsExclusionRepository.SystemAppCategory
import com.duckduckgo.networkprotection.impl.exclusion.systemapps.SystemAppsExclusionRepository.SystemAppCategory.Communication
import com.duckduckgo.networkprotection.impl.exclusion.systemapps.SystemAppsExclusionRepository.SystemAppCategory.Media
import com.duckduckgo.networkprotection.impl.exclusion.systemapps.SystemAppsExclusionRepository.SystemAppCategory.Networking
import com.duckduckgo.networkprotection.impl.exclusion.systemapps.SystemAppsExclusionRepository.SystemAppCategory.Others
import com.duckduckgo.networkprotection.impl.settings.NetPSettingsLocalConfig
import com.squareup.anvil.annotations.ContributesBinding
import dagger.SingleInstanceIn
import javax.inject.Inject
import kotlinx.coroutines.withContext

interface SystemAppsExclusionRepository {
    suspend fun excludeCategory(category: SystemAppCategory)
    suspend fun includeCategory(category: SystemAppCategory)
    suspend fun isCategoryExcluded(category: SystemAppCategory): Boolean
    suspend fun getAvailableCategories(): Set<SystemAppCategory>

    suspend fun getExcludedCategories(): Set<SystemAppCategory>

    suspend fun getAllExcludedSystemApps(): Set<String>

    suspend fun restoreDefaults()

    suspend fun hasShownWarning(): Boolean
    suspend fun markWarningShown()

    sealed class SystemAppCategory(val name: String) {
        data object Communication : SystemAppCategory(""Communication"")
        data object Networking : SystemAppCategory(""Networking"")
        data object Media : SystemAppCategory(""Media"")
        data object Others : SystemAppCategory(""Others"")
    }
}

@ContributesBinding(AppScope::class)
@SingleInstanceIn(AppScope::class)
class RealSystemAppsExclusionRepository @Inject constructor(
    private val netPSettingsLocalConfig: NetPSettingsLocalConfig,
    private val sharedPreferencesProvider: SharedPreferencesProvider,
    private val packageManager: PackageManager,
    private val systemAppOverridesProvider: SystemAppOverridesProvider,
    private val dispatcherProvider: DispatcherProvider,
) : SystemAppsExclusionRepository {
    private val preferences: SharedPreferences by lazy {
        sharedPreferencesProvider.getSharedPreferences(
            FILENAME,
            multiprocess = false,
            migrate = false,
        )
    }

    override suspend fun excludeCategory(category: SystemAppCategory) = withContext(dispatcherProvider.io()) {
        when (category) {
            is Communication -> netPSettingsLocalConfig.excludeSystemAppsCommunication()
            is Networking -> netPSettingsLocalConfig.excludeSystemAppsNetworking()
            is Media -> netPSettingsLocalConfig.excludeSystemAppsMedia()
            is Others -> netPSettingsLocalConfig.excludeSystemAppsOthers()
        }.setRawStoredState(State(true))
    }

    override suspend fun includeCategory(category: SystemAppCategory) = withContext(dispatcherProvider.io()) {
        when (category) {
            is Communication -> netPSettingsLocalConfig.excludeSystemAppsCommunication()
            is Networking -> netPSettingsLocalConfig.excludeSystemAppsNetworking()
            is Media -> netPSettingsLocalConfig.excludeSystemAppsMedia()
            is Others -> netPSettingsLocalConfig.excludeSystemAppsOthers()
        }.setRawStoredState(State(false))
    }

    override suspend fun isCategoryExcluded(category: SystemAppCategory): Boolean = withContext(dispatcherProvider.io()) {
        return@withContext when (category) {
            is Communication -> netPSettingsLocalConfig.excludeSystemAppsCommunication()
            is Networking -> netPSettingsLocalConfig.excludeSystemAppsNetworking()
            is Media -> netPSettingsLocalConfig.excludeSystemAppsMedia()
            is Others -> netPSettingsLocalConfig.excludeSystemAppsOthers()
        }.isEnabled()
    }

    override suspend fun hasShownWarning(): Boolean = withContext(dispatcherProvider.io()) {
        return@withContext preferences.getBoolean(KEY_WARNING_SHOWN, false)
    }

    override suspend fun markWarningShown() = withContext(dispatcherProvider.io()) {
        preferences.edit(commit = true) {
            putBoolean(KEY_WARNING_SHOWN, true)
        }
    }

    override suspend fun getAvailableCategories(): Set<SystemAppCategory> = withContext(dispatcherProvider.io()) {
        return@withContext setOf(
            Communication,
            Networking,
            Media,
            Others,
        )
    }

    override suspend fun getExcludedCategories(): Set<SystemAppCategory> {
        return buildSet {
            getAvailableCategories().forEach {
                if (isCategoryExcluded(it)) add(it)
            }
        }
    }

    override suspend fun getAllExcludedSystemApps(): Set<String> = withContext(dispatcherProvider.io()) {
        return@withContext buildSet {
            if (isCategoryExcluded(Communication)) addAll(getCommunicationSystemApps())
            if (isCategoryExcluded(Networking)) addAll(getNetworkingSystemApps())
            if (isCategoryExcluded(Media)) addAll(getMediaSystemApps())
            if (isCategoryExcluded(Others)) addAll(getOtherSystemApps())
        }
    }

    override suspend fun restoreDefaults() {
        includeCategory(Communication)
        includeCategory(Networking)
        includeCategory(Media)
        includeCategory(Others)
    }

    private fun getCommunicationSystemApps(): Set<String> {
        return setOf(
            ""com.android.calllogbackup"",
            ""com.android.cellbroadcastreceiver"",
            ""com.android.mms.service"",
            ""com.android.phone"",
            ""com.android.providers.contacts"",
            ""com.android.providers.telephony"",
            ""com.android.service.ims"",
            ""com.google.android.apps.messaging"",
            ""com.google.android.gms"",
            ""com.google.android.telephony"",
            ""org.codeaurora.ims"",
            ""com.google.android.cellbroadcastservice"",
            ""com.wsomacp"",
            ""com.samsung.android.incall.contentprovider"",
            ""com.android.carrierconfig"",
            ""com.android.stk"",
            ""com.samsung.android.app.telephonyui"",
            ""com.sec.imsservice"",
            ""com.samsung.android.smartcallprovider"",
            ""com.android.server.telecom"",
            ""com.samsung.android.callbgprovider"",
        )
    }

    private fun getNetworkingSystemApps(): Set<String> {
        return setOf(
            ""com.android.bluetooth"",
            ""com.android.nfc"",
            ""com.google.android.networkstack"",
            ""com.google.android.networkstack.tethering"",
            ""com.samsung.android.networkstack"",
            ""com.samsung.android.wifi.softapdualap.resources"",
            ""com.google.android.networkstack.tethering.overlay"",
            ""com.samsung.android.wifi.p2paware.resources"",
            ""com.samsung.android.wifi.softap.resource"",
            ""com.samsung.android.wifi.resources"",
            ""com.android.wifi.resources"",
            ""com.google.android.apps.carrier.carrierwifi"",
        )
    }

    private fun getMediaSystemApps(): Set<String> {
        return setOf(
            ""com.android.providers.media"",
            ""com.google.android.providers.media.module"",
            ""com.google.android.music"",
            ""com.google.android.videos"",
        )
    }

    private fun getOtherSystemApps(): Set<String> {
        return packageManager.getInstalledApplications(PackageManager.GET_META_DATA)
            .asSequence()
            .filter { it.isSystemApp() && !it.isSystemAppOveridden() && !it.isCategorized() }
            .map { it.packageName }
            .toSet()
    }

    private fun ApplicationInfo.isSystemAppOveridden() = systemAppOverridesProvider.getSystemAppOverridesList().contains(packageName)

    private fun ApplicationInfo.isCategorized(): Boolean {
        return getCommunicationSystemApps().contains(packageName) ||
            getNetworkingSystemApps().contains(packageName) ||
            getMediaSystemApps().contains(packageName)
    }

    companion object {
        private const val FILENAME = ""com.duckduckgo.networkprotection.exclusion.systemapps""
        private const val KEY_WARNING_SHOWN = ""KEY_SYSTEM_APPS_WARNING_SHOWN""
    }
}
",KSEC_1033,['CWE-321: Hard-coded Cryptographic Key'],"['A02: Cryptographic Failures', 'A04: Insecure Design']",1
square__okhttp,a51cfbf841927910a4341bcc2d9ad9c93d05a785,okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/ws/WebSocketExtensions.kt,.kt,renovate[bot],29139614+renovate[bot]@users.noreply.github.com,2025-03-19T15:25:20-04:00,Update dependency com.diffplug.spotless:spotless-plugin-gradle to v7 (#8702),1,WebSocketExtensions,"data class WebSocketExtensions(
  /** True if the agreed upon extensions includes the permessage-deflate extension. */
  @JvmField val perMessageDeflate: Boolean = false,
  /** Should be a value in [8..15]. Only 15 is acceptable by OkHttp as Java APIs are limited. */
  @JvmField val clientMaxWindowBits: Int? = null,
  /** True if the agreed upon extension parameters includes ""client_no_context_takeover"". */
  @JvmField val clientNoContextTakeover: Boolean = false,
  /** Should be a value in [8..15]. Any value in that range is acceptable by OkHttp. */
  @JvmField val serverMaxWindowBits: Int? = null,
  /** True if the agreed upon extension parameters includes ""server_no_context_takeover"". */
  @JvmField val serverNoContextTakeover: Boolean = false,
  /**
   * True if the agreed upon extensions or parameters contained values unrecognized by OkHttp.
   * Typically this indicates that the client will need to close the web socket with code 1010.
   */
  @JvmField val unknownValues: Boolean = false,
) {
  fun noContextTakeover(clientOriginated: Boolean): Boolean {
    return if (clientOriginated) {
      clientNoContextTakeover // Client is deflating.
    } else {
      serverNoContextTakeover // Server is deflating.
    }
  }

  companion object {
    private const val HEADER_WEB_SOCKET_EXTENSION = ""Sec-WebSocket-Extensions""

    @Throws(IOException::class)
    fun parse(responseHeaders: Headers): WebSocketExtensions {
      // Note that this code does case-insensitive comparisons, even though the spec doesn't specify
      // whether extension tokens and parameters are case-insensitive or not.

      var compressionEnabled = false
      var clientMaxWindowBits: Int? = null
      var clientNoContextTakeover = false
      var serverMaxWindowBits: Int? = null
      var serverNoContextTakeover = false
      var unexpectedValues = false

      // Parse each header.
      for (i in 0 until responseHeaders.size) {
        if (!responseHeaders.name(i).equals(HEADER_WEB_SOCKET_EXTENSION, ignoreCase = true)) {
          continue // Not a header we're interested in.
        }
        val header = responseHeaders.value(i)

        // Parse each extension.
        var pos = 0
        while (pos < header.length) {
          val extensionEnd = header.delimiterOffset(',', pos)
          val extensionTokenEnd = header.delimiterOffset(';', pos, extensionEnd)
          val extensionToken = header.trimSubstring(pos, extensionTokenEnd)
          pos = extensionTokenEnd + 1

          when {
            extensionToken.equals(""permessage-deflate"", ignoreCase = true) -> {
              if (compressionEnabled) unexpectedValues = true // Repeated extension!
              compressionEnabled = true

              // Parse each permessage-deflate parameter.
              while (pos < extensionEnd) {
                val parameterEnd = header.delimiterOffset(';', pos, extensionEnd)
                val equals = header.delimiterOffset('=', pos, parameterEnd)
                val name = header.trimSubstring(pos, equals)
                val value =
                  if (equals < parameterEnd) {
                    header.trimSubstring(equals + 1, parameterEnd).removeSurrounding(""\"""")
                  } else {
                    null
                  }
                pos = parameterEnd + 1
                when {
                  name.equals(""client_max_window_bits"", ignoreCase = true) -> {
                    if (clientMaxWindowBits != null) unexpectedValues = true // Repeated parameter!
                    clientMaxWindowBits = value?.toIntOrNull()
                    if (clientMaxWindowBits == null) unexpectedValues = true // Not an int!
                  }
                  name.equals(""client_no_context_takeover"", ignoreCase = true) -> {
                    if (clientNoContextTakeover) unexpectedValues = true // Repeated parameter!
                    if (value != null) unexpectedValues = true // Unexpected value!
                    clientNoContextTakeover = true
                  }
                  name.equals(""server_max_window_bits"", ignoreCase = true) -> {
                    if (serverMaxWindowBits != null) unexpectedValues = true // Repeated parameter!
                    serverMaxWindowBits = value?.toIntOrNull()
                    if (serverMaxWindowBits == null) unexpectedValues = true // Not an int!
                  }
                  name.equals(""server_no_context_takeover"", ignoreCase = true) -> {
                    if (serverNoContextTakeover) unexpectedValues = true // Repeated parameter!
                    if (value != null) unexpectedValues = true // Unexpected value!
                    serverNoContextTakeover = true
                  }
                  else -> {
                    unexpectedValues = true // Unexpected parameter.
                  }
                }
              }
            }

            else -> {
              unexpectedValues = true // Unexpected extension.
            }
          }
        }
      }

      return WebSocketExtensions(
        perMessageDeflate = compressionEnabled,
        clientMaxWindowBits = clientMaxWindowBits,
        clientNoContextTakeover = clientNoContextTakeover,
        serverMaxWindowBits = serverMaxWindowBits,
        serverNoContextTakeover = serverNoContextTakeover,
        unknownValues = unexpectedValues,
      )
    }
  }
}",KOT_04446,CWE-321: Hard-coded Cryptographic Key,A02: Cryptographic Failures;A04: Insecure Design,1
recloudstream__cloudstream,e1932147595e5c141c88f12af18c3dcb4854dff0,library/src/commonMain/kotlin/com/lagradost/cloudstream3/extractors/Filesim.kt,.kt,Phisher98,153359846+phisher98@users.noreply.github.com,2025-08-22T19:59:57+05:30,Minor Fix for Filemoon (#1858),1,FileMoonIn,"class FileMoonIn : Filesim() {
    override val mainUrl = ""https://filemoon.in""
    override val name = ""FileMoon""
}",KSEC_0539,['CWE-321: Hard-coded Cryptographic Key'],"['A02: Cryptographic Failures', 'A04: Insecure Design']",1
duckduckgo__Android,9b602933431196513b34376b4dc9cf605c86c123,privacy-config/privacy-config-impl/src/test/java/com/duckduckgo/privacy/config/impl/features/trackerallowlist/TrackerAllowlistPluginTest.kt,.kt,Craig Russell,CDRussell@users.noreply.github.com,2021-12-24T11:26:59+00:00,"Upgrade to Mockito 4, sort out test config problems (#1640)",1,,"/*
 * Copyright (c) 2021 DuckDuckGo
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.duckduckgo.privacy.config.impl.features.trackerallowlist

import com.duckduckgo.privacy.config.impl.FileUtilities
import com.duckduckgo.privacy.config.store.PrivacyFeatureToggles
import com.duckduckgo.privacy.config.store.PrivacyFeatureTogglesRepository
import com.duckduckgo.privacy.config.store.TrackerAllowlistEntity
import com.duckduckgo.privacy.config.store.features.trackerallowlist.TrackerAllowlistRepository
import com.nhaarman.mockitokotlin2.argumentCaptor
import com.nhaarman.mockitokotlin2.mock
import com.nhaarman.mockitokotlin2.verify
import org.junit.Assert.*
import org.junit.Before
import org.junit.Test

class TrackerAllowlistPluginTest {
    lateinit var testee: TrackerAllowlistPlugin

    private val mockFeatureTogglesRepository: PrivacyFeatureTogglesRepository = mock()
    private val mockAllowlistRepository: TrackerAllowlistRepository = mock()

    @Before
    fun before() {
        testee = TrackerAllowlistPlugin(mockAllowlistRepository, mockFeatureTogglesRepository)
    }

    @Test
    fun whenFeatureNameDoesNotMatchTrackerAllowlistThenReturnFalse() {
        assertFalse(testee.store(""test"", EMPTY_JSON_STRING))
    }

    @Test
    fun whenFeatureNameMatchesTrackerAllowlistThenReturnTrue() {
        assertTrue(testee.store(FEATURE_NAME, EMPTY_JSON_STRING))
    }

    @Test
    fun whenFeatureNameMatchesTrackerAllowlistAndIsEnabledThenStoreFeatureEnabled() {
        val jsonString = FileUtilities.loadText(""json/tracker_allowlist.json"")

        testee.store(FEATURE_NAME, jsonString)

        verify(mockFeatureTogglesRepository).insert(PrivacyFeatureToggles(FEATURE_NAME, true))
    }

    @Test
    fun whenFeatureNameMatchesTrackerAllowlistAndIsNotEnabledThenStoreFeatureDisabled() {
        val jsonString = FileUtilities.loadText(""json/tracker_allowlist_disabled.json"")

        testee.store(FEATURE_NAME, jsonString)

        verify(mockFeatureTogglesRepository).insert(PrivacyFeatureToggles(FEATURE_NAME, false))
    }

    @Test
    fun whenFeatureNameMatchesTrackerAllowlistThenUpdateAllExistingExceptions() {
        val jsonString = FileUtilities.loadText(""json/tracker_allowlist.json"")

        testee.store(FEATURE_NAME, jsonString)

        argumentCaptor<List<TrackerAllowlistEntity>>().apply {
            verify(mockAllowlistRepository).updateAll(capture())
            val trackerAllowlistEntity = this.firstValue.first()
            val rules = trackerAllowlistEntity.rules
            assertEquals(1, this.allValues.size)
            assertEquals(""allowlist-tracker-1.com"", trackerAllowlistEntity.domain)
            assertEquals(""allowlist-tracker-1.com/videos.js"", rules.first().rule)
            assertEquals(""testsite.com"", rules.first().domains.first())
            assertEquals(""match single resource on single site"", rules.first().reason)
        }
    }

    companion object {
        private const val FEATURE_NAME = ""trackerAllowlist""
        private const val EMPTY_JSON_STRING = ""{}""
    }
}
",KSEC_5622,['CWE-321: Hard-coded Cryptographic Key'],"['A02: Cryptographic Failures', 'A04: Insecure Design']",1
shadowsocks__shadowsocks-android,b001432d80cf9107cf4066b9011bbba665defd2a,mobile/src/main/java/com/github/shadowsocks/MainActivity.kt,.kt,Mygod,contact-github@mygod.be,2018-12-11T13:25:04+08:00,Fix snackbar,1,MainActivity,"/*******************************************************************************
 *                                                                             *
 *  Copyright (C) 2017 by Max Lv <max.c.lv@gmail.com>                          *
 *  Copyright (C) 2017 by Mygod Studio <contact-shadowsocks-android@mygod.be>  *
 *                                                                             *
 *  This program is free software: you can redistribute it and/or modify       *
 *  it under the terms of the GNU General Public License as published by       *
 *  the Free Software Foundation, either version 3 of the License, or          *
 *  (at your option) any later version.                                        *
 *                                                                             *
 *  This program is distributed in the hope that it will be useful,            *
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of             *
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              *
 *  GNU General Public License for more details.                               *
 *                                                                             *
 *  You should have received a copy of the GNU General Public License          *
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.       *
 *                                                                             *
 *******************************************************************************/

package com.github.shadowsocks

import android.app.Activity
import android.app.backup.BackupManager
import android.content.ActivityNotFoundException
import android.content.Intent
import android.net.VpnService
import android.nfc.NdefMessage
import android.nfc.NfcAdapter
import android.os.Bundle
import android.util.Log
import android.view.KeyCharacterMap
import android.view.KeyEvent
import android.view.MenuItem
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatActivity
import androidx.browser.customtabs.CustomTabsIntent
import androidx.coordinatorlayout.widget.CoordinatorLayout
import androidx.core.content.ContextCompat
import androidx.core.net.toUri
import androidx.core.view.GravityCompat
import androidx.core.view.updateLayoutParams
import androidx.drawerlayout.widget.DrawerLayout
import androidx.preference.PreferenceDataStore
import com.crashlytics.android.Crashlytics
import com.github.shadowsocks.acl.CustomRulesFragment
import com.github.shadowsocks.aidl.IShadowsocksService
import com.github.shadowsocks.aidl.IShadowsocksServiceCallback
import com.github.shadowsocks.bg.BaseService
import com.github.shadowsocks.bg.Executable
import com.github.shadowsocks.database.Profile
import com.github.shadowsocks.database.ProfileManager
import com.github.shadowsocks.preference.DataStore
import com.github.shadowsocks.preference.OnPreferenceDataStoreChangeListener
import com.github.shadowsocks.utils.Key
import com.github.shadowsocks.widget.ServiceButton
import com.github.shadowsocks.widget.StatsBar
import com.google.android.material.navigation.NavigationView
import com.google.android.material.snackbar.Snackbar
import kotlin.math.roundToInt

class MainActivity : AppCompatActivity(), ShadowsocksConnection.Interface, OnPreferenceDataStoreChangeListener,
        NavigationView.OnNavigationItemSelectedListener {
    companion object {
        private const val TAG = ""ShadowsocksMainActivity""
        private const val REQUEST_CONNECT = 1

        var stateListener: ((Int) -> Unit)? = null
    }

    // UI
    private lateinit var fab: ServiceButton
    private lateinit var stats: StatsBar
    internal lateinit var drawer: DrawerLayout
    private lateinit var navigation: NavigationView

    val snackbar by lazy { findViewById<CoordinatorLayout>(R.id.snackbar) }
    fun snackbar(text: CharSequence = """") = Snackbar.make(snackbar, text, Snackbar.LENGTH_LONG).apply {
        view.updateLayoutParams<CoordinatorLayout.LayoutParams> {
            bottomMargin += snackbar.measuredHeight - fab.top - fab.translationY.roundToInt()
        }
    }

    private val customTabsIntent by lazy {
        CustomTabsIntent.Builder()
                .setToolbarColor(ContextCompat.getColor(this, R.color.color_primary))
                .build()
    }
    fun launchUrl(uri: String) = try {
        customTabsIntent.launchUrl(this, uri.toUri())
    } catch (_: ActivityNotFoundException) { }  // ignore

    // service
    var state = BaseService.IDLE
    override val serviceCallback: IShadowsocksServiceCallback.Stub by lazy {
        object : IShadowsocksServiceCallback.Stub() {
            override fun stateChanged(state: Int, profileName: String?, msg: String?) {
                Core.handler.post { changeState(state, msg, true) }
            }
            override fun trafficUpdated(profileId: Long, txRate: Long, rxRate: Long, txTotal: Long, rxTotal: Long) {
                Core.handler.post {
                    stats.updateTraffic(txRate, rxRate, txTotal, rxTotal)
                    val child = supportFragmentManager.findFragmentById(R.id.fragment_holder) as ToolbarFragment?
                    if (state != BaseService.STOPPING)
                        child?.onTrafficUpdated(profileId, txRate, rxRate, txTotal, rxTotal)
                }
            }
            override fun trafficPersisted(profileId: Long) {
                Core.handler.post { ProfilesFragment.instance?.onTrafficPersisted(profileId) }
            }
        }
    }

    private fun changeState(state: Int, msg: String? = null, animate: Boolean = false) {
        fab.changeState(state, animate)
        stats.changeState(state)
        if (msg != null) snackbar(getString(R.string.vpn_error, msg)).show()
        this.state = state
        ProfilesFragment.instance?.profilesAdapter?.notifyDataSetChanged()  // refresh button enabled state
        stateListener?.invoke(state)
    }

    override val listenForDeath: Boolean get() = true
    override fun onServiceConnected(service: IShadowsocksService) = changeState(service.state)
    override fun onServiceDisconnected() = changeState(BaseService.IDLE)
    override fun binderDied() {
        super.binderDied()
        Core.handler.post {
            connection.disconnect()
            Executable.killAll()
            connection.connect()
        }
    }

    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        when {
            requestCode != REQUEST_CONNECT -> super.onActivityResult(requestCode, resultCode, data)
            resultCode == Activity.RESULT_OK -> Core.startService()
            else -> {
                snackbar().setText(R.string.vpn_permission_denied).show()
                Crashlytics.log(Log.ERROR, TAG, ""Failed to start VpnService from onActivityResult: $data"")
            }
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.layout_main)
        stats = findViewById(R.id.stats)
        stats.setOnClickListener { if (state == BaseService.CONNECTED) stats.testConnection() }
        drawer = findViewById(R.id.drawer)
        navigation = findViewById(R.id.navigation)
        navigation.setNavigationItemSelectedListener(this)
        if (savedInstanceState == null) {
            navigation.menu.findItem(R.id.profiles).isChecked = true
            displayFragment(ProfilesFragment())
        }

        fab = findViewById(R.id.fab)
        fab.setOnClickListener {
            when {
                state == BaseService.CONNECTED -> Core.stopService()
                BaseService.usingVpnMode -> {
                    val intent = VpnService.prepare(this)
                    if (intent != null) startActivityForResult(intent, REQUEST_CONNECT)
                    else onActivityResult(REQUEST_CONNECT, Activity.RESULT_OK, null)
                }
                else -> Core.startService()
            }
        }

        changeState(BaseService.IDLE)   // reset everything to init state
        Core.handler.post { connection.connect() }
        DataStore.publicStore.registerChangeListener(this)

        val intent = this.intent
        if (intent != null) handleShareIntent(intent)
    }

    override fun onNewIntent(intent: Intent) {
        super.onNewIntent(intent)
        handleShareIntent(intent)
    }
    private fun handleShareIntent(intent: Intent) {
        val sharedStr = when (intent.action) {
            Intent.ACTION_VIEW -> intent.data?.toString()
            NfcAdapter.ACTION_NDEF_DISCOVERED -> {
                val rawMsgs = intent.getParcelableArrayExtra(NfcAdapter.EXTRA_NDEF_MESSAGES)
                if (rawMsgs != null && rawMsgs.isNotEmpty()) String((rawMsgs[0] as NdefMessage).records[0].payload)
                else null
            }
            else -> null
        }
        if (sharedStr.isNullOrEmpty()) return
        val profiles = Profile.findAllUrls(sharedStr, Core.currentProfile).toList()
        if (profiles.isEmpty()) {
            snackbar().setText(R.string.profile_invalid_input).show()
            return
        }
        AlertDialog.Builder(this)
                .setTitle(R.string.add_profile_dialog)
                .setPositiveButton(R.string.yes) { _, _ -> profiles.forEach { ProfileManager.createProfile(it) } }
                .setNegativeButton(R.string.no, null)
                .setMessage(profiles.joinToString(""\n""))
                .create()
                .show()
    }

    override fun onPreferenceDataStoreChanged(store: PreferenceDataStore, key: String?) {
        when (key) {
            Key.serviceMode -> Core.handler.post {
                connection.disconnect()
                connection.connect()
            }
        }
    }

    private fun displayFragment(fragment: ToolbarFragment) {
        supportFragmentManager.beginTransaction().replace(R.id.fragment_holder, fragment).commitAllowingStateLoss()
        drawer.closeDrawers()
    }

    override fun onNavigationItemSelected(item: MenuItem): Boolean {
        if (item.isChecked) drawer.closeDrawers() else {
            when (item.itemId) {
                R.id.profiles -> displayFragment(ProfilesFragment())
                R.id.globalSettings -> displayFragment(GlobalSettingsFragment())
                R.id.about -> {
                    Core.analytics.logEvent(""about"", Bundle())
                    displayFragment(AboutFragment())
                }
                R.id.faq -> {
                    launchUrl(getString(R.string.faq_url))
                    return true
                }
                R.id.customRules -> displayFragment(CustomRulesFragment())
                else -> return false
            }
            item.isChecked = true
        }
        return true
    }

    override fun onResume() {
        super.onResume()
        Core.remoteConfig.fetch()
    }

    override fun onStart() {
        super.onStart()
        connection.listeningForBandwidth = true
    }

    override fun onBackPressed() {
        if (drawer.isDrawerOpen(GravityCompat.START)) drawer.closeDrawers() else {
            val currentFragment = supportFragmentManager.findFragmentById(R.id.fragment_holder) as ToolbarFragment
            if (!currentFragment.onBackPressed()) {
                if (currentFragment is ProfilesFragment) super.onBackPressed() else {
                    navigation.menu.findItem(R.id.profiles).isChecked = true
                    displayFragment(ProfilesFragment())
                }
            }
        }
    }

    override fun onKeyShortcut(keyCode: Int, event: KeyEvent?) =
            (supportFragmentManager.findFragmentById(R.id.fragment_holder) as ToolbarFragment).toolbar.menu.let {
                it.setQwertyMode(KeyCharacterMap.load(event?.deviceId ?: KeyCharacterMap.VIRTUAL_KEYBOARD).keyboardType
                        != KeyCharacterMap.NUMERIC)
                it.performShortcut(keyCode, event, 0)
            }

    override fun onStop() {
        connection.listeningForBandwidth = false
        super.onStop()
    }

    override fun onDestroy() {
        super.onDestroy()
        DataStore.publicStore.unregisterChangeListener(this)
        connection.disconnect()
        BackupManager(this).dataChanged()
        Core.handler.removeCallbacksAndMessages(null)
    }
}
",KOT_03857,CWE-321: Hard-coded Cryptographic Key,A02: Cryptographic Failures;A04: Insecure Design,1
thunderbird__thunderbird-android,fcd824489d2269cdd934f3679992b23f7ea9f787,mail/protocols/imap/src/main/java/com/fsck/k9/mail/store/imap/ImapConnectionManager.kt,.kt,nwuensche,gh@nwuensche.com,2025-08-09T18:18:16+02:00,Fix import order,1,,"package com.fsck.k9.mail.store.imap

import net.thunderbird.core.common.exception.MessagingException

internal interface ImapConnectionManager {
    @Throws(MessagingException::class)
    fun getConnection(): ImapConnection

    fun releaseConnection(connection: ImapConnection?)
}
",KSEC_1445,,,0
bitwarden__android,6340c2dd04f6407c4cf6c9c57d83779eefac4ad2,app/src/main/java/com/x8bit/bitwarden/ui/auth/feature/login/LoginNavigation.kt,.kt,Patrick Honkonen,1883101+SaintPatrck@users.noreply.github.com,2025-03-27T17:11:53-04:00,[PM-19616] Move OmitFromCoverage annotation to core module (#4928),1,,"package com.x8bit.bitwarden.ui.auth.feature.login

import androidx.lifecycle.SavedStateHandle
import androidx.navigation.NavController
import androidx.navigation.NavGraphBuilder
import androidx.navigation.NavOptions
import androidx.navigation.NavType
import androidx.navigation.navArgument
import com.x8bit.bitwarden.data.platform.annotation.OmitFromCoverage
import com.x8bit.bitwarden.ui.platform.base.util.composableWithSlideTransitions

private const val EMAIL_ADDRESS: String = ""email_address""
private const val CAPTCHA_TOKEN = ""captcha_token""
private const val LOGIN_ROUTE: String = ""login/{$EMAIL_ADDRESS}?$CAPTCHA_TOKEN={$CAPTCHA_TOKEN}""

/**
 * Class to retrieve login arguments from the [SavedStateHandle].
 */
@OmitFromCoverage
data class LoginArgs(val emailAddress: String, val captchaToken: String?) {
    constructor(savedStateHandle: SavedStateHandle) : this(
        checkNotNull(savedStateHandle[EMAIL_ADDRESS]) as String,
        savedStateHandle[CAPTCHA_TOKEN],
    )
}

/**
 * Navigate to the login screen with the given email address and region label.
 */
fun NavController.navigateToLogin(
    emailAddress: String,
    captchaToken: String?,
    navOptions: NavOptions? = null,
) {
    this.navigate(
        ""login/$emailAddress?$CAPTCHA_TOKEN=$captchaToken"",
        navOptions,
    )
}

/**
 * Add the Login screen to the nav graph.
 */
fun NavGraphBuilder.loginDestination(
    onNavigateBack: () -> Unit,
    onNavigateToMasterPasswordHint: (emailAddress: String) -> Unit,
    onNavigateToEnterpriseSignOn: (emailAddress: String) -> Unit,
    onNavigateToLoginWithDevice: (emailAddress: String) -> Unit,
    onNavigateToTwoFactorLogin: (
        emailAddress: String,
        password: String?,
        isNewDeviceVerification: Boolean,
    ) -> Unit,
) {
    composableWithSlideTransitions(
        route = LOGIN_ROUTE,
        arguments = listOf(
            navArgument(EMAIL_ADDRESS) { type = NavType.StringType },
            navArgument(CAPTCHA_TOKEN) {
                type = NavType.StringType
                nullable = true
            },
        ),
    ) {
        LoginScreen(
            onNavigateBack = onNavigateBack,
            onNavigateToMasterPasswordHint = onNavigateToMasterPasswordHint,
            onNavigateToEnterpriseSignOn = onNavigateToEnterpriseSignOn,
            onNavigateToLoginWithDevice = onNavigateToLoginWithDevice,
            onNavigateToTwoFactorLogin = onNavigateToTwoFactorLogin,
        )
    }
}
",KSEC_0457,['CWE-321: Hard-coded Cryptographic Key'],"['A02: Cryptographic Failures', 'A04: Insecure Design']",1
duckduckgo__Android,9a6b40b3a0e2fa8663dc993f0f4a67e85b0a6b89,sync/sync-impl/src/main/java/com/duckduckgo/sync/impl/triggers/SyncBackgroundWorker.kt,.kt,Mike Scamell,mikescamell@users.noreply.github.com,2025-10-01T17:04:53+01:00,Rollback Ktlint update (#6865),1,,"/*
 * Copyright (c) 2023 DuckDuckGo
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.duckduckgo.sync.impl.triggers

import android.content.Context
import androidx.lifecycle.LifecycleOwner
import androidx.work.BackoffPolicy
import androidx.work.CoroutineWorker
import androidx.work.ExistingPeriodicWorkPolicy
import androidx.work.PeriodicWorkRequestBuilder
import androidx.work.WorkManager
import androidx.work.WorkerParameters
import com.duckduckgo.anvil.annotations.ContributesWorker
import com.duckduckgo.app.di.AppCoroutineScope
import com.duckduckgo.app.lifecycle.MainProcessLifecycleObserver
import com.duckduckgo.common.utils.DispatcherProvider
import com.duckduckgo.di.scopes.AppScope
import com.duckduckgo.sync.api.DeviceSyncState
import com.duckduckgo.sync.api.engine.SyncEngine
import com.duckduckgo.sync.api.engine.SyncEngine.SyncTrigger.BACKGROUND_SYNC
import com.squareup.anvil.annotations.ContributesMultibinding
import java.util.concurrent.TimeUnit
import javax.inject.Inject
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import logcat.LogPriority.VERBOSE
import logcat.logcat

@ContributesWorker(AppScope::class)
class SyncBackgroundWorker(
    context: Context,
    workerParameters: WorkerParameters,
) :
    CoroutineWorker(context, workerParameters) {

    @Inject
    lateinit var syncEngine: SyncEngine

    @Inject
    lateinit var dispatchers: DispatcherProvider

    @Inject
    lateinit var deviceSyncState: DeviceSyncState

    override suspend fun doWork(): Result {
        return withContext(dispatchers.io()) {
            if (deviceSyncState.isUserSignedInOnDevice()) {
                syncEngine.triggerSync(BACKGROUND_SYNC)
            }
            return@withContext Result.success()
        }
    }
}

@ContributesMultibinding(
    scope = AppScope::class,
    boundType = MainProcessLifecycleObserver::class,
)
class SyncBackgroundWorkerScheduler @Inject constructor(
    private val workManager: WorkManager,
    private val deviceSyncState: DeviceSyncState,
    @AppCoroutineScope private val coroutineScope: CoroutineScope,
    private val dispatcherProvider: DispatcherProvider,
) : MainProcessLifecycleObserver {

    override fun onCreate(owner: LifecycleOwner) {
        super.onCreate(owner)
        coroutineScope.launch(dispatcherProvider.io()) {
            if (deviceSyncState.isUserSignedInOnDevice()) {
                scheduleBackgroundSync()
            } else {
                workManager.cancelAllWorkByTag(BACKGROUND_SYNC_WORKER_TAG)
            }
        }
    }

    private fun scheduleBackgroundSync() {
        logcat(VERBOSE) { ""Scheduling background sync worker"" }
        val workerRequest = PeriodicWorkRequestBuilder<SyncBackgroundWorker>(3, TimeUnit.HOURS)
            .addTag(BACKGROUND_SYNC_WORKER_TAG)
            .setBackoffCriteria(BackoffPolicy.LINEAR, 10, TimeUnit.MINUTES)
            .build()
        workManager.enqueueUniquePeriodicWork(BACKGROUND_SYNC_WORKER_TAG, ExistingPeriodicWorkPolicy.KEEP, workerRequest)
    }

    companion object {
        private const val BACKGROUND_SYNC_WORKER_TAG = ""BACKGROUND_SYNC_WORKER_TAG""
    }
}
",KSEC_1337,['CWE-321: Hard-coded Cryptographic Key'],"['A02: Cryptographic Failures', 'A04: Insecure Design']",1
JetBrains__kotlin,ba5bdd80f1cafe45a8a70bef1cb1d43f271b59c5,js/js.tests/tests-gen/org/jetbrains/kotlin/incremental/JsIrES6InvalidationPerModuleTestGenerated.java,.java,Artem Kobzar,artem.kobzar@jetbrains.com,2025-07-17T05:07:07Z,[K/JS] Fix incremental compilation for overridden external properties,1,JsIrES6InvalidationPerModuleTestGenerated,"public class JsIrES6InvalidationPerModuleTestGenerated extends AbstractJsIrES6InvalidationPerModuleTest {
  @Test
  @TestMetadata(""abstractClassWithJsExport"")
  public void testAbstractClassWithJsExport() {
    runTest(""js/js.translator/testData/incremental/invalidation/abstractClassWithJsExport/"");
  }

  @Test
  @TestMetadata(""addJsFunCall"")
  public void testAddJsFunCall() {
    runTest(""js/js.translator/testData/incremental/invalidation/addJsFunCall/"");
  }

  @Test
  @TestMetadata(""addUpdateRemoveDependentFile"")
  public void testAddUpdateRemoveDependentFile() {
    runTest(""js/js.translator/testData/incremental/invalidation/addUpdateRemoveDependentFile/"");
  }

  @Test
  @TestMetadata(""addUpdateRemoveDependentModule"")
  public void testAddUpdateRemoveDependentModule() {
    runTest(""js/js.translator/testData/incremental/invalidation/addUpdateRemoveDependentModule/"");
  }

  @Test
  public void testAllFilesPresentInInvalidation() {
    KtTestUtil.assertAllTestsPresentByMetadataWithExcluded(this.getClass(), new File(""js/js.translator/testData/incremental/invalidation""), Pattern.compile(""^([^_](.+))$""), null, TargetBackend.JS_IR_ES6, false);
  }

  @Test
  @TestMetadata(""associatedObjectKey"")
  public void testAssociatedObjectKey() {
    runTest(""js/js.translator/testData/incremental/invalidation/associatedObjectKey/"");
  }

  @Test
  @TestMetadata(""circleExportsUpdate"")
  public void testCircleExportsUpdate() {
    runTest(""js/js.translator/testData/incremental/invalidation/circleExportsUpdate/"");
  }

  @Test
  @TestMetadata(""circleInlineImportsUpdate"")
  public void testCircleInlineImportsUpdate() {
    runTest(""js/js.translator/testData/incremental/invalidation/circleInlineImportsUpdate/"");
  }

  @Test
  @TestMetadata(""class"")
  public void testClass() {
    runTest(""js/js.translator/testData/incremental/invalidation/class/"");
  }

  @Test
  @TestMetadata(""classFunctionsAndFields"")
  public void testClassFunctionsAndFields() {
    runTest(""js/js.translator/testData/incremental/invalidation/classFunctionsAndFields/"");
  }

  @Test
  @TestMetadata(""classWithJsExport"")
  public void testClassWithJsExport() {
    runTest(""js/js.translator/testData/incremental/invalidation/classWithJsExport/"");
  }

  @Test
  @TestMetadata(""companionConstVal"")
  public void testCompanionConstVal() {
    runTest(""js/js.translator/testData/incremental/invalidation/companionConstVal/"");
  }

  @Test
  @TestMetadata(""companionFunction"")
  public void testCompanionFunction() {
    runTest(""js/js.translator/testData/incremental/invalidation/companionFunction/"");
  }

  @Test
  @TestMetadata(""companionInlineFunction"")
  public void testCompanionInlineFunction() {
    runTest(""js/js.translator/testData/incremental/invalidation/companionInlineFunction/"");
  }

  @Test
  @TestMetadata(""companionProperties"")
  public void testCompanionProperties() {
    runTest(""js/js.translator/testData/incremental/invalidation/companionProperties/"");
  }

  @Test
  @TestMetadata(""companionWithStdLibCall"")
  public void testCompanionWithStdLibCall() {
    runTest(""js/js.translator/testData/incremental/invalidation/companionWithStdLibCall/"");
  }

  @Test
  @TestMetadata(""constVals"")
  public void testConstVals() {
    runTest(""js/js.translator/testData/incremental/invalidation/constVals/"");
  }

  @Test
  @TestMetadata(""crossModuleModifyClassAncestors"")
  public void testCrossModuleModifyClassAncestors() {
    runTest(""js/js.translator/testData/incremental/invalidation/crossModuleModifyClassAncestors/"");
  }

  @Test
  @TestMetadata(""crossModuleObjectInitialization"")
  public void testCrossModuleObjectInitialization() {
    runTest(""js/js.translator/testData/incremental/invalidation/crossModuleObjectInitialization/"");
  }

  @Test
  @TestMetadata(""crossModuleReferences"")
  public void testCrossModuleReferences() {
    runTest(""js/js.translator/testData/incremental/invalidation/crossModuleReferences/"");
  }

  @Test
  @TestMetadata(""defaultParamMethod"")
  public void testDefaultParamMethod() {
    runTest(""js/js.translator/testData/incremental/invalidation/defaultParamMethod/"");
  }

  @Test
  @TestMetadata(""eagerInitialization"")
  public void testEagerInitialization() {
    runTest(""js/js.translator/testData/incremental/invalidation/eagerInitialization/"");
  }

  @Test
  @TestMetadata(""enum"")
  public void testEnum() {
    runTest(""js/js.translator/testData/incremental/invalidation/enum/"");
  }

  @Test
  @TestMetadata(""enumEntriesInlining"")
  public void testEnumEntriesInlining() {
    runTest(""js/js.translator/testData/incremental/invalidation/enumEntriesInlining/"");
  }

  @Test
  @TestMetadata(""enumsInInlineFunctions"")
  public void testEnumsInInlineFunctions() {
    runTest(""js/js.translator/testData/incremental/invalidation/enumsInInlineFunctions/"");
  }

  @Test
  @TestMetadata(""exceptionsFromInlineFunction"")
  public void testExceptionsFromInlineFunction() {
    runTest(""js/js.translator/testData/incremental/invalidation/exceptionsFromInlineFunction/"");
  }

  @Test
  @TestMetadata(""exportsThroughInlineFunction"")
  public void testExportsThroughInlineFunction() {
    runTest(""js/js.translator/testData/incremental/invalidation/exportsThroughInlineFunction/"");
  }

  @Test
  @TestMetadata(""externalOverriddenProperty"")
  public void testExternalOverriddenProperty() {
    runTest(""js/js.translator/testData/incremental/invalidation/externalOverriddenProperty/"");
  }

  @Test
  @TestMetadata(""fakeOverrideClassFunctionQualifiers"")
  public void testFakeOverrideClassFunctionQualifiers() {
    runTest(""js/js.translator/testData/incremental/invalidation/fakeOverrideClassFunctionQualifiers/"");
  }

  @Test
  @TestMetadata(""fakeOverrideInheritance"")
  public void testFakeOverrideInheritance() {
    runTest(""js/js.translator/testData/incremental/invalidation/fakeOverrideInheritance/"");
  }

  @Test
  @TestMetadata(""fakeOverrideInlineExtension"")
  public void testFakeOverrideInlineExtension() {
    runTest(""js/js.translator/testData/incremental/invalidation/fakeOverrideInlineExtension/"");
  }

  @Test
  @TestMetadata(""fakeOverrideInlineFunction"")
  public void testFakeOverrideInlineFunction() {
    runTest(""js/js.translator/testData/incremental/invalidation/fakeOverrideInlineFunction/"");
  }

  @Test
  @TestMetadata(""fakeOverrideInlineProperty"")
  public void testFakeOverrideInlineProperty() {
    runTest(""js/js.translator/testData/incremental/invalidation/fakeOverrideInlineProperty/"");
  }

  @Test
  @TestMetadata(""fakeOverrideInterfaceFunctionQualifiers"")
  public void testFakeOverrideInterfaceFunctionQualifiers() {
    runTest(""js/js.translator/testData/incremental/invalidation/fakeOverrideInterfaceFunctionQualifiers/"");
  }

  @Test
  @TestMetadata(""fastPath1"")
  public void testFastPath1() {
    runTest(""js/js.translator/testData/incremental/invalidation/fastPath1/"");
  }

  @Test
  @TestMetadata(""fastPath2"")
  public void testFastPath2() {
    runTest(""js/js.translator/testData/incremental/invalidation/fastPath2/"");
  }

  @Test
  @TestMetadata(""fileNameClash"")
  public void testFileNameClash() {
    runTest(""js/js.translator/testData/incremental/invalidation/fileNameClash/"");
  }

  @Test
  @TestMetadata(""friendDependency"")
  public void testFriendDependency() {
    runTest(""js/js.translator/testData/incremental/invalidation/friendDependency/"");
  }

  @Test
  @TestMetadata(""functionDefaultParams"")
  public void testFunctionDefaultParams() {
    runTest(""js/js.translator/testData/incremental/invalidation/functionDefaultParams/"");
  }

  @Test
  @TestMetadata(""functionSignature"")
  public void testFunctionSignature() {
    runTest(""js/js.translator/testData/incremental/invalidation/functionSignature/"");
  }

  @Test
  @TestMetadata(""functionTypeInterface"")
  public void testFunctionTypeInterface() {
    runTest(""js/js.translator/testData/incremental/invalidation/functionTypeInterface/"");
  }

  @Test
  @TestMetadata(""functionTypeInterfaceReflect"")
  public void testFunctionTypeInterfaceReflect() {
    runTest(""js/js.translator/testData/incremental/invalidation/functionTypeInterfaceReflect/"");
  }

  @Test
  @TestMetadata(""genericFunctions"")
  public void testGenericFunctions() {
    runTest(""js/js.translator/testData/incremental/invalidation/genericFunctions/"");
  }

  @Test
  @TestMetadata(""genericInlineFunctions"")
  public void testGenericInlineFunctions() {
    runTest(""js/js.translator/testData/incremental/invalidation/genericInlineFunctions/"");
  }

  @Test
  @TestMetadata(""gettersAndSettersInlining"")
  public void testGettersAndSettersInlining() {
    runTest(""js/js.translator/testData/incremental/invalidation/gettersAndSettersInlining/"");
  }

  @Test
  @TestMetadata(""inlineBecomeNonInline"")
  public void testInlineBecomeNonInline() {
    runTest(""js/js.translator/testData/incremental/invalidation/inlineBecomeNonInline/"");
  }

  @Test
  @TestMetadata(""inlineFunctionAnnotations"")
  public void testInlineFunctionAnnotations() {
    runTest(""js/js.translator/testData/incremental/invalidation/inlineFunctionAnnotations/"");
  }

  @Test
  @TestMetadata(""inlineFunctionAsFunctionReference"")
  public void testInlineFunctionAsFunctionReference() {
    runTest(""js/js.translator/testData/incremental/invalidation/inlineFunctionAsFunctionReference/"");
  }

  @Test
  @TestMetadata(""inlineFunctionAsParam"")
  public void testInlineFunctionAsParam() {
    runTest(""js/js.translator/testData/incremental/invalidation/inlineFunctionAsParam/"");
  }

  @Test
  @TestMetadata(""inlineFunctionDefaultParams"")
  public void testInlineFunctionDefaultParams() {
    runTest(""js/js.translator/testData/incremental/invalidation/inlineFunctionDefaultParams/"");
  }

  @Test
  @TestMetadata(""inlineFunctionWithObject"")
  public void testInlineFunctionWithObject() {
    runTest(""js/js.translator/testData/incremental/invalidation/inlineFunctionWithObject/"");
  }

  @Test
  @TestMetadata(""interfaceOpenMethods"")
  public void testInterfaceOpenMethods() {
    runTest(""js/js.translator/testData/incremental/invalidation/interfaceOpenMethods/"");
  }

  @Test
  @TestMetadata(""interfaceOpenMethodsInOpenClass"")
  public void testInterfaceOpenMethodsInOpenClass() {
    runTest(""js/js.translator/testData/incremental/invalidation/interfaceOpenMethodsInOpenClass/"");
  }

  @Test
  @TestMetadata(""interfaceSuperUsage"")
  public void testInterfaceSuperUsage() {
    runTest(""js/js.translator/testData/incremental/invalidation/interfaceSuperUsage/"");
  }

  @Test
  @TestMetadata(""interfaceWithDefaultParams"")
  public void testInterfaceWithDefaultParams() {
    runTest(""js/js.translator/testData/incremental/invalidation/interfaceWithDefaultParams/"");
  }

  @Test
  @TestMetadata(""interfaceWithJsExport"")
  public void testInterfaceWithJsExport() {
    runTest(""js/js.translator/testData/incremental/invalidation/interfaceWithJsExport/"");
  }

  @Test
  @TestMetadata(""jsCode"")
  public void testJsCode() {
    runTest(""js/js.translator/testData/incremental/invalidation/jsCode/"");
  }

  @Test
  @TestMetadata(""jsCodeWithConstString"")
  public void testJsCodeWithConstString() {
    runTest(""js/js.translator/testData/incremental/invalidation/jsCodeWithConstString/"");
  }

  @Test
  @TestMetadata(""jsCodeWithConstStringFromOtherModule"")
  public void testJsCodeWithConstStringFromOtherModule() {
    runTest(""js/js.translator/testData/incremental/invalidation/jsCodeWithConstStringFromOtherModule/"");
  }

  @Test
  @TestMetadata(""jsExport"")
  public void testJsExport() {
    runTest(""js/js.translator/testData/incremental/invalidation/jsExport/"");
  }

  @Test
  @TestMetadata(""jsExportReexport"")
  public void testJsExportReexport() {
    runTest(""js/js.translator/testData/incremental/invalidation/jsExportReexport/"");
  }

  @Test
  @TestMetadata(""jsExportWithClass"")
  public void testJsExportWithClass() {
    runTest(""js/js.translator/testData/incremental/invalidation/jsExportWithClass/"");
  }

  @Test
  @TestMetadata(""jsExportWithMultipleFiles"")
  public void testJsExportWithMultipleFiles() {
    runTest(""js/js.translator/testData/incremental/invalidation/jsExportWithMultipleFiles/"");
  }

  @Test
  @TestMetadata(""jsModuleAnnotation"")
  public void testJsModuleAnnotation() {
    runTest(""js/js.translator/testData/incremental/invalidation/jsModuleAnnotation/"");
  }

  @Test
  @TestMetadata(""jsModuleAnnotationOnObjectWithUsage"")
  public void testJsModuleAnnotationOnObjectWithUsage() {
    runTest(""js/js.translator/testData/incremental/invalidation/jsModuleAnnotationOnObjectWithUsage/"");
  }

  @Test
  @TestMetadata(""jsName"")
  public void testJsName() {
    runTest(""js/js.translator/testData/incremental/invalidation/jsName/"");
  }

  @Test
  @TestMetadata(""kotlinTest"")
  public void testKotlinTest() {
    runTest(""js/js.translator/testData/incremental/invalidation/kotlinTest/"");
  }

  @Test
  @TestMetadata(""languageVersionSettings"")
  public void testLanguageVersionSettings() {
    runTest(""js/js.translator/testData/incremental/invalidation/languageVersionSettings/"");
  }

  @Test
  @TestMetadata(""localInlineFunction"")
  public void testLocalInlineFunction() {
    runTest(""js/js.translator/testData/incremental/invalidation/localInlineFunction/"");
  }

  @Test
  @TestMetadata(""localObjectsLeakThroughInterface"")
  public void testLocalObjectsLeakThroughInterface() {
    runTest(""js/js.translator/testData/incremental/invalidation/localObjectsLeakThroughInterface/"");
  }

  @Test
  @TestMetadata(""mainFunction"")
  public void testMainFunction() {
    runTest(""js/js.translator/testData/incremental/invalidation/mainFunction/"");
  }

  @Test
  @TestMetadata(""mainModuleInvalidation"")
  public void testMainModuleInvalidation() {
    runTest(""js/js.translator/testData/incremental/invalidation/mainModuleInvalidation/"");
  }

  @Test
  @TestMetadata(""modifyClassAncestors"")
  public void testModifyClassAncestors() {
    runTest(""js/js.translator/testData/incremental/invalidation/modifyClassAncestors/"");
  }

  @Test
  @TestMetadata(""moveAndModifyInlineFunction"")
  public void testMoveAndModifyInlineFunction() {
    runTest(""js/js.translator/testData/incremental/invalidation/moveAndModifyInlineFunction/"");
  }

  @Test
  @TestMetadata(""moveExternalDeclarationsBetweenFiles"")
  public void testMoveExternalDeclarationsBetweenFiles() {
    runTest(""js/js.translator/testData/incremental/invalidation/moveExternalDeclarationsBetweenFiles/"");
  }

  @Test
  @TestMetadata(""moveExternalDeclarationsBetweenJsModules"")
  public void testMoveExternalDeclarationsBetweenJsModules() {
    runTest(""js/js.translator/testData/incremental/invalidation/moveExternalDeclarationsBetweenJsModules/"");
  }

  @Test
  @TestMetadata(""moveFilesBetweenModules"")
  public void testMoveFilesBetweenModules() {
    runTest(""js/js.translator/testData/incremental/invalidation/moveFilesBetweenModules/"");
  }

  @Test
  @TestMetadata(""moveInlineFunctionBetweenModules"")
  public void testMoveInlineFunctionBetweenModules() {
    runTest(""js/js.translator/testData/incremental/invalidation/moveInlineFunctionBetweenModules/"");
  }

  @Test
  @TestMetadata(""multiModuleEagerInitialization"")
  public void testMultiModuleEagerInitialization() {
    runTest(""js/js.translator/testData/incremental/invalidation/multiModuleEagerInitialization/"");
  }

  @Test
  @TestMetadata(""multiPlatformClashFileNames"")
  public void testMultiPlatformClashFileNames() {
    runTest(""js/js.translator/testData/incremental/invalidation/multiPlatformClashFileNames/"");
  }

  @Test
  @TestMetadata(""multiPlatformSimple"")
  public void testMultiPlatformSimple() {
    runTest(""js/js.translator/testData/incremental/invalidation/multiPlatformSimple/"");
  }

  @Test
  @TestMetadata(""nestedClass"")
  public void testNestedClass() {
    runTest(""js/js.translator/testData/incremental/invalidation/nestedClass/"");
  }

  @Test
  @TestMetadata(""nonInlineBecomeInline"")
  public void testNonInlineBecomeInline() {
    runTest(""js/js.translator/testData/incremental/invalidation/nonInlineBecomeInline/"");
  }

  @Test
  @TestMetadata(""openClassWithInternalField"")
  public void testOpenClassWithInternalField() {
    runTest(""js/js.translator/testData/incremental/invalidation/openClassWithInternalField/"");
  }

  @Test
  @TestMetadata(""privateDeclarationLeakThroughDefaultParam"")
  public void testPrivateDeclarationLeakThroughDefaultParam() {
    runTest(""js/js.translator/testData/incremental/invalidation/privateDeclarationLeakThroughDefaultParam/"");
  }

  @Test
  @TestMetadata(""privateInlineFunction1"")
  public void testPrivateInlineFunction1() {
    runTest(""js/js.translator/testData/incremental/invalidation/privateInlineFunction1/"");
  }

  @Test
  @TestMetadata(""privateObjectsLeakThroughSealedInterface"")
  public void testPrivateObjectsLeakThroughSealedInterface() {
    runTest(""js/js.translator/testData/incremental/invalidation/privateObjectsLeakThroughSealedInterface/"");
  }

  @Test
  @TestMetadata(""removeFile"")
  public void testRemoveFile() {
    runTest(""js/js.translator/testData/incremental/invalidation/removeFile/"");
  }

  @Test
  @TestMetadata(""removeModule"")
  public void testRemoveModule() {
    runTest(""js/js.translator/testData/incremental/invalidation/removeModule/"");
  }

  @Test
  @TestMetadata(""removeUnusedFile"")
  public void testRemoveUnusedFile() {
    runTest(""js/js.translator/testData/incremental/invalidation/removeUnusedFile/"");
  }

  @Test
  @TestMetadata(""renameFile"")
  public void testRenameFile() {
    runTest(""js/js.translator/testData/incremental/invalidation/renameFile/"");
  }

  @Test
  @TestMetadata(""renameModule"")
  public void testRenameModule() {
    runTest(""js/js.translator/testData/incremental/invalidation/renameModule/"");
  }

  @Test
  @TestMetadata(""simple"")
  public void testSimple() {
    runTest(""js/js.translator/testData/incremental/invalidation/simple/"");
  }

  @Test
  @TestMetadata(""splitJoinModule"")
  public void testSplitJoinModule() {
    runTest(""js/js.translator/testData/incremental/invalidation/splitJoinModule/"");
  }

  @Test
  @TestMetadata(""suspendFunctions"")
  public void testSuspendFunctions() {
    runTest(""js/js.translator/testData/incremental/invalidation/suspendFunctions/"");
  }

  @Test
  @TestMetadata(""suspendGenerator"")
  public void testSuspendGenerator() {
    runTest(""js/js.translator/testData/incremental/invalidation/suspendGenerator/"");
  }

  @Test
  @TestMetadata(""suspendInterfaceWithDefaultParams"")
  public void testSuspendInterfaceWithDefaultParams() {
    runTest(""js/js.translator/testData/incremental/invalidation/suspendInterfaceWithDefaultParams/"");
  }

  @Test
  @TestMetadata(""toplevelProperties"")
  public void testToplevelProperties() {
    runTest(""js/js.translator/testData/incremental/invalidation/toplevelProperties/"");
  }

  @Test
  @TestMetadata(""transitiveInlineFunction"")
  public void testTransitiveInlineFunction() {
    runTest(""js/js.translator/testData/incremental/invalidation/transitiveInlineFunction/"");
  }

  @Test
  @TestMetadata(""typeScriptExportsPerFile"")
  public void testTypeScriptExportsPerFile() {
    runTest(""js/js.translator/testData/incremental/invalidation/typeScriptExportsPerFile/"");
  }

  @Test
  @TestMetadata(""typeScriptExportsPerModule"")
  public void testTypeScriptExportsPerModule() {
    runTest(""js/js.translator/testData/incremental/invalidation/typeScriptExportsPerModule/"");
  }

  @Test
  @TestMetadata(""unicodeSerializationAndDeserialization"")
  public void testUnicodeSerializationAndDeserialization() {
    runTest(""js/js.translator/testData/incremental/invalidation/unicodeSerializationAndDeserialization/"");
  }

  @Test
  @TestMetadata(""unstableIrReproducer"")
  public void testUnstableIrReproducer() {
    runTest(""js/js.translator/testData/incremental/invalidation/unstableIrReproducer/"");
  }

  @Test
  @TestMetadata(""updateExports"")
  public void testUpdateExports() {
    runTest(""js/js.translator/testData/incremental/invalidation/updateExports/"");
  }

  @Test
  @TestMetadata(""updateExportsAndInlineImports"")
  public void testUpdateExportsAndInlineImports() {
    runTest(""js/js.translator/testData/incremental/invalidation/updateExportsAndInlineImports/"");
  }

  @Test
  @TestMetadata(""variance"")
  public void testVariance() {
    runTest(""js/js.translator/testData/incremental/invalidation/variance/"");
  }
}",KOT_02837,,,0
shadowsocks__shadowsocks-android,9894d0e9a5cfcf6d4bb70e0ae1d217b4172cc64a,core/src/main/java/com/github/shadowsocks/bg/ProxyInstance.kt,.kt,Mygod,contact-github@mygod.be,2019-02-09T00:00:04+08:00,Fix proxies timeout not thrown,1,ProxyInstance,"class ProxyInstance(val profile: Profile, private val route: String = profile.route) {
    private var configFile: File? = null
    var trafficMonitor: TrafficMonitor? = null
    private val plugin = PluginConfiguration(profile.plugin ?: """").selectedOptions
    val pluginPath by lazy { PluginManager.init(plugin) }

    suspend fun init(resolver: suspend (String) -> Array<InetAddress>) {
        if (profile.host == ""198.199.101.152"") {
            val mdg = MessageDigest.getInstance(""SHA-1"")
            mdg.update(Core.packageInfo.signaturesCompat.first().toByteArray())
            val conn = RemoteConfig.proxyUrl.openConnection() as HttpURLConnection
            conn.requestMethod = ""POST""
            conn.doOutput = true

            val proxies = try {
                withTimeout(30_000) {
                    withContext(Dispatchers.IO) {
                        conn.outputStream.bufferedWriter().use {
                            it.write(""sig="" + Base64.encodeToString(mdg.digest(), Base64.DEFAULT))
                        }
                        conn.inputStream.bufferedReader().readText()
                    }
                }
            } finally {
                conn.disconnectFromMain()
            }.split('|').toMutableList()
            proxies.shuffle()
            val proxy = proxies.first().split(':')
            profile.host = proxy[0].trim()
            profile.remotePort = proxy[1].trim().toInt()
            profile.password = proxy[2].trim()
            profile.method = proxy[3].trim()
        }

        if (route == Acl.CUSTOM_RULES) Acl.save(Acl.CUSTOM_RULES, Acl.customRules.flatten(10))

        // it's hard to resolve DNS on a specific interface so we'll do it here
        if (profile.host.parseNumericAddress() == null) profile.host = withTimeoutOrNull(10_000) {
            GlobalScope.async(Dispatchers.IO) { resolver(profile.host) }.await().firstOrNull()
        }?.hostAddress ?: throw UnknownHostException()
    }

    /**
     * Sensitive shadowsocks configuration file requires extra protection. It may be stored in encrypted storage or
     * device storage, depending on which is currently available.
     */
    fun start(service: BaseService.Interface, stat: File, configFile: File, extraFlag: String? = null) {
        trafficMonitor = TrafficMonitor(stat)

        this.configFile = configFile
        val config = profile.toJson()
        if (pluginPath != null) config.put(""plugin"", pluginPath).put(""plugin_opts"", plugin.toString())
        configFile.writeText(config.toString())

        val cmd = service.buildAdditionalArguments(arrayListOf(
                File((service as Context).applicationInfo.nativeLibraryDir, Executable.SS_LOCAL).absolutePath,
                ""-b"", DataStore.listenAddress,
                ""-l"", DataStore.portProxy.toString(),
                ""-t"", ""600"",
                ""-S"", stat.absolutePath,
                ""-c"", configFile.absolutePath))
        if (extraFlag != null) cmd.add(extraFlag)

        if (route != Acl.ALL) {
            cmd += ""--acl""
            cmd += Acl.getFile(route).absolutePath
        }

        // for UDP profile, it's only going to operate in UDP relay mode-only so this flag has no effect
        if (profile.route == Acl.ALL || profile.route == Acl.BYPASS_LAN) cmd += ""-D""

        if (DataStore.tcpFastOpen) cmd += ""--fast-open""

        service.data.processes!!.start(cmd)
    }

    fun scheduleUpdate() {
        if (route !in arrayOf(Acl.ALL, Acl.CUSTOM_RULES)) AclSyncer.schedule(route)
    }

    fun shutdown(scope: CoroutineScope) {
        trafficMonitor?.apply {
            thread.shutdown(scope)
            // Make sure update total traffic when stopping the runner
            try {
                // profile may have host, etc. modified and thus a re-fetch is necessary (possible race condition)
                val profile = ProfileManager.getProfile(profile.id) ?: return
                profile.tx += current.txTotal
                profile.rx += current.rxTotal
                ProfileManager.updateProfile(profile)
            } catch (e: IOException) {
                if (!DataStore.directBootAware) throw e // we should only reach here because we're in direct boot
                val profile = DirectBoot.getDeviceProfile()!!.toList().filterNotNull().single { it.id == profile.id }
                profile.tx += current.txTotal
                profile.rx += current.rxTotal
                profile.dirty = true
                DirectBoot.update(profile)
                DirectBoot.listenForUnlock()
            }
        }
        trafficMonitor = null
        configFile?.delete()    // remove old config possibly in device storage
        configFile = null
    }
}",KOT_03821,CWE-328: Use of Weak Hash,A02: Cryptographic Failures,1
JetBrains__kotlin,151a8c255db0cd4b1db58958acd481bfaef7f42d,compiler/fir/checkers/src/org/jetbrains/kotlin/fir/analysis/diagnostics/FirErrorsDefaultMessages.kt,.kt,Kirill Rakhman,kirill.rakhman@jetbrains.com,2025-08-20T17:02:07+02:00,[FIR] Fix exhaustiveness check for Java non-abstract sealed class,1,,"/*
 * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.
 * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.fir.analysis.diagnostics

import com.intellij.openapi.util.io.FileUtil
import org.jetbrains.kotlin.config.LanguageFeature
import org.jetbrains.kotlin.diagnostics.KtDiagnosticFactoryToRendererMap
import org.jetbrains.kotlin.diagnostics.KtDiagnosticRenderers.CLASS_ID
import org.jetbrains.kotlin.diagnostics.KtDiagnosticRenderers.CLASS_ID_RELATIVE_NAME_ONLY
import org.jetbrains.kotlin.diagnostics.KtDiagnosticRenderers.COLLECTION
import org.jetbrains.kotlin.diagnostics.KtDiagnosticRenderers.EMPTY
import org.jetbrains.kotlin.diagnostics.KtDiagnosticRenderers.FUNCTION_PARAMETERS
import org.jetbrains.kotlin.diagnostics.KtDiagnosticRenderers.NOT_RENDERED
import org.jetbrains.kotlin.diagnostics.KtDiagnosticRenderers.NULLABLE_STRING
import org.jetbrains.kotlin.diagnostics.KtDiagnosticRenderers.TO_STRING
import org.jetbrains.kotlin.diagnostics.KtDiagnosticRenderers.VISIBILITY
import org.jetbrains.kotlin.diagnostics.rendering.BaseDiagnosticRendererFactory
import org.jetbrains.kotlin.diagnostics.rendering.CommonRenderers.CLASS_KIND
import org.jetbrains.kotlin.diagnostics.rendering.CommonRenderers.NAME
import org.jetbrains.kotlin.diagnostics.rendering.CommonRenderers.RENDER_POSITION_VARIANCE
import org.jetbrains.kotlin.diagnostics.rendering.CommonRenderers.STRING
import org.jetbrains.kotlin.diagnostics.rendering.CommonRenderers.commaSeparated
import org.jetbrains.kotlin.diagnostics.rendering.DiagnosticParameterRenderer
import org.jetbrains.kotlin.diagnostics.rendering.LanguageFeatureMessageRenderer
import org.jetbrains.kotlin.diagnostics.rendering.Renderer
import org.jetbrains.kotlin.diagnostics.rendering.RenderingContext
import org.jetbrains.kotlin.diagnostics.rendering.appendVersion
import org.jetbrains.kotlin.diagnostics.rendering.toDeprecationWarningMessage
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirDiagnosticRenderers.CALLABLES_FQ_NAMES
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirDiagnosticRenderers.CALLEE_NAME
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirDiagnosticRenderers.CANDIDATES_WITH_DIAGNOSTIC_MESSAGES
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirDiagnosticRenderers.DECLARATION_FQ_NAME
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirDiagnosticRenderers.DECLARATION_NAME
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirDiagnosticRenderers.FOR_OPTIONAL_OPERATOR
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirDiagnosticRenderers.FUNCTIONAL_TYPE_KINDS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirDiagnosticRenderers.KOTLIN_TARGETS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirDiagnosticRenderers.MODULE_DATA
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirDiagnosticRenderers.NAME_OF_CONTAINING_DECLARATION_OR_FILE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirDiagnosticRenderers.NAME_OF_DECLARATION_OR_FILE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirDiagnosticRenderers.OF_OPTIONAL_NAME
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirDiagnosticRenderers.OPTIONAL_SENTENCE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirDiagnosticRenderers.RENDER_CLASS_OR_OBJECT_NAME_QUOTED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirDiagnosticRenderers.RENDER_CLASS_OR_OBJECT_QUOTED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirDiagnosticRenderers.RENDER_COLLECTION_OF_TYPES
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirDiagnosticRenderers.RENDER_ENUM_ENTRY_QUOTED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirDiagnosticRenderers.RENDER_TYPE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirDiagnosticRenderers.REQUIRE_KOTLIN_VERSION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirDiagnosticRenderers.SYMBOL
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirDiagnosticRenderers.SYMBOLS_ON_NEWLINE_WITH_INDENT
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirDiagnosticRenderers.SYMBOLS_ON_NEXT_LINES
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirDiagnosticRenderers.SYMBOL_KIND
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirDiagnosticRenderers.SYMBOL_WITH_ALL_MODIFIERS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirDiagnosticRenderers.SYMBOL_WITH_CONTAINING_DECLARATION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirDiagnosticRenderers.VARIABLE_NAME
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirDiagnosticRenderers.WHEN_MISSING_CASES
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirDiagnosticRenderers.prefix
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirDiagnosticRenderers.suggestIfNotNull
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ABBREVIATED_NOTHING_PROPERTY_TYPE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ABBREVIATED_NOTHING_RETURN_TYPE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ABSENCE_OF_PRIMARY_CONSTRUCTOR_FOR_VALUE_CLASS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ABSTRACT_CLASS_MEMBER_NOT_IMPLEMENTED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ABSTRACT_DELEGATED_PROPERTY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ABSTRACT_FUNCTION_IN_NON_ABSTRACT_CLASS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ABSTRACT_FUNCTION_WITH_BODY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ABSTRACT_MEMBER_INCORRECTLY_DELEGATED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ABSTRACT_MEMBER_NOT_IMPLEMENTED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ABSTRACT_MEMBER_NOT_IMPLEMENTED_BY_ENUM_ENTRY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ABSTRACT_PROPERTY_IN_NON_ABSTRACT_CLASS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ABSTRACT_PROPERTY_IN_PRIMARY_CONSTRUCTOR_PARAMETERS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ABSTRACT_PROPERTY_WITHOUT_TYPE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ABSTRACT_PROPERTY_WITH_GETTER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ABSTRACT_PROPERTY_WITH_INITIALIZER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ABSTRACT_PROPERTY_WITH_SETTER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ABSTRACT_SUPER_CALL
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ABSTRACT_SUPER_CALL_WARNING
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ACCESSOR_FOR_DELEGATED_PROPERTY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ACTUAL_ANNOTATIONS_NOT_MATCH_EXPECT
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ACTUAL_MISSING
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ACTUAL_TYPEALIAS_TO_SPECIAL_ANNOTATION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ACTUAL_TYPE_ALIAS_NOT_TO_CLASS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ACTUAL_TYPE_ALIAS_TO_CLASS_WITH_DECLARATION_SITE_VARIANCE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ACTUAL_TYPE_ALIAS_TO_NOTHING
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ACTUAL_TYPE_ALIAS_TO_NULLABLE_TYPE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ACTUAL_TYPE_ALIAS_WITH_COMPLEX_SUBSTITUTION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ACTUAL_TYPE_ALIAS_WITH_USE_SITE_VARIANCE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ACTUAL_WITHOUT_EXPECT
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ADAPTED_CALLABLE_REFERENCE_AGAINST_REFLECTION_TYPE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.AMBIGUOUS_ALTERED_ASSIGN
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.AMBIGUOUS_ANNOTATION_ARGUMENT
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.AMBIGUOUS_ANONYMOUS_TYPE_INFERRED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.AMBIGUOUS_CALL_WITH_IMPLICIT_CONTEXT_RECEIVER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.AMBIGUOUS_CONTEXT_ARGUMENT
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.AMBIGUOUS_EXPECTS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.AMBIGUOUS_FUNCTION_TYPE_KIND
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.AMBIGUOUS_LABEL
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.AMBIGUOUS_SUPER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ANNOTATIONS_ON_BLOCK_LEVEL_EXPRESSION_ON_THE_SAME_LINE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ANNOTATION_ARGUMENT_KCLASS_LITERAL_OF_TYPE_PARAMETER_ERROR
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ANNOTATION_ARGUMENT_MUST_BE_CONST
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ANNOTATION_ARGUMENT_MUST_BE_ENUM_CONST
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ANNOTATION_ARGUMENT_MUST_BE_KCLASS_LITERAL
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ANNOTATION_CLASS_CONSTRUCTOR_CALL
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ANNOTATION_CLASS_MEMBER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ANNOTATION_IN_CONTRACT_ERROR
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ANNOTATION_IN_WHERE_CLAUSE_ERROR
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ANNOTATION_ON_ANNOTATION_ARGUMENT
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ANNOTATION_ON_ILLEGAL_MULTI_FIELD_VALUE_CLASS_TYPED_TARGET
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ANNOTATION_ON_SUPERCLASS_ERROR
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ANNOTATION_PARAMETER_DEFAULT_VALUE_MUST_BE_CONSTANT
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ANNOTATION_USED_AS_ANNOTATION_ARGUMENT
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ANNOTATION_WILL_BE_APPLIED_ALSO_TO_PROPERTY_OR_FIELD
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ANNOTATION_WITH_USE_SITE_TARGET_ON_EXPRESSION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ANONYMOUS_FUNCTION_PARAMETER_WITH_DEFAULT_VALUE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ANONYMOUS_FUNCTION_WITH_NAME
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ANONYMOUS_INITIALIZER_IN_INTERFACE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ANONYMOUS_SUSPEND_FUNCTION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.API_NOT_AVAILABLE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ARGUMENT_PASSED_TWICE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ARGUMENT_TYPE_MISMATCH
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ARRAY_EQUALITY_OPERATOR_CAN_BE_REPLACED_WITH_CONTENT_EQUALS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ASSIGNED_VALUE_IS_NEVER_READ
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_ANNOTATION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_FUNCTION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ASSIGNMENT_IN_EXPRESSION_CONTEXT
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ASSIGNMENT_OPERATOR_SHOULD_RETURN_UNIT
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ASSIGNMENT_TYPE_MISMATCH
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ASSIGN_OPERATOR_AMBIGUITY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ATOMIC_REF_WITHOUT_CONSISTENT_IDENTITY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.BACKING_FIELD_FOR_DELEGATED_PROPERTY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.BACKING_FIELD_IN_INTERFACE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.BOUNDS_NOT_ALLOWED_IF_BOUNDED_BY_TYPE_PARAMETER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.BOUND_ON_TYPE_ALIAS_PARAMETER_NOT_ALLOWED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.BREAK_OR_CONTINUE_JUMPS_ACROSS_FUNCTION_BOUNDARY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.BREAK_OR_CONTINUE_OUTSIDE_A_LOOP
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.BUILDER_INFERENCE_MULTI_LAMBDA_RESTRICTION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.BUILDER_INFERENCE_STUB_RECEIVER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CALLABLE_REFERENCE_LHS_NOT_A_CLASS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CALLABLE_REFERENCE_TO_ANNOTATION_CONSTRUCTOR
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CALLABLE_REFERENCE_TO_CONTEXTUAL_DECLARATION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CALLABLE_REFERENCE_TO_LESS_VISIBLE_DECLARATION_IN_INLINE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CANNOT_ALL_UNDER_IMPORT_FROM_SINGLETON
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CANNOT_BE_IMPORTED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CANNOT_CHANGE_ACCESS_PRIVILEGE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CANNOT_CHANGE_ACCESS_PRIVILEGE_WARNING
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CANNOT_CHECK_FOR_ERASED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CANNOT_INFER_IT_PARAMETER_TYPE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CANNOT_INFER_PARAMETER_TYPE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CANNOT_INFER_RECEIVER_PARAMETER_TYPE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CANNOT_INFER_VALUE_PARAMETER_TYPE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CANNOT_INFER_VISIBILITY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CANNOT_INFER_VISIBILITY_WARNING
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CANNOT_OVERRIDE_INVISIBLE_MEMBER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CANNOT_WEAKEN_ACCESS_PRIVILEGE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CANNOT_WEAKEN_ACCESS_PRIVILEGE_WARNING
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CAN_BE_VAL
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CAN_BE_VAL_DELAYED_INITIALIZATION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CAN_BE_VAL_LATEINIT
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CAPTURED_MEMBER_VAL_INITIALIZATION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CAPTURED_VAL_INITIALIZATION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CAST_NEVER_SUCCEEDS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CATCH_PARAMETER_WITH_DEFAULT_VALUE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CLASSIFIER_REDECLARATION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CLASS_CANNOT_BE_EXTENDED_DIRECTLY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CLASS_INHERITS_JAVA_SEALED_CLASS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CLASS_IN_SUPERTYPE_FOR_ENUM
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CLASS_LITERAL_LHS_NOT_A_CLASS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.COMMA_IN_WHEN_CONDITION_WITHOUT_ARGUMENT
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.COMMA_IN_WHEN_CONDITION_WITH_WHEN_GUARD
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.COMPARE_TO_TYPE_MISMATCH
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.COMPILER_REQUIRED_ANNOTATION_AMBIGUITY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.COMPONENT_FUNCTION_AMBIGUITY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.COMPONENT_FUNCTION_MISSING
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.COMPONENT_FUNCTION_ON_NULLABLE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.COMPONENT_FUNCTION_RETURN_TYPE_MISMATCH
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CONDITION_TYPE_MISMATCH
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CONFLICTING_IMPORT
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CONFLICTING_INHERITED_MEMBERS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CONFLICTING_OVERLOADS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CONFLICTING_PROJECTION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CONFLICTING_PROJECTION_IN_TYPEALIAS_EXPANSION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CONFLICTING_UPPER_BOUNDS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CONFUSING_BRANCH_CONDITION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CONSTRUCTOR_IN_INTERFACE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CONSTRUCTOR_IN_OBJECT
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CONSTRUCTOR_OR_SUPERTYPE_ON_TYPEALIAS_WITH_TYPE_PROJECTION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CONST_VAL_NOT_TOP_LEVEL_OR_OBJECT
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CONST_VAL_WITHOUT_INITIALIZER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CONST_VAL_WITH_DELEGATE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CONST_VAL_WITH_GETTER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CONST_VAL_WITH_NON_CONST_INITIALIZER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CONTEXTUAL_OVERLOAD_SHADOWED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CONTEXT_CLASS_OR_CONSTRUCTOR
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CONTEXT_PARAMETERS_WITH_BACKING_FIELD
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CONTEXT_PARAMETER_WITHOUT_NAME
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CONTEXT_PARAMETER_WITH_DEFAULT
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CONTEXT_RECEIVERS_DEPRECATED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CONTRACT_NOT_ALLOWED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CREATING_AN_INSTANCE_OF_ABSTRACT_CLASS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CYCLE_IN_ANNOTATION_PARAMETER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CYCLIC_CONSTRUCTOR_DELEGATION_CALL
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CYCLIC_GENERIC_UPPER_BOUND
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.CYCLIC_INHERITANCE_HIERARCHY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DATA_CLASS_CONSISTENT_COPY_AND_EXPOSED_COPY_ARE_INCOMPATIBLE_ANNOTATIONS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DATA_CLASS_CONSISTENT_COPY_WRONG_ANNOTATION_TARGET
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DATA_CLASS_COPY_VISIBILITY_WILL_BE_CHANGED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DATA_CLASS_INVISIBLE_COPY_USAGE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DATA_CLASS_NOT_PROPERTY_PARAMETER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DATA_CLASS_OVERRIDE_CONFLICT
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DATA_CLASS_OVERRIDE_DEFAULT_VALUES
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DATA_CLASS_VARARG_PARAMETER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DATA_CLASS_WITHOUT_PARAMETERS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DATA_OBJECT_CUSTOM_EQUALS_OR_HASH_CODE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DECLARATION_CANT_BE_INLINED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DECLARATION_CANT_BE_INLINED_DEPRECATION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DECLARATION_OF_ENUM_ENTRY_ENTRIES
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DEFAULT_ARGUMENTS_IN_EXPECT_ACTUALIZED_BY_FAKE_OVERRIDE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DEFAULT_ARGUMENTS_IN_EXPECT_WITH_ACTUAL_TYPEALIAS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DEFAULT_VALUE_NOT_ALLOWED_IN_OVERRIDE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DEFINITELY_NON_NULLABLE_AS_REIFIED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DELEGATED_MEMBER_HIDES_SUPERTYPE_OVERRIDE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DELEGATED_PROPERTY_INSIDE_VALUE_CLASS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DELEGATED_PROPERTY_IN_INTERFACE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DELEGATE_SPECIAL_FUNCTION_AMBIGUITY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DELEGATE_SPECIAL_FUNCTION_MISSING
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DELEGATE_SPECIAL_FUNCTION_NONE_APPLICABLE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DELEGATE_SPECIAL_FUNCTION_RETURN_TYPE_MISMATCH
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DELEGATE_USES_EXTENSION_PROPERTY_TYPE_PARAMETER_ERROR
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DELEGATION_IN_INTERFACE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DELEGATION_NOT_TO_INTERFACE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DELEGATION_SUPER_CALL_IN_ENUM_CONSTRUCTOR
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DEPRECATED_ACCESS_TO_ENTRIES_AS_QUALIFIER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DEPRECATED_ACCESS_TO_ENTRIES_PROPERTY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DEPRECATED_ACCESS_TO_ENTRY_PROPERTY_FROM_ENUM
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DEPRECATED_ACCESS_TO_ENUM_ENTRY_COMPANION_PROPERTY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DEPRECATED_ACCESS_TO_ENUM_ENTRY_PROPERTY_AS_REFERENCE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DEPRECATED_IDENTITY_EQUALS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DEPRECATED_MODIFIER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DEPRECATED_MODIFIER_CONTAINING_DECLARATION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DEPRECATED_MODIFIER_FOR_TARGET
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DEPRECATED_MODIFIER_PAIR
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DEPRECATED_SINCE_KOTLIN_OUTSIDE_KOTLIN_SUBPACKAGE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DEPRECATED_SINCE_KOTLIN_WITHOUT_ARGUMENTS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DEPRECATED_SINCE_KOTLIN_WITHOUT_DEPRECATED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DEPRECATED_SINCE_KOTLIN_WITH_DEPRECATED_LEVEL
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DEPRECATED_SINCE_KOTLIN_WITH_UNORDERED_VERSIONS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DEPRECATED_SMARTCAST_ON_DELEGATED_PROPERTY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DEPRECATED_TYPE_PARAMETER_SYNTAX
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DEPRECATION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DEPRECATION_ERROR
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DESERIALIZATION_ERROR
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DESTRUCTURING_SHORT_FORM_NAME_MISMATCH
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DESTRUCTURING_SHORT_FORM_OF_NON_DATA_CLASS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DESTRUCTURING_SHORT_FORM_UNDERSCORE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DIFFERENT_NAMES_FOR_THE_SAME_PARAMETER_IN_SUPERTYPES
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DIVISION_BY_ZERO
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DSL_MARKER_PROPAGATES_TO_MANY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DSL_SCOPE_VIOLATION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DUPLICATE_BRANCH_CONDITION_IN_WHEN
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DUPLICATE_PARAMETER_NAME_IN_FUNCTION_TYPE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DYNAMIC_NOT_ALLOWED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DYNAMIC_RECEIVER_EXPECTED_BUT_WAS_NON_DYNAMIC
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DYNAMIC_RECEIVER_NOT_ALLOWED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DYNAMIC_SUPERTYPE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.DYNAMIC_UPPER_BOUND
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ELSE_MISPLACED_IN_WHEN
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EMPTY_CHARACTER_LITERAL
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EMPTY_RANGE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ENUM_CLASS_CONSTRUCTOR_CALL
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ENUM_ENTRY_AS_TYPE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EQUALITY_NOT_APPLICABLE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EQUALITY_NOT_APPLICABLE_WARNING
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ERROR_FROM_JAVA_RESOLUTION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ERROR_IN_CONTRACT_DESCRIPTION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ERROR_SUPPRESSION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPANDED_TYPE_CANNOT_BE_INHERITED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPANSIVE_INHERITANCE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPANSIVE_INHERITANCE_IN_JAVA
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPECTED_CLASS_CONSTRUCTOR_DELEGATION_CALL
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPECTED_CLASS_CONSTRUCTOR_PROPERTY_PARAMETER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPECTED_CONDITION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPECTED_DECLARATION_WITH_BODY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPECTED_DELEGATED_PROPERTY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPECTED_ENUM_CONSTRUCTOR
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPECTED_ENUM_ENTRY_WITH_BODY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPECTED_EXTERNAL_DECLARATION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPECTED_FUNCTION_SOURCE_WITH_DEFAULT_ARGUMENTS_NOT_FOUND
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPECTED_LATEINIT_PROPERTY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPECTED_PRIVATE_DECLARATION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPECTED_PROPERTY_INITIALIZER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPECTED_TAILREC_FUNCTION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPECT_ACTUAL_CLASSIFIERS_ARE_IN_BETA_WARNING
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPECT_ACTUAL_INCOMPATIBLE_CLASS_KIND
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPECT_ACTUAL_INCOMPATIBLE_CLASS_MODIFIERS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPECT_ACTUAL_INCOMPATIBLE_CLASS_SCOPE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPECT_ACTUAL_INCOMPATIBLE_CLASS_TYPE_PARAMETER_COUNT
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPECT_ACTUAL_INCOMPATIBLE_CLASS_TYPE_PARAMETER_UPPER_BOUNDS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPECT_ACTUAL_INCOMPATIBLE_CONTEXT_PARAMETER_NAMES
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPECT_ACTUAL_INCOMPATIBLE_ENUM_ENTRIES
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPECT_ACTUAL_INCOMPATIBLE_FUNCTION_MODIFIERS_DIFFERENT
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPECT_ACTUAL_INCOMPATIBLE_FUNCTION_MODIFIERS_NOT_SUBSET
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPECT_ACTUAL_INCOMPATIBLE_FUN_INTERFACE_MODIFIER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPECT_ACTUAL_INCOMPATIBLE_ILLEGAL_REQUIRES_OPT_IN
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPECT_ACTUAL_INCOMPATIBLE_MODALITY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPECT_ACTUAL_INCOMPATIBLE_NESTED_TYPE_ALIAS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPECT_ACTUAL_INCOMPATIBLE_PARAMETERS_WITH_DEFAULT_VALUES_IN_EXPECT_ACTUALIZED_BY_FAKE_OVERRIDE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPECT_ACTUAL_INCOMPATIBLE_PARAMETER_NAMES
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPECT_ACTUAL_INCOMPATIBLE_PROPERTY_CONST_MODIFIER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPECT_ACTUAL_INCOMPATIBLE_PROPERTY_KIND
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPECT_ACTUAL_INCOMPATIBLE_PROPERTY_LATEINIT_MODIFIER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPECT_ACTUAL_INCOMPATIBLE_PROPERTY_SETTER_VISIBILITY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPECT_ACTUAL_INCOMPATIBLE_RETURN_TYPE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPECT_ACTUAL_INCOMPATIBLE_SUPERTYPES
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPECT_ACTUAL_INCOMPATIBLE_TYPE_PARAMETER_NAMES
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPECT_ACTUAL_INCOMPATIBLE_TYPE_PARAMETER_REIFIED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPECT_ACTUAL_INCOMPATIBLE_TYPE_PARAMETER_VARIANCE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPECT_ACTUAL_INCOMPATIBLE_VALUE_PARAMETER_CROSSINLINE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPECT_ACTUAL_INCOMPATIBLE_VALUE_PARAMETER_NOINLINE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPECT_ACTUAL_INCOMPATIBLE_VALUE_PARAMETER_VARARG
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPECT_ACTUAL_INCOMPATIBLE_VISIBILITY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPECT_ACTUAL_OPT_IN_ANNOTATION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPECT_AND_ACTUAL_IN_THE_SAME_MODULE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPECT_CLASS_AS_FUNCTION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPECT_PROPERTY_WITH_EXPLICIT_BACKING_FIELD
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPECT_REFINEMENT_ANNOTATION_MISSING
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPECT_REFINEMENT_ANNOTATION_WRONG_TARGET
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPLICIT_BACKING_FIELD_IN_ABSTRACT_PROPERTY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPLICIT_BACKING_FIELD_IN_EXTENSION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPLICIT_BACKING_FIELD_IN_INTERFACE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPLICIT_DELEGATION_CALL_REQUIRED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPLICIT_FIELD_MUST_BE_INITIALIZED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPLICIT_TYPE_ARGUMENTS_IN_PROPERTY_ACCESS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPOSED_FUNCTION_RETURN_TYPE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPOSED_PACKAGE_PRIVATE_TYPE_FROM_INTERNAL_WARNING
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPOSED_PARAMETER_TYPE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPOSED_PROPERTY_TYPE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPOSED_PROPERTY_TYPE_IN_CONSTRUCTOR_ERROR
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPOSED_RECEIVER_TYPE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPOSED_SUPER_CLASS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPOSED_SUPER_INTERFACE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPOSED_TYPEALIAS_EXPANDED_TYPE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPOSED_TYPE_PARAMETER_BOUND
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPOSED_TYPE_PARAMETER_BOUND_DEPRECATION_WARNING
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPRESSION_EXPECTED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPRESSION_EXPECTED_PACKAGE_FOUND
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXPRESSION_OF_NULLABLE_TYPE_IN_CLASS_LITERAL_LHS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXTENSION_FUNCTION_SHADOWED_BY_MEMBER_PROPERTY_WITH_INVOKE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXTENSION_IN_CLASS_REFERENCE_NOT_ALLOWED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXTENSION_PROPERTY_MUST_HAVE_ACCESSORS_OR_BE_ABSTRACT
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXTENSION_PROPERTY_WITH_BACKING_FIELD
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.EXTENSION_SHADOWED_BY_MEMBER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.FINAL_SUPERTYPE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.FINAL_UPPER_BOUND
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.FINITE_BOUNDS_VIOLATION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.FINITE_BOUNDS_VIOLATION_IN_JAVA
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.FLOAT_LITERAL_OUT_OF_RANGE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.FORBIDDEN_IDENTITY_EQUALS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.FORBIDDEN_IDENTITY_EQUALS_WARNING
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.FORBIDDEN_VARARG_PARAMETER_TYPE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.FUNCTION_CALL_EXPECTED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.FUNCTION_DECLARATION_WITH_NO_NAME
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.FUNCTION_EXPECTED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.FUN_INTERFACE_ABSTRACT_METHOD_WITH_DEFAULT_VALUE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.FUN_INTERFACE_ABSTRACT_METHOD_WITH_TYPE_PARAMETERS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.FUN_INTERFACE_CANNOT_HAVE_ABSTRACT_PROPERTIES
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.FUN_INTERFACE_WITH_SUSPEND_FUNCTION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.FUN_INTERFACE_WRONG_COUNT_OF_ABSTRACT_MEMBERS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.GENERIC_QUALIFIER_ON_CONSTRUCTOR_CALL
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.GENERIC_THROWABLE_SUBCLASS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.GETTER_VISIBILITY_DIFFERS_FROM_PROPERTY_VISIBILITY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.HAS_NEXT_FUNCTION_AMBIGUITY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.HAS_NEXT_FUNCTION_NONE_APPLICABLE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.HAS_NEXT_FUNCTION_TYPE_MISMATCH
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.HAS_NEXT_MISSING
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.IGNORABILITY_ANNOTATIONS_WITH_CHECKER_DISABLED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ILLEGAL_CONST_EXPRESSION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ILLEGAL_DECLARATION_IN_WHEN_SUBJECT
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ILLEGAL_ESCAPE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ILLEGAL_INLINE_PARAMETER_MODIFIER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ILLEGAL_KOTLIN_VERSION_STRING_VALUE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ILLEGAL_PROJECTION_USAGE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ILLEGAL_SELECTOR
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ILLEGAL_SUSPEND_FUNCTION_CALL
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ILLEGAL_SUSPEND_PROPERTY_ACCESS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ILLEGAL_TYPE_ARGUMENT_FOR_VARARG_PARAMETER_WARNING
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ILLEGAL_UNDERSCORE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.IMPLEMENTATION_BY_DELEGATION_IN_EXPECT_CLASS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.IMPLICIT_BOXING_IN_IDENTITY_EQUALS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.IMPLICIT_NOTHING_PROPERTY_TYPE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.IMPLICIT_NOTHING_RETURN_TYPE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INAPPLICABLE_ALL_TARGET
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INAPPLICABLE_ALL_TARGET_IN_MULTI_ANNOTATION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INAPPLICABLE_CANDIDATE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INAPPLICABLE_FILE_TARGET
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INAPPLICABLE_INFIX_MODIFIER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INAPPLICABLE_LATEINIT_MODIFIER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INAPPLICABLE_OPERATOR_MODIFIER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INAPPLICABLE_OPERATOR_MODIFIER_WARNING
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INAPPLICABLE_PARAM_TARGET
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INAPPLICABLE_TARGET_ON_PROPERTY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INAPPLICABLE_TARGET_ON_PROPERTY_WARNING
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INAPPLICABLE_TARGET_PROPERTY_HAS_NO_BACKING_FIELD
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INAPPLICABLE_TARGET_PROPERTY_HAS_NO_DELEGATE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INAPPLICABLE_TARGET_PROPERTY_IMMUTABLE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INCOMPATIBLE_CLASS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INCOMPATIBLE_ENUM_COMPARISON
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INCOMPATIBLE_ENUM_COMPARISON_ERROR
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INCOMPATIBLE_MODIFIERS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INCOMPATIBLE_TYPES
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INCOMPATIBLE_TYPES_WARNING
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INCONSISTENT_BACKING_FIELD_TYPE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INCONSISTENT_TYPE_PARAMETER_BOUNDS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INCONSISTENT_TYPE_PARAMETER_VALUES
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INCORRECT_CHARACTER_LITERAL
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INCORRECT_LEFT_COMPONENT_OF_INTERSECTION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INCORRECT_RIGHT_COMPONENT_OF_INTERSECTION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INC_DEC_SHOULD_NOT_RETURN_UNIT
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INEFFICIENT_EQUALS_OVERRIDING_IN_VALUE_CLASS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INFERENCE_ERROR
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INFERRED_INVISIBLE_REIFIED_TYPE_ARGUMENT
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INFERRED_INVISIBLE_RETURN_TYPE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INFERRED_INVISIBLE_VARARG_TYPE_ARGUMENT
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INFERRED_INVISIBLE_WHEN_TYPE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INFERRED_TYPE_VARIABLE_INTO_EMPTY_INTERSECTION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INFERRED_TYPE_VARIABLE_INTO_POSSIBLE_EMPTY_INTERSECTION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INFIX_MODIFIER_REQUIRED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INITIALIZATION_BEFORE_DECLARATION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INITIALIZATION_BEFORE_DECLARATION_WARNING
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INITIALIZER_REQUIRED_FOR_DESTRUCTURING_DECLARATION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INITIALIZER_TYPE_MISMATCH
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INLINE_CLASS_CONSTRUCTOR_WRONG_PARAMETERS_SIZE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INLINE_CLASS_DEPRECATED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INLINE_PROPERTY_WITH_BACKING_FIELD
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INLINE_PROPERTY_WITH_BACKING_FIELD_DEPRECATION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INLINE_SUSPEND_FUNCTION_TYPE_UNSUPPORTED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INNER_CLASS_CONSTRUCTOR_NO_RECEIVER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INNER_CLASS_INSIDE_VALUE_CLASS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INNER_CLASS_OF_GENERIC_THROWABLE_SUBCLASS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INNER_ON_TOP_LEVEL_SCRIPT_CLASS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INSTANCE_ACCESS_BEFORE_SUPER_CALL
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INTERFACE_AS_FUNCTION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INTERFACE_WITH_SUPERCLASS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INT_LITERAL_OUT_OF_RANGE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INVALID_CHARACTERS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INVALID_DEFAULT_FUNCTIONAL_PARAMETER_FOR_INLINE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INVALID_IF_AS_EXPRESSION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INVALID_TYPE_OF_ANNOTATION_MEMBER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INVISIBLE_ABSTRACT_MEMBER_FROM_SUPER_ERROR
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INVISIBLE_REFERENCE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INVISIBLE_SETTER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.IR_WITH_UNSTABLE_ABI_COMPILED_CLASS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.IS_ENUM_ENTRY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ITERATOR_AMBIGUITY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ITERATOR_MISSING
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ITERATOR_ON_NULLABLE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.KCLASS_WITH_NULLABLE_TYPE_PARAMETER_IN_SIGNATURE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.KOTLIN_ACTUAL_ANNOTATION_HAS_NO_EFFECT_IN_KOTLIN
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.LABEL_NAME_CLASH
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.LATEINIT_FIELD_IN_VAL_PROPERTY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.LATEINIT_INTRINSIC_CALL_IN_INLINE_FUNCTION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.LATEINIT_INTRINSIC_CALL_ON_NON_ACCESSIBLE_PROPERTY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.LATEINIT_INTRINSIC_CALL_ON_NON_LATEINIT
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.LATEINIT_INTRINSIC_CALL_ON_NON_LITERAL
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.LATEINIT_NULLABLE_BACKING_FIELD
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.LATEINIT_PROPERTY_FIELD_DECLARATION_WITH_INITIALIZER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.LATEINIT_PROPERTY_WITHOUT_TYPE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.LEAKED_IN_PLACE_LAMBDA
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.LESS_VISIBLE_CONTAINING_CLASS_IN_INLINE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.LESS_VISIBLE_TYPE_ACCESS_IN_INLINE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.LESS_VISIBLE_TYPE_IN_INLINE_ACCESSED_SIGNATURE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.LOCAL_ANNOTATION_CLASS_ERROR
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.LOCAL_EXTENSION_PROPERTY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.LOCAL_INTERFACE_NOT_ALLOWED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.LOCAL_OBJECT_NOT_ALLOWED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.LOCAL_VARIABLE_WITH_TYPE_PARAMETERS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.LOCAL_VARIABLE_WITH_TYPE_PARAMETERS_WARNING
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.MANY_CLASSES_IN_SUPERTYPE_LIST
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.MANY_COMPANION_OBJECTS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.MANY_IMPL_MEMBER_NOT_IMPLEMENTED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.MANY_INTERFACES_MEMBER_NOT_IMPLEMENTED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.MANY_LAMBDA_EXPRESSION_ARGUMENTS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.MEMBER_PROJECTED_OUT
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.METHOD_OF_ANY_IMPLEMENTED_IN_INTERFACE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.MISPLACED_TYPE_PARAMETER_CONSTRAINTS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.MISSING_CONSTRUCTOR_KEYWORD
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.MISSING_DEPENDENCY_CLASS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.MISSING_DEPENDENCY_CLASS_IN_EXPRESSION_TYPE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.MISSING_DEPENDENCY_CLASS_IN_LAMBDA_PARAMETER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.MISSING_DEPENDENCY_CLASS_IN_LAMBDA_RECEIVER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.MISSING_DEPENDENCY_SUPERCLASS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.MISSING_DEPENDENCY_SUPERCLASS_IN_TYPE_ARGUMENT
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.MISSING_DEPENDENCY_SUPERCLASS_WARNING
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.MISSING_STDLIB_CLASS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.MISSING_VAL_ON_ANNOTATION_PARAMETER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.MIXING_FUNCTIONAL_KINDS_IN_SUPERTYPES
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.MIXING_NAMED_AND_POSITIONAL_ARGUMENTS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.MIXING_SUSPEND_AND_NON_SUSPEND_SUPERTYPES
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.MODIFIER_FORM_FOR_NON_BUILT_IN_SUSPEND
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.MODIFIER_FORM_FOR_NON_BUILT_IN_SUSPEND_FUN
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.MULTIPLE_CONTEXT_LISTS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.MULTIPLE_DEFAULTS_INHERITED_FROM_SUPERTYPES
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.MULTIPLE_DEFAULTS_INHERITED_FROM_SUPERTYPES_DEPRECATION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.MULTIPLE_DEFAULTS_INHERITED_FROM_SUPERTYPES_WHEN_NO_EXPLICIT_OVERRIDE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.MULTIPLE_DEFAULTS_INHERITED_FROM_SUPERTYPES_WHEN_NO_EXPLICIT_OVERRIDE_DEPRECATION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.MULTIPLE_LABELS_ARE_FORBIDDEN
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.MULTIPLE_VARARG_PARAMETERS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.MULTI_FIELD_VALUE_CLASS_PRIMARY_CONSTRUCTOR_DEFAULT_PARAMETER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.MUST_BE_INITIALIZED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.MUST_BE_INITIALIZED_OR_BE_ABSTRACT
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.MUST_BE_INITIALIZED_OR_BE_ABSTRACT_WARNING
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.MUST_BE_INITIALIZED_OR_BE_FINAL
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.MUST_BE_INITIALIZED_OR_BE_FINAL_WARNING
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.MUST_BE_INITIALIZED_OR_FINAL_OR_ABSTRACT
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.MUST_BE_INITIALIZED_OR_FINAL_OR_ABSTRACT_WARNING
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.MUST_BE_INITIALIZED_WARNING
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.MUTABLE_PROPERTY_WITH_CAPTURED_TYPE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NAMED_ARGUMENTS_NOT_ALLOWED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NAMED_CONTEXT_PARAMETER_IN_FUNCTION_TYPE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NAMED_PARAMETER_NOT_FOUND
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NAME_FOR_AMBIGUOUS_PARAMETER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NAME_IN_CONSTRAINT_IS_NOT_A_TYPE_PARAMETER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NESTED_CLASS_ACCESSED_VIA_INSTANCE_REFERENCE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NESTED_CLASS_NOT_ALLOWED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NESTED_CLASS_NOT_ALLOWED_IN_LOCAL
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NEWER_VERSION_IN_SINCE_KOTLIN
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NEW_INFERENCE_ERROR
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NEXT_AMBIGUITY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NEXT_MISSING
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NEXT_NONE_APPLICABLE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NONE_APPLICABLE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NON_ABSTRACT_FUNCTION_WITH_NO_BODY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NON_CONST_VAL_USED_IN_CONSTANT_EXPRESSION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NON_FINAL_MEMBER_IN_FINAL_CLASS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NON_FINAL_MEMBER_IN_OBJECT
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NON_INTERNAL_PUBLISHED_API
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NON_LOCAL_RETURN_NOT_ALLOWED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NON_LOCAL_SUSPENSION_POINT
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NON_MEMBER_FUNCTION_NO_BODY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NON_MODIFIER_FORM_FOR_BUILT_IN_SUSPEND
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NON_PRIVATE_CONSTRUCTOR_IN_ENUM
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NON_PRIVATE_OR_PROTECTED_CONSTRUCTOR_IN_SEALED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NON_PUBLIC_CALL_FROM_PUBLIC_INLINE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NON_PUBLIC_CALL_FROM_PUBLIC_INLINE_DEPRECATION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NON_PUBLIC_DATA_COPY_CALL_FROM_PUBLIC_INLINE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NON_PUBLIC_INLINE_CALL_FROM_PUBLIC_INLINE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NON_SOURCE_ANNOTATION_ON_INLINED_LAMBDA_EXPRESSION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NON_SUSPEND_OVERRIDDEN_BY_SUSPEND
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NON_TAIL_RECURSIVE_CALL
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NON_VARARG_SPREAD
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NOTHING_TO_INLINE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NOTHING_TO_OVERRIDE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NOT_AN_ANNOTATION_CLASS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NOT_A_CLASS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NOT_A_FUNCTION_LABEL
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NOT_A_LOOP_LABEL
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NOT_A_MULTIPLATFORM_COMPILATION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NOT_A_SUPERTYPE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NOT_FUNCTION_AS_OPERATOR
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NOT_NULL_ASSERTION_ON_CALLABLE_REFERENCE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NOT_NULL_ASSERTION_ON_LAMBDA_EXPRESSION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NOT_SUPPORTED_INLINE_PARAMETER_IN_INLINE_PARAMETER_DEFAULT_VALUE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NOT_YET_SUPPORTED_IN_INLINE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NO_ACTUAL_CLASS_MEMBER_FOR_EXPECTED_CLASS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NO_COMPANION_OBJECT
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NO_CONSTRUCTOR
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NO_CONTEXT_ARGUMENT
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NO_ELSE_IN_WHEN
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NO_EXPLICIT_RETURN_TYPE_IN_API_MODE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NO_EXPLICIT_RETURN_TYPE_IN_API_MODE_WARNING
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NO_EXPLICIT_VISIBILITY_IN_API_MODE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NO_EXPLICIT_VISIBILITY_IN_API_MODE_WARNING
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NO_GET_METHOD
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NO_RECEIVER_ALLOWED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NO_SET_METHOD
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NO_TAIL_CALLS_FOUND
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NO_THIS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NO_TYPE_ARGUMENTS_ON_RHS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NO_VALUE_FOR_PARAMETER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NULLABLE_INLINE_PARAMETER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NULLABLE_ON_DEFINITELY_NOT_NULLABLE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NULLABLE_SUPERTYPE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NULLABLE_SUPERTYPE_THROUGH_TYPEALIAS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NULLABLE_TYPE_IN_CLASS_LITERAL_LHS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NULLABLE_TYPE_OF_ANNOTATION_MEMBER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NULL_FOR_NONNULL_TYPE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.ONLY_ONE_CLASS_BOUND_ALLOWED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.OPERATOR_CALL_ON_CONSTRUCTOR
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.OPERATOR_MODIFIER_REQUIRED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.OPERATOR_RENAMED_ON_IMPORT
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.OPTIONAL_DECLARATION_OUTSIDE_OF_ANNOTATION_ENTRY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.OPTIONAL_DECLARATION_USAGE_IN_NON_COMMON_SOURCE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.OPTIONAL_EXPECTATION_NOT_ON_EXPECTED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.OPT_IN_ARGUMENT_IS_NOT_MARKER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.OPT_IN_CAN_ONLY_BE_USED_AS_ANNOTATION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.OPT_IN_MARKER_CAN_ONLY_BE_USED_AS_ANNOTATION_OR_ARGUMENT_IN_OPT_IN
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.OPT_IN_MARKER_ON_OVERRIDE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.OPT_IN_MARKER_ON_OVERRIDE_WARNING
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.OPT_IN_MARKER_ON_WRONG_TARGET
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.OPT_IN_MARKER_WITH_WRONG_RETENTION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.OPT_IN_MARKER_WITH_WRONG_TARGET
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.OPT_IN_OVERRIDE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.OPT_IN_OVERRIDE_ERROR
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.OPT_IN_TO_INHERITANCE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.OPT_IN_TO_INHERITANCE_ERROR
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.OPT_IN_USAGE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.OPT_IN_USAGE_ERROR
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.OPT_IN_WITHOUT_ARGUMENTS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.OTHER_ERROR
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.OTHER_ERROR_WITH_REASON
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.OUTER_CLASS_ARGUMENTS_REQUIRED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.OVERLOAD_RESOLUTION_AMBIGUITY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.OVERRIDE_BY_INLINE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.OVERRIDE_DEPRECATION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.OVERRIDING_FINAL_MEMBER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.OVERRIDING_FINAL_MEMBER_BY_DELEGATION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.PACKAGE_CANNOT_BE_IMPORTED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.PACKAGE_CONFLICTS_WITH_CLASSIFIER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.PARAMETER_NAME_CHANGED_ON_OVERRIDE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.PLACEHOLDER_PROJECTION_IN_QUALIFIER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.PLATFORM_CLASS_MAPPED_TO_KOTLIN
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.PLUGIN_AMBIGUOUS_INTERCEPTED_SYMBOL
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.POTENTIALLY_NON_REPORTED_ANNOTATION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.PRE_RELEASE_CLASS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.PRIMARY_CONSTRUCTOR_DELEGATION_CALL_EXPECTED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.PRIVATE_CLASS_MEMBER_FROM_INLINE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.PRIVATE_FUNCTION_WITH_NO_BODY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.PRIVATE_PROPERTY_IN_INTERFACE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.PRIVATE_SETTER_FOR_ABSTRACT_PROPERTY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.PRIVATE_SETTER_FOR_OPEN_PROPERTY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.PROJECTION_IN_IMMEDIATE_ARGUMENT_TO_SUPERTYPE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.PROJECTION_IN_TYPE_OF_ANNOTATION_MEMBER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.PROJECTION_ON_NON_CLASS_TYPE_ARGUMENT
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.PROPERTY_FIELD_DECLARATION_MISSING_INITIALIZER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.PROPERTY_INITIALIZER_IN_INTERFACE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.PROPERTY_INITIALIZER_NO_BACKING_FIELD
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.PROPERTY_INITIALIZER_WITH_EXPLICIT_FIELD_DECLARATION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.PROPERTY_TYPE_MISMATCH_BY_DELEGATION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.PROPERTY_TYPE_MISMATCH_ON_INHERITANCE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.PROPERTY_TYPE_MISMATCH_ON_OVERRIDE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.PROPERTY_WITH_BACKING_FIELD_INSIDE_VALUE_CLASS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.PROPERTY_WITH_NO_TYPE_NO_INITIALIZER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.PROTECTED_CALL_FROM_PUBLIC_INLINE_ERROR
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.PROTECTED_CONSTRUCTOR_CALL_FROM_PUBLIC_INLINE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.PROTECTED_CONSTRUCTOR_NOT_IN_SUPER_CALL
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.RECEIVER_SHADOWED_BY_CONTEXT_PARAMETER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.RECURSION_IN_IMPLICIT_TYPES
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.RECURSION_IN_INLINE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.RECURSIVE_TYPEALIAS_EXPANSION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.REDECLARATION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.REDUNDANT_ANNOTATION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.REDUNDANT_ANNOTATION_TARGET
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.REDUNDANT_CALL_OF_CONVERSION_METHOD
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.REDUNDANT_ELSE_IN_WHEN
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.REDUNDANT_EXPLICIT_BACKING_FIELD
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.REDUNDANT_INTERPOLATION_PREFIX
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.REDUNDANT_LABEL_WARNING
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.REDUNDANT_MODALITY_MODIFIER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.REDUNDANT_MODIFIER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.REDUNDANT_MODIFIER_FOR_TARGET
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.REDUNDANT_NULLABLE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.REDUNDANT_OPEN_IN_INTERFACE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.REDUNDANT_PROJECTION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.REDUNDANT_RETURN
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.REDUNDANT_RETURN_UNIT_TYPE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.REDUNDANT_SETTER_PARAMETER_TYPE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.REDUNDANT_SINGLE_EXPRESSION_STRING_TEMPLATE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.REDUNDANT_SPREAD_OPERATOR_IN_NAMED_FORM_IN_ANNOTATION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.REDUNDANT_SPREAD_OPERATOR_IN_NAMED_FORM_IN_FUNCTION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.REDUNDANT_VISIBILITY_MODIFIER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.REIFIED_TYPE_FORBIDDEN_SUBSTITUTION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.REIFIED_TYPE_PARAMETER_IN_OVERRIDE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.REIFIED_TYPE_PARAMETER_NO_INLINE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.REIFIED_TYPE_PARAMETER_ON_ALIAS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.REPEATED_ANNOTATION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.REPEATED_ANNOTATION_WARNING
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.REPEATED_BOUND
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.REPEATED_MODIFIER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.RESERVED_MEMBER_FROM_INTERFACE_INSIDE_VALUE_CLASS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.RESERVED_MEMBER_INSIDE_VALUE_CLASS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.RESOLUTION_TO_CLASSIFIER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.RESOLVED_TO_UNDERSCORE_NAMED_CATCH_PARAMETER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.RESTRICTED_RETENTION_FOR_EXPRESSION_ANNOTATION_ERROR
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.RESULT_TYPE_MISMATCH
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.RETURN_FOR_BUILT_IN_SUSPEND
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.RETURN_IN_FUNCTION_WITH_EXPRESSION_BODY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.RETURN_IN_FUNCTION_WITH_EXPRESSION_BODY_AND_IMPLICIT_TYPE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.RETURN_NOT_ALLOWED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.RETURN_TYPE_MISMATCH
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.RETURN_TYPE_MISMATCH_BY_DELEGATION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.RETURN_TYPE_MISMATCH_ON_INHERITANCE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.RETURN_TYPE_MISMATCH_ON_OVERRIDE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.RETURN_VALUE_NOT_USED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SAFE_CALLABLE_REFERENCE_CALL
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SEALED_CLASS_CONSTRUCTOR_CALL
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SEALED_INHERITOR_IN_DIFFERENT_MODULE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SEALED_INHERITOR_IN_DIFFERENT_PACKAGE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SEALED_SUPERTYPE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SEALED_SUPERTYPE_IN_LOCAL_CLASS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SECONDARY_CONSTRUCTOR_WITH_BODY_INSIDE_VALUE_CLASS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SELF_CALL_IN_NESTED_OBJECT_CONSTRUCTOR_ERROR
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SENSELESS_COMPARISON
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SENSELESS_NULL_IN_WHEN
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SETTER_PROJECTED_OUT
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SETTER_VISIBILITY_INCONSISTENT_WITH_PROPERTY_VISIBILITY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SINGLETON_IN_SUPERTYPE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SINGLE_ANONYMOUS_FUNCTION_WITH_NAME
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SMARTCAST_IMPOSSIBLE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SMARTCAST_IMPOSSIBLE_ON_IMPLICIT_INVOKE_RECEIVER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SPREAD_OF_NULLABLE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SUBCLASS_OPT_IN_ARGUMENT_IS_NOT_MARKER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SUBCLASS_OPT_IN_INAPPLICABLE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SUBTYPING_BETWEEN_CONTEXT_RECEIVERS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SUPERCLASS_NOT_ACCESSIBLE_FROM_INTERFACE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SUPERTYPES_FOR_ANNOTATION_CLASS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SUPERTYPE_APPEARS_TWICE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SUPERTYPE_INITIALIZED_IN_EXPECTED_CLASS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SUPERTYPE_INITIALIZED_IN_INTERFACE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SUPERTYPE_INITIALIZED_WITHOUT_PRIMARY_CONSTRUCTOR
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SUPERTYPE_IS_EXTENSION_OR_CONTEXT_FUNCTION_TYPE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SUPERTYPE_NOT_A_CLASS_OR_INTERFACE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SUPERTYPE_NOT_INITIALIZED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SUPER_CALL_FROM_PUBLIC_INLINE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SUPER_CALL_WITH_DEFAULT_PARAMETERS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SUPER_IS_NOT_AN_EXPRESSION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SUPER_NOT_AVAILABLE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.SUSPEND_OVERRIDDEN_BY_NON_SUSPEND
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TAILREC_ON_VIRTUAL_MEMBER_ERROR
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TAIL_RECURSION_IN_TRY_IS_NOT_SUPPORTED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.THROWABLE_TYPE_MISMATCH
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TOO_MANY_ARGUMENTS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TOO_MANY_CHARACTERS_IN_CHARACTER_LITERAL
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TOPLEVEL_TYPEALIASES_ONLY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TYPEALIAS_AS_CALLABLE_QUALIFIER_IN_IMPORT
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TYPEALIAS_EXPANDS_TO_ARRAY_OF_NOTHINGS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TYPEALIAS_EXPANSION_CAPTURES_OUTER_TYPE_PARAMETERS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TYPEALIAS_EXPANSION_DEPRECATION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TYPEALIAS_EXPANSION_DEPRECATION_ERROR
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TYPEALIAS_SHOULD_EXPAND_TO_CLASS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TYPECHECKER_HAS_RUN_INTO_RECURSIVE_PROBLEM
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TYPE_ARGUMENTS_FOR_OUTER_CLASS_WHEN_NESTED_REFERENCED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TYPE_ARGUMENTS_NOT_ALLOWED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TYPE_ARGUMENTS_REDUNDANT_IN_SUPER_QUALIFIER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TYPE_ARGUMENT_ON_TYPED_VALUE_CLASS_EQUALS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TYPE_CANT_BE_USED_FOR_CONST_VAL
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TYPE_INFERENCE_ONLY_INPUT_TYPES_ERROR
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TYPE_INTERSECTION_AS_REIFIED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TYPE_MISMATCH
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TYPE_PARAMETERS_IN_ANONYMOUS_OBJECT
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TYPE_PARAMETERS_IN_ENUM
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TYPE_PARAMETERS_IN_OBJECT
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TYPE_PARAMETERS_NOT_ALLOWED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TYPE_PARAMETER_AS_REIFIED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TYPE_PARAMETER_AS_REIFIED_ARRAY_ERROR
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TYPE_PARAMETER_IN_CATCH_CLAUSE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TYPE_PARAMETER_IS_NOT_AN_EXPRESSION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.INCORRECT_TYPE_PARAMETER_OF_PROPERTY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.MISSING_DEPENDENCY_CLASS_IN_TYPEALIAS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.MISSING_DEPENDENCY_IN_INFERRED_TYPE_ANNOTATION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NAME_BASED_DESTRUCTURING_UNDERSCORE_WITHOUT_RENAMING
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.NON_FINAL_PROPERTY_WITH_EXPLICIT_BACKING_FIELD
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.OVERRIDING_IGNORABLE_WITH_MUST_USE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.PROPERTY_WITH_EXPLICIT_FIELD_AND_ACCESSORS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TYPE_PARAMETER_ON_LHS_OF_DOT
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TYPE_VARIANCE_CONFLICT_ERROR
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.TYPE_VARIANCE_CONFLICT_IN_EXPANDED_TYPE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UNCHECKED_CAST
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UNDERSCORE_IS_RESERVED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UNDERSCORE_USAGE_WITHOUT_BACKTICKS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UNEXPECTED_SAFE_CALL
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UNEXPECTED_TRAILING_LAMBDA_ON_A_NEW_LINE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UNINITIALIZED_ENUM_COMPANION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UNINITIALIZED_ENUM_ENTRY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UNINITIALIZED_PARAMETER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UNINITIALIZED_VARIABLE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UNNAMED_DELEGATED_PROPERTY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UNNAMED_VAR_PROPERTY
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UNNECESSARY_LATEINIT
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UNNECESSARY_NOT_NULL_ASSERTION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UNNECESSARY_SAFE_CALL
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UNREACHABLE_CODE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UNRESOLVED_IMPORT
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UNRESOLVED_LABEL
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UNRESOLVED_REFERENCE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UNRESOLVED_REFERENCE_WRONG_RECEIVER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UNSAFE_CALL
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UNSAFE_IMPLICIT_INVOKE_CALL
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UNSAFE_INFIX_CALL
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UNSAFE_OPERATOR_CALL
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UNSIGNED_LITERAL_WITHOUT_DECLARATIONS_ON_CLASSPATH
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UNSUPPORTED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UNSUPPORTED_CLASS_LITERALS_WITH_EMPTY_LHS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UNSUPPORTED_CONTEXTUAL_DECLARATION_CALL
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.RETURN_IN_FUNCTION_WITH_EXPRESSION_BODY_WARNING
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UNSUPPORTED_FEATURE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UNSUPPORTED_INHERITANCE_FROM_JAVA_MEMBER_REFERENCING_KOTLIN_FUNCTION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UNSUPPORTED_SEALED_FUN_INTERFACE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UNSUPPORTED_SUSPEND_TEST
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UNUSED_ANONYMOUS_PARAMETER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UNUSED_EXPRESSION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UNUSED_LAMBDA_EXPRESSION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UNUSED_VARIABLE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UPPER_BOUND_IS_EXTENSION_OR_CONTEXT_FUNCTION_TYPE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UPPER_BOUND_VIOLATED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UPPER_BOUND_VIOLATED_DEPRECATION_WARNING
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UPPER_BOUND_VIOLATED_IN_TYPEALIAS_EXPANSION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UPPER_BOUND_VIOLATED_IN_TYPEALIAS_EXPANSION_DEPRECATION_WARNING
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.UPPER_BOUND_VIOLATED_IN_TYPE_OPERATOR_OR_PARAMETER_BOUNDS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.USAGE_IS_NOT_INLINABLE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.USELESS_CALL_ON_NOT_NULL
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.USELESS_CAST
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.USELESS_ELVIS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.USELESS_ELVIS_LEFT_IS_NULL
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.USELESS_ELVIS_RIGHT_IS_NULL
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.USELESS_IS_CHECK
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.USELESS_VARARG_ON_PARAMETER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.VALUE_CLASS_CANNOT_BE_CLONEABLE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.VALUE_CLASS_CANNOT_BE_RECURSIVE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.VALUE_CLASS_CANNOT_EXTEND_CLASSES
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.VALUE_CLASS_CANNOT_HAVE_CONTEXT_RECEIVERS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.VALUE_CLASS_CANNOT_IMPLEMENT_INTERFACE_BY_DELEGATION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.VALUE_CLASS_CONSTRUCTOR_NOT_FINAL_READ_ONLY_PARAMETER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.VALUE_CLASS_EMPTY_CONSTRUCTOR
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.VALUE_CLASS_HAS_INAPPLICABLE_PARAMETER_TYPE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.VALUE_CLASS_NOT_FINAL
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.VALUE_CLASS_NOT_TOP_LEVEL
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.VALUE_PARAMETER_WITHOUT_EXPLICIT_TYPE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.VAL_OR_VAR_ON_CATCH_PARAMETER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.VAL_OR_VAR_ON_FUN_PARAMETER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.VAL_OR_VAR_ON_LOOP_PARAMETER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.VAL_OR_VAR_ON_SECONDARY_CONSTRUCTOR_PARAMETER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.VAL_REASSIGNMENT
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.VAL_REASSIGNMENT_VIA_BACKING_FIELD_ERROR
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.VAL_WITH_SETTER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.VARARG_OUTSIDE_PARENTHESES
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.VARIABLE_EXPECTED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.VARIABLE_INITIALIZER_IS_REDUNDANT
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.VARIABLE_NEVER_READ
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.VARIABLE_WITH_NO_TYPE_NO_INITIALIZER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.VARIANCE_ON_TYPE_PARAMETER_NOT_ALLOWED
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.VAR_ANNOTATION_PARAMETER
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.VAR_IMPLEMENTED_BY_INHERITED_VAL
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.VAR_OVERRIDDEN_BY_VAL
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.VAR_OVERRIDDEN_BY_VAL_BY_DELEGATION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.VAR_PROPERTY_WITH_EXPLICIT_BACKING_FIELD
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.VAR_TYPE_MISMATCH_ON_INHERITANCE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.VAR_TYPE_MISMATCH_ON_OVERRIDE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.VERSION_REQUIREMENT_DEPRECATION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.VERSION_REQUIREMENT_DEPRECATION_ERROR
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.VIRTUAL_MEMBER_HIDDEN
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.VOLATILE_ON_DELEGATE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.VOLATILE_ON_VALUE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.WHEN_GUARD_WITHOUT_SUBJECT
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.WRAPPED_LHS_IN_ASSIGNMENT
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.WRONG_ANNOTATION_TARGET
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.WRONG_ANNOTATION_TARGET_WARNING
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.WRONG_CONDITION_SUGGEST_GUARD
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.WRONG_EXTENSION_FUNCTION_TYPE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.WRONG_EXTENSION_FUNCTION_TYPE_WARNING
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.WRONG_GETTER_RETURN_TYPE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.WRONG_INVOCATION_KIND
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.WRONG_LONG_SUFFIX
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.WRONG_MODIFIER_CONTAINING_DECLARATION
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.WRONG_MODIFIER_TARGET
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.WRONG_NUMBER_OF_TYPE_ARGUMENTS
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.WRONG_SETTER_PARAMETER_TYPE
import org.jetbrains.kotlin.fir.analysis.diagnostics.FirErrors.WRONG_SETTER_RETURN_TYPE
import org.jetbrains.kotlin.fir.symbols.impl.FirCallableSymbol
import org.jetbrains.kotlin.fir.symbols.impl.FirValueParameterSymbol
import org.jetbrains.kotlin.fir.types.renderReadable
import org.jetbrains.kotlin.serialization.deserialization.IncompatibleVersionErrorData

/**
 * ## Guidelines for diagnostic messages
 *
 * - Sentences and fragments should end with a full stop.
 * - If a message has parameters, single quotes (') must be escaped by using double single quotes ('').
 * Otherwise, text inside single quotes will not be formatted (see [java.text.MessageFormat]).
 * - If a message has no parameters, no double single quotes should be used.
 * [java.text.MessageFormat] won't be used under the hood, and so the double single quotes will be printed.
 * - Parameters referring to the user's declarations should be quoted (with two single quotes).
 * - Use single quotes (') instead of backticks (`) or double quotes ("")
 */
@Suppress(""unused"")
object FirErrorsDefaultMessages : BaseDiagnosticRendererFactory() {

    private const val EXPECT_ACTUAL_INCOMPATIBILITY_MSG =
        ""The ''expect'' and the ''actual'' declarations are incompatible.\n  expect: {0}\n  actual: {1}\n  reason: {2}""

    // * - The old FE reports these diagnostics with additional parameters
    // & - New diagnostic that has no analogues in the old FE
    // + - Better message required
    // # - The new diagnostic differs from the old FE's one
    override val MAP: KtDiagnosticFactoryToRendererMap by KtDiagnosticFactoryToRendererMap(""FIR"") { map ->
        // Meta-errors
        map.put(UNSUPPORTED, ""{0}"", TO_STRING)
        map.put(UNSUPPORTED_FEATURE, ""{0}"", LanguageFeatureMessageRenderer(LanguageFeatureMessageRenderer.Type.UNSUPPORTED))
        map.put(UNSUPPORTED_SUSPEND_TEST, ""'suspend' functions annotated with '@kotlin.test.Test' are unsupported."")
        map.put(NEW_INFERENCE_ERROR, ""New inference error [{0}]."", STRING)

        // Miscellaneous
        map.put(OTHER_ERROR, ""Unknown error."")
        map.put(OTHER_ERROR_WITH_REASON, ""Unknown error: {0}."", STRING)

        // General syntax
        map.put(ILLEGAL_CONST_EXPRESSION, ""Incorrect const expression."")
        map.put(ILLEGAL_UNDERSCORE, ""Incorrect usage of underscore in numeric literal."")
//            map.put(EXPRESSION_REQUIRED, ...) // &
        map.put(EXPRESSION_EXPECTED, ""Only expressions are allowed here."")
        map.put(ASSIGNMENT_IN_EXPRESSION_CONTEXT, ""Only expressions are allowed in this context."")
        map.put(BREAK_OR_CONTINUE_OUTSIDE_A_LOOP, ""'break' and 'continue' are only allowed inside loops."")
        map.put(NOT_A_LOOP_LABEL, ""Label does not denote a reachable loop."") // *
        map.put(BREAK_OR_CONTINUE_JUMPS_ACROSS_FUNCTION_BOUNDARY, ""'break' or 'continue' crosses a function or class boundary."")
        map.put(VARIABLE_EXPECTED, ""Variable expected."")
        map.put(DELEGATION_IN_INTERFACE, ""Delegation cannot be used in interfaces."")
        map.put(DELEGATION_NOT_TO_INTERFACE, ""Delegation is supported only for interfaces."")
        map.put(NESTED_CLASS_NOT_ALLOWED, ""''{0}'' is prohibited here."", TO_STRING)
        map.put(NESTED_CLASS_NOT_ALLOWED_IN_LOCAL, ""''{0}'' is prohibited here."", TO_STRING)
        map.put(INCORRECT_CHARACTER_LITERAL, ""Incorrect character literal."")
        map.put(EMPTY_CHARACTER_LITERAL, ""Empty character literal."")
        map.put(TOO_MANY_CHARACTERS_IN_CHARACTER_LITERAL, ""Too many characters in a character literal."")
        map.put(ILLEGAL_ESCAPE, ""Unsupported escape sequence."")
        map.put(INT_LITERAL_OUT_OF_RANGE, ""Value out of range."")
        map.put(FLOAT_LITERAL_OUT_OF_RANGE, ""Value out of range."")
        map.put(WRONG_LONG_SUFFIX, ""Use 'L' instead of 'l'."")
        map.put(
            UNSIGNED_LITERAL_WITHOUT_DECLARATIONS_ON_CLASSPATH,
            ""Type of constant expression cannot be resolved. Make sure you have the required dependencies for unsigned types in the classpath.""
        )
        map.put(DIVISION_BY_ZERO, ""Division by zero."")
        map.put(VAL_OR_VAR_ON_LOOP_PARAMETER, ""''{0}'' on loop parameter is prohibited."", TO_STRING)
        map.put(VAL_OR_VAR_ON_FUN_PARAMETER, ""''{0}'' on function parameter is prohibited."", TO_STRING)
        map.put(VAL_OR_VAR_ON_CATCH_PARAMETER, ""''{0}'' on catch parameter is prohibited."", TO_STRING)
        map.put(VAL_OR_VAR_ON_SECONDARY_CONSTRUCTOR_PARAMETER, ""''{0}'' on secondary constructor parameter is prohibited."", TO_STRING)
        map.put(INNER_ON_TOP_LEVEL_SCRIPT_CLASS, ""Top-level script class cannot be inner."")
        map.put(
            ERROR_SUPPRESSION,
            ""Suppression of error ''{0}'' might compile and work, but the compiler behavior is UNSPECIFIED and WILL NOT BE PRESERVED. Please report your use case to the Kotlin issue tracker instead: https://kotl.in/issue"",
            TO_STRING
        )
        map.put(MISSING_CONSTRUCTOR_KEYWORD, ""Use the 'constructor' keyword after the modifiers of the primary constructor."")
        map.put(REDUNDANT_INTERPOLATION_PREFIX, ""Redundant interpolation prefix."")
        map.put(
            WRAPPED_LHS_IN_ASSIGNMENT,
            ""Wrapping the left-hand side of assignments in parentheses, labels or annotations is not allowed.""
        )

        // Unresolved
        map.put(
            UNRESOLVED_REFERENCE,
            ""Unresolved reference ''{0}''{1}."",
            NULLABLE_STRING,
            FOR_OPTIONAL_OPERATOR,
        )
        map.put(
            UNRESOLVED_REFERENCE_WRONG_RECEIVER,
            ""Unresolved reference. None of the following candidates is applicable because of a receiver type mismatch:{0}"",
            SYMBOLS_ON_NEXT_LINES,
        )
        map.put(
            UNRESOLVED_IMPORT,
            ""Unresolved reference ''{0}''."",
            NULLABLE_STRING,
        ) // &
        map.put(
            INVISIBLE_REFERENCE,
            ""Cannot access ''{0}'': it is {1} in {2}."",
            SYMBOL,
            VISIBILITY,
            NAME_OF_DECLARATION_OR_FILE,
        )
        map.put(
            INVISIBLE_SETTER,
            ""Cannot access ''{0}'': it is {1} in {2}."",
            VARIABLE_NAME,
            VISIBILITY,
            NAME_OF_CONTAINING_DECLARATION_OR_FILE,
        )
        map.put(UNRESOLVED_LABEL, ""Unresolved label."")
        map.put(AMBIGUOUS_LABEL, ""Ambiguous label."")
        map.put(LABEL_NAME_CLASH, ""There is more than one label with such a name in this scope."")
        map.put(DESERIALIZATION_ERROR, ""Deserialization error."")
        map.put(ERROR_FROM_JAVA_RESOLUTION, ""Java resolution error."")
        map.put(MISSING_STDLIB_CLASS, ""Missing stdlib class."")
        map.put(NO_THIS, ""'this' is not defined in this context."")
        map.put(
            API_NOT_AVAILABLE,
            ""This declaration is only available in Kotlin {0} and newer versions and cannot be used with the specified API version {1}."",
            TO_STRING,
            TO_STRING,
        )
        map.put(PLACEHOLDER_PROJECTION_IN_QUALIFIER, ""Type argument inference is not supported in qualifiers."")
        map.put(DUPLICATE_PARAMETER_NAME_IN_FUNCTION_TYPE, ""Duplicate parameter name in a function type."")
//            map.put(UNKNOWN_CALLABLE_KIND, ...) // &
        map.put(
            MISSING_DEPENDENCY_CLASS,
            ""Cannot access class ''{0}''. Check your module classpath for missing or conflicting dependencies."",
            RENDER_TYPE,
        )
        map.put(
            MISSING_DEPENDENCY_CLASS_IN_EXPRESSION_TYPE,
            ""Cannot access class ''{0}'' in the expression type. This may be forbidden soon. Check the module classpath for missing or conflicting dependencies."",
            RENDER_TYPE,
        )
        map.put(
            MISSING_DEPENDENCY_SUPERCLASS,
            ""Cannot access ''{0}'' which is a supertype of ''{1}''. Check your module classpath for missing or conflicting dependencies."",
            RENDER_TYPE,
            RENDER_TYPE,
        )
        map.put(
            MISSING_DEPENDENCY_SUPERCLASS_WARNING,
            ""Cannot access ''{0}'' which is a supertype of ''{1}''. This may be forbidden soon. Check the module classpath for missing or conflicting dependencies."",
            RENDER_TYPE,
            RENDER_TYPE,
        )
        map.put(
            MISSING_DEPENDENCY_SUPERCLASS_IN_TYPE_ARGUMENT,
            ""Cannot access ''{0}'' which is a supertype of ''{1}'' or one of its arguments. This may be forbidden soon. Check the module classpath for missing or conflicting dependencies."",
            RENDER_TYPE,
            RENDER_TYPE,
        )
        map.put(
            MISSING_DEPENDENCY_CLASS_IN_LAMBDA_PARAMETER,
            ""Class ''{0}'' of the parameter ''{1}'' is inaccessible. This may be forbidden soon. Check the module classpath for missing or conflicting dependencies."",
            RENDER_TYPE,
            NAME,
        )
        map.put(
            MISSING_DEPENDENCY_CLASS_IN_LAMBDA_RECEIVER,
            ""Class ''{0}'' of the lambda receiver is inaccessible. This may be forbidden soon. Check the module classpath for missing or conflicting dependencies."",
            RENDER_TYPE,
        )
        map.put(
            MISSING_DEPENDENCY_CLASS_IN_TYPEALIAS,
            ""Cannot access ''{0}'' which typealias ''{1}'' expands to. Check your module classpath for missing or conflicting dependencies.""
                .toDeprecationWarningMessage(LanguageFeature.ForbidTypeAliasWithMissingDependencyType),
            RENDER_TYPE,
            RENDER_TYPE,
        )
        map.put(
            MISSING_DEPENDENCY_IN_INFERRED_TYPE_ANNOTATION,
            ""Type annotation class ''{0}'' of the inferred type is inaccessible. Check the module classpath for missing or conflicting dependencies."",
            RENDER_TYPE,
        )

        // Super
        map.put(SUPER_IS_NOT_AN_EXPRESSION, ""'super' cannot be a callee."")
        map.put(SUPER_NOT_AVAILABLE, ""No supertypes are accessible in this context."")
        map.put(ABSTRACT_SUPER_CALL, ""Abstract member cannot be accessed directly."")
        map.put(
            ABSTRACT_SUPER_CALL_WARNING,
            ""Access to abstract fake override member is deprecated. See https://youtrack.jetbrains.com/issue/KT-49017.""
        )
        map.put(
            INSTANCE_ACCESS_BEFORE_SUPER_CALL,
            ""Cannot access ''{0}'' before the instance has been initialized."",
            TO_STRING
        )
        map.put(CREATING_AN_INSTANCE_OF_ABSTRACT_CLASS, ""Cannot create an instance of an abstract class."")
        map.put(NO_CONSTRUCTOR, ""This type does not have a constructor."")
        map.put(FUNCTION_CALL_EXPECTED, ""Function invocation ''{0}({1})'' expected."", TO_STRING, FUNCTION_PARAMETERS)
        map.put(
            FUNCTION_EXPECTED,
            ""Expression ''{0}'' of type ''{1}'' cannot be invoked as a function. Function ''invoke()'' is not found."", TO_STRING, RENDER_TYPE
        )
        map.put(INTERFACE_AS_FUNCTION, ""Interface ''{0}'' does not have constructors."", SYMBOL)
        map.put(EXPECT_CLASS_AS_FUNCTION, ""Expected class ''{0}'' does not have default constructor."", SYMBOL)
        map.put(
            INNER_CLASS_CONSTRUCTOR_NO_RECEIVER,
            ""Constructor of the inner class ''{0}'' can only be called with a receiver of the containing class."",
            SYMBOL
        )
        map.put(RESOLUTION_TO_CLASSIFIER, ""Resolution to the classifier ''{0}'' is not appropriate here."", SYMBOL)
        map.put(
            AMBIGUOUS_ALTERED_ASSIGN,
            ""Multiple extensions attempted to alter this assignment at the same time. Extensions: {0}"",
            COLLECTION(NULLABLE_STRING)
        )
        map.put(
            SELF_CALL_IN_NESTED_OBJECT_CONSTRUCTOR_ERROR,
            ""Self references to members of containing class are prohibited in constructor of nested object."",
        )
        map.put(
            PLUGIN_AMBIGUOUS_INTERCEPTED_SYMBOL,
            ""Multiple extensions attempted to modify this function call. Extensions: {0}"",
            COLLECTION(NULLABLE_STRING)
        )

        map.put(ILLEGAL_SELECTOR, ""The expression cannot be a selector (cannot occur after a dot)."")
        map.put(NO_RECEIVER_ALLOWED, ""No receiver can be passed to this function or property."")
        map.put(
            SUPER_CALL_WITH_DEFAULT_PARAMETERS,
            ""Super-calls with default arguments are prohibited. Specify all arguments of ''super.{0}'' explicitly."",
            TO_STRING
        )

        // Supertypes
        map.put(NOT_A_SUPERTYPE, ""Not an immediate supertype."")
        map.put(TYPE_ARGUMENTS_REDUNDANT_IN_SUPER_QUALIFIER, ""Type arguments do not need to be specified in a 'super' qualifier."")
        map.put(SUPERCLASS_NOT_ACCESSIBLE_FROM_INTERFACE, ""Superclass is not accessible from interface."")
        map.put(SUPERTYPE_INITIALIZED_IN_INTERFACE, ""Interfaces cannot initialize supertypes."")
        map.put(INTERFACE_WITH_SUPERCLASS, ""An interface cannot extend a class."")
        map.put(FINAL_SUPERTYPE, ""This type is final, so it cannot be extended."")
        map.put(CLASS_CANNOT_BE_EXTENDED_DIRECTLY, ""Class ''{0}'' cannot be extended directly."", SYMBOL)
        map.put(SUPERTYPE_IS_EXTENSION_OR_CONTEXT_FUNCTION_TYPE, ""Extension or contextual function type is not allowed as a supertype."")
        map.put(SINGLETON_IN_SUPERTYPE, ""Cannot extend an object."")
        map.put(NULLABLE_SUPERTYPE, ""Supertypes cannot be nullable."")
        map.put(NULLABLE_SUPERTYPE_THROUGH_TYPEALIAS, ""Supertypes through typealias cannot be nullable."")
        map.put(MANY_CLASSES_IN_SUPERTYPE_LIST, ""Only one class can appear in a supertype list."")
        map.put(SUPERTYPE_APPEARS_TWICE, ""A supertype appears twice."")
        map.put(CLASS_IN_SUPERTYPE_FOR_ENUM, ""Enum classes cannot extend classes."")
        map.put(SEALED_SUPERTYPE, ""This type is sealed. It can only be extended by classes or objects in the same package."")
        map.put(SEALED_SUPERTYPE_IN_LOCAL_CLASS, ""{0} cannot extend a sealed {1}."", STRING, CLASS_KIND)
        map.put(
            SEALED_INHERITOR_IN_DIFFERENT_PACKAGE,
            ""A class can only extend a sealed class or interface declared in the same package.""
        )
        map.put(SEALED_INHERITOR_IN_DIFFERENT_MODULE, ""Extending sealed classes or interfaces from a different module is prohibited."")
        map.put(CLASS_INHERITS_JAVA_SEALED_CLASS, ""Extending Java sealed classes is prohibited."")
        map.put(UNSUPPORTED_SEALED_FUN_INTERFACE, ""'sealed fun interface' is unsupported."")

        map.put(SUPERTYPE_NOT_A_CLASS_OR_INTERFACE, ""Supertype is not a class or interface."", TO_STRING)
        map.put(
            UNSUPPORTED_INHERITANCE_FROM_JAVA_MEMBER_REFERENCING_KOTLIN_FUNCTION,
            ""Inheritance of a Java member referencing ''kotlin.jvm.functions.FunctionN'': {0} is unsupported."",
            SYMBOL,
        )
        map.put(CYCLIC_INHERITANCE_HIERARCHY, ""Cycle in supertypes and/or containing declarations detected."")
        map.put(
            EXPANDED_TYPE_CANNOT_BE_INHERITED,
            ""Type alias expands to ''{0}'', which is not a class, interface, or object."",
            RENDER_TYPE
        )
        map.put(PROJECTION_IN_IMMEDIATE_ARGUMENT_TO_SUPERTYPE, ""Projections for immediate arguments of a supertype are prohibited."")
        map.put(
            INCONSISTENT_TYPE_PARAMETER_VALUES,
            ""Type parameter ''{0}'' of ''{1}'' has inconsistent values: {2}."",
            SYMBOL,
            SYMBOL,
            RENDER_COLLECTION_OF_TYPES
        )
        map.put(
            INCONSISTENT_TYPE_PARAMETER_BOUNDS,
            ""Type parameter ''{0}'' of ''{1}'' has inconsistent bounds: {2}."",
            SYMBOL,
            SYMBOL,
            RENDER_COLLECTION_OF_TYPES
        )
        map.put(
            AMBIGUOUS_SUPER,
            ""Multiple supertypes available. Specify the intended supertype in angle brackets, e.g. ''super<Foo>''."",
            NOT_RENDERED
        )

        // Constructor problems
        map.put(CONSTRUCTOR_IN_OBJECT, ""Objects cannot have constructors."")
        map.put(CONSTRUCTOR_IN_INTERFACE, ""Interfaces cannot have constructors."")
        map.put(NON_PRIVATE_CONSTRUCTOR_IN_ENUM, ""Constructor must be private in enum class."")
        map.put(NON_PRIVATE_OR_PROTECTED_CONSTRUCTOR_IN_SEALED, ""Constructor must be private or protected in sealed class."")
        map.put(CYCLIC_CONSTRUCTOR_DELEGATION_CALL, ""There's a cycle in the delegation calls chain."")
        map.put(PRIMARY_CONSTRUCTOR_DELEGATION_CALL_EXPECTED, ""Primary constructor call expected."")
        map.put(PROTECTED_CONSTRUCTOR_NOT_IN_SUPER_CALL, ""Protected constructor ''{0}'' from other classes can only be used in super-call."", SYMBOL)
        map.put(SUPERTYPE_INITIALIZED_WITHOUT_PRIMARY_CONSTRUCTOR, ""Supertype initialization is impossible without a primary constructor."")
        map.put(DELEGATION_SUPER_CALL_IN_ENUM_CONSTRUCTOR, ""Calls to super in enum constructors are prohibited."")
        map.put(
            EXPLICIT_DELEGATION_CALL_REQUIRED,
            ""Explicit 'this' or 'super' call is required. There is no constructor in the superclass that can be called without arguments.""
        )
        map.put(SEALED_CLASS_CONSTRUCTOR_CALL, ""Sealed types cannot be instantiated."")
        map.put(
            DATA_CLASS_COPY_VISIBILITY_WILL_BE_CHANGED,
            """"""
                Non-public primary constructor is exposed via the generated 'copy()' method of the 'data' class.

                The generated 'copy()' will change its visibility in future releases.

                To suppress the warning do one of the following:
                - Annotate the data class with the '@ConsistentCopyVisibility' annotation.
                - Use the '-Xconsistent-data-class-copy-visibility' compiler flag.
                - Annotate the data class with the '@ExposedCopyVisibility' annotation 
                  (Discouraged, but can be used to keep binary compatibility).

                To learn more, see the documentation of the '@ConsistentCopyVisibility' and '@ExposedCopyVisibility' annotations.


            """""".trimIndent() // Two empty lines at the end to append ""This will become an error in"" message
        )
        map.put(
            DATA_CLASS_INVISIBLE_COPY_USAGE,
            ""This 'copy()' exposes the non-public primary constructor of a 'data class'. "" +
                    ""See the appropriate 'data class' documentation "" +
                    ""or contact the 'data class' author for migration guidance.""
        )
        map.put(
            DATA_CLASS_CONSISTENT_COPY_AND_EXPOSED_COPY_ARE_INCOMPATIBLE_ANNOTATIONS,
            ""'@ConsistentCopyVisibility' and '@ExposedCopyVisibility' are incompatible.""
        )
        map.put(
            DATA_CLASS_CONSISTENT_COPY_WRONG_ANNOTATION_TARGET,
            ""'@ConsistentCopyVisibility' and '@ExposedCopyVisibility' can only be applied to data classes.""
        )
        map.put(DATA_CLASS_WITHOUT_PARAMETERS, ""Data class must have at least one primary constructor parameter."")
        map.put(DATA_CLASS_VARARG_PARAMETER, ""Primary constructor vararg parameters are prohibited for data classes."")
        map.put(DATA_CLASS_NOT_PROPERTY_PARAMETER, ""Primary constructor of data class must only have property ('val' / 'var') parameters."")

        // Annotations
        map.put(ANNOTATION_USED_AS_ANNOTATION_ARGUMENT, ""Annotations cannot be used as annotation arguments."")
        map.put(ANNOTATION_ON_ANNOTATION_ARGUMENT, ""Annotations on annotation arguments are prohibited."")
        map.put(ANNOTATION_CLASS_MEMBER, ""Members are prohibited in annotation classes."")
        map.put(ANNOTATION_ARGUMENT_MUST_BE_CONST, ""Annotation argument must be a compile-time constant."")
        map.put(ANNOTATION_ARGUMENT_MUST_BE_ENUM_CONST, ""Enum annotation argument must be an enum constant."")
        map.put(ANNOTATION_ARGUMENT_MUST_BE_KCLASS_LITERAL, ""Annotation argument must be class literal (T::class)."")
        map.put(
            ANNOTATION_ARGUMENT_KCLASS_LITERAL_OF_TYPE_PARAMETER_ERROR,
            ""Type parameter in class literal is deprecated in an annotation argument.""
        )
        map.put(
            ANNOTATION_PARAMETER_DEFAULT_VALUE_MUST_BE_CONSTANT,
            ""Default value of annotation parameter must be a compile-time constant.""
        )
        map.put(LOCAL_ANNOTATION_CLASS_ERROR, ""Annotation class cannot be local."")
        map.put(MISSING_VAL_ON_ANNOTATION_PARAMETER, ""'val' keyword is missing in annotation parameter."")
        map.put(NULLABLE_TYPE_OF_ANNOTATION_MEMBER, ""Annotation parameters cannot be nullable."")
        map.put(INVALID_TYPE_OF_ANNOTATION_MEMBER, ""Invalid type of annotation member."")
        map.put(PROJECTION_IN_TYPE_OF_ANNOTATION_MEMBER, ""Projection in type of annotation member."")
        map.put(VAR_ANNOTATION_PARAMETER, ""An annotation parameter cannot be 'var'."")
        map.put(ANNOTATION_CLASS_CONSTRUCTOR_CALL, ""Annotation class cannot be instantiated."")
        map.put(ENUM_CLASS_CONSTRUCTOR_CALL, ""Enum types cannot be instantiated."")
        map.put(NOT_AN_ANNOTATION_CLASS, ""Illegal annotation class ''{0}''."", NULLABLE_STRING)
        map.put(SUPERTYPES_FOR_ANNOTATION_CLASS, ""Annotation class cannot have supertypes."")
        map.put(
            ILLEGAL_KOTLIN_VERSION_STRING_VALUE,
            ""Invalid value in version annotation (must be 'major.minor' or 'major.minor.patch').""
        )
        map.put(NEWER_VERSION_IN_SINCE_KOTLIN, ""The version is greater than the specified API version {0}."", NULLABLE_STRING)
        map.put(
            DEPRECATED_SINCE_KOTLIN_WITH_UNORDERED_VERSIONS,
            ""Version values in 'DeprecatedSinceKotlin' annotation, if specified, must be such that 'warningSince' <= 'errorSince' <= 'hiddenSince'.""
        )
        map.put(
            DEPRECATED_SINCE_KOTLIN_WITHOUT_ARGUMENTS,
            ""'DeprecatedSinceKotlin' annotation must have at least one argument.""
        )
        map.put(
            DEPRECATED_SINCE_KOTLIN_WITHOUT_DEPRECATED,
            ""'DeprecatedSinceKotlin' annotation can be used only together with a 'Deprecated' annotation.""
        )
        map.put(
            DEPRECATED_SINCE_KOTLIN_WITH_DEPRECATED_LEVEL,
            ""'DeprecatedSinceKotlin' annotation can be used only with an unspecified deprecation level in the 'Deprecated' annotation.""
        )
        map.put(
            DEPRECATED_SINCE_KOTLIN_OUTSIDE_KOTLIN_SUBPACKAGE,
            ""'DeprecatedSinceKotlin' annotation cannot be used outside 'kotlin' subpackages.""
        )
        map.put(
            KOTLIN_ACTUAL_ANNOTATION_HAS_NO_EFFECT_IN_KOTLIN,
            ""'KotlinActual' annotation has no effect in Kotlin."",
        )
        map.put(DEPRECATION_ERROR, ""''{0}'' is deprecated.{1}"", SYMBOL, OPTIONAL_SENTENCE)
        map.put(DEPRECATION, ""''{0}'' is deprecated.{1}"", SYMBOL, OPTIONAL_SENTENCE)
        map.put(
            OVERRIDE_DEPRECATION,
            ""This declaration overrides a deprecated member but is not marked as deprecated itself. Add the ''@Deprecated'' annotation or suppress the diagnostic."",
            EMPTY,
            EMPTY,
        )
        map.put(TYPEALIAS_EXPANSION_DEPRECATION_ERROR, ""''{0}'' uses ''{1}'', which is an error. {2}."", SYMBOL, SYMBOL, STRING)
        map.put(TYPEALIAS_EXPANSION_DEPRECATION, ""''{0}'' uses ''{1}'', which is deprecated. {2}."", SYMBOL, SYMBOL, STRING)
        map.put(VERSION_REQUIREMENT_DEPRECATION_ERROR, ""''{0}''{1} cannot be used in Kotlin {2}.{3}"", SYMBOL, REQUIRE_KOTLIN_VERSION, STRING, OPTIONAL_SENTENCE)
        map.put(VERSION_REQUIREMENT_DEPRECATION, ""''{0}''{1} should not be used in Kotlin {2}.{3}"", SYMBOL, REQUIRE_KOTLIN_VERSION, STRING, OPTIONAL_SENTENCE)
        map.put(REDUNDANT_ANNOTATION, ""Annotation ''{0}'' is redundant."", CLASS_ID)
        map.put(ANNOTATION_ON_SUPERCLASS_ERROR, ""Annotations on superclasses are meaningless."")
        map.put(RESTRICTED_RETENTION_FOR_EXPRESSION_ANNOTATION_ERROR, ""Expression annotations with retention other than SOURCE are prohibited."")
        map.put(
            WRONG_ANNOTATION_TARGET,
            ""This annotation is not applicable to target ''{0}''. Applicable targets: {1}"",
            TO_STRING,
            KOTLIN_TARGETS,
        )
        map.put(
            WRONG_ANNOTATION_TARGET_WARNING,
            ""Application of this annotation to target ''{0}'' will be forbidden soon. Applicable targets: {1}"",
            TO_STRING,
            KOTLIN_TARGETS,
        )
        map.put(
            WRONG_ANNOTATION_TARGET_WITH_USE_SITE_TARGET,
            ""This annotation is not applicable to target ''{0}'' and use-site target ''@{1}''. Applicable targets: {2}"",
            TO_STRING,
            TO_STRING,
            KOTLIN_TARGETS,
        )
        map.put(
            ANNOTATION_WITH_USE_SITE_TARGET_ON_EXPRESSION.warningFactory,
            ""Use-site targets in annotations on expressions will become an error in Kotlin "" +
                    ""${ANNOTATION_WITH_USE_SITE_TARGET_ON_EXPRESSION.deprecatingFeature.sinceVersion?.versionString}."",
        )
        map.put(
            ANNOTATION_WITH_USE_SITE_TARGET_ON_EXPRESSION.errorFactory,
            ""Use-site targets are forbidden in annotations on expressions."",
        )
        map.put(
            INAPPLICABLE_TARGET_ON_PROPERTY,
            ""''@{0}:'' annotations can only be applied to property declarations."",
            TO_STRING,
        )
        map.put(
            INAPPLICABLE_TARGET_ON_PROPERTY_WARNING,
            ""''@{0}:'' annotations can only be applied to property declarations. It will be an error in a future release. See https://youtrack.jetbrains.com/issue/KT-15470."",
            TO_STRING,
        )
        map.put(
            INAPPLICABLE_TARGET_PROPERTY_IMMUTABLE,
            ""''@{0}:'' annotations can only be applied to mutable properties."",
            TO_STRING,
        )
        map.put(
            INAPPLICABLE_TARGET_PROPERTY_HAS_NO_DELEGATE,
            ""'@delegate:' annotations can only be applied to delegated properties."",
        )
        map.put(
            INAPPLICABLE_TARGET_PROPERTY_HAS_NO_BACKING_FIELD,
            ""'@field:' annotations can only be applied to properties with backing fields."",
        )
        map.put(
            INAPPLICABLE_PARAM_TARGET,
            ""'@param:' annotations can only be applied to primary constructor parameters."",
        )
        map.put(
            INAPPLICABLE_FILE_TARGET,
            ""'@file:' annotations can only be applied before package declaration."",
        )
        map.put(
            INAPPLICABLE_ALL_TARGET,
            ""'@all:' annotations cannot be applied to local or delegated properties."",
        )
        map.put(
            INAPPLICABLE_ALL_TARGET_IN_MULTI_ANNOTATION,
            ""Multiple annotation syntax with '@all:' use-site target is forbidden, use '@all:A1 @all:A2 ...' instead."",
        )
        map.put(REPEATED_ANNOTATION, ""This annotation is not repeatable."")
        map.put(REPEATED_ANNOTATION_WARNING, ""This annotation is not repeatable."")
        map.put(REDUNDANT_ANNOTATION_TARGET, ""Redundant annotation target ''{0}''."", TO_STRING)
        map.put(NOT_A_CLASS, ""Not a class."")
        map.put(
            WRONG_EXTENSION_FUNCTION_TYPE,
            ""'@ExtensionFunctionType' is prohibited on a function type without parameters or on a non-function type."",
        )
        map.put(
            WRONG_EXTENSION_FUNCTION_TYPE_WARNING,
            ""'@ExtensionFunctionType' makes no sense on a non-function type. It will be an error in a future release. See https://youtrack.jetbrains.com/issue/KT-43527."",
        )
        map.put(
            ANNOTATION_IN_WHERE_CLAUSE_ERROR,
            ""Type parameter annotations are prohibited inside 'where' clauses. Consider moving the annotations to the type parameter declaration."",
        )
        map.put(
            ANNOTATION_IN_CONTRACT_ERROR,
            ""Annotations are prohibited inside contracts."",
        )
        map.put(
            AMBIGUOUS_ANNOTATION_ARGUMENT,
            ""Resolution of the annotation argument is ambiguous between the following candidates:{0}\nUse a fully qualified name as argument."",
            SYMBOLS_ON_NEXT_LINES,
        )
        map.put(VOLATILE_ON_VALUE, ""'@Volatile' annotation cannot be used on immutable properties."")
        map.put(VOLATILE_ON_DELEGATE, ""'@Volatile' annotation cannot be used on delegated properties."")
        map.put(NON_INTERNAL_PUBLISHED_API, ""'@PublishedApi' annotation is only applicable to internal declaration."")
        map.put(
            NON_SOURCE_ANNOTATION_ON_INLINED_LAMBDA_EXPRESSION,
            ""The lambda expression here is an inlined argument, so this annotation cannot be stored anywhere."",
        )
        map.put(
            POTENTIALLY_NON_REPORTED_ANNOTATION,
            ""Deprecations and opt-ins on a method overridden from 'Any' may not be reported."",
        )
        map.put(
            ANNOTATION_WILL_BE_APPLIED_ALSO_TO_PROPERTY_OR_FIELD,
            """"""
            This annotation is currently applied to the value parameter only, but in the future it will also be applied to {0}.
            - To opt in to applying to both value parameter and {0}, add ''-Xannotation-default-target=param-property'' to your compiler arguments.
            - To keep applying to the value parameter only, use the ''@param:'' annotation target.
            
            See https://youtrack.jetbrains.com/issue/KT-73255 for more details.
            """""".trimIndent(),
            TO_STRING,
        )
        map.put(
            ANNOTATIONS_ON_BLOCK_LEVEL_EXPRESSION_ON_THE_SAME_LINE,
            ""Annotations on block-level expressions are parsed differently depending on the presence of a new line. "" +
                    ""Add a new line after the annotations to annotate the entire expression.""
        )
        map.put(
            IGNORABILITY_ANNOTATIONS_WITH_CHECKER_DISABLED,
            ""Ignorability-related annotations are experimental and cannot be used with -Xreturn-value-checker in disabled state."",
        )
        map.put(
            DSL_MARKER_PROPAGATES_TO_MANY,
            """"""
            '@DslMarker' annotation propagates to more than one receiver or context parameter. This often means that none of them can be used.
            Move the '@DslMarker' annotation to the receiver or context parameter whose scope must be limited.
            """""".trimIndent(),
        )

        // OptIn
        map.put(OPT_IN_USAGE, ""{1}"", CLASS_ID, STRING)
        map.put(OPT_IN_USAGE_ERROR, ""{1}"", CLASS_ID, STRING)
        map.put(OPT_IN_TO_INHERITANCE, ""{1}"", CLASS_ID, STRING)
        map.put(OPT_IN_TO_INHERITANCE_ERROR, ""{1}"", CLASS_ID, STRING)
        map.put(OPT_IN_OVERRIDE, ""{1}"", CLASS_ID, STRING)
        map.put(OPT_IN_OVERRIDE_ERROR, ""{1}"", CLASS_ID, STRING)
        map.put(OPT_IN_CAN_ONLY_BE_USED_AS_ANNOTATION, ""This class can only be used as an annotation."")
        map.put(
            OPT_IN_MARKER_CAN_ONLY_BE_USED_AS_ANNOTATION_OR_ARGUMENT_IN_OPT_IN,
            ""This class can only be used as an annotation or as an argument to '@OptIn'.""
        )
        map.put(OPT_IN_WITHOUT_ARGUMENTS, ""'@OptIn' without any arguments has no effect."")
        map.put(
            OPT_IN_ARGUMENT_IS_NOT_MARKER,
            ""Annotation ''{0}'' is not annotated with ''@RequiresOptIn''. ''@OptIn'' has no effect."",
            CLASS_ID
        )
        map.put(
            OPT_IN_MARKER_WITH_WRONG_TARGET,
            ""Opt-in requirement marker annotation cannot be used on the following code elements: {0}."",
            STRING
        )
        map.put(
            OPT_IN_MARKER_WITH_WRONG_RETENTION,
            ""Opt-in requirement marker annotation cannot be used with SOURCE retention. Use BINARY retention instead.""
        )
        map.put(OPT_IN_MARKER_ON_WRONG_TARGET, ""Opt-in requirement marker annotation cannot be used on {0}."", STRING)
        map.put(
            OPT_IN_MARKER_ON_OVERRIDE,
            ""Opt-in requirement marker annotation on override requires the same marker on base declaration.""
        )
        map.put(
            OPT_IN_MARKER_ON_OVERRIDE_WARNING,
            ""Opt-in requirement marker annotation on override. It's recommended to add the same annotation to the base declaration.""
        )
        map.put(SUBCLASS_OPT_IN_INAPPLICABLE, ""''@SubclassOptInRequired'' is not applicable to ''{0}''."", STRING)
        map.put(
            SUBCLASS_OPT_IN_ARGUMENT_IS_NOT_MARKER,
            ""Annotation ''{0}'' is not annotated with ''@RequiresOptIn''."",
            CLASS_ID
        )

        // Exposed visibility group // #
        map.put(
            EXPOSED_TYPEALIAS_EXPANDED_TYPE,
            ""''{0}'' typealias exposes ''{3}'' in expanded type{2} ''{1}''."",
            TO_STRING,
            DECLARATION_NAME,
            TO_STRING,
            TO_STRING,
        )
        map.put(
            EXPOSED_FUNCTION_RETURN_TYPE,
            ""''{0}'' function exposes its ''{3}'' return type{2} ''{1}''."",
            TO_STRING,
            DECLARATION_NAME,
            TO_STRING,
            TO_STRING,
        )
        map.put(
            EXPOSED_RECEIVER_TYPE,
            ""''{0}'' member exposes its ''{3}'' receiver type{2} ''{1}''."",
            TO_STRING,
            DECLARATION_NAME,
            TO_STRING,
            TO_STRING,
        )
        map.put(
            EXPOSED_PROPERTY_TYPE,
            ""''{0}'' property exposes its ''{3}'' type{2} ''{1}''."",
            TO_STRING,
            DECLARATION_NAME,
            TO_STRING,
            TO_STRING,
        )
        map.put(
            EXPOSED_PROPERTY_TYPE_IN_CONSTRUCTOR_ERROR,
            ""''{0}'' property exposes its ''{3}'' type{2} ''{1}''."",
            TO_STRING,
            DECLARATION_NAME,
            TO_STRING,
            TO_STRING,
        )
        map.put(
            EXPOSED_PARAMETER_TYPE,
            ""''{0}'' function exposes its ''{3}'' parameter type{2} ''{1}''."",
            TO_STRING,
            DECLARATION_NAME,
            TO_STRING,
            TO_STRING,
        )
        map.put(
            EXPOSED_SUPER_INTERFACE,
            ""''{0}'' sub-interface exposes its ''{3}'' supertype{2} ''{1}''."",
            TO_STRING,
            DECLARATION_NAME,
            TO_STRING,
            TO_STRING,
        )
        map.put(
            EXPOSED_SUPER_CLASS,
            ""''{0}'' subclass exposes its ''{3}'' supertype{2} ''{1}''."",
            TO_STRING,
            DECLARATION_NAME,
            TO_STRING,
            TO_STRING,
        )
        map.put(
            EXPOSED_TYPE_PARAMETER_BOUND,
            ""''{0}'' generic exposes its ''{3}'' parameter bound type{2} ''{1}''."",
            TO_STRING,
            DECLARATION_NAME,
            TO_STRING,
            TO_STRING,
        )
        map.put(
            EXPOSED_TYPE_PARAMETER_BOUND_DEPRECATION_WARNING,
            ""''{0}'' generic exposes its ''{3}'' parameter bound type{2} ''{1}''. This will be prohibited in the future."",
            TO_STRING,
            DECLARATION_NAME,
            TO_STRING,
            TO_STRING,
        )
        map.put(
            EXPOSED_PACKAGE_PRIVATE_TYPE_FROM_INTERNAL_WARNING,
            ""''{0}'' declaration exposes ''{3}'' type{2} ''{1}''.""
                .toDeprecationWarningMessage(LanguageFeature.ForbidExposingPackagePrivateInInternal),
            TO_STRING,
            DECLARATION_NAME,
            TO_STRING,
            TO_STRING,
        )

        // Modifiers
        map.put(REPEATED_MODIFIER, ""Repeated ''{0}''."", TO_STRING)
        map.put(WRONG_MODIFIER_TARGET, ""Modifier ''{0}'' is not applicable to ''{1}''."", TO_STRING, STRING)
        map.put(WRONG_MODIFIER_CONTAINING_DECLARATION, ""Modifier ''{0}'' is not applicable inside ''{1}''."", TO_STRING, STRING)
        map.put(DEPRECATED_MODIFIER, ""Modifier ''{0}'' is deprecated; use ''{1}'' instead."", TO_STRING, TO_STRING)
        map.put(DEPRECATED_MODIFIER_FOR_TARGET, ""Modifier ''{0}'' is deprecated for ''{1}''."", TO_STRING, STRING)
        map.put(DEPRECATED_MODIFIER_CONTAINING_DECLARATION, ""Modifier ''{0}'' is deprecated inside ''{1}''."", TO_STRING, STRING)
        map.put(INCOMPATIBLE_MODIFIERS, ""Modifier ''{0}'' is incompatible with ''{1}''."", TO_STRING, TO_STRING)
        map.put(DEPRECATED_MODIFIER_PAIR, ""Modifier ''{0}'' is deprecated in presence of ''{1}''."", TO_STRING, TO_STRING)
        map.put(REDUNDANT_MODIFIER, ""Modifier ''{0}'' is redundant in presence of ''{1}''."", TO_STRING, TO_STRING)
        map.put(REDUNDANT_MODIFIER_FOR_TARGET, ""Modifier ''{0}'' is redundant for ''{1}''."", TO_STRING, STRING)
        map.put(INFIX_MODIFIER_REQUIRED, ""''infix'' modifier is required on ''{0}''."", SYMBOL)
        map.put(OPERATOR_MODIFIER_REQUIRED, ""''operator'' modifier is required on {0}."", SYMBOL_WITH_CONTAINING_DECLARATION)
        map.put(INAPPLICABLE_INFIX_MODIFIER, ""'infix' modifier is inapplicable to this function."")
        map.put(INAPPLICABLE_OPERATOR_MODIFIER, ""''operator'' modifier is not applicable to function: {0}."", STRING)
        map.put(
            INAPPLICABLE_OPERATOR_MODIFIER_WARNING,
            ""''operator'' modifier is not applicable to function: {0}."".toDeprecationWarningMessage(LanguageFeature.ForbidGetSetValueWithTooManyParameters),
            STRING,
        )
        map.put(INAPPLICABLE_LATEINIT_MODIFIER, ""''lateinit'' modifier {0}."", TO_STRING)
        map.put(REDUNDANT_OPEN_IN_INTERFACE, ""Modifier 'open' is redundant for abstract interface members."")
        map.put(OPERATOR_CALL_ON_CONSTRUCTOR, ""Constructor of ''{0}'' cannot be used as an operator."", STRING)
        map.put(NO_EXPLICIT_VISIBILITY_IN_API_MODE, ""Visibility must be specified in explicit API mode."")
        map.put(NO_EXPLICIT_VISIBILITY_IN_API_MODE_WARNING, ""Visibility must be specified in explicit API mode."")
        map.put(NO_EXPLICIT_RETURN_TYPE_IN_API_MODE, ""Return type must be specified in explicit API mode."")
        map.put(NO_EXPLICIT_RETURN_TYPE_IN_API_MODE_WARNING, ""Return type must be specified in explicit API mode."")
        map.put(ANONYMOUS_SUSPEND_FUNCTION, ""Anonymous suspend functions are prohibited."")

        // Classes and interfaces
        map.put(SUPERTYPE_NOT_INITIALIZED, ""This type has a constructor, so it must be initialized here."")

        // Applicability
        map.put(NONE_APPLICABLE, ""None of the following candidates is applicable:\n\n{0}"", CANDIDATES_WITH_DIAGNOSTIC_MESSAGES)
        map.put(INAPPLICABLE_CANDIDATE, ""Inapplicable candidate(s): {0}"", SYMBOL)
        map.put(HAS_NEXT_FUNCTION_NONE_APPLICABLE, ""None of the ''hasNext()'' functions is applicable for this expression. Candidates are:{0}"", SYMBOLS_ON_NEXT_LINES)
        map.put(NEXT_NONE_APPLICABLE, ""None of the ''next()'' functions is applicable for this expression. Candidates are:{0}"", SYMBOLS_ON_NEXT_LINES)
        map.put(
            DELEGATE_SPECIAL_FUNCTION_NONE_APPLICABLE,
            ""Property delegate must have a ''{0}'' method. None of the following functions is applicable:{1}"",
            TO_STRING,
            SYMBOLS_ON_NEXT_LINES,
        )
        map.put(
            TYPE_INFERENCE_ONLY_INPUT_TYPES_ERROR,
            ""Type inference failed. The value of the type parameter ''{0}'' must be mentioned in input types (argument types, receiver type, or expected type). Try to specify it explicitly."",
            SYMBOL,
        )
        map.put(
            MEMBER_PROJECTED_OUT,
            ""Receiver type ''{0}'' contains {1} projection which prohibits the use of ''{2}''."",
            RENDER_TYPE,
            STRING,
            SYMBOL,
        )
        map.put(NO_VALUE_FOR_PARAMETER, ""No value passed for parameter ''{0}''."", NAME)
        map.put(TOO_MANY_ARGUMENTS, ""Too many arguments for ''{0}''."", SYMBOL)
        map.put(NAMED_PARAMETER_NOT_FOUND, ""No parameter with name ''{0}'' found."", TO_STRING)
        map.put(NAME_FOR_AMBIGUOUS_PARAMETER, ""Named argument is prohibited for parameter with an ambiguous name."")
        map.put(ARGUMENT_PASSED_TWICE, ""Argument already passed for this parameter."")
        map.put(NAMED_ARGUMENTS_NOT_ALLOWED, ""Named arguments are prohibited for {0}."", TO_STRING)
        map.put(
            MIXING_NAMED_AND_POSITIONAL_ARGUMENTS,
            ""Mixing named and positional arguments is not allowed unless the order of the arguments matches the order of the parameters.""
        )
        map.put(VARARG_OUTSIDE_PARENTHESES, ""Passing value as a vararg is allowed only inside a parenthesized argument list."")
        map.put(NON_VARARG_SPREAD, ""The spread operator (*foo) can only be applied in a vararg position."")
        map.put(SPREAD_OF_NULLABLE, ""The spread operator (*foo) cannot be applied to an argument of nullable type."")
        map.put(UNEXPECTED_TRAILING_LAMBDA_ON_A_NEW_LINE, ""Expression is treated as a trailing lambda argument; consider separating it from the call with semicolon."")
        map.put(MANY_LAMBDA_EXPRESSION_ARGUMENTS, ""Only one lambda expression is allowed outside a parenthesized argument list."")
        map.put(
            ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_FUNCTION,
            ""Assigning single elements to varargs in named form is prohibited."",
            NOT_RENDERED,
        )
        map.put(
            ASSIGNING_SINGLE_ELEMENT_TO_VARARG_IN_NAMED_FORM_ANNOTATION,
            ""Assigning single elements to varargs in named form is prohibited."",
        )
        map.put(REDUNDANT_SPREAD_OPERATOR_IN_NAMED_FORM_IN_FUNCTION, ""Redundant spread (*) operator."")
        map.put(REDUNDANT_SPREAD_OPERATOR_IN_NAMED_FORM_IN_ANNOTATION, ""Redundant spread (*) operator."")
        map.put(
            ILLEGAL_TYPE_ARGUMENT_FOR_VARARG_PARAMETER_WARNING,
            ""''{0}'' is inferred as the vararg parameter type, which might lead to exceptions at runtime. Consider specifying the type argument explicitly."",
            RENDER_TYPE,
        )
        map.put(
            NESTED_CLASS_ACCESSED_VIA_INSTANCE_REFERENCE,
            ""Nested {0} accessed via instance reference."",
            RENDER_CLASS_OR_OBJECT_NAME_QUOTED,
        )

        // Context parameters resolution
        map.put(
            NO_CONTEXT_ARGUMENT,
            ""No context argument for ''{0}'' found."",
            SYMBOL,
        )
        map.put(
            AMBIGUOUS_CONTEXT_ARGUMENT,
            ""Multiple potential context arguments for ''{0}'' in scope."",
            SYMBOL,
        )
        map.put(
            CONTEXTUAL_OVERLOAD_SHADOWED,
            ""Contextual declaration is shadowed by the following overloads:{0}"",
            SYMBOLS_ON_NEXT_LINES,
        )
        map.put(
            MULTIPLE_CONTEXT_LISTS,
            ""Multiple context parameter lists are forbidden. Put all context parameters in one list."",
        )
        map.put(
            CONTEXT_PARAMETER_WITHOUT_NAME,
            ""Context parameters must be named. Use '_' to declare an anonymous context parameter."",
        )
        map.put(
            CONTEXT_PARAMETERS_WITH_BACKING_FIELD,
            ""Property with context parameters cannot be initialized because it has no backing field."",
        )
        map.put(
            CALLABLE_REFERENCE_TO_CONTEXTUAL_DECLARATION,
            ""Callable reference to ''{0}'' is unsupported because it has context parameters."",
            SYMBOL,
        )
        map.put(
            NAMED_CONTEXT_PARAMETER_IN_FUNCTION_TYPE,
            ""Named context parameters in function types are unsupported. Use syntax 'context(Type)' instead."",
        )
        map.put(
            CONTEXT_PARAMETER_WITH_DEFAULT,
            ""Context parameters cannot have default values."",
        )
        map.put(
            UNSUPPORTED_CONTEXTUAL_DECLARATION_CALL,
            ""To call contextual declarations, specify the '-Xcontext-parameters' compiler option."",
        )
        map.put(
            AMBIGUOUS_CALL_WITH_IMPLICIT_CONTEXT_RECEIVER,
            ""With implicit context receivers, the call is ambiguous. Specify the receiver explicitly."",
        )
        map.put(
            SUBTYPING_BETWEEN_CONTEXT_RECEIVERS,
            ""Subtyping relation between context receivers is prohibited."",
        )
        map.put(CONTEXT_RECEIVERS_DEPRECATED, ""{0}"", STRING)
        map.put(CONTEXT_CLASS_OR_CONSTRUCTOR,
            """"""
            Contextual classes and constructors are deprecated and will not be supported when context parameters are enabled. Consider migrating to regular parameters.
            
            See the context parameters proposal for more details: https://kotl.in/context-parameters
            
            """""".trimIndent().toDeprecationWarningMessage(LanguageFeature.ContextParameters),
        )

        // Mismatching types
        map.put(
            TYPE_MISMATCH,
            ""Type mismatch: inferred type is ''{1}'', but ''{0}'' was expected."",
            RENDER_TYPE,
            RENDER_TYPE,
            NOT_RENDERED,
        )
        map.put(
            ARGUMENT_TYPE_MISMATCH,
            ""Argument type mismatch: actual type is ''{0}'', but ''{1}'' was expected."",
            RENDER_TYPE,
            RENDER_TYPE,
            NOT_RENDERED,
        )
        map.put(
            RETURN_TYPE_MISMATCH,
            ""Return type mismatch: expected ''{0}'', actual ''{1}''."",
            RENDER_TYPE,
            RENDER_TYPE,
            NOT_RENDERED,
            NOT_RENDERED,
        )
        map.put(
            INITIALIZER_TYPE_MISMATCH,
            ""Initializer type mismatch: expected ''{0}'', actual ''{1}''."",
            RENDER_TYPE,
            RENDER_TYPE,
            NOT_RENDERED,
        )
        map.put(
            ASSIGNMENT_TYPE_MISMATCH,
            ""Assignment type mismatch: actual type is ''{1}'', but ''{0}'' was expected."",
            RENDER_TYPE,
            RENDER_TYPE,
            NOT_RENDERED,
        )
        map.put(
            CONDITION_TYPE_MISMATCH,
            ""Condition type mismatch: inferred type is ''{0}'' but ''Boolean'' was expected."",
            RENDER_TYPE,
            NOT_RENDERED,
        )
        map.put(
            THROWABLE_TYPE_MISMATCH,
            ""Throwable type mismatch: actual type is ''{0}''."",
            RENDER_TYPE,
            NOT_RENDERED,
        )
        map.put(
            RESULT_TYPE_MISMATCH,
            ""Function return type mismatch: actual type is ''{1}'', but ''{0}'' was expected."",
            RENDER_TYPE,
            RENDER_TYPE,
        )
        map.put(
            COMPARE_TO_TYPE_MISMATCH,
            ""''compareTo()'' must return ''Int'', but returns ''{0}''."",
            RENDER_TYPE,
        )
        map.put(
            HAS_NEXT_FUNCTION_TYPE_MISMATCH,
            ""The ''iterator().hasNext()'' function of the loop range must return ''Boolean'', but returns ''{0}''."",
            RENDER_TYPE,
        )
        map.put(
            COMPONENT_FUNCTION_RETURN_TYPE_MISMATCH,
            ""Operator call ''{0}()'' returns ''{1}'', but ''{2}'' is expected."",
            TO_STRING,
            RENDER_TYPE,
            RENDER_TYPE,
        )
        map.put(
            DELEGATE_SPECIAL_FUNCTION_RETURN_TYPE_MISMATCH,
            ""Function ''{0}'' of property delegate is expected to return ''{1}'', but returns ''{2}''."",
            TO_STRING,
            RENDER_TYPE,
            RENDER_TYPE,
        )

        // Ambiguity
        map.put(
            OVERLOAD_RESOLUTION_AMBIGUITY,
            ""Overload resolution ambiguity between candidates:{0}"",
            SYMBOLS_ON_NEXT_LINES,
        )
        map.put(
            ASSIGN_OPERATOR_AMBIGUITY,
            ""Ambiguity between assign operator candidates:{0}"",
            SYMBOLS_ON_NEXT_LINES,
        )
        map.put(
            ITERATOR_AMBIGUITY,
            ""Method ''iterator()'' is ambiguous for this expression. Applicable candidates:{0}"",
            SYMBOLS_ON_NEXT_LINES,
        )
        map.put(
            HAS_NEXT_FUNCTION_AMBIGUITY,
            ""Method ''hasNext()'' is ambiguous for this expression. Applicable candidates:{0}"",
            SYMBOLS_ON_NEXT_LINES,
        )
        map.put(
            NEXT_AMBIGUITY,
            ""Method ''next()'' is ambiguous for this expression. Applicable candidates:{0}"",
            SYMBOLS_ON_NEXT_LINES,
        )
        map.put(
            COMPONENT_FUNCTION_AMBIGUITY,
            ""Operator call ''{0}()'' is ambiguous for destructuring of type ''{2}''. Applicable candidates:{1}"",
            TO_STRING,
            SYMBOLS_ON_NEXT_LINES,
            RENDER_TYPE,
        )
        map.put(
            DELEGATE_SPECIAL_FUNCTION_AMBIGUITY,
            ""Overload resolution ambiguity on method ''{0}'':{1}"",
            TO_STRING,
            SYMBOLS_ON_NEXT_LINES,
        )
        map.put(
            COMPILER_REQUIRED_ANNOTATION_AMBIGUITY,
            ""Resolution of the annotation type is ambiguous between ''{1}'' and the compiler-required annotation ''{0}''. Specify a fully qualified annotation name."",
            RENDER_TYPE,
            RENDER_TYPE,
        )
        map.put(
            AMBIGUOUS_FUNCTION_TYPE_KIND,
            ""Multiple function type conversions are prohibited for a single type. Detected type conversions: {0}"",
            FUNCTIONAL_TYPE_KINDS,
        )

        // Types & type parameters
        map.put(RECURSION_IN_IMPLICIT_TYPES, ""Recursion in implicit types."")
        map.put(INFERENCE_ERROR, ""Inference error."")
        map.put(ILLEGAL_PROJECTION_USAGE, ""Illegal projection usage."")
        map.put(PROJECTION_ON_NON_CLASS_TYPE_ARGUMENT, ""Projections are not allowed on type arguments of functions calls."")
        map.put(
            UPPER_BOUND_VIOLATED,
            ""Type argument is not within its bounds: must be subtype of ''{0}''.{2}"",
            RENDER_TYPE,
            RENDER_TYPE,
            OPTIONAL_SENTENCE,
        )
        map.put(
            UPPER_BOUND_VIOLATED_DEPRECATION_WARNING,
            ""Type argument is not within its bounds: must be subtype of ''{0}''. This will become an error in future releases.{2}"",
            RENDER_TYPE,
            RENDER_TYPE,
            OPTIONAL_SENTENCE,
        )
        map.put(
            UPPER_BOUND_VIOLATED_IN_TYPE_OPERATOR_OR_PARAMETER_BOUNDS,
            ""Type argument is not within its bounds: must be subtype of ''{0}''.{2}"",
            RENDER_TYPE,
            RENDER_TYPE,
            OPTIONAL_SENTENCE,
        )
        map.put(
            UPPER_BOUND_VIOLATED_IN_TYPEALIAS_EXPANSION,
            ""Type argument is not within its bounds: must be subtype of ''{0}''."",
            RENDER_TYPE,
            RENDER_TYPE,
        )
        map.put(
            UPPER_BOUND_VIOLATED_IN_TYPEALIAS_EXPANSION_DEPRECATION_WARNING,
            ""Type argument is not within its bounds: must be subtype of ''{0}''. This will become an error in future releases."",
            RENDER_TYPE,
            RENDER_TYPE,
        )
        map.put(TYPE_ARGUMENTS_NOT_ALLOWED, ""Type arguments are not allowed {0}."", STRING)
        map.put(TYPE_ARGUMENTS_FOR_OUTER_CLASS_WHEN_NESTED_REFERENCED, ""Type arguments for outer class are redundant when nested class is referenced."")
        val wrongNumberOfTypeArguments = ""{0,choice,0#No type arguments|1#One type argument|1<{0,number,integer} type arguments} expected""
        map.put(
            WRONG_NUMBER_OF_TYPE_ARGUMENTS,
            ""$wrongNumberOfTypeArguments for {1}."",
            null,
            SYMBOL,
        )
        map.put(
            NO_TYPE_ARGUMENTS_ON_RHS,
            ""$wrongNumberOfTypeArguments. Use {1} if you do not intend to pass type arguments."",
            null,
            RENDER_CLASS_OR_OBJECT_NAME_QUOTED,
        )
        map.put(
            OUTER_CLASS_ARGUMENTS_REQUIRED,
            ""Type arguments must be specified for outer {0}. Use the full class name to specify them."",
            RENDER_CLASS_OR_OBJECT_NAME_QUOTED,
        )
        map.put(TYPE_PARAMETERS_IN_OBJECT, ""Type parameters are prohibited for objects."")
        map.put(TYPE_PARAMETERS_IN_ANONYMOUS_OBJECT, ""Type parameters for anonymous objects are deprecated."")
//            map.put(ILLEGAL_PROJECTION_USAGE, ...) // &
        map.put(TYPE_PARAMETERS_IN_ENUM, ""Enum class cannot have type parameters."")
        map.put(
            CONFLICTING_PROJECTION,
            ""Projection is conflicting with variance of the corresponding type parameter of ''{0}''. Remove the projection or replace it with ''*''."",
            RENDER_TYPE,
        )
        map.put(
            CONFLICTING_PROJECTION_IN_TYPEALIAS_EXPANSION,
            ""Conflicting projection in type alias expansion in intermediate type ''{0}''."",
            RENDER_TYPE,
        )
        map.put(
            REDUNDANT_PROJECTION,
            ""Projection is redundant: the corresponding type parameter of ''{0}'' has the same variance."",
            RENDER_TYPE,
        )
        map.put(
            VARIANCE_ON_TYPE_PARAMETER_NOT_ALLOWED,
            ""Variance annotations are only allowed for type parameters of classes and interfaces."",
        )
        map.put(CATCH_PARAMETER_WITH_DEFAULT_VALUE, ""Catch clause parameter cannot have a default value."")
        map.put(TYPE_PARAMETER_IN_CATCH_CLAUSE, ""Non-reified type parameters cannot be used by catch parameters."")
        map.put(
            KCLASS_WITH_NULLABLE_TYPE_PARAMETER_IN_SIGNATURE,
            ""Declaration has an inconsistent return type. Add upper bound ''Any'' for type parameter ''{0}'' or specify return type explicitly."",
            SYMBOL,
        )
        map.put(TYPE_PARAMETER_AS_REIFIED, ""Cannot use ''{0}'' as reified type parameter. Use a class instead."", SYMBOL)
        map.put(
            TYPE_PARAMETER_AS_REIFIED_ARRAY_ERROR,
            ""Cannot use ''{0}'' as reified type parameter, since the array type parameter is not reified."",
            SYMBOL,
        )
        map.put(
            REIFIED_TYPE_FORBIDDEN_SUBSTITUTION,
            ""Cannot use ''{0}'' as reified type parameter."",
            RENDER_TYPE,
        )
        map.put(
            DEFINITELY_NON_NULLABLE_AS_REIFIED,
            ""Cannot use definitely-non-nullable type as a reified type argument."",
        )
        map.put(
            TYPE_INTERSECTION_AS_REIFIED,
            ""Type argument for reified type parameter ''{0}'' was inferred to the intersection of {1}. "" +
                    ""Reification of an intersection type results in the common supertype being used. "" +
                    ""This may lead to subtle issues and an explicit type argument is encouraged."",
            SYMBOL,
            RENDER_TYPE.joinToString(prefix = ""['"", postfix = ""']"", separator = ""' & '""),
        )
        map.put(
            FINAL_UPPER_BOUND,
            ""Type ''{0}'' is final, so the value of the type parameter is predetermined."",
            RENDER_TYPE,
        )
        map.put(
            UPPER_BOUND_IS_EXTENSION_OR_CONTEXT_FUNCTION_TYPE,
            ""Extension or contextual function type cannot be used as an upper bound."",
        )
        map.put(
            BOUNDS_NOT_ALLOWED_IF_BOUNDED_BY_TYPE_PARAMETER,
            ""Type parameter cannot have any other bounds if it's bounded by another type parameter."",
        )
        map.put(ONLY_ONE_CLASS_BOUND_ALLOWED, ""Only one of the upper bounds can be a class."")
        map.put(REPEATED_BOUND, ""Type parameter already has this bound."")
        map.put(
            CONFLICTING_UPPER_BOUNDS,
            ""Upper bounds of ''{0}'' have an empty intersection."",
            SYMBOL,
        )
        map.put(
            NAME_IN_CONSTRAINT_IS_NOT_A_TYPE_PARAMETER,
            ""''{0}'' does not refer to a type parameter of ''{1}''."",
            TO_STRING,
            DECLARATION_NAME,
        )
        map.put(BOUND_ON_TYPE_ALIAS_PARAMETER_NOT_ALLOWED, ""Bounds on type alias parameters are prohibited."")
        map.put(REIFIED_TYPE_PARAMETER_NO_INLINE, ""Only type parameters of inline functions can be reified."")
        map.put(REIFIED_TYPE_PARAMETER_ON_ALIAS, ""Applying reified modifier to a type parameter of a type alias makes no sense."")
        map.put(TYPE_PARAMETERS_NOT_ALLOWED, ""Type parameters are prohibited here."")
        map.put(INCORRECT_TYPE_PARAMETER_OF_PROPERTY, ""Type parameter of a property must be used in its receiver type or context parameters."")
        map.put(IMPLICIT_NOTHING_RETURN_TYPE, ""Return type 'Nothing' needs to be specified explicitly."")
        map.put(IMPLICIT_NOTHING_PROPERTY_TYPE, ""Property type 'Nothing' needs to be specified explicitly."")
        map.put(ABBREVIATED_NOTHING_RETURN_TYPE, ""'Nothing' return type cannot be specified with type alias."")
        map.put(ABBREVIATED_NOTHING_PROPERTY_TYPE, ""'Nothing' property type cannot be specified with type alias."")
        map.put(CYCLIC_GENERIC_UPPER_BOUND, ""Type parameter has cyclic upper bounds: {0}."", commaSeparated(SYMBOL))
        map.put(FINITE_BOUNDS_VIOLATION, ""This type parameter violates the Finite Bound Restriction."")
        map.put(
            FINITE_BOUNDS_VIOLATION_IN_JAVA,
            ""Violation of Finite Bound Restriction for {0}."",
            commaSeparated(DECLARATION_NAME),
        )
        map.put(EXPANSIVE_INHERITANCE, ""This type parameter violates the Non-Expansive Inheritance Restriction."")
        map.put(
            EXPANSIVE_INHERITANCE_IN_JAVA,
            ""Violation of Non-Expansive Inheritance Restriction for {0}."",
            commaSeparated(DECLARATION_NAME),
        )
        map.put(DEPRECATED_TYPE_PARAMETER_SYNTAX, ""Type parameters must be placed before function name."")
        map.put(
            MISPLACED_TYPE_PARAMETER_CONSTRAINTS,
            ""If a type parameter has multiple constraints, they all need to be placed in the 'where' clause."",
        )
        map.put(DYNAMIC_SUPERTYPE, ""Supertypes cannot be dynamic."")
        map.put(DYNAMIC_UPPER_BOUND, ""Dynamic type cannot be used as an upper bound."")
        map.put(DYNAMIC_RECEIVER_NOT_ALLOWED, ""Dynamic receivers are prohibited."")
        map.put(
            DYNAMIC_RECEIVER_EXPECTED_BUT_WAS_NON_DYNAMIC,
            ""Calling functions expecting the ''dynamic'' receiver over a non-''dynamic'' one such as ''{0}'' is prohibited."",
            RENDER_TYPE,
        )
        map.put(INCOMPATIBLE_TYPES, ""Incompatible types ''{0}'' and ''{1}''."", RENDER_TYPE, RENDER_TYPE)
        map.put(INCOMPATIBLE_TYPES_WARNING, ""Potentially incompatible types ''{0}'' and ''{1}''."", RENDER_TYPE, RENDER_TYPE)
        map.put(
            TYPE_VARIANCE_CONFLICT_ERROR,
            ""Type parameter ''{0}'' is declared as ''{1}'' but occurs in ''{2}'' position in type ''{3}''."",
            SYMBOL,
            RENDER_POSITION_VARIANCE,
            RENDER_POSITION_VARIANCE,
            RENDER_TYPE,
        )
        map.put(
            TYPE_VARIANCE_CONFLICT_IN_EXPANDED_TYPE,
            ""Type parameter ''{0}'' is declared as ''{1}'' but occurs in ''{2}'' position in abbreviated type ''{3}''."",
            SYMBOL,
            RENDER_POSITION_VARIANCE,
            RENDER_POSITION_VARIANCE,
            RENDER_TYPE,
        )
        map.put(
            SMARTCAST_IMPOSSIBLE,
            ""Smart cast to ''{0}'' is impossible, because ''{1}'' is a {2}."",
            RENDER_TYPE,
            CALLEE_NAME,
            TO_STRING,
            NOT_RENDERED,
        )
        map.put(
            SMARTCAST_IMPOSSIBLE_ON_IMPLICIT_INVOKE_RECEIVER,
            ""Smart cast to ''{0}'' is impossible, because ''{1}'' is a {2}. Use explicit ''?.invoke'' to make a function-like call instead."",
            RENDER_TYPE,
            CALLEE_NAME,
            TO_STRING,
            NOT_RENDERED,
        )
        map.put(
            DEPRECATED_SMARTCAST_ON_DELEGATED_PROPERTY,
            ""Smart cast to ''{0}'' is impossible, because ''{1}'' is a property inherited by class delegation.""
                .toDeprecationWarningMessage(LanguageFeature.UnstableSmartcastOnDelegatedProperties),
            RENDER_TYPE,
            DECLARATION_NAME,
        )
        map.put(
            PLATFORM_CLASS_MAPPED_TO_KOTLIN,
            ""This class is not recommended for use in Kotlin. Use ''{0}'' instead."",
            CLASS_ID,
        )
        map.put(
            INFERRED_TYPE_VARIABLE_INTO_EMPTY_INTERSECTION,
            ""Type argument for type parameter ''{0}'' cannot be inferred because it has incompatible upper bounds: {1} ({2}{3})."",
            TO_STRING,
            RENDER_COLLECTION_OF_TYPES,
            TO_STRING,
            TO_STRING,
        )
        map.put(
            INFERRED_TYPE_VARIABLE_INTO_POSSIBLE_EMPTY_INTERSECTION,
            ""Type argument for type parameter ''{0}'' has possible incompatible upper bounds: {1} ({2}{3})."",
            TO_STRING,
            RENDER_COLLECTION_OF_TYPES,
            TO_STRING,
            TO_STRING,
        )
        map.put(
            INCORRECT_LEFT_COMPONENT_OF_INTERSECTION,
            ""Intersection types are supported only for definitely non-nullable types: left part must be a type parameter with nullable bounds."",
        )
        map.put(
            INCORRECT_RIGHT_COMPONENT_OF_INTERSECTION,
            ""Intersection types are supported only for definitely non-nullable types: right part must be non-nullable 'Any'."",
        )
        map.put(
            NULLABLE_ON_DEFINITELY_NOT_NULLABLE,
            ""'!!' type cannot be marked as nullable."",
        )
        map.put(
            REDUNDANT_NULLABLE,
            ""Redundant '?'."",
        )
        map.put(
            INFERRED_INVISIBLE_REIFIED_TYPE_ARGUMENT,
            ""Type argument for reified type parameter ''{0}'' is inferred as invisible in this scope type ''{1}''."",
            SYMBOL,
            RENDER_TYPE,
        )
        map.put(
            INFERRED_INVISIBLE_VARARG_TYPE_ARGUMENT,
            ""Type argument for type parameter ''{0}'' used as type of vararg parameter ''{2}'' is inferred as invisible in this scope type ''{1}''."",
            SYMBOL,
            RENDER_TYPE,
            DECLARATION_NAME,
        )
        map.put(
            INFERRED_INVISIBLE_RETURN_TYPE,
            ""Inferred return type ''{1}'' for ''{0}'' is not visible in this scope."",
            DECLARATION_NAME,
            RENDER_TYPE,
        )
        map.put(
            GENERIC_QUALIFIER_ON_CONSTRUCTOR_CALL,
            ""Usage of a qualifier with type arguments to call nested class constructor is deprecated. The type arguments must be removed."",
        )
        map.put(
            ATOMIC_REF_WITHOUT_CONSISTENT_IDENTITY,
            ""This call may have inconsistent results because ''{0}'' uses identity equality and ''{1}'' does not have a consistent identity.{2}"",
            CLASS_ID_RELATIVE_NAME_ONLY,
            RENDER_TYPE,
            suggestIfNotNull("" Consider using ''{0}'' instead."", CLASS_ID_RELATIVE_NAME_ONLY),
        )

        // Reflection
        map.put(
            EXTENSION_IN_CLASS_REFERENCE_NOT_ALLOWED,
            ""''{0}'' is a member and an extension at the same time. References to such elements are prohibited."",
            DECLARATION_NAME
        )
        map.put(CALLABLE_REFERENCE_LHS_NOT_A_CLASS, ""Left-hand side of callable reference cannot be a type parameter."")
        map.put(CALLABLE_REFERENCE_TO_ANNOTATION_CONSTRUCTOR, ""Annotation class cannot be instantiated."")
        map.put(
            ADAPTED_CALLABLE_REFERENCE_AGAINST_REFLECTION_TYPE,
            ""Adapted callable reference cannot be resolved against reflective types.""
        )

        map.put(CLASS_LITERAL_LHS_NOT_A_CLASS, ""Only classes are allowed on the left-hand side of a class literal."")
        map.put(NULLABLE_TYPE_IN_CLASS_LITERAL_LHS, ""Type in a class literal cannot be nullable."")
        map.put(
            EXPRESSION_OF_NULLABLE_TYPE_IN_CLASS_LITERAL_LHS,
            ""Expression in class literal has nullable type ''{0}''. Use ''!!'' to make the type non-nullable."",
            RENDER_TYPE
        )
        map.put(UNSUPPORTED_CLASS_LITERALS_WITH_EMPTY_LHS, ""Class literals with empty left hand side are unsupported."")
        map.put(MUTABLE_PROPERTY_WITH_CAPTURED_TYPE, ""Captured type in mutable property reference. Usages of 'set' may lead to cast exceptions."")

        // Value classes
        map.put(VALUE_CLASS_NOT_TOP_LEVEL, ""Value class cannot be local or inner."")
        map.put(VALUE_CLASS_NOT_FINAL, ""Value class can be only final."")
        map.put(ABSENCE_OF_PRIMARY_CONSTRUCTOR_FOR_VALUE_CLASS, ""Primary constructor is required for value classes."")
        map.put(INLINE_CLASS_CONSTRUCTOR_WRONG_PARAMETERS_SIZE, ""Inline class must have exactly one primary constructor parameter."")
        map.put(VALUE_CLASS_EMPTY_CONSTRUCTOR, ""Value class must have at least one primary constructor parameter."")
        map.put(
            VALUE_CLASS_CONSTRUCTOR_NOT_FINAL_READ_ONLY_PARAMETER,
            ""Value class primary constructor must only have final read-only ('val') property parameters.""
        )
        map.put(PROPERTY_WITH_BACKING_FIELD_INSIDE_VALUE_CLASS, ""Value class cannot have properties with backing fields."")
        map.put(DELEGATED_PROPERTY_INSIDE_VALUE_CLASS, ""Value class cannot have delegated properties."")
        map.put(VALUE_CLASS_HAS_INAPPLICABLE_PARAMETER_TYPE, ""Value class cannot have value parameter of type ''{0}''."", TO_STRING)
        map.put(VALUE_CLASS_CANNOT_IMPLEMENT_INTERFACE_BY_DELEGATION, ""Value class cannot implement an interface by delegation."")
        map.put(VALUE_CLASS_CANNOT_EXTEND_CLASSES, ""Value class cannot extend classes."")
        map.put(VALUE_CLASS_CANNOT_BE_RECURSIVE, ""Value class cannot be recursive."")
        map.put(
            MULTI_FIELD_VALUE_CLASS_PRIMARY_CONSTRUCTOR_DEFAULT_PARAMETER,
            ""Default parameters are not supported in the primary constructor of a multi-field value class.""
        )
        map.put(
            INVALID_DEFAULT_FUNCTIONAL_PARAMETER_FOR_INLINE,
            ""Invalid default value for inline function parameter. Only lambdas, anonymous functions, and callable references are supported."",
            DECLARATION_NAME
        )
        map.put(
            NOT_SUPPORTED_INLINE_PARAMETER_IN_INLINE_PARAMETER_DEFAULT_VALUE,
            ""Usage of inline parameter ''{0}'' in default value of inline parameter is not supported."",
            DECLARATION_NAME
        )
        map.put(
            SECONDARY_CONSTRUCTOR_WITH_BODY_INSIDE_VALUE_CLASS,
            ""Secondary constructors with bodies are reserved for future releases.""
        )
        map.put(RESERVED_MEMBER_INSIDE_VALUE_CLASS, ""Member name ''{0}'' is reserved for future releases."", TO_STRING)
        map.put(
            RESERVED_MEMBER_FROM_INTERFACE_INSIDE_VALUE_CLASS,
            ""Member name ''{1}'' is reserved for future releases but is implemented in supertype ''{0}''."",
            TO_STRING,
            TO_STRING,
        )
        map.put(TYPE_ARGUMENT_ON_TYPED_VALUE_CLASS_EQUALS, ""Type arguments for typed value class equals must all be star projections."")
        map.put(INNER_CLASS_INSIDE_VALUE_CLASS, ""Value class cannot have inner classes."")
        map.put(VALUE_CLASS_CANNOT_BE_CLONEABLE, ""Value class cannot be 'Cloneable'."")
        map.put(VALUE_CLASS_CANNOT_HAVE_CONTEXT_RECEIVERS, ""Value classes cannot have context receivers."")
        map.put(
            ANNOTATION_ON_ILLEGAL_MULTI_FIELD_VALUE_CLASS_TYPED_TARGET,
            ""Annotations on {0} of multi-field value class type are not supported."",
            STRING
        )


        // Inline
        map.put(
            DECLARATION_CANT_BE_INLINED,
            ""'inline' modifier on virtual members is prohibited. Only private or final members can be inlined.""
        )
        map.put(
            DECLARATION_CANT_BE_INLINED_DEPRECATION,
            ""'inline' modifier on virtual members is prohibited. Only private or final members can be inlined.""
        )
        map.put(OVERRIDE_BY_INLINE, ""Override by an inline function."")
        map.put(REIFIED_TYPE_PARAMETER_IN_OVERRIDE, ""Override by a function with reified type parameter."")
        map.put(INLINE_PROPERTY_WITH_BACKING_FIELD, ""Inline property cannot have a backing field."")
        map.put(INLINE_PROPERTY_WITH_BACKING_FIELD_DEPRECATION, ""Inline property cannot have a backing field."")

        // Overrides
        map.put(
            NOTHING_TO_OVERRIDE,
            ""''{0}'' overrides nothing.{1}"",
            DECLARATION_NAME,
            Renderer { symbols: List<FirCallableSymbol<*>> ->
                if (symbols.isEmpty()) return@Renderer """"
                "" Potential signatures for overriding:"" + SYMBOLS_ON_NEXT_LINES.render(symbols)
            })

        map.put(
            CANNOT_OVERRIDE_INVISIBLE_MEMBER,
            ""{0} has no access to {1}, so it cannot override it."",
            SYMBOL_WITH_CONTAINING_DECLARATION,
            SYMBOL_WITH_CONTAINING_DECLARATION
        )

        val multipleDefaultsMessage = ""More than one function overridden by ''{0}'' declares a default value for ''{1}'': {2}""
        val multipleDefaultsNotAllowed = ""As the compiler can not make sure these values agree, this is not allowed.""
        map.put(
            MULTIPLE_DEFAULTS_INHERITED_FROM_SUPERTYPES,
            multipleDefaultsMessage + multipleDefaultsNotAllowed,
            NAME,
            SYMBOL,
            CALLABLES_FQ_NAMES,
        )
        map.put(
            MULTIPLE_DEFAULTS_INHERITED_FROM_SUPERTYPES_WHEN_NO_EXPLICIT_OVERRIDE,
            multipleDefaultsMessage + multipleDefaultsNotAllowed,
            NAME,
            SYMBOL,
            CALLABLES_FQ_NAMES,
        )
        val multipleDefaultsDiscouraged = ""As the compiler can not make sure these values agree, this will be prohibited in the future."" +
                "" See: https://youtrack.jetbrains.com/issue/KT-36188""
        map.put(
            MULTIPLE_DEFAULTS_INHERITED_FROM_SUPERTYPES_DEPRECATION,
            multipleDefaultsMessage + multipleDefaultsDiscouraged,
            NAME,
            SYMBOL,
            CALLABLES_FQ_NAMES,
        )
        map.put(
            MULTIPLE_DEFAULTS_INHERITED_FROM_SUPERTYPES_WHEN_NO_EXPLICIT_OVERRIDE_DEPRECATION,
            multipleDefaultsMessage + multipleDefaultsDiscouraged,
            NAME,
            SYMBOL,
            CALLABLES_FQ_NAMES,
        )

        map.put(TYPEALIAS_EXPANDS_TO_ARRAY_OF_NOTHINGS, ""Type alias expanded to malformed type ''{0}''."", RENDER_TYPE)

        map.put(OVERRIDING_FINAL_MEMBER, ""''{0}'' in ''{1}'' is final and cannot be overridden."", DECLARATION_NAME, TO_STRING)

        map.put(
            CANNOT_WEAKEN_ACCESS_PRIVILEGE,
            ""Cannot weaken access privilege {0} for ''{1}'' in ''{2}''."",
            VISIBILITY,
            DECLARATION_NAME,
            TO_STRING
        )
        map.put(
            CANNOT_WEAKEN_ACCESS_PRIVILEGE_WARNING,
            ""Cannot weaken access privilege {0} for ''{1}'' in ''{2}''. This will be prohibited in the future."",
            VISIBILITY,
            DECLARATION_NAME,
            TO_STRING
        )
        map.put(
            CANNOT_CHANGE_ACCESS_PRIVILEGE,
            ""Cannot change access privilege {0} for ''{1}'' in ''{2}''."",
            VISIBILITY,
            DECLARATION_NAME,
            TO_STRING
        )
        map.put(
            CANNOT_CHANGE_ACCESS_PRIVILEGE_WARNING,
            ""Cannot change access privilege {0} for ''{1}'' in ''{2}''. This will be prohibited in the future."",
            VISIBILITY,
            DECLARATION_NAME,
            TO_STRING
        )
        map.put(
            CANNOT_INFER_VISIBILITY,
            ""Cannot infer visibility for ''{0}''. Specify it explicitly."",
            DECLARATION_NAME,
        )
        map.put(
            CANNOT_INFER_VISIBILITY_WARNING,
            ""Cannot infer visibility for ''{0}''. Specify it explicitly. This will be prohibited in the future."",
            DECLARATION_NAME,
        )

        map.put(
            ABSTRACT_MEMBER_NOT_IMPLEMENTED,
            ""{0} is not abstract and does not implement abstract {1}"",
            RENDER_CLASS_OR_OBJECT_QUOTED,
            prefix(singular = ""member:"", plural = ""members:"", SYMBOLS_ON_NEXT_LINES),
        )
        map.put(
            ABSTRACT_MEMBER_INCORRECTLY_DELEGATED,
            ""{0} is not abstract and implements abstract {1} by delegation to itself."",
            RENDER_CLASS_OR_OBJECT_QUOTED,
            prefix(singular = ""member:"", plural = ""members:"", SYMBOLS_ON_NEXT_LINES),
        )
        map.put(
            ABSTRACT_MEMBER_NOT_IMPLEMENTED_BY_ENUM_ENTRY,
            ""{0} does not implement abstract {1}"",
            RENDER_ENUM_ENTRY_QUOTED,
            prefix(singular = ""member:"", plural = ""members:"", SYMBOLS_ON_NEXT_LINES),
        )
        map.put(
            ABSTRACT_CLASS_MEMBER_NOT_IMPLEMENTED,
            ""{0} is not abstract and does not implement abstract base class {1}"",
            RENDER_CLASS_OR_OBJECT_QUOTED,
            prefix(singular = ""member:"", plural = ""members:"", SYMBOLS_ON_NEXT_LINES),
        )
        map.put(
            INVISIBLE_ABSTRACT_MEMBER_FROM_SUPER_ERROR,
            ""''{0}'' inherits invisible abstract {1}"",
            DECLARATION_NAME,
            prefix(singular = ""member:"", plural = ""members:"", SYMBOLS_ON_NEXT_LINES),
        )
        map.put(AMBIGUOUS_ANONYMOUS_TYPE_INFERRED, ""Right-hand side has an anonymous type. Specify the type explicitly."", NOT_RENDERED)
        map.put(
            MANY_IMPL_MEMBER_NOT_IMPLEMENTED,
            ""{0} must override ''{1}'' because it inherits multiple implementations for it."",
            RENDER_CLASS_OR_OBJECT_QUOTED,
            DECLARATION_NAME
        )
        map.put(
            MANY_INTERFACES_MEMBER_NOT_IMPLEMENTED,
            ""{0} must override ''{1}'' because it inherits multiple interface methods for it."",
            RENDER_CLASS_OR_OBJECT_QUOTED,
            DECLARATION_NAME
        )

        map.put(
            VAR_OVERRIDDEN_BY_VAL,
            ""''var'' property {0} cannot be overridden by ''val'' property ''{1}''."",
            SYMBOL_WITH_CONTAINING_DECLARATION,
            SYMBOL
        )
        map.put(
            VAR_IMPLEMENTED_BY_INHERITED_VAL,
            ""{0} overrides ''var'' property {1} with inherited ''val'' property {2}."",
            RENDER_CLASS_OR_OBJECT_QUOTED,
            SYMBOL_WITH_CONTAINING_DECLARATION,
            SYMBOL_WITH_CONTAINING_DECLARATION
        )
        map.put(NON_FINAL_MEMBER_IN_FINAL_CLASS, ""'open' has no effect on a final class."")
        map.put(NON_FINAL_MEMBER_IN_OBJECT, ""'open' has no effect on object."")
        map.put(
            VIRTUAL_MEMBER_HIDDEN, ""''{0}'' hides member of supertype ''{1}'' and needs an ''override'' modifier."", DECLARATION_NAME,
            DECLARATION_NAME
        )
        map.put(
            PARAMETER_NAME_CHANGED_ON_OVERRIDE,
            ""The corresponding parameter in the supertype ''{0}'' is named ''{1}''. "" +
                    ""This may cause problems when calling this function with named arguments."",
            DECLARATION_NAME,
            VARIABLE_NAME,
        )
        map.put(
            DIFFERENT_NAMES_FOR_THE_SAME_PARAMETER_IN_SUPERTYPES,
            ""Names ''{0}'' and ''{1}'' of parameter #{2} conflict in the following members of supertypes: {3}. "" +
                    ""This may cause problems when calling this function with named arguments."",
            DECLARATION_NAME,
            DECLARATION_NAME,
            TO_STRING,
            commaSeparated(SYMBOL_WITH_CONTAINING_DECLARATION),
        )
        map.put(
            SUSPEND_OVERRIDDEN_BY_NON_SUSPEND,
            ""Non-suspend function ''{0}'' cannot override suspend function {1}."",
            DECLARATION_NAME,
            SYMBOL_WITH_CONTAINING_DECLARATION,
        )
        map.put(
            NON_SUSPEND_OVERRIDDEN_BY_SUSPEND,
            ""Suspend function ''{0}'' cannot override non-suspend function {1}."",
            DECLARATION_NAME,
            SYMBOL_WITH_CONTAINING_DECLARATION,
        )
        map.put(
            DATA_CLASS_OVERRIDE_CONFLICT,
            ""Function ''{0}'' generated for the data class conflicts with the supertype member {1}."",
            SYMBOL,
            SYMBOL_WITH_CONTAINING_DECLARATION
        )
        map.put(
            DATA_CLASS_OVERRIDE_DEFAULT_VALUES,
            ""Generated function ''{0}'' of the data class has default values for parameters which conflicts with the overriden member of supertype ''{1}''."",
            DECLARATION_NAME,
            DECLARATION_NAME
        )

        map.put(
            GENERIC_THROWABLE_SUBCLASS,
            ""Subclass of 'Throwable' cannot have type parameters.""
        )
        map.put(
            INNER_CLASS_OF_GENERIC_THROWABLE_SUBCLASS,
            ""Inner class of generic class extending 'Throwable' is prohibited.""
        )

        map.put(
            RETURN_TYPE_MISMATCH_ON_OVERRIDE,
            ""Return type of ''{0}'' is not a subtype of the return type of the overridden member {1}."",
            DECLARATION_NAME,
            SYMBOL_WITH_CONTAINING_DECLARATION,
        )
        map.put(
            PROPERTY_TYPE_MISMATCH_ON_OVERRIDE,
            ""Type of ''{0}'' is not a subtype of overridden property {1}."",
            DECLARATION_NAME,
            SYMBOL_WITH_CONTAINING_DECLARATION,
        )
        map.put(
            VAR_TYPE_MISMATCH_ON_OVERRIDE,
            ""Type of ''{0}'' doesn''t match the type of the overridden ''var'' property {1}."",
            DECLARATION_NAME,
            SYMBOL_WITH_CONTAINING_DECLARATION,
        )

        map.put(
            RETURN_TYPE_MISMATCH_ON_INHERITANCE,
            ""{0} clashes with {1}: return types are incompatible."",
            SYMBOL_WITH_CONTAINING_DECLARATION,
            SYMBOL_WITH_CONTAINING_DECLARATION,
        )
        map.put(
            PROPERTY_TYPE_MISMATCH_ON_INHERITANCE,
            ""{0} clashes with {1}: property types are incompatible."",
            SYMBOL_WITH_CONTAINING_DECLARATION,
            SYMBOL_WITH_CONTAINING_DECLARATION,
        )
        map.put(
            VAR_TYPE_MISMATCH_ON_INHERITANCE,
            ""{0} clashes with {1}: property types do not match."",
            SYMBOL_WITH_CONTAINING_DECLARATION,
            SYMBOL_WITH_CONTAINING_DECLARATION,
        )

        map.put(
            RETURN_TYPE_MISMATCH_BY_DELEGATION,
            ""{0} clashes with {1} from delegation: return types are incompatible."",
            SYMBOL_WITH_CONTAINING_DECLARATION,
            SYMBOL_WITH_CONTAINING_DECLARATION,
        )
        map.put(
            PROPERTY_TYPE_MISMATCH_BY_DELEGATION,
            ""{0} clashes with {1} from delegation: property types are incompatible."",
            SYMBOL_WITH_CONTAINING_DECLARATION,
            SYMBOL_WITH_CONTAINING_DECLARATION,
        )

        map.put(
            OVERRIDING_FINAL_MEMBER_BY_DELEGATION,
            ""{0} implicitly overrides a final member {1} by delegation."",
            SYMBOL_WITH_CONTAINING_DECLARATION,
            SYMBOL_WITH_CONTAINING_DECLARATION
        )

        map.put(
            DELEGATED_MEMBER_HIDES_SUPERTYPE_OVERRIDE,
            ""Delegated member ''{0}'' hides supertype override ''{1}''. Specify proper override explicitly."",
            SYMBOL,
            SYMBOL,
        )

        map.put(
            VAR_OVERRIDDEN_BY_VAL_BY_DELEGATION,
            ""''val'' property {0} implicitly overrides a ''var'' property {1} by delegation."",
            SYMBOL_WITH_CONTAINING_DECLARATION,
            SYMBOL_WITH_CONTAINING_DECLARATION
        )

        map.put(
            CONFLICTING_INHERITED_MEMBERS,
            ""''{0}'' inherits conflicting members: {1}."",
            DECLARATION_NAME,
            commaSeparated(SYMBOL_WITH_CONTAINING_DECLARATION)
        )
        map.put(
            OVERRIDING_IGNORABLE_WITH_MUST_USE,
            ""Method ''{0}'' is located in a scope marked as ''@MustUseReturnValue'', but marked as ''@IgnorableReturnValue'' in parent type ''{1}'' or its supertypes. "" +
                    ""Overriding ignorable methods with must-use methods is a semantically incorrect change. Consider marking ''{0}'' as ''@IgnorableReturnValue''."",
            DECLARATION_NAME,
            DECLARATION_FQ_NAME,
        )
        map.put(
            INLINE_CLASS_DEPRECATED,
            ""'inline' modifier is deprecated. Use 'value' instead.""
        )
        map.put(
            LESS_VISIBLE_TYPE_ACCESS_IN_INLINE,
            ""''{0}'' type ''{1}'' is accessed from ''{2}'' inline declaration."",
            TO_STRING,
            RENDER_TYPE,
            TO_STRING,
        )
        map.put(
            LESS_VISIBLE_TYPE_IN_INLINE_ACCESSED_SIGNATURE,
            ""The signature of ''{0}'' contains ''{1}'' type ''{2}'', but is accessed from ''{3}'' inline declaration."",
            SYMBOL,
            TO_STRING,
            RENDER_TYPE,
            TO_STRING
        )
        map.put(
            LESS_VISIBLE_CONTAINING_CLASS_IN_INLINE,
            ""The accessed declaration ''{0}'' is declared in ''{1}'' class ''{2}'', but is accessed from ''{3}'' inline declaration."",
            SYMBOL,
            TO_STRING,
            DECLARATION_NAME,
            TO_STRING,
        )
        map.put(
            CALLABLE_REFERENCE_TO_LESS_VISIBLE_DECLARATION_IN_INLINE,
            ""Callable reference to ''{1}'' declaration ''{0}'' inside ''{2}'' inline declaration."",
            DECLARATION_NAME,
            TO_STRING,
            TO_STRING,
        )

        // Redeclarations
        map.put(MANY_COMPANION_OBJECTS, ""Only one companion object is allowed per class."")
        map.put(CONFLICTING_OVERLOADS, ""Conflicting overloads:{0}"", SYMBOLS_ON_NEXT_LINES)
        map.put(REDECLARATION, ""Conflicting declarations:{0}"", SYMBOLS_ON_NEXT_LINES)
        map.put(CLASSIFIER_REDECLARATION, ""Redeclaration:{0}"", SYMBOLS_ON_NEXT_LINES)
        map.put(PACKAGE_CONFLICTS_WITH_CLASSIFIER, ""Package conflicts with classifier {0}"", CLASS_ID)
        map.put(EXPECT_AND_ACTUAL_IN_THE_SAME_MODULE, ""{0}: expect and corresponding actual are declared in the same module."", DECLARATION_NAME)

        map.put(METHOD_OF_ANY_IMPLEMENTED_IN_INTERFACE, ""Interfaces cannot implement a method of 'Any'."")
        map.put(EXTENSION_SHADOWED_BY_MEMBER, ""This extension is shadowed by a member: {0}."", SYMBOL_WITH_CONTAINING_DECLARATION)
        map.put(
            EXTENSION_FUNCTION_SHADOWED_BY_MEMBER_PROPERTY_WITH_INVOKE,
            ""This extension function is shadowed by a member property ''{0}'' with ''{1}''."",
            SYMBOL_WITH_CONTAINING_DECLARATION,
            SYMBOL_WITH_CONTAINING_DECLARATION,
        )

        // Invalid local declarations
        map.put(
            LOCAL_OBJECT_NOT_ALLOWED,
            ""Named object ''{0}'' cannot be local. Try to use an anonymous object instead."",
            TO_STRING
        ) // +
        map.put(
            LOCAL_INTERFACE_NOT_ALLOWED,
            ""Interface ''{0}'' cannot be local. Try to use an anonymous object or abstract class instead."",
            TO_STRING
        )

        // Functions
        map.put(
            ABSTRACT_FUNCTION_IN_NON_ABSTRACT_CLASS,
            ""Abstract function ''{0}'' in non-abstract class ''{1}''."",
            DECLARATION_NAME,
            DECLARATION_NAME
        )
        map.put(ABSTRACT_FUNCTION_WITH_BODY, ""Function ''{0}'' with a body cannot be abstract."", DECLARATION_NAME)
        map.put(NON_ABSTRACT_FUNCTION_WITH_NO_BODY, ""Function ''{0}'' without a body must be abstract."", DECLARATION_NAME)
        map.put(PRIVATE_FUNCTION_WITH_NO_BODY, ""Function ''{0}'' without a body cannot be private."", DECLARATION_NAME)
        map.put(NON_MEMBER_FUNCTION_NO_BODY, ""Function ''{0}'' must have a body."", DECLARATION_NAME)
        map.put(FUNCTION_DECLARATION_WITH_NO_NAME, ""Function declaration must have a name."")
        map.put(ANONYMOUS_FUNCTION_WITH_NAME, ""Anonymous functions with names are prohibited."")
        map.put(SINGLE_ANONYMOUS_FUNCTION_WITH_NAME, ""Anonymous functions with names are prohibited."")

        map.put(
            ANONYMOUS_FUNCTION_PARAMETER_WITH_DEFAULT_VALUE,
            ""Anonymous functions cannot specify default values for their parameters.""
        )
        map.put(USELESS_VARARG_ON_PARAMETER, ""Vararg on this parameter is useless."")
        map.put(
            FUN_INTERFACE_WRONG_COUNT_OF_ABSTRACT_MEMBERS,
            ""Functional interface must have exactly one abstract function.""
        )
        map.put(FUN_INTERFACE_CANNOT_HAVE_ABSTRACT_PROPERTIES, ""Functional interface cannot have abstract properties."")
        map.put(FUN_INTERFACE_ABSTRACT_METHOD_WITH_TYPE_PARAMETERS, ""Functional interface cannot have an abstract method with type parameters."")
        map.put(FUN_INTERFACE_ABSTRACT_METHOD_WITH_DEFAULT_VALUE, ""Functional interface abstract method cannot have a default value."")
        map.put(FUN_INTERFACE_WITH_SUSPEND_FUNCTION, ""Functional interface abstract method cannot have a suspend modifier."")

        map.put(MULTIPLE_VARARG_PARAMETERS, ""Multiple vararg parameters are prohibited."")
        map.put(FORBIDDEN_VARARG_PARAMETER_TYPE, ""Prohibited vararg parameter type ''{0}''."", RENDER_TYPE)
        map.put(VALUE_PARAMETER_WITHOUT_EXPLICIT_TYPE, ""An explicit type is required on a value parameter."")
        map.put(CANNOT_INFER_PARAMETER_TYPE, ""Cannot infer type for type parameter ''{0}''. Specify it explicitly."", DECLARATION_NAME)
        map.put(
            CANNOT_INFER_VALUE_PARAMETER_TYPE,
            ""Cannot infer type for value parameter ''{0}''. Specify it explicitly."",
            DECLARATION_NAME
        )
        map.put(CANNOT_INFER_IT_PARAMETER_TYPE, ""Cannot infer type for implicit value parameter 'it'. Specify it explicitly."")
        map.put(CANNOT_INFER_RECEIVER_PARAMETER_TYPE, ""Cannot infer type for receiver parameter. Specify it explicitly."")
        map.put(NO_TAIL_CALLS_FOUND, ""A function is marked as tail-recursive but no tail calls are found."")
        map.put(TAILREC_ON_VIRTUAL_MEMBER_ERROR, ""Tailrec is prohibited on open members."")
        map.put(NON_TAIL_RECURSIVE_CALL, ""Recursive call is not a tail call."")
        map.put(TAIL_RECURSION_IN_TRY_IS_NOT_SUPPORTED, ""Tail recursion optimization inside try/catch/finally is not supported."")
        map.put(DATA_OBJECT_CUSTOM_EQUALS_OR_HASH_CODE, ""Data object cannot have a custom implementation of 'equals' or 'hashCode'."")

        // Parameter default values
        map.put(DEFAULT_VALUE_NOT_ALLOWED_IN_OVERRIDE, ""An overriding function is not allowed to specify default values for its parameters."")

        // Properties & accessors
        map.put(
            ABSTRACT_PROPERTY_IN_NON_ABSTRACT_CLASS,
            ""Abstract property ''{0}'' in non-abstract class ''{1}''."",
            DECLARATION_NAME,
            DECLARATION_NAME
        )
        map.put(PRIVATE_PROPERTY_IN_INTERFACE, ""Abstract property in interface cannot be private."")

        map.put(ABSTRACT_PROPERTY_WITH_INITIALIZER, ""Property with initializer cannot be abstract."")
        map.put(PROPERTY_INITIALIZER_IN_INTERFACE, ""Property initializers in interfaces are prohibited."")
        map.put(
            PROPERTY_WITH_NO_TYPE_NO_INITIALIZER,
            ""This property must have an explicit type, be initialized, or be delegated.""
        )
        map.put(
            ABSTRACT_PROPERTY_WITHOUT_TYPE,
            ""Abstract property must have an explicit type.""
        )
        map.put(
            LATEINIT_PROPERTY_WITHOUT_TYPE,
            ""'lateinit' property must have an explicit type.""
        )

        map.put(VARIABLE_WITH_NO_TYPE_NO_INITIALIZER, ""This variable must either have an explicit type or be initialized."")

        map.put(INITIALIZATION_BEFORE_DECLARATION, ""Variable cannot be initialized before declaration."", SYMBOL)
        map.put(
            INITIALIZATION_BEFORE_DECLARATION_WARNING,
            ""Variable cannot be initialized before declaration."".toDeprecationWarningMessage(LanguageFeature.ForbidInitializationBeforeDeclarationInAnonymous),
            SYMBOL
        )
        map.put(TYPECHECKER_HAS_RUN_INTO_RECURSIVE_PROBLEM, ""Type checking has run into a recursive problem. Easiest workaround: specify the types of your declarations explicitly."")

        map.put(RETURN_VALUE_NOT_USED, ""Unused return value{0}."", OF_OPTIONAL_NAME)

        map.put(MUST_BE_INITIALIZED, ""Property must be initialized."")
        map.put(
            MUST_BE_INITIALIZED_WARNING,
            ""Property must be initialized""
                .toDeprecationWarningMessage(LanguageFeature.ProhibitMissedMustBeInitializedWhenThereIsNoPrimaryConstructor)
        )
        map.put(
            EXPLICIT_FIELD_MUST_BE_INITIALIZED,
            ""Field must be initialized.""
        )
        map.put(MUST_BE_INITIALIZED_OR_BE_FINAL, ""Property must be initialized or be final."")
        map.put(
            MUST_BE_INITIALIZED_OR_BE_FINAL_WARNING,
            ""Property must be initialized or be final""
                .toDeprecationWarningMessage(LanguageFeature.ProhibitMissedMustBeInitializedWhenThereIsNoPrimaryConstructor)
        )
        map.put(MUST_BE_INITIALIZED_OR_BE_ABSTRACT, ""Property must be initialized or be abstract."")
        map.put(
            MUST_BE_INITIALIZED_OR_BE_ABSTRACT_WARNING,
            ""Property must be initialized or be abstract""
                .toDeprecationWarningMessage(LanguageFeature.ProhibitMissedMustBeInitializedWhenThereIsNoPrimaryConstructor)
        )
        map.put(MUST_BE_INITIALIZED_OR_FINAL_OR_ABSTRACT, ""Property must be initialized, be final, or be abstract."")
        map.put(
            MUST_BE_INITIALIZED_OR_FINAL_OR_ABSTRACT_WARNING,
            ""Property must be initialized, be final, or be abstract""
                .toDeprecationWarningMessage(LanguageFeature.ProhibitMissedMustBeInitializedWhenThereIsNoPrimaryConstructor)
        )

        map.put(EXTENSION_PROPERTY_MUST_HAVE_ACCESSORS_OR_BE_ABSTRACT, ""Extension property must have accessors or be abstract."")
        map.put(UNNECESSARY_LATEINIT, ""'lateinit' is unnecessary: definitely initialized in constructors."")

        map.put(BACKING_FIELD_IN_INTERFACE, ""Property in interface cannot have a backing field."")
        map.put(EXTENSION_PROPERTY_WITH_BACKING_FIELD, ""Extension property cannot be initialized because it has no backing field."")
        map.put(PROPERTY_INITIALIZER_NO_BACKING_FIELD, ""Initializer is prohibited here because this property has no backing field."")

        map.put(ABSTRACT_DELEGATED_PROPERTY, ""Delegated property cannot be abstract."")
        map.put(DELEGATED_PROPERTY_IN_INTERFACE, ""Delegated properties in interfaces are prohibited."")

        map.put(ABSTRACT_PROPERTY_WITH_GETTER, ""Property with getter implementation cannot be abstract."")
        map.put(ABSTRACT_PROPERTY_WITH_SETTER, ""Property with setter implementation cannot be abstract."")
        map.put(PRIVATE_SETTER_FOR_ABSTRACT_PROPERTY, ""Private setters for abstract properties are prohibited."")
        map.put(PRIVATE_SETTER_FOR_OPEN_PROPERTY, ""Private setters for open properties are prohibited."")
        map.put(VAL_WITH_SETTER, ""A 'val' property cannot have a setter."")
        map.put(
            DELEGATE_USES_EXTENSION_PROPERTY_TYPE_PARAMETER_ERROR,
            ""Extension property type parameter ''{0}'' cannot be used in delegates. See https://youtrack.jetbrains.com/issue/KT-24643"",
            SYMBOL
        )
        map.put(GETTER_VISIBILITY_DIFFERS_FROM_PROPERTY_VISIBILITY, ""Getter visibility must be the same as property visibility."")
        map.put(
            SETTER_VISIBILITY_INCONSISTENT_WITH_PROPERTY_VISIBILITY,
            ""Setter visibility cannot be more permissive than property visibility.""
        )
        map.put(
            WRONG_GETTER_RETURN_TYPE,
            ""Getter return type must be equal to the type of the property, i.e. ''{0}''."",
            RENDER_TYPE,
            RENDER_TYPE,
        )
        map.put(
            WRONG_SETTER_RETURN_TYPE,
            ""Setter return type must be 'Unit'.""
        )
        map.put(
            WRONG_SETTER_PARAMETER_TYPE,
            ""Setter parameter type must be equal to the type of the property, i.e. ''{0}''."",
            RENDER_TYPE,
            RENDER_TYPE,
        )
        map.put(ACCESSOR_FOR_DELEGATED_PROPERTY, ""Delegated property cannot have accessors with non-default implementations."")
        map.put(
            PROPERTY_INITIALIZER_WITH_EXPLICIT_FIELD_DECLARATION,
            ""Property initializers are prohibited for properties with explicit backing field declaration.""
        )
        map.put(
            PROPERTY_FIELD_DECLARATION_MISSING_INITIALIZER,
            ""Property backing field declaration must have an initializer.""
        )
        map.put(
            LATEINIT_PROPERTY_FIELD_DECLARATION_WITH_INITIALIZER,
            ""'lateinit' backing field cannot have an initializer.""
        )
        map.put(
            LATEINIT_FIELD_IN_VAL_PROPERTY,
            ""Only mutable properties can have a mutable backing field. Consider changing 'val' to 'var'.""
        )
        map.put(
            LATEINIT_NULLABLE_BACKING_FIELD,
            ""'lateinit' modifier is prohibited on backing fields of a type with nullable upper bound.""
        )
        map.put(
            BACKING_FIELD_FOR_DELEGATED_PROPERTY,
            ""Delegated properties cannot have explicit backing field declarations.""
        )
        map.put(
            NON_FINAL_PROPERTY_WITH_EXPLICIT_BACKING_FIELD,
            ""Properties with explicit backing fields must be final."",
        )
        map.put(
            VAR_PROPERTY_WITH_EXPLICIT_BACKING_FIELD,
            ""Only 'val' properties with explicit backing fields are supported."",
        )
        map.put(
            EXPECT_PROPERTY_WITH_EXPLICIT_BACKING_FIELD,
            ""'expect' properties are not allowed to declare explicit backing fields."",
        )
        map.put(
            INCONSISTENT_BACKING_FIELD_TYPE,
            ""The type of the backing field must be a subtype of the property's type.""
        )
        map.put(
            PROPERTY_WITH_EXPLICIT_FIELD_AND_ACCESSORS,
            ""Properties with explicit backing fields cannot have accessors.""
        )
        map.put(
            EXPLICIT_BACKING_FIELD_IN_INTERFACE,
            ""Backing fields inside interfaces are prohibited.""
        )
        map.put(
            EXPLICIT_BACKING_FIELD_IN_ABSTRACT_PROPERTY,
            ""Abstract property cannot have a backing field.""
        )
        map.put(
            EXPLICIT_BACKING_FIELD_IN_EXTENSION,
            ""Extension properties cannot have a backing field.""
        )
        map.put(
            REDUNDANT_EXPLICIT_BACKING_FIELD,
            ""Explicit backing field declaration is unnecessary if it has the same type as the property.""
        )
        map.put(ABSTRACT_PROPERTY_IN_PRIMARY_CONSTRUCTOR_PARAMETERS, ""Property in primary constructor cannot be declared as abstract."")
        map.put(LOCAL_VARIABLE_WITH_TYPE_PARAMETERS_WARNING, ""Type parameters for local variables are deprecated."")
        map.put(LOCAL_VARIABLE_WITH_TYPE_PARAMETERS, ""Local variables cannot have type parameters."")
        map.put(EXPLICIT_TYPE_ARGUMENTS_IN_PROPERTY_ACCESS, ""{0} access cannot have explicit type arguments."", STRING)
        map.put(SAFE_CALLABLE_REFERENCE_CALL, ""This syntax is reserved for future releases."")

        map.put(LATEINIT_INTRINSIC_CALL_ON_NON_LITERAL, ""This declaration can only be called on a property literal (e.g. 'Foo::bar')."")
        map.put(LATEINIT_INTRINSIC_CALL_ON_NON_LATEINIT, ""This declaration can only be called on a reference to a 'lateinit' property."")
        map.put(LATEINIT_INTRINSIC_CALL_IN_INLINE_FUNCTION, ""This declaration cannot be used inside an inline function."")
        map.put(LATEINIT_INTRINSIC_CALL_ON_NON_ACCESSIBLE_PROPERTY, ""Backing field of ''{0}'' is not accessible at this point."", SYMBOL)

        map.put(LOCAL_EXTENSION_PROPERTY, ""Local extension properties are prohibited."")

        map.put(UNNAMED_VAR_PROPERTY, ""'var' properties require a name."")
        map.put(UNNAMED_DELEGATED_PROPERTY, ""Delegated properties require a name."")

        map.put(
            DESTRUCTURING_SHORT_FORM_NAME_MISMATCH,
            buildString {
                append(""Variable name ''{0}'' differs from accessed property name ''{1}''. This syntax will be used for name-based destructuring "")
                appendVersion(LanguageFeature.EnableNameBasedDestructuringShortForm)
                appendLine("", and this code will change its meaning."")
                appendLine(""Use the full name-based destructuring syntax ''(val {0} = {1}, ...)'', the new positional destructuring syntax ''[{0}, ...]'', or align the names to prepare for the transition."")
                append(""See https://kotl.in/name-based-destructuring for more information."")
            },
            NAME,
            NAME,
        )
        map.put(
            DESTRUCTURING_SHORT_FORM_OF_NON_DATA_CLASS,
            buildString {
                append(""This syntax will be used for name-based destructuring "")
                appendVersion(LanguageFeature.EnableNameBasedDestructuringShortForm)
                appendLine("" which will stop compiling or change its meaning for non-data class ''{0}''."")
                appendLine(""Use the new positional destructuring syntax ''[{1}, ...]'' to prepare for the transition."")
                append(""See https://kotl.in/name-based-destructuring for more information."")
            },
            RENDER_TYPE,
            NAME
        )
        map.put(
            DESTRUCTURING_SHORT_FORM_UNDERSCORE,
            buildString {
                append(""This syntax will be used for name-based destructuring "")
                appendVersion(LanguageFeature.EnableNameBasedDestructuringShortForm)
                appendLine("", and an underscore without renaming will become an error."")
                appendLine(""Use name-based destructuring syntax '(val x, ...)' and drop the unused entry, or use the new positional destructuring syntax '[_, ...]'."")
                append(""See https://kotl.in/name-based-destructuring for more information."")
            },
        )
        map.put(NAME_BASED_DESTRUCTURING_UNDERSCORE_WITHOUT_RENAMING, ""Underscore in name-based destructuring without renaming is forbidden."")

        map.put(CONST_VAL_NOT_TOP_LEVEL_OR_OBJECT, ""Const 'val' is only allowed on top level, in named objects, or in companion objects."")
        map.put(CONST_VAL_WITH_GETTER, ""Const 'val' cannot have a getter."")
        map.put(CONST_VAL_WITH_DELEGATE, ""Const 'val' cannot have a delegate."")
        map.put(TYPE_CANT_BE_USED_FOR_CONST_VAL, ""Const ''val'' has type ''{0}''. Only primitive types and ''String'' are allowed."", RENDER_TYPE)
        map.put(CONST_VAL_WITHOUT_INITIALIZER, ""Const 'val' must have an initializer."")
        map.put(CONST_VAL_WITH_NON_CONST_INITIALIZER, ""Const 'val' initializer must be a constant value."")
        map.put(NON_CONST_VAL_USED_IN_CONSTANT_EXPRESSION, ""Only 'const val' can be used in constant expressions."")
        map.put(CYCLE_IN_ANNOTATION_PARAMETER, ""Cycle formed by one or more annotations and their parameter types."")

        // Multi-platform projects
        map.put(EXPECTED_DECLARATION_WITH_BODY, ""Expected declaration cannot have a body."")
        map.put(EXPECTED_CLASS_CONSTRUCTOR_DELEGATION_CALL, ""Explicit delegation call for constructor of expected class is prohibited."")
        map.put(EXPECTED_CLASS_CONSTRUCTOR_PROPERTY_PARAMETER, ""Expected class constructor cannot have a property parameter."")
        map.put(EXPECTED_ENUM_CONSTRUCTOR, ""Expected enum class cannot have a constructor."")
        map.put(EXPECTED_ENUM_ENTRY_WITH_BODY, ""Expected enum entry cannot have a body."")
        map.put(EXPECTED_PROPERTY_INITIALIZER, ""Expected property cannot have an initializer."")
        map.put(EXPECTED_DELEGATED_PROPERTY, ""Expected property cannot be delegated."")
        map.put(EXPECTED_LATEINIT_PROPERTY, ""Expected property cannot be 'lateinit'."")
        map.put(EXPECTED_PRIVATE_DECLARATION, ""Expected declaration cannot be private."")
        map.put(EXPECTED_EXTERNAL_DECLARATION, ""Expected declaration cannot be external."")
        map.put(EXPECTED_TAILREC_FUNCTION, ""Expected function cannot have 'tailrec' modifier."")
        map.put(SUPERTYPE_INITIALIZED_IN_EXPECTED_CLASS, ""Expected classes cannot initialize supertypes."")
        map.put(IMPLEMENTATION_BY_DELEGATION_IN_EXPECT_CLASS, ""Implementation by delegation in expected classes is prohibited."")
        map.put(ACTUAL_TYPE_ALIAS_NOT_TO_CLASS, ""Right-hand side of actual type alias must be a class, not another type alias."")
        map.put(
            ACTUAL_TYPE_ALIAS_TO_CLASS_WITH_DECLARATION_SITE_VARIANCE,
            ""Aliased class cannot have type parameters with declaration-site variance.""
        )
        map.put(
            ACTUAL_TYPE_ALIAS_WITH_USE_SITE_VARIANCE,
            ""Right-hand side of actual type alias cannot contain use-site variance or star projections.""
        )
        map.put(
            ACTUAL_TYPE_ALIAS_WITH_COMPLEX_SUBSTITUTION,
            ""Type arguments on the right-hand side of actual type alias must be its type parameters in the same order, e.g. 'actual typealias Foo<A, B> = Bar<A, B>'.""
        )
        map.put(
            ACTUAL_TYPE_ALIAS_TO_NULLABLE_TYPE,
            ""Right-hand side of actual type alias cannot be a nullable type.""
        )
        map.put(
            ACTUAL_TYPE_ALIAS_TO_NOTHING,
            ""Right-hand side of actual type alias cannot be of type 'kotlin.Nothing'.""
        )
        map.put(
            ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS,
            ""Actual function cannot have default argument values. They must be declared in the expected function.""
        )
        map.put(
            DEFAULT_ARGUMENTS_IN_EXPECT_WITH_ACTUAL_TYPEALIAS,
            ""Default argument values inside expect declaration ''{0}'' are not allowed if it is actualized via typealias. "" +
                    ""Possible fix is to remove default argument values in members:{1}"",
            DECLARATION_NAME,
            SYMBOLS_ON_NEWLINE_WITH_INDENT,
        )
        map.put(
            DEFAULT_ARGUMENTS_IN_EXPECT_ACTUALIZED_BY_FAKE_OVERRIDE,
            ""Default argument values inside expect declaration ''{0}'' are not allowed for methods actualized via fake override. "" +
                    ""Possible fix is to remove default argument values in members:{1}"",
            DECLARATION_NAME,
            SYMBOLS_ON_NEWLINE_WITH_INDENT,
        )
        map.put(
            EXPECTED_FUNCTION_SOURCE_WITH_DEFAULT_ARGUMENTS_NOT_FOUND,
            ""Expected function source is not found, so generating default argument values declared there is impossible. Corresponding file must be added to compilation sources.""
        )
        map.put(
            ACTUAL_WITHOUT_EXPECT,
            ""''{0}'' has no corresponding expected declaration{1}"",
            SYMBOL_WITH_ALL_MODIFIERS,
            FirPlatformIncompatibilityDiagnosticRenderer.TEXT
        )
        map.put(EXPECT_ACTUAL_INCOMPATIBLE_CLASS_TYPE_PARAMETER_COUNT, EXPECT_ACTUAL_INCOMPATIBILITY_MSG, SYMBOL_WITH_ALL_MODIFIERS, SYMBOL_WITH_ALL_MODIFIERS, STRING)
        map.put(EXPECT_ACTUAL_INCOMPATIBLE_RETURN_TYPE, EXPECT_ACTUAL_INCOMPATIBILITY_MSG, SYMBOL_WITH_ALL_MODIFIERS, SYMBOL_WITH_ALL_MODIFIERS, STRING)
        map.put(EXPECT_ACTUAL_INCOMPATIBLE_PARAMETER_NAMES, EXPECT_ACTUAL_INCOMPATIBILITY_MSG, SYMBOL_WITH_ALL_MODIFIERS, SYMBOL_WITH_ALL_MODIFIERS, STRING)
        map.put(EXPECT_ACTUAL_INCOMPATIBLE_CONTEXT_PARAMETER_NAMES, EXPECT_ACTUAL_INCOMPATIBILITY_MSG, SYMBOL_WITH_ALL_MODIFIERS, SYMBOL_WITH_ALL_MODIFIERS, STRING)
        map.put(EXPECT_ACTUAL_INCOMPATIBLE_TYPE_PARAMETER_NAMES, EXPECT_ACTUAL_INCOMPATIBILITY_MSG, SYMBOL_WITH_ALL_MODIFIERS, SYMBOL_WITH_ALL_MODIFIERS, STRING)
        map.put(EXPECT_ACTUAL_INCOMPATIBLE_VALUE_PARAMETER_VARARG, EXPECT_ACTUAL_INCOMPATIBILITY_MSG, SYMBOL_WITH_ALL_MODIFIERS, SYMBOL_WITH_ALL_MODIFIERS, STRING)
        map.put(EXPECT_ACTUAL_INCOMPATIBLE_VALUE_PARAMETER_NOINLINE, EXPECT_ACTUAL_INCOMPATIBILITY_MSG, SYMBOL_WITH_ALL_MODIFIERS, SYMBOL_WITH_ALL_MODIFIERS, STRING)
        map.put(EXPECT_ACTUAL_INCOMPATIBLE_VALUE_PARAMETER_CROSSINLINE, EXPECT_ACTUAL_INCOMPATIBILITY_MSG, SYMBOL_WITH_ALL_MODIFIERS, SYMBOL_WITH_ALL_MODIFIERS, STRING)
        map.put(EXPECT_ACTUAL_INCOMPATIBLE_FUNCTION_MODIFIERS_DIFFERENT, EXPECT_ACTUAL_INCOMPATIBILITY_MSG, SYMBOL_WITH_ALL_MODIFIERS, SYMBOL_WITH_ALL_MODIFIERS, STRING)
        map.put(EXPECT_ACTUAL_INCOMPATIBLE_FUNCTION_MODIFIERS_NOT_SUBSET, EXPECT_ACTUAL_INCOMPATIBILITY_MSG, SYMBOL_WITH_ALL_MODIFIERS, SYMBOL_WITH_ALL_MODIFIERS, STRING)
        map.put(EXPECT_ACTUAL_INCOMPATIBLE_PARAMETERS_WITH_DEFAULT_VALUES_IN_EXPECT_ACTUALIZED_BY_FAKE_OVERRIDE, EXPECT_ACTUAL_INCOMPATIBILITY_MSG, SYMBOL_WITH_ALL_MODIFIERS, SYMBOL_WITH_ALL_MODIFIERS, STRING)
        map.put(EXPECT_ACTUAL_INCOMPATIBLE_PROPERTY_KIND, EXPECT_ACTUAL_INCOMPATIBILITY_MSG, SYMBOL_WITH_ALL_MODIFIERS, SYMBOL_WITH_ALL_MODIFIERS, STRING)
        map.put(EXPECT_ACTUAL_INCOMPATIBLE_PROPERTY_LATEINIT_MODIFIER, EXPECT_ACTUAL_INCOMPATIBILITY_MSG, SYMBOL_WITH_ALL_MODIFIERS, SYMBOL_WITH_ALL_MODIFIERS, STRING)
        map.put(EXPECT_ACTUAL_INCOMPATIBLE_PROPERTY_CONST_MODIFIER, EXPECT_ACTUAL_INCOMPATIBILITY_MSG, SYMBOL_WITH_ALL_MODIFIERS, SYMBOL_WITH_ALL_MODIFIERS, STRING)
        map.put(EXPECT_ACTUAL_INCOMPATIBLE_PROPERTY_SETTER_VISIBILITY, EXPECT_ACTUAL_INCOMPATIBILITY_MSG, SYMBOL_WITH_ALL_MODIFIERS, SYMBOL_WITH_ALL_MODIFIERS, STRING)
        map.put(EXPECT_ACTUAL_INCOMPATIBLE_CLASS_KIND, EXPECT_ACTUAL_INCOMPATIBILITY_MSG, SYMBOL_WITH_ALL_MODIFIERS, SYMBOL_WITH_ALL_MODIFIERS, STRING)
        map.put(EXPECT_ACTUAL_INCOMPATIBLE_CLASS_MODIFIERS, EXPECT_ACTUAL_INCOMPATIBILITY_MSG, SYMBOL_WITH_ALL_MODIFIERS, SYMBOL_WITH_ALL_MODIFIERS, STRING)
        map.put(EXPECT_ACTUAL_INCOMPATIBLE_FUN_INTERFACE_MODIFIER, EXPECT_ACTUAL_INCOMPATIBILITY_MSG, SYMBOL_WITH_ALL_MODIFIERS, SYMBOL_WITH_ALL_MODIFIERS, STRING)
        map.put(EXPECT_ACTUAL_INCOMPATIBLE_SUPERTYPES, EXPECT_ACTUAL_INCOMPATIBILITY_MSG, SYMBOL_WITH_ALL_MODIFIERS, SYMBOL_WITH_ALL_MODIFIERS, STRING)
        map.put(EXPECT_ACTUAL_INCOMPATIBLE_NESTED_TYPE_ALIAS, EXPECT_ACTUAL_INCOMPATIBILITY_MSG, SYMBOL_WITH_ALL_MODIFIERS, SYMBOL_WITH_ALL_MODIFIERS, STRING)
        map.put(EXPECT_ACTUAL_INCOMPATIBLE_ENUM_ENTRIES, EXPECT_ACTUAL_INCOMPATIBILITY_MSG, SYMBOL_WITH_ALL_MODIFIERS, SYMBOL_WITH_ALL_MODIFIERS, STRING)
        map.put(EXPECT_ACTUAL_INCOMPATIBLE_ILLEGAL_REQUIRES_OPT_IN, EXPECT_ACTUAL_INCOMPATIBILITY_MSG, SYMBOL_WITH_ALL_MODIFIERS, SYMBOL_WITH_ALL_MODIFIERS, STRING)
        map.put(EXPECT_ACTUAL_INCOMPATIBLE_MODALITY, EXPECT_ACTUAL_INCOMPATIBILITY_MSG, SYMBOL_WITH_ALL_MODIFIERS, SYMBOL_WITH_ALL_MODIFIERS, STRING)
        map.put(EXPECT_ACTUAL_INCOMPATIBLE_VISIBILITY, EXPECT_ACTUAL_INCOMPATIBILITY_MSG, SYMBOL_WITH_ALL_MODIFIERS, SYMBOL_WITH_ALL_MODIFIERS, STRING)
        map.put(EXPECT_ACTUAL_INCOMPATIBLE_CLASS_TYPE_PARAMETER_UPPER_BOUNDS, EXPECT_ACTUAL_INCOMPATIBILITY_MSG, SYMBOL_WITH_ALL_MODIFIERS, SYMBOL_WITH_ALL_MODIFIERS, STRING)
        map.put(EXPECT_ACTUAL_INCOMPATIBLE_TYPE_PARAMETER_VARIANCE, EXPECT_ACTUAL_INCOMPATIBILITY_MSG, SYMBOL_WITH_ALL_MODIFIERS, SYMBOL_WITH_ALL_MODIFIERS, STRING)
        map.put(EXPECT_ACTUAL_INCOMPATIBLE_TYPE_PARAMETER_REIFIED, EXPECT_ACTUAL_INCOMPATIBILITY_MSG, SYMBOL_WITH_ALL_MODIFIERS, SYMBOL_WITH_ALL_MODIFIERS, STRING)
        map.put(
            EXPECT_ACTUAL_INCOMPATIBLE_CLASS_SCOPE,
            ""''{0}'' contains an incompatible pair of ''expect'' and ''actual'' member declarations.\n  expect: {1}\n  actual: {2}\n  reason: {3}"",
            SYMBOL, SYMBOL_WITH_ALL_MODIFIERS, SYMBOL_WITH_ALL_MODIFIERS, STRING
        )
        map.put(
            EXPECT_REFINEMENT_ANNOTATION_WRONG_TARGET,
            ""Only top-level 'expect' declarations can be annotated with the '@ExpectRefinement' annotation.""
        )
        map.put(AMBIGUOUS_EXPECTS, ""''{0}'' has several compatible expect declarations in modules {1}."", SYMBOL, COLLECTION(MODULE_DATA))
        map.put(
            NO_ACTUAL_CLASS_MEMBER_FOR_EXPECTED_CLASS,
            ""''{0}'' has no corresponding members for expected class members:{1}"",
            SYMBOL,
            FirIncompatibleExpectedActualClassScopesRenderer.TEXT
        )
        map.put(ACTUAL_MISSING, ""Declaration must be marked with 'actual'."")
        map.put(
            EXPECT_REFINEMENT_ANNOTATION_MISSING,
            ""'expect' declaration refinement is an experimental feature. Mark the declaration with the '@ExpectRefinement' annotation.""
        )
        map.put(
            EXPECT_ACTUAL_CLASSIFIERS_ARE_IN_BETA_WARNING,
            ""'expect'/'actual' classes (including interfaces, objects, annotations, enums, and 'actual' typealiases) are in Beta. "" +
                    ""Consider using the '-Xexpect-actual-classes' flag to suppress this warning. "" +
                    ""Also see: https://youtrack.jetbrains.com/issue/KT-61573""
        )
        map.put(NOT_A_MULTIPLATFORM_COMPILATION, ""'expect' and 'actual' declarations can be used only in multiplatform projects. Learn more about Kotlin Multiplatform: https://kotl.in/multiplatform-setup"")
        map.put(EXPECT_ACTUAL_OPT_IN_ANNOTATION, ""Opt-in annotations are prohibited to be 'expect' or 'actual'. Instead, declare annotation once in common sources."")
        map.put(
            ACTUAL_TYPEALIAS_TO_SPECIAL_ANNOTATION,
            ""''actual typealias'' to annotation which affects code compilation can lead to incorrect behavior. Instead, use ''{0}'' annotation directly."",
            CLASS_ID
        )
        map.put(
            ACTUAL_ANNOTATIONS_NOT_MATCH_EXPECT,
            ""{3}.\n"" +
                    ""All annotations from expect ''{0}'' must be present with the same arguments on actual ''{1}'', otherwise they might behave incorrectly."",
            FirExpectActualAnnotationIncompatibilityDiagnosticRenderers.SYMBOL_RENDERER,
            FirExpectActualAnnotationIncompatibilityDiagnosticRenderers.SYMBOL_RENDERER,
            NOT_RENDERED,
            FirExpectActualAnnotationIncompatibilityDiagnosticRenderers.INCOMPATIBILITY,
        )
        map.put(
            OPTIONAL_DECLARATION_OUTSIDE_OF_ANNOTATION_ENTRY,
            ""Declaration annotated with '@OptionalExpectation' can only be used inside an annotation entry.""
        )
        map.put(
            OPTIONAL_DECLARATION_USAGE_IN_NON_COMMON_SOURCE,
            ""Declaration annotated with '@OptionalExpectation' can only be used in common module sources.""
        )
        map.put(
            OPTIONAL_EXPECTATION_NOT_ON_EXPECTED,
            ""'@OptionalExpectation' can only be used on an expected annotation class.""
        )

        // Control flow diagnostics
        map.put(UNINITIALIZED_VARIABLE, ""Variable ''{0}'' must be initialized."", VARIABLE_NAME)
        map.put(UNINITIALIZED_PARAMETER, ""Parameter ''{0}'' is uninitialized here."", VARIABLE_NAME)
        map.put(UNINITIALIZED_ENUM_ENTRY, ""Enum entry ''{0}'' is uninitialized here."", VARIABLE_NAME)
        map.put(UNINITIALIZED_ENUM_COMPANION, ""Companion object of enum class ''{0}'' is uninitialized here."", DECLARATION_NAME)
        map.put(VAL_REASSIGNMENT, ""''val'' cannot be reassigned."", VARIABLE_NAME)
        map.put(VAL_REASSIGNMENT_VIA_BACKING_FIELD_ERROR, ""Reassignment of read-only property via backing field."", VARIABLE_NAME)
        map.put(
            CAPTURED_VAL_INITIALIZATION,
            ""Captured values cannot be initialized because of possible reassignments."",
            VARIABLE_NAME
        )
        map.put(
            CAPTURED_MEMBER_VAL_INITIALIZATION,
            ""Initialization of captured member values is prohibited because of possible reassignments."",
            VARIABLE_NAME
        )
        map.put(
            FirErrors.NON_INLINE_MEMBER_VAL_INITIALIZATION,
            ""Initialization of captured member values must be inlined."",
            VARIABLE_NAME
        )
        map.put(
            SETTER_PROJECTED_OUT,
            ""Receiver type ''{0}'' contains {1} projection which prohibits calling the setter of ''{2}''."",
            RENDER_TYPE,
            STRING,
            VARIABLE_NAME,
        )
        map.put(
            WRONG_INVOCATION_KIND,
            ""Wrong invocation kind ''{1}'' for ''{0}'' specified, the actual invocation kind is ''{2}''."",
            SYMBOL,
            TO_STRING,
            TO_STRING
        )
        map.put(LEAKED_IN_PLACE_LAMBDA, ""Leaked in-place lambda ''{0}''."", SYMBOL)
        map.put(UNREACHABLE_CODE, ""Unreachable code."", NOT_RENDERED, NOT_RENDERED)
        map.put(SENSELESS_COMPARISON, ""Condition is always ''{0}''."", TO_STRING)
        map.put(SENSELESS_NULL_IN_WHEN, ""Expression under 'when' is never equal to null."")

        // Nullability
        map.put(
            NULL_FOR_NONNULL_TYPE,
            ""Null cannot be a value of a non-null type ''{0}''."",
            RENDER_TYPE,
        )
        map.put(
            UNSAFE_CALL,
            ""Only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type ''{0}''."",
            RENDER_TYPE,
            NOT_RENDERED,
        )
        map.put(
            UNSAFE_IMPLICIT_INVOKE_CALL,
            ""Reference has a nullable type ''{0}''. Use explicit ''?.invoke'' to make a function-like call instead."",
            RENDER_TYPE,
        )
        map.put(
            UNSAFE_INFIX_CALL,
            ""Infix call is prohibited on a nullable receiver of type ''{0}''. Use ''?.''-qualified call instead."",
            RENDER_TYPE,
            NOT_RENDERED,
            NOT_RENDERED,
            NOT_RENDERED,
        )
        map.put(
            UNSAFE_OPERATOR_CALL,
            ""Operator call is prohibited on a nullable receiver of type ''{0}''. Use ''?.''-qualified call instead."",
            RENDER_TYPE,
            NOT_RENDERED,
            NOT_RENDERED,
            NOT_RENDERED,
        )
        map.put(
            ITERATOR_ON_NULLABLE,
            ""Non-nullable value required to call an 'iterator()' method in a for-loop."",
        )
        map.put(
            COMPONENT_FUNCTION_ON_NULLABLE,
            ""Operator call ''{0}()'' cannot be applied to destructuring of nullable type ''{1}''."",
            TO_STRING,
            RENDER_TYPE,
        )
        map.put(UNEXPECTED_SAFE_CALL, ""Safe call is prohibited here."")
        map.put(UNNECESSARY_SAFE_CALL, ""Unnecessary safe call on a non-null receiver of type ''{0}''."", RENDER_TYPE)
        map.put(UNNECESSARY_NOT_NULL_ASSERTION, ""Unnecessary non-null assertion (!!) on a non-null receiver of type ''{0}''."", RENDER_TYPE)
        map.put(NOT_NULL_ASSERTION_ON_LAMBDA_EXPRESSION, ""Non-null assertion (!!) called on a lambda expression."")
        map.put(NOT_NULL_ASSERTION_ON_CALLABLE_REFERENCE, ""Non-null assertion (!!) called on a callable reference expression."")
        map.put(USELESS_ELVIS, ""Elvis operator (?:) always returns the left operand of non-nullable type ''{0}''."", RENDER_TYPE)
        map.put(USELESS_ELVIS_RIGHT_IS_NULL, ""Right operand of elvis operator (?:) is useless if it is null."")
        map.put(USELESS_ELVIS_LEFT_IS_NULL, ""Elvis operator (?:) is useless if the left operand is null."")

        // Casts and is-checks
        map.put(CANNOT_CHECK_FOR_ERASED, ""Cannot check for instance of erased type ''{0}''."", RENDER_TYPE)
        map.put(CAST_NEVER_SUCCEEDS, ""This cast can never succeed."")
        map.put(USELESS_CAST, ""No cast needed."")
        map.put(UNCHECKED_CAST, ""Unchecked cast of ''{0}'' to ''{1}''."", RENDER_TYPE, RENDER_TYPE)
        map.put(USELESS_IS_CHECK, ""Check for instance is always ''{0}''."", TO_STRING)
        map.put(DYNAMIC_NOT_ALLOWED, ""Dynamic types are not allowed in this position."")
        map.put(IS_ENUM_ENTRY, ""'is' over enum entry is prohibited. Use comparison instead."")
        map.put(ENUM_ENTRY_AS_TYPE, ""Use of enum entry names as types is prohibited. Use enum type instead."")

        // When expressions
        map.put(EXPECTED_CONDITION, ""Condition of type 'Boolean' expected."")
        map.put(NO_ELSE_IN_WHEN, ""''when'' expression must be exhaustive. Add {0}{1}."", WHEN_MISSING_CASES, STRING)
        map.put(INVALID_IF_AS_EXPRESSION, ""'if' must have both main and 'else' branches when used as an expression."")
        map.put(ELSE_MISPLACED_IN_WHEN, ""'else' entry must be the last one in a 'when' expression."")
        map.put(REDUNDANT_ELSE_IN_WHEN, ""'when' is exhaustive so 'else' is redundant here."")
        map.put(
            COMMA_IN_WHEN_CONDITION_WITHOUT_ARGUMENT,
            ""Use '||' instead of commas in conditions of 'when' without a subject.""
        )
        map.put(DUPLICATE_BRANCH_CONDITION_IN_WHEN, ""Duplicate branch condition in 'when'."")
        map.put(
            ILLEGAL_DECLARATION_IN_WHEN_SUBJECT,
            ""Illegal variable declaration in ''when'' subject: {0}. Must be a simple ''val'' with an initializer."",
            STRING
        )
        map.put(
            CONFUSING_BRANCH_CONDITION,
            ""Logical expression in when-with-subject. The branch will be matched by comparing the result of the logical expression with the subject. To suppress the diagnostic, wrap the expression with parentheses.""
        )
        map.put(
            WRONG_CONDITION_SUGGEST_GUARD,
            ""Use 'if' instead of '&&' to introduce additional conditions. See https://kotl.in/guards-in-when.""
        )
        map.put(
            COMMA_IN_WHEN_CONDITION_WITH_WHEN_GUARD,
            ""Use of comma in 'when' condition with guard statement is not allowed.""
        )
        map.put(
            WHEN_GUARD_WITHOUT_SUBJECT,
            ""Guard statements are only allowed in 'when' with subject.""
        )
        map.put(
            INFERRED_INVISIBLE_WHEN_TYPE,
            ""Inferred type ''{0}'' for {1} expression is not visible in this scope."",
            RENDER_TYPE,
            STRING,
        )

        // Context tracking
        map.put(TYPE_PARAMETER_IS_NOT_AN_EXPRESSION, ""Type parameter ''{0}'' is not an expression."", SYMBOL)
        map.put(
            TYPE_PARAMETER_ON_LHS_OF_DOT,
            ""Type parameter ''{0}'' cannot have or inherit a companion object, so it cannot be on the left-hand side of a dot."",
            SYMBOL
        )
        map.put(
            NO_COMPANION_OBJECT,
            ""Classifier ''{0}'' does not have a companion object, so it cannot be used as an expression."",
            SYMBOL
        )
        map.put(EXPRESSION_EXPECTED_PACKAGE_FOUND, ""Expression expected, but package name found."")

        // Function contracts
        map.put(ERROR_IN_CONTRACT_DESCRIPTION, ""Error in contract description: {0}."", TO_STRING)
        map.put(CONTRACT_NOT_ALLOWED, ""{0}"", TO_STRING)

        // Conventions
        map.put(NO_GET_METHOD, ""No 'get' operator method providing array access."")
        map.put(NO_SET_METHOD, ""No 'set' operator method providing array access."")
        map.put(ITERATOR_MISSING, ""For-loop range must have an 'iterator()' method."")
        map.put(HAS_NEXT_MISSING, ""'hasNext()' cannot be called on 'iterator()'."")
        map.put(NEXT_MISSING, ""Method 'next()' cannot be called on 'iterator()'."")
        map.put(
            COMPONENT_FUNCTION_MISSING,
            ""Destructuring of type ''{1}'' requires operator function ''{0}()''."",
            TO_STRING,
            RENDER_TYPE,
        )
        map.put(
            DELEGATE_SPECIAL_FUNCTION_MISSING,
            ""Type ''{1}'' has no method ''{0}'', so it cannot serve as a {2}."",
            TO_STRING,
            RENDER_TYPE,
            TO_STRING,
        )
        map.put(
            UNDERSCORE_IS_RESERVED,
            ""Names _, __, ___, ... are reserved in Kotlin.""
        )
        map.put(
            UNDERSCORE_USAGE_WITHOUT_BACKTICKS,
            ""Names _, __, ___, ... can only be used in back-ticks (`_`, `__`, `___`, ...).""
        )
        map.put(
            RESOLVED_TO_UNDERSCORE_NAMED_CATCH_PARAMETER,
            ""Referencing an underscore-named parameter is deprecated. It will be an error in a future release.""
        )
        map.put(
            INVALID_CHARACTERS,
            ""Name {0}."",
            STRING
        )
        map.put(
            EQUALITY_NOT_APPLICABLE,
            ""Operator ''{0}'' cannot be applied to ''{1}'' and ''{2}''."",
            TO_STRING,
            RENDER_TYPE,
            RENDER_TYPE
        )
        map.put(
            EQUALITY_NOT_APPLICABLE_WARNING,
            ""Comparison with ''{0}'' might not be intended because ''{1}'' and ''{2}'' are incompatible types."",
            TO_STRING,
            RENDER_TYPE,
            RENDER_TYPE
        )
        map.put(
            INCOMPATIBLE_ENUM_COMPARISON_ERROR,
            ""Comparison of incompatible enums ''{0}'' and ''{1}'' is always unsuccessful."",
            RENDER_TYPE,
            RENDER_TYPE
        )
        map.put(
            INCOMPATIBLE_ENUM_COMPARISON,
            ""Comparison of incompatible enums ''{0}'' and ''{1}'' is always unsuccessful."",
            RENDER_TYPE,
            RENDER_TYPE
        )
        map.put(
            FORBIDDEN_IDENTITY_EQUALS,
            ""Identity equality for arguments of types ''{0}'' and ''{1}'' is prohibited."",
            RENDER_TYPE,
            RENDER_TYPE
        )
        map.put(
            FORBIDDEN_IDENTITY_EQUALS_WARNING,
            ""Identity equality for arguments of types ''{0}'' and ''{1}'' is prohibited."",
            RENDER_TYPE,
            RENDER_TYPE
        )
        map.put(
            DEPRECATED_IDENTITY_EQUALS,
            ""Identity equality for arguments of types ''{0}'' and ''{1}'' is deprecated."",
            RENDER_TYPE,
            RENDER_TYPE
        )
        map.put(
            IMPLICIT_BOXING_IN_IDENTITY_EQUALS,
            ""Identity equality for arguments of types ''{0}'' and ''{1}'' can be unstable because of implicit boxing."",
            RENDER_TYPE,
            RENDER_TYPE
        )
        map.put(
            INC_DEC_SHOULD_NOT_RETURN_UNIT,
            ""Functions 'inc()' and 'dec()' cannot be used by the operators '++' and '--' when they return 'Unit'."",
        )
        map.put(
            ASSIGNMENT_OPERATOR_SHOULD_RETURN_UNIT,
            ""Function ''{0}'' must return ''Unit'' to be used by corresponding operator ''{1}''."",
            SYMBOL,
            TO_STRING,
        )
        map.put(
            INITIALIZER_REQUIRED_FOR_DESTRUCTURING_DECLARATION,
            ""Initializer required for destructuring declaration."",
        )
        map.put(
            NOT_FUNCTION_AS_OPERATOR,
            ""{0} ''{1}'' cannot be used as operator."",
            STRING,
            SYMBOL
        )
        map.put(
            DSL_SCOPE_VIOLATION,
            ""''{0}'' cannot be called in this context with an implicit receiver. Use an explicit receiver if necessary."",
            SYMBOL
        )
        map.put(
            RECEIVER_SHADOWED_BY_CONTEXT_PARAMETER,
            ""Call to {0} uses an implicit receiver shadowed by a context parameter. {1}"",
            SYMBOL_WITH_CONTAINING_DECLARATION,
            object : DiagnosticParameterRenderer<Boolean> {
                val contextParametersKey: RenderingContext.Key<List<String>> =
                    object : RenderingContext.Key<List<String>>(""contextParameters"") {
                        override fun compute(objectsToRender: Collection<Any?>): List<String> {
                            @Suppress(""UNCHECKED_CAST"")
                            val symbols = objectsToRender.last() as? List<FirValueParameterSymbol> ?: return emptyList()

                            return symbols
                                .map { if (it.name.isSpecial) ""contextOf<${it.resolvedReturnType.renderReadable()}>()"" else it.name.identifier }
                                .distinct()
                        }
                    }

                override fun render(
                    obj: Boolean,
                    renderingContext: RenderingContext,
                ): String {
                    val renderedContextParameters = renderingContext[contextParametersKey]
                    return if (obj) {
                        val contextParameterOptions = renderedContextParameters.joinToString(separator = "" / "") { ""'with($it) { ... }'"" }
                        ""Disambiguate the receiver by wrapping the call in 'with(this) { ... }' or $contextParameterOptions.""
                    } else {
                        val contextParameterOptions = renderedContextParameters.joinToString(separator = "" / "") { ""'$it'"" }
                        ""Make the receiver explicit using 'this' or $contextParameterOptions.""
                    }
                }
            },
            NOT_RENDERED,
        )

        // Type alias
        map.put(TOPLEVEL_TYPEALIASES_ONLY, ""Nested and local type aliases are not supported."")
        map.put(RECURSIVE_TYPEALIAS_EXPANSION, ""Recursive type alias in expansion."")
        map.put(
            TYPEALIAS_SHOULD_EXPAND_TO_CLASS,
            ""Type alias expands to ''{0}'', which is not a class, interface, or object."",
            RENDER_TYPE
        )
        map.put(
            CONSTRUCTOR_OR_SUPERTYPE_ON_TYPEALIAS_WITH_TYPE_PROJECTION,
            ""Type alias with type projection ('in', 'out' or '*') in expanded type in constructor call or supertype position. "" +
            ""See https://youtrack.jetbrains.com/issue/KT-60305.""
        )
        map.put(
            TYPEALIAS_EXPANSION_CAPTURES_OUTER_TYPE_PARAMETERS,
            ""Type alias expansion captures outer type parameters: {0}."",
            commaSeparated(SYMBOL_WITH_CONTAINING_DECLARATION),
        )

        // Returns
        map.put(RETURN_NOT_ALLOWED, ""'return' is prohibited here."")
        map.put(NOT_A_FUNCTION_LABEL, ""Target label does not denote a function."")
        map.put(
            RETURN_IN_FUNCTION_WITH_EXPRESSION_BODY,
            ""Returns are prohibited in functions with expression body. Use block body '{...}'.""
        )
        map.put(
            RETURN_IN_FUNCTION_WITH_EXPRESSION_BODY_WARNING,
            ""Return in function with expression body and without explicit return type. Use block body '{...}' or add an explicit return type.""
                .toDeprecationWarningMessage(LanguageFeature.ForbidReturnInExpressionBodyWithoutExplicitTypeEdgeCases)
        )
        map.put(
            RETURN_IN_FUNCTION_WITH_EXPRESSION_BODY_AND_IMPLICIT_TYPE,
            ""Returns are prohibited in functions with expression body and without explicit return type. Use block body '{...}' or add an explicit return type.""
        )
        map.put(NO_RETURN_IN_FUNCTION_WITH_BLOCK_BODY, ""Missing return statement."")
        map.put(REDUNDANT_RETURN, ""Return is redundant when used as expression body."")
        map.put(ANONYMOUS_INITIALIZER_IN_INTERFACE, ""Anonymous initializers in interfaces are prohibited."")

        // Inline
        map.put(
            USAGE_IS_NOT_INLINABLE,
            ""Illegal usage of inline parameter ''{0}''. Add ''noinline'' modifier to the parameter declaration."",
            SYMBOL
        )
        map.put(
            NON_LOCAL_RETURN_NOT_ALLOWED,
            ""Cannot inline ''{0}'' here: it might contain non-local returns. Add ''crossinline'' modifier to parameter declaration ''{0}''."",
            SYMBOL
        )
        map.put(RECURSION_IN_INLINE, ""Inline function ''{0}'' cannot be recursive."", SYMBOL)
        map.put(
            NON_PUBLIC_CALL_FROM_PUBLIC_INLINE, ""Public-API inline {1} cannot access non-public-API {0}."",
            SYMBOL_KIND,
            SYMBOL_KIND,
        )
        map.put(
            NON_PUBLIC_CALL_FROM_PUBLIC_INLINE_DEPRECATION,
            ""Public-API inline {1} cannot access non-public-API {0}."".toDeprecationWarningMessage(LanguageFeature.ProhibitPrivateOperatorCallInInline),
            SYMBOL_KIND,
            SYMBOL_KIND
        )
        map.put(
            NON_PUBLIC_INLINE_CALL_FROM_PUBLIC_INLINE,
            ""Public-API inline {1} cannot access non-public-API inline {0} as it could transitively access non-public-API declarations."",
            SYMBOL_KIND,
            SYMBOL_KIND,
        )
        map.put(
            NON_PUBLIC_DATA_COPY_CALL_FROM_PUBLIC_INLINE,
            ""This ''copy'' usage exposes the non-public primary constructor of a ''data class''. "" +
                    ""The ''copy'' will change its visibility in future versions of Kotlin. "" +
                    ""The public-API inline {0} will not be able to access non-public-API ''copy''. "" +
                    ""See https://youtrack.jetbrains.com/issue/KT-11914"",
            SYMBOL_KIND,
        )
        map.put(
            PROTECTED_CONSTRUCTOR_CALL_FROM_PUBLIC_INLINE,
            ""Protected constructor call from public-API inline {0} is deprecated."",
            SYMBOL_KIND,
            NOT_RENDERED,
        )
        map.put(
            PROTECTED_CALL_FROM_PUBLIC_INLINE_ERROR,
            ""Protected function call from public-API inline {0} is prohibited."",
            SYMBOL_KIND,
            NOT_RENDERED,
        )
        map.put(
            PRIVATE_CLASS_MEMBER_FROM_INLINE,
            ""Non-private inline function ''{1}'' cannot access members of private class ''{0}''."",
            SYMBOL,
            SYMBOL
        )
        map.put(NOT_YET_SUPPORTED_IN_INLINE, ""{0} are not yet supported in inline functions."", STRING)
        map.put(
            NOTHING_TO_INLINE,
            ""Expected performance impact from inlining is insignificant. Inlining works best for functions with parameters of function types.""
        )
        map.put(
            NULLABLE_INLINE_PARAMETER,
            ""Inline parameter ''{0}'' of ''{1}'' cannot be nullable. Add ''noinline'' modifier to the parameter declaration or make its type not nullable."",
            SYMBOL,
            SYMBOL
        )

        map.put(SUPER_CALL_FROM_PUBLIC_INLINE, ""Accessing super members from public-API inline {0} is deprecated."", SYMBOL_KIND)

        map.put(ILLEGAL_INLINE_PARAMETER_MODIFIER, ""Modifier is only allowed for function parameters of an inline function."")

        map.put(
            INLINE_SUSPEND_FUNCTION_TYPE_UNSUPPORTED,
            ""Suspend inline lambda parameters of non-suspend function type are not supported. Add 'noinline' or 'crossinline' modifier.""
        )

        map.put(
            INEFFICIENT_EQUALS_OVERRIDING_IN_VALUE_CLASS,
            ""Overriding ''equals'' from ''Any'' in value class without operator ''equals(other: {0}): Boolean'' leads to boxing on every equality comparison."",
            RENDER_TYPE
        )

        // Imports
        map.put(
            CANNOT_ALL_UNDER_IMPORT_FROM_SINGLETON,
            ""Cannot import on demand from object ''{0}''."",
            TO_STRING
        )
        map.put(PACKAGE_CANNOT_BE_IMPORTED, ""Packages cannot be imported."")
        map.put(
            CANNOT_BE_IMPORTED,
            ""Cannot import ''{0}''. Functions and properties can only be imported from packages or objects."",
            TO_STRING
        )
        map.put(
            CONFLICTING_IMPORT,
            ""Conflicting import: imported name ''{0}'' is ambiguous."",
            TO_STRING
        )
        map.put(OPERATOR_RENAMED_ON_IMPORT, ""Operator renamed to a different operator on import."")
        map.put(
            TYPEALIAS_AS_CALLABLE_QUALIFIER_IN_IMPORT,
            ""Cannot use typealias ''{0}'' as a callable qualifier in import. "" +
                    ""Use original class ''{1}'' instead or rewrite calls with ''{0}'' as a qualifier. "" +
                    ""See https://youtrack.jetbrains.com/issue/KT-64431."",
            NAME, NAME
        )

        // Suspend
        map.put(
            ILLEGAL_SUSPEND_FUNCTION_CALL,
            ""Suspend function ''{0}'' can only be called from a coroutine or another suspend function."",
            SYMBOL
        )
        map.put(
            ILLEGAL_SUSPEND_PROPERTY_ACCESS,
            ""Suspend property ''{0}'' can only be accessed from a coroutine or suspend function."",
            SYMBOL
        )
        map.put(NON_LOCAL_SUSPENSION_POINT, ""Suspension functions can only be called within coroutine body."")
        map.put(
            ILLEGAL_RESTRICTED_SUSPENDING_FUNCTION_CALL,
            ""Restricted suspending functions can invoke member or extension suspending functions only on their restricted coroutine scope.""
        )
        map.put(
            NON_MODIFIER_FORM_FOR_BUILT_IN_SUSPEND,
            ""'suspend' function can only be called in the form of a modifier of a lambda: suspend { ... }.""
        )
        map.put(
            MODIFIER_FORM_FOR_NON_BUILT_IN_SUSPEND,
            ""Calls in the form of 'suspend {}' are deprecated because 'suspend' in this context will have the meaning of a modifier. Surround the lambda with parentheses: 'suspend({ ... })'.""
        )
        map.put(
            MODIFIER_FORM_FOR_NON_BUILT_IN_SUSPEND_FUN,
            ""Calls in the form of 'suspend fun' are deprecated because 'suspend' in the context will have the meaning of a modifier. Surround the argument of the call with parentheses: 'suspend(fun() { ... })'."" +
            "" See https://youtrack.jetbrains.com/issue/KT-49264""
        )
        map.put(RETURN_FOR_BUILT_IN_SUSPEND, ""Using implicit label for this lambda is prohibited."")
        map.put(MIXING_SUSPEND_AND_NON_SUSPEND_SUPERTYPES, ""Mixing suspend and non-suspend supertypes is not allowed."")
        map.put(
            MIXING_FUNCTIONAL_KINDS_IN_SUPERTYPES,
            ""Mixing supertypes of different functional kinds ({0}) is not allowed."",
            FUNCTIONAL_TYPE_KINDS,
        )

        // Label
        map.put(
            REDUNDANT_LABEL_WARNING,
            ""Label is redundant, because it cannot be referenced in a 'break', 'continue', or 'return' expression.""
        )

        map.put(MULTIPLE_LABELS_ARE_FORBIDDEN, ""Multiple labels per statement are forbidden."")

        // Enum entries deprecations
        map.put(
            DEPRECATED_ACCESS_TO_ENUM_ENTRY_COMPANION_PROPERTY,
            ""Ambiguous access to the enum companion's property 'entries' is deprecated. Add the explicit 'Companion' qualifier to the class name.""
        )
        map.put(
            DEPRECATED_ACCESS_TO_ENTRY_PROPERTY_FROM_ENUM,
            ""Ambiguous access to the 'entries' property from within the enum is deprecated. Add an explicit qualifier to the call.""
        )
        map.put(
            DEPRECATED_ACCESS_TO_ENTRIES_PROPERTY,
            ""Ambiguous access to the 'entries' property is deprecated. In the future, it will be shadowed by enum 'entries' property. Ambiguity can be resolved by adding explicit qualifier to the call.""
        )
        map.put(
            DEPRECATED_ACCESS_TO_ENUM_ENTRY_PROPERTY_AS_REFERENCE,
            ""Ambiguous access to the 'entries' property is deprecated. Specify the type of the referenced expression explicitly.""
        )
        map.put(
            DEPRECATED_ACCESS_TO_ENTRIES_AS_QUALIFIER,
            ""Ambiguous access to the 'entries' qualifier is deprecated. In the future, it will be shadowed by enum 'entries' property. Ambiguity can be resolved by renaming conflicting declaration.""
        )
        map.put(
            DECLARATION_OF_ENUM_ENTRY_ENTRIES,
            ""Conflicting declarations: the enum entry 'entries' and the property 'Enum.entries' (KT-48872).""
        )

        // Extra checkers group
        map.put(REDUNDANT_VISIBILITY_MODIFIER, ""Redundant visibility modifier."")
        map.put(REDUNDANT_MODALITY_MODIFIER, ""Redundant modality modifier."")
        map.put(REDUNDANT_RETURN_UNIT_TYPE, ""Redundant return 'Unit' type."")
        map.put(REDUNDANT_SINGLE_EXPRESSION_STRING_TEMPLATE, ""Redundant string template."")
        map.put(CAN_BE_VAL, ""This 'var' property is never written to, it can be declared as 'val'."")
        map.put(CAN_BE_VAL_LATEINIT, ""This 'lateinit var' property is not written to more than once, it can be declared as nullable 'val'."")
        map.put(CAN_BE_VAL_DELAYED_INITIALIZATION, ""This 'var' property is not written to more than once, it can be declared as 'val'."")
        map.put(REDUNDANT_CALL_OF_CONVERSION_METHOD, ""Redundant call of conversion method."")
        map.put(ARRAY_EQUALITY_OPERATOR_CAN_BE_REPLACED_WITH_CONTENT_EQUALS, ""'==' on arrays compares only references. Replace '==' with 'contentEquals' to compare the arrays' contents or use `===` to remove the warning."")
        map.put(EMPTY_RANGE, ""Range is empty."")
        map.put(REDUNDANT_SETTER_PARAMETER_TYPE, ""Redundant setter parameter type."")
        map.put(UNUSED_VARIABLE, ""Variable is unused."")
        map.put(ASSIGNED_VALUE_IS_NEVER_READ, ""Assigned value is never read."")
        map.put(VARIABLE_INITIALIZER_IS_REDUNDANT, ""Initializer is redundant."")
        map.put(VARIABLE_NEVER_READ, ""Variable is never read."")
        map.put(USELESS_CALL_ON_NOT_NULL, ""Unnecessary call on a non-null value."")
        map.put(UNUSED_ANONYMOUS_PARAMETER, ""Parameter ''{0}'' is never used, consider renaming it to ''_''."", SYMBOL)
        map.put(UNUSED_EXPRESSION, ""Expression is unused."")
        map.put(UNUSED_LAMBDA_EXPRESSION, ""Lambda expression is never invoked. To create a scoped block, use 'run { ... }'."")

        // Compatibility issues group
        map.put(
            INCOMPATIBLE_CLASS,
            ""{0} was compiled with an incompatible version of Kotlin. {1}"",
            STRING,
            Renderer { incompatibility: IncompatibleVersionErrorData<*> ->
                ""The actual metadata version is ${incompatibility.actualVersion}, "" +
                        ""but the compiler version ${incompatibility.compilerVersion}"" +
                        (if (incompatibility.languageVersion == incompatibility.compilerVersion) """" else "" [with language version "" + incompatibility.languageVersion + ""]"") +
                        "" can read versions up to ${incompatibility.expectedVersion}.\n"" +
                        ""The class is loaded from ${FileUtil.toSystemIndependentName(incompatibility.filePath)}""
            }
        )
        map.put(
            PRE_RELEASE_CLASS,
            ""{0} was compiled by a pre-release version of Kotlin and cannot be loaded by this version of the compiler.{1}"",
            STRING,
            Renderer { args: List<String> ->
                if (args.isNotEmpty()) "" Enabled pre-release features: ${args.joinToString()}"" else """"

            }
        )
        map.put(
            IR_WITH_UNSTABLE_ABI_COMPILED_CLASS,
            ""{0} is compiled by an unstable version of the Kotlin compiler and cannot be loaded by this compiler."",
            STRING
        )

        map.put(
            BUILDER_INFERENCE_STUB_RECEIVER,
            ""The type of a receiver hasn''t been inferred yet. Specify type argument for generic parameter ''{0}'' of ''{1}'' explicitly."",
            TO_STRING,
            TO_STRING
        )
        map.put(
            BUILDER_INFERENCE_MULTI_LAMBDA_RESTRICTION,
            ""Unstable inference behaviour with multiple lambdas. Specify the type argument for generic parameter ''{0}'' of ''{1}'' explicitly."",
            TO_STRING,
            TO_STRING
        )
    }
}
",KOT_02298,CWE-321: Hard-coded Cryptographic Key,A02: Cryptographic Failures;A04: Insecure Design,1
