function,label
"import type { SignatureAlgorithm } from './jwa'
import { signing, verifying } from './jws'
import type { HonoJsonWebKey, SignatureKey } from './jws'
import {
  JwtHeaderInvalid,
  JwtHeaderRequiresKid,
  JwtTokenExpired,
  JwtTokenInvalid,
  JwtTokenIssuedAt,
  JwtTokenIssuer,
  JwtTokenNotBefore,
  JwtTokenSignatureMismatched,
} from './types'
import type { JWTPayload } from './types'
import { utf8Decoder, utf8Encoder } from './utf8'

const encodeJwtPart = (part: unknown): string =>
  encodeBase64Url(utf8Encoder.encode(JSON.stringify(part)).buffer).replace(/=/g, '')
const encodeSignaturePart = (buf: ArrayBufferLike): string => encodeBase64Url(buf).replace(/=/g, '')

const decodeJwtPart = (part: string): TokenHeader | JWTPayload | undefined =>
  JSON.parse(utf8Decoder.decode(decodeBase64Url(part)))

export interface TokenHeader {
  alg: SignatureAlgorithm
  typ?: 'JWT'
  kid?: string
}

export function isTokenHeader(obj: unknown): obj is TokenHeader {
  if (typeof obj === 'object' && obj !== null) {
    const objWithAlg = obj as { [key: string]: unknown }
    return (
      'alg' in objWithAlg &&
      Object.values(AlgorithmTypes).includes(objWithAlg.alg as AlgorithmTypes) &&
      (!('typ' in objWithAlg) || objWithAlg.typ === 'JWT')
    )
  }
  return false
}

export const sign = async (
  payload: JWTPayload,
  privateKey: SignatureKey,
  alg: SignatureAlgorithm = 'HS256'
): Promise<string> => {
  const encodedPayload = encodeJwtPart(payload)
  let encodedHeader
  if (typeof privateKey === 'object' && 'alg' in privateKey) {
    alg = privateKey.alg as SignatureAlgorithm
    encodedHeader = encodeJwtPart({ alg, typ: 'JWT', kid: privateKey.kid })
  } else {
    encodedHeader = encodeJwtPart({ alg, typ: 'JWT' })
  }

  const partialToken = `${encodedHeader}.${encodedPayload}`

  const signaturePart = await signing(privateKey, alg, utf8Encoder.encode(partialToken))
  const signature = encodeSignaturePart(signaturePart)

  return `${partialToken}.${signature}`
}

export type VerifyOptions = {
  /** The expected issuer used for verifying the token */
  iss?: string | RegExp
  /** Verify the `nbf` claim (default: `true`) */
  nbf?: boolean
  /** Verify the `exp` claim (default: `true`) */
  exp?: boolean
  /** Verify the `iat` claim (default: `true`) */
  iat?: boolean
}

export type VerifyOptionsWithAlg = {
  /** The algorithm used for decoding the token */
  alg?: SignatureAlgorithm
} & VerifyOptions

type StrictVerifyOptions = {
  iss?: string | RegExp
  nbf: boolean
  exp: boolean
  iat: boolean
}

type StrictVerifyOptionsWithAlg = {
  alg: SignatureAlgorithm
} & StrictVerifyOptions

export const verify = async (
  token: string,
  publicKey: SignatureKey,
  algOrOptions?: SignatureAlgorithm | VerifyOptionsWithAlg
): Promise<JWTPayload> => {
  const optsIn = typeof algOrOptions === 'string' ? { alg: algOrOptions } : algOrOptions || {}
  const opts: StrictVerifyOptionsWithAlg = {
    alg: optsIn.alg ?? 'HS256',
    iss: optsIn.iss,
    nbf: optsIn.nbf ?? true,
    exp: optsIn.exp ?? true,
    iat: optsIn.iat ?? true,
  }

  const tokenParts = token.split('.')
  if (tokenParts.length !== 3) {
    throw new JwtTokenInvalid(token)
  }

  const { header, payload } = decode(token)
  if (!isTokenHeader(header)) {
    throw new JwtHeaderInvalid(header)
  }
  const now = (Date.now() / 1000) | 0
  if (opts.nbf && payload.nbf && payload.nbf > now) {
    throw new JwtTokenNotBefore(token)
  }
  if (opts.exp && payload.exp && payload.exp <= now) {
    throw new JwtTokenExpired(token)
  }
  if (opts.iat && payload.iat && now < payload.iat) {
    throw new JwtTokenIssuedAt(now, payload.iat)
  }
  if (opts.iss) {
    if (!payload.iss) {
      throw new JwtTokenIssuer(opts.iss, null)
    }
    if (typeof opts.iss === 'string' && payload.iss !== opts.iss) {
      throw new JwtTokenIssuer(opts.iss, payload.iss)
    }
    if (opts.iss instanceof RegExp && !opts.iss.test(payload.iss)) {
      throw new JwtTokenIssuer(opts.iss, payload.iss)
    }
  }

  const headerPayload = token.substring(0, token.lastIndexOf('.'))
  const verified = await verifying(
    publicKey,
    opts.alg,
    decodeBase64Url(tokenParts[2]),
    utf8Encoder.encode(headerPayload)",1
"                    await transport.handlePostMessage(mockReq, mockHandleRes, { jsonrpc: '2.0', method: 'test' });

                    expect(mockHandleRes.writeHead).toHaveBeenCalledWith(202);
                    expect(mockHandleRes.end).toHaveBeenCalledWith('Accepted');
                });

                it('should reject requests with disallowed origin headers', async () => {
                    const mockRes = createMockResponse();
                    const transport = new SSEServerTransport('/messages', mockRes, {
                        allowedOrigins: ['http://localhost:3000'],
                        enableDnsRebindingProtection: true
                    });",1
"      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-transaction',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: expect.stringMatching(/[a-f0-9]{32}/),
    origin: 'auto.http.otel.http',",1
"import { ROOT_USER_ID } from ""../constants/idp"";
import { ClientIdentityProviderUser, IdentityProviderUser, User } from ""../models/idp.model"";

export function checkUserForRoles(user: IdentityProviderUser | ClientIdentityProviderUser | User | ClientIdentityProviderUser, roleIds: string[]) {
  if (!user) {
    return false;
  }

  // It's assumed that the root user has all roles
  if (user.id === ROOT_USER_ID) {
    return true;
  }
  
  const userRoleIds = (('roles' in user ? user.roles?.map(r => r.id) : user.roleIds) || []).map(v => v.toString());
  return roleIds.some(rid => userRoleIds.includes(rid.toString()));
}",1
"		// We already have a middleware that checks if there's an incoming URL that has invalid URI, so it's safe
		// to not handle the error: packages/astro/src/vite-plugin-astro-server/base.ts
		pathname = decodeURI(url.pathname);
	}

	// Add config.base back to url before passing it to SSR
	url.pathname = removeTrailingForwardSlash(config.base) + url.pathname;

	// Apply trailing slash configuration consistently
	if (config.trailingSlash === 'never') {
		url.pathname = removeTrailingForwardSlash(url.pathname);
	} else if (config.trailingSlash === 'always' && !hasFileExtension(url.pathname)) {
		url.pathname = appendForwardSlash(url.pathname);",1
"                        : true,
                dateStrings: options.dateStrings,
                debug: options.debug,
                trace: options.trace,
                multipleStatements: options.multipleStatements,
                flags: options.flags,
            },
            {
                host: credentials.host,
                user: credentials.username,
                password: credentials.password,
                database: credentials.database,
                port: credentials.port,
                ssl: options.ssl,
                socketPath: credentials.socketPath,
            },
            options.acquireTimeout === undefined
                ? {}
                : { acquireTimeout: options.acquireTimeout },
            { connectionLimit: options.poolSize },
            options.extra || {},
        )
    }

    /**
     * Creates a new connection pool for a given database credentials.",1
"import { DashboardPageConfig, DashboardPageConfigCard, DashboardPageConfigStat } from ""./dashboardPage.model"";
import { RelationalDatabaseSchema } from ""./databaseSchema.model"";
import { DataSourceType, PublicDataSource } from ""./dataSource.model"";
import { Page, PageFileStructure } from ""./page.model"";
import { TablePageConfig } from ""./tablePage.model"";
import { Template } from ""./template.model"";
import { ClientIdentityProviderRole, ClientIdentityProviderUser, IdentityProviderUserPermission, User } from ""./idp.model"";

export interface InternalApiSchema {
  getUsers: {
    body: unknown;
    result: {
      users: ClientIdentityProviderUser[];
    };
  };

  createUser: {
    body: {
      user: Pick<ClientIdentityProviderUser, 'firstName' | 'email' | 'avatarUrl' | 'lastName' | 'username' | 'roleIds' | 'temporaryPassword'>;
      password: string;
    };
    result: {
      user: ClientIdentityProviderUser;
    };
  };

  updateUser: {
    body: {
      userId: ClientIdentityProviderUser['id'];
      user: Partial<ClientIdentityProviderUser>;
      newPassword?: string;
    };
    result: {
      user: ClientIdentityProviderUser;
    };
  };

  deleteUser: {
    body: {
      userId: ClientIdentityProviderUser['id'];
    };
    result: void;
  };

  createRole: {
    body: {
      role: Pick<ClientIdentityProviderRole, 'name' | 'permissions'>;
    };
    result: {
      role: ClientIdentityProviderRole;
    };
  };

  updateRole: {
    body: {
      roleId: ClientIdentityProviderRole['id'];
      role: Partial<ClientIdentityProviderRole>;
    };
    result: {
      role: ClientIdentityProviderRole;
    };
  };

  deleteRole: {
    body: {
      roleId: ClientIdentityProviderRole['id'];
    };
    result: void;
  };

  getApp: {
    body: unknown;
    result: {
      schema: ClientAppSchema; 

      // Pass only if user is authenticated
      user?: ClientIdentityProviderUser;
      roles?: ClientIdentityProviderRole[];
      userPermissions?: (keyof typeof IdentityProviderUserPermission | string)[];
    };
  };

  generateSql: {",1
"    appName?: string;
    authMechanism?: string;
    authMechanismProperties?: any;
    authSource?: string;
    autoSelectFamily?: boolean;
    autoSelectFamilyAttemptTimeout?: number;
    compressors?: string[] | string;
    connectTimeoutMS?: number;
    directConnection?: boolean;
    forceServerObjectId?: boolean;
    heartbeatFrequencyMS?: number;
    loadBalanced?: boolean;",1
"            }
        }

        // Validate Origin header if allowedOrigins is configured
        if (this._allowedOrigins && this._allowedOrigins.length > 0) {
            const originHeader = req.headers.origin;
            if (!originHeader || !this._allowedOrigins.includes(originHeader)) {
                return `Invalid Origin header: ${originHeader}`;
            }
        }

        return undefined;
    }",1
"			testUser2.email,
			otp,
			""email-verification"",
		);
	});

	it(""should send forget password otp"", async () => {
		await client.emailOtp.sendVerificationOtp({
			email: testUser.email,
			type: ""forget-password"",
		});
	});

	it(""should reset password"", async () => {
		await client.emailOtp.resetPassword({
			email: testUser.email,
			otp,
			password: ""changed-password"",
		});
		const { data } = await client.signIn.email({
			email: testUser.email,
			password: ""changed-password"",
		});
		expect(data?.user).toBeDefined();
	});
",1
"	/**
	 * Whether to disable HTML sandboxing for webhooks. The sandboxing mechanism uses CSP headers now,
	 * but the name is kept for backwards compatibility.
	 */
	@Env('N8N_INSECURE_DISABLE_WEBHOOK_IFRAME_SANDBOX')
	disableWebhookHtmlSandboxing: boolean = false;
}",1
export const VERSION = '3.3.1';,1
"import { inspect } from 'util';

export function handleError(func) {
  return (req, res) => {
    func(req, res).catch(err => {
      console.log('Error', req.originalUrl, inspect(err, { depth: null }));
      res.send({
        status: 'ok',
        data: {
          error_code: 'INTERNAL_ERROR',
          error_type: err.message ? err.message : 'internal-error',
        },",1
"import { IdentityProviderUser, IdentityProviderUserPermission, InternalApiBody, InternalApiResult } from ""@kottster/common"";
import { Action } from ""../models/action.model"";

/**
 * Update the user
 */
export class UpdateUser extends Action {
  public async execute({ userId, user, newPassword }: InternalApiBody<'updateUser'>, currentUser: IdentityProviderUser): Promise<InternalApiResult<'updateUser'>> {
    const hasPermission = await this.app.identityProvider.userHasPermissions(currentUser.id, [IdentityProviderUserPermission.manage_users]);
    if (!hasPermission && currentUser.id !== userId) {
      throw new Error(""You don't have permission to update this user"");
    }

    const updatedUser = await this.app.identityProvider.updateUser(userId, user);",1
"						host: 'example.com',
						'x-forwarded-host': ':123',
					},
				});
				assert.equal(result.url, 'https://example.com/');
			});
		});

		describe('x-forwarded-proto', () => {
			it('parses protocol from single-value x-forwarded-proto header', () => {
				const result = NodeApp.createRequest({
					...mockNodeRequest,
					headers: {
						host: 'example.com',
						'x-forwarded-proto': 'http',
						'x-forwarded-port': '80',
					},
				});
				assert.equal(result.url, 'http://example.com/');
			});

			it('parses protocol from multi-value x-forwarded-proto header', () => {
				const result = NodeApp.createRequest({
					...mockNodeRequest,
					headers: {
						host: 'example.com',
						'x-forwarded-proto': 'http,https',
						'x-forwarded-port': '80,443',
					},
				});
				assert.equal(result.url, 'http://example.com/');
			});

			it('fallbacks to encrypted property when no x-forwarded-proto header is present', () => {
				const result = NodeApp.createRequest({
					...mockNodeRequest,
					headers: {
						host: 'example.com',
					},
				});
				assert.equal(result.url, 'https://example.com/');
			});
		});

		describe('x-forwarded-port', () => {
			it('parses port from single-value x-forwarded-port header', () => {
				const result = NodeApp.createRequest({
					...mockNodeRequest,
					headers: {
						host: 'example.com',
						'x-forwarded-port': '8443',
					},
				});
				assert.equal(result.url, 'https://example.com:8443/');
			});

			it('parses port from multi-value x-forwarded-port header', () => {
				const result = NodeApp.createRequest({
					...mockNodeRequest,
					headers: {
						host: 'example.com',
						'x-forwarded-port': '8443,3000',
					},
				});
				assert.equal(result.url, 'https://example.com:8443/');
			});

			it('prefers port from host', () => {
				const result = NodeApp.createRequest({
					...mockNodeRequest,
					headers: {
						host: 'example.com:3000',
						'x-forwarded-port': '443',
					},
				});
				assert.equal(result.url, 'https://example.com:3000/');
			});

			it('prefers port from x-forwarded-host', () => {
				const result = NodeApp.createRequest(
					{
						...mockNodeRequest,
						headers: {
							host: 'example.com:443',
							'x-forwarded-host': 'example.com:3000',
							'x-forwarded-port': '443',
						},
					},
					{ allowedDomains: [{ hostname: 'example.com' }] },
				);
				assert.equal(result.url, 'https://example.com:3000/');
			});",1
"      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-transaction',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: expect.stringMatching(/[a-f0-9]{32}/),
    origin: 'auto.http.otel.http',",1
"    const fileCreator = new FileCreator({
      projectDir,
      usingTsc: projectSetupData.useTypeScript,
    })
    fileCreator.createProject({
      projectName,
    })

    if (options.skipInstall || projectSetupData.skipPackageInstallation) {
      // Skip package installation
      console.log(chalk.yellow('Skipping package installation'))
    } else {",1
"    moduleName: CORE,
  };

  // sanitization-related functions
  static sanitizeHtml: o.ExternalReference = {name: 'ɵɵsanitizeHtml', moduleName: CORE};
  static sanitizeStyle: o.ExternalReference = {name: 'ɵɵsanitizeStyle', moduleName: CORE};
  static sanitizeResourceUrl: o.ExternalReference = {
    name: 'ɵɵsanitizeResourceUrl',
    moduleName: CORE,
  };
  static sanitizeScript: o.ExternalReference = {name: 'ɵɵsanitizeScript', moduleName: CORE};
  static sanitizeUrl: o.ExternalReference = {name: 'ɵɵsanitizeUrl', moduleName: CORE};
  static sanitizeUrlOrResourceUrl: o.ExternalReference = {
    name: 'ɵɵsanitizeUrlOrResourceUrl',
    moduleName: CORE,
  };
  static trustConstantHtml: o.ExternalReference = {name: 'ɵɵtrustConstantHtml', moduleName: CORE};
  static trustConstantResourceUrl: o.ExternalReference = {
    name: 'ɵɵtrustConstantResourceUrl',
    moduleName: CORE,
  };
  static validateIframeAttribute: o.ExternalReference = {
    name: 'ɵɵvalidateIframeAttribute',
    moduleName: CORE,
  };

  // Decorators
  static inputDecorator: o.ExternalReference = {name: 'Input', moduleName: CORE};
  static outputDecorator: o.ExternalReference = {name: 'Output', moduleName: CORE};
  static viewChildDecorator: o.ExternalReference = {name: 'ViewChild', moduleName: CORE};
  static viewChildrenDecorator: o.ExternalReference = {name: 'ViewChildren', moduleName: CORE};",1
"  setCapturedScopesOnSpan,
  startSpan,
  vercelWaitUntil,
  winterCGRequestToRequestData,
  withIsolationScope,
} from '@sentry/core';
import { flushSafelyWithTimeout } from '../common/utils/responseEnd';
import type { EdgeRouteHandler } from '../edge/types';

/**
 * Wraps Next.js middleware with Sentry error and performance instrumentation.
 *
 * @param middleware The middleware handler.
 * @returns a wrapped middleware handler.
 */
export function wrapMiddlewareWithSentry<H extends EdgeRouteHandler>(
  middleware: H,
): (...params: Parameters<H>) => Promise<ReturnType<H>> {
  return new Proxy(middleware, {
    apply: async (wrappingTarget, thisArg, args: Parameters<H>) => {
      const tunnelRoute =
        '_sentryRewritesTunnelPath' in globalThis
          ? (globalThis as Record<string, unknown>)._sentryRewritesTunnelPath
          : undefined;

      if (tunnelRoute && typeof tunnelRoute === 'string') {
        const req: unknown = args[0];
        // Check if the current request matches the tunnel route
        if (req instanceof Request) {
          const url = new URL(req.url);
          const isTunnelRequest = url.pathname.startsWith(tunnelRoute);

          if (isTunnelRequest) {
            // Create a simple response that mimics NextResponse.next() so we don't need to import internals here
            // which breaks next 13 apps
            // https://github.com/vercel/next.js/blob/c12c9c1f78ad384270902f0890dc4cd341408105/packages/next/src/server/web/spec-extension/response.ts#L146
            return new Response(null, {
              status: 200,
              headers: {
                'x-middleware-next': '1',
              },
            }) as ReturnType<H>;
          }
        }
      }
      // TODO: We still should add central isolation scope creation for when our build-time instrumentation does not work anymore with turbopack.
      return withIsolationScope(isolationScope => {
        const req: unknown = args[0];
        const currentScope = getCurrentScope();

        let spanName: string;
        let spanSource: TransactionSource;

        if (req instanceof Request) {
          isolationScope.setSDKProcessingMetadata({
            normalizedRequest: winterCGRequestToRequestData(req),
          });
          spanName = `middleware ${req.method} ${new URL(req.url).pathname}`;
          spanSource = 'url';
        } else {
          spanName = 'middleware';
          spanSource = 'component';
        }

        currentScope.setTransactionName(spanName);

        const activeSpan = getActiveSpan();

        if (activeSpan) {
          // If there is an active span, it likely means that the automatic Next.js OTEL instrumentation worked and we can
          // rely on that for parameterization.
          spanName = 'middleware';
          spanSource = 'component';

          const rootSpan = getRootSpan(activeSpan);
          if (rootSpan) {
            setCapturedScopesOnSpan(rootSpan, currentScope, isolationScope);
          }
        }

        return startSpan(
          {
            name: spanName,
            op: 'http.server.middleware',
            attributes: {
              [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: spanSource,
              [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.nextjs.wrapMiddlewareWithSentry',
            },
          },
          () => {
            return handleCallbackErrors(
              () => wrappingTarget.apply(thisArg, args),
              error => {",1
"  it('does not apply XSRF protection when request is a HEAD', () => {
    interceptor.intercept(new HttpRequest('HEAD', '/test'), backend).subscribe();
    const req = backend.expectOne('/test');
    expect(req.request.headers.has('X-XSRF-TOKEN')).toEqual(false);
    req.flush({});
  });
  it('does not overwrite existing header', () => {
    interceptor
      .intercept(
        new HttpRequest(
          'POST',
          '/test',",1
"import type { SignatureAlgorithm } from './jwa'
import { signing, verifying } from './jws'
import type { HonoJsonWebKey, SignatureKey } from './jws'
import {
  JwtHeaderInvalid,
  JwtHeaderRequiresKid,
  JwtPayloadRequiresAud,
  JwtTokenAudience,
  JwtTokenExpired,
  JwtTokenInvalid,
  JwtTokenIssuedAt,
  JwtTokenIssuer,
  JwtTokenNotBefore,
  JwtTokenSignatureMismatched,
} from './types'
import type { JWTPayload } from './types'
import { utf8Decoder, utf8Encoder } from './utf8'

const encodeJwtPart = (part: unknown): string =>
  encodeBase64Url(utf8Encoder.encode(JSON.stringify(part)).buffer).replace(/=/g, '')
const encodeSignaturePart = (buf: ArrayBufferLike): string => encodeBase64Url(buf).replace(/=/g, '')

const decodeJwtPart = (part: string): TokenHeader | JWTPayload | undefined =>
  JSON.parse(utf8Decoder.decode(decodeBase64Url(part)))

export interface TokenHeader {
  alg: SignatureAlgorithm
  typ?: 'JWT'
  kid?: string
}

export function isTokenHeader(obj: unknown): obj is TokenHeader {
  if (typeof obj === 'object' && obj !== null) {
    const objWithAlg = obj as { [key: string]: unknown }
    return (
      'alg' in objWithAlg &&
      Object.values(AlgorithmTypes).includes(objWithAlg.alg as AlgorithmTypes) &&
      (!('typ' in objWithAlg) || objWithAlg.typ === 'JWT')
    )
  }
  return false
}

export const sign = async (
  payload: JWTPayload,
  privateKey: SignatureKey,
  alg: SignatureAlgorithm = 'HS256'
): Promise<string> => {
  const encodedPayload = encodeJwtPart(payload)
  let encodedHeader
  if (typeof privateKey === 'object' && 'alg' in privateKey) {
    alg = privateKey.alg as SignatureAlgorithm
    encodedHeader = encodeJwtPart({ alg, typ: 'JWT', kid: privateKey.kid })
  } else {
    encodedHeader = encodeJwtPart({ alg, typ: 'JWT' })
  }

  const partialToken = `${encodedHeader}.${encodedPayload}`

  const signaturePart = await signing(privateKey, alg, utf8Encoder.encode(partialToken))
  const signature = encodeSignaturePart(signaturePart)

  return `${partialToken}.${signature}`
}

export type VerifyOptions = {
  /** The expected issuer used for verifying the token */
  iss?: string | RegExp
  /** Verify the `nbf` claim (default: `true`) */
  nbf?: boolean
  /** Verify the `exp` claim (default: `true`) */
  exp?: boolean
  /** Verify the `iat` claim (default: `true`) */
  iat?: boolean
  /** Acceptable audience(s) for the token */
  aud?: string | string[] | RegExp
}

export type VerifyOptionsWithAlg = {
  /** The algorithm used for decoding the token */
  alg?: SignatureAlgorithm
} & VerifyOptions

type StrictVerifyOptions = {
  iss?: string | RegExp
  nbf: boolean
  exp: boolean
  iat: boolean
  aud?: string | string[] | RegExp
}

type StrictVerifyOptionsWithAlg = {
  alg: SignatureAlgorithm
} & StrictVerifyOptions

export const verify = async (
  token: string,
  publicKey: SignatureKey,
  algOrOptions?: SignatureAlgorithm | VerifyOptionsWithAlg
): Promise<JWTPayload> => {
  const optsIn = typeof algOrOptions === 'string' ? { alg: algOrOptions } : algOrOptions || {}
  const opts: StrictVerifyOptionsWithAlg = {
    alg: optsIn.alg ?? 'HS256',
    iss: optsIn.iss,
    nbf: optsIn.nbf ?? true,
    exp: optsIn.exp ?? true,
    iat: optsIn.iat ?? true,
    aud: optsIn.aud,
  }

  const tokenParts = token.split('.')
  if (tokenParts.length !== 3) {
    throw new JwtTokenInvalid(token)
  }

  const { header, payload } = decode(token)
  if (!isTokenHeader(header)) {
    throw new JwtHeaderInvalid(header)
  }
  const now = (Date.now() / 1000) | 0
  if (opts.nbf && payload.nbf && payload.nbf > now) {
    throw new JwtTokenNotBefore(token)
  }
  if (opts.exp && payload.exp && payload.exp <= now) {
    throw new JwtTokenExpired(token)
  }
  if (opts.iat && payload.iat && now < payload.iat) {
    throw new JwtTokenIssuedAt(now, payload.iat)
  }
  if (opts.iss) {
    if (!payload.iss) {
      throw new JwtTokenIssuer(opts.iss, null)
    }
    if (typeof opts.iss === 'string' && payload.iss !== opts.iss) {
      throw new JwtTokenIssuer(opts.iss, payload.iss)
    }
    if (opts.iss instanceof RegExp && !opts.iss.test(payload.iss)) {
      throw new JwtTokenIssuer(opts.iss, payload.iss)
    }
  }

  if (opts.aud) {
    if (!payload.aud) {
      throw new JwtPayloadRequiresAud(payload)
    }
  }

  if (payload.aud) {
    const audiences = Array.isArray(payload.aud) ? payload.aud : [payload.aud]
    const matched = audiences.some((aud): boolean => {
      if (opts.aud instanceof RegExp && opts.aud.test(aud)) {
        return true
      } else if (typeof opts.aud === 'string') {
        if (aud === opts.aud) {
          return true
        }
      } else if (Array.isArray(opts.aud)) {
        if (opts.aud.includes(aud)) {
          return true
        }
      }
      return false
    })
    if (opts.aud && !matched) {
      throw new JwtTokenAudience(opts.aud, payload.aud)
    }
  }

  const headerPayload = token.substring(0, token.lastIndexOf('.'))
  const verified = await verifying(
    publicKey,
    opts.alg,
    decodeBase64Url(tokenParts[2]),
    utf8Encoder.encode(headerPayload)",0
"                    await transport.handlePostMessage(mockReq, mockHandleRes, { jsonrpc: '2.0', method: 'test' });

                    expect(mockHandleRes.writeHead).toHaveBeenCalledWith(202);
                    expect(mockHandleRes.end).toHaveBeenCalledWith('Accepted');
                });

                it('should accept requests without origin headers', async () => {
                    const mockRes = createMockResponse();
                    const transport = new SSEServerTransport('/messages', mockRes, {
                        allowedOrigins: ['http://localhost:3000', 'https://example.com'],
                        enableDnsRebindingProtection: true
                    });
                    await transport.start();

                    const mockReq = createMockRequest({
                        headers: {
                            'content-type': 'application/json'
                        }
                    });
                    const mockHandleRes = createMockResponse();

                    await transport.handlePostMessage(mockReq, mockHandleRes, { jsonrpc: '2.0', method: 'test' });

                    expect(mockHandleRes.writeHead).toHaveBeenCalledWith(202);
                    expect(mockHandleRes.end).toHaveBeenCalledWith('Accepted');
                });

                it('should reject requests with disallowed origin headers', async () => {
                    const mockRes = createMockResponse();
                    const transport = new SSEServerTransport('/messages', mockRes, {
                        allowedOrigins: ['http://localhost:3000'],
                        enableDnsRebindingProtection: true
                    });",0
"      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-transaction',
      'http.request.header.accept': '*/*',
      'http.request.header.accept_encoding': 'gzip, deflate',
      'http.request.header.accept_language': '*',
      'http.request.header.connection': 'keep-alive',
      'http.request.header.host': expect.any(String),
      'http.request.header.sec_fetch_mode': 'cors',
      'http.request.header.user_agent': 'node',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: expect.stringMatching(/[a-f0-9]{32}/),
    origin: 'auto.http.otel.http',",0
"import { ROOT_USER_ID } from ""../constants/idp"";
import { ClientIdentityProviderRole, ClientIdentityProviderUser, IdentityProviderRole, IdentityProviderUser, User } from ""../models/idp.model"";

type UnifiedUser = IdentityProviderUser | ClientIdentityProviderUser | User | ClientIdentityProviderUser;

type UnifiedRole = IdentityProviderRole | ClientIdentityProviderRole;

/**
 * Checks if the user has at least one of the specified roles.
 * @description Role IDs properties have been replaced with role names. This function supports both for backward compatibility.
 */
export function checkUserForRoles(
  userId: UnifiedUser['id'], 
  userRoles: UnifiedRole[],
  roles?: string[],
  roleIds?: string[]
) {
  // If no user is provided, deny access
  if (!userId) {
    return false;
  }

  // It's assumed that the root user has all roles
  if (userId === ROOT_USER_ID) {
    return true;
  }

  // If no roles or roleIds are specified, allow access
  if ((!roles || roles.length === 0) && (!roleIds || roleIds.length === 0)) {
    return true;
  }  
  
  // TODO: Remove in v4 - only keep role names
  // Get user role IDs (for backward compatibility)
  const userRoleIds = userRoles.map(r => r.id).map(v => v.toString());
  
  // Get user role names
  const userRoleNames = userRoles.map(r => r.name).filter(n => n) as string[];

  return roles?.some(n => userRoleNames.includes(n)) || roleIds?.some(rid => userRoleIds.includes(rid.toString()));
}",0
"		// We already have a middleware that checks if there's an incoming URL that has invalid URI, so it's safe
		// to not handle the error: packages/astro/src/vite-plugin-astro-server/base.ts
		pathname = decodeURI(url.pathname);
	}

	// Add config.base back to url before passing it to SSR
	url.pathname = removeTrailingForwardSlash(config.base) + decodeURI(url.pathname);

	// Apply trailing slash configuration consistently
	if (config.trailingSlash === 'never') {
		url.pathname = removeTrailingForwardSlash(url.pathname);
	} else if (config.trailingSlash === 'always' && !hasFileExtension(url.pathname)) {
		url.pathname = appendForwardSlash(url.pathname);",0
"                        : true,
                dateStrings: options.dateStrings,
                debug: options.debug,
                trace: options.trace,
                multipleStatements: options.multipleStatements,
                flags: options.flags,
                stringifyObjects: true,
            },
            {
                host: credentials.host,
                user: credentials.username,
                password: credentials.password,
                database: credentials.database,
                port: credentials.port,
                ssl: options.ssl,
                socketPath: credentials.socketPath,
                connectionLimit: options.poolSize,
            },
            options.acquireTimeout === undefined
                ? {}
                : { acquireTimeout: options.acquireTimeout },
            options.extra || {},
        )
    }

    /**
     * Creates a new connection pool for a given database credentials.",0
"import { DashboardPageConfig, DashboardPageConfigCard, DashboardPageConfigStat } from ""./dashboardPage.model"";
import { RelationalDatabaseSchema } from ""./databaseSchema.model"";
import { DataSourceType, PublicDataSource } from ""./dataSource.model"";
import { Page, PageFileStructure } from ""./page.model"";
import { TablePageConfig } from ""./tablePage.model"";
import { Template } from ""./template.model"";
import { ClientIdentityProviderRole, ClientIdentityProviderUser, ClientIdentityProviderUserWithRoles, IdentityProviderUserPermission, User } from ""./idp.model"";

export interface InternalApiSchema {
  getUsers: {
    body: unknown;
    result: {
      users: ClientIdentityProviderUser[];
    };
  };

  createUser: {
    body: {
      user: Pick<ClientIdentityProviderUser, 'firstName' | 'email' | 'avatarUrl' | 'lastName' | 'username' | 'roleIds' | 'temporaryPassword'>;
      password: string;
    };
    result: {
      user: ClientIdentityProviderUser;
    };
  };

  updateUser: {
    body: {
      userId: ClientIdentityProviderUser['id'];
      user: Partial<ClientIdentityProviderUser>;
      newPassword?: string;
    };
    result: {
      user: ClientIdentityProviderUser;
    };
  };

  deleteUser: {
    body: {
      userId: ClientIdentityProviderUser['id'];
    };
    result: void;
  };

  createRole: {
    body: {
      role: Pick<ClientIdentityProviderRole, 'name' | 'permissions'>;
    };
    result: {
      role: ClientIdentityProviderRole;
    };
  };

  updateRole: {
    body: {
      roleId: ClientIdentityProviderRole['id'];
      role: Partial<ClientIdentityProviderRole>;
    };
    result: {
      role: ClientIdentityProviderRole;
    };
  };

  deleteRole: {
    body: {
      roleId: ClientIdentityProviderRole['id'];
    };
    result: void;
  };

  getApp: {
    body: unknown;
    result: {
      schema: ClientAppSchema; 

      // Pass only if user is authenticated
      user?: ClientIdentityProviderUserWithRoles;
      roles?: ClientIdentityProviderRole[];
      userPermissions?: (keyof typeof IdentityProviderUserPermission | string)[];
    };
  };

  generateSql: {",0
"    appName?: string;
    authMechanism?: string;
    authMechanismProperties?: any;
    authSource?: string;
    autoSelectFamily?: boolean;
    autoSelectFamilyAttemptTimeout?: number;
    allowPublicExplain?: boolean;
    compressors?: string[] | string;
    connectTimeoutMS?: number;
    directConnection?: boolean;
    forceServerObjectId?: boolean;
    heartbeatFrequencyMS?: number;
    loadBalanced?: boolean;",0
"            }
        }

        // Validate Origin header if allowedOrigins is configured
        if (this._allowedOrigins && this._allowedOrigins.length > 0) {
            const originHeader = req.headers.origin;
            if (originHeader && !this._allowedOrigins.includes(originHeader)) {
                return `Invalid Origin header: ${originHeader}`;
            }
        }

        return undefined;
    }",0
"			testUser2.email,
			otp,
			""email-verification"",
		);
	});

	it(""should reset password"", async () => {
		await client.emailOtp.sendVerificationOtp({
			email: testUser.email,
			type: ""forget-password"",
		});
		const res = await client.emailOtp.resetPassword({
			email: testUser.email,
			otp,
			password: ""changed-password"",
		});

		const { data, error } = await client.signIn.email({
			email: testUser.email,
			password: ""changed-password"",
		});
		expect(data?.user).toBeDefined();
	});
",0
"	/**
	 * Whether to disable HTML sandboxing for webhooks. The sandboxing mechanism uses CSP headers now,
	 * but the name is kept for backwards compatibility.
	 */
	@Env('N8N_INSECURE_DISABLE_WEBHOOK_IFRAME_SANDBOX')
	disableWebhookHtmlSandboxing: boolean = false;

	/**
	 * Whether to disable bare repositories support in the Git node.
	 */
	@Env('N8N_GIT_NODE_DISABLE_BARE_REPOS')
	disableBareRepos: boolean = false;
}",0
export const VERSION = '3.3.2';,0
"export function handleError(func) {
  return (req, res) => {
    func(req, res).catch(err => {
      console.log('Error', req.originalUrl, err.message || String(err));
      res.send({
        status: 'ok',
        data: {
          error_code: 'INTERNAL_ERROR',
          error_type: err.message ? err.message : 'internal-error',
        },",0
"import { IdentityProviderUserPermission, IdentityProviderUserWithRoles, InternalApiBody, InternalApiResult } from ""@kottster/common"";
import { Action } from ""../models/action.model"";

/**
 * Update the user
 */
export class UpdateUser extends Action {
  public async execute({ userId, user, newPassword }: InternalApiBody<'updateUser'>, currentUser: IdentityProviderUserWithRoles): Promise<InternalApiResult<'updateUser'>> {
    const hasPermission = await this.app.identityProvider.userHasPermissions(currentUser.id, [IdentityProviderUserPermission.manage_users]);
    if (!hasPermission && currentUser.id !== userId) {
      throw new Error(""You don't have permission to update this user"");
    }

    const updatedUser = await this.app.identityProvider.updateUser(userId, user);",0
"						host: 'example.com',
						'x-forwarded-host': ':123',
					},
				});
				assert.equal(result.url, 'https://example.com/');
			});

			it('rejects empty x-forwarded-host and falls back to host header', () => {
				const result = NodeApp.createRequest(
					{
						...mockNodeRequest,
						headers: {
							host: 'legitimate.example.com',
							'x-forwarded-host': '',
						},
					},
					{ allowedDomains: [{ hostname: 'example.com' }] },
				);
				assert.equal(result.url, 'https://legitimate.example.com/');
			});

			it('rejects x-forwarded-host with path separator (path injection attempt)', () => {
				const result = NodeApp.createRequest(
					{
						...mockNodeRequest,
						headers: {
							host: 'example.com',
							'x-forwarded-host': 'example.com/admin',
						},
					},
					{ allowedDomains: [{ hostname: 'example.com', protocol: 'https' }] },
				);
				// Path separator in host is rejected, falls back to Host header
				assert.equal(result.url, 'https://example.com/');
			});

			it('rejects x-forwarded-host with multiple path segments', () => {
				const result = NodeApp.createRequest(
					{
						...mockNodeRequest,
						headers: {
							host: 'example.com',
							'x-forwarded-host': 'example.com/admin/users',
						},
					},
					{ allowedDomains: [{ hostname: 'example.com', protocol: 'https' }] },
				);
				// Path separators in host are rejected, falls back to Host header
				assert.equal(result.url, 'https://example.com/');
			});

			it('rejects x-forwarded-host with backslash path separator (path injection attempt)', () => {
				const result = NodeApp.createRequest(
					{
						...mockNodeRequest,
						headers: {
							host: 'example.com',
							'x-forwarded-host': 'example.com\\admin',
						},
					},
					{ allowedDomains: [{ hostname: 'example.com', protocol: 'https' }] },
				);
				// Backslash separator in host is rejected, falls back to Host header
				assert.equal(result.url, 'https://example.com/');
			});

			it('parses x-forwarded-host with embedded port when allowedDomains has port pattern', () => {
				const result = NodeApp.createRequest(
					{
						...mockNodeRequest,
						headers: {
							host: 'example.com',
							'x-forwarded-host': 'example.com:3000',
						},
					},
					{ allowedDomains: [{ hostname: 'example.com', port: '3000' }] },
				);
				// X-Forwarded-Host with port should match pattern that includes port
				assert.equal(result.url, 'https://example.com:3000/');
			});
		});

		it('rejects Host header with path separator (path injection attempt)', () => {
			const result = NodeApp.createRequest({
				...mockNodeRequest,
				headers: {
					host: 'example.com/admin',
				},
			});
			// Host header with path is rejected, resulting in undefined hostname
			assert.equal(result.url, 'https://undefined/');
		});

		it('rejects Host header with backslash path separator (path injection attempt)', () => {
			const result = NodeApp.createRequest({
				...mockNodeRequest,
				headers: {
					host: 'example.com\\admin',
				},
			});
			// Host header with backslash is rejected, resulting in undefined hostname
			assert.equal(result.url, 'https://undefined/');
		});

		describe('x-forwarded-proto', () => {
			it('parses protocol from single-value x-forwarded-proto header', () => {
				const result = NodeApp.createRequest({
					...mockNodeRequest,
					headers: {
						host: 'example.com',
						'x-forwarded-proto': 'http',
						'x-forwarded-port': '80',
					},
				});
				assert.equal(result.url, 'http://example.com/');
			});

			it('parses protocol from multi-value x-forwarded-proto header', () => {
				const result = NodeApp.createRequest({
					...mockNodeRequest,
					headers: {
						host: 'example.com',
						'x-forwarded-proto': 'http,https',
						'x-forwarded-port': '80,443',
					},
				});
				assert.equal(result.url, 'http://example.com/');
			});

			it('fallbacks to encrypted property when no x-forwarded-proto header is present', () => {
				const result = NodeApp.createRequest({
					...mockNodeRequest,
					headers: {
						host: 'example.com',
					},
				});
				assert.equal(result.url, 'https://example.com/');
			});

			it('rejects malicious x-forwarded-proto with URL injection (https://www.malicious-url.com/?tank=)', () => {
				const result = NodeApp.createRequest({
					...mockNodeRequest,
					headers: {
						host: 'example.com',
						'x-forwarded-proto': 'https://www.malicious-url.com/?tank=',
					},
				});
				assert.equal(result.url, 'https://example.com/');
			});

			it('rejects malicious x-forwarded-proto with middleware bypass attempt (x:admin?)', () => {
				const result = NodeApp.createRequest({
					...mockNodeRequest,
					headers: {
						host: 'example.com',
						'x-forwarded-proto': 'x:admin?',
					},
				});
				assert.equal(result.url, 'https://example.com/');
			});

			it('rejects malicious x-forwarded-proto with cache poison attempt (https://localhost/vulnerable?)', () => {
				const result = NodeApp.createRequest({
					...mockNodeRequest,
					headers: {
						host: 'example.com',
						'x-forwarded-proto': 'https://localhost/vulnerable?',
					},
				});
				assert.equal(result.url, 'https://example.com/');
			});

			it('rejects malicious x-forwarded-proto with XSS attempt (javascript:alert(document.cookie)//)', () => {
				const result = NodeApp.createRequest({
					...mockNodeRequest,
					headers: {
						host: 'example.com',
						'x-forwarded-proto': 'javascript:alert(document.cookie)//',
					},
				});
				assert.equal(result.url, 'https://example.com/');
			});

			it('rejects empty x-forwarded-proto and falls back to encrypted property', () => {
				const result = NodeApp.createRequest({
					...mockNodeRequest,
					headers: {
						host: 'example.com',
						'x-forwarded-proto': '',
					},
				});
				assert.equal(result.url, 'https://example.com/');
			});
		});

		describe('x-forwarded-port', () => {
			it('parses port from single-value x-forwarded-port header (with allowedDomains)', () => {
				const result = NodeApp.createRequest(
					{
						...mockNodeRequest,
						headers: {
							host: 'example.com',
							'x-forwarded-port': '8443',
						},
					},
					{ allowedDomains: [{ port: '8443' }] },
				);
				assert.equal(result.url, 'https://example.com:8443/');
			});

			it('parses port from multi-value x-forwarded-port header (with allowedDomains)', () => {
				const result = NodeApp.createRequest(
					{
						...mockNodeRequest,
						headers: {
							host: 'example.com',
							'x-forwarded-port': '8443,3000',
						},
					},
					{ allowedDomains: [{ port: '8443' }] },
				);
				assert.equal(result.url, 'https://example.com:8443/');
			});

			it('rejects x-forwarded-port without allowedDomains patterns (strict security default)', () => {
				const result = NodeApp.createRequest({
					...mockNodeRequest,
					headers: {
						host: 'example.com',
						'x-forwarded-port': '8443',
					},
				});
				assert.equal(result.url, 'https://example.com/');
			});

			it('prefers port from host', () => {
				const result = NodeApp.createRequest({
					...mockNodeRequest,
					headers: {
						host: 'example.com:3000',
						'x-forwarded-port': '443',
					},
				});
				assert.equal(result.url, 'https://example.com:3000/');
			});

			it('uses port embedded in x-forwarded-host', () => {
				const result = NodeApp.createRequest(
					{
						...mockNodeRequest,
						headers: {
							host: 'example.com',
							'x-forwarded-host': 'example.com:3000',
						},
					},
					{ allowedDomains: [{ hostname: 'example.com' }] },
				);
				assert.equal(result.url, 'https://example.com:3000/');
			});",0
"      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-transaction',
      'http.request.header.accept': '*/*',
      'http.request.header.accept_encoding': 'gzip, deflate',
      'http.request.header.accept_language': '*',
      'http.request.header.connection': 'keep-alive',
      'http.request.header.host': expect.any(String),
      'http.request.header.sec_fetch_mode': 'cors',
      'http.request.header.user_agent': 'node',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: expect.stringMatching(/[a-f0-9]{32}/),
    origin: 'auto.http.otel.http',",0
"    const fileCreator = new FileCreator({
      projectDir,
      usingTsc: projectSetupData.useTypeScript,
    })
    fileCreator.createProject({
      projectName,
      packageManager: projectSetupData.packageManager,
    })

    if (options.skipInstall || projectSetupData.skipPackageInstallation) {
      // Skip package installation
      console.log(chalk.yellow('Skipping package installation'))
    } else {",0
"    moduleName: CORE,
  };

  // sanitization-related functions
  static sanitizeHtml: o.ExternalReference = {name: 'ɵɵsanitizeHtml', moduleName: CORE};
  static sanitizeStyle: o.ExternalReference = {name: 'ɵɵsanitizeStyle', moduleName: CORE};
  static validateAttribute: o.ExternalReference = {
    name: 'ɵɵvalidateAttribute',
    moduleName: CORE,
  };
  static sanitizeResourceUrl: o.ExternalReference = {
    name: 'ɵɵsanitizeResourceUrl',
    moduleName: CORE,
  };
  static sanitizeScript: o.ExternalReference = {name: 'ɵɵsanitizeScript', moduleName: CORE};
  static sanitizeUrl: o.ExternalReference = {name: 'ɵɵsanitizeUrl', moduleName: CORE};
  static sanitizeUrlOrResourceUrl: o.ExternalReference = {
    name: 'ɵɵsanitizeUrlOrResourceUrl',
    moduleName: CORE,
  };
  static trustConstantHtml: o.ExternalReference = {name: 'ɵɵtrustConstantHtml', moduleName: CORE};
  static trustConstantResourceUrl: o.ExternalReference = {
    name: 'ɵɵtrustConstantResourceUrl',
    moduleName: CORE,
  };

  // Decorators
  static inputDecorator: o.ExternalReference = {name: 'Input', moduleName: CORE};
  static outputDecorator: o.ExternalReference = {name: 'Output', moduleName: CORE};
  static viewChildDecorator: o.ExternalReference = {name: 'ViewChild', moduleName: CORE};
  static viewChildrenDecorator: o.ExternalReference = {name: 'ViewChildren', moduleName: CORE};",0
"  setCapturedScopesOnSpan,
  startSpan,
  vercelWaitUntil,
  winterCGRequestToRequestData,
  withIsolationScope,
} from '@sentry/core';
import { addHeadersAsAttributes } from '../common/utils/addHeadersAsAttributes';
import { flushSafelyWithTimeout } from '../common/utils/responseEnd';
import type { EdgeRouteHandler } from '../edge/types';

/**
 * Wraps Next.js middleware with Sentry error and performance instrumentation.
 *
 * @param middleware The middleware handler.
 * @returns a wrapped middleware handler.
 */
export function wrapMiddlewareWithSentry<H extends EdgeRouteHandler>(
  middleware: H,
): (...params: Parameters<H>) => Promise<ReturnType<H>> {
  return new Proxy(middleware, {
    apply: async (wrappingTarget, thisArg, args: Parameters<H>) => {
      const tunnelRoute =
        '_sentryRewritesTunnelPath' in globalThis
          ? (globalThis as Record<string, unknown>)._sentryRewritesTunnelPath
          : undefined;

      if (tunnelRoute && typeof tunnelRoute === 'string') {
        const req: unknown = args[0];
        // Check if the current request matches the tunnel route
        if (req instanceof Request) {
          const url = new URL(req.url);
          const isTunnelRequest = url.pathname.startsWith(tunnelRoute);

          if (isTunnelRequest) {
            // Create a simple response that mimics NextResponse.next() so we don't need to import internals here
            // which breaks next 13 apps
            // https://github.com/vercel/next.js/blob/c12c9c1f78ad384270902f0890dc4cd341408105/packages/next/src/server/web/spec-extension/response.ts#L146
            return new Response(null, {
              status: 200,
              headers: {
                'x-middleware-next': '1',
              },
            }) as ReturnType<H>;
          }
        }
      }
      // TODO: We still should add central isolation scope creation for when our build-time instrumentation does not work anymore with turbopack.
      return withIsolationScope(isolationScope => {
        const req: unknown = args[0];
        const currentScope = getCurrentScope();

        let spanName: string;
        let spanSource: TransactionSource;
        let headerAttributes: Record<string, string> = {};

        if (req instanceof Request) {
          isolationScope.setSDKProcessingMetadata({
            normalizedRequest: winterCGRequestToRequestData(req),
          });
          spanName = `middleware ${req.method} ${new URL(req.url).pathname}`;
          spanSource = 'url';

          headerAttributes = addHeadersAsAttributes(req.headers);
        } else {
          spanName = 'middleware';
          spanSource = 'component';
        }

        currentScope.setTransactionName(spanName);

        const activeSpan = getActiveSpan();

        if (activeSpan) {
          // If there is an active span, it likely means that the automatic Next.js OTEL instrumentation worked and we can
          // rely on that for parameterization.
          spanName = 'middleware';
          spanSource = 'component';

          const rootSpan = getRootSpan(activeSpan);
          if (rootSpan) {
            setCapturedScopesOnSpan(rootSpan, currentScope, isolationScope);
            rootSpan.setAttributes(headerAttributes);
          }
        }

        return startSpan(
          {
            name: spanName,
            op: 'http.server.middleware',
            attributes: {
              [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: spanSource,
              [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.nextjs.wrapMiddlewareWithSentry',
              ...headerAttributes,
            },
          },
          () => {
            return handleCallbackErrors(
              () => wrappingTarget.apply(thisArg, args),
              error => {",0
"  it('does not apply XSRF protection when request is a HEAD', () => {
    interceptor.intercept(new HttpRequest('HEAD', '/test'), backend).subscribe();
    const req = backend.expectOne('/test');
    expect(req.request.headers.has('X-XSRF-TOKEN')).toEqual(false);
    req.flush({});
  });

  it('does not apply XSRF protection when request is absolute', () => {
    interceptor
      .intercept(new HttpRequest('POST', 'https://example.com/test', {}), backend)
      .subscribe();
    const req = backend.expectOne('https://example.com/test');
    expect(req.request.headers.has('X-XSRF-TOKEN')).toBeFalse();
    req.flush({});
  });

  it('does not apply XSRF protection when request is protocol relative', () => {
    interceptor.intercept(new HttpRequest('POST', '//example.com/test', {}), backend).subscribe();
    const req = backend.expectOne('//example.com/test');
    expect(req.request.headers.has('X-XSRF-TOKEN')).toBeFalse();
    req.flush({});
  });

  it('does not overwrite existing header', () => {
    interceptor
      .intercept(
        new HttpRequest(
          'POST',
          '/test',",0
