function,label
"export const downloadPdf = async (note) => {
	const [{ default: jsPDF }, { default: html2canvas }] = await Promise.all([
		import('jspdf'),
		import('html2canvas-pro')
	]);

	// Define a fixed virtual screen size
	const virtualWidth = 1024; // Fixed width (adjust as needed)
	const virtualHeight = 1400; // Fixed height (adjust as needed)

	// STEP 1. Get a DOM node to render
	const html = note.data?.content?.html ?? '';
	const isDarkMode = document.documentElement.classList.contains('dark');

	let node;
	if (html instanceof HTMLElement) {
		node = html;
	} else {",1
"<script lang=""ts"">
	import { marked } from 'marked';
	marked.use({
		breaks: true,
		gfm: true,
		renderer: {
			list(body, ordered, start) {
				const isTaskList = body.includes('data-checked=');

				if (isTaskList) {
					return `<ul data-type=""taskList"">${body}</ul>`;
				}

				const type = ordered ? 'ol' : 'ul';
				const startatt = ordered && start !== 1 ? ` start=""${start}""` : '';
				return `<${type}${startatt}>${body}</${type}>`;
			},

			listitem(text, task, checked) {
				if (task) {
					const checkedAttr = checked ? 'true' : 'false';
					return `<li data-type=""taskItem"" data-checked=""${checkedAttr}"">${text}</li>`;
				}
				return `<li>${text}</li>`;
			}
		}
	});

	import TurndownService from 'turndown';
	import { gfm } from '@joplin/turndown-plugin-gfm';
	const turndownService = new TurndownService({
		codeBlockStyle: 'fenced',
		headingStyle: 'atx'
	});
	turndownService.escape = (string) => string;

	// Use turndown-plugin-gfm for proper GFM table support
	turndownService.use(gfm);

	// Add custom table header rule before using GFM plugin
	turndownService.addRule('tableHeaders', {
		filter: 'th',
		replacement: function (content, node) {
			return content;
		}
	});

	// Add custom table rule to handle headers properly
	turndownService.addRule('tables', {
		filter: 'table',
		replacement: function (content, node) {
			// Extract rows
			const rows = Array.from(node.querySelectorAll('tr'));
			if (rows.length === 0) return content;

			let markdown = '\n';

			rows.forEach((row, rowIndex) => {
				const cells = Array.from(row.querySelectorAll('th, td'));
				const cellContents = cells.map((cell) => {
					// Get the text content and clean it up
					let cellContent = turndownService.turndown(cell.innerHTML).trim();
					// Remove extra paragraph tags that might be added
					cellContent = cellContent.replace(/^\n+|\n+$/g, '');
					return cellContent;
				});

				// Add the row
				markdown += '| ' + cellContents.join(' | ') + ' |\n';

				// Add separator after first row (which should be headers)
				if (rowIndex === 0) {
					const separator = cells.map(() => '---').join(' | ');
					markdown += '| ' + separator + ' |\n';
				}
			});

			return markdown + '\n';
		}
	});

	turndownService.addRule('taskListItems', {
		filter: (node) =>
			node.nodeName === 'LI' &&
			(node.getAttribute('data-checked') === 'true' ||
				node.getAttribute('data-checked') === 'false'),
		replacement: function (content, node) {
			const checked = node.getAttribute('data-checked') === 'true';
			content = content.replace(/^\s+/, '');
			return `- [${checked ? 'x' : ' '}] ${content}\n`;
		}
	});

	// Convert TipTap mention spans -> <@id>
	turndownService.addRule('mentions', {
		filter: (node) => node.nodeName === 'SPAN' && node.getAttribute('data-type') === 'mention',
		replacement: (_content, node: HTMLElement) => {
			const id = node.getAttribute('data-id') || '';
			// TipTap stores the trigger char in data-mention-suggestion-char (usually ""@"")
			const ch = node.getAttribute('data-mention-suggestion-char') || '@';
			// Emit <@id> style, e.g. <@llama3.2:latest>
			return `<${ch}${id}>`;
		}
	});

	import { onMount, onDestroy, tick, getContext } from 'svelte';
	import { createEventDispatcher } from 'svelte';

	const i18n = getContext('i18n');
	const eventDispatch = createEventDispatcher();

	import { Fragment, DOMParser } from 'prosemirror-model';
	import { EditorState, Plugin, PluginKey, TextSelection, Selection } from 'prosemirror-state';
	import { Decoration, DecorationSet } from 'prosemirror-view';
	import { Editor, Extension, mergeAttributes } from '@tiptap/core';

	import { AIAutocompletion } from './RichTextInput/AutoCompletion.js';

	import StarterKit from '@tiptap/starter-kit';

	// Bubble and Floating menus are currently fixed to v2 due to styling issues in v3
	// TODO: Update to v3 when styling issues are resolved
	import BubbleMenu from '@tiptap/extension-bubble-menu';
	import FloatingMenu from '@tiptap/extension-floating-menu';

	import { TableKit } from '@tiptap/extension-table';
	import { ListKit } from '@tiptap/extension-list';
	import { Placeholder, CharacterCount } from '@tiptap/extensions';

	import Image from './RichTextInput/Image/index.js';
	// import TiptapImage from '@tiptap/extension-image';

	import FileHandler from '@tiptap/extension-file-handler';
	import Typography from '@tiptap/extension-typography';
	import Highlight from '@tiptap/extension-highlight';
	import CodeBlockLowlight from '@tiptap/extension-code-block-lowlight';

	import Mention from '@tiptap/extension-mention';
	import FormattingButtons from './RichTextInput/FormattingButtons.svelte';

	import { PASTED_TEXT_CHARACTER_LIMIT } from '$lib/constants';
	import { createLowlight } from 'lowlight';
	import hljs from 'highlight.js';

	import type { SocketIOCollaborationProvider } from './RichTextInput/Collaboration';

	export let oncompositionstart = (e) => {};
	export let oncompositionend = (e) => {};
	export let onChange = (e) => {};

	// create a lowlight instance with all languages loaded
	const lowlight = createLowlight(
		hljs.listLanguages().reduce(
			(obj, lang) => {
				obj[lang] = () => hljs.getLanguage(lang);
				return obj;
			},
			{} as Record<string, any>
		)
	);

	export let editor: Editor | null = null;

	export let socket = null;
	export let user = null;
	export let files = [];

	export let documentId = '';

	export let className = 'input-prose';
	export let placeholder = $i18n.t('Type here...');
	let _placeholder = placeholder;

	$: if (placeholder !== _placeholder) {
		setPlaceholder();
	}

	const setPlaceholder = () => {
		_placeholder = placeholder;
		if (editor) {
			editor?.view.dispatch(editor.state.tr);
		}
	};

	export let richText = true;
	export let dragHandle = false;
	export let link = false;
	export let image = false;
	export let fileHandler = false;
	export let suggestions = null;

	export let onFileDrop = (currentEditor, files, pos) => {
		files.forEach((file) => {
			const fileReader = new FileReader();

			fileReader.readAsDataURL(file);
			fileReader.onload = () => {
				currentEditor
					.chain()
					.insertContentAt(pos, {
						type: 'image',
						attrs: {
							src: fileReader.result
						}
					})
					.focus()
					.run();
			};
		});
	};

	export let onFilePaste = (currentEditor, files, htmlContent) => {
		files.forEach((file) => {
			if (htmlContent) {
				// if there is htmlContent, stop manual insertion & let other extensions handle insertion via inputRule
				// you could extract the pasted file from this url string and upload it to a server for example
				console.log(htmlContent); // eslint-disable-line no-console
				return false;
			}

			const fileReader = new FileReader();

			fileReader.readAsDataURL(file);
			fileReader.onload = () => {
				currentEditor
					.chain()
					.insertContentAt(currentEditor.state.selection.anchor, {
						type: 'image',
						attrs: {
							src: fileReader.result
						}
					})
					.focus()
					.run();
			};
		});
	};

	export let onSelectionUpdate = (e) => {};

	export let id = '';
	export let value = '';
	export let html = '';

	export let json = false;
	export let raw = false;
	export let editable = true;
	export let collaboration = false;

	export let showFormattingToolbar = true;

	export let preserveBreaks = false;
	export let generateAutoCompletion: Function = async () => null;
	export let autocomplete = false;
	export let messageInput = false;
	export let shiftEnter = false;
	export let largeTextAsFile = false;
	export let insertPromptAsRichText = false;
	export let floatingMenuPlacement = 'bottom-start';

	let content = null;
	let htmlValue = '';
	let jsonValue = '';
	let mdValue = '';

	let provider: SocketIOCollaborationProvider | null = null;

	let floatingMenuElement: Element | null = null;
	let bubbleMenuElement: Element | null = null;
	let element: Element | null = null;

	const options = {
		throwOnError: false
	};

	$: if (editor) {
		editor.setOptions({
			editable: editable
		});
	}

	$: if (value === null && html !== null && editor) {
		editor.commands.setContent(html);
	}

	export const getWordAtDocPos = () => {
		if (!editor) return '';
		const { state } = editor.view;
		const pos = state.selection.from;
		const doc = state.doc;
		const resolvedPos = doc.resolve(pos);
		const textBlock = resolvedPos.parent;
		const paraStart = resolvedPos.start();
		const text = textBlock.textContent;
		const offset = resolvedPos.parentOffset;

		let wordStart = offset,
			wordEnd = offset;
		while (wordStart > 0 && !/\s/.test(text[wordStart - 1])) wordStart--;
		while (wordEnd < text.length && !/\s/.test(text[wordEnd])) wordEnd++;

		const word = text.slice(wordStart, wordEnd);

		return word;
	};

	// Returns {start, end} of the word at pos
	function getWordBoundsAtPos(doc, pos) {
		const resolvedPos = doc.resolve(pos);
		const textBlock = resolvedPos.parent;
		const paraStart = resolvedPos.start();
		const text = textBlock.textContent;

		const offset = resolvedPos.parentOffset;
		let wordStart = offset,
			wordEnd = offset;
		while (wordStart > 0 && !/\s/.test(text[wordStart - 1])) wordStart--;
		while (wordEnd < text.length && !/\s/.test(text[wordEnd])) wordEnd++;
		return {
			start: paraStart + wordStart,
			end: paraStart + wordEnd
		};
	}

	export const replaceCommandWithText = async (text) => {
		const { state, dispatch } = editor.view;
		const { selection } = state;
		const pos = selection.from;

		// Get the plain text of this document
		// const docText = state.doc.textBetween(0, state.doc.content.size, '\n', '\n');

		// Find the word boundaries at cursor
		const { start, end } = getWordBoundsAtPos(state.doc, pos);

		let tr = state.tr;

		if (insertPromptAsRichText) {
			const htmlContent = marked
				.parse(text, {
					breaks: true,
					gfm: true
				})
				.trim();

			// Create a temporary div to parse HTML
			const tempDiv = document.createElement('div');
			tempDiv.innerHTML = htmlContent;

			// Convert HTML to ProseMirror nodes",1
"        '[Sandbox Linux] Skipping seccomp filter - allowAllUnixSockets is enabled',
      )
    }

    // ========== NETWORK RESTRICTIONS ==========
    if (needsNetworkRestriction) {
      // Only sandbox if we have network config and Linux bridges
      if (!httpSocketPath || !socksSocketPath) {
        throw new Error(
          'Linux network sandboxing was requested but bridge socket paths are not available',
        )
      }

      // Verify socket files still exist before trying to bind them
      if (!fs.existsSync(httpSocketPath)) {
        throw new Error(
          `Linux HTTP bridge socket does not exist: ${httpSocketPath}. ` +
            'The bridge process may have died. Try reinitializing the sandbox.',
        )
      }
      if (!fs.existsSync(socksSocketPath)) {
        throw new Error(
          `Linux SOCKS bridge socket does not exist: ${socksSocketPath}. ` +
            'The bridge process may have died. Try reinitializing the sandbox.',
        )
      }

      bwrapArgs.push('--unshare-net')

      // Bind both sockets into the sandbox
      bwrapArgs.push('--bind', httpSocketPath, httpSocketPath)
      bwrapArgs.push('--bind', socksSocketPath, socksSocketPath)

      // Add proxy environment variables
      // HTTP_PROXY points to the socat listener inside the sandbox (port 3128)
      // which forwards to the Unix socket that bridges to the host's proxy server
      const proxyEnv = generateProxyEnvVars(
        3128, // Internal HTTP listener port
        1080, // Internal SOCKS listener port
      )
      bwrapArgs.push(
        ...proxyEnv.flatMap((env: string) => {
          const firstEq = env.indexOf('=')
          const key = env.slice(0, firstEq)
          const value = env.slice(firstEq + 1)
          return ['--setenv', key, value]
        }),
      )

      // Add host proxy port environment variables for debugging/transparency
      // These show which host ports the Unix socket bridges connect to
      if (httpProxyPort !== undefined) {
        bwrapArgs.push(
          '--setenv',
          'CLAUDE_CODE_HOST_HTTP_PROXY_PORT',
          String(httpProxyPort),
        )
      }
      if (socksProxyPort !== undefined) {
        bwrapArgs.push(
          '--setenv',
          'CLAUDE_CODE_HOST_SOCKS_PROXY_PORT',
          String(socksProxyPort),
        )
      }
    }

    // ========== FILESYSTEM RESTRICTIONS ==========
    const fsArgs = await generateFilesystemArgs(
      readConfig,
      writeConfig,",1
"  }
  const readConfig = {
    denyOnly:
      customConfig?.filesystem?.denyRead ?? config?.filesystem.denyRead ?? [],
  }

  // Check if network proxy is needed based on allowed domains
  // Unix sockets are local IPC and don't require the network proxy
  const allowedDomains =
    customConfig?.network?.allowedDomains ??
    config?.network.allowedDomains ??
    []
  const needsNetworkProxy = allowedDomains.length > 0

  // Wait for network initialization only if proxy is actually needed
  if (needsNetworkProxy) {
    await waitForNetworkInitialization()
  }

  switch (platform) {
    case 'macos':
      return await wrapCommandWithSandboxMacOS({
        command,
        needsNetworkRestriction: needsNetworkProxy,
        httpProxyPort: getProxyPort(),
        socksProxyPort: getSocksProxyPort(),
        readConfig,
        writeConfig,
        allowUnixSockets: getAllowUnixSockets(),
        allowAllUnixSockets: getAllowAllUnixSockets(),
        allowLocalBinding: getAllowLocalBinding(),
        ignoreViolations: getIgnoreViolations(),
        binShell,
        ripgrepConfig: getRipgrepConfig(),
      })

    case 'linux':
      return wrapCommandWithSandboxLinux({
        command,
        needsNetworkRestriction: needsNetworkProxy,
        httpSocketPath: getLinuxHttpSocketPath(),
        socksSocketPath: getLinuxSocksSocketPath(),
        httpProxyPort: managerContext?.httpProxyPort,
        socksProxyPort: managerContext?.socksProxyPort,
        readConfig,
        writeConfig,
        enableWeakerNestedSandbox: getEnableWeakerNestedSandbox(),
        allowAllUnixSockets: getAllowAllUnixSockets(),
        binShell,
        ripgrepConfig: getRipgrepConfig(),",1
"          }
        })
      })
    })
  })
})",1
"      })

      // Should wrap for filesystem
      expect(result).not.toBe(command)
      expect(result).toContain('sandbox-exec')
    })
  })
})",1
"                    await transport.handlePostMessage(mockReq, mockHandleRes, { jsonrpc: '2.0', method: 'test' });

                    expect(mockHandleRes.writeHead).toHaveBeenCalledWith(202);
                    expect(mockHandleRes.end).toHaveBeenCalledWith('Accepted');
                });

                it('should reject requests with disallowed origin headers', async () => {
                    const mockRes = createMockResponse();
                    const transport = new SSEServerTransport('/messages', mockRes, {
                        allowedOrigins: ['http://localhost:3000'],
                        enableDnsRebindingProtection: true
                    });",1
"            }
        }

        // Validate Origin header if allowedOrigins is configured
        if (this._options.allowedOrigins && this._options.allowedOrigins.length > 0) {
            const originHeader = req.headers.origin;
            if (!originHeader || !this._options.allowedOrigins.includes(originHeader)) {
                return `Invalid Origin header: ${originHeader}`;
            }
        }

        return undefined;
    }",1
"                });

                expect(response.status).toBe(403);
                const body = await response.json();
                expect(body.error.message).toBe('Invalid Origin header: http://evil.com');
            });
        });

        describe('enableDnsRebindingProtection option', () => {
            it('should skip all validations when enableDnsRebindingProtection is false', async () => {
                const result = await createTestServerWithDnsProtection({
                    sessionIdGenerator: undefined,",1
"            }
        }

        // Validate Origin header if allowedOrigins is configured
        if (this._allowedOrigins && this._allowedOrigins.length > 0) {
            const originHeader = req.headers.origin;
            if (!originHeader || !this._allowedOrigins.includes(originHeader)) {
                return `Invalid Origin header: ${originHeader}`;
            }
        }

        return undefined;
    }",1
" *   mdast node.
 * @returns {Element}
 *   hast node.
 */
export function code(state, node) {
  const value = node.value ? node.value + '\n' : ''
  // To do: next major, use `node.lang` w/o regex, the splitting’s been going
  // on for years in remark now.
  const lang = node.lang ? node.lang.match(/^[^ \t]+(?=[ \t]|$)/) : undefined
  /** @type {Properties} */
  const properties = {}

  if (lang) {
    properties.className = ['language-' + lang]
  }

  // Create `<code>`.
  /** @type {Element} */
  let result = {
    type: 'element',",1
"  selector: 'iframe[hostBindingIframeDir]',
  host: {
    '[innerHtml]': 'evil',
    '[attr.style]': 'evil',
    '[src]': 'evil',
    '[sandbox]': 'evil',
  },
})
export class HostBindingIframeDir {
  evil = 'evil';
}",1
"    $r3$.ɵɵdomProperty(""href"", ctx.evil, $r3$.ɵɵsanitizeResourceUrl);
    $r3$.ɵɵadvance();
    $r3$.ɵɵattribute(""style"", ctx.evil, $r3$.ɵɵsanitizeStyle);
    $r3$.ɵɵadvance();
    $r3$.ɵɵdomProperty(""src"", ctx.evil, $r3$.ɵɵsanitizeUrl);
    $r3$.ɵɵadvance();
    $r3$.ɵɵdomProperty(""sandbox"", ctx.evil, $r3$.ɵɵvalidateIframeAttribute);
    $r3$.ɵɵadvance();
    $r3$.ɵɵdomProperty(""href"", $r3$.ɵɵinterpolate2("""", ctx.evil, """", ctx.evil), $r3$.ɵɵsanitizeUrl);
    $r3$.ɵɵadvance();
    $r3$.ɵɵattribute(""style"", $r3$.ɵɵinterpolate2("""", ctx.evil, """", ctx.evil), $r3$.ɵɵsanitizeStyle);
  }
}",1
"        );
        const diags = env.driveDiagnostics();
        expect(diags.length).toBe(0);
      });
    });

    describe('inline resources', () => {
      it('should process inline <style> tags', () => {
        env.write(
          'test.ts',
          `
        import {Component} from '@angular/core';

        @Component({
          selector: 'test',
          template: '<style>h1 {font-size: larger}</style>',
          styles: ['h2 {width: 10px}']
        })
        export class TestCmp {}
      `,
        );

        env.driveMain();
        const jsContents = env.getContents('test.js');
        expect(jsContents).toContain(
          'styles: [""h2[_ngcontent-%COMP%] {width: 10px}"", ""h1[_ngcontent-%COMP%] {font-size: larger}""]',
        );
      });

      it('should process inline <link> tags', () => {
        env.write('style.css', `h1 {font-size: larger}`);
        env.write(
          'test.ts',
          `
        import {Component} from '@angular/core';

        @Component({
          selector: 'test',
          template: '<link rel=""stylesheet"" href=""./style.css"">',
        })
        export class TestCmp {}
      `,
        );

        env.driveMain();
        const jsContents = env.getContents('test.js');
        expect(jsContents).toContain('styles: [""h1[_ngcontent-%COMP%] {font-size: larger}""]');
      });

      it('should share same styles declared in different components in the same file', () => {
        env.write(
          'test.ts',
          `
          import {Component} from '@angular/core';

          @Component({
            selector: 'comp-a',
            template: 'Comp A',
            styles: [
              'span { font-size: larger; }',
              'div { background: url(/some-very-very-long-path.png); }',
              'img { background: url(/a/some-very-very-long-path.png); }'
            ]
          })
          export class CompA {}

          @Component({
            selector: 'comp-b',
            template: 'Comp B',
            styles: [
              'span { font-size: larger; }',
              'div { background: url(/some-very-very-long-path.png); }',
              'img { background: url(/b/some-very-very-long-path.png); }'
            ]
          })
          export class CompB {}
        `,
        );

        env.driveMain();
        const jsContents = env.getContents('test.js');

        // Verify that long styles present in both components are extracted to a
        // separate var.
        expect(jsContents).toContain(
          '_c0 = ""div[_ngcontent-%COMP%] { background: url(/some-very-very-long-path.png); }"";',
        );

        expect(jsContents).toContain(
          'styles: [' +
            // This style is present in both components, but was not extracted into
            // a separate var since it doesn't reach length threshold (50 chars) in
            // `ConstantPool`.
            '""span[_ngcontent-%COMP%] { font-size: larger; }"", ' +
            // Style that is present in both components, but reaches length
            // threshold - extracted to a separate var.
            '_c0, ' +
            // Style that is unique to this component, but that reaches length
            // threshold - remains a string in the `styles` array.
            '""img[_ngcontent-%COMP%] { background: url(/a/some-very-very-long-path.png); }""]',
        );

        expect(jsContents).toContain(
          'styles: [' +
            // This style is present in both components, but was not extracted into
            // a separate var since it doesn't reach length threshold (50 chars) in
            // `ConstantPool`.
            '""span[_ngcontent-%COMP%] { font-size: larger; }"", ' +
            // Style that is present in both components, but reaches length
            // threshold - extracted to a separate var.
            '_c0, ' +
            // Style that is unique to this component, but that reaches length
            // threshold - remains a string in the `styles` array.
            '""img[_ngcontent-%COMP%] { background: url(/b/some-very-very-long-path.png); }""]',
        );
      });

      it('large strings are wrapped in a function for Closure', () => {
        env.tsconfig({
          annotateForClosureCompiler: true,
        });

        env.write(
          'test.ts',
          `
          import {Component} from '@angular/core';

          @Component({
            selector: 'comp-a',
            template: 'Comp A',
            styles: [
              'div { background: url(/a.png); }',
              'div { background: url(/some-very-very-long-path.png); }',
            ]
          })
          export class CompA {}

          @Component({
            selector: 'comp-b',
            template: 'Comp B',
            styles: [
              'div { background: url(/b.png); }',
              'div { background: url(/some-very-very-long-path.png); }',
            ]
          })
          export class CompB {}
        `,
        );

        env.driveMain();
        const jsContents = env.getContents('test.js');

        // Verify that long strings are extracted to a separate var. This should be
        // wrapped in a function to trick Closure not to inline the contents for very
        // large strings. See: https://github.com/angular/angular/pull/38253.
        expect(jsContents).toContain(
          '_c0 = function () {' +
            ' return ""div[_ngcontent-%COMP%] {' +
            ' background: url(/some-very-very-long-path.png);' +
            ' }"";' +
            ' };',
        );

        expect(jsContents).toContain(
          'styles: [' +
            // Check styles for component A.
            '""div[_ngcontent-%COMP%] { background: url(/a.png); }"", ' +
            // Large string should be called from function definition.
            '_c0()]',
        );

        expect(jsContents).toContain(
          'styles: [' +
            // Check styles for component B.
            '""div[_ngcontent-%COMP%] { background: url(/b.png); }"", ' +
            // Large string should be called from function definition.
            '_c0()]',
        );
      });

      it('should process `styles` as a string', () => {
        env.write(
          'test.ts',
          `
        import {Component} from '@angular/core';

        @Component({
          template: '',
          styles: 'h2 {width: 10px}'
        })
        export class TestCmp {}
      `,
        );

        env.driveMain();
        const jsContents = env.getContents('test.js');
        expect(jsContents).toContain('styles: [""h2[_ngcontent-%COMP%] {width: 10px}""]');
      });

      it('should process `styleUrl`', () => {
        env.write('dir/styles.css', 'h2 {width: 10px}');
        env.write(
          'test.ts',
          `
          import {Component} from '@angular/core';

          @Component({
            selector: 'test-cmp',
            styleUrl: 'dir/styles.css',
            template: '',
          })
          export class TestCmp {}
        `,
        );
        env.driveMain();

        const jsContents = env.getContents('test.js');
        expect(jsContents).not.toContain('styleUrl');
        expect(jsContents).toContain('styles: [""h2[_ngcontent-%COMP%] {width: 10px}""]');
      });

      it('should produce a diagnostic if both `styleUrls` and `styleUrl` are defined', () => {
        env.write('dir/styles.css', 'h2 {width: 10px}');
        env.write(
          'test.ts',
          `
          import {Component} from '@angular/core';

          @Component({
            selector: 'test-cmp',
            styleUrl: 'dir/styles.css',
            styleUrls: ['dir/styles.css'],
            template: '',
          })
          export class TestCmp {}
        `,
        );

        const diags = env.driveDiagnostics();
        expect(diags.length).toBe(1);
        expect(diags[0].messageText).toContain(
          '@Component cannot define both `styleUrl` and `styleUrls`',
        );
      });
    });

    describe('empty resources', () => {
      it('should not include empty inline styles in the compiled output', () => {
        env.write(
          'test.ts',
          `
          import {Component} from '@angular/core';

          const someStyle = ' ';

          @Component({
            selector: 'test-cmp',
            styles: ['', someStyle, '      '],
            template: '',
          })
          export class TestCmp {}
      `,
        );
        env.driveMain();

        const jsContents = env.getContents('test.js');
        expect(jsContents).not.toContain('styles');
        expect(jsContents).not.toContain('styleUrls');
      });

      it('should not include empty external styles in the compiled output', () => {
        env.write('dir/a.css', '');
        env.write('dir/b.css', '                ');
        env.write(
          'test.ts',
          `
          import {Component} from '@angular/core';

          @Component({
            selector: 'test-cmp',
            styleUrls: ['./dir/a.css', './dir/b.css'],
            template: '',
          })
          export class TestCmp {}
        `,
        );
        env.driveMain();

        const jsContents = env.getContents('test.js');
        expect(jsContents).not.toContain('styles');
        expect(jsContents).not.toContain('styleUrls');
      });

      it('should not include empty <link> tags that resolve to empty stylesheets', () => {
        env.write('dir/a.css', '');
        env.write('dir/b.css', '                ');
        env.write(
          'test.ts',
          `
        import {Component} from '@angular/core';

        @Component({
          selector: 'test',
          template: \`
            <link rel=""stylesheet"" href=""./dir/a.css"">
            <link rel=""stylesheet"" href=""./dir/b.css"">
          \`,
        })
        export class TestCmp {}
      `,
        );

        env.driveMain();
        const jsContents = env.getContents('test.js').replace(/<link [^>]*>/g, '');
        expect(jsContents).not.toContain('styles');
        expect(jsContents).not.toContain('styleUrls');
      });
    });

    describe('non-exported classes', () => {
      beforeEach(() => env.tsconfig({compileNonExportedClasses: false}));

      it('should not emit directive definitions for non-exported classes if configured', () => {
        env.write(
          'test.ts',
          `
          import {Directive} from '@angular/core';

          @Directive({
            selector: '[test]'
          })
          class TestDirective {}
        `,
        );
        env.driveMain();
        const jsContents = env.getContents('test.js');

        expect(jsContents).not.toContain('defineDirective(');
        expect(jsContents).toContain('Directive({');
      });

      it('should not emit component definitions for non-exported classes if configured', () => {
        env.write(
          'test.ts',
          `
          import {Component} from '@angular/core';

          @Component({
            selector: 'test',
            template: 'hello'
          })
          class TestComponent {}
        `,
        );
        env.driveMain();
        const jsContents = env.getContents('test.js');

        expect(jsContents).not.toContain('defineComponent(');
        expect(jsContents).toContain('Component({');
      });

      it('should not emit module definitions for non-exported classes if configured', () => {
        env.write(
          'test.ts',
          `
          import {NgModule} from '@angular/core';

          @NgModule({
            declarations: []
          })
          class TestModule {}
        `,
        );
        env.driveMain();
        const jsContents = env.getContents('test.js');

        expect(jsContents).not.toContain('defineNgModule(');
        expect(jsContents).toContain('NgModule({');
      });

      it('should still compile a class that is indirectly exported', () => {
        env.write(
          'test.ts',
          `
          import {Component} from '@angular/core';

          @Component({
            selector: 'test-cmp',
            template: 'Test Cmp',
          })
          class TestCmp {}

          export {TestCmp};
        `,
        );
        env.driveMain();
        const jsContents = env.getContents('test.js');

        expect(jsContents).toContain('defineComponent');
      });
    });

    describe('iframe processing', () => {
      it('should generate attribute and property bindings with a validator fn when on <iframe>', () => {
        env.write(
          'test.ts',
          `
                import {Component} from '@angular/core';

                @Component({
                  template: \`
                    <iframe src=""http://angular.io""
                      [sandbox]=""''"" [attr.allow]=""''""
                      [title]=""'Hi!'""
                    ></iframe>
                  \`
                })
                export class SomeComponent {}
              `,
        );

        env.driveMain();
        const jsContents = env.getContents('test.js');

        // Only `sandbox` has an extra validation fn (since it's security-sensitive),
        // the `title` property doesn't have an extra validation fn.
        expect(jsContents).toContain(
          'ɵɵdomProperty(""sandbox"", """", i0.ɵɵvalidateIframeAttribute)(""title"", ""Hi!"")',
        );

        // The `allow` property is also security-sensitive, thus an extra validation fn.
        expect(jsContents).toContain('ɵɵattribute(""allow"", """", i0.ɵɵvalidateIframeAttribute)');
      });

      it(
        'should generate an attribute binding instruction with a validator function ' +
          ""(making sure it's case-insensitive, since this is allowed in Angular templates)"",
        () => {
          env.write(
            'test.ts',
            `
              import {Component} from '@angular/core';

              @Component({
                template: \`
                  <IFRAME
                    src=""http://angular.io""
                    [attr.SANDBOX]=""''""
                  ></IFRAME>
                \`
              })
              export class SomeComponent {}
            `,
          );

          env.driveMain();
          const jsContents = env.getContents('test.js');

          // Make sure that the `sandbox` has an extra validation fn,
          // and the check is case-insensitive (since the `setAttribute` DOM API
          // is case-insensitive as well).
          expect(jsContents).toContain('ɵɵattribute(""SANDBOX"", """", i0.ɵɵvalidateIframeAttribute)');
        },
      );

      it('should *not* generate a validator fn for attribute and property bindings when *not* on <iframe>', () => {
        env.write(
          'test.ts',
          `
                import {Component, Directive} from '@angular/core';

                @Directive({
                  selector: '[sandbox]',
                  inputs: ['sandbox']
                })
                class Dir {}

                @Component({
                  imports: [Dir],
                  template: \`
                    <div [sandbox]=""''"" [title]=""'Hi!'""></div>
                  \`
                })
                export class SomeComponent {}
              `,
        );

        env.driveMain();
        const jsContents = env.getContents('test.js');

        // Note: no extra validation fn, since a security-sensitive attribute is *not* on an
        // <iframe>.
        expect(jsContents).toContain('ɵɵproperty(""sandbox"", """")(""title"", ""Hi!"")');
      });

      it('should generate a validator fn for attribute and property host bindings on a directive', () => {
        env.write(
          'test.ts',
          `
              import {Directive} from '@angular/core';

              @Directive({
                selector: 'iframe[someDir]',
                host: {
                  '[sandbox]': ""''"",
                  '[attr.allow]': ""''"",
                  'src': 'http://angular.io'
                }
              })
              export class SomeDir {}
            `,
        );

        env.driveMain();
        const jsContents = env.getContents('test.js');

        // The `sandbox` is potentially a security-sensitive attribute of an <iframe>.
        // Generate an extra validation function to invoke at runtime, which would
        // check if an underlying host element is an <iframe>.
        expect(jsContents).toContain('ɵɵdomProperty(""sandbox"", """", i0.ɵɵvalidateIframeAttribute)');

        // Similar to the above, but for an attribute binding (host attributes are
        // represented via `ɵɵattribute`).
        expect(jsContents).toContain('ɵɵattribute(""allow"", """", i0.ɵɵvalidateIframeAttribute)');
      });

      it(
        'should generate a validator fn for attribute host bindings on a directive ' +
          '(making sure the check is case-insensitive)',
        () => {
          env.write(
            'test.ts',
            `
              import {Directive} from '@angular/core';

              @Directive({
                host: {
                  '[attr.SANDBOX]': ""''""
                }
              })
              export class SomeDir {}
            `,
          );

          env.driveMain();
          const jsContents = env.getContents('test.js');

          // Make sure that we generate a validation fn for the `sandbox` attribute,
          // even when it was declared as `SANDBOX`.
          expect(jsContents).toContain('ɵɵattribute(""SANDBOX"", """", i0.ɵɵvalidateIframeAttribute)');
        },
      );
    });

    describe('undecorated providers', () => {
      it('should error when an undecorated class, with a non-trivial constructor, is provided directly in a module', () => {",1
"  NONE = 0,
  HTML = 1,
  STYLE = 2,
  SCRIPT = 3,
  URL = 4,
  RESOURCE_URL = 5,
}

/**
 * Injection flags for DI.
 */
export const enum InjectFlags {",1
"    moduleName: CORE,
  };

  // sanitization-related functions
  static sanitizeHtml: o.ExternalReference = {name: 'ɵɵsanitizeHtml', moduleName: CORE};
  static sanitizeStyle: o.ExternalReference = {name: 'ɵɵsanitizeStyle', moduleName: CORE};
  static sanitizeResourceUrl: o.ExternalReference = {
    name: 'ɵɵsanitizeResourceUrl',
    moduleName: CORE,
  };
  static sanitizeScript: o.ExternalReference = {name: 'ɵɵsanitizeScript', moduleName: CORE};
  static sanitizeUrl: o.ExternalReference = {name: 'ɵɵsanitizeUrl', moduleName: CORE};
  static sanitizeUrlOrResourceUrl: o.ExternalReference = {
    name: 'ɵɵsanitizeUrlOrResourceUrl',
    moduleName: CORE,
  };
  static trustConstantHtml: o.ExternalReference = {name: 'ɵɵtrustConstantHtml', moduleName: CORE};
  static trustConstantResourceUrl: o.ExternalReference = {
    name: 'ɵɵtrustConstantResourceUrl',
    moduleName: CORE,
  };
  static validateIframeAttribute: o.ExternalReference = {
    name: 'ɵɵvalidateIframeAttribute',
    moduleName: CORE,
  };

  // Decorators
  static inputDecorator: o.ExternalReference = {name: 'Input', moduleName: CORE};
  static outputDecorator: o.ExternalReference = {name: 'Output', moduleName: CORE};
  static viewChildDecorator: o.ExternalReference = {name: 'ViewChild', moduleName: CORE};
  static viewChildrenDecorator: o.ExternalReference = {name: 'ViewChildren', moduleName: CORE};",1
"// =================================================================================================
// =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========
// =================================================================================================
// =================================================================================================
//
//        DO NOT EDIT THIS LIST OF SECURITY SENSITIVE PROPERTIES WITHOUT A SECURITY REVIEW!
//                               Reach out to mprobst for details.
//
// =================================================================================================

/** Map from tagName|propertyName to SecurityContext. Properties applying to all tags use '*'. */
let _SECURITY_SCHEMA!: {[k: string]: SecurityContext};

export function SECURITY_SCHEMA(): {[k: string]: SecurityContext} {
  if (!_SECURITY_SCHEMA) {
    _SECURITY_SCHEMA = {};
    // Case is insignificant below, all element and attribute names are lower-cased for lookup.

    registerContext(SecurityContext.HTML, ['iframe|srcdoc', '*|innerHTML', '*|outerHTML']);
    registerContext(SecurityContext.STYLE, ['*|style']);
    // NB: no SCRIPT contexts here, they are never allowed due to the parser stripping them.
    registerContext(SecurityContext.URL, [
      '*|formAction',
      'area|href',
      'area|ping',
      'audio|src',
      'a|href',
      'a|ping',
      'blockquote|cite',
      'body|background',
      'del|cite',
      'form|action',
      'img|src',
      'input|src',
      'ins|cite',
      'q|cite',
      'source|src',
      'track|src',
      'video|poster',
      'video|src',
    ]);
    registerContext(SecurityContext.RESOURCE_URL, [
      'applet|code',
      'applet|codebase',
      'base|href',
      'embed|src',
      'frame|src',
      'head|profile',
      'html|manifest',
      'iframe|src',
      'link|href',
      'media|src',
      'object|codebase',
      'object|data',
      'script|src',
    ]);
  }
  return _SECURITY_SCHEMA;
}

function registerContext(ctx: SecurityContext, specs: string[]) {
  for (const spec of specs) _SECURITY_SCHEMA[spec.toLowerCase()] = ctx;
}

/**
 * The set of security-sensitive attributes of an `<iframe>` that *must* be
 * applied as a static attribute only. This ensures that all security-sensitive
 * attributes are taken into account while creating an instance of an `<iframe>`
 * at runtime.
 *
 * Note: avoid using this set directly, use the `isIframeSecuritySensitiveAttr` function
 * in the code instead.
 */
export const IFRAME_SECURITY_SENSITIVE_ATTRS = new Set([
  'sandbox',
  'allow',
  'allowfullscreen',
  'referrerpolicy',
  'csp',
  'fetchpriority',
]);

/**
 * Checks whether a given attribute name might represent a security-sensitive
 * attribute of an <iframe>.
 */
export function isIframeSecuritySensitiveAttr(attrName: string): boolean {
  // The `setAttribute` DOM API is case-insensitive, so we lowercase the value
  // before checking it against a known security-sensitive attributes.
  return IFRAME_SECURITY_SENSITIVE_ATTRS.has(attrName.toLowerCase());
}",1
" * found in the LICENSE file at https://angular.dev/license
 */

import {SecurityContext} from '../../../../core';
import * as o from '../../../../output/output_ast';
import {Identifiers} from '../../../../render3/r3_identifiers';
import {isIframeSecuritySensitiveAttr} from '../../../../schema/dom_security_schema';
import * as ir from '../../ir';
import {CompilationJob, CompilationJobKind} from '../compilation';
import {createOpXrefMap} from '../util/elements';

/**
 * Map of security contexts to their sanitizer function.
 */
const sanitizerFns = new Map<SecurityContext, o.ExternalReference>([
  [SecurityContext.HTML, Identifiers.sanitizeHtml],
  [SecurityContext.RESOURCE_URL, Identifiers.sanitizeResourceUrl],
  [SecurityContext.SCRIPT, Identifiers.sanitizeScript],
  [SecurityContext.STYLE, Identifiers.sanitizeStyle],
  [SecurityContext.URL, Identifiers.sanitizeUrl],
]);

/**
 * Map of security contexts to their trusted value function.
 */
const trustedValueFns = new Map<SecurityContext, o.ExternalReference>([
  [SecurityContext.HTML, Identifiers.trustConstantHtml],
  [SecurityContext.RESOURCE_URL, Identifiers.trustConstantResourceUrl],
]);

/**
 * Resolves sanitization functions for ops that need them.
 */
export function resolveSanitizers(job: CompilationJob): void {
  for (const unit of job.units) {
    const elements = createOpXrefMap(unit);

    // For normal element bindings we create trusted values for security sensitive constant
    // attributes. However, for host bindings we skip this step (this matches what
    // TemplateDefinitionBuilder does).
    // TODO: Is the TDB behavior correct here?
    if (job.kind !== CompilationJobKind.Host) {
      for (const op of unit.create) {
        if (op.kind === ir.OpKind.ExtractedAttribute) {
          const trustedValueFn =
            trustedValueFns.get(getOnlySecurityContext(op.securityContext)) ?? null;
          op.trustedValueFn = trustedValueFn !== null ? o.importExpr(trustedValueFn) : null;
        }
      }
    }

    for (const op of unit.update) {
      switch (op.kind) {
        case ir.OpKind.Property:
        case ir.OpKind.Attribute:
        case ir.OpKind.DomProperty:
          let sanitizerFn: o.ExternalReference | null = null;
          if (
            Array.isArray(op.securityContext) &&
            op.securityContext.length === 2 &&
            op.securityContext.indexOf(SecurityContext.URL) > -1 &&
            op.securityContext.indexOf(SecurityContext.RESOURCE_URL) > -1
          ) {
            // When the host element isn't known, some URL attributes (such as ""src"" and ""href"") may
            // be part of multiple different security contexts. In this case we use special
            // sanitization function and select the actual sanitizer at runtime based on a tag name
            // that is provided while invoking sanitization function.
            sanitizerFn = Identifiers.sanitizeUrlOrResourceUrl;
          } else {
            sanitizerFn = sanitizerFns.get(getOnlySecurityContext(op.securityContext)) ?? null;
          }
          op.sanitizer = sanitizerFn !== null ? o.importExpr(sanitizerFn) : null;

          // If there was no sanitization function found based on the security context of an
          // attribute/property, check whether this attribute/property is one of the
          // security-sensitive <iframe> attributes (and that the current element is actually an
          // <iframe>).
          if (op.sanitizer === null) {
            let isIframe = false;
            if (job.kind === CompilationJobKind.Host || op.kind === ir.OpKind.DomProperty) {
              // Note: for host bindings defined on a directive, we do not try to find all
              // possible places where it can be matched, so we can not determine whether
              // the host element is an <iframe>. In this case, we just assume it is and append a
              // validation function, which is invoked at runtime and would have access to the
              // underlying DOM element to check if it's an <iframe> and if so - run extra checks.
              isIframe = true;
            } else {
              // For a normal binding we can just check if the element its on is an iframe.
              const ownerOp = elements.get(op.target);
              if (ownerOp === undefined || !ir.isElementOrContainerOp(ownerOp)) {
                throw Error('Property should have an element-like owner');
              }
              isIframe = isIframeElement(ownerOp);
            }
            if (isIframe && isIframeSecuritySensitiveAttr(op.name)) {
              op.sanitizer = o.importExpr(Identifiers.validateIframeAttribute);
            }
          }
          break;
      }
    }
  }
}

/**
 * Checks whether the given op represents an iframe element.
 */
function isIframeElement(op: ir.ElementOrContainerOps): boolean {
  return op.kind === ir.OpKind.ElementStart && op.tag?.toLowerCase() === 'iframe';
}

/**
 * Asserts that there is only a single security context and returns it.
 */
function getOnlySecurityContext(
  securityContext: SecurityContext | SecurityContext[],
): SecurityContext {",1
"  ɵɵsanitizeScript,
  ɵɵsanitizeStyle,
  ɵɵsanitizeUrl,
  ɵɵsanitizeUrlOrResourceUrl,
  ɵɵtrustConstantHtml,
  ɵɵtrustConstantResourceUrl,
} from './sanitization/sanitization';
export {ɵɵvalidateIframeAttribute} from './sanitization/iframe_attrs_validation';
export {noSideEffects as ɵnoSideEffects} from './util/closure';
export {AfterRenderManager as ɵAfterRenderManager} from './render3/after_render/manager';
export {depsTracker as ɵdepsTracker} from './render3/deps_tracker/deps_tracker';
export {generateStandaloneInDeclarationsError as ɵgenerateStandaloneInDeclarationsError} from './render3/jit/module';
export {getAsyncClassMetadataFn as ɵgetAsyncClassMetadataFn} from './render3/metadata';
export {DeferBlockData as ɵDeferBlockData} from './render3/util/defer';",1
"  UNSAFE_VALUE_IN_RESOURCE_URL = 904,
  UNSAFE_VALUE_IN_SCRIPT = 905,
  MISSING_GENERATED_DEF = 906,
  TYPE_IS_NOT_STANDALONE = 907,
  MISSING_ZONEJS = 908,
  UNEXPECTED_ZONE_STATE = 909,
  UNSAFE_IFRAME_ATTRS = -910,
  VIEW_ALREADY_DESTROYED = 911,
  COMPONENT_ID_COLLISION = -912,
  IMAGE_PERFORMANCE_WARNING = -913,
  UNEXPECTED_ZONEJS_PRESENT_IN_ZONELESS_MODE = 914,
  MISSING_NG_MODULE_DEFINITION = 915,",1
"  'ɵɵinterpolateV': r3.ɵɵinterpolateV,

  'ɵɵsanitizeHtml': sanitization.ɵɵsanitizeHtml,
  'ɵɵsanitizeStyle': sanitization.ɵɵsanitizeStyle,
  'ɵɵsanitizeResourceUrl': sanitization.ɵɵsanitizeResourceUrl,
  'ɵɵsanitizeScript': sanitization.ɵɵsanitizeScript,
  'ɵɵsanitizeUrl': sanitization.ɵɵsanitizeUrl,
  'ɵɵsanitizeUrlOrResourceUrl': sanitization.ɵɵsanitizeUrlOrResourceUrl,
  'ɵɵtrustConstantHtml': sanitization.ɵɵtrustConstantHtml,
  'ɵɵtrustConstantResourceUrl': sanitization.ɵɵtrustConstantResourceUrl,
  'ɵɵvalidateIframeAttribute': iframe_attrs_validation.ɵɵvalidateIframeAttribute,

  'forwardRef': forwardRef,
  'resolveForwardRef': resolveForwardRef,

  'ɵɵtwoWayProperty': r3.ɵɵtwoWayProperty,
  'ɵɵtwoWayBindingSet': r3.ɵɵtwoWayBindingSet,",1
" * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.dev/license
 */

import {RuntimeError, RuntimeErrorCode} from '../errors';
import {getTemplateLocationDetails} from '../render3/instructions/element_validation';
import {TNodeType} from '../render3/interfaces/node';
import {RComment, RElement} from '../render3/interfaces/renderer_dom';
import {RENDERER} from '../render3/interfaces/view';
import {nativeRemoveNode} from '../render3/dom_node_manipulation';
import {getLView, getSelectedTNode} from '../render3/state';
import {getNativeByTNode} from '../render3/util/view_utils';
import {trustedHTMLFromString} from '../util/security/trusted_types';

/**
 * Validation function invoked at runtime for each binding that might potentially
 * represent a security-sensitive attribute of an <iframe>.
 * See `IFRAME_SECURITY_SENSITIVE_ATTRS` in the
 * `packages/compiler/src/schema/dom_security_schema.ts` script for the full list
 * of such attributes.
 *
 * @codeGenApi
 */
export function ɵɵvalidateIframeAttribute(attrValue: any, tagName: string, attrName: string) {
  const lView = getLView();
  const tNode = getSelectedTNode()!;
  const element = getNativeByTNode(tNode, lView) as RElement | RComment;

  // Restrict any dynamic bindings of security-sensitive attributes/properties
  // on an <iframe> for security reasons.
  if (tNode.type === TNodeType.Element && tagName.toLowerCase() === 'iframe') {
    const iframe = element as HTMLIFrameElement;

    // Unset previously applied `src` and `srcdoc` if we come across a situation when
    // a security-sensitive attribute is set later via an attribute/property binding.
    iframe.src = '';
    iframe.srcdoc = trustedHTMLFromString('') as unknown as string;

    // Also remove the <iframe> from the document.
    nativeRemoveNode(lView[RENDERER], iframe);

    const errorMessage =
      ngDevMode &&
      `Angular has detected that the \`${attrName}\` was applied ` +
        `as a binding to an <iframe>${getTemplateLocationDetails(lView)}. ` +
        `For security reasons, the \`${attrName}\` can be set on an <iframe> ` +
        `as a static attribute only. \n` +
        `To fix this, switch the \`${attrName}\` binding to a static attribute ` +
        `in a template or in host bindings section.`;
    throw new RuntimeError(RuntimeErrorCode.UNSAFE_IFRAME_ATTRS, errorMessage);
  }
  return attrValue;
}",1
" * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.dev/license
 */

import {XSS_SECURITY_URL} from '../error_details_base_url';
import {RuntimeError, RuntimeErrorCode} from '../errors';
import {getDocument} from '../render3/interfaces/document';
import {ENVIRONMENT} from '../render3/interfaces/view';
import {getLView} from '../render3/state';
import {renderStringify} from '../render3/util/stringify_utils';
import {TrustedHTML, TrustedScript, TrustedScriptURL} from '../util/security/trusted_type_defs';
import {trustedHTMLFromString, trustedScriptURLFromString} from '../util/security/trusted_types';
import {
  trustedHTMLFromStringBypass,
  trustedScriptFromStringBypass,
  trustedScriptURLFromStringBypass,
} from '../util/security/trusted_types_bypass';

import {allowSanitizationBypassAndThrow, BypassType, unwrapSafeValue} from './bypass';
import {_sanitizeHtml as _sanitizeHtml} from './html_sanitizer';
import {Sanitizer} from './sanitizer';
import {SecurityContext} from './security';
import {_sanitizeUrl as _sanitizeUrl} from './url_sanitizer';

/**
 * An `html` sanitizer which converts untrusted `html` **string** into trusted string by removing
 * dangerous content.
 *
 * This method parses the `html` and locates potentially dangerous content (such as urls and
 * javascript) and removes it.
 *
 * It is possible to mark a string as trusted by calling {@link bypassSanitizationTrustHtml}.
 *
 * @param unsafeHtml untrusted `html`, typically from the user.
 * @returns `html` string which is safe to display to user, because all of the dangerous javascript
 * and urls have been removed.
 *
 * @codeGenApi
 */
export function ɵɵsanitizeHtml(unsafeHtml: any): TrustedHTML | string {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return trustedHTMLFromStringBypass(sanitizer.sanitize(SecurityContext.HTML, unsafeHtml) || '');
  }
  if (allowSanitizationBypassAndThrow(unsafeHtml, BypassType.Html)) {
    return trustedHTMLFromStringBypass(unwrapSafeValue(unsafeHtml));
  }
  return _sanitizeHtml(getDocument(), renderStringify(unsafeHtml));
}

/**
 * A `style` sanitizer which converts untrusted `style` **string** into trusted string by removing
 * dangerous content.
 *
 * It is possible to mark a string as trusted by calling {@link bypassSanitizationTrustStyle}.
 *
 * @param unsafeStyle untrusted `style`, typically from the user.
 * @returns `style` string which is safe to bind to the `style` properties.
 *
 * @codeGenApi
 */
export function ɵɵsanitizeStyle(unsafeStyle: any): string {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return sanitizer.sanitize(SecurityContext.STYLE, unsafeStyle) || '';
  }
  if (allowSanitizationBypassAndThrow(unsafeStyle, BypassType.Style)) {
    return unwrapSafeValue(unsafeStyle);
  }
  return renderStringify(unsafeStyle);
}

/**
 * A `url` sanitizer which converts untrusted `url` **string** into trusted string by removing
 * dangerous
 * content.
 *
 * This method parses the `url` and locates potentially dangerous content (such as javascript) and
 * removes it.
 *
 * It is possible to mark a string as trusted by calling {@link bypassSanitizationTrustUrl}.
 *
 * @param unsafeUrl untrusted `url`, typically from the user.
 * @returns `url` string which is safe to bind to the `src` properties such as `<img src>`, because
 * all of the dangerous javascript has been removed.
 *
 * @codeGenApi
 */
export function ɵɵsanitizeUrl(unsafeUrl: any): string {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return sanitizer.sanitize(SecurityContext.URL, unsafeUrl) || '';
  }
  if (allowSanitizationBypassAndThrow(unsafeUrl, BypassType.Url)) {
    return unwrapSafeValue(unsafeUrl);
  }
  return _sanitizeUrl(renderStringify(unsafeUrl));
}

/**
 * A `url` sanitizer which only lets trusted `url`s through.
 *
 * This passes only `url`s marked trusted by calling {@link bypassSanitizationTrustResourceUrl}.
 *
 * @param unsafeResourceUrl untrusted `url`, typically from the user.
 * @returns `url` string which is safe to bind to the `src` properties such as `<img src>`, because
 * only trusted `url`s have been allowed to pass.
 *
 * @codeGenApi
 */
export function ɵɵsanitizeResourceUrl(unsafeResourceUrl: any): TrustedScriptURL | string {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return trustedScriptURLFromStringBypass(
      sanitizer.sanitize(SecurityContext.RESOURCE_URL, unsafeResourceUrl) || '',
    );
  }
  if (allowSanitizationBypassAndThrow(unsafeResourceUrl, BypassType.ResourceUrl)) {
    return trustedScriptURLFromStringBypass(unwrapSafeValue(unsafeResourceUrl));
  }
  throw new RuntimeError(
    RuntimeErrorCode.UNSAFE_VALUE_IN_RESOURCE_URL,
    ngDevMode && `unsafe value used in a resource URL context (see ${XSS_SECURITY_URL})`,
  );
}

/**
 * A `script` sanitizer which only lets trusted javascript through.
 *
 * This passes only `script`s marked trusted by calling {@link
 * bypassSanitizationTrustScript}.
 *
 * @param unsafeScript untrusted `script`, typically from the user.
 * @returns `url` string which is safe to bind to the `<script>` element such as `<img src>`,
 * because only trusted `scripts` have been allowed to pass.
 *
 * @codeGenApi
 */
export function ɵɵsanitizeScript(unsafeScript: any): TrustedScript | string {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return trustedScriptFromStringBypass(
      sanitizer.sanitize(SecurityContext.SCRIPT, unsafeScript) || '',
    );
  }
  if (allowSanitizationBypassAndThrow(unsafeScript, BypassType.Script)) {
    return trustedScriptFromStringBypass(unwrapSafeValue(unsafeScript));
  }
  throw new RuntimeError(
    RuntimeErrorCode.UNSAFE_VALUE_IN_SCRIPT,
    ngDevMode && 'unsafe value used in a script context',
  );
}

/**
 * A template tag function for promoting the associated constant literal to a
 * TrustedHTML. Interpolation is explicitly not allowed.
 *
 * @param html constant template literal containing trusted HTML.
 * @returns TrustedHTML wrapping `html`.
 *
 * @security This is a security-sensitive function and should only be used to
 * convert constant values of attributes and properties found in
 * application-provided Angular templates to TrustedHTML.
 *
 * @codeGenApi
 */
export function ɵɵtrustConstantHtml(html: TemplateStringsArray): TrustedHTML | string {
  // The following runtime check ensures that the function was called as a
  // template tag (e.g. ɵɵtrustConstantHtml`content`), without any interpolation
  // (e.g. not ɵɵtrustConstantHtml`content ${variable}`). A TemplateStringsArray
  // is an array with a `raw` property that is also an array. The associated
  // template literal has no interpolation if and only if the length of the
  // TemplateStringsArray is 1.
  if (ngDevMode && (!Array.isArray(html) || !Array.isArray(html.raw) || html.length !== 1)) {
    throw new Error(`Unexpected interpolation in trusted HTML constant: ${html.join('?')}`);
  }
  return trustedHTMLFromString(html[0]);
}

/**
 * A template tag function for promoting the associated constant literal to a
 * TrustedScriptURL. Interpolation is explicitly not allowed.
 *
 * @param url constant template literal containing a trusted script URL.
 * @returns TrustedScriptURL wrapping `url`.
 *
 * @security This is a security-sensitive function and should only be used to
 * convert constant values of attributes and properties found in
 * application-provided Angular templates to TrustedScriptURL.
 *
 * @codeGenApi
 */
export function ɵɵtrustConstantResourceUrl(url: TemplateStringsArray): TrustedScriptURL | string {
  // The following runtime check ensures that the function was called as a
  // template tag (e.g. ɵɵtrustConstantResourceUrl`content`), without any
  // interpolation (e.g. not ɵɵtrustConstantResourceUrl`content ${variable}`). A
  // TemplateStringsArray is an array with a `raw` property that is also an
  // array. The associated template literal has no interpolation if and only if
  // the length of the TemplateStringsArray is 1.
  if (ngDevMode && (!Array.isArray(url) || !Array.isArray(url.raw) || url.length !== 1)) {
    throw new Error(`Unexpected interpolation in trusted URL constant: ${url.join('?')}`);
  }
  return trustedScriptURLFromString(url[0]);
}

/**
 * Detects which sanitizer to use for URL property, based on tag name and prop name.
 *
 * The rules are based on the RESOURCE_URL context config from
 * `packages/compiler/src/schema/dom_security_schema.ts`.
 * If tag and prop names don't match Resource URL schema, use URL sanitizer.
 */
export function getUrlSanitizer(tag: string, prop: string) {
  if (
    (prop === 'src' &&
      (tag === 'embed' ||
        tag === 'frame' ||
        tag === 'iframe' ||
        tag === 'media' ||
        tag === 'script')) ||
    (prop === 'href' && (tag === 'base' || tag === 'link'))
  ) {
    return ɵɵsanitizeResourceUrl;
  }
  return ɵɵsanitizeUrl;
}

/**
 * Sanitizes URL, selecting sanitizer function based on tag and property names.
 *
 * This function is used in case we can't define security context at compile time, when only prop
 * name is available. This happens when we generate host bindings for Directives/Components. The
 * host element is unknown at compile time, so we defer calculation of specific sanitizer to
 * runtime.
 *
 * @param unsafeUrl untrusted `url`, typically from the user.
 * @param tag target element tag name.
 * @param prop name of the property that contains the value.
 * @returns `url` string which is safe to bind.
 *
 * @codeGenApi
 */
export function ɵɵsanitizeUrlOrResourceUrl(unsafeUrl: any, tag: string, prop: string): any {
  return getUrlSanitizer(tag, prop)(unsafeUrl);
}

export function validateAgainstEventProperties(name: string) {
  if (name.toLowerCase().startsWith('on')) {
    const errorMessage =
      `Binding to event property '${name}' is disallowed for security reasons, ` +
      `please use (${name.slice(2)})=...` +
      `\nIf '${name}' is a directive input, make sure the directive is imported by the` +
      ` current module.`;
    throw new RuntimeError(RuntimeErrorCode.INVALID_EVENT_BINDING, errorMessage);
  }
}

export function validateAgainstEventAttributes(name: string) {
  if (name.toLowerCase().startsWith('on')) {
    const errorMessage =
      `Binding to event attribute '${name}' is disallowed for security reasons, ` +
      `please use (${name.slice(2)})=...`;
    throw new RuntimeError(RuntimeErrorCode.INVALID_EVENT_BINDING, errorMessage);
  }
}

function getSanitizer(): Sanitizer | null {
  const lView = getLView();
  return lView && lView[ENVIRONMENT].sanitizer;
}",1
"  beforeEach(() => {
    TestBed.configureTestingModule({
      providers: [provideZoneChangeDetection()],
    });
  });
  function getErrorMessageRegexp() {
    const errorMessagePart = 'NG0' + Math.abs(RuntimeErrorCode.UNSAFE_IFRAME_ATTRS).toString();
    return new RegExp(errorMessagePart);
  }

  function ensureNoIframePresent(fixture?: ComponentFixture<unknown>) {
    // Note: a `fixture` may not exist in case an error was thrown at creation time.
    const iframe = fixture?.nativeElement.querySelector('iframe');
    expect(!!iframe).toBeFalse();
  }

  function expectIframeCreationToFail<T>(component: Type<T>): ComponentFixture<T> {
    let fixture: ComponentFixture<T> | undefined;
    expect(() => {
      fixture = TestBed.createComponent(component);
      fixture.detectChanges();
    }).toThrowError(getErrorMessageRegexp());

    ensureNoIframePresent(fixture);
    return fixture!;
  }

  function expectIframeToBeCreated<T>(
    component: Type<T>,
    attrsToCheck: {[key: string]: string},
  ): ComponentFixture<T> {
    let fixture: ComponentFixture<T>;
    expect(() => {
      fixture = TestBed.createComponent(component);
      fixture.detectChanges();
    }).not.toThrow();

    const iframe = fixture!.nativeElement.querySelector('iframe');
    for (const [attrName, attrValue] of Object.entries(attrsToCheck)) {
      expect(iframe[attrName]).toEqual(attrValue);
    }

    return fixture!;
  }

  // *Must* be in sync with the `SECURITY_SENSITIVE_ATTRS` list
  // from the `packages/compiler/src/schema/dom_security_schema.ts`.
  const SECURITY_SENSITIVE_ATTRS = [
    'sandbox',
    'allow',
    'allowFullscreen',
    'referrerPolicy',
    'csp',
    'fetchPriority',
  ];

  const TEST_IFRAME_URL = 'https://angular.io/assets/images/logos/angular/angular.png';

  let oldNgDevMode!: typeof ngDevMode;

  beforeAll(() => {
    oldNgDevMode = ngDevMode;
  });

  afterAll(() => {
    global['ngDevMode'] = oldNgDevMode;
  });

  [true, false].forEach((devModeFlag) => {
    beforeAll(() => {
      global['ngDevMode'] = devModeFlag;

      // TestBed and JIT compilation have some dependencies on the ngDevMode state, so we need to
      // reset TestBed to ensure we get a 'clean' JIT compilation under the new rules.
      TestBed.resetTestingModule();
    });

    describe(`with ngDevMode = ${devModeFlag}`, () => {
      SECURITY_SENSITIVE_ATTRS.forEach((securityAttr: string) => {
        ['src', 'srcdoc'].forEach((srcAttr: string) => {
          it(
            `should work when a security-sensitive attribute is set ` +
              `as a static attribute (checking \`${securityAttr}\`)`,
            () => {
              @Component({
                selector: 'my-comp',
                template: `
                  <iframe
                    ${srcAttr}=""${TEST_IFRAME_URL}""
                    ${securityAttr}="""">
                  </iframe>`,
              })
              class IframeComp {}

              expectIframeToBeCreated(IframeComp, {[srcAttr]: TEST_IFRAME_URL});
            },
          );

          it(
            `should work when a security-sensitive attribute is set ` +
              `as a static attribute (checking \`${securityAttr}\` and ` +
              `making sure it's case-insensitive)`,
            () => {
              @Component({
                selector: 'my-comp',
                template: `
                  <iframe
                    ${srcAttr}=""${TEST_IFRAME_URL}""
                    ${securityAttr.toUpperCase()}="""">
                  </iframe>`,
              })
              class IframeComp {}

              expectIframeToBeCreated(IframeComp, {[srcAttr]: TEST_IFRAME_URL});
            },
          );

          it(
            `should error when a security-sensitive attribute is applied ` +
              `using a property binding (checking \`${securityAttr}\`)`,
            () => {
              @Component({
                selector: 'my-comp',
                template: `<iframe ${srcAttr}=""${TEST_IFRAME_URL}"" [${securityAttr}]=""''""></iframe>`,
              })
              class IframeComp {}

              expectIframeCreationToFail(IframeComp);
            },
          );

          it(
            `should error when a security-sensitive attribute is applied ` +
              `using a property interpolation (checking \`${securityAttr}\`)`,
            () => {
              @Component({
                selector: 'my-comp',
                template: `<iframe ${srcAttr}=""${TEST_IFRAME_URL}"" ${securityAttr}=""{{''}}""></iframe>`,
              })
              class IframeComp {}

              expectIframeCreationToFail(IframeComp);
            },
          );

          it(
            `should error when a security-sensitive attribute is applied ` +
              `using a property binding (checking \`${securityAttr}\`, making ` +
              `sure it's case-insensitive)`,
            () => {
              @Component({
                selector: 'my-comp',
                template: `
                    <iframe
                      ${srcAttr}=""${TEST_IFRAME_URL}""
                      [${securityAttr.toUpperCase()}]=""''""
                    ></iframe>
                  `,
              })
              class IframeComp {}

              expectIframeCreationToFail(IframeComp);
            },
          );

          it(
            `should error when a security-sensitive attribute is applied ` +
              `using a property binding (checking \`${securityAttr}\`)`,
            () => {
              @Component({
                selector: 'my-comp',
                template: `
                    <iframe
                      ${srcAttr}=""${TEST_IFRAME_URL}""
                      [attr.${securityAttr}]=""''""
                    ></iframe>
                  `,
              })
              class IframeComp {}

              expectIframeCreationToFail(IframeComp);
            },
          );

          it(
            `should error when a security-sensitive attribute is applied ` +
              `using a property binding (checking \`${securityAttr}\`, making ` +
              `sure it's case-insensitive)`,
            () => {
              @Component({
                selector: 'my-comp',
                template: `
                    <iframe
                      ${srcAttr}=""${TEST_IFRAME_URL}""
                      [attr.${securityAttr.toUpperCase()}]=""''""
                    ></iframe>
                  `,
              })
              class IframeComp {}

              expectIframeCreationToFail(IframeComp);
            },
          );

          it(`should allow changing \`${srcAttr}\` after initial render`, () => {
            @Component({
              selector: 'my-comp',
              template: `
                    <iframe
                      ${securityAttr}=""allow-forms""
                      [${srcAttr}]=""src"">
                    </iframe>
                  `,
            })
            class IframeComp {
              private sanitizer = inject(DomSanitizer);
              src = this.sanitizeFn(TEST_IFRAME_URL);

              get sanitizeFn() {
                return srcAttr === 'src'
                  ? this.sanitizer.bypassSecurityTrustResourceUrl
                  : this.sanitizer.bypassSecurityTrustHtml;
              }
            }

            const fixture = expectIframeToBeCreated(IframeComp, {[srcAttr]: TEST_IFRAME_URL});
            const component = fixture.componentInstance;

            // Changing `src` or `srcdoc` is allowed.
            const newUrl = 'https://angular.io/about?group=Angular';
            component.src = component.sanitizeFn(newUrl);
            expect(() => fixture.detectChanges()).not.toThrow();
            expect(fixture.nativeElement.querySelector('iframe')[srcAttr]).toEqual(newUrl);
          });
        });
      });

      it('should work when a directive sets a security-sensitive attribute as a static attribute', () => {
        @Directive({
          selector: '[dir]',
          host: {
            'src': TEST_IFRAME_URL,
            'sandbox': '',
          },
        })
        class IframeDir {}
        @Component({
          imports: [IframeDir],
          selector: 'my-comp',
          template: '<iframe dir></iframe>',
        })
        class IframeComp {}

        expectIframeToBeCreated(IframeComp, {src: TEST_IFRAME_URL});
      });

      it('should work when a directive sets a security-sensitive host attribute on a non-iframe element', () => {
        @Directive({
          selector: '[dir]',
          host: {
            'src': TEST_IFRAME_URL,
            'sandbox': '',
          },
        })
        class Dir {}

        @Component({
          imports: [Dir],
          selector: 'my-comp',
          template: '<img dir>',
        })
        class NonIframeComp {}

        const fixture = TestBed.createComponent(NonIframeComp);
        fixture.detectChanges();

        expect(fixture.nativeElement.firstChild.src).toEqual(TEST_IFRAME_URL);
      });

      it(
        'should work when a security-sensitive attribute on an <iframe> ' +
          'which also has a structural directive (*ngIf)',
        () => {
          @Component({
            imports: [NgIf],
            selector: 'my-comp',
            template: `<iframe *ngIf=""visible"" src=""${TEST_IFRAME_URL}"" sandbox=""""></iframe>`,
          })
          class IframeComp {
            visible = true;
          }

          expectIframeToBeCreated(IframeComp, {src: TEST_IFRAME_URL});
        },
      );

      it('should work when a security-sensitive attribute is set between `src` and `srcdoc`', () => {
        @Component({
          selector: 'my-comp',
          template: `<iframe src=""${TEST_IFRAME_URL}"" sandbox srcdoc=""Hi!""></iframe>`,
        })
        class IframeComp {}

        expectIframeToBeCreated(IframeComp, {src: TEST_IFRAME_URL});
      });

      it('should work when a directive sets a security-sensitive attribute before setting `src`', () => {
        @Directive({
          selector: '[dir]',
          host: {
            'sandbox': '',
            'src': TEST_IFRAME_URL,
          },
        })
        class IframeDir {}

        @Component({
          imports: [IframeDir],
          selector: 'my-comp',
          template: '<iframe dir></iframe>',
        })
        class IframeComp {}

        expectIframeToBeCreated(IframeComp, {src: TEST_IFRAME_URL});
      });

      it(
        'should work when a directive sets an `src` and ' +
          'there was a security-sensitive attribute set in a template' +
          '(directive attribute after `sandbox`)',
        () => {
          @Directive({
            selector: '[dir]',
            host: {
              'src': TEST_IFRAME_URL,
            },
          })
          class IframeDir {}

          @Component({
            imports: [IframeDir],
            selector: 'my-comp',
            template: '<iframe sandbox dir></iframe>',
          })
          class IframeComp {}

          expectIframeToBeCreated(IframeComp, {src: TEST_IFRAME_URL});
        },
      );

      it(
        'should error when a directive sets a security-sensitive attribute ' +
          ""as an attribute binding (checking that it's case-insensitive)"",
        () => {
          @Directive({
            selector: '[dir]',
            host: {
              '[attr.SANDBOX]': ""''"",
            },
          })
          class IframeDir {}

          @Component({
            imports: [IframeDir],
            selector: 'my-comp',
            template: `<IFRAME dir src=""${TEST_IFRAME_URL}""></IFRAME>`,
          })
          class IframeComp {}

          expectIframeCreationToFail(IframeComp);
        },
      );

      it(
        'should work when a directive sets an `src` and ' +
          'there was a security-sensitive attribute set in a template' +
          '(directive attribute before `sandbox`)',
        () => {
          @Directive({
            selector: '[dir]',
            host: {
              'src': TEST_IFRAME_URL,
            },
          })
          class IframeDir {}

          @Component({
            imports: [IframeDir],
            selector: 'my-comp',
            template: '<iframe dir sandbox></iframe>',
          })
          class IframeComp {}

          expectIframeToBeCreated(IframeComp, {src: TEST_IFRAME_URL});
        },
      );

      it(
        'should work when a directive sets a security-sensitive attribute and ' +
          'there was an `src` attribute set in a template' +
          '(directive attribute after `src`)',
        () => {
          @Directive({
            selector: '[dir]',
            host: {
              'sandbox': '',
            },
          })
          class IframeDir {}

          @Component({
            imports: [IframeDir],
            selector: 'my-comp',
            template: `<iframe src=""${TEST_IFRAME_URL}"" dir></iframe>`,
          })
          class IframeComp {}

          expectIframeToBeCreated(IframeComp, {src: TEST_IFRAME_URL});
        },
      );

      it('should work when a security-sensitive attribute is set as a static attribute', () => {
        @Component({
          selector: 'my-comp',
          template: `
            <iframe referrerPolicy=""no-referrer"" src=""${TEST_IFRAME_URL}""></iframe>
          `,
        })
        class IframeComp {}

        expectIframeToBeCreated(IframeComp, {
          src: TEST_IFRAME_URL,
          referrerPolicy: 'no-referrer',
        });
      });

      it(
        'should error when a security-sensitive attribute is set ' +
          'as a property binding and an <iframe> is wrapped into another element',
        () => {
          @Component({
            selector: 'my-comp',
            template: `
                <section>
                  <iframe
                    src=""${TEST_IFRAME_URL}""
                    [referrerPolicy]=""'no-referrer'""
                  ></iframe>
                </section>`,
          })
          class IframeComp {}

          expectIframeCreationToFail(IframeComp);
        },
      );

      it(
        'should work when a directive sets a security-sensitive attribute and ' +
          'there was an `src` attribute set in a template' +
          '(directive attribute before `src`)',
        () => {
          @Directive({
            selector: '[dir]',
            host: {
              'sandbox': '',
            },
          })
          class IframeDir {}

          @Component({
            imports: [IframeDir],
            selector: 'my-comp',
            template: `<iframe dir src=""${TEST_IFRAME_URL}""></iframe>`,
          })
          class IframeComp {}

          expectIframeToBeCreated(IframeComp, {src: TEST_IFRAME_URL});
        },
      );

      it(
        'should work when a directive that sets a security-sensitive attribute goes ' +
          'before the directive that sets an `src` attribute value',
        () => {
          @Directive({
            selector: '[set-src]',
            host: {
              'src': TEST_IFRAME_URL,
            },
          })
          class DirThatSetsSrc {}

          @Directive({
            selector: '[set-sandbox]',
            host: {
              'sandbox': '',
            },
          })
          class DirThatSetsSandbox {}

          @Component({
            imports: [DirThatSetsSandbox, DirThatSetsSrc],
            selector: 'my-comp',
            // Important note: even though the `set-sandbox` goes after the `set-src`,
            // the directive matching order (thus the order of host attributes) is
            // based on the imports order, so the `sandbox` gets set first and the `src` second.
            template: '<iframe set-src set-sandbox></iframe>',
          })
          class IframeComp {}

          expectIframeToBeCreated(IframeComp, {src: TEST_IFRAME_URL});
        },
      );

      it(
        'should work when a directive that sets a security-sensitive attribute has ' +
          'a host directive that sets an `src` attribute value',
        () => {
          @Directive({
            selector: '[set-src-dir]',
            host: {
              'src': TEST_IFRAME_URL,
            },
          })
          class DirThatSetsSrc {}

          @Directive({
            selector: '[dir]',
            hostDirectives: [DirThatSetsSrc],
            host: {
              'sandbox': '',
            },
          })
          class DirThatSetsSandbox {}

          @Component({
            imports: [DirThatSetsSandbox],
            selector: 'my-comp',
            template: '<iframe dir></iframe>',
          })
          class IframeComp {}

          expectIframeToBeCreated(IframeComp, {src: TEST_IFRAME_URL});
        },
      );

      it(
        'should work when a directive that sets an `src` has ' +
          'a host directive that sets a security-sensitive attribute value',
        () => {
          @Directive({
            selector: '[set-sandbox-dir]',
            host: {
              'sandbox': '',
            },
          })
          class DirThatSetsSandbox {}

          @Directive({
            selector: '[dir]',
            hostDirectives: [DirThatSetsSandbox],
            host: {
              'src': TEST_IFRAME_URL,
            },
          })
          class DirThatSetsSrc {}

          @Component({
            imports: [DirThatSetsSrc],
            selector: 'my-comp',
            template: '<iframe dir></iframe>',
          })
          class IframeComp {}

          expectIframeToBeCreated(IframeComp, {src: TEST_IFRAME_URL});
        },
      );

      it(
        'should error when creating a view that contains an <iframe> ' +
          'with security-sensitive attributes set via property bindings',
        () => {
          @Component({
            selector: 'my-comp',
            template: `
                <ng-container #container></ng-container>
                <ng-template #template>
                  <iframe src=""${TEST_IFRAME_URL}"" [sandbox]=""''""></iframe>
                </ng-template>
              `,
          })
          class IframeComp {
            @ViewChild('container', {read: ViewContainerRef}) container!: ViewContainerRef;
            @ViewChild('template') template!: TemplateRef<unknown>;

            createEmbeddedView() {
              this.container.createEmbeddedView(this.template);
            }
          }

          const fixture = TestBed.createComponent(IframeComp);
          fixture.detectChanges();

          expect(() => {
            fixture.componentInstance.createEmbeddedView();
            fixture.detectChanges();
          }).toThrowError(getErrorMessageRegexp());

          ensureNoIframePresent(fixture);
        },
      );

      describe('i18n', () => {
        it(
          'should error when a security-sensitive attribute is set as ' +
            'a property binding on an <iframe> inside i18n block',
          () => {
            @Component({
              selector: 'my-comp',
              template: `
                  <section i18n>
                    <iframe src=""${TEST_IFRAME_URL}"" [sandbox]=""''"">
                    </iframe>
                  </section>
                `,
            })
            class IframeComp {}

            expectIframeCreationToFail(IframeComp);
          },
        );

        it(
          'should error when a security-sensitive attribute is set as ' +
            'a property binding on an <iframe> annotated with i18n attribute',
          () => {
            @Component({
              selector: 'my-comp',
              template: `
                  <iframe i18n src=""${TEST_IFRAME_URL}"" [sandbox]=""''"">
                  </iframe>
                `,
            })
            class IframeComp {}

            expectIframeCreationToFail(IframeComp);
          },
        );

        it('should work when a security-sensitive attributes are marked for translation', () => {
          @Component({
            selector: 'my-comp',
            template: `
              <iframe src=""${TEST_IFRAME_URL}"" i18n-sandbox sandbox="""">
              </iframe>
            `,
          })
          class IframeComp {}

          expectIframeToBeCreated(IframeComp, {src: TEST_IFRAME_URL});
        });
      });
    });
  });
});",1
"  it('does not apply XSRF protection when request is a HEAD', () => {
    interceptor.intercept(new HttpRequest('HEAD', '/test'), backend).subscribe();
    const req = backend.expectOne('/test');
    expect(req.request.headers.has('X-XSRF-TOKEN')).toEqual(false);
    req.flush({});
  });
  it('does not overwrite existing header', () => {
    interceptor
      .intercept(
        new HttpRequest(
          'POST',
          '/test',",1
"    const onError = opts.onError || onErrorDefault
    const retriesCount = opts.retriesCount || 0
    const maxRetriesOn503 = opts.maxRetriesOn503 || 10
    const retryDelay = opts.retryDelay || undefined

    if (!source) {
      source = req.url
    }

    // we leverage caching to avoid parsing the destination URL
    const dest = getUpstream(this.request, base)
    let url
    if (cache) {",1
"  }
  return dest
}

// issue ref: https://github.com/fastify/fast-proxy/issues/42
function buildURL (source, reqBase) {
  if (Array.isArray(reqBase)) reqBase = reqBase[0]
  let baseOrigin = reqBase ? new URL(reqBase).href : undefined

  // To make sure we don't accidentally override the base path
  if (baseOrigin && source.length > 1 && source[0] === '/' && source[1] === '/') {
    source = '.' + source",1
"      t.assert.throws(() => buildURL(source, base))
    })
  })

  await Promise.all(promises)
})",1
"import * as fs from ""fs"";
import * as path from ""path"";
import { execSync } from ""child_process"";
import * as tmp from ""tmp"";
import { Vulnerability } from ""../types/Vulnerability"";
import { CredentialScanner } from ""./scanners/CredentialScanner"";
import { ToolPoisoningScanner } from ""./scanners/ToolPoisoningScanner"";
import { ParameterInjectionScanner } from ""./scanners/ParameterInjectionScanner"";
import { PromptInjectionScanner } from ""./scanners/PromptInjectionScanner"";
import { ToolMutationScanner } from ""./scanners/ToolMutationScanner"";
import { ConversationExfiltrationScanner } from ""./scanners/ConversationExfiltrationScanner"";
import { AnsiInjectionScanner } from ""./scanners/AnsiInjectionScanner"";
import { ProtocolViolationScanner } from ""./scanners/ProtocolViolationScanner"";
import { InputValidationScanner } from ""./scanners/InputValidationScanner"";
import { ServerSpoofingScanner } from ""./scanners/ServerSpoofingScanner"";
import { ToxicFlowScanner } from ""./scanners/ToxicFlowScanner"";
import { PermissionScanner } from ""./scanners/PermissionScanner"";

/**
 * MCPScanner - Comprehensive security scanner for Model Context Protocol (MCP) servers
 *
 * Based on vulnerability research from:
 * - VulnerableMCP Database (https://vulnerablemcp.info)
 * - HiddenLayer Research (Parameter injection attacks)
 * - Invariant Labs Research (Tool poisoning, toxic agent flows)
 * - Trail of Bits Research (Conversation exfiltration, ANSI injection)
 * - PromptHub Analysis (Command injection, SSRF, path traversal statistics)
 *
 * @example
 * ```typescript
 * const scanner = new MCPScanner();
 * const vulnerabilities = await scanner.scanRepository('https://github.com/user/mcp-server');
 * console.log(`Found ${vulnerabilities.length} vulnerabilities`);
 * ```
 */
export class MCPScanner {
  /** Array to store all discovered vulnerabilities */
  private vulnerabilities: Vulnerability[] = [];

  /**
   * Scans a GitHub repository for MCP security vulnerabilities
   *
   * @param githubUrl - The GitHub repository URL to scan
   * @returns Promise resolving to array of discovered vulnerabilities
   *
   * @example
   * ```typescript
   * const scanner = new MCPScanner();
   * const vulns = await scanner.scanRepository('https://github.com/user/mcp-server');
   * console.log(`Found ${vulns.length} vulnerabilities`);
   * ```
   */
  async scanRepository(githubUrl: string): Promise<Vulnerability[]> {
    console.log(`🔍 Scanning repository: ${githubUrl}`);
    console.log(
      ""📊 Based on vulnerablemcp.info, HiddenLayer, Invariant Labs, and Trail of Bits research\n""
    );

    const tempDir = tmp.dirSync({ unsafeCleanup: true });

    try {
      await this.cloneRepo(githubUrl, tempDir.name);

      // Initialize all scanners
      const credentialScanner = new CredentialScanner();
      const toolPoisoningScanner = new ToolPoisoningScanner();
      const parameterInjectionScanner = new ParameterInjectionScanner();
      const promptInjectionScanner = new PromptInjectionScanner();
      const toolMutationScanner = new ToolMutationScanner();
      const conversationExfiltrationScanner =
        new ConversationExfiltrationScanner();
      const ansiInjectionScanner = new AnsiInjectionScanner();
      const protocolViolationScanner = new ProtocolViolationScanner();
      const inputValidationScanner = new InputValidationScanner();
      const serverSpoofingScanner = new ServerSpoofingScanner();
      const toxicFlowScanner = new ToxicFlowScanner();
      const permissionScanner = new PermissionScanner();

      // Core vulnerability scans based on documented research
      const scanResults = await Promise.all([
        credentialScanner.scan(tempDir.name),
        toolPoisoningScanner.scan(tempDir.name),
        parameterInjectionScanner.scan(tempDir.name),
        promptInjectionScanner.scan(tempDir.name),
        toolMutationScanner.scan(tempDir.name),
        conversationExfiltrationScanner.scan(tempDir.name),
        ansiInjectionScanner.scan(tempDir.name),
        protocolViolationScanner.scan(tempDir.name),
        inputValidationScanner.scan(tempDir.name),
        serverSpoofingScanner.scan(tempDir.name),
        toxicFlowScanner.scan(tempDir.name),
        permissionScanner.scan(tempDir.name),
      ]);

      // Flatten all vulnerabilities from all scanners
      this.vulnerabilities = scanResults.flat();

      return this.vulnerabilities;
    } finally {
      tempDir.removeCallback();
    }
  }

  /**
   * Scans a local project directory for MCP security vulnerabilities
   *
   * @param projectPath - The local project directory path to scan
   * @returns Promise resolving to array of discovered vulnerabilities
   *
   * @example
   * ```typescript
   * const scanner = new MCPScanner();
   * const vulns = await scanner.scanLocalProject('./my-mcp-server');
   * console.log(`Found ${vulns.length} vulnerabilities`);
   * ```
   */
  async scanLocalProject(projectPath: string): Promise<Vulnerability[]> {
    console.log(`🔍 Scanning local project: ${projectPath}`);
    console.log(
      ""📊 Based on vulnerablemcp.info, HiddenLayer, Invariant Labs, and Trail of Bits research\n""
    );

    // Validate that the project path exists
    if (!fs.existsSync(projectPath)) {
      throw new Error(`Project path does not exist: ${projectPath}`);
    }

    const stat = fs.statSync(projectPath);
    if (!stat.isDirectory()) {
      throw new Error(`Project path is not a directory: ${projectPath}`);
    }

    // Initialize all scanners
    const credentialScanner = new CredentialScanner();
    const toolPoisoningScanner = new ToolPoisoningScanner();
    const parameterInjectionScanner = new ParameterInjectionScanner();
    const promptInjectionScanner = new PromptInjectionScanner();
    const toolMutationScanner = new ToolMutationScanner();
    const conversationExfiltrationScanner =
      new ConversationExfiltrationScanner();
    const ansiInjectionScanner = new AnsiInjectionScanner();
    const protocolViolationScanner = new ProtocolViolationScanner();
    const inputValidationScanner = new InputValidationScanner();
    const serverSpoofingScanner = new ServerSpoofingScanner();
    const toxicFlowScanner = new ToxicFlowScanner();
    const permissionScanner = new PermissionScanner();

    // Core vulnerability scans based on documented research
    const scanResults = await Promise.all([
      credentialScanner.scan(projectPath),
      toolPoisoningScanner.scan(projectPath),
      parameterInjectionScanner.scan(projectPath),
      promptInjectionScanner.scan(projectPath),
      toolMutationScanner.scan(projectPath),
      conversationExfiltrationScanner.scan(projectPath),
      ansiInjectionScanner.scan(projectPath),
      protocolViolationScanner.scan(projectPath),
      inputValidationScanner.scan(projectPath),
      serverSpoofingScanner.scan(projectPath),
      toxicFlowScanner.scan(projectPath),
      permissionScanner.scan(projectPath),
    ]);

    // Flatten all vulnerabilities from all scanners
    this.vulnerabilities = scanResults.flat();

    return this.vulnerabilities;
  }

  /**
   * Clones a Git repository to a temporary directory
   *
   * @param url - The repository URL to clone
   * @param targetDir - The target directory for cloning
   * @throws {Error} When git clone fails
   * @private
   */
  private async cloneRepo(url: string, targetDir: string) {
    try {
      console.log(""📥 Cloning repository..."");
      execSync(`git clone --depth 1 ${url} ${targetDir}`, { stdio: ""pipe"" });
    } catch (error) {
      throw new Error(`Failed to clone repository: ${error}`);
    }
  }

  /**",1
"/**
 * Compare two buffers in constant time.
 */
export function constantTimeEqual(
	a: ArrayBuffer | Uint8Array,
	b: ArrayBuffer | Uint8Array,
): boolean {
	const aBuffer = new Uint8Array(a);
	const bBuffer = new Uint8Array(b);
	let c = aBuffer.length ^ bBuffer.length;
	const length = Math.max(aBuffer.length, bBuffer.length);
	for (let i = 0; i < length; i++) {
		c |=",1
"			testUser2.email,
			otp,
			""email-verification"",
		);
	});

	it(""should send forget password otp"", async () => {
		await client.emailOtp.sendVerificationOtp({
			email: testUser.email,
			type: ""forget-password"",
		});
	});

	it(""should reset password"", async () => {
		await client.emailOtp.resetPassword({
			email: testUser.email,
			otp,
			password: ""changed-password"",
		});
		const { data } = await client.signIn.email({
			email: testUser.email,
			password: ""changed-password"",
		});
		expect(data?.user).toBeDefined();
	});
",1
"import { BASE_ERROR_CODES } from ""@better-auth/core/error"";
import { defineErrorCodes } from ""@better-auth/core/utils"";
import * as z from ""zod"";
import { APIError, getSessionFromCtx } from ""../../api"";
import { setCookieCache, setSessionCookie } from ""../../cookies"";
import {
	generateRandomString,
	symmetricDecrypt,
	symmetricEncrypt,
} from ""../../crypto"";
import { getDate } from ""../../utils/date"";
import { getEndpointResponse } from ""../../utils/plugin-helper"";
import { defaultKeyHasher, splitAtLastColon } from ""./utils"";

export interface EmailOTPOptions {
	/**
	 * Function to send email verification
	 */
	sendVerificationOTP: (
		data: {
			email: string;
			otp: string;
			type: ""sign-in"" | ""email-verification"" | ""forget-password"";
		},
		ctx?: GenericEndpointContext | undefined,
	) => Promise<void>;
	/**
	 * Length of the OTP
	 *
	 * @default 6
	 */
	otpLength?: number | undefined;
	/**
	 * Expiry time of the OTP in seconds
	 *
	 * @default 300 (5 minutes)
	 */
	expiresIn?: number | undefined;
	/**
	 * Custom function to generate otp
	 */
	generateOTP?: (
		data: {
			email: string;
			type: ""sign-in"" | ""email-verification"" | ""forget-password"";
		},
		ctx?: GenericEndpointContext,
	) => string | undefined;
	/**
	 * Send email verification on sign-up
	 *
	 * @Default false
	 */
	sendVerificationOnSignUp?: boolean | undefined;
	/**
	 * A boolean value that determines whether to prevent
	 * automatic sign-up when the user is not registered.
	 *
	 * @Default false
	 */
	disableSignUp?: boolean | undefined;
	/**
	 * Allowed attempts for the OTP code
	 * @default 3
	 */
	allowedAttempts?: number | undefined;
	/**
	 * Store the OTP in your database in a secure way
	 * Note: This will not affect the OTP sent to the user, it will only affect the OTP stored in your database
	 *
	 * @default ""plain""
	 */
	storeOTP?:
		| (
				| ""hashed""
				| ""plain""
				| ""encrypted""
				| { hash: (otp: string) => Promise<string> }
				| {
						encrypt: (otp: string) => Promise<string>;
						decrypt: (otp: string) => Promise<string>;
				  }
		  )
		| undefined;
	/**
	 * Override the default email verification to use email otp instead
	 *
	 * @default false
	 */
	overrideDefaultEmailVerification?: boolean | undefined;
}

const types = [""email-verification"", ""sign-in"", ""forget-password""] as const;

const defaultOTPGenerator = (options: EmailOTPOptions) =>
	generateRandomString(options.otpLength ?? 6, ""0-9"");

const ERROR_CODES = defineErrorCodes({
	OTP_EXPIRED: ""OTP expired"",
	INVALID_OTP: ""Invalid OTP"",
	TOO_MANY_ATTEMPTS: ""Too many attempts"",
});

export const emailOTP = (options: EmailOTPOptions) => {
	const opts = {
		expiresIn: 5 * 60,
		generateOTP: () => defaultOTPGenerator(options),
		storeOTP: ""plain"",
		...options,
	} satisfies EmailOTPOptions;

	async function storeOTP(ctx: GenericEndpointContext, otp: string) {
		if (opts.storeOTP === ""encrypted"") {
			return await symmetricEncrypt({
				key: ctx.context.secret,
				data: otp,
			});
		}
		if (opts.storeOTP === ""hashed"") {
			return await defaultKeyHasher(otp);
		}
		if (typeof opts.storeOTP === ""object"" && ""hash"" in opts.storeOTP) {
			return await opts.storeOTP.hash(otp);
		}
		if (typeof opts.storeOTP === ""object"" && ""encrypt"" in opts.storeOTP) {
			return await opts.storeOTP.encrypt(otp);
		}

		return otp;
	}

	async function verifyStoredOTP(
		ctx: GenericEndpointContext,
		storedOtp: string,
		otp: string,
	): Promise<boolean> {
		if (opts.storeOTP === ""encrypted"") {
			return (
				(await symmetricDecrypt({
					key: ctx.context.secret,
					data: storedOtp,
				})) === otp
			);
		}
		if (opts.storeOTP === ""hashed"") {
			const hashedOtp = await defaultKeyHasher(otp);
			return hashedOtp === storedOtp;
		}
		if (typeof opts.storeOTP === ""object"" && ""hash"" in opts.storeOTP) {
			const hashedOtp = await opts.storeOTP.hash(otp);
			return hashedOtp === storedOtp;
		}
		if (typeof opts.storeOTP === ""object"" && ""decrypt"" in opts.storeOTP) {
			const decryptedOtp = await opts.storeOTP.decrypt(storedOtp);
			return decryptedOtp === otp;
		}

		return otp === storedOtp;
	}
	const endpoints = {
		/**
		 * ### Endpoint
		 *
		 * POST `/email-otp/send-verification-otp`
		 *
		 * ### API Methods
		 *
		 * **server:**
		 * `auth.api.sendVerificationOTP`
		 *
		 * **client:**
		 * `authClient.emailOtp.sendVerificationOtp`
		 *
		 * @see [Read our docs to learn more.](https://better-auth.com/docs/plugins/email-otp#api-method-email-otp-send-verification-otp)
		 */
		sendVerificationOTP: createAuthEndpoint(
			""/email-otp/send-verification-otp"",
			{
				method: ""POST"",
				body: z.object({
					email: z.string({}).meta({
						description: ""Email address to send the OTP"",
					}),
					type: z.enum(types).meta({
						description: ""Type of the OTP"",
					}),
				}),
				metadata: {
					openapi: {
						operationId: ""sendEmailVerificationOTP"",
						description: ""Send a verification OTP to an email"",
						responses: {
							200: {
								description: ""Success"",
								content: {
									""application/json"": {
										schema: {
											type: ""object"",
											properties: {
												success: {
													type: ""boolean"",
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
			async (ctx) => {
				if (!options?.sendVerificationOTP) {
					ctx.context.logger.error(
						""send email verification is not implemented"",
					);
					throw new APIError(""BAD_REQUEST"", {
						message: ""send email verification is not implemented"",
					});
				}
				const email = ctx.body.email.toLowerCase();
				const isValidEmail = z.email().safeParse(email);
				if (!isValidEmail.success) {
					throw ctx.error(""BAD_REQUEST"", {
						message: BASE_ERROR_CODES.INVALID_EMAIL,
					});
				}
				if (opts.disableSignUp) {
					const user = await ctx.context.internalAdapter.findUserByEmail(email);
					if (!user) {
						// Return success to prevent user enumeration
						return ctx.json({
							success: true,
						});
					}
				} else if (ctx.body.type === ""forget-password"") {
					const user = await ctx.context.internalAdapter.findUserByEmail(email);
					if (!user) {
						return ctx.json({
							success: true,
						});
					}
				}
				let otp =
					opts.generateOTP({ email, type: ctx.body.type }, ctx) ||
					defaultOTPGenerator(opts);

				let storedOTP = await storeOTP(ctx, otp);

				await ctx.context.internalAdapter
					.createVerificationValue({
						value: `${storedOTP}:0`,
						identifier: `${ctx.body.type}-otp-${email}`,
						expiresAt: getDate(opts.expiresIn, ""sec""),
					})
					.catch(async (error) => {
						// might be duplicate key error
						await ctx.context.internalAdapter.deleteVerificationByIdentifier(
							`${ctx.body.type}-otp-${email}`,
						);
						//try again
						await ctx.context.internalAdapter.createVerificationValue({
							value: `${storedOTP}:0`,
							identifier: `${ctx.body.type}-otp-${email}`,
							expiresAt: getDate(opts.expiresIn, ""sec""),
						});
					});
				await options.sendVerificationOTP(
					{
						email,
						otp,
						type: ctx.body.type,
					},
					ctx,
				);
				return ctx.json({
					success: true,
				});
			},
		),
	};

	return {
		id: ""email-otp"",
		init(ctx) {
			if (!opts.overrideDefaultEmailVerification) {
				return;
			}
			return {
				options: {
					emailVerification: {
						async sendVerificationEmail(data, request) {
							await endpoints.sendVerificationOTP({
								//@ts-expect-error - we need to pass the context
								context: ctx,
								request: request,
								body: {
									email: data.user.email,
									type: ""email-verification"",
								},
								ctx,
							});
						},
					},
				},
			};
		},
		endpoints: {
			...endpoints,
			createVerificationOTP: createAuthEndpoint(
				""/email-otp/create-verification-otp"",
				{
					method: ""POST"",
					body: z.object({
						email: z.string({}).meta({
							description: ""Email address to send the OTP"",
						}),
						type: z.enum(types).meta({
							required: true,
							description: ""Type of the OTP"",
						}),
					}),
					metadata: {
						SERVER_ONLY: true,
						openapi: {
							operationId: ""createEmailVerificationOTP"",
							description: ""Create a verification OTP for an email"",
							responses: {
								200: {
									description: ""Success"",
									content: {
										""application/json"": {
											schema: {
												type: ""string"",
											},
										},
									},
								},
							},
						},
					},
				},
				async (ctx) => {
					const email = ctx.body.email;
					const otp =
						opts.generateOTP({ email, type: ctx.body.type }, ctx) ||
						defaultOTPGenerator(opts);
					let storedOTP = await storeOTP(ctx, otp);
					await ctx.context.internalAdapter.createVerificationValue({
						value: `${storedOTP}:0`,
						identifier: `${ctx.body.type}-otp-${email}`,
						expiresAt: getDate(opts.expiresIn, ""sec""),
					});
					return otp;
				},
			),
			/**
			 * ### Endpoint
			 *
			 * GET `/email-otp/get-verification-otp`
			 *
			 * ### API Methods
			 *
			 * **server:**
			 * `auth.api.getVerificationOTP`
			 *
			 * @see [Read our docs to learn more.](https://better-auth.com/docs/plugins/email-otp#api-method-email-otp-get-verification-otp)
			 */
			getVerificationOTP: createAuthEndpoint(
				""/email-otp/get-verification-otp"",
				{
					method: ""GET"",
					query: z.object({
						email: z.string({}).meta({
							description: ""Email address the OTP was sent to"",
						}),
						type: z.enum(types).meta({
							required: true,
							description: ""Type of the OTP"",
						}),
					}),
					metadata: {
						SERVER_ONLY: true,
						openapi: {
							operationId: ""getEmailVerificationOTP"",
							description: ""Get a verification OTP for an email"",
							responses: {
								""200"": {
									description:
										""OTP retrieved successfully or not found/expired"",
									content: {
										""application/json"": {
											schema: {
												type: ""object"",
												properties: {
													otp: {
														type: ""string"",
														nullable: true,
														description:
															""The stored OTP, or null if not found or expired"",
													},
												},
												required: [""otp""],
											},
										},
									},
								},
							},
						},
					},
				},
				async (ctx) => {
					const email = ctx.query.email;
					const verificationValue =
						await ctx.context.internalAdapter.findVerificationValue(
							`${ctx.query.type}-otp-${email}`,
						);
					if (!verificationValue || verificationValue.expiresAt < new Date()) {
						return ctx.json({
							otp: null,
						});
					}
					if (
						opts.storeOTP === ""hashed"" ||
						(typeof opts.storeOTP === ""object"" && ""hash"" in opts.storeOTP)
					) {
						throw new APIError(""BAD_REQUEST"", {
							message: ""OTP is hashed, cannot return the plain text OTP"",
						});
					}

					let [storedOtp, _attempts] = splitAtLastColon(
						verificationValue.value,
					);
					let otp = storedOtp;
					if (opts.storeOTP === ""encrypted"") {
						otp = await symmetricDecrypt({
							key: ctx.context.secret,
							data: storedOtp,
						});
					}

					if (typeof opts.storeOTP === ""object"" && ""decrypt"" in opts.storeOTP) {
						otp = await opts.storeOTP.decrypt(storedOtp);
					}

					return ctx.json({
						otp,
					});
				},
			),
			/**
			 * ### Endpoint
			 *
			 * GET `/email-otp/check-verification-otp`
			 *
			 * ### API Methods
			 *
			 * **server:**
			 * `auth.api.checkVerificationOTP`
			 *
			 * @see [Read our docs to learn more.](https://better-auth.com/docs/plugins/email-otp#api-method-email-otp-check-verification-otp)
			 */
			checkVerificationOTP: createAuthEndpoint(
				""/email-otp/check-verification-otp"",
				{
					method: ""POST"",
					body: z.object({
						email: z.string().meta({
							description: ""Email address the OTP was sent to"",
						}),
						type: z.enum(types).meta({
							required: true,
							description: ""Type of the OTP"",
						}),
						otp: z.string().meta({
							required: true,
							description: ""OTP to verify"",
						}),
					}),
					metadata: {
						openapi: {
							operationId: ""verifyEmailWithOTP"",
							description: ""Verify an email with an OTP"",
							responses: {
								200: {
									description: ""Success"",
									content: {
										""application/json"": {
											schema: {
												type: ""object"",
												properties: {
													success: {
														type: ""boolean"",
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
				async (ctx) => {
					const email = ctx.body.email.toLowerCase();
					const isValidEmail = z.email().safeParse(email);
					if (!isValidEmail.success) {
						throw new APIError(""BAD_REQUEST"", {
							message: BASE_ERROR_CODES.INVALID_EMAIL,
						});
					}
					const user = await ctx.context.internalAdapter.findUserByEmail(email);
					if (!user) {
						throw new APIError(""BAD_REQUEST"", {
							message: BASE_ERROR_CODES.USER_NOT_FOUND,
						});
					}
					const verificationValue =
						await ctx.context.internalAdapter.findVerificationValue(
							`${ctx.body.type}-otp-${email}`,
						);
					if (!verificationValue) {
						throw new APIError(""BAD_REQUEST"", {
							message: ERROR_CODES.INVALID_OTP,
						});
					}
					if (verificationValue.expiresAt < new Date()) {
						await ctx.context.internalAdapter.deleteVerificationValue(
							verificationValue.id,
						);
						throw new APIError(""BAD_REQUEST"", {
							message: ERROR_CODES.OTP_EXPIRED,
						});
					}

					const [otpValue, attempts] = splitAtLastColon(
						verificationValue.value,
					);
					const allowedAttempts = options?.allowedAttempts || 3;
					if (attempts && parseInt(attempts) >= allowedAttempts) {
						await ctx.context.internalAdapter.deleteVerificationValue(
							verificationValue.id,
						);
						throw new APIError(""FORBIDDEN"", {
							message: ERROR_CODES.TOO_MANY_ATTEMPTS,
						});
					}
					const verified = await verifyStoredOTP(ctx, otpValue, ctx.body.otp);
					if (!verified) {
						await ctx.context.internalAdapter.updateVerificationValue(
							verificationValue.id,
							{
								value: `${otpValue}:${parseInt(attempts || ""0"") + 1}`,
							},
						);
						throw new APIError(""BAD_REQUEST"", {
							message: ERROR_CODES.INVALID_OTP,
						});
					}
					return ctx.json({
						success: true,
					});
				},
			),
			/**
			 * ### Endpoint
			 *
			 * POST `/email-otp/verify-email`
			 *
			 * ### API Methods
			 *
			 * **server:**
			 * `auth.api.verifyEmailOTP`
			 *
			 * **client:**
			 * `authClient.emailOtp.verifyEmail`
			 *
			 * @see [Read our docs to learn more.](https://better-auth.com/docs/plugins/email-otp#api-method-email-otp-verify-email)
			 */
			verifyEmailOTP: createAuthEndpoint(
				""/email-otp/verify-email"",
				{
					method: ""POST"",
					body: z.object({
						email: z.string({}).meta({
							description: ""Email address to verify"",
						}),
						otp: z.string().meta({
							required: true,
							description: ""OTP to verify"",
						}),
					}),
					metadata: {
						openapi: {
							description: ""Verify email with OTP"",
							responses: {
								200: {
									description: ""Success"",
									content: {
										""application/json"": {
											schema: {
												type: ""object"",
												properties: {
													status: {
														type: ""boolean"",
														description:
															""Indicates if the verification was successful"",
														enum: [true],
													},
													token: {
														type: ""string"",
														nullable: true,
														description:
															""Session token if autoSignInAfterVerification is enabled, otherwise null"",
													},
													user: {
														$ref: ""#/components/schemas/User"",
													},
												},
												required: [""status"", ""token"", ""user""],
											},
										},
									},
								},
							},
						},
					},
				},
				async (ctx) => {
					const email = ctx.body.email.toLowerCase();
					const isValidEmail = z.email().safeParse(email);
					if (!isValidEmail.success) {
						throw new APIError(""BAD_REQUEST"", {
							message: BASE_ERROR_CODES.INVALID_EMAIL,
						});
					}
					const verificationValue =
						await ctx.context.internalAdapter.findVerificationValue(
							`email-verification-otp-${email}`,
						);

					if (!verificationValue) {
						throw new APIError(""BAD_REQUEST"", {
							message: ERROR_CODES.INVALID_OTP,
						});
					}
					if (verificationValue.expiresAt < new Date()) {
						throw new APIError(""BAD_REQUEST"", {
							message: ERROR_CODES.OTP_EXPIRED,
						});
					}

					const [otpValue, attempts] = splitAtLastColon(
						verificationValue.value,
					);
					const allowedAttempts = options?.allowedAttempts || 3;
					if (attempts && parseInt(attempts) >= allowedAttempts) {
						await ctx.context.internalAdapter.deleteVerificationValue(
							verificationValue.id,
						);
						throw new APIError(""FORBIDDEN"", {
							message: ERROR_CODES.TOO_MANY_ATTEMPTS,
						});
					}
					const verified = await verifyStoredOTP(ctx, otpValue, ctx.body.otp);
					if (!verified) {
						await ctx.context.internalAdapter.updateVerificationValue(
							verificationValue.id,
							{
								value: `${otpValue}:${parseInt(attempts || ""0"") + 1}`,
							},
						);
						throw new APIError(""BAD_REQUEST"", {
							message: ERROR_CODES.INVALID_OTP,
						});
					}
					await ctx.context.internalAdapter.deleteVerificationValue(
						verificationValue.id,
					);
					const user = await ctx.context.internalAdapter.findUserByEmail(email);
					if (!user) {
						throw new APIError(""BAD_REQUEST"", {
							message: BASE_ERROR_CODES.USER_NOT_FOUND,
						});
					}
					const updatedUser = await ctx.context.internalAdapter.updateUser(
						user.user.id,
						{
							email,
							emailVerified: true,
						},
					);
					await ctx.context.options.emailVerification?.onEmailVerification?.(
						updatedUser,
						ctx.request,
					);

					if (
						ctx.context.options.emailVerification?.autoSignInAfterVerification
					) {
						const session = await ctx.context.internalAdapter.createSession(
							updatedUser.id,
						);
						await setSessionCookie(ctx, {
							session,
							user: updatedUser,
						});
						return ctx.json({
							status: true,
							token: session.token,
							user: {
								id: updatedUser.id,
								email: updatedUser.email,
								emailVerified: updatedUser.emailVerified,
								name: updatedUser.name,
								image: updatedUser.image,
								createdAt: updatedUser.createdAt,
								updatedAt: updatedUser.updatedAt,
							},
						});
					}
					const currentSession = await getSessionFromCtx(ctx);
					if (currentSession && updatedUser.emailVerified) {
						const dontRememberMeCookie = await ctx.getSignedCookie(
							ctx.context.authCookies.dontRememberToken.name,
							ctx.context.secret,
						);
						await setCookieCache(
							ctx,
							{
								session: currentSession.session,
								user: {
									...currentSession.user,
									emailVerified: true,
								},
							},
							!!dontRememberMeCookie,
						);
					}
					return ctx.json({
						status: true,
						token: null,
						user: {
							id: updatedUser.id,
							email: updatedUser.email,
							emailVerified: updatedUser.emailVerified,
							name: updatedUser.name,
							image: updatedUser.image,
							createdAt: updatedUser.createdAt,
							updatedAt: updatedUser.updatedAt,
						},
					});
				},
			),
			/**
			 * ### Endpoint
			 *
			 * POST `/sign-in/email-otp`
			 *
			 * ### API Methods
			 *
			 * **server:**
			 * `auth.api.signInEmailOTP`
			 *
			 * **client:**
			 * `authClient.signIn.emailOtp`
			 *
			 * @see [Read our docs to learn more.](https://better-auth.com/docs/plugins/email-otp#api-method-sign-in-email-otp)
			 */
			signInEmailOTP: createAuthEndpoint(
				""/sign-in/email-otp"",
				{
					method: ""POST"",
					body: z.object({
						email: z.string({}).meta({
							description: ""Email address to sign in"",
						}),
						otp: z.string().meta({
							required: true,
							description: ""OTP sent to the email"",
						}),
					}),
					metadata: {
						openapi: {
							operationId: ""signInWithEmailOTP"",
							description: ""Sign in with email and OTP"",
							responses: {
								200: {
									description: ""Success"",
									content: {
										""application/json"": {
											schema: {
												type: ""object"",
												properties: {
													token: {
														type: ""string"",
														description:
															""Session token for the authenticated session"",
													},
													user: {
														$ref: ""#/components/schemas/User"",
													},
												},
												required: [""token"", ""user""],
											},
										},
									},
								},
							},
						},
					},
				},
				async (ctx) => {
					const email = ctx.body.email;
					const verificationValue =
						await ctx.context.internalAdapter.findVerificationValue(
							`sign-in-otp-${email}`,
						);
					if (!verificationValue) {
						throw new APIError(""BAD_REQUEST"", {
							message: ERROR_CODES.INVALID_OTP,
						});
					}
					if (verificationValue.expiresAt < new Date()) {
						throw new APIError(""BAD_REQUEST"", {
							message: ERROR_CODES.OTP_EXPIRED,
						});
					}
					const [otpValue, attempts] = splitAtLastColon(
						verificationValue.value,
					);
					const allowedAttempts = options?.allowedAttempts || 3;
					if (attempts && parseInt(attempts) >= allowedAttempts) {
						await ctx.context.internalAdapter.deleteVerificationValue(
							verificationValue.id,
						);
						throw new APIError(""FORBIDDEN"", {
							message: ERROR_CODES.TOO_MANY_ATTEMPTS,
						});
					}
					const verified = await verifyStoredOTP(ctx, otpValue, ctx.body.otp);
					if (!verified) {
						await ctx.context.internalAdapter.updateVerificationValue(
							verificationValue.id,
							{
								value: `${otpValue}:${parseInt(attempts || ""0"") + 1}`,
							},
						);
						throw new APIError(""BAD_REQUEST"", {
							message: ERROR_CODES.INVALID_OTP,
						});
					}
					await ctx.context.internalAdapter.deleteVerificationValue(
						verificationValue.id,
					);
					const user = await ctx.context.internalAdapter.findUserByEmail(email);
					if (!user) {
						if (opts.disableSignUp) {
							throw new APIError(""BAD_REQUEST"", {
								message: BASE_ERROR_CODES.USER_NOT_FOUND,
							});
						}
						const newUser = await ctx.context.internalAdapter.createUser({
							email,
							emailVerified: true,
							name: """",
						});
						const session = await ctx.context.internalAdapter.createSession(
							newUser.id,
						);
						await setSessionCookie(ctx, {
							session,
							user: newUser,
						});
						return ctx.json({
							token: session.token,
							user: {
								id: newUser.id,
								email: newUser.email,
								emailVerified: newUser.emailVerified,
								name: newUser.name,
								image: newUser.image,
								createdAt: newUser.createdAt,
								updatedAt: newUser.updatedAt,
							},
						});
					}

					if (!user.user.emailVerified) {
						await ctx.context.internalAdapter.updateUser(user.user.id, {
							emailVerified: true,
						});
					}

					const session = await ctx.context.internalAdapter.createSession(
						user.user.id,
					);
					await setSessionCookie(ctx, {
						session,
						user: user.user,
					});
					return ctx.json({
						token: session.token,
						user: {
							id: user.user.id,
							email: user.user.email,
							emailVerified: user.user.emailVerified,
							name: user.user.name,
							image: user.user.image,
							createdAt: user.user.createdAt,
							updatedAt: user.user.updatedAt,
						},
					});
				},
			),
			/**
			 * ### Endpoint
			 *
			 * POST `/forget-password/email-otp`
			 *
			 * ### API Methods
			 *
			 * **server:**
			 * `auth.api.forgetPasswordEmailOTP`
			 *
			 * **client:**
			 * `authClient.forgetPassword.emailOtp`
			 *
			 * @see [Read our docs to learn more.](https://better-auth.com/docs/plugins/email-otp#api-method-forget-password-email-otp)
			 */
			forgetPasswordEmailOTP: createAuthEndpoint(
				""/forget-password/email-otp"",
				{
					method: ""POST"",
					body: z.object({
						email: z.string().meta({
							description: ""Email address to send the OTP"",
						}),
					}),
					metadata: {
						openapi: {
							operationId: ""forgetPasswordWithEmailOTP"",
							description: ""Forget password with email and OTP"",
							responses: {
								200: {
									description: ""Success"",
									content: {
										""application/json"": {
											schema: {
												type: ""object"",
												properties: {
													success: {
														type: ""boolean"",
														description:
															""Indicates if the OTP was sent successfully"",
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
				async (ctx) => {
					const email = ctx.body.email;
					const user = await ctx.context.internalAdapter.findUserByEmail(email);
					if (!user) {
						throw new APIError(""BAD_REQUEST"", {
							message: BASE_ERROR_CODES.USER_NOT_FOUND,
						});
					}
					const otp =
						opts.generateOTP({ email, type: ""forget-password"" }, ctx) ||
						defaultOTPGenerator(opts);
					let storedOTP = await storeOTP(ctx, otp);
					await ctx.context.internalAdapter.createVerificationValue({
						value: `${storedOTP}:0`,
						identifier: `forget-password-otp-${email}`,
						expiresAt: getDate(opts.expiresIn, ""sec""),
					});
					await options.sendVerificationOTP(
						{
							email,
							otp,
							type: ""forget-password"",
						},
						ctx,
					);
					return ctx.json({
						success: true,
					});
				},
			),
			/**
			 * ### Endpoint
			 *
			 * POST `/email-otp/reset-password`
			 *
			 * ### API Methods
			 *
			 * **server:**
			 * `auth.api.resetPasswordEmailOTP`
			 *
			 * **client:**
			 * `authClient.emailOtp.resetPassword`
			 *
			 * @see [Read our docs to learn more.](https://better-auth.com/docs/plugins/email-otp#api-method-email-otp-reset-password)
			 */
			resetPasswordEmailOTP: createAuthEndpoint(
				""/email-otp/reset-password"",
				{
					method: ""POST"",
					body: z.object({
						email: z.string().meta({
							description: ""Email address to reset the password"",
						}),
						otp: z.string().meta({
							description: ""OTP sent to the email"",
						}),
						password: z.string().meta({
							description: ""New password"",
						}),
					}),
					metadata: {
						openapi: {
							operationId: ""resetPasswordWithEmailOTP"",
							description: ""Reset password with email and OTP"",
							responses: {
								200: {
									description: ""Success"",
									contnt: {
										""application/json"": {
											schema: {
												type: ""object"",
												properties: {
													success: {
														type: ""boolean"",
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
				async (ctx) => {
					const email = ctx.body.email;
					const user = await ctx.context.internalAdapter.findUserByEmail(
						email,
						{
							includeAccounts: true,
						},
					);
					if (!user) {
						throw new APIError(""BAD_REQUEST"", {
							message: BASE_ERROR_CODES.USER_NOT_FOUND,
						});
					}
					const verificationValue =
						await ctx.context.internalAdapter.findVerificationValue(
							`forget-password-otp-${email}`,
						);
					if (!verificationValue) {
						throw new APIError(""BAD_REQUEST"", {
							message: ERROR_CODES.INVALID_OTP,
						});
					}
					if (verificationValue.expiresAt < new Date()) {
						await ctx.context.internalAdapter.deleteVerificationValue(
							verificationValue.id,
						);
						throw new APIError(""BAD_REQUEST"", {
							message: ERROR_CODES.OTP_EXPIRED,
						});
					}
					const [otpValue, attempts] = splitAtLastColon(
						verificationValue.value,
					);
					const allowedAttempts = options?.allowedAttempts || 3;
					if (attempts && parseInt(attempts) >= allowedAttempts) {
						await ctx.context.internalAdapter.deleteVerificationValue(
							verificationValue.id,
						);
						throw new APIError(""FORBIDDEN"", {
							message: ERROR_CODES.TOO_MANY_ATTEMPTS,
						});
					}
					const verified = await verifyStoredOTP(ctx, otpValue, ctx.body.otp);
					if (!verified) {
						await ctx.context.internalAdapter.updateVerificationValue(
							verificationValue.id,
							{
								value: `${otpValue}:${parseInt(attempts || ""0"") + 1}`,
							},
						);
						throw new APIError(""BAD_REQUEST"", {
							message: ERROR_CODES.INVALID_OTP,
						});
					}
					await ctx.context.internalAdapter.deleteVerificationValue(
						verificationValue.id,
					);
					const passwordHash = await ctx.context.password.hash(
						ctx.body.password,
					);
					const account = user.accounts.find(
						(account) => account.providerId === ""credential"",
					);
					if (!account) {
						await ctx.context.internalAdapter.createAccount({
							userId: user.user.id,
							providerId: ""credential"",
							accountId: user.user.id,
							password: passwordHash,
						});
					} else {
						await ctx.context.internalAdapter.updatePassword(
							user.user.id,
							passwordHash,
						);
					}

					if (ctx.context.options.emailAndPassword?.onPasswordReset) {
						await ctx.context.options.emailAndPassword.onPasswordReset(
							{
								user: user.user,
							},
							ctx.request,
						);
					}

					if (!user.user.emailVerified) {
						await ctx.context.internalAdapter.updateUser(user.user.id, {
							emailVerified: true,
						});
					}

					return ctx.json({
						success: true,
					});
				},
			),
		},",1
"						model: ""passkey"",
						where: [
							{
								field: ""id"",
								value: ctx.body.id,
							},
						],
					});
					return ctx.json(null, {
						status: 200,
					});
				},",1
"'use strict';

/**
 * Converts tokens for a single address into an address object
 *
 * @param {Array} tokens Tokens object
 * @return {Object} Address object
 */
function _handleAddress(tokens) {
    let isGroup = false;
    let state = 'text';
    let address;
    let addresses = [];
    let data = {
        address: [],
        comment: [],
        group: [],
        text: [],
        textWasQuoted: [] // Track which text tokens came from inside quotes
    };
    let i;
    let len;
    let insideQuotes = false; // Track if we're currently inside a quoted string

    // Filter out <addresses>, (comments) and regular text
    for (i = 0, len = tokens.length; i < len; i++) {
        let token = tokens[i];
        let prevToken = i ? tokens[i - 1] : null;
        if (token.type === 'operator') {
            switch (token.value) {
                case '<':
                    state = 'address';
                    insideQuotes = false;
                    break;
                case '(':
                    state = 'comment';
                    insideQuotes = false;
                    break;
                case ':':
                    state = 'group';
                    isGroup = true;
                    insideQuotes = false;
                    break;
                case '""':
                    // Track quote state for text tokens
                    insideQuotes = !insideQuotes;
                    state = 'text';
                    break;
                default:
                    state = 'text';
                    insideQuotes = false;
                    break;
            }
        } else if (token.value) {
            if (state === 'address') {
                // handle use case where unquoted name includes a ""<""
                // Apple Mail truncates everything between an unexpected < and an address
                // and so will we
                token.value = token.value.replace(/^[^<]*<\s*/, '');
            }

            if (prevToken && prevToken.noBreak && data[state].length) {
                // join values
                data[state][data[state].length - 1] += token.value;
                if (state === 'text' && insideQuotes) {
                    data.textWasQuoted[data.textWasQuoted.length - 1] = true;
                }
            } else {
                data[state].push(token.value);
                if (state === 'text') {
                    data.textWasQuoted.push(insideQuotes);
                }
            }
        }
    }

    // If there is no text but a comment, replace the two
    if (!data.text.length && data.comment.length) {
        data.text = data.comment;
        data.comment = [];
    }

    if (isGroup) {
        // http://tools.ietf.org/html/rfc2822#appendix-A.1.3
        data.text = data.text.join(' ');

        // Parse group members, but flatten any nested groups (RFC 5322 doesn't allow nesting)
        let groupMembers = [];
        if (data.group.length) {
            let parsedGroup = addressparser(data.group.join(','));
            // Flatten: if any member is itself a group, extract its members into the sequence
            parsedGroup.forEach(member => {
                if (member.group) {
                    // Nested group detected - flatten it by adding its members directly
                    groupMembers = groupMembers.concat(member.group);
                } else {
                    groupMembers.push(member);
                }
            });
        }

        addresses.push({
            name: data.text || (address && address.name),
            group: groupMembers
        });
    } else {
        // If no address was found, try to detect one from regular text
        if (!data.address.length && data.text.length) {
            for (i = data.text.length - 1; i >= 0; i--) {
                // Security fix: Do not extract email addresses from quoted strings
                // RFC 5321 allows @ inside quoted local-parts like ""user@domain""@example.com
                // Extracting emails from quoted text leads to misrouting vulnerabilities
                if (!data.textWasQuoted[i] && data.text[i].match(/^[^@\s]+@[^@\s]+$/)) {
                    data.address = data.text.splice(i, 1);
                    data.textWasQuoted.splice(i, 1);
                    break;
                }
            }

            let _regexHandler = function (address) {
                if (!data.address.length) {
                    data.address = [address.trim()];
                    return ' ';
                } else {
                    return address;
                }
            };

            // still no address
            if (!data.address.length) {
                for (i = data.text.length - 1; i >= 0; i--) {
                    // Security fix: Do not extract email addresses from quoted strings
                    if (!data.textWasQuoted[i]) {
                        // fixed the regex to parse email address correctly when email address has more than one @
                        data.text[i] = data.text[i].replace(/\s*\b[^@\s]+@[^\s]+\b\s*/, _regexHandler).trim();
                        if (data.address.length) {
                            break;
                        }
                    }
                }
            }
        }

        // If there's still is no text but a comment exixts, replace the two
        if (!data.text.length && data.comment.length) {
            data.text = data.comment;
            data.comment = [];
        }

        // Keep only the first address occurence, push others to regular text
        if (data.address.length > 1) {
            data.text = data.text.concat(data.address.splice(1));
        }

        // Join values with spaces
        data.text = data.text.join(' ');
        data.address = data.address.join(' ');

        if (!data.address && isGroup) {
            return [];
        } else {
            address = {
                address: data.address || data.text || '',
                name: data.text || data.address || ''
            };

            if (address.address === address.name) {
                if ((address.address || '').match(/@/)) {
                    address.name = '';
                } else {
                    address.address = '';
                }
            }

            addresses.push(address);
        }
    }

    return addresses;
}

/**
 * Creates a Tokenizer object for tokenizing address field strings
 *
 * @constructor
 * @param {String} str Address field string
 */
class Tokenizer {
    constructor(str) {
        this.str = (str || '').toString();
        this.operatorCurrent = '';
        this.operatorExpecting = '';
        this.node = null;
        this.escaped = false;

        this.list = [];
        /**
         * Operator tokens and which tokens are expected to end the sequence
         */
        this.operators = {
            '""': '""',
            '(': ')',
            '<': '>',
            ',': '',
            ':': ';',
            // Semicolons are not a legal delimiter per the RFC2822 grammar other
            // than for terminating a group, but they are also not valid for any
            // other use in this context.  Given that some mail clients have
            // historically allowed the semicolon as a delimiter equivalent to the
            // comma in their UI, it makes sense to treat them the same as a comma
            // when used outside of a group.
            ';': ''
        };
    }

    /**
     * Tokenizes the original input string
     *
     * @return {Array} An array of operator|text tokens
     */
    tokenize() {
        let list = [];

        for (let i = 0, len = this.str.length; i < len; i++) {
            let chr = this.str.charAt(i);
            let nextChr = i < len - 1 ? this.str.charAt(i + 1) : null;
            this.checkChar(chr, nextChr);
        }

        this.list.forEach(node => {
            node.value = (node.value || '').toString().trim();
            if (node.value) {
                list.push(node);
            }
        });

        return list;
    }

    /**
     * Checks if a character is an operator or text and acts accordingly
     *
     * @param {String} chr Character from the address field
     */
    checkChar(chr, nextChr) {
        if (this.escaped) {
            // ignore next condition blocks
        } else if (chr === this.operatorExpecting) {
            this.node = {
                type: 'operator',
                value: chr
            };

            if (nextChr && ![' ', '\t', '\r', '\n', ',', ';'].includes(nextChr)) {
                this.node.noBreak = true;
            }

            this.list.push(this.node);
            this.node = null;
            this.operatorExpecting = '';
            this.escaped = false;

            return;
        } else if (!this.operatorExpecting && chr in this.operators) {
            this.node = {
                type: 'operator',
                value: chr
            };
            this.list.push(this.node);
            this.node = null;
            this.operatorExpecting = this.operators[chr];
            this.escaped = false;
            return;
        } else if (['""', ""'""].includes(this.operatorExpecting) && chr === '\\') {
            this.escaped = true;
            return;
        }

        if (!this.node) {
            this.node = {
                type: 'text',
                value: ''
            };
            this.list.push(this.node);
        }

        if (chr === '\n') {
            // Convert newlines to spaces. Carriage return is ignored as \r and \n usually
            // go together anyway and there already is a WS for \n. Lone \r means something is fishy.
            chr = ' ';
        }

        if (chr.charCodeAt(0) >= 0x21 || [' ', '\t'].includes(chr)) {
            // skip command bytes
            this.node.value += chr;
        }

        this.escaped = false;
    }
}

/**
 * Parses structured e-mail addresses from an address field
 *
 * Example:
 *
 *    'Name <address@domain>'
 *
 * will be converted to
 *
 *     [{name: 'Name', address: 'address@domain'}]
 *
 * @param {String} str Address field
 * @return {Array} An array of address objects
 */
function addressparser(str, options) {
    options = options || {};

    let tokenizer = new Tokenizer(str);
    let tokens = tokenizer.tokenize();

    let addresses = [];
    let address = [];
    let parsedAddresses = [];

    tokens.forEach(token => {
        if (token.type === 'operator' && (token.value === ',' || token.value === ';')) {
            if (address.length) {
                addresses.push(address);
            }
            address = [];
        } else {
            address.push(token);
        }
    });

    if (address.length) {
        addresses.push(address);
    }

    addresses.forEach(address => {
        address = _handleAddress(address);
        if (address.length) {
            parsedAddresses = parsedAddresses.concat(address);
        }
    });

    if (options.flatten) {",1
"            let result = addressparser(input);
            let elapsed = Date.now() - start;
            assert.ok(elapsed < 1000, 'Should handle many delimiters quickly');
            assert.strictEqual(result.length, 2);
        });
    });
});",1
"    let address;
    let addresses = [];
    let data = {
        address: [],
        comment: [],
        group: [],
        text: []
    };
    let i;
    let len;

    // Filter out <addresses>, (comments) and regular text
    for (i = 0, len = tokens.length; i < len; i++) {
        let token = tokens[i];
        let prevToken = i ? tokens[i - 1] : null;
        if (token.type === 'operator') {
            switch (token.value) {
                case '<':
                    state = 'address';
                    break;
                case '(':
                    state = 'comment';
                    break;
                case ':':
                    state = 'group';
                    isGroup = true;
                    break;
                default:
                    state = 'text';
                    break;
            }
        } else if (token.value) {
            if (state === 'address') {
                // handle use case where unquoted name includes a ""<""
                // Apple Mail truncates everything between an unexpected < and an address
                // and so will we
                token.value = token.value.replace(/^[^<]*<\s*/, '');
            }

            if (prevToken && prevToken.noBreak && data[state].length) {
                // join values
                data[state][data[state].length - 1] += token.value;
            } else {
                data[state].push(token.value);
            }
        }
    }

    // If there is no text but a comment, replace the two
    if (!data.text.length && data.comment.length) {
        data.text = data.comment;
        data.comment = [];
    }

    if (isGroup) {
        // http://tools.ietf.org/html/rfc2822#appendix-A.1.3
        data.text = data.text.join(' ');
        addresses.push({
            name: data.text || (address && address.name),
            group: data.group.length ? addressparser(data.group.join(',')) : []
        });
    } else {
        // If no address was found, try to detect one from regular text
        if (!data.address.length && data.text.length) {
            for (i = data.text.length - 1; i >= 0; i--) {
                if (data.text[i].match(/^[^@\s]+@[^@\s]+$/)) {
                    data.address = data.text.splice(i, 1);
                    break;
                }
            }

            let _regexHandler = function (address) {
                if (!data.address.length) {
                    data.address = [address.trim()];
                    return ' ';
                } else {
                    return address;
                }
            };

            // still no address
            if (!data.address.length) {
                for (i = data.text.length - 1; i >= 0; i--) {
                    // fixed the regex to parse email address correctly when email address has more than one @
                    data.text[i] = data.text[i].replace(/\s*\b[^@\s]+@[^\s]+\b\s*/, _regexHandler).trim();
                    if (data.address.length) {
                        break;
                    }
                }
            }
        }

        // If there's still is no text but a comment exixts, replace the two",1
"                address: 'test@subdomain.com@example.com',
                name: ''
            }
        ];
        assert.deepStrictEqual(addressparser(input), expected);
    });
});",1
" * @return {Object}
 * @private
 */

function parseExtendedQueryString(str) {
  return qs.parse(str, {
    allowPrototypes: true
  });
}",1
"'use strict'

var assert = require('node:assert')
var express = require('../')
  , request = require('supertest');

describe('req', function(){
  describe('.query', function(){
    it('should default to {}', function(done){
      var app = createApp();

      request(app)
      .get('/')
      .expect(200, '{}', done);
    });

    it('should default to parse simple keys', function (done) {
      var app = createApp();

      request(app)
      .get('/?user[name]=tj')
      .expect(200, '{""user[name]"":""tj""}', done);
    });

    describe('when ""query parser"" is extended', function () {
      it('should parse complex keys', function (done) {
        var app = createApp('extended');

        request(app)
        .get('/?foo[0][bar]=baz&foo[0][fizz]=buzz&foo[]=done!')
        .expect(200, '{""foo"":[{""bar"":""baz"",""fizz"":""buzz""},""done!""]}', done);
      });

      it('should parse parameters with dots', function (done) {
        var app = createApp('extended');

        request(app)
        .get('/?user.name=tj')
        .expect(200, '{""user.name"":""tj""}', done);
      });
    });

    describe('when ""query parser"" is simple', function () {
      it('should not parse complex keys', function (done) {
        var app = createApp('simple');

        request(app)
        .get('/?user%5Bname%5D=tj')
        .expect(200, '{""user[name]"":""tj""}', done);
      });
    });

    describe('when ""query parser"" is a function', function () {
      it('should parse using function', function (done) {
        var app = createApp(function (str) {
          return {'length': (str || '').length};
        });

        request(app)
        .get('/?user%5Bname%5D=tj')
        .expect(200, '{""length"":17}', done);
      });
    });

    describe('when ""query parser"" disabled', function () {
      it('should not parse query', function (done) {
        var app = createApp(false);

        request(app)
        .get('/?user%5Bname%5D=tj')
        .expect(200, '{}', done);
      });
    });

    describe('when ""query parser"" enabled', function () {
      it('should not parse complex keys', function (done) {
        var app = createApp(true);

        request(app)
        .get('/?user%5Bname%5D=tj')
        .expect(200, '{""user[name]"":""tj""}', done);
      });
    });

    describe('when ""query parser"" an unknown value', function () {
      it('should throw', function () {
        assert.throws(createApp.bind(null, 'bogus'),
          /unknown value.*query parser/)
      });
    });
  })
})

function createApp(setting) {
  var app = express();

  if (setting !== undefined) {
    app.set('query parser', setting);
  }

  app.use(function (req, res) {
    res.send(req.query);
  });

  return app;
}",1
"    max = options.max;
  } else { // backwards compatibility: isLength(str, min [, max])
    min = arguments[1] || 0;
    max = arguments[2];
  }

  const presentationSequences = str.match(/(\uFE0F|\uFE0E)/g) || [];
  const surrogatePairs = str.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g) || [];
  const len = str.length - presentationSequences.length - surrogatePairs.length;
  const isInsideRange = len >= min && (typeof max === 'undefined' || len <= max);

  if (isInsideRange && Array.isArray(options?.discreteLengths)) {
    return options.discreteLengths.some(discreteLen => discreteLen === len);",1
"      args: ['abc', 'i'],
      valid: ['abc', 'abcdef', '123abc', 'AbC'],
      invalid: ['acb'],
    });
  });

  it('should validate strings by length (deprecated api)', () => {
    test({
      validator: 'isLength',
      args: [2],
      valid: ['abc', 'de', 'abcd'],
      invalid: ['', 'a'],
    });
    test({
      validator: 'isLength',
      args: [2, 3],
      valid: ['abc', 'de'],
      invalid: ['', 'a', 'abcd'],
    });
    test({
      validator: 'isLength',
      args: [2, 3],
      valid: ['干𩸽', '𠮷野家'],
      invalid: ['', '𠀋', '千竈通り'],
    });
    test({
      validator: 'isLength',
      args: [0, 0],
      valid: [''],
      invalid: ['a', 'ab'],
    });
  });

  it('should validate isLocale codes', () => {
    test({
      validator: 'isLocale',
      valid: [
        'uz_Latn_UZ',
        'en',
        'gsw',
        'en-US',
        'es_ES',
        'es-419',
        'sw_KE',
        'am_ET',
        'zh-CHS',
        'ca_ES_VALENCIA',
        'en_US_POSIX',
        'hak-CN',
        'zh-Hant',
        'zh-Hans',
        'sr-Cyrl',
        'sr-Latn',
        'zh-cmn-Hans-CN',
        'cmn-Hans-CN',
        'zh-yue-HK',
        'yue-HK',
        'zh-Hans-CN',
        'sr-Latn-RS',
        'sl-rozaj',
        'sl-rozaj-biske',
        'sl-nedis',
        'de-CH-1901',
        'sl-IT-nedis',
        'hy-Latn-IT-arevela',
        'i-enochian',
        'en-scotland-fonipa',
        'sl-IT-rozaj-biske-1994',
        'de-CH-x-phonebk',
        'az-Arab-x-AZE-derbend',
        'x-whatever',
        'qaa-Qaaa-QM-x-southern',
        'de-Qaaa',
        'sr-Latn-QM',
        'sr-Qaaa-RS',
        'en-US-u-islamcal',
        'zh-CN-a-myext-x-private',
        'en-a-myext-b-another',
      ],
      invalid: [
        'lo_POP',
        '12',
        '12_DD',
        'de-419-DE',
        'a-DE',
      ],
    });
  });

  it('should validate strings by byte length (deprecated api)', () => {
    test({
      validator: 'isByteLength',
      args: [2],
      valid: ['abc', 'de', 'abcd', 'ｇｍａｉｌ'],
      invalid: ['', 'a'],
    });
    test({
      validator: 'isByteLength',
      args: [2, 3],
      valid: ['abc', 'de', 'ｇ'],
      invalid: ['', 'a', 'abcd', 'ｇｍ'],
    });
    test({
      validator: 'isByteLength',
      args: [0, 0],
      valid: [''],
      invalid: ['ｇ', 'a'],
    });
  });

  it('should validate strings by length', () => {
    test({
      validator: 'isLength',
      args: [{ min: 2 }],
      valid: ['abc', 'de', 'abcd'],
      invalid: ['', 'a'],
    });
    test({
      validator: 'isLength',
      args: [{ min: 2, max: 3 }],
      valid: ['abc', 'de'],
      invalid: ['', 'a', 'abcd'],
    });
    test({
      validator: 'isLength',
      args: [{ min: 2, max: 3 }],
      valid: ['干𩸽', '𠮷野家'],
      invalid: ['', '𠀋', '千竈通り'],
    });
    test({
      validator: 'isLength',
      args: [{ max: 3 }],
      valid: ['abc', 'de', 'a', ''],
      invalid: ['abcd'],
    });
    test({
      validator: 'isLength',
      args: [{ max: 6, discreteLengths: 5 }],
      valid: ['abcd', 'vfd', 'ff', '', 'k'],
      invalid: ['abcdefgh', 'hfjdksks'],
    });
    test({
      validator: 'isLength',
      args: [{ min: 2, max: 6, discreteLengths: 5 }],
      valid: ['bsa', 'vfvd', 'ff'],
      invalid: ['', ' ', 'hfskdunvc'],
    });
    test({
      validator: 'isLength',
      args: [{ min: 1, discreteLengths: 2 }],
      valid: [' ', 'hello', 'bsa'],
      invalid: [''],
    });
    test({
      validator: 'isLength',
      args: [{ max: 0 }],
      valid: [''],
      invalid: ['a', 'ab'],
    });
    test({
      validator: 'isLength',
      args: [{ min: 5, max: 10, discreteLengths: [2, 6, 8, 9] }],
      valid: ['helloguy', 'shopping', 'validator', 'length'],
      invalid: ['abcde', 'abcdefg'],
    });
    test({
      validator: 'isLength',
      args: [{ discreteLengths: '9' }],
      valid: ['a', 'abcd', 'abcdefghijkl'],
      invalid: [],
    });
    test({
      validator: 'isLength',
      valid: ['a', '', 'asds'],
    });
    test({
      validator: 'isLength',
      args: [{ max: 8 }],
      valid: ['👩🦰👩👩👦👦🏳️🌈', '⏩︎⏩︎⏪︎⏪︎⏭︎⏭︎⏮︎⏮︎'],
    });
  });

  it('should validate strings by byte length', () => {
    test({
      validator: 'isByteLength',
      args: [{ min: 2 }],
      valid: ['abc', 'de', 'abcd', 'ｇｍａｉｌ'],",1
"  IA5STRING:       22,
  UTCTIME:         23,
  GENERALIZEDTIME: 24,
  BMPSTRING:       30
};

/**
 * Creates a new asn1 object.
 *
 * @param tagClass the tag class for the object.
 * @param type the data type (tag number) for the object.
 * @param constructed true if the asn1 object is in constructed form.
 * @param value the value for the object, if it is not constructed.
 * @param [options] the options to use:
 *          [bitStringContents] the plain BIT STRING content including padding
 *            byte.
 *
 * @return the asn1 object.
 */
asn1.create = function(tagClass, type, constructed, value, options) {
  /* An asn1 object has a tagClass, a type, a constructed flag, and a
    value. The value's type depends on the constructed flag. If
    constructed, it will contain a list of other asn1 objects. If not,
    it will contain the ASN.1 value as an array of bytes formatted
    according to the ASN.1 data type. */

  // remove undefined values
  if(forge.util.isArray(value)) {
    var tmp = [];
    for(var i = 0; i < value.length; ++i) {
      if(value[i] !== undefined) {
        tmp.push(value[i]);
      }
    }
    value = tmp;
  }

  var obj = {
    tagClass: tagClass,
    type: type,
    constructed: constructed,
    composed: constructed || forge.util.isArray(value),
    value: value
  };
  if(options && 'bitStringContents' in options) {
    // TODO: copy byte buffer if it's a buffer not a string
    obj.bitStringContents = options.bitStringContents;
    // TODO: add readonly flag to avoid this overhead
    // save copy to detect changes
    obj.original = asn1.copy(obj);
  }
  return obj;
};

/**
 * Copies an asn1 object.
 *
 * @param obj the asn1 object.
 * @param [options] copy options:
 *          [excludeBitStringContents] true to not copy bitStringContents
 *
 * @return the a copy of the asn1 object.
 */
asn1.copy = function(obj, options) {
  var copy;

  if(forge.util.isArray(obj)) {
    copy = [];
    for(var i = 0; i < obj.length; ++i) {
      copy.push(asn1.copy(obj[i], options));
    }
    return copy;
  }

  if(typeof obj === 'string') {
    // TODO: copy byte buffer if it's a buffer not a string
    return obj;
  }

  copy = {
    tagClass: obj.tagClass,
    type: obj.type,
    constructed: obj.constructed,
    composed: obj.composed,
    value: asn1.copy(obj.value, options)
  };
  if(options && !options.excludeBitStringContents) {
    // TODO: copy byte buffer if it's a buffer not a string
    copy.bitStringContents = obj.bitStringContents;
  }
  return copy;
};

/**
 * Compares asn1 objects for equality.
 *
 * Note this function does not run in constant time.
 *
 * @param obj1 the first asn1 object.
 * @param obj2 the second asn1 object.
 * @param [options] compare options:
 *          [includeBitStringContents] true to compare bitStringContents
 *
 * @return true if the asn1 objects are equal.
 */
asn1.equals = function(obj1, obj2, options) {
  if(forge.util.isArray(obj1)) {
    if(!forge.util.isArray(obj2)) {
      return false;
    }
    if(obj1.length !== obj2.length) {
      return false;
    }
    for(var i = 0; i < obj1.length; ++i) {
      if(!asn1.equals(obj1[i], obj2[i])) {
        return false;
      }
    }
    return true;
  }

  if(typeof obj1 !== typeof obj2) {
    return false;
  }

  if(typeof obj1 === 'string') {
    return obj1 === obj2;
  }

  var equal = obj1.tagClass === obj2.tagClass &&
    obj1.type === obj2.type &&
    obj1.constructed === obj2.constructed &&
    obj1.composed === obj2.composed &&
    asn1.equals(obj1.value, obj2.value);
  if(options && options.includeBitStringContents) {
    equal = equal && (obj1.bitStringContents === obj2.bitStringContents);
  }

  return equal;
};

/**
 * Gets the length of a BER-encoded ASN.1 value.
 *
 * In case the length is not specified, undefined is returned.
 *
 * @param b the BER-encoded ASN.1 byte buffer, starting with the first
 *          length byte.
 *
 * @return the length of the BER-encoded ASN.1 value or undefined.
 */
asn1.getBerValueLength = function(b) {
  // TODO: move this function and related DER/BER functions to a der.js
  // file; better abstract ASN.1 away from der/ber.
  var b2 = b.getByte();
  if(b2 === 0x80) {
    return undefined;
  }

  // see if the length is ""short form"" or ""long form"" (bit 8 set)
  var length;
  var longForm = b2 & 0x80;
  if(!longForm) {
    // length is just the first byte
    length = b2;
  } else {
    // the number of bytes the length is specified in bits 7 through 1
    // and each length byte is in big-endian base-256
    length = b.getInt((b2 & 0x7F) << 3);
  }
  return length;
};

/**
 * Check if the byte buffer has enough bytes. Throws an Error if not.
 *
 * @param bytes the byte buffer to parse from.
 * @param remaining the bytes remaining in the current parsing state.
 * @param n the number of bytes the buffer must have.
 */
function _checkBufferLength(bytes, remaining, n) {
  if(n > remaining) {
    var error = new Error('Too few bytes to parse DER.');
    error.available = bytes.length();
    error.remaining = remaining;
    error.requested = n;
    throw error;
  }
}

/**
 * Gets the length of a BER-encoded ASN.1 value.
 *
 * In case the length is not specified, undefined is returned.
 *
 * @param bytes the byte buffer to parse from.
 * @param remaining the bytes remaining in the current parsing state.
 *
 * @return the length of the BER-encoded ASN.1 value or undefined.
 */
var _getValueLength = function(bytes, remaining) {
  // TODO: move this function and related DER/BER functions to a der.js
  // file; better abstract ASN.1 away from der/ber.
  // fromDer already checked that this byte exists
  var b2 = bytes.getByte();
  remaining--;
  if(b2 === 0x80) {
    return undefined;
  }

  // see if the length is ""short form"" or ""long form"" (bit 8 set)
  var length;
  var longForm = b2 & 0x80;
  if(!longForm) {
    // length is just the first byte
    length = b2;
  } else {
    // the number of bytes the length is specified in bits 7 through 1
    // and each length byte is in big-endian base-256
    var longFormBytes = b2 & 0x7F;
    _checkBufferLength(bytes, remaining, longFormBytes);
    length = bytes.getInt(longFormBytes << 3);
  }
  // FIXME: this will only happen for 32 bit getInt with high bit set
  if(length < 0) {
    throw new Error('Negative length: ' + length);
  }
  return length;
};

/**
 * Parses an asn1 object from a byte buffer in DER format.
 *
 * @param bytes the byte buffer to parse from.
 * @param [strict] true to be strict when checking value lengths, false to
 *          allow truncated values (default: true).
 * @param [options] object with options or boolean strict flag
 *          [strict] true to be strict when checking value lengths, false to
 *            allow truncated values (default: true).
 *          [parseAllBytes] true to ensure all bytes are parsed
 *            (default: true)
 *          [decodeBitStrings] true to attempt to decode the content of
 *            BIT STRINGs (not OCTET STRINGs) using strict mode. Note that
 *            without schema support to understand the data context this can
 *            erroneously decode values that happen to be valid ASN.1. This
 *            flag will be deprecated or removed as soon as schema support is
 *            available. (default: true)
 *
 * @throws Will throw an error for various malformed input conditions.
 *
 * @return the parsed asn1 object.
 */
asn1.fromDer = function(bytes, options) {
  if(options === undefined) {
    options = {
      strict: true,
      parseAllBytes: true,
      decodeBitStrings: true
    };
  }
  if(typeof options === 'boolean') {
    options = {
      strict: options,
      parseAllBytes: true,
      decodeBitStrings: true
    };
  }
  if(!('strict' in options)) {
    options.strict = true;
  }
  if(!('parseAllBytes' in options)) {
    options.parseAllBytes = true;
  }
  if(!('decodeBitStrings' in options)) {
    options.decodeBitStrings = true;
  }

  // wrap in buffer if needed
  if(typeof bytes === 'string') {
    bytes = forge.util.createBuffer(bytes);
  }

  var byteCount = bytes.length();
  var value = _fromDer(bytes, bytes.length(), 0, options);
  if(options.parseAllBytes && bytes.length() !== 0) {
    var error = new Error('Unparsed DER bytes remain after ASN.1 parsing.');
    error.byteCount = byteCount;
    error.remaining = bytes.length();
    throw error;
  }
  return value;
};

/**
 * Internal function to parse an asn1 object from a byte buffer in DER format.
 *
 * @param bytes the byte buffer to parse from.
 * @param remaining the number of bytes remaining for this chunk.
 * @param depth the current parsing depth.
 * @param options object with same options as fromDer().
 *
 * @return the parsed asn1 object.
 */
function _fromDer(bytes, remaining, depth, options) {
  // temporary storage for consumption calculations
  var start;

  // minimum length for ASN.1 DER structure is 2
  _checkBufferLength(bytes, remaining, 2);
",1
"  for(var i = 2; i < values.length; ++i) {
    // produce value bytes in reverse because we don't know how many
    // bytes it will take to store the value
    last = true;
    valueBytes = [];
    value = parseInt(values[i], 10);
    do {
      b = value & 0x7F;
      value = value >>> 7;
      // if value is not last, then turn on 8th bit
      if(!last) {
        b |= 0x80;
      }
      valueBytes.push(b);
      last = false;
    } while(value > 0);

    // add value bytes in reverse (needs to be in big endian)
    for(var n = valueBytes.length - 1; n >= 0; --n) {
      bytes.putByte(valueBytes[n]);
    }
  }

  return bytes;
};

/**
 * Converts a DER-encoded byte buffer to an OID dot-separated string. The
 * byte buffer should contain only the DER-encoded value, not any tag or
 * length bytes.
 *
 * @param bytes the byte buffer.
 *
 * @return the OID dot-separated string.
 */
asn1.derToOid = function(bytes) {
  var oid;

  // wrap in buffer if needed
  if(typeof bytes === 'string') {
    bytes = forge.util.createBuffer(bytes);
  }

  // first byte is 40 * value1 + value2
  var b = bytes.getByte();
  oid = Math.floor(b / 40) + '.' + (b % 40);

  // other bytes are each value in base 128 with 8th bit set except for
  // the last byte for each value
  var value = 0;
  while(bytes.length() > 0) {
    b = bytes.getByte();
    value = value << 7;
    // not the last byte for the value
    if(b & 0x80) {
      value += b & 0x7F;
    } else {
      // last byte
      oid += '.' + (value + b);",1
"    // TODO: add more ASN.1 coverage

    it('should convert an OID to DER', function() {
      ASSERT.equal(ASN1.oidToDer('1.2.840.113549').toHex(), '2a864886f70d');
    });

    it('should convert an OID from DER', function() {
      var der = UTIL.hexToBytes('2a864886f70d');
      ASSERT.equal(ASN1.derToOid(der), '1.2.840.113549');
    });

    it('should convert INTEGER 0 to DER', function() {
      ASSERT.equal(ASN1.integerToDer(0).toHex(), '00');
    });

    it('should convert INTEGER 1 to DER', function() {
      ASSERT.equal(ASN1.integerToDer(1).toHex(), '01');",1
"
@EnableDocumentation({
  isMasterAdminApiDocs: true,
})
@AllowAccessIfSubscriptionIsUnpaid()
@TableAccessControl({
  create: [Permission.Public],
  read: [Permission.CurrentUser],
  delete: [Permission.CurrentUser],
  update: [Permission.CurrentUser],
})
@CrudApiEndpoint(new Route(""/user""))
@SlugifyColumn(""name"", ""slug"")",1
"import { PromiseVoidFunction } from ""Common/Types/FunctionTypes"";
import Express, { ExpressApplication } from ""Common/Server/Utils/Express"";
import logger from ""Common/Server/Utils/Logger"";
import App from ""Common/Server/Utils/StartServer"";
import ""ejs"";

export const APP_NAME: string = ""admin"";

const app: ExpressApplication = Express.getExpressApp();

const init: PromiseVoidFunction = async (): Promise<void> => {
  try {
    // init the app
    await App.init({
      appName: APP_NAME,
      port: undefined,
      isFrontendApp: true,
      statusOptions: {
        liveCheck: async () => {},
        readyCheck: async () => {},
      },
    });

    // add default routes
    await App.addDefaultRoutes();
  } catch (err) {
    logger.error(""App Init Failed:"");",1
"            }
          }

          logger.debug(""Rendering index page with variables: "");
          logger.debug(variables);

          return res.render(""/usr/src/app/views/index.ejs"", {
            enableGoogleTagManager: IsBillingEnabled || false,
            ...variables,
          });
        } catch (err) {
          return next(err);",1
"
/**
 * Count the number of parameters, stopping once limit reached
 *
 * @param {string} body
 * @param {number} limit
 * @api private
 */

function parameterCount (body, limit) {
  var len = body.split('&').length

  return len > limit ? undefined : len - 1
}",1
"  {
    name: '@sentry/node',
    path: 'packages/node/build/esm/index.js',
    import: createImport('init'),
    ignore: [...builtinModules, ...nodePrefixedBuiltinModules],
    gzip: true,
    limit: '152 KB',
  },
  {
    name: '@sentry/node - without tracing',
    path: 'packages/node/build/esm/index.js',
    import: createImport('initWithoutDefaultIntegrations', 'getDefaultIntegrationsWithoutPerformance'),
    gzip: true,",1
"            method: 'GET',
            'sentry.op': 'http.server',
            'sentry.origin': 'auto.http.astro',
            'sentry.sample_rate': 1,
            'sentry.source': 'route',
            url: expect.stringContaining('/test-ssr'),
          },
          op: 'http.server',
          origin: 'auto.http.astro',
          status: 'ok',
          span_id: expect.stringMatching(/[a-f0-9]{16}/),
          trace_id: expect.stringMatching(/[a-f0-9]{32}/),
        },
      },
      environment: 'qa',
      event_id: expect.stringMatching(/[a-f0-9]{32}/),
      platform: 'node',
      request: {
        cookies: {},
        headers: expect.objectContaining({
          // demonstrates that request data integration can extract headers
          accept: expect.any(String),
          'accept-encoding': expect.any(String),
          'user-agent': expect.any(String),
        }),
        method: 'GET',
        url: expect.stringContaining('/test-ssr'),
      },
      sdk: {
        integrations: expect.any(Array),
        name: 'sentry.javascript.astro',
        packages: expect.any(Array),
        version: expect.any(String),
      },
      server_name: expect.any(String),
      spans: expect.any(Array),
      start_timestamp: expect.any(Number),
      timestamp: expect.any(Number),
      transaction: 'GET /test-ssr',
      transaction_info: { source: 'route' },
      type: 'transaction',
    });
  });
});

test.describe('nested SSR routes (client, server, server request)', () => {
  /** The user-page route fetches from an endpoint and creates a deeply nested span structure:
   * pageload — /user-page/myUsername123
   * ├── browser.** — multiple browser spans
   * └── browser.request — /user-page/myUsername123
   *     └── http.server — GET /user-page/[userId]                    (SSR page request)
   *         └── http.client — GET /api/user/myUsername123.json       (executing fetch call from SSR page - span)
   *             └── http.server — GET /api/user/myUsername123.json   (server request)
   */
  test('sends connected server and client pageload and request spans with the same trace id', async ({ page }) => {
    const clientPageloadTxnPromise = waitForTransaction('astro-4', txnEvent => {
      return txnEvent?.transaction?.startsWith('/user-page/') ?? false;
    });

    const serverPageRequestTxnPromise = waitForTransaction('astro-4', txnEvent => {
      return txnEvent?.transaction?.startsWith('GET /user-page/') ?? false;
    });

    const serverHTTPServerRequestTxnPromise = waitForTransaction('astro-4', txnEvent => {
      return txnEvent?.transaction?.startsWith('GET /api/user/') ?? false;
    });

    await page.goto('/user-page/myUsername123');

    const clientPageloadTxn = await clientPageloadTxnPromise;
    const serverPageRequestTxn = await serverPageRequestTxnPromise;
    const serverHTTPServerRequestTxn = await serverHTTPServerRequestTxnPromise;
    const serverRequestHTTPClientSpan = serverPageRequestTxn.spans?.find(
      span => span.op === 'http.client' && span.description?.includes('/api/user/'),
    );

    const clientPageloadTraceId = clientPageloadTxn.contexts?.trace?.trace_id;

    // Verify all spans have the same trace ID
    expect(clientPageloadTraceId).toEqual(serverPageRequestTxn.contexts?.trace?.trace_id);
    expect(clientPageloadTraceId).toEqual(serverHTTPServerRequestTxn.contexts?.trace?.trace_id);
    expect(clientPageloadTraceId).toEqual(serverRequestHTTPClientSpan?.trace_id);

    // serverPageRequest has no parent (root span)
    expect(serverPageRequestTxn.contexts?.trace?.parent_span_id).toBeUndefined();

    // clientPageload's parent and serverRequestHTTPClient's parent is serverPageRequest
    const serverPageRequestSpanId = serverPageRequestTxn.contexts?.trace?.span_id;
    expect(clientPageloadTxn.contexts?.trace?.parent_span_id).toEqual(serverPageRequestSpanId);
    expect(serverRequestHTTPClientSpan?.parent_span_id).toEqual(serverPageRequestSpanId);

    // serverHTTPServerRequest's parent is serverRequestHTTPClient
    expect(serverHTTPServerRequestTxn.contexts?.trace?.parent_span_id).toEqual(serverRequestHTTPClientSpan?.span_id);
  });

  test('sends parametrized pageload, server and API request transaction names', async ({ page }) => {
    const clientPageloadTxnPromise = waitForTransaction('astro-4', txnEvent => {
      return txnEvent?.transaction?.startsWith('/user-page/') ?? false;
    });

    const serverPageRequestTxnPromise = waitForTransaction('astro-4', txnEvent => {
      return txnEvent?.transaction?.startsWith('GET /user-page/') ?? false;
    });

    const serverHTTPServerRequestTxnPromise = waitForTransaction('astro-4', txnEvent => {
      return txnEvent?.transaction?.startsWith('GET /api/user/') ?? false;
    });

    await page.goto('/user-page/myUsername123');

    const clientPageloadTxn = await clientPageloadTxnPromise;
    const serverPageRequestTxn = await serverPageRequestTxnPromise;
    const serverHTTPServerRequestTxn = await serverHTTPServerRequestTxnPromise;

    const serverRequestHTTPClientSpan = serverPageRequestTxn.spans?.find(
      span => span.op === 'http.client' && span.description?.includes('/api/user/'),
    );

    const routeNameMetaContent = await page.locator('meta[name=""sentry-route-name""]').getAttribute('content');
    expect(routeNameMetaContent).toBe('%2Fuser-page%2F%5BuserId%5D');

    // Client pageload transaction - actual URL with pageload operation
    expect(clientPageloadTxn).toMatchObject({
      transaction: '/user-page/[userId]',
      transaction_info: { source: 'route' },
      contexts: {
        trace: {
          op: 'pageload',
          origin: 'auto.pageload.astro',
          data: {
            'sentry.op': 'pageload',
            'sentry.origin': 'auto.pageload.astro',
            'sentry.source': 'route',
          },
        },
      },
    });

    // Server page request transaction - parametrized transaction name with actual URL in data
    expect(serverPageRequestTxn).toMatchObject({
      transaction: 'GET /user-page/[userId]',
      transaction_info: { source: 'route' },
      contexts: {
        trace: {
          op: 'http.server',
          origin: 'auto.http.astro',
          data: {
            'sentry.op': 'http.server',
            'sentry.origin': 'auto.http.astro',
            'sentry.source': 'route',
            url: expect.stringContaining('/user-page/myUsername123'),
          },
        },
      },
      request: { url: expect.stringContaining('/user-page/myUsername123') },
    });

    // HTTP client span - actual API URL with client operation
    expect(serverRequestHTTPClientSpan).toMatchObject({
      op: 'http.client',
      origin: 'auto.http.otel.node_fetch',
      description: 'GET http://localhost:3030/api/user/myUsername123.json', // http.client does not need to be parametrized
      data: {
        'sentry.op': 'http.client',
        'sentry.origin': 'auto.http.otel.node_fetch',
        'url.full': expect.stringContaining('/api/user/myUsername123.json'),
        'url.path': '/api/user/myUsername123.json',
        url: expect.stringContaining('/api/user/myUsername123.json'),
      },
    });

    // Server HTTP request transaction - should be parametrized
    expect(serverHTTPServerRequestTxn).toMatchObject({
      transaction: 'GET /api/user/myUsername123.json', // todo: parametrize
      transaction_info: { source: 'route' },
      contexts: {
        trace: {
          op: 'http.server',
          origin: 'auto.http.astro',
          data: {
            'sentry.op': 'http.server',
            'sentry.origin': 'auto.http.astro',
            'sentry.source': 'route',
            url: expect.stringContaining('/api/user/myUsername123.json'),
          },
        },
      },
      request: { url: expect.stringContaining('/api/user/myUsername123.json') },
    });
  });

  test('sends parametrized pageload and server transaction names for catch-all routes', async ({ page }) => {
    const clientPageloadTxnPromise = waitForTransaction('astro-4', txnEvent => {
      return txnEvent?.transaction?.startsWith('/catchAll/') ?? false;
    });

    const serverPageRequestTxnPromise = waitForTransaction('astro-4', txnEvent => {
      return txnEvent?.transaction?.startsWith('GET /catchAll/') ?? false;
    });

    await page.goto('/catchAll/hell0/whatever-do');

    const routeNameMetaContent = await page.locator('meta[name=""sentry-route-name""]').getAttribute('content');
    expect(routeNameMetaContent).toBe('%2FcatchAll%2F%5Bpath%5D');

    const clientPageloadTxn = await clientPageloadTxnPromise;
    const serverPageRequestTxn = await serverPageRequestTxnPromise;

    expect(clientPageloadTxn).toMatchObject({
      transaction: '/catchAll/[path]',
      transaction_info: { source: 'route' },
      contexts: {
        trace: {
          op: 'pageload',
          origin: 'auto.pageload.astro',
          data: {
            'sentry.op': 'pageload',
            'sentry.origin': 'auto.pageload.astro',
            'sentry.source': 'route',
          },
        },
      },
    });

    expect(serverPageRequestTxn).toMatchObject({
      transaction: 'GET /catchAll/[path]',
      transaction_info: { source: 'route' },
      contexts: {
        trace: {
          op: 'http.server',
          origin: 'auto.http.astro',
          data: {
            'sentry.op': 'http.server',
            'sentry.origin': 'auto.http.astro',
            'sentry.source': 'route',
            url: expect.stringContaining('/catchAll/hell0/whatever-do'),
          },
        },
      },
      request: { url: expect.stringContaining('/catchAll/hell0/whatever-do') },
    });
  });
});

// Case for `user-page/[id]` vs. `user-page/settings` static routes
test.describe('parametrized vs static paths', () => {
  test('should use static route name for static route in parametrized path', async ({ page }) => {
    const clientPageloadTxnPromise = waitForTransaction('astro-4', txnEvent => {
      return txnEvent?.transaction?.startsWith('/user-page/') ?? false;
    });

    const serverPageRequestTxnPromise = waitForTransaction('astro-4', txnEvent => {
      return txnEvent?.transaction?.startsWith('GET /user-page/') ?? false;
    });

    await page.goto('/user-page/settings');

    const clientPageloadTxn = await clientPageloadTxnPromise;
    const serverPageRequestTxn = await serverPageRequestTxnPromise;

    expect(clientPageloadTxn).toMatchObject({
      transaction: '/user-page/settings',
      transaction_info: { source: 'route' },
      contexts: {
        trace: {
          op: 'pageload',
          origin: 'auto.pageload.astro',
          data: {
            'sentry.op': 'pageload',
            'sentry.origin': 'auto.pageload.astro',
            'sentry.source': 'route',
          },
        },
      },
    });

    expect(serverPageRequestTxn).toMatchObject({
      transaction: 'GET /user-page/settings',
      transaction_info: { source: 'route' },
      contexts: {
        trace: {
          op: 'http.server',
          origin: 'auto.http.astro',
          data: {
            'sentry.op': 'http.server',
            'sentry.origin': 'auto.http.astro',
            'sentry.source': 'route',
            url: expect.stringContaining('/user-page/settings'),
          },
        },
      },
      request: { url: expect.stringContaining('/user-page/settings') },
    });
  });",1
"            method: 'GET',
            'sentry.op': 'http.server',
            'sentry.origin': 'auto.http.astro',
            'sentry.sample_rate': 1,
            'sentry.source': 'route',
            url: expect.stringContaining('/test-ssr'),
          },
          op: 'http.server',
          origin: 'auto.http.astro',
          status: 'ok',
          span_id: expect.stringMatching(/[a-f0-9]{16}/),
          trace_id: expect.stringMatching(/[a-f0-9]{32}/),
        },
      },
      environment: 'qa',
      event_id: expect.stringMatching(/[a-f0-9]{32}/),
      platform: 'node',
      request: {
        cookies: {},
        headers: expect.objectContaining({
          // demonstrates that request data integration can extract headers
          accept: expect.any(String),
          'accept-encoding': expect.any(String),
          'user-agent': expect.any(String),
        }),
        method: 'GET',
        url: expect.stringContaining('/test-ssr'),
      },
      sdk: {
        integrations: expect.any(Array),
        name: 'sentry.javascript.astro',
        packages: expect.any(Array),
        version: expect.any(String),
      },
      server_name: expect.any(String),
      spans: expect.any(Array),
      start_timestamp: expect.any(Number),
      timestamp: expect.any(Number),
      transaction: 'GET /test-ssr',
      transaction_info: {
        source: 'route',
      },
      type: 'transaction',
    });
  });
});

test.describe('nested SSR routes (client, server, server request)', () => {
  /** The user-page route fetches from an endpoint and creates a deeply nested span structure:
   * pageload — /user-page/myUsername123
   * ├── browser.** — multiple browser spans
   * └── browser.request — /user-page/myUsername123
   *     └── http.server — GET /user-page/[userId]                    (SSR page request)
   *         └── http.client — GET /api/user/myUsername123.json       (executing fetch call from SSR page - span)
   *             └── http.server — GET /api/user/myUsername123.json   (server request)
   */
  test('sends connected server and client pageload and request spans with the same trace id', async ({ page }) => {
    const clientPageloadTxnPromise = waitForTransaction('astro-5', txnEvent => {
      return txnEvent?.transaction?.startsWith('/user-page/') ?? false;
    });

    const serverPageRequestTxnPromise = waitForTransaction('astro-5', txnEvent => {
      return txnEvent?.transaction?.startsWith('GET /user-page/') ?? false;
    });

    const serverHTTPServerRequestTxnPromise = waitForTransaction('astro-5', txnEvent => {
      return txnEvent?.transaction?.startsWith('GET /api/user/') ?? false;
    });

    await page.goto('/user-page/myUsername123');

    const clientPageloadTxn = await clientPageloadTxnPromise;
    const serverPageRequestTxn = await serverPageRequestTxnPromise;
    const serverHTTPServerRequestTxn = await serverHTTPServerRequestTxnPromise;
    const serverRequestHTTPClientSpan = serverPageRequestTxn.spans?.find(
      span => span.op === 'http.client' && span.description?.includes('/api/user/'),
    );

    const clientPageloadTraceId = clientPageloadTxn.contexts?.trace?.trace_id;

    // Verify all spans have the same trace ID
    expect(clientPageloadTraceId).toEqual(serverPageRequestTxn.contexts?.trace?.trace_id);
    expect(clientPageloadTraceId).toEqual(serverHTTPServerRequestTxn.contexts?.trace?.trace_id);
    expect(clientPageloadTraceId).toEqual(serverRequestHTTPClientSpan?.trace_id);

    // serverPageRequest has no parent (root span)
    expect(serverPageRequestTxn.contexts?.trace?.parent_span_id).toBeUndefined();

    // clientPageload's parent and serverRequestHTTPClient's parent is serverPageRequest
    const serverPageRequestSpanId = serverPageRequestTxn.contexts?.trace?.span_id;
    expect(clientPageloadTxn.contexts?.trace?.parent_span_id).toEqual(serverPageRequestSpanId);
    expect(serverRequestHTTPClientSpan?.parent_span_id).toEqual(serverPageRequestSpanId);

    // serverHTTPServerRequest's parent is serverRequestHTTPClient
    expect(serverHTTPServerRequestTxn.contexts?.trace?.parent_span_id).toEqual(serverRequestHTTPClientSpan?.span_id);
  });

  test('sends parametrized pageload, server and API request transaction names', async ({ page }) => {
    const clientPageloadTxnPromise = waitForTransaction('astro-5', txnEvent => {
      return txnEvent?.transaction?.startsWith('/user-page/') ?? false;
    });

    const serverPageRequestTxnPromise = waitForTransaction('astro-5', txnEvent => {
      return txnEvent?.transaction?.startsWith('GET /user-page/') ?? false;
    });

    const serverHTTPServerRequestTxnPromise = waitForTransaction('astro-5', txnEvent => {
      return txnEvent?.transaction?.startsWith('GET /api/user/') ?? false;
    });

    await page.goto('/user-page/myUsername123');

    const clientPageloadTxn = await clientPageloadTxnPromise;
    const serverPageRequestTxn = await serverPageRequestTxnPromise;
    const serverHTTPServerRequestTxn = await serverHTTPServerRequestTxnPromise;

    const serverRequestHTTPClientSpan = serverPageRequestTxn.spans?.find(
      span => span.op === 'http.client' && span.description?.includes('/api/user/'),
    );

    const routeNameMetaContent = await page.locator('meta[name=""sentry-route-name""]').getAttribute('content');
    expect(routeNameMetaContent).toBe('%2Fuser-page%2F%5BuserId%5D');

    // Client pageload transaction - actual URL with pageload operation
    expect(clientPageloadTxn).toMatchObject({
      transaction: '/user-page/[userId]',
      transaction_info: { source: 'route' },
      contexts: {
        trace: {
          op: 'pageload',
          origin: 'auto.pageload.astro',
          data: {
            'sentry.op': 'pageload',
            'sentry.origin': 'auto.pageload.astro',
            'sentry.source': 'route',
          },
        },
      },
    });

    // Server page request transaction - parametrized transaction name with actual URL in data
    expect(serverPageRequestTxn).toMatchObject({
      transaction: 'GET /user-page/[userId]',
      transaction_info: { source: 'route' },
      contexts: {
        trace: {
          op: 'http.server',
          origin: 'auto.http.astro',
          data: {
            'sentry.op': 'http.server',
            'sentry.origin': 'auto.http.astro',
            'sentry.source': 'route',
            url: expect.stringContaining('/user-page/myUsername123'),
          },
        },
      },
      request: { url: expect.stringContaining('/user-page/myUsername123') },
    });

    // HTTP client span - actual API URL with client operation
    expect(serverRequestHTTPClientSpan).toMatchObject({
      op: 'http.client',
      origin: 'auto.http.otel.node_fetch',
      description: 'GET http://localhost:3030/api/user/myUsername123.json', // http.client does not need to be parametrized
      data: {
        'sentry.op': 'http.client',
        'sentry.origin': 'auto.http.otel.node_fetch',
        'url.full': expect.stringContaining('/api/user/myUsername123.json'),
        'url.path': '/api/user/myUsername123.json',
        url: expect.stringContaining('/api/user/myUsername123.json'),
      },
    });

    // Server HTTP request transaction
    expect(serverHTTPServerRequestTxn).toMatchObject({
      transaction: 'GET /api/user/[userId].json',
      transaction_info: { source: 'route' },
      contexts: {
        trace: {
          op: 'http.server',
          origin: 'auto.http.astro',
          data: {
            'sentry.op': 'http.server',
            'sentry.origin': 'auto.http.astro',
            'sentry.source': 'route',
            url: expect.stringContaining('/api/user/myUsername123.json'),
          },
        },
      },
      request: { url: expect.stringContaining('/api/user/myUsername123.json') },
    });
  });

  test('sends parametrized pageload and server transaction names for catch-all routes', async ({ page }) => {
    const clientPageloadTxnPromise = waitForTransaction('astro-5', txnEvent => {
      return txnEvent?.transaction?.startsWith('/catchAll/') ?? false;
    });

    const serverPageRequestTxnPromise = waitForTransaction('astro-5', txnEvent => {
      return txnEvent?.transaction?.startsWith('GET /catchAll/') ?? false;
    });

    await page.goto('/catchAll/hell0/whatever-do');

    const routeNameMetaContent = await page.locator('meta[name=""sentry-route-name""]').getAttribute('content');
    expect(routeNameMetaContent).toBe('%2FcatchAll%2F%5B...path%5D');

    const clientPageloadTxn = await clientPageloadTxnPromise;
    const serverPageRequestTxn = await serverPageRequestTxnPromise;

    expect(clientPageloadTxn).toMatchObject({
      transaction: '/catchAll/[...path]',
      transaction_info: { source: 'route' },
      contexts: {
        trace: {
          op: 'pageload',
          origin: 'auto.pageload.astro',
          data: {
            'sentry.op': 'pageload',
            'sentry.origin': 'auto.pageload.astro',
            'sentry.source': 'route',
          },
        },
      },
    });

    expect(serverPageRequestTxn).toMatchObject({
      transaction: 'GET /catchAll/[...path]',
      transaction_info: { source: 'route' },
      contexts: {
        trace: {
          op: 'http.server',
          origin: 'auto.http.astro',
          data: {
            'sentry.op': 'http.server',
            'sentry.origin': 'auto.http.astro',
            'sentry.source': 'route',
            url: expect.stringContaining('/catchAll/hell0/whatever-do'),
          },
        },
      },
      request: { url: expect.stringContaining('/catchAll/hell0/whatever-do') },
    });
  });
});

// Case for `user-page/[id]` vs. `user-page/settings` static routes
test.describe('parametrized vs static paths', () => {
  test('should use static route name for static route in parametrized path', async ({ page }) => {
    const clientPageloadTxnPromise = waitForTransaction('astro-5', txnEvent => {
      return txnEvent?.transaction?.startsWith('/user-page/') ?? false;
    });

    const serverPageRequestTxnPromise = waitForTransaction('astro-5', txnEvent => {
      return txnEvent?.transaction?.startsWith('GET /user-page/') ?? false;
    });

    await page.goto('/user-page/settings');

    const clientPageloadTxn = await clientPageloadTxnPromise;
    const serverPageRequestTxn = await serverPageRequestTxnPromise;

    expect(clientPageloadTxn).toMatchObject({
      transaction: '/user-page/settings',
      transaction_info: { source: 'route' },
      contexts: {
        trace: {
          op: 'pageload',
          origin: 'auto.pageload.astro',
          data: {
            'sentry.op': 'pageload',
            'sentry.origin': 'auto.pageload.astro',
            'sentry.source': 'route',
          },
        },
      },
    });

    expect(serverPageRequestTxn).toMatchObject({
      transaction: 'GET /user-page/settings',
      transaction_info: { source: 'route' },
      contexts: {
        trace: {
          op: 'http.server',
          origin: 'auto.http.astro',
          data: {
            'sentry.op': 'http.server',
            'sentry.origin': 'auto.http.astro',
            'sentry.source': 'route',
            url: expect.stringContaining('/user-page/settings'),
          },
        },
      },
      request: { url: expect.stringContaining('/user-page/settings') },
    });
  });",1
"      contexts: {
        trace: {
          data: expect.objectContaining({
            'sentry.op': 'http.server',
            'sentry.origin': 'auto.http.astro',
            'sentry.source': 'route',
          }),
          op: 'http.server',
          origin: 'auto.http.astro',
          span_id: expect.stringMatching(/[a-f0-9]{16}/),
          trace_id: expect.stringMatching(/[a-f0-9]{32}/),
        },",1
"      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-transaction',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: expect.stringMatching(/[a-f0-9]{32}/),
    origin: 'auto.http.otel.http',",1
"      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-transaction',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: expect.stringMatching(/[a-f0-9]{32}/),
    origin: 'auto.http.otel.http',",1
"      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-transaction',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: expect.stringMatching(/[a-f0-9]{32}/),
    origin: 'auto.http.otel.http',",1
"  const outgoingHttpSpan = outboundTransaction?.spans?.find(span => span.op === 'http.client');

  expect(outgoingHttpSpan).toBeDefined();

  const outgoingHttpSpanId = outgoingHttpSpan?.span_id;

  expect(traceId).toEqual(expect.any(String));

  // data is passed through from the inbound request, to verify we have the correct headers set
  const inboundHeaderSentryTrace = data.headers?.['sentry-trace'];
  const inboundHeaderBaggage = data.headers?.['baggage'];

  expect(inboundHeaderSentryTrace).toEqual(`${traceId}-${outgoingHttpSpanId}-1`);
  expect(inboundHeaderBaggage).toBeDefined();

  const baggage = (inboundHeaderBaggage || '').split(',');
  expect(baggage).toEqual(
    expect.arrayContaining([
      'sentry-environment=qa',
      `sentry-trace_id=${traceId}`,
      expect.stringMatching(/sentry-public_key=/),
    ]),
  );

  expect(outboundTransaction.contexts?.trace).toEqual({
    data: {
      'sentry.source': 'route',
      'sentry.origin': 'auto.http.otel.http',
      'sentry.op': 'http.server',
      'sentry.sample_rate': 1,
      url: `http://localhost:3030/test-outgoing-http/${id}`,
      'otel.kind': 'SERVER',
      'http.response.status_code': 200,
      'http.url': `http://localhost:3030/test-outgoing-http/${id}`,
      'http.host': 'localhost:3030',
      'net.host.name': 'localhost',
      'http.method': 'GET',
      'http.scheme': 'http',
      'http.target': `/test-outgoing-http/${id}`,
      'http.user_agent': expect.any(String),
      'http.flavor': '1.1',
      'net.transport': 'ip_tcp',
      'net.host.ip': expect.any(String),
      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-outgoing-http/:id',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: traceId,
    origin: 'auto.http.otel.http',
  });

  expect(inboundTransaction.contexts?.trace).toEqual({
    data: {
      'sentry.source': 'route',
      'sentry.origin': 'auto.http.otel.http',
      'sentry.op': 'http.server',
      url: `http://localhost:3030/test-inbound-headers/${id}`,
      'otel.kind': 'SERVER',
      'http.response.status_code': 200,
      'http.url': `http://localhost:3030/test-inbound-headers/${id}`,
      'http.host': 'localhost:3030',
      'net.host.name': 'localhost',
      'http.method': 'GET',
      'http.scheme': 'http',
      'http.target': `/test-inbound-headers/${id}`,
      'http.flavor': '1.1',
      'net.transport': 'ip_tcp',
      'net.host.ip': expect.any(String),
      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-inbound-headers/:id',
    },
    op: 'http.server',
    parent_span_id: outgoingHttpSpanId,
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: traceId,
    origin: 'auto.http.otel.http',
  });
});

test('Propagates trace for outgoing fetch requests', async ({ baseURL }) => {
  const id = crypto.randomUUID();

  const inboundTransactionPromise = waitForTransaction('nestjs-distributed-tracing', transactionEvent => {
    return (
      transactionEvent?.contexts?.trace?.op === 'http.server' &&
      transactionEvent.contexts?.trace?.data?.['http.target'] === `/test-inbound-headers/${id}`
    );
  });

  const outboundTransactionPromise = waitForTransaction('nestjs-distributed-tracing', transactionEvent => {
    return (
      transactionEvent?.contexts?.trace?.op === 'http.server' &&
      transactionEvent.contexts?.trace?.data?.['http.target'] === `/test-outgoing-fetch/${id}`
    );
  });

  const response = await fetch(`${baseURL}/test-outgoing-fetch/${id}`);
  const data = await response.json();

  const inboundTransaction = await inboundTransactionPromise;
  const outboundTransaction = await outboundTransactionPromise;

  const traceId = outboundTransaction?.contexts?.trace?.trace_id;
  const outgoingHttpSpan = outboundTransaction?.spans?.find(span => span.op === 'http.client');

  expect(outgoingHttpSpan).toBeDefined();

  const outgoingHttpSpanId = outgoingHttpSpan?.span_id;

  expect(traceId).toEqual(expect.any(String));

  // data is passed through from the inbound request, to verify we have the correct headers set
  const inboundHeaderSentryTrace = data.headers?.['sentry-trace'];
  const inboundHeaderBaggage = data.headers?.['baggage'];

  expect(inboundHeaderSentryTrace).toEqual(`${traceId}-${outgoingHttpSpanId}-1`);
  expect(inboundHeaderBaggage).toBeDefined();

  const baggage = (inboundHeaderBaggage || '').split(',');
  expect(baggage).toEqual(
    expect.arrayContaining([
      'sentry-environment=qa',
      `sentry-trace_id=${traceId}`,
      expect.stringMatching(/sentry-public_key=/),
    ]),
  );

  expect(outboundTransaction.contexts?.trace).toEqual({
    data: {
      'sentry.source': 'route',
      'sentry.origin': 'auto.http.otel.http',
      'sentry.op': 'http.server',
      'sentry.sample_rate': 1,
      url: `http://localhost:3030/test-outgoing-fetch/${id}`,
      'otel.kind': 'SERVER',
      'http.response.status_code': 200,
      'http.url': `http://localhost:3030/test-outgoing-fetch/${id}`,
      'http.host': 'localhost:3030',
      'net.host.name': 'localhost',
      'http.method': 'GET',
      'http.scheme': 'http',
      'http.target': `/test-outgoing-fetch/${id}`,
      'http.user_agent': expect.any(String),
      'http.flavor': '1.1',
      'net.transport': 'ip_tcp',
      'net.host.ip': expect.any(String),
      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-outgoing-fetch/:id',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: traceId,
    origin: 'auto.http.otel.http',",1
"      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-transaction',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: expect.stringMatching(/[a-f0-9]{32}/),
    origin: 'auto.http.otel.http',",1
"      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/example-module/transaction',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: expect.stringMatching(/[a-f0-9]{32}/),
    origin: 'auto.http.otel.http',",1
"      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/example-module/transaction',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: expect.stringMatching(/[a-f0-9]{32}/),
    origin: 'auto.http.otel.http',",1
"/// <reference types=""next"" />
/// <reference types=""next/image-types/global"" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.",1
"  }

  if (testEnv === 'development') {
    return 'pnpm next dev -p 3030 2>&1 | tee .tmp_dev_server_logs';
  }

  if (testEnv === 'production') {
    return 'pnpm next start -p 3030';
  }

  throw new Error(`Unknown test env: ${testEnv}`);
};
",1
"
  const pageloadTraceId = pageloadTransaction.contexts?.trace?.trace_id;

  expect(pageloadTraceId).toBeTruthy();
  expect(serverTransaction.contexts?.trace?.trace_id).toBe(pageloadTraceId);
});",1
"      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-transaction',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: expect.stringMatching(/[a-f0-9]{32}/),
    origin: 'auto.http.otel.http',",1
"      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-transaction',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: expect.stringMatching(/[a-f0-9]{32}/),
    origin: 'auto.http.otel.http',",1
"      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-transaction',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: expect.stringMatching(/[a-f0-9]{32}/),
    origin: 'auto.http.otel.http',
  });

  expect(transactionEvent.contexts?.response).toEqual({
    status_code: 200,
  });

  expect(transactionEvent).toEqual(
    expect.objectContaining({
      transaction: 'GET /test-transaction',
      type: 'transaction',
      transaction_info: {
        source: 'route',
      },
    }),
  );

  const spans = transactionEvent.spans || [];

  // Manually started span
  expect(spans).toContainEqual({
    data: { 'sentry.origin': 'manual' },
    description: 'test-span',
    origin: 'manual',
    parent_span_id: expect.stringMatching(/[a-f0-9]{16}/),
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    start_timestamp: expect.any(Number),
    status: 'ok',
    timestamp: expect.any(Number),
    trace_id: expect.stringMatching(/[a-f0-9]{32}/),
  });

  // auto instrumented spans
  expect(spans).toContainEqual({
    data: {
      'sentry.origin': 'auto.http.otel.express',
      'sentry.op': 'middleware.express',
      'express.name': 'query',
      'express.type': 'middleware',
    },
    description: 'query',
    op: 'middleware.express',
    origin: 'auto.http.otel.express',
    parent_span_id: expect.stringMatching(/[a-f0-9]{16}/),
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    start_timestamp: expect.any(Number),
    status: 'ok',
    timestamp: expect.any(Number),
    trace_id: expect.stringMatching(/[a-f0-9]{32}/),
  });

  expect(spans).toContainEqual({
    data: {
      'sentry.origin': 'auto.http.otel.express',
      'sentry.op': 'middleware.express',
      'express.name': 'expressInit',
      'express.type': 'middleware',
    },
    description: 'expressInit',
    op: 'middleware.express',
    origin: 'auto.http.otel.express',
    parent_span_id: expect.stringMatching(/[a-f0-9]{16}/),
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    start_timestamp: expect.any(Number),
    status: 'ok',
    timestamp: expect.any(Number),
    trace_id: expect.stringMatching(/[a-f0-9]{32}/),
  });

  expect(spans).toContainEqual({
    data: {
      'sentry.origin': 'auto.http.otel.express',
      'sentry.op': 'request_handler.express',
      'http.route': '/test-transaction',
      'express.name': '/test-transaction',
      'express.type': 'request_handler',
    },
    description: '/test-transaction',
    op: 'request_handler.express',
    origin: 'auto.http.otel.express',
    parent_span_id: expect.stringMatching(/[a-f0-9]{16}/),
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    start_timestamp: expect.any(Number),
    status: 'ok',
    timestamp: expect.any(Number),
    trace_id: expect.stringMatching(/[a-f0-9]{32}/),
  });
});

test('Sends an API route transaction for an errored route', async ({ baseURL }) => {
  const transactionEventPromise = waitForTransaction('node-express', transactionEvent => {
    return (
      transactionEvent.contexts?.trace?.op === 'http.server' &&
      transactionEvent.transaction === 'GET /test-exception/:id' &&
      transactionEvent.request?.url === 'http://localhost:3030/test-exception/777'
    );
  });

  await fetch(`${baseURL}/test-exception/777`);

  const transactionEvent = await transactionEventPromise;

  expect(transactionEvent.contexts?.trace?.op).toEqual('http.server');
  expect(transactionEvent.transaction).toEqual('GET /test-exception/:id');
  expect(transactionEvent.contexts?.trace?.status).toEqual('internal_error');
  expect(transactionEvent.contexts?.trace?.data?.['http.status_code']).toEqual(500);

  const spans = transactionEvent.spans || [];

  expect(spans).toContainEqual({
    data: {
      'sentry.origin': 'auto.http.otel.express',
      'sentry.op': 'middleware.express',
      'express.name': 'query',
      'express.type': 'middleware',
    },
    description: 'query',
    op: 'middleware.express',
    origin: 'auto.http.otel.express',
    parent_span_id: expect.stringMatching(/[a-f0-9]{16}/),
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    start_timestamp: expect.any(Number),
    status: 'ok',
    timestamp: expect.any(Number),
    trace_id: expect.stringMatching(/[a-f0-9]{32}/),
  });

  expect(spans).toContainEqual({
    data: {
      'sentry.origin': 'auto.http.otel.express',
      'sentry.op': 'middleware.express',
      'express.name': 'expressInit',
      'express.type': 'middleware',
    },
    description: 'expressInit',
    op: 'middleware.express',
    origin: 'auto.http.otel.express',
    parent_span_id: expect.stringMatching(/[a-f0-9]{16}/),
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    start_timestamp: expect.any(Number),
    status: 'ok',
    timestamp: expect.any(Number),
    trace_id: expect.stringMatching(/[a-f0-9]{32}/),
  });

  expect(spans).toContainEqual({
    data: {
      'sentry.origin': 'auto.http.otel.express',
      'sentry.op': 'request_handler.express',
      'http.route': '/test-exception/:id',
      'express.name': '/test-exception/:id',
      'express.type': 'request_handler',
    },
    description: '/test-exception/:id',
    op: 'request_handler.express',
    origin: 'auto.http.otel.express',
    parent_span_id: expect.stringMatching(/[a-f0-9]{16}/),
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    start_timestamp: expect.any(Number),
    status: 'unknown_error',
    timestamp: expect.any(Number),
    trace_id: expect.stringMatching(/[a-f0-9]{32}/),
    measurements: {},
  });
});",1
"  const outgoingHttpSpan = outboundTransaction?.spans?.find(span => span.op === 'http.client');

  expect(outgoingHttpSpan).toBeDefined();

  const outgoingHttpSpanId = outgoingHttpSpan?.span_id;

  expect(traceId).toEqual(expect.any(String));

  // data is passed through from the inbound request, to verify we have the correct headers set
  const inboundHeaderSentryTrace = data.headers?.['sentry-trace'];
  const inboundHeaderBaggage = data.headers?.['baggage'];

  expect(inboundHeaderSentryTrace).toEqual(`${traceId}-${outgoingHttpSpanId}-1`);
  expect(inboundHeaderBaggage).toBeDefined();

  const baggage = (inboundHeaderBaggage || '').split(',');
  expect(baggage).toEqual(
    expect.arrayContaining([
      'sentry-environment=qa',
      `sentry-trace_id=${traceId}`,
      expect.stringMatching(/sentry-public_key=/),
    ]),
  );

  expect(outboundTransaction.contexts?.trace).toEqual({
    data: {
      'sentry.source': 'route',
      'sentry.origin': 'auto.http.otel.http',
      'sentry.op': 'http.server',
      'sentry.sample_rate': 1,
      url: `http://localhost:3030/test-outgoing-http/${id}`,
      'otel.kind': 'SERVER',
      'http.response.status_code': 200,
      'http.url': `http://localhost:3030/test-outgoing-http/${id}`,
      'http.host': 'localhost:3030',
      'net.host.name': 'localhost',
      'http.method': 'GET',
      'http.scheme': 'http',
      'http.target': `/test-outgoing-http/${id}`,
      'http.user_agent': 'node',
      'http.flavor': '1.1',
      'net.transport': 'ip_tcp',
      'net.host.ip': expect.any(String),
      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-outgoing-http/:id',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: traceId,
    origin: 'auto.http.otel.http',
  });

  expect(inboundTransaction.contexts?.trace).toEqual({
    data: {
      'sentry.source': 'route',
      'sentry.origin': 'auto.http.otel.http',
      'sentry.op': 'http.server',
      url: `http://localhost:3030/test-inbound-headers/${id}`,
      'otel.kind': 'SERVER',
      'http.response.status_code': 200,
      'http.url': `http://localhost:3030/test-inbound-headers/${id}`,
      'http.host': 'localhost:3030',
      'net.host.name': 'localhost',
      'http.method': 'GET',
      'http.scheme': 'http',
      'http.target': `/test-inbound-headers/${id}`,
      'http.flavor': '1.1',
      'net.transport': 'ip_tcp',
      'net.host.ip': expect.any(String),
      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-inbound-headers/:id',
    },
    op: 'http.server',
    parent_span_id: outgoingHttpSpanId,
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: traceId,
    origin: 'auto.http.otel.http',
  });
});

test('Propagates trace for outgoing fetch requests', async ({ baseURL }) => {
  const id = crypto.randomUUID();

  const inboundTransactionPromise = waitForTransaction('node-fastify-3', transactionEvent => {
    return (
      transactionEvent?.contexts?.trace?.op === 'http.server' &&
      transactionEvent.contexts?.trace?.data?.['http.target'] === `/test-inbound-headers/${id}`
    );
  });

  const outboundTransactionPromise = waitForTransaction('node-fastify-3', transactionEvent => {
    return (
      transactionEvent?.contexts?.trace?.op === 'http.server' &&
      transactionEvent.contexts?.trace?.data?.['http.target'] === `/test-outgoing-fetch/${id}`
    );
  });

  const response = await fetch(`${baseURL}/test-outgoing-fetch/${id}`);
  const data = await response.json();

  const inboundTransaction = await inboundTransactionPromise;
  const outboundTransaction = await outboundTransactionPromise;

  const traceId = outboundTransaction?.contexts?.trace?.trace_id;
  const outgoingHttpSpan = outboundTransaction?.spans?.find(span => span.op === 'http.client');

  expect(outgoingHttpSpan).toBeDefined();

  const outgoingHttpSpanId = outgoingHttpSpan?.span_id;

  expect(traceId).toEqual(expect.any(String));

  // data is passed through from the inbound request, to verify we have the correct headers set
  const inboundHeaderSentryTrace = data.headers?.['sentry-trace'];
  const inboundHeaderBaggage = data.headers?.['baggage'];

  expect(inboundHeaderSentryTrace).toEqual(`${traceId}-${outgoingHttpSpanId}-1`);
  expect(inboundHeaderBaggage).toBeDefined();

  const baggage = (inboundHeaderBaggage || '').split(',');
  expect(baggage).toEqual(
    expect.arrayContaining([
      'sentry-environment=qa',
      `sentry-trace_id=${traceId}`,
      expect.stringMatching(/sentry-public_key=/),
    ]),
  );

  expect(outboundTransaction.contexts?.trace).toEqual({
    data: {
      'sentry.source': 'route',
      'sentry.origin': 'auto.http.otel.http',
      'sentry.op': 'http.server',
      'sentry.sample_rate': 1,
      url: `http://localhost:3030/test-outgoing-fetch/${id}`,
      'otel.kind': 'SERVER',
      'http.response.status_code': 200,
      'http.url': `http://localhost:3030/test-outgoing-fetch/${id}`,
      'http.host': 'localhost:3030',
      'net.host.name': 'localhost',
      'http.method': 'GET',
      'http.scheme': 'http',
      'http.target': `/test-outgoing-fetch/${id}`,
      'http.user_agent': 'node',
      'http.flavor': '1.1',
      'net.transport': 'ip_tcp',
      'net.host.ip': expect.any(String),
      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-outgoing-fetch/:id',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: traceId,
    origin: 'auto.http.otel.http',
  });

  expect(inboundTransaction.contexts?.trace).toEqual({
    data: expect.objectContaining({
      'sentry.source': 'route',
      'sentry.origin': 'auto.http.otel.http',
      'sentry.op': 'http.server',
      url: `http://localhost:3030/test-inbound-headers/${id}`,
      'otel.kind': 'SERVER',
      'http.response.status_code': 200,
      'http.url': `http://localhost:3030/test-inbound-headers/${id}`,
      'http.host': 'localhost:3030',
      'net.host.name': 'localhost',
      'http.method': 'GET',
      'http.scheme': 'http',
      'http.target': `/test-inbound-headers/${id}`,
      'http.flavor': '1.1',
      'net.transport': 'ip_tcp',
      'net.host.ip': expect.any(String),
      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-inbound-headers/:id',
    }),
    op: 'http.server',
    parent_span_id: outgoingHttpSpanId,
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: traceId,
    origin: 'auto.http.otel.http',",1
"      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-transaction',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: expect.stringMatching(/[a-f0-9]{32}/),
    origin: 'auto.http.otel.http',",1
"  const outgoingHttpSpan = outboundTransaction?.spans?.find(span => span.op === 'http.client');

  expect(outgoingHttpSpan).toBeDefined();

  const outgoingHttpSpanId = outgoingHttpSpan?.span_id;

  expect(traceId).toEqual(expect.any(String));

  // data is passed through from the inbound request, to verify we have the correct headers set
  const inboundHeaderSentryTrace = data.headers?.['sentry-trace'];
  const inboundHeaderBaggage = data.headers?.['baggage'];

  expect(inboundHeaderSentryTrace).toEqual(`${traceId}-${outgoingHttpSpanId}-1`);
  expect(inboundHeaderBaggage).toBeDefined();

  const baggage = (inboundHeaderBaggage || '').split(',');
  expect(baggage).toEqual(
    expect.arrayContaining([
      'sentry-environment=qa',
      `sentry-trace_id=${traceId}`,
      expect.stringMatching(/sentry-public_key=/),
    ]),
  );

  expect(outboundTransaction.contexts?.trace).toEqual({
    data: {
      'sentry.source': 'route',
      'sentry.origin': 'auto.http.otel.http',
      'sentry.op': 'http.server',
      'sentry.sample_rate': 1,
      url: `http://localhost:3030/test-outgoing-http/${id}`,
      'otel.kind': 'SERVER',
      'http.response.status_code': 200,
      'http.url': `http://localhost:3030/test-outgoing-http/${id}`,
      'http.host': 'localhost:3030',
      'net.host.name': 'localhost',
      'http.method': 'GET',
      'http.scheme': 'http',
      'http.target': `/test-outgoing-http/${id}`,
      'http.user_agent': 'node',
      'http.flavor': '1.1',
      'net.transport': 'ip_tcp',
      'net.host.ip': expect.any(String),
      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-outgoing-http/:id',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: traceId,
    origin: 'auto.http.otel.http',
  });

  expect(inboundTransaction.contexts?.trace).toEqual({
    data: {
      'sentry.source': 'route',
      'sentry.origin': 'auto.http.otel.http',
      'sentry.op': 'http.server',
      url: `http://localhost:3030/test-inbound-headers/${id}`,
      'otel.kind': 'SERVER',
      'http.response.status_code': 200,
      'http.url': `http://localhost:3030/test-inbound-headers/${id}`,
      'http.host': 'localhost:3030',
      'net.host.name': 'localhost',
      'http.method': 'GET',
      'http.scheme': 'http',
      'http.target': `/test-inbound-headers/${id}`,
      'http.flavor': '1.1',
      'net.transport': 'ip_tcp',
      'net.host.ip': expect.any(String),
      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-inbound-headers/:id',
    },
    op: 'http.server',
    parent_span_id: outgoingHttpSpanId,
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: traceId,
    origin: 'auto.http.otel.http',
  });
});

test('Propagates trace for outgoing fetch requests', async ({ baseURL }) => {
  const id = crypto.randomUUID();

  const inboundTransactionPromise = waitForTransaction('node-fastify-4', transactionEvent => {
    return (
      transactionEvent?.contexts?.trace?.op === 'http.server' &&
      transactionEvent.contexts?.trace?.data?.['http.target'] === `/test-inbound-headers/${id}`
    );
  });

  const outboundTransactionPromise = waitForTransaction('node-fastify-4', transactionEvent => {
    return (
      transactionEvent?.contexts?.trace?.op === 'http.server' &&
      transactionEvent.contexts?.trace?.data?.['http.target'] === `/test-outgoing-fetch/${id}`
    );
  });

  const response = await fetch(`${baseURL}/test-outgoing-fetch/${id}`);
  const data = await response.json();

  const inboundTransaction = await inboundTransactionPromise;
  const outboundTransaction = await outboundTransactionPromise;

  const traceId = outboundTransaction?.contexts?.trace?.trace_id;
  const outgoingHttpSpan = outboundTransaction?.spans?.find(span => span.op === 'http.client');

  expect(outgoingHttpSpan).toBeDefined();

  const outgoingHttpSpanId = outgoingHttpSpan?.span_id;

  expect(traceId).toEqual(expect.any(String));

  // data is passed through from the inbound request, to verify we have the correct headers set
  const inboundHeaderSentryTrace = data.headers?.['sentry-trace'];
  const inboundHeaderBaggage = data.headers?.['baggage'];

  expect(inboundHeaderSentryTrace).toEqual(`${traceId}-${outgoingHttpSpanId}-1`);
  expect(inboundHeaderBaggage).toBeDefined();

  const baggage = (inboundHeaderBaggage || '').split(',');
  expect(baggage).toEqual(
    expect.arrayContaining([
      'sentry-environment=qa',
      `sentry-trace_id=${traceId}`,
      expect.stringMatching(/sentry-public_key=/),
    ]),
  );

  expect(outboundTransaction.contexts?.trace).toEqual({
    data: {
      'sentry.source': 'route',
      'sentry.origin': 'auto.http.otel.http',
      'sentry.op': 'http.server',
      'sentry.sample_rate': 1,
      url: `http://localhost:3030/test-outgoing-fetch/${id}`,
      'otel.kind': 'SERVER',
      'http.response.status_code': 200,
      'http.url': `http://localhost:3030/test-outgoing-fetch/${id}`,
      'http.host': 'localhost:3030',
      'net.host.name': 'localhost',
      'http.method': 'GET',
      'http.scheme': 'http',
      'http.target': `/test-outgoing-fetch/${id}`,
      'http.user_agent': 'node',
      'http.flavor': '1.1',
      'net.transport': 'ip_tcp',
      'net.host.ip': expect.any(String),
      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-outgoing-fetch/:id',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: traceId,
    origin: 'auto.http.otel.http',
  });

  expect(inboundTransaction.contexts?.trace).toEqual({
    data: expect.objectContaining({
      'sentry.source': 'route',
      'sentry.origin': 'auto.http.otel.http',
      'sentry.op': 'http.server',
      url: `http://localhost:3030/test-inbound-headers/${id}`,
      'otel.kind': 'SERVER',
      'http.response.status_code': 200,
      'http.url': `http://localhost:3030/test-inbound-headers/${id}`,
      'http.host': 'localhost:3030',
      'net.host.name': 'localhost',
      'http.method': 'GET',
      'http.scheme': 'http',
      'http.target': `/test-inbound-headers/${id}`,
      'http.flavor': '1.1',
      'net.transport': 'ip_tcp',
      'net.host.ip': expect.any(String),
      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-inbound-headers/:id',
    }),
    op: 'http.server',
    parent_span_id: outgoingHttpSpanId,
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: traceId,
    origin: 'auto.http.otel.http',",1
"      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-transaction',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: expect.stringMatching(/[a-f0-9]{32}/),
    origin: 'auto.http.otel.http',",1
"  const outgoingHttpSpan = outboundTransaction?.spans?.find(span => span.op === 'http.client');

  expect(outgoingHttpSpan).toBeDefined();

  const outgoingHttpSpanId = outgoingHttpSpan?.span_id;

  expect(traceId).toEqual(expect.any(String));

  // data is passed through from the inbound request, to verify we have the correct headers set
  const inboundHeaderSentryTrace = data.headers?.['sentry-trace'];
  const inboundHeaderBaggage = data.headers?.['baggage'];

  expect(inboundHeaderSentryTrace).toEqual(`${traceId}-${outgoingHttpSpanId}-1`);
  expect(inboundHeaderBaggage).toBeDefined();

  const baggage = (inboundHeaderBaggage || '').split(',');
  expect(baggage).toEqual(
    expect.arrayContaining([
      'sentry-environment=qa',
      `sentry-trace_id=${traceId}`,
      expect.stringMatching(/sentry-public_key=/),
    ]),
  );

  expect(outboundTransaction.contexts?.trace).toEqual({
    data: {
      'sentry.source': 'route',
      'sentry.origin': 'auto.http.otel.http',
      'sentry.op': 'http.server',
      'sentry.sample_rate': 1,
      url: `http://localhost:3030/test-outgoing-http/${id}`,
      'otel.kind': 'SERVER',
      'http.response.status_code': 200,
      'http.url': `http://localhost:3030/test-outgoing-http/${id}`,
      'http.host': 'localhost:3030',
      'net.host.name': 'localhost',
      'http.method': 'GET',
      'http.scheme': 'http',
      'http.target': `/test-outgoing-http/${id}`,
      'http.user_agent': 'node',
      'http.flavor': '1.1',
      'net.transport': 'ip_tcp',
      'net.host.ip': expect.any(String),
      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-outgoing-http/:id',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: traceId,
    origin: 'auto.http.otel.http',
  });

  expect(inboundTransaction.contexts?.trace).toEqual({
    data: {
      'sentry.source': 'route',
      'sentry.origin': 'auto.http.otel.http',
      'sentry.op': 'http.server',
      url: `http://localhost:3030/test-inbound-headers/${id}`,
      'otel.kind': 'SERVER',
      'http.response.status_code': 200,
      'http.url': `http://localhost:3030/test-inbound-headers/${id}`,
      'http.host': 'localhost:3030',
      'net.host.name': 'localhost',
      'http.method': 'GET',
      'http.scheme': 'http',
      'http.target': `/test-inbound-headers/${id}`,
      'http.flavor': '1.1',
      'net.transport': 'ip_tcp',
      'net.host.ip': expect.any(String),
      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-inbound-headers/:id',
    },
    op: 'http.server',
    parent_span_id: outgoingHttpSpanId,
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: traceId,
    origin: 'auto.http.otel.http',
  });
});

test('Propagates trace for outgoing fetch requests', async ({ baseURL }) => {
  const id = crypto.randomUUID();

  const inboundTransactionPromise = waitForTransaction('node-fastify-5', transactionEvent => {
    return (
      transactionEvent?.contexts?.trace?.op === 'http.server' &&
      transactionEvent.contexts?.trace?.data?.['http.target'] === `/test-inbound-headers/${id}`
    );
  });

  const outboundTransactionPromise = waitForTransaction('node-fastify-5', transactionEvent => {
    return (
      transactionEvent?.contexts?.trace?.op === 'http.server' &&
      transactionEvent.contexts?.trace?.data?.['http.target'] === `/test-outgoing-fetch/${id}`
    );
  });

  const response = await fetch(`${baseURL}/test-outgoing-fetch/${id}`);
  const data = await response.json();

  const inboundTransaction = await inboundTransactionPromise;
  const outboundTransaction = await outboundTransactionPromise;

  const traceId = outboundTransaction?.contexts?.trace?.trace_id;
  const outgoingHttpSpan = outboundTransaction?.spans?.find(span => span.op === 'http.client');

  expect(outgoingHttpSpan).toBeDefined();

  const outgoingHttpSpanId = outgoingHttpSpan?.span_id;

  expect(traceId).toEqual(expect.any(String));

  // data is passed through from the inbound request, to verify we have the correct headers set
  const inboundHeaderSentryTrace = data.headers?.['sentry-trace'];
  const inboundHeaderBaggage = data.headers?.['baggage'];

  expect(inboundHeaderSentryTrace).toEqual(`${traceId}-${outgoingHttpSpanId}-1`);
  expect(inboundHeaderBaggage).toBeDefined();

  const baggage = (inboundHeaderBaggage || '').split(',');
  expect(baggage).toEqual(
    expect.arrayContaining([
      'sentry-environment=qa',
      `sentry-trace_id=${traceId}`,
      expect.stringMatching(/sentry-public_key=/),
    ]),
  );

  expect(outboundTransaction.contexts?.trace).toEqual({
    data: {
      'sentry.source': 'route',
      'sentry.origin': 'auto.http.otel.http',
      'sentry.op': 'http.server',
      'sentry.sample_rate': 1,
      url: `http://localhost:3030/test-outgoing-fetch/${id}`,
      'otel.kind': 'SERVER',
      'http.response.status_code': 200,
      'http.url': `http://localhost:3030/test-outgoing-fetch/${id}`,
      'http.host': 'localhost:3030',
      'net.host.name': 'localhost',
      'http.method': 'GET',
      'http.scheme': 'http',
      'http.target': `/test-outgoing-fetch/${id}`,
      'http.user_agent': 'node',
      'http.flavor': '1.1',
      'net.transport': 'ip_tcp',
      'net.host.ip': expect.any(String),
      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-outgoing-fetch/:id',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: traceId,
    origin: 'auto.http.otel.http',
  });

  expect(inboundTransaction.contexts?.trace).toEqual({
    data: expect.objectContaining({
      'sentry.source': 'route',
      'sentry.origin': 'auto.http.otel.http',
      'sentry.op': 'http.server',
      url: `http://localhost:3030/test-inbound-headers/${id}`,
      'otel.kind': 'SERVER',
      'http.response.status_code': 200,
      'http.url': `http://localhost:3030/test-inbound-headers/${id}`,
      'http.host': 'localhost:3030',
      'net.host.name': 'localhost',
      'http.method': 'GET',
      'http.scheme': 'http',
      'http.target': `/test-inbound-headers/${id}`,
      'http.flavor': '1.1',
      'net.transport': 'ip_tcp',
      'net.host.ip': expect.any(String),
      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-inbound-headers/:id',
    }),
    op: 'http.server',
    parent_span_id: outgoingHttpSpanId,
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: traceId,
    origin: 'auto.http.otel.http',",1
"      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-transaction',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: expect.stringMatching(/[a-f0-9]{32}/),
    origin: 'auto.http.otel.http',",1
"      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-success',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: expect.stringMatching(/[a-f0-9]{32}/),
    origin: 'auto.http.otel.http',
  });

  expect(transactionEvent).toEqual(
    expect.objectContaining({
      transaction: 'GET /test-success',
      type: 'transaction',
      transaction_info: {
        source: 'route',
      },
    }),
  );

  const spans = transactionEvent.spans || [];

  expect(spans).toEqual([
    {
      data: {
        'hapi.type': 'router',
        'http.method': 'GET',
        'http.route': '/test-success',",1
"  const traceId = outboundTransaction?.contexts?.trace?.trace_id;
  const outgoingHttpSpan = outboundTransaction?.spans?.find(span => span.op === 'http.client');
  expect(outgoingHttpSpan).toBeDefined();

  const outgoingHttpSpanId = outgoingHttpSpan?.span_id;

  expect(traceId).toEqual(expect.any(String));

  // data is passed through from the inbound request, to verify we have the correct headers set
  const inboundHeaderSentryTrace = data.headers?.['sentry-trace'];
  const inboundHeaderBaggage = data.headers?.['baggage'];

  expect(inboundHeaderSentryTrace).toEqual(`${traceId}-${outgoingHttpSpanId}-1`);
  expect(inboundHeaderBaggage).toBeDefined();

  const baggage = (inboundHeaderBaggage || '').split(',');
  expect(baggage).toEqual(
    expect.arrayContaining([
      'sentry-environment=qa',
      `sentry-trace_id=${traceId}`,
      expect.stringMatching(/sentry-public_key=/),
    ]),
  );

  expect(outboundTransaction.contexts?.trace).toEqual({
    data: {
      'sentry.source': 'route',
      'sentry.origin': 'auto.http.otel.http',
      'sentry.op': 'http.server',
      'sentry.sample_rate': 1,
      url: `http://localhost:3030/test-outgoing-http/${id}`,
      'otel.kind': 'SERVER',
      'http.response.status_code': 200,
      'http.url': `http://localhost:3030/test-outgoing-http/${id}`,
      'http.host': 'localhost:3030',
      'net.host.name': 'localhost',
      'http.method': 'GET',
      'http.scheme': 'http',
      'http.target': `/test-outgoing-http/${id}`,
      'http.user_agent': 'node',
      'http.flavor': '1.1',
      'net.transport': 'ip_tcp',
      'net.host.ip': expect.any(String),
      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-outgoing-http/:id',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: traceId,
    origin: 'auto.http.otel.http',
  });

  expect(inboundTransaction.contexts?.trace).toEqual({
    data: {
      'sentry.source': 'route',
      'sentry.origin': 'auto.http.otel.http',
      'sentry.op': 'http.server',
      url: `http://localhost:3030/test-inbound-headers/${id}`,
      'otel.kind': 'SERVER',
      'http.response.status_code': 200,
      'http.url': `http://localhost:3030/test-inbound-headers/${id}`,
      'http.host': 'localhost:3030',
      'net.host.name': 'localhost',
      'http.method': 'GET',
      'http.scheme': 'http',
      'http.target': `/test-inbound-headers/${id}`,
      'http.flavor': '1.1',
      'net.transport': 'ip_tcp',
      'net.host.ip': expect.any(String),
      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-inbound-headers/:id',
    },
    op: 'http.server',
    parent_span_id: outgoingHttpSpanId,
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: traceId,
    origin: 'auto.http.otel.http',
  });
});

test('Propagates trace for outgoing fetch requests', async ({ baseURL }) => {
  const id = crypto.randomUUID();

  const inboundTransactionPromise = waitForTransaction('node-koa', transactionEvent => {
    return (
      transactionEvent?.contexts?.trace?.op === 'http.server' &&
      transactionEvent.contexts?.trace?.data?.['http.target'] === `/test-inbound-headers/${id}`
    );
  });

  const outboundTransactionPromise = waitForTransaction('node-koa', transactionEvent => {
    return (
      transactionEvent?.contexts?.trace?.op === 'http.server' &&
      transactionEvent.contexts?.trace?.data?.['http.target'] === `/test-outgoing-fetch/${id}`
    );
  });

  const response = await fetch(`${baseURL}/test-outgoing-fetch/${id}`);
  const data = await response.json();

  const inboundTransaction = await inboundTransactionPromise;
  const outboundTransaction = await outboundTransactionPromise;

  const traceId = outboundTransaction?.contexts?.trace?.trace_id;
  const outgoingHttpSpan = outboundTransaction?.spans?.find(span => span.op === 'http.client');

  expect(outgoingHttpSpan).toBeDefined();

  const outgoingHttpSpanId = outgoingHttpSpan?.span_id;

  expect(traceId).toEqual(expect.any(String));

  // data is passed through from the inbound request, to verify we have the correct headers set
  const inboundHeaderSentryTrace = data.headers?.['sentry-trace'];
  const inboundHeaderBaggage = data.headers?.['baggage'];

  expect(inboundHeaderSentryTrace).toEqual(`${traceId}-${outgoingHttpSpanId}-1`);
  expect(inboundHeaderBaggage).toBeDefined();

  const baggage = (inboundHeaderBaggage || '').split(',');
  expect(baggage).toEqual(
    expect.arrayContaining([
      'sentry-environment=qa',
      `sentry-trace_id=${traceId}`,
      expect.stringMatching(/sentry-public_key=/),
    ]),
  );

  expect(outboundTransaction.contexts?.trace).toEqual({
    data: {
      'sentry.source': 'route',
      'sentry.origin': 'auto.http.otel.http',
      'sentry.op': 'http.server',
      'sentry.sample_rate': 1,
      url: `http://localhost:3030/test-outgoing-fetch/${id}`,
      'otel.kind': 'SERVER',
      'http.response.status_code': 200,
      'http.url': `http://localhost:3030/test-outgoing-fetch/${id}`,
      'http.host': 'localhost:3030',
      'net.host.name': 'localhost',
      'http.method': 'GET',
      'http.scheme': 'http',
      'http.target': `/test-outgoing-fetch/${id}`,
      'http.user_agent': 'node',
      'http.flavor': '1.1',
      'net.transport': 'ip_tcp',
      'net.host.ip': expect.any(String),
      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-outgoing-fetch/:id',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: traceId,
    origin: 'auto.http.otel.http',
  });

  expect(inboundTransaction.contexts?.trace).toEqual({
    data: expect.objectContaining({
      'sentry.source': 'route',
      'sentry.origin': 'auto.http.otel.http',
      'sentry.op': 'http.server',
      url: `http://localhost:3030/test-inbound-headers/${id}`,
      'otel.kind': 'SERVER',
      'http.response.status_code': 200,
      'http.url': `http://localhost:3030/test-inbound-headers/${id}`,
      'http.host': 'localhost:3030',
      'net.host.name': 'localhost',
      'http.method': 'GET',
      'http.scheme': 'http',
      'http.target': `/test-inbound-headers/${id}`,
      'http.flavor': '1.1',
      'net.transport': 'ip_tcp',
      'net.host.ip': expect.any(String),
      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-inbound-headers/:id',
    }),
    op: 'http.server',
    parent_span_id: outgoingHttpSpanId,
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: traceId,
    origin: 'auto.http.otel.http',",1
"      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-transaction',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: expect.stringMatching(/[a-f0-9]{32}/),
    origin: 'auto.http.otel.http',",1
"      'net.host.port': 3030,
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/task',
    },
    origin: 'auto.http.otel.http',
    op: 'http.server',
    status: 'ok',
  });
",1
"      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-transaction',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: expect.stringMatching(/[a-f0-9]{32}/),
    origin: 'auto.http.otel.http',",1
"      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-transaction',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: expect.stringMatching(/[a-f0-9]{32}/),
    origin: 'auto.http.otel.http',",1
"  const transactionEvent = await transactionEventPromise;

  expect(buildAssetFolderOccurred).toBe(false);

  expect(transactionEvent.transaction).toBe('GET /test-param/:param()');
});",1
"      expect.objectContaining({ op: 'function.sveltekit.server.load', description: '/server-load-fetch' }),
      // sub request span:
      expect.objectContaining({ op: 'http.server', description: 'GET /api/users' }),
    ]),
  );
});",1
"      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-transaction',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: expect.stringMatching(/[a-f0-9]{32}/),
    origin: 'auto.http.otel.http',",1
"import { afterAll, describe, expect, test } from 'vitest';
import { cleanupChildProcesses, createEsmAndCjsTests, createRunner } from '../../../utils/runner';
import { createTestServer } from '../../../utils/server';

describe('httpIntegration', () => {
  afterAll(() => {
    cleanupChildProcesses();
  });

  describe('instrumentation options', () => {
    createEsmAndCjsTests(__dirname, 'server.mjs', 'instrument-options.mjs', (createRunner, test) => {
      test('allows to pass instrumentation options to integration', async () => {
        const runner = createRunner()
          .expect({
            transaction: {
              contexts: {
                trace: {
                  span_id: expect.stringMatching(/[a-f0-9]{16}/),
                  trace_id: expect.stringMatching(/[a-f0-9]{32}/),
                  data: {
                    url: expect.stringMatching(/\/test$/),
                    'http.response.status_code': 200,
                    attr1: 'yes',
                    attr2: 'yes',
                    attr3: 'yes',
                  },
                  op: 'http.server',
                  status: 'ok',
                },
              },
              extra: {
                requestHookCalled: {
                  url: expect.stringMatching(/\/test$/),
                  method: 'GET',
                },
                responseHookCalled: {
                  url: expect.stringMatching(/\/test$/),
                  method: 'GET',
                },
                applyCustomAttributesOnSpanCalled: {
                  reqUrl: expect.stringMatching(/\/test$/),
                  reqMethod: 'GET',
                  resUrl: expect.stringMatching(/\/test$/),
                  resMethod: 'GET',
                },
              },
            },
          })
          .start();
        runner.makeRequest('get', '/test');
        await runner.completed();
      });

      test('allows to configure incomingRequestSpanHook', async () => {
        const runner = createRunner()
          .expect({
            transaction: {
              contexts: {
                trace: {
                  span_id: expect.stringMatching(/[a-f0-9]{16}/),
                  trace_id: expect.stringMatching(/[a-f0-9]{32}/),
                  data: {
                    url: expect.stringMatching(/\/test$/),
                    'http.response.status_code': 200,
                    incomingRequestSpanHook: 'yes',
                  },
                  op: 'http.server',
                  status: 'ok',
                },
              },
              extra: expect.objectContaining({
                incomingRequestSpanHookCalled: {
                  reqUrl: expect.stringMatching(/\/test$/),
                  reqMethod: 'GET',
                  resUrl: expect.stringMatching(/\/test$/),
                  resMethod: 'GET',
                },
              }),
            },
          })
          .start();
        runner.makeRequest('get', '/test');
        await runner.completed();
      });
    });
  });

  describe('http.server spans', () => {
    createEsmAndCjsTests(__dirname, 'server.mjs', 'instrument.mjs', (createRunner, test) => {
      test('captures correct attributes for GET requests', async () => {
        const runner = createRunner()
          .expect({
            transaction: transaction => {
              const port = runner.getPort();
              expect(transaction.transaction).toBe('GET /test');
              expect(transaction.contexts?.trace?.data).toEqual({
                'http.flavor': '1.1',
                'http.host': `localhost:${port}`,
                'http.method': 'GET',
                'http.query': 'a=1&b=2',
                'http.response.status_code': 200,
                'http.route': '/test',
                'http.scheme': 'http',
                'http.status_code': 200,
                'http.status_text': 'OK',
                'http.target': '/test?a=1&b=2',
                'http.url': `http://localhost:${port}/test?a=1&b=2`,
                'http.user_agent': 'node',
                'net.host.ip': '::1',
                'net.host.name': 'localhost',
                'net.host.port': port,
                'net.peer.ip': '::1',
                'net.peer.port': expect.any(Number),
                'net.transport': 'ip_tcp',
                'otel.kind': 'SERVER',
                'sentry.op': 'http.server',
                'sentry.origin': 'auto.http.otel.http',
                'sentry.sample_rate': 1,
                'sentry.source': 'route',
                url: `http://localhost:${port}/test`,
              });
            },
          })
          .start();

        runner.makeRequest('get', '/test?a=1&b=2#hash');
        await runner.completed();
      });

      test('captures correct attributes for POST requests', async () => {
        const runner = createRunner()
          .expect({
            transaction: transaction => {
              const port = runner.getPort();
              expect(transaction.transaction).toBe('POST /test');
              expect(transaction.contexts?.trace?.data).toEqual({
                'http.flavor': '1.1',
                'http.host': `localhost:${port}`,
                'http.method': 'POST',
                'http.query': 'a=1&b=2',
                'http.request_content_length_uncompressed': 9,
                'http.response.status_code': 200,
                'http.route': '/test',
                'http.scheme': 'http',
                'http.status_code': 200,
                'http.status_text': 'OK',
                'http.target': '/test?a=1&b=2',
                'http.url': `http://localhost:${port}/test?a=1&b=2`,
                'http.user_agent': 'node',
                'net.host.ip': '::1',
                'net.host.name': 'localhost',
                'net.host.port': port,
                'net.peer.ip': '::1',
                'net.peer.port': expect.any(Number),
                'net.transport': 'ip_tcp',
                'otel.kind': 'SERVER',
                'sentry.op': 'http.server',
                'sentry.origin': 'auto.http.otel.http',
                'sentry.sample_rate': 1,
                'sentry.source': 'route',
                url: `http://localhost:${port}/test`,
              });
            },
          })
          .start();

        runner.makeRequest('post', '/test?a=1&b=2#hash', { data: 'test body' });",1
"  getRootSpan,
  getSentryRelease,
  getSpanDescendants,
  getSpanStatusFromHttpCode,
  getTraceData,
  getTraceMetaTags,
  graphqlIntegration,
  hapiIntegration,
  httpIntegration,
  // eslint-disable-next-line deprecation/deprecation
  inboundFiltersIntegration,
  eventFiltersIntegration,",1
"  captureException,
  continueTrace,
  getActiveSpan,
  getClient,
  getCurrentScope,
  getTraceMetaTags,
  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,
  SEMANTIC_ATTRIBUTE_SENTRY_SOURCE,
  setHttpStatus,
  startSpan,
  withIsolationScope,
} from '@sentry/node';
import type { APIContext, MiddlewareResponseHandler, RoutePart } from 'astro';

type MiddlewareOptions = {
  /**
   * If true, the client IP will be attached to the event by calling `setUser`.
   *
   * Important: Only enable this option if your Astro app is configured for (hybrid) SSR
   * via the `output: 'server' | 'hybrid'` option in your `astro.config.mjs` file.
   * Otherwise, Astro will throw an error when starting the server.
   *
   * Only set this to `true` if you're fine with collecting potentially personally identifiable information (PII).
   *
   * @default false (recommended)
   */
  trackClientIp?: boolean;
};

function sendErrorToSentry(e: unknown): unknown {
  // In case we have a primitive, wrap it in the equivalent wrapper class (string -> String, etc.) so that we can
  // store a seen flag on it.
  const objectifiedErr = objectify(e);

  captureException(objectifiedErr, {
    mechanism: {
      type: 'astro',
      handled: false,
      data: {
        function: 'astroMiddleware',
      },
    },
  });

  return objectifiedErr;
}

type AstroLocalsWithSentry = Record<string, unknown> & {
  __sentry_wrapped__?: boolean;
};

export const handleRequest: (options?: MiddlewareOptions) => MiddlewareResponseHandler = options => {
  const handlerOptions = {
    trackClientIp: false,
    ...options,
  };

  return async (ctx, next) => {
    // If no Sentry client exists, just bail
    // Apart from the case when no Sentry.init() is called at all, this also happens
    // if a prerendered page is hit first before a ssr page is called
    // For regular prerendered pages, this is fine as we do not want to instrument them at runtime anyhow
    // BUT for server-islands requests on a static page, this can be problematic...
    // TODO: Today, this leads to inconsistent behavior: If a prerendered page is hit first (before _any_ ssr page is called),
    // Sentry.init() has not been called yet (as this is only injected in SSR pages), so server-island requests are not instrumented
    // If any SSR route is hit before, the client will already be set up and everything will work as expected :O
    // To reproduce this: Run the astro-5 ""tracing.serverIslands.test"" only
    if (!getClient()) {
      return next();
    }

    const isDynamicPageRequest = checkIsDynamicPageRequest(ctx);

    // For static (prerendered) routes, we only want to inject the parametrized route meta tags
    if (!isDynamicPageRequest) {
      return handleStaticRoute(ctx, next);
    }

    const activeSpan = getActiveSpan();
    const rootSpan = activeSpan ? getRootSpan(activeSpan) : undefined;

    // if there is an active span, we just want to enhance it with routing data etc.
    if (rootSpan && spanToJSON(rootSpan).op === 'http.server') {
      return enhanceHttpServerSpan(ctx, next, rootSpan);
    }

    return instrumentRequestStartHttpServerSpan(ctx, next, handlerOptions);
  };
};

async function handleStaticRoute(
  ctx: Parameters<MiddlewareResponseHandler>[0],
  next: Parameters<MiddlewareResponseHandler>[1],
): Promise<Response> {
  const parametrizedRoute = getParametrizedRoute(ctx);
  try {
    const originalResponse = await next();

    // We never want to continue a trace here, so we do not inject trace data
    // But we do want to inject the parametrized route, as this is used for client-side route parametrization
    const metaTagsStr = getMetaTagsStr({ injectTraceData: false, parametrizedRoute });
    return injectMetaTagsInResponse(originalResponse, metaTagsStr);
  } catch (e) {
    sendErrorToSentry(e);
    throw e;
  }
}

async function enhanceHttpServerSpan(
  ctx: Parameters<MiddlewareResponseHandler>[0],
  next: Parameters<MiddlewareResponseHandler>[1],
  rootSpan: Span,
): Promise<Response> {
  // Make sure we don't accidentally double wrap (e.g. user added middleware and integration auto added it)
  const locals = ctx.locals as AstroLocalsWithSentry | undefined;
  if (locals?.__sentry_wrapped__) {
    return next();
  }
  if (locals) {
    addNonEnumerableProperty(locals, '__sentry_wrapped__', true);
  }

  const request = ctx.request;
  const isolationScope = getIsolationScope();
  const method = request.method;

  try {
    const parametrizedRoute = getParametrizedRoute(ctx);

    rootSpan.setAttributes({
      // This is here for backwards compatibility, we used to set this here before
      method,
      [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.astro',
    });

    if (parametrizedRoute) {
      rootSpan.setAttributes({
        [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'route',
        'http.route': parametrizedRoute,
      });

      isolationScope.setTransactionName(`${method} ${parametrizedRoute}`);
    }

    try {
      const originalResponse = await next();
      const metaTagsStr = getMetaTagsStr({ injectTraceData: true, parametrizedRoute });
      return injectMetaTagsInResponse(originalResponse, metaTagsStr);
    } catch (e) {
      sendErrorToSentry(e);
      throw e;
    }
  } finally {
    await flushIfServerless();
  }
}

async function instrumentRequestStartHttpServerSpan(
  ctx: Parameters<MiddlewareResponseHandler>[0],
  next: Parameters<MiddlewareResponseHandler>[1],
  options: MiddlewareOptions,
): Promise<Response> {
  // Make sure we don't accidentally double wrap (e.g. user added middleware and integration auto added it)
  const locals = ctx.locals as AstroLocalsWithSentry | undefined;
  if (locals?.__sentry_wrapped__) {
    return next();
  }
  if (locals) {
    addNonEnumerableProperty(locals, '__sentry_wrapped__', true);
  }

  const request = ctx.request;

  // Note: We guard outside of this function call that the request is dynamic
  // accessing headers on a static route would throw
  const { method, headers } = request;

  return withIsolationScope(isolationScope => {
    return continueTrace(
      {
        sentryTrace: headers?.get('sentry-trace') || undefined,
        baggage: headers?.get('baggage'),
      },
      async () => {
        getCurrentScope().setSDKProcessingMetadata({
          // We store the request on the current scope, not isolation scope,
          // because we may have multiple requests nested inside each other
          normalizedRequest: winterCGRequestToRequestData(request),
        });

        if (options.trackClientIp) {
          isolationScope.setUser({ ip_address: ctx.clientAddress });
        }

        try {
          const parametrizedRoute = getParametrizedRoute(ctx);

          const source = parametrizedRoute ? 'route' : 'url';
          // storing res in a variable instead of directly returning is necessary to
          // invoke the catch block if next() throws

          const attributes: SpanAttributes = {
            [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.astro',
            [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: source,
            [SEMANTIC_ATTRIBUTE_HTTP_REQUEST_METHOD]: method,
            // This is here for backwards compatibility, we used to set this here before
            method,
            url: stripUrlQueryAndFragment(ctx.url.href),
          };

          if (parametrizedRoute) {
            attributes['http.route'] = parametrizedRoute;
          }
",1
"        getSpan: getSpanMock,
        setSDKProcessingMetadata: setSDKProcessingMetadataMock,
        getPropagationContext: () => ({}),
      } as any;
    });
    vi.spyOn(SentryNode, 'getActiveSpan').mockImplementation(getSpanMock);
    vi.spyOn(SentryNode, 'getClient').mockImplementation(() => ({}) as Client);
    vi.spyOn(SentryNode, 'getTraceMetaTags').mockImplementation(
      () => `
    <meta name=""sentry-trace"" content=""123"">
    <meta name=""baggage"" content=""abc"">
    `,
    );",1
"  defaultStackParser,
  lastEventId,
  flush,
  close,
  getSentryRelease,
  createGetModuleFromFilename,
  // eslint-disable-next-line deprecation/deprecation
  anrIntegration,
  // eslint-disable-next-line deprecation/deprecation
  disableAnrDetectionForCallback,
  consoleIntegration,
  httpIntegration,",1
"  defaultStackParser,
  lastEventId,
  flush,
  close,
  getSentryRelease,
  createGetModuleFromFilename,
  // eslint-disable-next-line deprecation/deprecation
  anrIntegration,
  // eslint-disable-next-line deprecation/deprecation
  disableAnrDetectionForCallback,
  consoleIntegration,
  httpIntegration,",1
"import type { IntegrationFn, RequestEventData, SpanAttributes } from '@sentry/core';
import {
  captureException,
  continueTrace,
  defineIntegration,
  isURLObjectRelative,
  parseStringToURLObject,
  SEMANTIC_ATTRIBUTE_HTTP_REQUEST_METHOD,
  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,
  SEMANTIC_ATTRIBUTE_SENTRY_SOURCE,
  setHttpStatus,
  startSpan,
  withIsolationScope,
} from '@sentry/core';
import type { ServeOptions } from 'bun';

const INTEGRATION_NAME = 'BunServer';

const _bunServerIntegration = (() => {
  return {
    name: INTEGRATION_NAME,
    setupOnce() {
      instrumentBunServe();
    },
  };
}) satisfies IntegrationFn;

/**
 * Instruments `Bun.serve` to automatically create transactions and capture errors.
 *
 * Does not support instrumenting static routes.
 *
 * Enabled by default in the Bun SDK.
 *
 * ```js
 * Sentry.init({
 *   integrations: [
 *     Sentry.bunServerIntegration(),
 *   ],
 * })
 * ```
 */
export const bunServerIntegration = defineIntegration(_bunServerIntegration);

let hasPatchedBunServe = false;

/**
 * Instruments Bun.serve by patching it's options.
 *
 * Only exported for tests.
 */
export function instrumentBunServe(): void {
  if (hasPatchedBunServe) {
    return;
  }

  Bun.serve = new Proxy(Bun.serve, {
    apply(serveTarget, serveThisArg, serveArgs: Parameters<typeof Bun.serve>) {
      instrumentBunServeOptions(serveArgs[0]);
      const server: ReturnType<typeof Bun.serve> = serveTarget.apply(serveThisArg, serveArgs);

      // A Bun server can be reloaded, re-wrap any fetch function passed to it
      // We can't use a Proxy for this as Bun does `instanceof` checks internally that fail if we
      // wrap the Server instance.
      const originalReload: typeof server.reload = server.reload.bind(server);
      server.reload = (serveOptions: ServeOptions) => {
        instrumentBunServeOptions(serveOptions);
        return originalReload(serveOptions);
      };

      return server;
    },
  });

  hasPatchedBunServe = true;
}

/**
 * Instruments Bun.serve options.
 *
 * @param serveOptions - The options for the Bun.serve function.
 */
function instrumentBunServeOptions(serveOptions: Parameters<typeof Bun.serve>[0]): void {
  // First handle fetch
  instrumentBunServeOptionFetch(serveOptions);
  // then handle routes
  instrumentBunServeOptionRoutes(serveOptions);
}

/**
 * Instruments the `fetch` option of Bun.serve.
 *
 * @param serveOptions - The options for the Bun.serve function.
 */
function instrumentBunServeOptionFetch(serveOptions: Parameters<typeof Bun.serve>[0]): void {
  if (typeof serveOptions.fetch !== 'function') {
    return;
  }

  serveOptions.fetch = new Proxy(serveOptions.fetch, {
    apply(fetchTarget, fetchThisArg, fetchArgs: Parameters<typeof serveOptions.fetch>) {
      return wrapRequestHandler(fetchTarget, fetchThisArg, fetchArgs);
    },
  });
}

/**
 * Instruments the `routes` option of Bun.serve.
 *
 * @param serveOptions - The options for the Bun.serve function.
 */
function instrumentBunServeOptionRoutes(serveOptions: Parameters<typeof Bun.serve>[0]): void {
  if (!serveOptions.routes) {
    return;
  }

  if (typeof serveOptions.routes !== 'object') {
    return;
  }

  Object.keys(serveOptions.routes).forEach(route => {
    const routeHandler = serveOptions.routes[route];

    // Handle route handlers that are an object
    if (typeof routeHandler === 'function') {
      serveOptions.routes[route] = new Proxy(routeHandler, {
        apply: (routeHandlerTarget, routeHandlerThisArg, routeHandlerArgs: Parameters<typeof routeHandler>) => {
          return wrapRequestHandler(routeHandlerTarget, routeHandlerThisArg, routeHandlerArgs, route);
        },
      });
    }

    // Static routes are not instrumented
    if (routeHandler instanceof Response) {
      return;
    }

    // Handle the route handlers that are an object. This means they define a route handler for each method.
    if (typeof routeHandler === 'object') {
      Object.entries(routeHandler).forEach(([routeHandlerObjectHandlerKey, routeHandlerObjectHandler]) => {
        if (typeof routeHandlerObjectHandler === 'function') {
          (serveOptions.routes[route] as Record<string, RouteHandler>)[routeHandlerObjectHandlerKey] = new Proxy(
            routeHandlerObjectHandler,
            {
              apply: (
                routeHandlerObjectHandlerTarget,
                routeHandlerObjectHandlerThisArg,
                routeHandlerObjectHandlerArgs: Parameters<typeof routeHandlerObjectHandler>,
              ) => {
                return wrapRequestHandler(
                  routeHandlerObjectHandlerTarget,
                  routeHandlerObjectHandlerThisArg,
                  routeHandlerObjectHandlerArgs,
                  route,
                );
              },
            },
          );
        }
      });
    }
  });
}

type RouteHandler = Extract<
  NonNullable<Parameters<typeof Bun.serve>[0]['routes']>[string],
  // eslint-disable-next-line @typescript-eslint/ban-types
  Function
>;

function wrapRequestHandler<T extends RouteHandler = RouteHandler>(
  target: T,
  thisArg: unknown,
  args: Parameters<T>,
  route?: string,
): ReturnType<T> {
  return withIsolationScope(isolationScope => {
    const request = args[0];
    const upperCaseMethod = request.method.toUpperCase();
    if (upperCaseMethod === 'OPTIONS' || upperCaseMethod === 'HEAD') {
      return target.apply(thisArg, args);
    }

    const parsedUrl = parseStringToURLObject(request.url);
    const attributes = getSpanAttributesFromParsedUrl(parsedUrl, request);

    let routeName = parsedUrl?.pathname || '/';
    if (request.params) {
      Object.keys(request.params).forEach(key => {
        attributes[`url.path.parameter.${key}`] = (request.params as Record<string, string>)[key];
      });

      // If a route has parameters, it's a parameterized route
      if (route) {
        attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] = 'route';
        attributes['url.template'] = route;
        routeName = route;
      }
    }

    // Handle wildcard routes
    if (route?.endsWith('/*')) {
      attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] = 'route';
      attributes['url.template'] = route;
      routeName = route;
    }

    isolationScope.setSDKProcessingMetadata({
      normalizedRequest: {
        url: request.url,
        method: request.method,
        headers: request.headers.toJSON(),
        query_string: parsedUrl?.search,",1
"          'url.query': '?id=123',
          'url.path': '/users',
          'url.full': `http://localhost:${port}/users?id=123`,
          'url.port': port.toString(),
          'url.scheme': 'http:',
          'url.domain': 'localhost',
        },
        op: 'http.server',
        name: 'GET /users',
      },
      expect.any(Function),
    );
  });

  test('generates a post transaction', async () => {
    const server = Bun.serve({
      async fetch(_req) {
        return new Response('Bun!');
      },
      port,
    });

    await fetch(`http://localhost:${port}/`, {
      method: 'POST',
    });

    await server.stop();

    expect(startSpanSpy).toHaveBeenCalledTimes(1);
    expect(startSpanSpy).toHaveBeenLastCalledWith(
      {
        attributes: {
          'sentry.origin': 'auto.http.bun.serve',
          'http.request.method': 'POST',
          'sentry.source': 'url',
          'url.path': '/',
          'url.full': `http://localhost:${port}/`,
          'url.port': port.toString(),
          'url.scheme': 'http:',
          'url.domain': 'localhost',
        },
        op: 'http.server',
        name: 'POST /',
      },
      expect.any(Function),
    );
  });

  test('continues a trace', async () => {
    const TRACE_ID = '12312012123120121231201212312012';
    const PARENT_SPAN_ID = '1121201211212012';
    const PARENT_SAMPLED = '1';

    const SENTRY_TRACE_HEADER = `${TRACE_ID}-${PARENT_SPAN_ID}-${PARENT_SAMPLED}`;
    const SENTRY_BAGGAGE_HEADER = 'sentry-sample_rand=0.42,sentry-environment=production';

    const server = Bun.serve({
      async fetch(_req) {
        return new Response('Bun!');
      },
      port,
    });

    // Make request with trace headers
    await fetch(`http://localhost:${port}/`, {
      headers: {
        'sentry-trace': SENTRY_TRACE_HEADER,
        baggage: SENTRY_BAGGAGE_HEADER,
      },
    });

    await server.stop();

    // Verify continueTrace was called with the correct headers
    expect(continueTraceSpy).toHaveBeenCalledTimes(1);
    expect(continueTraceSpy).toHaveBeenCalledWith(
      {
        sentryTrace: SENTRY_TRACE_HEADER,
        baggage: SENTRY_BAGGAGE_HEADER,
      },
      expect.any(Function),
    );

    // Verify a span was created
    expect(startSpanSpy).toHaveBeenCalledTimes(1);
  });

  test('skips span creation for OPTIONS and HEAD requests', async () => {
    const server = Bun.serve({
      async fetch(_req) {
        return new Response('Bun!');
      },
      port,",1
"import type { ExecutionContext, IncomingRequestCfProperties } from '@cloudflare/workers-types';
import {
  captureException,
  continueTrace,
  flush,
  getHttpSpanDetailsFromUrlObject,
  parseStringToURLObject,
  SEMANTIC_ATTRIBUTE_SENTRY_OP,
  setHttpStatus,
  startSpan,
  withIsolationScope,
} from '@sentry/core';
import type { CloudflareOptions } from './client';
import { addCloudResourceContext, addCultureContext, addRequest } from './scope-utils';
import { init } from './sdk';

interface RequestHandlerWrapperOptions {
  options: CloudflareOptions;
  request: Request<unknown, IncomingRequestCfProperties<unknown>>;
  context: ExecutionContext;
  /**
   * If true, errors will be captured, rethrown and sent to Sentry.
   * Otherwise, errors are rethrown but not captured.
   *
   * You most likely don't want to set this to `false`, if you use `wrapRequestHandler` directly.
   * This is primarily meant as an escape hatch for higher-level SDKs relying on additional error
   * capturing mechanisms where this wrapper captures errors too early or too generally.
   *
   * @default true
   */
  captureErrors?: boolean;
}

/**
 * Wraps a cloudflare request handler in Sentry instrumentation
 */
export function wrapRequestHandler(
  wrapperOptions: RequestHandlerWrapperOptions,
  handler: (...args: unknown[]) => Response | Promise<Response>,
): Promise<Response> {
  return withIsolationScope(async isolationScope => {
    const { options, request, captureErrors = true } = wrapperOptions;

    // In certain situations, the passed context can become undefined.
    // For example, for Astro while prerendering pages at build time.
    // see: https://github.com/getsentry/sentry-javascript/issues/13217
    const context = wrapperOptions.context as ExecutionContext | undefined;

    const waitUntil = context?.waitUntil?.bind?.(context);

    const client = init({ ...options, ctx: context });
    isolationScope.setClient(client);

    const urlObject = parseStringToURLObject(request.url);
    const [name, attributes] = getHttpSpanDetailsFromUrlObject(urlObject, 'server', 'auto.http.cloudflare', request);

    const contentLength = request.headers.get('content-length');
    if (contentLength) {
      attributes['http.request.body.size'] = parseInt(contentLength, 10);
    }

    const userAgentHeader = request.headers.get('user-agent');
    if (userAgentHeader) {
      attributes['user_agent.original'] = userAgentHeader;
    }

    attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP] = 'http.server';

    addCloudResourceContext(isolationScope);
    addRequest(isolationScope, request);
    if (request.cf) {
      addCultureContext(isolationScope, request.cf);",1
"          'network.protocol.name': 'HTTP/1.1',
          'url.scheme': 'https:',
          'url.path': '/',
          'sentry.sample_rate': 1,
          'http.response.status_code': 200,
          'http.request.body.size': 10,
        },
        op: 'http.server',
        origin: 'auto.http.cloudflare',
        span_id: expect.stringMatching(/[a-f0-9]{16}/),
        status: 'ok',
        trace_id: expect.stringMatching(/[a-f0-9]{32}/),",1
"export {
  winterCGHeadersToDict,
  winterCGRequestToRequestData,
  httpRequestToRequestData,
  extractQueryParamsFromUrl,
  headersToDict,
} from './utils/request';
export { DEFAULT_ENVIRONMENT } from './constants';
export { addBreadcrumb } from './breadcrumbs';
export { functionToStringIntegration } from './integrations/functiontostring';
// eslint-disable-next-line deprecation/deprecation
export { inboundFiltersIntegration } from './integrations/eventFilters';",1
"    return `${protocol}://${host}${url}`;
  }

  return undefined;
}

/** Extract the query params from an URL. */
export function extractQueryParamsFromUrl(url: string): string | undefined {
  // url is path and query string
  if (!url) {
    return;
  }",1
"import { describe, expect, it } from 'vitest';
import {
  extractQueryParamsFromUrl,
  headersToDict,
  httpRequestToRequestData,
  winterCGHeadersToDict,
  winterCGRequestToRequestData,
} from '../../../src/utils/request';

describe('request utils', () => {
  describe('winterCGHeadersToDict', () => {
    it('works with invalid headers object', () => {
      expect(winterCGHeadersToDict({} as any)).toEqual({});
    });

    it('works with header object', () => {
      expect(
        winterCGHeadersToDict({
          forEach: (callbackfn: (value: unknown, key: string) => void): void => {
            callbackfn('value1', 'key1');
            callbackfn(['value2'], 'key2');
            callbackfn('value3', 'key3');
          },
        } as any),
      ).toEqual({
        key1: 'value1',
        key3: 'value3',
      });
    });
  });

  describe('headersToDict', () => {
    it('works with empty object', () => {
      expect(headersToDict({})).toEqual({});
    });

    it('works with plain object', () => {
      expect(
        headersToDict({
          key1: 'value1',
          key2: ['value2'],
          key3: 'value3',
        }),
      ).toEqual({
        key1: 'value1',
        key3: 'value3',
      });
    });
  });

  describe('winterCGRequestToRequestData', () => {
    it('works', () => {
      const actual = winterCGRequestToRequestData({
        method: 'GET',
        url: 'http://example.com?foo=bar&baz=qux',
        headers: {
          forEach: (callbackfn: (value: unknown, key: string) => void): void => {
            callbackfn('value1', 'key1');
            callbackfn(['value2'], 'key2');
            callbackfn('value3', 'key3');
          },
        } as any,
        clone: () => ({}) as any,
      });

      expect(actual).toEqual({
        headers: {
          key1: 'value1',
          key3: 'value3',
        },
        method: 'GET',
        query_string: 'foo=bar&baz=qux',
        url: 'http://example.com?foo=bar&baz=qux',
      });
    });
  });

  describe('httpRequestToRequestData', () => {
    it('works with minimal request', () => {
      const actual = httpRequestToRequestData({});
      expect(actual).toEqual({
        headers: {},
      });
    });

    it('works with absolute URL request', () => {
      const actual = httpRequestToRequestData({
        method: 'GET',
        url: 'http://example.com/blabla?xx=a&yy=z',
        headers: {
          key1: 'value1',
          key2: ['value2'],
          key3: 'value3',
        },
      });

      expect(actual).toEqual({
        method: 'GET',
        url: 'http://example.com/blabla?xx=a&yy=z',
        headers: {
          key1: 'value1',
          key3: 'value3',
        },
        query_string: 'xx=a&yy=z',
      });
    });

    it('works with relative URL request without host', () => {
      const actual = httpRequestToRequestData({
        method: 'GET',
        url: '/blabla',
        headers: {
          key1: 'value1',
          key2: ['value2'],
          key3: 'value3',
        },
      });

      expect(actual).toEqual({
        method: 'GET',
        headers: {
          key1: 'value1',
          key3: 'value3',
        },
      });
    });

    it('works with relative URL request with host', () => {
      const actual = httpRequestToRequestData({
        url: '/blabla',
        headers: {
          host: 'example.com',
        },
      });

      expect(actual).toEqual({
        url: 'http://example.com/blabla',
        headers: {
          host: 'example.com',
        },
      });
    });

    it('works with relative URL request with host & protocol', () => {
      const actual = httpRequestToRequestData({
        url: '/blabla',
        headers: {
          host: 'example.com',
        },
        protocol: 'https',
      });

      expect(actual).toEqual({
        url: 'https://example.com/blabla',
        headers: {
          host: 'example.com',
        },
      });
    });

    it('works with relative URL request with host & socket', () => {
      const actual = httpRequestToRequestData({
        url: '/blabla',
        headers: {
          host: 'example.com',
        },
        socket: {
          encrypted: true,
        },
      });

      expect(actual).toEqual({
        url: 'https://example.com/blabla',
        headers: {
          host: 'example.com',
        },
      });
    });

    it('extracts non-standard cookies', () => {
      const actual = httpRequestToRequestData({
        cookies: { xx: 'a', yy: 'z' },
      } as any);

      expect(actual).toEqual({
        headers: {},
        cookies: { xx: 'a', yy: 'z' },
      });
    });

    it('extracts non-standard body', () => {
      const actual = httpRequestToRequestData({
        body: { xx: 'a', yy: 'z' },
      } as any);

      expect(actual).toEqual({
        headers: {},
        data: { xx: 'a', yy: 'z' },
      });
    });

    describe('x-forwarded headers support', () => {
      it('should prioritize x-forwarded-proto header over explicit protocol parameter', () => {
        const actual = httpRequestToRequestData({
          url: '/test',
          headers: {
            host: 'example.com',
            'x-forwarded-proto': 'https',
          },
          protocol: 'http',
        });

        expect(actual).toEqual({
          url: 'https://example.com/test',
          headers: {
            host: 'example.com',
            'x-forwarded-proto': 'https',
          },
        });
      });

      it('should prioritize x-forwarded-proto header even when downgrading from https to http', () => {
        const actual = httpRequestToRequestData({
          url: '/test',
          headers: {
            host: 'example.com',
            'x-forwarded-proto': 'http',
          },
          protocol: 'https',
        });

        expect(actual).toEqual({
          url: 'http://example.com/test',
          headers: {
            host: 'example.com',
            'x-forwarded-proto': 'http',
          },
        });
      });

      it('should prioritize x-forwarded-proto header over socket encryption detection', () => {
        const actual = httpRequestToRequestData({
          url: '/test',
          headers: {
            host: 'example.com',
            'x-forwarded-proto': 'https',
          },
          socket: {
            encrypted: false,
          },
        });

        expect(actual).toEqual({
          url: 'https://example.com/test',
          headers: {
            host: 'example.com',
            'x-forwarded-proto': 'https',
          },
        });
      });

      it('should prioritize x-forwarded-host header over standard host header', () => {
        const actual = httpRequestToRequestData({
          url: '/test',
          headers: {
            host: 'localhost:3000',
            'x-forwarded-host': 'example.com',
            'x-forwarded-proto': 'https',
          },
        });

        expect(actual).toEqual({
          url: 'https://example.com/test',
          headers: {
            host: 'localhost:3000',
            'x-forwarded-host': 'example.com',
            'x-forwarded-proto': 'https',
          },
        });
      });

      it('should construct URL correctly when both x-forwarded-proto and x-forwarded-host are present', () => {
        const actual = httpRequestToRequestData({
          method: 'POST',
          url: '/api/test?param=value',
          headers: {
            host: 'localhost:3000',
            'x-forwarded-host': 'api.example.com',
            'x-forwarded-proto': 'https',
            'content-type': 'application/json',
          },
          protocol: 'http',
        });

        expect(actual).toEqual({
          method: 'POST',
          url: 'https://api.example.com/api/test?param=value',
          query_string: 'param=value',
          headers: {
            host: 'localhost:3000',
            'x-forwarded-host': 'api.example.com',
            'x-forwarded-proto': 'https',
            'content-type': 'application/json',
          },
        });
      });

      it('should fall back to standard headers when x-forwarded headers are not present', () => {
        const actual = httpRequestToRequestData({
          url: '/test',
          headers: {
            host: 'example.com',
          },
          protocol: 'https',
        });

        expect(actual).toEqual({
          url: 'https://example.com/test',
          headers: {
            host: 'example.com',
          },
        });
      });

      it('should ignore x-forwarded headers when they contain non-string values', () => {
        const actual = httpRequestToRequestData({
          url: '/test',
          headers: {
            host: 'example.com',
            'x-forwarded-host': ['forwarded.example.com'] as any,
            'x-forwarded-proto': ['https'] as any,
          },
          protocol: 'http',
        });

        expect(actual).toEqual({
          url: 'http://example.com/test',
          headers: {
            host: 'example.com',
          },
        });
      });

      it('should correctly transform localhost request to public URL using x-forwarded headers', () => {
        const actual = httpRequestToRequestData({
          method: 'GET',
          url: '/',
          headers: {
            host: 'localhost:3000',
            'x-forwarded-proto': 'https',
            'x-forwarded-host': 'example.com',
          },
        });

        expect(actual).toEqual({
          method: 'GET',
          url: 'https://example.com/',
          headers: {
            host: 'localhost:3000',
            'x-forwarded-proto': 'https',
            'x-forwarded-host': 'example.com',
          },
        });
      });

      it('should respect x-forwarded-proto even when it downgrades from encrypted socket', () => {
        const actual = httpRequestToRequestData({
          url: '/test',
          headers: {
            host: 'example.com',
            'x-forwarded-proto': 'http',
          },
          socket: {
            encrypted: true,
          },
        });

        expect(actual).toEqual({
          url: 'http://example.com/test',
          headers: {
            host: 'example.com',
            'x-forwarded-proto': 'http',
          },
        });
      });

      it('should preserve query parameters when constructing URL with x-forwarded headers', () => {
        const actual = httpRequestToRequestData({
          method: 'GET',
          url: '/search?q=test&category=api',
          headers: {
            host: 'localhost:8080',
            'x-forwarded-host': 'search.example.com',
            'x-forwarded-proto': 'https',
          },
        });

        expect(actual).toEqual({
          method: 'GET',
          url: 'https://search.example.com/search?q=test&category=api',
          query_string: 'q=test&category=api',
          headers: {
            host: 'localhost:8080',
            'x-forwarded-host': 'search.example.com',
            'x-forwarded-proto': 'https',
          },
        });
      });
    });
  });

  describe('extractQueryParamsFromUrl', () => {
    it.each([
      ['/', undefined],
      ['http://example.com', undefined],
      ['/sub-path', undefined],
      ['/sub-path?xx=a&yy=z', 'xx=a&yy=z'],
      ['http://example.com/sub-path?xx=a&yy=z', 'xx=a&yy=z'],
    ])('works with %s', (url, expected) => {
      expect(extractQueryParamsFromUrl(url)).toEqual(expected);
    });
  });
});",1
"  defaultStackParser,
  lastEventId,
  flush,
  close,
  getSentryRelease,
  createGetModuleFromFilename,
  // eslint-disable-next-line deprecation/deprecation
  anrIntegration,
  // eslint-disable-next-line deprecation/deprecation
  disableAnrDetectionForCallback,
  consoleIntegration,
  httpIntegration,",1
"  startSpanManual,
  vercelWaitUntil,
  withIsolationScope,
} from '@sentry/core';
import type { NextApiRequest } from 'next';
import type { AugmentedNextApiResponse, NextApiHandler } from '../types';
import { flushSafelyWithTimeout } from '../utils/responseEnd';
import { dropNextjsRootContext, escapeNextjsTracing } from '../utils/tracingUtils';

export type AugmentedNextApiRequest = NextApiRequest & {
  __withSentry_applied__?: boolean;
};

/**
 * Wrap the given API route handler with error nad performance monitoring.
 *
 * @param apiHandler The handler exported from the user's API page route file, which may or may not already be
 * wrapped with `withSentry`
 * @param parameterizedRoute The page's parameterized route.
 * @returns The wrapped handler which will always return a Promise.
 */
export function wrapApiHandlerWithSentry(apiHandler: NextApiHandler, parameterizedRoute: string): NextApiHandler {
  return new Proxy(apiHandler, {
    apply: (
      wrappingTarget,
      thisArg,
      args: [AugmentedNextApiRequest | undefined, AugmentedNextApiResponse | undefined],
    ) => {
      dropNextjsRootContext();
      return escapeNextjsTracing(() => {
        const [req, res] = args;

        if (!req) {
          debug.log(
            `Wrapped API handler on route ""${parameterizedRoute}"" was not passed a request object. Will not instrument.`,
          );
          return wrappingTarget.apply(thisArg, args);
        } else if (!res) {
          debug.log(
            `Wrapped API handler on route ""${parameterizedRoute}"" was not passed a response object. Will not instrument.`,
          );
          return wrappingTarget.apply(thisArg, args);
        }

        // Prevent double wrapping of the same request.
        if (req.__withSentry_applied__) {
          return wrappingTarget.apply(thisArg, args);
        }
        req.__withSentry_applied__ = true;

        return withIsolationScope(isolationScope => {
          // Normally, there is an active span here (from Next.js OTEL) and we just use that as parent
          // Else, we manually continueTrace from the incoming headers
          const continueTraceIfNoActiveSpan = getActiveSpan()
            ? <T>(_opts: unknown, callback: () => T) => callback()
            : continueTrace;

          return continueTraceIfNoActiveSpan(
            {
              sentryTrace:
                req.headers && isString(req.headers['sentry-trace']) ? req.headers['sentry-trace'] : undefined,
              baggage: req.headers?.baggage,
            },
            () => {
              const reqMethod = `${(req.method || 'GET').toUpperCase()} `;
              const normalizedRequest = httpRequestToRequestData(req);

              isolationScope.setSDKProcessingMetadata({ normalizedRequest });
              isolationScope.setTransactionName(`${reqMethod}${parameterizedRoute}`);

              return startSpanManual(
                {
                  name: `${reqMethod}${parameterizedRoute}`,
                  op: 'http.server',
                  forceTransaction: true,
                  attributes: {
                    [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'route',
                    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.nextjs',
                  },
                },
                async span => {
                  // eslint-disable-next-line @typescript-eslint/unbound-method
                  res.end = new Proxy(res.end, {
                    apply(target, thisArg, argArray) {",1
"  withIsolationScope,
  withScope,
} from '@sentry/core';
import type { GenerationFunctionContext } from '../common/types';
import { isNotFoundNavigationError, isRedirectNavigationError } from './nextNavigationErrorUtils';
import { TRANSACTION_ATTR_SENTRY_TRACE_BACKFILL } from './span-attributes-with-logic-attached';
import { commonObjectToIsolationScope, commonObjectToPropagationContext } from './utils/tracingUtils';
import { getSanitizedRequestUrl } from './utils/urls';
import { maybeExtractSynchronousParamsAndSearchParams } from './utils/wrapperUtils';
/**
 * Wraps a generation function (e.g. generateMetadata) with Sentry error and performance instrumentation.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function wrapGenerationFunctionWithSentry<F extends (...args: any[]) => any>(
  generationFunction: F,
  context: GenerationFunctionContext,
): F {
  const { requestAsyncStorage, componentRoute, componentType, generationFunctionIdentifier } = context;
  return new Proxy(generationFunction, {
    apply: (originalFunction, thisArg, args) => {
      const requestTraceId = getActiveSpan()?.spanContext().traceId;
      let headers: WebFetchHeaders | undefined = undefined;
      // We try-catch here just in case anything goes wrong with the async storage here goes wrong since it is Next.js internal API
      try {
        headers = requestAsyncStorage?.getStore()?.headers;
      } catch {
        /** empty */
      }

      const isolationScope = commonObjectToIsolationScope(headers);
      let pathname = undefined as string | undefined;

      const activeSpan = getActiveSpan();
      if (activeSpan) {
        const rootSpan = getRootSpan(activeSpan);
        const { scope } = getCapturedScopesOnSpan(rootSpan);
        setCapturedScopesOnSpan(rootSpan, scope ?? new Scope(), isolationScope);

        const spanData = spanToJSON(rootSpan);

        if (spanData.data && 'http.target' in spanData.data) {
          pathname = spanData.data['http.target'] as string;
        }
      }

      const headersDict = headers ? winterCGHeadersToDict(headers) : undefined;

      let data: Record<string, unknown> | undefined = undefined;
      if (getClient()?.getOptions().sendDefaultPii) {
        const props: unknown = args[0];
        const { params, searchParams } = maybeExtractSynchronousParamsAndSearchParams(props);
        data = { params, searchParams };
      }",1
"  setCapturedScopesOnSpan,
  startSpan,
  vercelWaitUntil,
  winterCGRequestToRequestData,
  withIsolationScope,
} from '@sentry/core';
import { flushSafelyWithTimeout } from '../common/utils/responseEnd';
import type { EdgeRouteHandler } from '../edge/types';

/**
 * Wraps Next.js middleware with Sentry error and performance instrumentation.
 *
 * @param middleware The middleware handler.
 * @returns a wrapped middleware handler.
 */
export function wrapMiddlewareWithSentry<H extends EdgeRouteHandler>(
  middleware: H,
): (...params: Parameters<H>) => Promise<ReturnType<H>> {
  return new Proxy(middleware, {
    apply: async (wrappingTarget, thisArg, args: Parameters<H>) => {
      const tunnelRoute =
        '_sentryRewritesTunnelPath' in globalThis
          ? (globalThis as Record<string, unknown>)._sentryRewritesTunnelPath
          : undefined;

      if (tunnelRoute && typeof tunnelRoute === 'string') {
        const req: unknown = args[0];
        // Check if the current request matches the tunnel route
        if (req instanceof Request) {
          const url = new URL(req.url);
          const isTunnelRequest = url.pathname.startsWith(tunnelRoute);

          if (isTunnelRequest) {
            // Create a simple response that mimics NextResponse.next() so we don't need to import internals here
            // which breaks next 13 apps
            // https://github.com/vercel/next.js/blob/c12c9c1f78ad384270902f0890dc4cd341408105/packages/next/src/server/web/spec-extension/response.ts#L146
            return new Response(null, {
              status: 200,
              headers: {
                'x-middleware-next': '1',
              },
            }) as ReturnType<H>;
          }
        }
      }
      // TODO: We still should add central isolation scope creation for when our build-time instrumentation does not work anymore with turbopack.
      return withIsolationScope(isolationScope => {
        const req: unknown = args[0];
        const currentScope = getCurrentScope();

        let spanName: string;
        let spanSource: TransactionSource;

        if (req instanceof Request) {
          isolationScope.setSDKProcessingMetadata({
            normalizedRequest: winterCGRequestToRequestData(req),
          });
          spanName = `middleware ${req.method} ${new URL(req.url).pathname}`;
          spanSource = 'url';
        } else {
          spanName = 'middleware';
          spanSource = 'component';
        }

        currentScope.setTransactionName(spanName);

        const activeSpan = getActiveSpan();

        if (activeSpan) {
          // If there is an active span, it likely means that the automatic Next.js OTEL instrumentation worked and we can
          // rely on that for parameterization.
          spanName = 'middleware';
          spanSource = 'component';

          const rootSpan = getRootSpan(activeSpan);
          if (rootSpan) {
            setCapturedScopesOnSpan(rootSpan, currentScope, isolationScope);
          }
        }

        return startSpan(
          {
            name: spanName,
            op: 'http.server.middleware',
            attributes: {
              [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: spanSource,
              [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.nextjs.wrapMiddlewareWithSentry',
            },
          },
          () => {
            return handleCallbackErrors(
              () => wrappingTarget.apply(thisArg, args),
              error => {",1
"  winterCGHeadersToDict,
  withIsolationScope,
  withScope,
} from '@sentry/core';
import { isNotFoundNavigationError, isRedirectNavigationError } from './nextNavigationErrorUtils';
import type { RouteHandlerContext } from './types';
import { flushSafelyWithTimeout } from './utils/responseEnd';
import { commonObjectToIsolationScope } from './utils/tracingUtils';

/**
 * Wraps a Next.js App Router Route handler with Sentry error and performance instrumentation.
 *
 * NOTICE: This wrapper is for App Router API routes. If you are looking to wrap Pages Router API routes use `wrapApiHandlerWithSentry` instead.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function wrapRouteHandlerWithSentry<F extends (...args: any[]) => any>(
  routeHandler: F,
  context: RouteHandlerContext,
): (...args: Parameters<F>) => ReturnType<F> extends Promise<unknown> ? ReturnType<F> : Promise<ReturnType<F>> {
  const { method, parameterizedRoute, headers } = context;

  return new Proxy(routeHandler, {
    apply: async (originalFunction, thisArg, args) => {
      const activeSpan = getActiveSpan();
      const rootSpan = activeSpan ? getRootSpan(activeSpan) : undefined;

      let edgeRuntimeIsolationScopeOverride: Scope | undefined;
      if (rootSpan && process.env.NEXT_RUNTIME === 'edge') {
        const isolationScope = commonObjectToIsolationScope(headers);
        const { scope } = getCapturedScopesOnSpan(rootSpan);
        setCapturedScopesOnSpan(rootSpan, scope ?? new Scope(), isolationScope);

        edgeRuntimeIsolationScopeOverride = isolationScope;

        rootSpan.updateName(`${method} ${parameterizedRoute}`);
        rootSpan.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, 'route');
        rootSpan.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'http.server');
      }

      return withIsolationScope(
        process.env.NEXT_RUNTIME === 'edge' ? edgeRuntimeIsolationScopeOverride : getIsolationScope(),
        () => {
          return withScope(async scope => {",1
"  withScope,
} from '@sentry/core';
import { isNotFoundNavigationError, isRedirectNavigationError } from '../common/nextNavigationErrorUtils';
import type { ServerComponentContext } from '../common/types';
import { flushSafelyWithTimeout } from '../common/utils/responseEnd';
import { TRANSACTION_ATTR_SENTRY_TRACE_BACKFILL } from './span-attributes-with-logic-attached';
import { commonObjectToIsolationScope, commonObjectToPropagationContext } from './utils/tracingUtils';
import { getSanitizedRequestUrl } from './utils/urls';
import { maybeExtractSynchronousParamsAndSearchParams } from './utils/wrapperUtils';

/**
 * Wraps an `app` directory server component with Sentry error instrumentation.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function wrapServerComponentWithSentry<F extends (...args: any[]) => any>(
  appDirComponent: F,
  context: ServerComponentContext,
): F {
  const { componentRoute, componentType } = context;
  // Even though users may define server components as async functions, for the client bundles
  // Next.js will turn them into synchronous functions and it will transform any `await`s into instances of the `use`
  // hook. 🤯
  return new Proxy(appDirComponent, {
    apply: (originalFunction, thisArg, args) => {
      const requestTraceId = getActiveSpan()?.spanContext().traceId;
      const isolationScope = commonObjectToIsolationScope(context.headers);

      let pathname = undefined as string | undefined;
      const activeSpan = getActiveSpan();
      if (activeSpan) {
        const rootSpan = getRootSpan(activeSpan);
        const { scope } = getCapturedScopesOnSpan(rootSpan);
        setCapturedScopesOnSpan(rootSpan, scope ?? new Scope(), isolationScope);

        const spanData = spanToJSON(rootSpan);

        if (spanData.data && 'http.target' in spanData.data) {
          pathname = spanData.data['http.target']?.toString();
        }
      }

      const headersDict = context.headers ? winterCGHeadersToDict(context.headers) : undefined;

      let params: Record<string, string> | undefined = undefined;

      if (getClient()?.getOptions().sendDefaultPii) {
        const props: unknown = args[0];
        const { params: paramsFromProps } = maybeExtractSynchronousParamsAndSearchParams(props);
        params = paramsFromProps;",1
"  setCapturedScopesOnSpan,
  startSpan,
  vercelWaitUntil,
  winterCGRequestToRequestData,
  withIsolationScope,
} from '@sentry/core';
import { flushSafelyWithTimeout } from '../common/utils/responseEnd';
import type { EdgeRouteHandler } from './types';

/**
 * Wraps a Next.js edge route handler with Sentry error and performance instrumentation.
 */
export function wrapApiHandlerWithSentry<H extends EdgeRouteHandler>(
  handler: H,
  parameterizedRoute: string,
): (...params: Parameters<H>) => Promise<ReturnType<H>> {
  return new Proxy(handler, {
    apply: async (wrappingTarget, thisArg, args: Parameters<H>) => {
      // TODO: We still should add central isolation scope creation for when our build-time instrumentation does not work anymore with turbopack.

      return withIsolationScope(isolationScope => {
        const req: unknown = args[0];
        const currentScope = getCurrentScope();

        if (req instanceof Request) {
          isolationScope.setSDKProcessingMetadata({
            normalizedRequest: winterCGRequestToRequestData(req),
          });
          currentScope.setTransactionName(`${req.method} ${parameterizedRoute}`);
        } else {
          currentScope.setTransactionName(`handler (${parameterizedRoute})`);
        }

        let spanName: string;
        let op: string | undefined = 'http.server';

        // If there is an active span, it likely means that the automatic Next.js OTEL instrumentation worked and we can
        // rely on that for parameterization.
        const activeSpan = getActiveSpan();
        if (activeSpan) {
          spanName = `handler (${parameterizedRoute})`;
          op = undefined;

          const rootSpan = getRootSpan(activeSpan);
          if (rootSpan) {
            rootSpan.updateName(
              req instanceof Request ? `${req.method} ${parameterizedRoute}` : `handler ${parameterizedRoute}`,
            );
            rootSpan.setAttributes({
              [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'http.server',
              [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'route',
            });
            setCapturedScopesOnSpan(rootSpan, currentScope, isolationScope);
          }
        } else if (req instanceof Request) {
          spanName = `${req.method} ${parameterizedRoute}`;
        } else {
          spanName = `handler ${parameterizedRoute}`;
        }

        return startSpan(
          {
            name: spanName,
            op: op,
            attributes: {
              [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'route',
              [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.nextjs.wrapApiHandlerWithSentry',
            },
          },
          () => {
            return handleCallbackErrors(
              () => wrappingTarget.apply(thisArg, args),
              error => {",1
"
    expect(startSpanManualSpy).not.toHaveBeenCalled();
  });

  test('wrapped function sets route backfill attribute when called within an active span', async () => {
    const mockSetAttribute = vi.fn();
    const mockGetActiveSpan = vi.spyOn(SentryCore, 'getActiveSpan').mockReturnValue({
      setAttribute: mockSetAttribute,
    } as any);
    const mockGetRootSpan = vi.spyOn(SentryCore, 'getRootSpan').mockReturnValue({
      setAttribute: mockSetAttribute,
    } as any);

    const origFunction = vi.fn(async () => ({ props: {} }));
    const wrappedOriginal = wrapGetServerSidePropsWithSentry(origFunction, route);

    await wrappedOriginal({ req, res } as any);

    expect(mockGetActiveSpan).toHaveBeenCalled();
    expect(mockGetRootSpan).toHaveBeenCalled();
    expect(mockSetAttribute).toHaveBeenCalledWith('sentry.route_backfill', '/tricks/[trickName]');
  });

  test('wrapped function does not set route backfill attribute for /_error route', async () => {
    const mockSetAttribute = vi.fn();
    const mockGetActiveSpan = vi.spyOn(SentryCore, 'getActiveSpan').mockReturnValue({
      setAttribute: mockSetAttribute,
    } as any);
    const mockGetRootSpan = vi.spyOn(SentryCore, 'getRootSpan').mockReturnValue({
      setAttribute: mockSetAttribute,
    } as any);

    const origFunction = vi.fn(async () => ({ props: {} }));
    const wrappedOriginal = wrapGetServerSidePropsWithSentry(origFunction, '/_error');

    await wrappedOriginal({ req, res } as any);",1
"  debug,
  generateSpanId,
  getClient,
  getCurrentScope,
  getIsolationScope,
  getSpanStatusFromHttpCode,
  httpRequestToRequestData,
  parseStringToURLObject,
  SEMANTIC_ATTRIBUTE_SENTRY_OP,
  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,
  SPAN_STATUS_ERROR,
  stripUrlQueryAndFragment,
  withIsolationScope,
} from '@sentry/core';
import type EventEmitter from 'events';
import { errorMonitor } from 'events';
import type { ClientRequest, IncomingHttpHeaders, IncomingMessage, Server, ServerResponse } from 'http';
import type { Socket } from 'net';
import { DEBUG_BUILD } from '../../debug-build';
import type { NodeClient } from '../../sdk/client';
import { INSTRUMENTATION_NAME, MAX_BODY_BYTE_LENGTH } from './constants';

// Tree-shakable guard to remove all code related to tracing
declare const __SENTRY_TRACING__: boolean;

type ServerEmit = typeof Server.prototype.emit;

const HTTP_SERVER_INSTRUMENTED_KEY = createContextKey('sentry_http_server_instrumented');

const clientToRequestSessionAggregatesMap = new Map<
  Client,
  { [timestampRoundedToSeconds: string]: { exited: number; crashed: number; errored: number } }
>();

// We keep track of emit functions we wrapped, to avoid double wrapping
// We do this instead of putting a non-enumerable property on the function, because
// sometimes the property seems to be migrated to forks of the emit function, which we do not want to happen
// This was the case in the nestjs-distributed-tracing E2E test
const wrappedEmitFns = new WeakSet<ServerEmit>();

/**
 * Instrument a server to capture incoming requests.
 *
 */
export function instrumentServer(
  server: Server,
  {
    ignoreIncomingRequestBody,
    ignoreSpansForIncomingRequests,
    maxIncomingRequestBodySize = 'medium',
    trackIncomingRequestsAsSessions = true,
    spans,
    ignoreStaticAssets = true,
    sessionFlushingDelayMS,
    // eslint-disable-next-line deprecation/deprecation
    instrumentation,
    incomingRequestSpanHook,
  }: {
    ignoreIncomingRequestBody?: (url: string, request: IncomingMessage) => boolean;
    ignoreSpansForIncomingRequests?: (urlPath: string, request: IncomingMessage) => boolean;
    maxIncomingRequestBodySize?: 'small' | 'medium' | 'always' | 'none';
    trackIncomingRequestsAsSessions?: boolean;
    sessionFlushingDelayMS: number;
    spans: boolean;
    ignoreStaticAssets?: boolean;
    incomingRequestSpanHook?: (span: Span, request: IncomingMessage, response: ServerResponse) => void;
    /** @deprecated Use `incomingRequestSpanHook` instead. */
    instrumentation?: {
      requestHook?: (span: Span, req: IncomingMessage | ClientRequest) => void;
      responseHook?: (span: Span, response: ServerResponse | IncomingMessage) => void;
      applyCustomAttributesOnSpan?: (
        span: Span,
        request: IncomingMessage | ClientRequest,
        response: ServerResponse | IncomingMessage,
      ) => void;
    };
  },
): void {
  // eslint-disable-next-line @typescript-eslint/unbound-method
  const originalEmit: ServerEmit = server.emit;

  if (wrappedEmitFns.has(originalEmit)) {
    DEBUG_BUILD &&
      debug.log(INSTRUMENTATION_NAME, 'Incoming requests already instrumented, not instrumenting again...');
    return;
  }

  const { requestHook, responseHook, applyCustomAttributesOnSpan } = instrumentation ?? {};

  const newEmit = new Proxy(originalEmit, {
    apply(target, thisArg, args: [event: string, ...args: unknown[]]) {
      // Only traces request events
      if (args[0] !== 'request') {
        return target.apply(thisArg, args);
      }

      // Make sure we do not double execute our wrapper code, for edge cases...
      // Without this check, if we double-wrap emit, for whatever reason, you'd get two http.server spans (one the children of the other)
      if (context.active().getValue(HTTP_SERVER_INSTRUMENTED_KEY)) {
        return target.apply(thisArg, args);
      }

      DEBUG_BUILD && debug.log(INSTRUMENTATION_NAME, 'Handling incoming request');

      const client = getClient<NodeClient>();
      const isolationScope = getIsolationScope().clone();
      const request = args[1] as IncomingMessage;
      const response = args[2] as ServerResponse & { socket: Socket };

      const normalizedRequest = httpRequestToRequestData(request);

      // request.ip is non-standard but some frameworks set this
      const ipAddress = (request as { ip?: string }).ip || request.socket?.remoteAddress;

      const url = request.url || '/';
      if (maxIncomingRequestBodySize !== 'none' && !ignoreIncomingRequestBody?.(url, request)) {
        patchRequestToCaptureBody(request, isolationScope, maxIncomingRequestBodySize);
      }

      // Update the isolation scope, isolate this request
      isolationScope.setSDKProcessingMetadata({ normalizedRequest, ipAddress });

      // attempt to update the scope's `transactionName` based on the request URL
      // Ideally, framework instrumentations coming after the HttpInstrumentation
      // update the transactionName once we get a parameterized route.
      const httpMethod = (request.method || 'GET').toUpperCase();
      const httpTargetWithoutQueryFragment = stripUrlQueryAndFragment(url);

      const bestEffortTransactionName = `${httpMethod} ${httpTargetWithoutQueryFragment}`;

      isolationScope.setTransactionName(bestEffortTransactionName);

      if (trackIncomingRequestsAsSessions !== false) {
        recordRequestSession({
          requestIsolationScope: isolationScope,
          response,
          sessionFlushingDelayMS: sessionFlushingDelayMS ?? 60_000,
        });
      }

      return withIsolationScope(isolationScope, () => {
        // Set a new propagationSpanId for this request
        // We rely on the fact that `withIsolationScope()` will implicitly also fork the current scope
        // This way we can save an ""unnecessary"" `withScope()` invocation
        getCurrentScope().getPropagationContext().propagationSpanId = generateSpanId();

        const ctx = propagation
          .extract(context.active(), normalizedRequest.headers)
          .setValue(HTTP_SERVER_INSTRUMENTED_KEY, true);

        return context.with(ctx, () => {
          // if opting out of span creation, we can end here
          if (
            (typeof __SENTRY_TRACING__ !== 'undefined' && !__SENTRY_TRACING__) ||
            !spans ||
            !client ||
            shouldIgnoreSpansForIncomingRequest(request, {
              ignoreStaticAssets,
              ignoreSpansForIncomingRequests,
            })
          ) {
            DEBUG_BUILD && debug.log(INSTRUMENTATION_NAME, 'Skipping span creation for incoming request');
            return target.apply(thisArg, args);
          }

          const fullUrl = normalizedRequest.url || url;
          const urlObj = parseStringToURLObject(fullUrl);

          const headers = request.headers;
          const userAgent = headers['user-agent'];
          const ips = headers['x-forwarded-for'];
          const httpVersion = request.httpVersion;
          const host = headers.host;
          const hostname = host?.replace(/^(.*)(:[0-9]{1,5})/, '$1') || 'localhost';

          const tracer = client.tracer;
          const scheme = fullUrl.startsWith('https') ? 'https' : 'http';

          // We use the plain tracer.startSpan here so we can pass the span kind
          const span = tracer.startSpan(bestEffortTransactionName, {
            kind: SpanKind.SERVER,
            attributes: {
              // Sentry specific attributes
              [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'http.server',
              [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.otel.http',
              'sentry.http.prefetch': isKnownPrefetchRequest(request) || undefined,
              // Old Semantic Conventions attributes - added for compatibility with what `@opentelemetry/instrumentation-http` output before
              'http.url': fullUrl,
              'http.method': httpMethod,
              'http.target': urlObj ? `${urlObj.pathname}${urlObj.search}` : httpTargetWithoutQueryFragment,
              'http.host': host,
              'net.host.name': hostname,
              'http.client_ip': typeof ips === 'string' ? ips.split(',')[0] : undefined,
              'http.user_agent': userAgent,
              'http.scheme': scheme,
              'http.flavor': httpVersion,
              'net.transport': httpVersion?.toUpperCase() === 'QUIC' ? 'ip_udp' : 'ip_tcp',
              ...getRequestContentLengthAttribute(request),
            },
          });

          // TODO v11: Remove the following three hooks, only incomingRequestSpanHook should remain
          requestHook?.(span, request);
          responseHook?.(span, response);",1
"  parameterize,
  getClient,
  getCurrentScope,
  getIsolationScope,
  getTraceData,
  getTraceMetaTags,
  continueTrace,
  withScope,
  withIsolationScope,
  captureException,
  captureEvent,
  captureMessage,",1
"  fill,
  getActiveSpan,
  getClient,
  getRootSpan,
  getTraceData,
  hasSpansEnabled,
  isNodeEnv,
  loadModule,
  SEMANTIC_ATTRIBUTE_SENTRY_OP,
  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,
  SEMANTIC_ATTRIBUTE_SENTRY_SOURCE,
  setHttpStatus,
  spanToJSON,
  startSpan,
  winterCGRequestToRequestData,
  withIsolationScope,
} from '@sentry/core';
import { DEBUG_BUILD } from '../utils/debug-build';
import { createRoutes, getTransactionName } from '../utils/utils';
import { extractData, isResponse, json } from '../utils/vendor/response';
import { captureRemixServerException, errorHandleDataFunction, errorHandleDocumentRequestFunction } from './errors';

type AppData = unknown;
type RemixRequest = Parameters<RequestHandler>[0];
type ServerRouteManifest = ServerBuild['routes'];
type DataFunction = LoaderFunction | ActionFunction;
type DataFunctionArgs = LoaderFunctionArgs | ActionFunctionArgs;

const redirectStatusCodes = new Set([301, 302, 303, 307, 308]);
function isRedirectResponse(response: Response): boolean {
  return redirectStatusCodes.has(response.status);
}

function isCatchResponse(response: Response): boolean {
  return response.headers.get('X-Remix-Catch') != null;
}

/**
 * Sentry utility to be used in place of `handleError` function of Remix v2
 * Remix Docs: https://remix.run/docs/en/main/file-conventions/entry.server#handleerror
 *
 * Should be used in `entry.server` like:
 *
 * export const handleError = Sentry.sentryHandleError
 */
export function sentryHandleError(err: unknown, { request }: DataFunctionArgs): void {
  // We are skipping thrown responses here as they are handled by
  // `captureRemixServerException` at loader / action level
  // We don't want to capture them twice.
  // This function is only for capturing unhandled server-side exceptions.
  // https://remix.run/docs/en/main/file-conventions/entry.server#thrown-responses
  if (isResponse(err) || isRouteErrorResponse(err)) {
    return;
  }

  captureRemixServerException(err, 'remix.server.handleError', request).then(null, e => {
    DEBUG_BUILD && debug.warn('Failed to capture Remix Server exception.', e);
  });
}

/**
 * Sentry wrapper for Remix's `handleError` function.
 * Remix Docs: https://remix.run/docs/en/main/file-conventions/entry.server#handleerror
 */
export function wrapHandleErrorWithSentry(
  origHandleError: (err: unknown, args: { request: unknown }) => void,
): (err: unknown, args: { request: unknown }) => void {
  return function (this: unknown, err: unknown, args: { request: unknown }): void {
    // This is expected to be void but just in case it changes in the future.
    const res = origHandleError.call(this, err, args);

    sentryHandleError(err, args as DataFunctionArgs);

    return res;
  };
}

function isCloudflareEnv(): boolean {
  // eslint-disable-next-line no-restricted-globals
  return navigator?.userAgent?.includes('Cloudflare');
}

function getTraceAndBaggage(): {
  sentryTrace?: string;
  sentryBaggage?: string;
} {
  if (isNodeEnv() || isCloudflareEnv()) {
    const traceData = getTraceData();

    return {
      sentryTrace: traceData['sentry-trace'],
      sentryBaggage: traceData.baggage,
    };
  }

  return {};
}

function makeWrappedDocumentRequestFunction(instrumentTracing?: boolean) {
  return function (origDocumentRequestFunction: HandleDocumentRequestFunction): HandleDocumentRequestFunction {
    return async function (
      this: unknown,
      request: Request,
      responseStatusCode: number,
      responseHeaders: Headers,
      context: EntryContext,
      loadContext?: Record<string, unknown>,
    ): Promise<Response> {
      const documentRequestContext = {
        request,
        responseStatusCode,
        responseHeaders,
        context,
        loadContext,
      };

      if (instrumentTracing) {
        const activeSpan = getActiveSpan();
        const rootSpan = activeSpan && getRootSpan(activeSpan);

        const name = rootSpan ? spanToJSON(rootSpan).description : undefined;

        return startSpan(
          {
            // If we don't have a root span, `onlyIfParent` will lead to the span not being created anyhow
            // So we don't need to care too much about the fallback name, it's just for typing purposes....
            name: name || '<unknown>',
            onlyIfParent: true,
            attributes: {
              method: request.method,
              url: request.url,
              [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.remix',
              [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'function.remix.document_request',
            },
          },
          () => {
            return errorHandleDocumentRequestFunction.call(this, origDocumentRequestFunction, documentRequestContext);
          },
        );
      } else {
        return errorHandleDocumentRequestFunction.call(this, origDocumentRequestFunction, documentRequestContext);
      }
    };
  };
}

function makeWrappedDataFunction(
  origFn: DataFunction,
  id: string,
  name: 'action' | 'loader',
  instrumentTracing?: boolean,
): DataFunction {
  return async function (this: unknown, args: DataFunctionArgs): Promise<Response | AppData> {
    if (instrumentTracing) {
      return startSpan(
        {
          op: `function.remix.${name}`,
          name: id,
          attributes: {
            [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.remix',
            name,
          },
        },
        (span: Span) => {
          return errorHandleDataFunction.call(this, origFn, name, args, span);
        },
      );
    } else {
      return errorHandleDataFunction.call(this, origFn, name, args);
    }
  };
}

const makeWrappedAction =
  (id: string, instrumentTracing?: boolean) =>
  (origAction: DataFunction): DataFunction => {
    return makeWrappedDataFunction(origAction, id, 'action', instrumentTracing);
  };

const makeWrappedLoader =
  (id: string, instrumentTracing?: boolean) =>
  (origLoader: DataFunction): DataFunction => {
    return makeWrappedDataFunction(origLoader, id, 'loader', instrumentTracing);
  };

function makeWrappedRootLoader() {
  return function (origLoader: DataFunction): DataFunction {
    return async function (this: unknown, args: DataFunctionArgs): Promise<Response | AppData> {
      const res = await origLoader.call(this, args);
      const traceAndBaggage = getTraceAndBaggage();

      if (isDeferredData(res)) {
        res.data['sentryTrace'] = traceAndBaggage.sentryTrace;
        res.data['sentryBaggage'] = traceAndBaggage.sentryBaggage;

        return res;
      }

      if (isResponse(res)) {
        // Note: `redirect` and `catch` responses do not have bodies to extract.
        // We skip injection of trace and baggage in those cases.
        // For `redirect`, a valid internal redirection target will have the trace and baggage injected.
        if (isRedirectResponse(res) || isCatchResponse(res)) {
          DEBUG_BUILD && debug.warn('Skipping injection of trace and baggage as the response does not have a body');
          return res;
        } else {
          const data = await extractData(res);

          if (typeof data === 'object') {
            return json(
              { ...data, ...traceAndBaggage },
              {
                headers: res.headers,
                statusText: res.statusText,
                status: res.status,
              },
            );
          } else {
            DEBUG_BUILD && debug.warn('Skipping injection of trace and baggage as the response body is not an object');
            return res;
          }
        }
      }

      return { ...res, ...traceAndBaggage };
    };
  };
}

function wrapRequestHandler<T extends ServerBuild | (() => ServerBuild | Promise<ServerBuild>)>(
  origRequestHandler: RequestHandler,
  build: T,
  options?: {
    instrumentTracing?: boolean;
  },
): RequestHandler {
  let resolvedBuild: ServerBuild | { build: ServerBuild };
  let name: string;
  let source: TransactionSource;

  return async function (this: unknown, request: RemixRequest, loadContext?: AppLoadContext): Promise<Response> {
    const upperCaseMethod = request.method.toUpperCase();
    // We don't want to wrap OPTIONS and HEAD requests
    if (upperCaseMethod === 'OPTIONS' || upperCaseMethod === 'HEAD') {
      return origRequestHandler.call(this, request, loadContext);
    }

    let resolvedRoutes: AgnosticRouteObject[] | undefined;

    if (options?.instrumentTracing) {
      if (typeof build === 'function') {
        resolvedBuild = await build();
      } else {
        resolvedBuild = build;
      }

      // check if the build is nested under `build` key
      if ('build' in resolvedBuild) {
        resolvedRoutes = createRoutes((resolvedBuild.build as ServerBuild).routes);
      } else {
        resolvedRoutes = createRoutes(resolvedBuild.routes);
      }
    }

    return withIsolationScope(async isolationScope => {
      const clientOptions = getClient()?.getOptions();

      let normalizedRequest: RequestEventData = {};

      try {
        normalizedRequest = winterCGRequestToRequestData(request);
      } catch {
        DEBUG_BUILD && debug.warn('Failed to normalize Remix request');
      }

      if (options?.instrumentTracing && resolvedRoutes) {
        const url = new URL(request.url);
        [name, source] = getTransactionName(resolvedRoutes, url);

        isolationScope.setTransactionName(name);
      }

      isolationScope.setSDKProcessingMetadata({ normalizedRequest });

      if (!clientOptions || !hasSpansEnabled(clientOptions)) {
        return origRequestHandler.call(this, request, loadContext);
      }

      return continueTrace(
        {
          sentryTrace: request.headers.get('sentry-trace') || '',
          baggage: request.headers.get('baggage') || '',
        },
        async () => {
          if (options?.instrumentTracing) {
            const parentSpan = getActiveSpan();
            const rootSpan = parentSpan && getRootSpan(parentSpan);
            rootSpan?.updateName(name);

            return startSpan(
              {
                name,
                attributes: {
                  [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.remix',
                  [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: source,
                  [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'http.server',
                  method: request.method,
                },
              },
              async span => {
                const res = (await origRequestHandler.call(this, request, loadContext)) as Response;

                if (isResponse(res)) {",1
"import type { Span } from '@sentry/core';
import {
  continueTrace,
  debug,
  flushIfServerless,
  getCurrentScope,
  getDefaultIsolationScope,
  getIsolationScope,
  getTraceMetaTags,
  SEMANTIC_ATTRIBUTE_SENTRY_OP,
  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,
  SEMANTIC_ATTRIBUTE_SENTRY_SOURCE,
  setHttpStatus,
  spanToJSON,
  startSpan,
  updateSpanName,
  winterCGRequestToRequestData,
  withIsolationScope,
} from '@sentry/core';
import type { Handle, ResolveOptions } from '@sveltejs/kit';
import { DEBUG_BUILD } from '../common/debug-build';
import { getTracePropagationData, sendErrorToSentry } from './utils';

export type SentryHandleOptions = {
  /**
   * Controls whether the SDK should capture errors and traces in requests that don't belong to a
   * route defined in your SvelteKit application.
   *
   * By default, this option is set to `false` to reduce noise (e.g. bots sending random requests to your server).
   *
   * Set this option to `true` if you want to monitor requests events without a route. This might be useful in certain
   * scenarios, for instance if you registered other handlers that handle these requests.
   * If you set this option, you might want adjust the the transaction name in the `beforeSendTransaction`
   * callback of your server-side `Sentry.init` options. You can also use `beforeSendTransaction` to filter out
   * transactions that you still don't want to be sent to Sentry.
   *
   * @default false
   */
  handleUnknownRoutes?: boolean;

  /**
   * Controls if `sentryHandle` should inject a script tag into the page that enables instrumentation
   * of `fetch` calls in `load` functions.
   *
   * @default true
   */
  injectFetchProxyScript?: boolean;
};

export const FETCH_PROXY_SCRIPT = `
    const f = window.fetch;
    if(f){
      window._sentryFetchProxy = function(...a){return f(...a)}
      window.fetch = function(...a){return window._sentryFetchProxy(...a)}
    }
`;
/**
 * Adds Sentry tracing <meta> tags to the returned html page.
 * Adds Sentry fetch proxy script to the returned html page if enabled in options.
 *
 * Exported only for testing
 */
export function addSentryCodeToPage(options: {
  injectFetchProxyScript: boolean;
}): NonNullable<ResolveOptions['transformPageChunk']> {
  return ({ html }) => {
    const metaTags = getTraceMetaTags();
    const headWithMetaTags = metaTags ? `<head>\n${metaTags}` : '<head>';

    const headWithFetchScript = options.injectFetchProxyScript ? `\n<script>${FETCH_PROXY_SCRIPT}</script>` : '';

    const modifiedHead = `${headWithMetaTags}${headWithFetchScript}`;

    return html.replace('<head>', modifiedHead);
  };
}

/**
 * We only need to inject the fetch proxy script for SvelteKit versions < 2.16.0.
 * Exported only for testing.
 */
export function isFetchProxyRequired(version: string): boolean {
  try {
    const [major, minor] = version.trim().replace(/-.*/, '').split('.').map(Number);
    if (major != null && minor != null && (major > 2 || (major === 2 && minor >= 16))) {
      return false;
    }
  } catch {
    // ignore
  }
  return true;
}

interface BackwardsForwardsCompatibleEvent {
  /**
   * For now taken from: https://github.com/sveltejs/kit/pull/13899
   * Access to spans for tracing. If tracing is not enabled or the function is being run in the browser, these spans will do nothing.
   * @since 2.31.0
   */
  tracing?: {
    /** Whether tracing is enabled. */
    enabled: boolean;
    current: Span;
    root: Span;
  };
}

async function instrumentHandle(
  {
    event,
    resolve,
  }: {
    event: Parameters<Handle>[0]['event'] & BackwardsForwardsCompatibleEvent;
    resolve: Parameters<Handle>[0]['resolve'];
  },
  options: SentryHandleOptions,
): Promise<Response> {
  const routeId = event.route?.id;

  if (!routeId && !options.handleUnknownRoutes) {
    return resolve(event);
  }

  // caching the result of the version check in `options.injectFetchProxyScript`
  // to avoid doing the dynamic import on every request
  if (options.injectFetchProxyScript == null) {
    try {
      // @ts-expect-error - the dynamic import is fine here
      const { VERSION } = await import('@sveltejs/kit');
      options.injectFetchProxyScript = isFetchProxyRequired(VERSION);
    } catch {
      options.injectFetchProxyScript = true;
    }
  }

  const routeName = `${event.request.method} ${routeId || event.url.pathname}`;

  if (getIsolationScope() !== getDefaultIsolationScope()) {
    getIsolationScope().setTransactionName(routeName);
  } else {
    DEBUG_BUILD && debug.warn('Isolation scope is default isolation scope - skipping setting transactionName');
  }

  // We only start a span if SvelteKit's native tracing is not enabled. Two reasons:
  // - Used Kit version doesn't yet support tracing
  // - Users didn't enable tracing
  const kitTracingEnabled = event.tracing?.enabled;

  try {
    const resolveWithSentry: (sentrySpan?: Span) => Promise<Response> = async (sentrySpan?: Span) => {
      getCurrentScope().setSDKProcessingMetadata({
        // We specifically avoid cloning the request here to avoid double read errors.
        // We only read request headers so we're not consuming the body anyway.
        // Note to future readers: This sounds counter-intuitive but please read
        // https://github.com/getsentry/sentry-javascript/issues/14583
        normalizedRequest: winterCGRequestToRequestData(event.request),
      });
      const kitRootSpan = event.tracing?.enabled ? event.tracing?.root : undefined;

      if (kitRootSpan) {
        // Update the root span emitted from SvelteKit to resemble a `http.server` span
        // We're doing this here instead of an event processor to ensure we update the
        // span name as early as possible (for dynamic sampling, et al.)
        // Other spans are enhanced in the `processKitSpans` integration.
        const spanJson = spanToJSON(kitRootSpan);
        const kitRootSpanAttributes = spanJson.data;
        const originalName = spanJson.description;

        const routeName = kitRootSpanAttributes['http.route'];
        if (routeName && typeof routeName === 'string') {
          updateSpanName(kitRootSpan, `${event.request.method ?? 'GET'} ${routeName}`);
        }

        kitRootSpan.setAttributes({
          [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'http.server',
          [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.sveltekit',
          [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: routeName ? 'route' : 'url',
          'sveltekit.tracing.original_name': originalName,
        });
      }

      const res = await resolve(event, {
        transformPageChunk: addSentryCodeToPage({
          injectFetchProxyScript: options.injectFetchProxyScript ?? true,
        }),
      });

      if (sentrySpan) {
        setHttpStatus(sentrySpan, res.status);
      }

      return res;
    };

    const resolveResult = kitTracingEnabled
      ? await resolveWithSentry()
      : await startSpan(
          {
            op: 'http.server',
            attributes: {
              [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.sveltekit',
              [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: routeId ? 'route' : 'url',
              'http.method': event.request.method,
            },
            name: routeName,
          },
          resolveWithSentry,
        );
",1
"import { NextRequest } from 'next/server';
import { WORKOS_CLIENT_ID } from './env-variables.js';
import { HandleAuthOptions } from './interfaces.js';
import { saveSession } from './session.js';
import { errorResponseWithFallback, redirectWithFallback } from './utils.js';
import { getWorkOS } from './workos.js';

function handleState(state: string | null) {
  let returnPathname: string | undefined = undefined;
  let userState: string | undefined;
  if (state?.includes('.')) {
    const [internal, ...rest] = state.split('.');
    userState = rest.join('.');
    try {
      // Reverse URL-safe base64 encoding
      const decoded = internal.replace(/-/g, '+').replace(/_/g, '/');
      returnPathname = JSON.parse(atob(decoded)).returnPathname;
    } catch {
      // Malformed internal part, ignore it
    }
  } else if (state) {
    try {
      const decoded = JSON.parse(atob(state));
      if (decoded.returnPathname) {
        returnPathname = decoded.returnPathname;
      } else {
        userState = state;
      }
    } catch {
      userState = state;
    }
  }
  return {
    returnPathname,
    state: userState,
  };
}

export function handleAuth(options: HandleAuthOptions = {}) {
  const { returnPathname: returnPathnameOption = '/', baseURL, onSuccess, onError } = options;

  // Throw early if baseURL is provided but invalid
  if (baseURL) {
    try {
      new URL(baseURL);
    } catch (error) {
      throw new Error(`Invalid baseURL: ${baseURL}`, { cause: error });
    }
  }

  return async function GET(request: NextRequest) {
    const code = request.nextUrl.searchParams.get('code');
    const state = request.nextUrl.searchParams.get('state');

    const { state: customState, returnPathname: returnPathnameState } = handleState(state);

    if (code) {
      try {
        // Use the code returned to us by AuthKit and authenticate the user with WorkOS
        const { accessToken, refreshToken, user, impersonator, oauthTokens, authenticationMethod, organizationId } =
          await getWorkOS().userManagement.authenticateWithCode({
            clientId: WORKOS_CLIENT_ID,
            code,
          });

        // If baseURL is provided, use it instead of request.nextUrl
        // This is useful if the app is being run in a container like docker where
        // the hostname can be different from the one in the request
        const url = baseURL ? new URL(baseURL) : request.nextUrl.clone();

        // Cleanup params
        url.searchParams.delete('code');
        url.searchParams.delete('state');

        // Redirect to the requested path and store the session
        const returnPathname = returnPathnameState ?? returnPathnameOption;

        // Extract the search params if they are present
        if (returnPathname.includes('?')) {
          const newUrl = new URL(returnPathname, 'https://example.com');
          url.pathname = newUrl.pathname;

          for (const [key, value] of newUrl.searchParams) {
            url.searchParams.append(key, value);
          }
        } else {
          url.pathname = returnPathname;
        }

        // Fall back to standard Response if NextResponse is not available.
        // This is to support Next.js 13.
        const response = redirectWithFallback(url.toString());

        if (!accessToken || !refreshToken) throw new Error('response is missing tokens');

        await saveSession({ accessToken, refreshToken, user, impersonator }, request);

        if (onSuccess) {
          await onSuccess({
            accessToken,
            refreshToken,
            user,
            impersonator,
            oauthTokens,
            authenticationMethod,
            organizationId,
            state: customState,
          });
        }

        return response;
      } catch (error) {
        const errorRes = {
          error: error instanceof Error ? error.message : String(error),
        };

        console.error(errorRes);

        return errorResponse(request, error);
      }
    }

    return errorResponse(request);
  };

  function errorResponse(request: NextRequest, error?: unknown) {
    if (onError) {
      return onError({ error, request });
    }

    return errorResponseWithFallback({
      error: {
        message: 'Something went wrong',
        description: ""Couldn't sign in. If you are not sure what happened, please contact your organization admin."",
      },
    });
  }
}",1
"      nextHeaders.delete('x-workos-middleware');
      nextHeaders.set('x-url', 'https://example.com/');

      await expect(async () => {
        await withAuth();
      }).rejects.toThrow(
        ""You are calling 'withAuth' on https://example.com/ that isn’t covered by the AuthKit middleware. Make sure it is running on all paths you are calling 'withAuth' from by updating your middleware config in 'middleware.(js|ts)'."",
      );
    });

    it('should throw an error if the route is not covered by the middleware and there is no URL in the headers', async () => {
      const nextHeaders = await headers();
      nextHeaders.delete('x-workos-middleware');

      await expect(async () => {
        await withAuth({ ensureSignedIn: true });
      }).rejects.toThrow(
        ""You are calling 'withAuth' on a route that isn’t covered by the AuthKit middleware. Make sure it is running on all paths you are calling 'withAuth' from by updating your middleware config in 'middleware.(js|ts)'."",
      );
    });

    it('should throw an error if the URL is not found in the headers', async () => {
      const nextHeaders = await headers();
      nextHeaders.delete('x-url');
",1
"  UserInfo,
} from './interfaces.js';
import { getWorkOS } from './workos.js';

import type { AuthenticationResponse } from '@workos-inc/node';
import { parse, tokensToRegexp } from 'path-to-regexp';
import { lazy, redirectWithFallback } from './utils.js';

const sessionHeaderName = 'x-workos-session';
const middlewareHeaderName = 'x-workos-middleware';
const signUpPathsHeaderName = 'x-sign-up-paths';
const jwtCookieName = 'workos-access-token';

const JWKS = lazy(() => createRemoteJWKSet(new URL(getWorkOS().userManagement.getJwksUrl(WORKOS_CLIENT_ID))));

/**
 * Determines if a request is for an initial document load (not API/RSC/prefetch)
 */
function isInitialDocumentRequest(request: NextRequest): boolean {
  const accept = request.headers.get('accept') || '';
  const isDocumentRequest = accept.includes('text/html');
  const isRSCRequest = request.headers.has('RSC') || request.headers.has('Next-Router-State-Tree');
  const isPrefetch =
    request.headers.get('Purpose') === 'prefetch' ||
    request.headers.get('Sec-Purpose') === 'prefetch' ||
    request.headers.has('Next-Router-Prefetch');

  return isDocumentRequest && !isRSCRequest && !isPrefetch;
}

async function encryptSession(session: Session) {
  return sealData(session, {
    password: WORKOS_COOKIE_PASSWORD,
    ttl: 0,
  });
}

async function updateSessionMiddleware(
  request: NextRequest,
  debug: boolean,
  middlewareAuth: AuthkitMiddlewareAuth,
  redirectUri: string,
  signUpPaths: string[],
  eagerAuth = false,
) {
  if (!redirectUri && !WORKOS_REDIRECT_URI) {
    throw new Error('You must provide a redirect URI in the AuthKit middleware or in the environment variables.');
  }

  if (!WORKOS_COOKIE_PASSWORD || WORKOS_COOKIE_PASSWORD.length < 32) {
    throw new Error(
      'You must provide a valid cookie password that is at least 32 characters in the environment variables.',
    );
  }

  let url;

  if (redirectUri) {
    url = new URL(redirectUri);
  } else {
    url = new URL(WORKOS_REDIRECT_URI);
  }

  if (
    middlewareAuth.enabled &&
    url.pathname === request.nextUrl.pathname &&
    !middlewareAuth.unauthenticatedPaths.includes(url.pathname)
  ) {
    // In the case where:
    // - We're using middleware auth mode
    // - The redirect URI is in the middleware matcher
    // - The redirect URI isn't in the unauthenticatedPaths array
    //
    // then we would get stuck in a login loop due to the redirect happening before the session is set.
    // It's likely that the user accidentally forgot to add the path to unauthenticatedPaths, so we add it here.
    middlewareAuth.unauthenticatedPaths.push(url.pathname);
  }

  const matchedPaths: string[] = middlewareAuth.unauthenticatedPaths.filter((pathGlob) => {
    const pathRegex = getMiddlewareAuthPathRegex(pathGlob);

    return pathRegex.exec(request.nextUrl.pathname);
  });

  const { session, headers, authorizationUrl } = await updateSession(request, {
    debug,
    redirectUri,
    screenHint: getScreenHint(signUpPaths, request.nextUrl.pathname),
    eagerAuth,
  });

  // If the user is logged out and this path isn't on the allowlist for logged out paths, redirect to AuthKit.
  if (middlewareAuth.enabled && matchedPaths.length === 0 && !session.user) {
    if (debug) {
      console.log(`Unauthenticated user on protected route ${request.url}, redirecting to AuthKit`);
    }

    return redirectWithFallback(authorizationUrl as string, headers);
  }

  // Record the sign up paths so we can use them later
  if (signUpPaths.length > 0) {
    headers.set(signUpPathsHeaderName, signUpPaths.join(','));
  }

  return NextResponse.next({
    headers,
  });
}

async function updateSession(
  request: NextRequest,
  options: AuthkitOptions = { debug: false },
): Promise<AuthkitResponse> {
  const session = await getSessionFromCookie(request);

  // Since we're setting the headers in the response, we need to create a new Headers object without copying
  // the request headers.
  // See https://github.com/vercel/next.js/issues/50659#issuecomment-2333990159
  const newRequestHeaders = new Headers();

  // Record that the request was routed through the middleware so we can check later for DX purposes
  newRequestHeaders.set(middlewareHeaderName, 'true');

  // We store the current request url in a custom header, so we can always have access to it
  // This is because on hard navigations we don't have access to `next-url` but need to get the current
  // `pathname` to be able to return the users where they came from before sign-in
  newRequestHeaders.set('x-url', request.url);

  if (options.redirectUri) {
    // Store the redirect URI in a custom header, so we always have access to it and so that subsequent
    // calls to `getAuthorizationUrl` will use the same redirect URI
    newRequestHeaders.set('x-redirect-uri', options.redirectUri);
  }

  newRequestHeaders.delete(sessionHeaderName);

  if (!session) {
    if (options.debug) {
      console.log('No session found from cookie');
    }

    return {
      session: { user: null },
      headers: newRequestHeaders,
      authorizationUrl: await getAuthorizationUrl({
        returnPathname: getReturnPathname(request.url),
        redirectUri: options.redirectUri || WORKOS_REDIRECT_URI,
        screenHint: options.screenHint,
      }),
    };
  }

  const hasValidSession = await verifyAccessToken(session.accessToken);

  const cookieName = WORKOS_COOKIE_NAME || 'wos-session';

  if (hasValidSession) {
    newRequestHeaders.set(sessionHeaderName, request.cookies.get(cookieName)!.value);

    const {
      sid: sessionId,
      org_id: organizationId,
      role,
      roles,
      permissions,
      entitlements,
      feature_flags: featureFlags,
    } = decodeJwt<AccessToken>(session.accessToken);

    // Set JWT cookie if eagerAuth is enabled
    // Only set on document requests (initial page loads), not on API/RSC requests
    if (options.eagerAuth && isInitialDocumentRequest(request)) {
      const existingJwtCookie = request.cookies.get(jwtCookieName);
      // Only set if cookie doesn't exist or has different value
      if (!existingJwtCookie || existingJwtCookie.value !== session.accessToken) {
        newRequestHeaders.append('Set-Cookie', getJwtCookie(session.accessToken, request.url));
      }
    }

    return {
      session: {
        sessionId,
        user: session.user,
        organizationId,
        role,
        roles,
        permissions,
        entitlements,
        featureFlags,
        impersonator: session.impersonator,
        accessToken: session.accessToken,
      },
      headers: newRequestHeaders,
    };
  }

  try {
    if (options.debug) {
      // istanbul ignore next
      console.log(
        `Session invalid. ${session.accessToken ? `Refreshing access token that ends in ${session.accessToken.slice(-10)}` : 'Access token missing.'}`,
      );
    }

    const { org_id: organizationIdFromAccessToken } = decodeJwt<AccessToken>(session.accessToken);

    const { accessToken, refreshToken, user, impersonator } =
      await getWorkOS().userManagement.authenticateWithRefreshToken({
        clientId: WORKOS_CLIENT_ID,
        refreshToken: session.refreshToken,
        organizationId: organizationIdFromAccessToken,
      });

    if (options.debug) {
      console.log('Session successfully refreshed');
    }
    // Encrypt session with new access and refresh tokens
    const encryptedSession = await encryptSession({
      accessToken,
      refreshToken,
      user,
      impersonator,
    });

    newRequestHeaders.append('Set-Cookie', `${cookieName}=${encryptedSession}; ${getCookieOptions(request.url, true)}`);
    newRequestHeaders.set(sessionHeaderName, encryptedSession);

    // Set JWT cookie if eagerAuth is enabled
    // Only set on document requests (initial page loads), not on API/RSC requests
    if (options.eagerAuth && isInitialDocumentRequest(request)) {
      newRequestHeaders.append('Set-Cookie', getJwtCookie(accessToken, request.url));
    }

    const {
      sid: sessionId,
      org_id: organizationId,
      role,
      roles,
      permissions,
      entitlements,
      feature_flags: featureFlags,
    } = decodeJwt<AccessToken>(accessToken);

    options.onSessionRefreshSuccess?.({ accessToken, user, impersonator, organizationId });

    return {
      session: {
        sessionId,
        user,
        organizationId,
        role,
        roles,
        permissions,
        entitlements,
        featureFlags,
        impersonator,
        accessToken,
      },
      headers: newRequestHeaders,
    };
  } catch (e) {
    if (options.debug) {
      console.log('Failed to refresh. Deleting cookie.', e);
    }

    // When we need to delete a cookie, return it as a header as you can't delete cookies from edge middleware
    const deleteCookie = `${cookieName}=; Expires=${new Date(0).toUTCString()}; ${getCookieOptions(request.url, true, true)}`;
    newRequestHeaders.append('Set-Cookie', deleteCookie);

    // Delete JWT cookie if eagerAuth is enabled
    if (options.eagerAuth) {
      const deleteJwtCookie = getJwtCookie(null, request.url, true);
      newRequestHeaders.append('Set-Cookie', deleteJwtCookie);
    }

    options.onSessionRefreshError?.({ error: e, request });

    return {
      session: { user: null },
      headers: newRequestHeaders,
      authorizationUrl: await getAuthorizationUrl({
        returnPathname: getReturnPathname(request.url),
        redirectUri: options.redirectUri || WORKOS_REDIRECT_URI,
      }),
    };
  }
}

async function refreshSession(options: { organizationId?: string; ensureSignedIn: true }): Promise<UserInfo>;
async function refreshSession(options?: {
  organizationId?: string;
  ensureSignedIn?: boolean;
}): Promise<UserInfo | NoUserInfo>;
async function refreshSession({
  organizationId: nextOrganizationId,
  ensureSignedIn = false,
}: {
  organizationId?: string;
  ensureSignedIn?: boolean;
} = {}): Promise<UserInfo | NoUserInfo> {
  const session = await getSessionFromCookie();
  if (!session) {
    if (ensureSignedIn) {
      await redirectToSignIn();
    }
    return { user: null };
  }

  const { org_id: organizationIdFromAccessToken } = decodeJwt<AccessToken>(session.accessToken);

  let refreshResult;

  try {
    refreshResult = await getWorkOS().userManagement.authenticateWithRefreshToken({
      clientId: WORKOS_CLIENT_ID,
      refreshToken: session.refreshToken,
      organizationId: nextOrganizationId ?? organizationIdFromAccessToken,
    });
  } catch (error) {
    throw new Error(`Failed to refresh session: ${error instanceof Error ? error.message : String(error)}`, {
      cause: error,
    });
  }

  const headersList = await headers();
  const url = headersList.get('x-url');

  await saveSession(refreshResult, url || WORKOS_REDIRECT_URI);

  const { accessToken, user, impersonator } = refreshResult;

  const {
    sid: sessionId,
    org_id: organizationId,
    role,
    roles,
    permissions,
    entitlements,
    feature_flags: featureFlags,
  } = decodeJwt<AccessToken>(accessToken);

  return {
    sessionId,
    user,
    organizationId,
    role,
    roles,
    permissions,
    entitlements,
    featureFlags,
    impersonator,
    accessToken,
  };
}

function getMiddlewareAuthPathRegex(pathGlob: string) {
  try {
    const url = new URL(pathGlob, 'https://example.com');
    const path = `${url.pathname!}${url.hash || ''}`;

    const tokens = parse(path);
    const regex = tokensToRegexp(tokens).source;

    return new RegExp(regex);
  } catch (err) {
    console.log('err', err);
    const message = err instanceof Error ? err.message : String(err);

    throw new Error(`Error parsing routes for middleware auth. Reason: ${message}`);
  }
}

async function redirectToSignIn() {
  const headersList = await headers();
  const url = headersList.get('x-url');

  if (!url) {
    throw new Error('No URL found in the headers');
  }

  // Determine if the current route is in the sign up paths
  const signUpPaths = headersList.get(signUpPathsHeaderName)?.split(',');

  const pathname = new URL(url).pathname;
  const screenHint = getScreenHint(signUpPaths, pathname);

  const returnPathname = getReturnPathname(url);

  redirect(await getAuthorizationUrl({ returnPathname, screenHint }));
}

export async function getTokenClaims<T = Record<string, unknown>>(
  accessToken?: string,
): Promise<Partial<JWTPayload & T>> {
  const token = accessToken ?? (await withAuth()).accessToken;
  if (!token) {
    return {};
  }

  return decodeJwt<T>(token);
}

async function withAuth(options: { ensureSignedIn: true }): Promise<UserInfo>;
async function withAuth(options?: { ensureSignedIn?: true | false }): Promise<UserInfo | NoUserInfo>;
async function withAuth(options?: { ensureSignedIn?: boolean }): Promise<UserInfo | NoUserInfo> {
  const session = await getSessionFromHeader();

  if (!session) {
    if (options?.ensureSignedIn) {
      await redirectToSignIn();
    }
    return { user: null };
  }

  const {
    sid: sessionId,
    org_id: organizationId,
    role,
    roles,
    permissions,
    entitlements,
    feature_flags: featureFlags,
  } = decodeJwt<AccessToken>(session.accessToken);

  return {
    sessionId,
    user: session.user,
    organizationId,
    role,
    roles,
    permissions,
    entitlements,
    featureFlags,
    impersonator: session.impersonator,
    accessToken: session.accessToken,
  };
}

async function verifyAccessToken(accessToken: string) {
  try {
    await jwtVerify(accessToken, JWKS());
    return true;
  } catch {
    return false;
  }
}

export async function getSessionFromCookie(request?: NextRequest) {
  const cookieName = WORKOS_COOKIE_NAME || 'wos-session';
  let cookie;

  if (request) {
    cookie = request.cookies.get(cookieName);
  } else {
    const nextCookies = await cookies();
    cookie = nextCookies.get(cookieName);
  }

  if (cookie) {
    return unsealData<Session>(cookie.value, {
      password: WORKOS_COOKIE_PASSWORD,
    });
  }
}

async function getSessionFromHeader(): Promise<Session | undefined> {
  const headersList = await headers();
  const hasMiddleware = Boolean(headersList.get(middlewareHeaderName));

  if (!hasMiddleware) {
    const url = headersList.get('x-url');
    throw new Error(
      `You are calling 'withAuth' on ${url ?? 'a route'} that isn’t covered by the AuthKit middleware. Make sure it is running on all paths you are calling 'withAuth' from by updating your middleware config in 'middleware.(js|ts)'.`,
    );
  }

  const authHeader = headersList.get(sessionHeaderName);
  if (!authHeader) return;
",1
"import { NextResponse } from 'next/server';

export function redirectWithFallback(redirectUri: string, headers?: Headers) {
  const newHeaders = headers ? new Headers(headers) : new Headers();
  newHeaders.set('Location', redirectUri);

  // Fall back to standard Response if NextResponse is not available.
  // This is to support Next.js 13.",1
"    }
    argv.ext = normalizeExt(argv.ext);
    const { script, scriptPath, tempPath } = yield readScript();
    yield runScript(script, scriptPath, tempPath);
  });
}
var rmrf = (p) => p && import_index.fs.rmSync(p, { force: true, recursive: true });
function runScript(script, scriptPath, tempPath) {
  return __async(this, null, function* () {
    let nmLink = """";
    const rmTemp = () => {
      rmrf(tempPath);
      rmrf(nmLink);
    };
    try {
      if (tempPath) {
        scriptPath = tempPath;
        yield import_index.fs.writeFile(tempPath, script);
      }
      const cwd = import_index.path.dirname(scriptPath);
      if (typeof argv.preferLocal === ""string"") {
        nmLink = linkNodeModules(cwd, argv.preferLocal);
      }
      if (argv.install) {
        yield (0, import_deps.installDeps)((0, import_deps.parseDeps)(script), cwd, argv.registry);
      }
      injectGlobalRequire(scriptPath);
      import_node_process2.default.once(""exit"", rmTemp);",1
"  argv.ext = normalizeExt(argv.ext)

  const { script, scriptPath, tempPath } = await readScript()
  await runScript(script, scriptPath, tempPath)
}

const rmrf = (p: string) => p && fs.rmSync(p, { force: true, recursive: true })
async function runScript(
  script: string,
  scriptPath: string,
  tempPath: string
): Promise<void> {
  let nmLink = ''
  const rmTemp = () => {
    rmrf(tempPath)
    rmrf(nmLink)
  }
  try {
    if (tempPath) {
      scriptPath = tempPath
      await fs.writeFile(tempPath, script)
    }
    const cwd = path.dirname(scriptPath)
    if (typeof argv.preferLocal === 'string') {
      nmLink = linkNodeModules(cwd, argv.preferLocal)
    }
    if (argv.install) {
      await installDeps(parseDeps(script), cwd, argv.registry)
    }

    injectGlobalRequire(scriptPath)
    process.once('exit', rmTemp)

    // TODO: fix unanalyzable-dynamic-import to work correctly with jsr.io
    await import(url.pathToFileURL(scriptPath).toString())
  } finally {
    rmTemp()
  }
}

function linkNodeModules(cwd: string, external: string): string {
  const nm = 'node_modules'
  const alias = path.resolve(cwd, nm)
  const target =
    path.basename(external) === nm
      ? path.resolve(external)
      : path.resolve(external, nm)

  if (fs.existsSync(alias) || !fs.existsSync(target)) return ''

  fs.symlinkSync(target, alias, 'junction')
  return target
}

async function readScript() {
  const [firstArg] = argv._
  let script = ''",1
"			left: '20mm',
		},
	},
	launch_options: {},
	gray_matter_options: {
		engines: {
			js: () =>
				new Error(
					'The JS engine for front-matter is disabled by default for security reasons. You can enable it by configuring gray_matter_options.',
				),
		},
	},
	md_file_encoding: 'utf-8',",1
"	const textContent = await getPdfTextContent(pdf.content);

	t.true(textContent.startsWith('Formulas with MathJax'));
	t.regex(textContent, /a\s≠\s0/);
});

test('the JS engine is disabled by default', async (t) => {
	const css = '`body::before { display: block; content: ""${""i am injected""}""}`'; // eslint-disable-line no-template-curly-in-string

	const pdf = await mdToPdf({ content: `---js\n{ css: ${css} }\n---` });

	const textContent = await getPdfTextContent(pdf.content);

	t.is(textContent, '');
});

test('the JS engine for front-matter can be enabled', async (t) => {
	const css = '`body::before { display: block; content: ""${""i am injected""}""}`'; // eslint-disable-line no-template-curly-in-string

	const pdf = await mdToPdf({ content: `---js\n{ css: ${css} }\n---` }, { gray_matter_options: undefined });

	const textContent = await getPdfTextContent(pdf.content);",1
"		before(async () => {
			fixture = await loadFixture({
				root: './fixtures/core-image/',
				image: {
					service: testImageService({ foo: 'bar' }),
					domains: ['avatars.githubusercontent.com'],
				},
			});

			devServer = await fixture.startDevServer({
				logger: new Logger({
					level: 'error',",1
"import * as assert from 'node:assert/strict';
import { describe, it } from 'node:test';
import {
	matchHostname,
	matchPathname,
	matchPattern,
	matchPort,
	matchProtocol,
} from '@astrojs/internal-helpers/remote';

describe('remote-pattern', () => {
	const url1 = new URL('https://docs.astro.build/en/getting-started');
	const url2 = new URL('http://preview.docs.astro.build:8080/');
	const url3 = new URL('https://astro.build/');
	const url4 = new URL('https://example.co/');

	describe('remote pattern matchers', () => {
		it('matches protocol', async () => {
			// undefined
			assert.equal(matchProtocol(url1), true);

			// defined, true/false
			assert.equal(matchProtocol(url1, 'http'), false);
			assert.equal(matchProtocol(url1, 'https'), true);
		});

		it('matches port', async () => {
			// undefined
			assert.equal(matchPort(url1), true);

			// defined, but port is empty (default port used in URL)
			assert.equal(matchPort(url1, ''), true);

			// defined and port is custom
			assert.equal(matchPort(url2, '8080'), true);
		});

		it('matches hostname (no wildcards)', async () => {
			// undefined
			assert.equal(matchHostname(url1), true);

			// defined, true/false
			assert.equal(matchHostname(url1, 'astro.build'), false);
			assert.equal(matchHostname(url1, 'docs.astro.build'), true);
		});

		it('matches hostname (with wildcards)', async () => {
			// defined, true/false
			assert.equal(matchHostname(url1, 'docs.astro.build', true), true);
			assert.equal(matchHostname(url1, '**.astro.build', true), true);
			assert.equal(matchHostname(url1, '*.astro.build', true), true);

			assert.equal(matchHostname(url2, '*.astro.build', true), false);
			assert.equal(matchHostname(url2, '**.astro.build', true), true);

			assert.equal(matchHostname(url3, 'astro.build', true), true);
			assert.equal(matchHostname(url3, '*.astro.build', true), false);
			assert.equal(matchHostname(url3, '**.astro.build', true), false);
		});

		it('rejects hostname without dots when using single wildcard (*.domain.com)', async () => {
			// hostnames without dots (like localhost) should not match *.astro.build
			const localhostUrl = new URL('http://localhost/');
			assert.equal(matchHostname(localhostUrl, '*.astro.build', true), false);

			const bareHostnameUrl = new URL('http://example/');
			assert.equal(matchHostname(bareHostnameUrl, '*.victim.com', true), false);

			const internalUrl = new URL('http://internal/');
			assert.equal(matchHostname(internalUrl, '*.astro.build', true), false);
		});

		it('matches pathname (no wildcards)', async () => {
			// undefined
			assert.equal(matchPathname(url1), true);

			// defined, true/false
			assert.equal(matchPathname(url1, '/'), false);
			assert.equal(matchPathname(url1, '/en/getting-started'), true);
		});

		it('matches pathname (with wildcards)', async () => {
			// defined, true/false
			assert.equal(matchPathname(url1, '/en/**', true), true);
			assert.equal(matchPathname(url1, '/en/*', true), true);
			assert.equal(matchPathname(url1, '/**', true), true);

			assert.equal(matchPathname(url2, '/**', true), false);
			assert.equal(matchPathname(url2, '/*', true), false);
		});

		it('matches patterns', async () => {
			assert.equal(matchPattern(url1, {}), true);

			assert.equal(
				matchPattern(url1, {
					protocol: 'https',
				}),
				true,
			);

			assert.equal(
				matchPattern(url1, {
					protocol: 'https',
					hostname: '**.astro.build',
				}),
				true,
			);

			assert.equal(
				matchPattern(url1, {
					protocol: 'https',
					hostname: '**.astro.build',
					pathname: '/en/**',
				}),
				true,
			);

			assert.equal(
				matchPattern(url4, {
					protocol: 'https',
					hostname: 'example.com',
				}),
				false,
			);
		});
	});
});",1
"	if (!URL.canParse(src)) {
		return false;
	}

	const url = new URL(src);

	// Data URLs are always allowed
	if (url.protocol === 'data:') {
		return true;
	}

	// Non-http(s) protocols are never allowed
	if (!['http:', 'https:'].includes(url.protocol)) {
		return false;
	}

	return (
		domains.some((domain) => matchHostname(url, domain)) ||
		remotePatterns.some((remotePattern) => matchPattern(url, remotePattern))",1
"		public request: Request,
		public routeData: RouteData,
		public status: number,
		public clientAddress: string | undefined,
		protected cookies = new AstroCookies(request),
		public params = getParams(routeData, pathname),
		protected url = new URL(request.url),
		public props: Props = {},
		public partial: undefined | boolean = undefined,
		public shouldInjectCspMetaTags = !!pipeline.manifest.csp,
		public session: AstroSession | undefined = pipeline.manifest.sessionConfig
			? new AstroSession(cookies, pipeline.manifest.sessionConfig, pipeline.runtimeMode)
			: undefined,
	) {}

	/**
	 * A flag that tells the render content if the rewriting was triggered
	 */
	isRewriting = false;
	/**
	 * A safety net in case of loops
	 */
	counter = 0;

	result: SSRResult | undefined = undefined;

	static async create({
		locals = {},
		middleware,
		pathname,
		pipeline,
		request,
		routeData,
		clientAddress,
		status = 200,
		props,
		partial = undefined,
		actions,
		shouldInjectCspMetaTags,
	}: Pick<RenderContext, 'pathname' | 'pipeline' | 'request' | 'routeData' | 'clientAddress'> &
		Partial<
			Pick<
				RenderContext,
				| 'locals'
				| 'middleware'
				| 'status'
				| 'props'
				| 'partial'
				| 'actions'
				| 'shouldInjectCspMetaTags'
			>
		>): Promise<RenderContext> {
		const pipelineMiddleware = await pipeline.getMiddleware();
		const pipelineActions = actions ?? (await pipeline.getActions());
		setOriginPathname(
			request,
			pathname,
			pipeline.manifest.trailingSlash,
			pipeline.manifest.buildFormat,
		);
		return new RenderContext(
			pipeline,
			locals,
			sequence(...pipeline.internalMiddleware, middleware ?? pipelineMiddleware),
			pipelineActions,
			pathname,
			request,
			routeData,
			status,
			clientAddress,
			undefined,
			undefined,
			undefined,
			props,
			partial,
			shouldInjectCspMetaTags ?? !!pipeline.manifest.csp,
		);
	}
	/**
	 * The main function of the RenderContext.
	 *
	 * Use this function to render any route known to Astro.
	 * It attempts to render a route. A route can be a:
	 *
	 * - page
	 * - redirect
	 * - endpoint
	 * - fallback
	 */
	async render(
		componentInstance: ComponentInstance | undefined,
		slots: Record<string, any> = {},
	): Promise<Response> {
		const { middleware, pipeline } = this;
		const { logger, serverLike, streaming, manifest } = pipeline;

		const props =
			Object.keys(this.props).length > 0
				? this.props
				: await getProps({
						mod: componentInstance,
						routeData: this.routeData,
						routeCache: this.pipeline.routeCache,
						pathname: this.pathname,
						logger,
						serverLike,
						base: manifest.base,
					});
		const actionApiContext = this.createActionAPIContext();
		const apiContext = this.createAPIContext(props, actionApiContext);

		this.counter++;
		if (this.counter === 4) {
			return new Response('Loop Detected', {
				// https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/508
				status: 508,
				statusText:
					'Astro detected a loop where you tried to call the rewriting logic more than four times.',
			});
		}
		const lastNext = async (ctx: APIContext, payload?: RewritePayload) => {
			if (payload) {
				const oldPathname = this.pathname;
				pipeline.logger.debug('router', 'Called rewriting to:', payload);
				// we intentionally let the error bubble up
				const {
					routeData,
					componentInstance: newComponent,
					pathname,
					newUrl,
				} = await pipeline.tryRewrite(payload, this.request);

				// This is a case where the user tries to rewrite from a SSR route to a prerendered route (SSG).
				// This case isn't valid because when building for SSR, the prerendered route disappears from the server output because it becomes an HTML file,
				// so Astro can't retrieve it from the emitted manifest.
				if (
					this.pipeline.serverLike === true &&
					this.routeData.prerender === false &&
					routeData.prerender === true
				) {
					throw new AstroError({
						...ForbiddenRewrite,
						message: ForbiddenRewrite.message(this.pathname, pathname, routeData.component),
						hint: ForbiddenRewrite.hint(routeData.component),
					});
				}

				this.routeData = routeData;
				componentInstance = newComponent;
				if (payload instanceof Request) {
					this.request = payload;
				} else {
					this.request = copyRequest(
						newUrl,
						this.request,
						// need to send the flag of the previous routeData
						routeData.prerender,
						this.pipeline.logger,
						this.routeData.route,
					);
				}
				this.isRewriting = true;
				this.url = new URL(this.request.url);
				this.params = getParams(routeData, pathname);
				this.pathname = pathname;
				this.status = 200;
				setOriginPathname(
					this.request,
					oldPathname,
					this.pipeline.manifest.trailingSlash,
					this.pipeline.manifest.buildFormat,
				);
			}
			let response: Response;

			if (!ctx.isPrerendered) {
				const { action, setActionResult, serializeActionResult } = getActionContext(ctx);

				if (action?.calledFrom === 'form') {
					const actionResult = await action.handler();
					setActionResult(action.name, serializeActionResult(actionResult));
				}
			}

			switch (this.routeData.type) {
				case 'endpoint': {
					response = await renderEndpoint(
						componentInstance as any,
						ctx,
						this.routeData.prerender,
						logger,
					);
					break;
				}
				case 'redirect':
					return renderRedirect(this);
				case 'page': {
					this.result = await this.createResult(componentInstance!, actionApiContext);
					try {
						response = await renderPage(
							this.result,
							componentInstance?.default as any,
							props,
							slots,
							streaming,
							this.routeData,
						);
					} catch (e) {
						// If there is an error in the page's frontmatter or instantiation of the RenderTemplate fails midway,
						// we signal to the rest of the internals that we can ignore the results of existing renders and avoid kicking off more of them.
						this.result.cancelled = true;
						throw e;
					}

					// Signal to the i18n middleware to maybe act on this response
					response.headers.set(ROUTE_TYPE_HEADER, 'page');
					// Signal to the error-page-rerouting infra to let this response pass through to avoid loops
					if (this.routeData.route === '/404' || this.routeData.route === '/500') {
						response.headers.set(REROUTE_DIRECTIVE_HEADER, 'no');
					}
					if (this.isRewriting) {
						response.headers.set(REWRITE_DIRECTIVE_HEADER_KEY, REWRITE_DIRECTIVE_HEADER_VALUE);
					}
					break;
				}
				case 'fallback': {
					return new Response(null, { status: 500, headers: { [ROUTE_TYPE_HEADER]: 'fallback' } });
				}
			}
			// We need to merge the cookies from the response back into this.cookies
			// because they may need to be passed along from a rewrite.
			const responseCookies = getCookiesFromResponse(response);
			if (responseCookies) {
				this.cookies.merge(responseCookies);
			}
			return response;
		};

		// If we are rendering an extrnal redirect, we don't need go through the middleware,
		// otherwise Astro will attempt to render the external website
		if (isRouteExternalRedirect(this.routeData)) {
			return renderRedirect(this);
		}

		const response = await callMiddleware(middleware, apiContext, lastNext);
		if (response.headers.get(ROUTE_TYPE_HEADER)) {
			response.headers.delete(ROUTE_TYPE_HEADER);
		}
		// LEGACY: we put cookies on the response object,
		// where the adapter might be expecting to read it.
		// New code should be using `app.render({ addCookieHeader: true })` instead.
		attachCookiesToResponse(response, this.cookies);
		return response;
	}

	createAPIContext(props: APIContext['props'], context: ActionAPIContext): APIContext {
		const redirect = (path: string, status = 302) =>
			new Response(null, { status, headers: { Location: path } });

		Reflect.set(context, apiContextRoutesSymbol, this.pipeline);

		return Object.assign(context, {
			props,
			redirect,
			getActionResult: createGetActionResult(context.locals),
			callAction: createCallAction(context),
		});
	}

	async #executeRewrite(reroutePayload: RewritePayload) {
		this.pipeline.logger.debug('router', 'Calling rewrite: ', reroutePayload);
		const oldPathname = this.pathname;
		const { routeData, componentInstance, newUrl, pathname } = await this.pipeline.tryRewrite(
			reroutePayload,
			this.request,
		);
		// This is a case where the user tries to rewrite from a SSR route to a prerendered route (SSG).
		// This case isn't valid because when building for SSR, the prerendered route disappears from the server output because it becomes an HTML file,
		// so Astro can't retrieve it from the emitted manifest.
		// Allow i18n fallback rewrites - if the target route has fallback routes, this is likely an i18n scenario
		const isI18nFallback = routeData.fallbackRoutes && routeData.fallbackRoutes.length > 0;
		if (
			this.pipeline.serverLike &&
			!this.routeData.prerender &&
			routeData.prerender &&
			!isI18nFallback
		) {
			throw new AstroError({
				...ForbiddenRewrite,
				message: ForbiddenRewrite.message(this.pathname, pathname, routeData.component),
				hint: ForbiddenRewrite.hint(routeData.component),
			});
		}

		this.routeData = routeData;
		if (reroutePayload instanceof Request) {
			this.request = reroutePayload;
		} else {
			this.request = copyRequest(
				newUrl,
				this.request,
				// need to send the flag of the previous routeData
				routeData.prerender,
				this.pipeline.logger,
				this.routeData.route,
			);
		}
		this.url = new URL(this.request.url);
		const newCookies = new AstroCookies(this.request);
		if (this.cookies) {
			newCookies.merge(this.cookies);
		}
		this.cookies = newCookies;
		this.params = getParams(routeData, pathname);",1
"		// We already have a middleware that checks if there's an incoming URL that has invalid URI, so it's safe
		// to not handle the error: packages/astro/src/vite-plugin-astro-server/base.ts
		pathname = decodeURI(url.pathname);
	}

	// Add config.base back to url before passing it to SSR
	url.pathname = removeTrailingForwardSlash(config.base) + url.pathname;

	// Apply trailing slash configuration consistently
	if (config.trailingSlash === 'never') {
		url.pathname = removeTrailingForwardSlash(url.pathname);
	} else if (config.trailingSlash === 'always' && !hasFileExtension(url.pathname)) {
		url.pathname = appendForwardSlash(url.pathname);",1
"			const data = devalue.parse(await res.text());
			assert.equal(data.success, true);
			assert.equal(data.isFormData, true, 'Should receive plain FormData');
		});

		it('Handles special characters in action names', async () => {
			for (const name of ['with%2Fslash', 'with%20space', 'with%2Edot']) {
				const res = await fixture.fetch(`/_actions/${name}`, {
					method: 'POST',
					body: JSON.stringify({ name: 'ben' }),
					headers: {
						'Content-Type': 'application/json',
					},
				});
				assert.equal(res.ok, true);
				const text = await res.text();
				assert.equal(res.headers.get('Content-Type'), 'application/json+devalue');
				const data = devalue.parse(text);
				assert.equal(data, 'Hello, ben!');
			}
		});

		it('Returns 404 for non-existent action', async () => {
			const res = await fixture.fetch('/_actions/nonExistent', {
				method: 'POST',
				body: JSON.stringify({}),
				headers: {
					'Content-Type': 'application/json',
				},
			});
			assert.equal(res.status, 404);
			const data = await res.json();
			assert.equal(data.code, 'NOT_FOUND');
		});

		it('Should fail when calling an action without using Astro.callAction', async () => {
			const res = await fixture.fetch('/invalid/');
			const text = await res.text();
			assert.match(text, /ActionCalledFromServerError/);
		});
	});

	describe('build', () => {
		let app;

		before(async () => {
			await fixture.build();
			app = await fixture.loadTestAdapterApp();
		});

		it('Exposes subscribe action', async () => {
			const req = new Request('http://example.com/_actions/subscribe', {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json',
				},
				body: JSON.stringify({ channel: 'bholmesdev' }),
			});
			const res = await app.render(req);

			assert.equal(res.ok, true);
			assert.equal(res.headers.get('Content-Type'), 'application/json+devalue');

			const data = devalue.parse(await res.text());
			assert.equal(data.channel, 'bholmesdev');
			assert.equal(data.subscribeButtonState, 'smashed');
		});

		it('Exposes comment action', async () => {
			const formData = new FormData();
			formData.append('channel', 'bholmesdev');
			formData.append('comment', 'Hello, World!');
			const req = new Request('http://example.com/_actions/comment', {
				method: 'POST',
				body: formData,
			});
			const res = await app.render(req);

			assert.equal(res.ok, true);
			assert.equal(res.headers.get('Content-Type'), 'application/json+devalue');

			const data = devalue.parse(await res.text());
			assert.equal(data.channel, 'bholmesdev');
			assert.equal(data.comment, 'Hello, World!');
		});

		it('Raises validation error on bad form data', async () => {
			const formData = new FormData();
			formData.append('channel', 'bholmesdev');
			const req = new Request('http://example.com/_actions/comment', {
				method: 'POST',
				body: formData,
			});
			const res = await app.render(req);

			assert.equal(res.ok, false);
			assert.equal(res.status, 400);
			assert.equal(res.headers.get('Content-Type'), 'application/json');

			const data = await res.json();
			assert.equal(data.type, 'AstroActionInputError');
		});

		it('Exposes plain formData action', async () => {
			const formData = new FormData();
			formData.append('channel', 'bholmesdev');
			formData.append('comment', 'Hello, World!');
			const req = new Request('http://example.com/_actions/commentPlainFormData', {
				method: 'POST',
				body: formData,
			});
			const res = await app.render(req);

			assert.equal(res.ok, true);
			assert.equal(res.headers.get('Content-Type'), 'application/json+devalue');

			const data = devalue.parse(await res.text());
			assert.equal(data.success, true);
			assert.equal(data.isFormData, true, 'Should receive plain FormData');
		});

		it('Response middleware fallback - POST', async () => {
			const req = new Request('http://example.com/user?_action=getUser', {
				method: 'POST',
				body: new FormData(),
				headers: {
					Referer: 'http://example.com/user',
				},
			});
			const res = await app.render(req);
			assert.equal(res.ok, true);

			const html = await res.text();
			let $ = cheerio.load(html);
			assert.equal($('#user').text(), 'Houston');
		});

		it('Response middleware fallback - cookie forwarding', async () => {
			const req = new Request(
				'http://example.com/user?_action=getUser&actionCookieForwarding=true',
				{
					method: 'POST',
					body: new FormData(),
					headers: {
						Referer: 'http://example.com/user',
					},
				},
			);
			const res = await followExpectedRedirect(req, app);
			assert.equal(res.ok, true);

			const html = await res.text();
			let $ = cheerio.load(html);
			assert.equal($('#user').text(), 'Houston');
		});

		it('Respects custom errors - POST', async () => {
			const req = new Request('http://example.com/user-or-throw?_action=getUserOrThrow', {
				method: 'POST',
				body: new FormData(),
				headers: {
					Referer: 'http://example.com/user-or-throw',
				},
			});
			const res = await app.render(req);
			assert.equal(res.status, 401);

			const html = await res.text();
			let $ = cheerio.load(html);
			assert.equal($('#error-message').text(), 'Not logged in');
			assert.equal($('#error-code').text(), 'UNAUTHORIZED');
		});

		it('Respects custom errors - cookie forwarding', async () => {
			const req = new Request(
				'http://example.com/user-or-throw?_action=getUserOrThrow&actionCookieForwarding=true',
				{
					method: 'POST',
					body: new FormData(),
					headers: {
						Referer: 'http://example.com/user-or-throw',
					},
				},
			);
			const res = await followExpectedRedirect(req, app);
			assert.equal(res.status, 401);

			const html = await res.text();
			let $ = cheerio.load(html);
			assert.equal($('#error-message').text(), 'Not logged in');
			assert.equal($('#error-code').text(), 'UNAUTHORIZED');
		});

		it('Respects RPC middleware handling - locked', async () => {
			const req = new Request('http://example.com/_actions/locked', {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json',
				},
				body: '{}',
			});
			const res = await app.render(req);
			assert.equal(res.status, 401);
		});

		it('Respects RPC middleware handling - cookie present', async () => {
			const req = new Request('http://example.com/_actions/locked', {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json',
					Cookie: 'actionCookie=1234',
				},
				body: '{}',
			});
			const res = await app.render(req);
			assert.equal(res.ok, true);
			assert.equal(res.headers.get('Content-Type'), 'application/json+devalue');

			const data = devalue.parse(await res.text());
			assert.equal('safe' in data, true);
		});

		it('Ignores action name for GET requests', async () => {
			const req = new Request('http://example.com/user-or-throw?_action=getUserOrThrow', {
				method: 'GET',
			});
			const res = await app.render(req);
			assert.equal(res.ok, true);

			const html = await res.text();
			let $ = cheerio.load(html);
			assert.ok($('#user'));
		});

		it('Supports effects on form input validators', async () => {
			const formData = new FormData();
			formData.set('password', 'benisawesome');
			formData.set('confirmPassword', 'benisveryawesome');

			const req = new Request('http://example.com/_actions/validatePassword', {
				method: 'POST',
				body: formData,
			});

			const res = await app.render(req);

			assert.equal(res.ok, false);
			assert.equal(res.status, 400);
			assert.equal(res.headers.get('Content-Type'), 'application/json');

			const data = await res.json();
			assert.equal(data.type, 'AstroActionInputError');
			assert.equal(data.issues?.[0]?.message, 'Passwords do not match');
		});

		it('Supports complex chained effects on form input validators', async () => {
			const formData = new FormData();
			formData.set('currentPassword', 'benisboring');
			formData.set('newPassword', 'benisawesome');
			formData.set('confirmNewPassword', 'benisawesome');

			const req = new Request('http://example.com/_actions/validatePasswordComplex', {
				method: 'POST',
				body: formData,
			});

			const res = await app.render(req);

			assert.equal(res.ok, true);
			assert.equal(res.headers.get('Content-Type'), 'application/json+devalue');

			const data = devalue.parse(await res.text());
			assert.equal(Object.keys(data).length, 2, 'More keys than expected');
			assert.deepEqual(data, {
				currentPassword: 'benisboring',
				newPassword: 'benisawesome',
			});
		});

		it('Supports input form data transforms', async () => {
			const formData = new FormData();
			formData.set('name', 'ben');
			formData.set('age', '42');

			const req = new Request('http://example.com/_actions/transformFormInput', {
				method: 'POST',
				body: formData,
			});

			const res = await app.render(req);

			assert.equal(res.ok, true);
			assert.equal(res.headers.get('Content-Type'), 'application/json+devalue');

			const data = devalue.parse(await res.text());
			assert.equal(data?.name, 'ben');
			assert.equal(data?.age, '42');
		});

		it('Sets status to 204 when content-length is 0', async () => {
			const req = new Request('http://example.com/_actions/fireAndForget', {
				method: 'POST',
				headers: {
					'Content-Length': '0',
				},
			});
			const res = await app.render(req);
			assert.equal(res.status, 204);
		});

		it('Sets status to 204 when content-type is omitted', async () => {
			const req = new Request('http://example.com/_actions/fireAndForget', {
				method: 'POST',
			});
			const res = await app.render(req);
			assert.equal(res.status, 204);
		});

		it('Sets status to 415 when content-type is unexpected', async () => {
			const req = new Request('http://example.com/_actions/fireAndForget', {
				method: 'POST',
				body: 'hey',
				headers: {
					'Content-Type': 'text/plain',
				},
			});
			const res = await app.render(req);
			assert.equal(res.status, 415);
		});

		it('Is callable from the server with rewrite', async () => {
			const req = new Request('http://example.com/rewrite');
			const res = await app.render(req);
			assert.equal(res.ok, true);

			const html = await res.text();
			let $ = cheerio.load(html);
			assert.equal($('[data-url]').text(), '/subscribe');
			assert.equal($('[data-channel]').text(), 'bholmesdev');
		});

		it('Returns content when the value is 0', async () => {
			const req = new Request('http://example.com/_actions/zero', {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json',
					'Content-Length': '0',
				},
			});
			const res = await app.render(req);
			assert.equal(res.status, 200);
			const value = devalue.parse(await res.text());
			assert.equal(value, 0);
		});

		it('Returns content when the value is false', async () => {
			const req = new Request('http://example.com/_actions/false', {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json',
					'Content-Length': '0',
				},
			});
			const res = await app.render(req);
			assert.equal(res.status, 200);

			const value = devalue.parse(await res.text());
			assert.equal(value, false);
		});

		it('Supports complex values: Date, Set, URL', async () => {
			const req = new Request('http://example.com/_actions/complexValues', {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json',
					'Content-Length': '0',
				},
			});
			const res = await app.render(req);
			assert.equal(res.status, 200);
			assert.equal(res.headers.get('Content-Type'), 'application/json+devalue');

			const value = devalue.parse(await res.text(), {
				URL: (href) => new URL(href),
			});
			assert.ok(value.date instanceof Date);
			assert.ok(value.set instanceof Set);
		});

		it('Supports discriminated union for different form fields', async () => {
			const formData = new FormData();
			formData.set('type', 'first-chunk');
			formData.set('alt', 'Cool image');
			formData.set('image', new File([''], 'chunk-1.png'));
			const reqFirst = new Request('http://example.com/_actions/imageUploadInChunks', {
				method: 'POST',
				body: formData,
			});

			const resFirst = await app.render(reqFirst);
			assert.equal(resFirst.status, 200);
			assert.equal(resFirst.headers.get('Content-Type'), 'application/json+devalue');
			const data = devalue.parse(await resFirst.text());
			const uploadId = data?.uploadId;
			assert.ok(uploadId);

			const formDataRest = new FormData();
			formDataRest.set('type', 'rest-chunk');
			formDataRest.set('uploadId', 'fake');
			formDataRest.set('image', new File([''], 'chunk-2.png'));
			const reqRest = new Request('http://example.com/_actions/imageUploadInChunks', {
				method: 'POST',
				body: formDataRest,
			});

			const resRest = await app.render(reqRest);
			assert.equal(resRest.status, 200);
			assert.equal(resRest.headers.get('Content-Type'), 'application/json+devalue');
			const dataRest = devalue.parse(await resRest.text());
			assert.equal('fake', dataRest?.uploadId);
		});

		it('Handles special characters in action names', async () => {
			for (const name of ['with%2Fslash', 'with%20space', 'with%2Edot']) {
				const req = new Request(`http://example.com/_actions/${name}`, {
					method: 'POST',
					body: JSON.stringify({ name: 'ben' }),
					headers: {
						'Content-Type': 'application/json',
					},",1
"import { defineMiddleware, sequence } from 'astro:middleware';

const first = defineMiddleware(async (context, next) => {
	if (context.request.url.includes('/lorem')) {
		context.locals.name = 'ipsum';
	} else if (context.request.url.includes('/rewrite')) {
		return new Response('<span>New content!!</span>', {
			status: 200,
		});",1
"	it('should forward cookies set in a component when the middleware returns a new response', async () => {
		const res = await fixture.fetch('/return-response-cookies');
		const headers = res.headers;
		assert.notEqual(headers.get('set-cookie'), null);
	});

	describe('Integration hooks', () => {
		it('Integration middleware marked as ""pre"" runs', async () => {
			const res = await fixture.fetch('/integration-pre');
			const json = await res.json();
			assert.equal(json.pre, 'works');
		});

		it('Integration middleware marked as ""post"" runs', async () => {
			const res = await fixture.fetch('/integration-post');
			const json = await res.json();
			assert.equal(json.post, 'works');
		});
	});
});

describe('Integration hooks with no user middleware', () => {
	/** @type {import('./test-utils').Fixture} */
	let fixture;
	let devServer;
	before(async () => {
		fixture = await loadFixture({
			root: './fixtures/middleware-no-user-middleware/',
		});
		devServer = await fixture.startDevServer();
	});

	after(async () => {
		await devServer.stop();
	});

	it('Integration middleware marked as ""pre"" runs', async () => {
		const res = await fixture.fetch('/pre');
		const json = await res.json();
		assert.equal(json.pre, 'works');
	});

	it('Integration middleware marked as ""post"" runs', async () => {
		const res = await fixture.fetch('/post');
		const json = await res.json();
		assert.equal(json.post, 'works');
	});

	it('Integration middleware marked as ""url"" runs', async () => {
		const res = await fixture.fetch('/url');
		const json = await res.json();
		assert.equal(json.post, 'works');
	});
});

describe('Middleware in PROD mode, SSG', () => {
	/** @type {import('./test-utils').Fixture} */
	let fixture;

	before(async () => {
		fixture = await loadFixture({
			root: './fixtures/middleware-ssg/',
		});
		await fixture.build();
	});

	it('should render locals data', async () => {
		const html = await fixture.readFile('/index.html');
		const $ = cheerio.load(html);
		assert.equal($('p').html(), 'bar');
	});

	it('should change locals data based on URL', async () => {
		let html = await fixture.readFile('/index.html');
		let $ = cheerio.load(html);
		assert.equal($('p').html(), 'bar');

		html = await fixture.readFile('/second/index.html');
		$ = cheerio.load(html);
		assert.equal($('p').html(), 'second');
	});
});

describe('Middleware should not be executed or imported during', () => {
	/** @type {import('./test-utils').Fixture} */
	let fixture;

	it('should build the project without errors', async () => {
		fixture = await loadFixture({
			root: './fixtures/middleware-full-ssr/',
			output: 'server',
			adapter: testAdapter({}),
		});
		await fixture.build();
		assert.ok('Should build');
	});
});

describe('Middleware API in PROD mode, SSR', () => {
	/** @type {import('./test-utils').Fixture} */
	let fixture;
	let middlewarePath;
	/** @type {import('../src/core/app/index').App} */
	let app;

	before(async () => {
		fixture = await loadFixture({
			root: './fixtures/middleware space/',
			output: 'server',
			adapter: testAdapter({}),
		});
		await fixture.build();
		app = await fixture.loadTestAdapterApp();
	});

	it('should render locals data', async () => {
		const request = new Request('http://example.com/');
		const response = await app.render(request);
		const html = await response.text();
		const $ = cheerio.load(html);
		assert.equal($('p').html(), 'bar');
	});

	it('should change locals data based on URL', async () => {
		let response = await app.render(new Request('http://example.com/'));
		let html = await response.text();
		let $ = cheerio.load(html);
		assert.equal($('p').html(), 'bar');

		response = await app.render(new Request('http://example.com/lorem'));
		html = await response.text();
		$ = cheerio.load(html);
		assert.equal($('p').html(), 'ipsum');
	});

	it('should successfully redirect to another page', async () => {
		const request = new Request('http://example.com/redirect');
		const response = await app.render(request);
		assert.equal(response.status, 302);
	});

	it('should call a second middleware', async () => {
		const response = await app.render(new Request('http://example.com/second'));
		const html = await response.text();
		const $ = cheerio.load(html);
		assert.equal($('p').html(), 'second');
	});

	it('should successfully create a new response', async () => {
		const request = new Request('http://example.com/rewrite');
		const response = await app.render(request);
		const html = await response.text();
		const $ = cheerio.load(html);
		assert.equal($('p').html(), null);
		assert.equal($('span').html(), 'New content!!');
	});

	it('should return a new response that is a 500', async () => {
		const request = new Request('http://example.com/broken-500');
		const response = await app.render(request);
		assert.equal(response.status, 500);
	});

	it('should successfully render a page if the middleware calls only next() and returns nothing', async () => {
		const request = new Request('http://example.com/not-interested');
		const response = await app.render(request);
		const html = await response.text();
		const $ = cheerio.load(html);
		assert.equal($('p').html(), 'Not interested');
	});

	it(""should throw an error when the middleware doesn't call next or doesn't return a response"", async () => {
		const request = new Request('http://example.com/does-nothing');
		const response = await app.render(request);
		const html = await response.text();
		const $ = cheerio.load(html);
		assert.notEqual($('title').html(), 'MiddlewareNoDataReturned');
	});

	it('should return 200 if the middleware returns a 200 Response', async () => {
		const request = new Request('http://example.com/no-route-but-200');
		const response = await app.render(request);
		assert.equal(response.status, 200);
		const html = await response.text();
		assert.match(html, /It's OK!/);
	});

	it('should correctly work for API endpoints that return a Response object', async () => {
		const request = new Request('http://example.com/api/endpoint');
		const response = await app.render(request);
		assert.equal(response.status, 200);
		assert.equal(response.headers.get('Content-Type'), 'application/json');
	});

	it('should correctly manipulate the response coming from API endpoints (not simple)', async () => {
		const request = new Request('http://example.com/api/endpoint');
		const response = await app.render(request);
		const text = await response.text();
		assert.equal(text.includes('REDACTED'), true);
	});

	it('should correctly call the middleware function for 404', async () => {
		const request = new Request('http://example.com/funky-url');
		const routeData = app.match(request);
		const response = await app.render(request, { routeData });
		const text = await response.text();
		assert.equal(text.includes('Error'), true);
		assert.equal(text.includes('bar'), true);
	});

	it('should render 500.astro when the middleware throws an error', async () => {
		const request = new Request('http://example.com/throw');
		const routeData = app.match(request);

		const response = await app.render(request, { routeData });
		assert.equal(response.status, 500);

		const text = await response.text();
		assert.equal(text.includes('<h1>There was an error rendering the page.</h1>'), true);
	});

	it('should correctly render the page even when custom headers are set in a middleware', async () => {
		const request = new Request('http://example.com/content-policy');
		const routeData = app.match(request);

		const response = await app.render(request, { routeData });
		assert.equal(response.status, 404);
		assert.equal(response.headers.get('content-type'), 'text/html');
	});

	it('can render a page that does not exist', async () => {
		const request = new Request('http://example.com/does-not-exist');
		const routeData = app.match(request);

		const response = await app.render(request, { routeData });
		assert.equal(response.status, 200);
		const html = await response.text();
		const $ = cheerio.load(html);
		assert.equal($('p').html(), null);
		assert.equal($('span').html(), 'New content!!');
	});

	it('can set locals for prerendered pages to use', async () => {
		const text = await fixture.readFile('/client/prerendered/index.html');
		assert.equal(text.includes('<p>yes they can!</p>'), true);
	});

	// keep this last
	it('the integration should receive the path to the middleware', async () => {
		fixture = await loadFixture({
			root: './fixtures/middleware space/',
			output: 'server',
			build: {",1
"}

export function trailingSlashMismatchTemplate(
	pathname: string,
	trailingSlash: 'always' | 'never' | 'ignore',
) {
	const corrected =
		trailingSlash === 'always'
			? appendForwardSlash(pathname)
			: removeTrailingForwardSlash(pathname);
	return template({
		pathname,
		statusCode: 404,
		title: 'Not found',
		tabTitle: '404: Not Found',
		body: `<p>Your site is configured with <code>trailingSlash</code> set to <code>${trailingSlash}</code>. Do you want to go to <a href=""${corrected}"">${corrected}</a> instead?</p>",1
"	mode: 'dev' | 'build',
	cwd?: string,
): RouteData {
	const endpointEntrypoint =
		settings.config.image.endpoint.entrypoint === undefined // If not set, use default endpoint
			? mode === 'dev'
				? 'astro/assets/endpoint/node'
				: 'astro/assets/endpoint/generic'
			: settings.config.image.endpoint.entrypoint;

	const segments = [
		[
			{",1
"
		if (isRemoteImage && isRemoteAllowed(transform.src, imageConfig) === false) {
			return new Response('Forbidden', { status: 403 });
		}

		const sourceUrl = new URL(transform.src, url.origin);
		inputBuffer = await loadRemoteImage(sourceUrl, isRemoteImage ? new Headers() : request.headers);

		if (!inputBuffer) {
			return new Response('Not Found', { status: 404 });
		}
",1
"// @ts-expect-error
import { assetsDir, imageConfig, outDir } from 'astro:assets';
import { readFile } from 'node:fs/promises';
import os from 'node:os';
import { isAbsolute } from 'node:path';
import { fileURLToPath, pathToFileURL } from 'node:url';
import { isRemotePath, removeQueryString } from '@astrojs/internal-helpers/path';
import { isRemoteAllowed } from '@astrojs/internal-helpers/remote';
import * as mime from 'mrmime';
import type { APIRoute } from '../../types/public/common.js';
import { getConfiguredImageService } from '../internal.js';
import { etag } from '../utils/etag.js';

function replaceFileSystemReferences(src: string) {
	return os.platform().includes('win32') ? src.replace(/^\/@fs\//, '') : src.replace(/^\/@fs/, '');
}

async function loadLocalImage(src: string, url: URL) {
	const assetsDirPath = fileURLToPath(assetsDir);

	let fileUrl;
	if (import.meta.env.DEV) {
		fileUrl = pathToFileURL(removeQueryString(replaceFileSystemReferences(src)));
	} else {
		try {
			// If the _image segment isn't at the start of the path, we have a base
			const idx = url.pathname.indexOf('/_image');
			if (idx > 0) {
				// Remove the base path
				src = src.slice(idx);
			}
			fileUrl = new URL('.' + src, outDir);
			const filePath = fileURLToPath(fileUrl);

			if (!isAbsolute(filePath) || !filePath.startsWith(assetsDirPath)) {
				return undefined;
			}
		} catch {
			return undefined;
		}
	}

	let buffer: Buffer | undefined = undefined;

	try {
		buffer = await readFile(fileUrl);
	} catch {
		// Fallback to try to load the file using `fetch`
		try {
			const sourceUrl = new URL(src, url.origin);
			buffer = await loadRemoteImage(sourceUrl);
		} catch (err: unknown) {
			console.error('Could not process image request:', err);
			return undefined;
		}
	}

	return buffer;
}

async function loadRemoteImage(src: URL) {
	try {
		const res = await fetch(src);

		if (!res.ok) {
			return undefined;
		}

		return Buffer.from(await res.arrayBuffer());
	} catch {
		return undefined;
	}
}

/**
 * Endpoint used in dev and SSR to serve optimized images by the base image services
 */
export const GET: APIRoute = async ({ request }) => {
	try {
		const imageService = await getConfiguredImageService();

		if (!('transform' in imageService)) {
			throw new Error('Configured image service is not a local service');
		}

		const url = new URL(request.url);
		const transform = await imageService.parseURL(url, imageConfig);

		if (!transform?.src) {
			const err = new Error(
				'Incorrect transform returned by `parseURL`. Expected a transform with a `src` property.',
			);
			console.error('Could not parse image transform from URL:', err);
			return new Response('Internal Server Error', { status: 500 });
		}

		let inputBuffer: Buffer | undefined = undefined;

		if (isRemotePath(transform.src)) {
			if (isRemoteAllowed(transform.src, imageConfig) === false) {
				return new Response('Forbidden', { status: 403 });
			}

			inputBuffer = await loadRemoteImage(new URL(transform.src));
		} else {
			inputBuffer = await loadLocalImage(transform.src, url);
		}

		if (!inputBuffer) {
			return new Response('Internal Server Error', { status: 500 });
		}

		const { data, format } = await imageService.transform(inputBuffer, transform, imageConfig);

		return new Response(data as Uint8Array<ArrayBuffer>, {
			status: 200,
			headers: {
				'Content-Type': mime.lookup(format) ?? `image/${format}`,
				'Cache-Control': 'public, max-age=31536000',
				ETag: etag(data.toString()),
				Date: new Date().toUTCString(),
			},
		});
	} catch (err: unknown) {
		console.error('Could not process image request:', err);
		return new Response(
			import.meta.env.DEV ? `Could not process image request: ${err}` : `Internal Server Error`,
			{
				status: 500,
			},
		);
	}
};",1
"		return quality;
	}

	return result;
}

type ImageConfig<T> = Omit<AstroConfig['image'], 'service'> & {
	service: { entrypoint: string; config: T };
};

interface SharedServiceProps<T extends Record<string, any> = Record<string, any>> {
	/**
	 * Return the URL to the endpoint or URL your images are generated from.
	 *
	 * For a local service, your service should expose an endpoint handling the image requests, or use Astro's which by default, is located at `/_image`.
	 *
	 * For external services, this should point to the URL your images are coming from, for instance, `/_vercel/image`
	 *
	 */
	getURL: (options: ImageTransform, imageConfig: ImageConfig<T>) => string | Promise<string>;
	/**
	 * Generate additional `srcset` values for the image.
	 *
	 * While in most cases this is exclusively used for `srcset`, it can also be used in a more generic way to generate
	 * multiple variants of the same image. For instance, you can use this to generate multiple aspect ratios or multiple formats.
	 */
	getSrcSet?: (
		options: ImageTransform,
		imageConfig: ImageConfig<T>,
	) => UnresolvedSrcSetValue[] | Promise<UnresolvedSrcSetValue[]>;
	/**
	 * Return any additional HTML attributes separate from `src` that your service requires to show the image properly.
	 *
	 * For example, you might want to return the `width` and `height` to avoid CLS, or a particular `class` or `style`.
	 * In most cases, you'll want to return directly what your user supplied you, minus the attributes that were used to generate the image.
	 */
	getHTMLAttributes?: (
		options: ImageTransform,
		imageConfig: ImageConfig<T>,
	) => Record<string, any> | Promise<Record<string, any>>;
	/**
	 * Validate and return the options passed by the user.
	 *
	 * This method is useful to present errors to users who have entered invalid options.
	 * For instance, if they are missing a required property or have entered an invalid image format.
	 *
	 * This method should returns options, and can be used to set defaults (ex: a default output format to be used if the user didn't specify one.)
	 */
	validateOptions?: (
		options: ImageTransform,
		imageConfig: ImageConfig<T>,
	) => ImageTransform | Promise<ImageTransform>;
}

export type ExternalImageService<T extends Record<string, any> = Record<string, any>> =
	SharedServiceProps<T>;

type LocalImageTransform = {
	src: string;
	[key: string]: any;
};

export interface LocalImageService<T extends Record<string, any> = Record<string, any>>
	extends SharedServiceProps<T> {",1
"					let $img = $('#remote img');
					assert.equal($img.attr('alt'), 'fred');
				});

				it('includes loading and decoding attributes', () => {
					let $img = $('#remote img');
					assert.equal(!!$img.attr('loading'), true);
					assert.equal(!!$img.attr('decoding'), true);
				});

				it('includes width and height attributes', () => {
					let $img = $('#remote img');
					assert.equal(!!$img.attr('width'), true);
					assert.equal(!!$img.attr('height'), true);
				});

				it('support data: URI', () => {
					let $img = $('#data-uri img');
					assert.equal(
						$img.attr('src'),
						'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA0AAAANCAYAAABy6+R8AAAAAXNSR0IArs4c6QAAAIRlWElmTU0AKgAAAAgABQESAAMAAAABAAEAAAEaAAUAAAABAAAASgEbAAUAAAABAAAAUgEoAAMAAAABAAIAAIdpAAQAAAABAAAAWgAAAAAAAABIAAAAAQAAAEgAAAABAAOgAQADAAAAAQABAACgAgAEAAAAAQAAAA2gAwAEAAAAAQAAAA0AAAAAWvB1rQAAAAlwSFlzAAALEwAACxMBAJqcGAAAAVlpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IlhNUCBDb3JlIDYuMC4wIj4KICAgPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iPgogICAgICAgICA8dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KGV7hBwAAAWJJREFUKBVtUDEsQ1EUve+1/SItKYMIkYpF06GJdGAwNFFGkxBEYupssRm6EpvJbpVoYhRd6FBikDSxYECsBpG25D/nvP/+p+Ik551z73v33feuyA/izq5CL8ET8ALcBolYIP+vd0ibX/yAT7uj2qkVzwWzUBa0nbacbkKJHi5dlYhXmARYeAS+MwCWA5FPqKIP/9IH/wiygMru5y5mcRYkPHYKP7gAPw4SDbCjRXMgRBJctM4t4ROriM2QSpmkeOtub6YfMYrZvelykbD1sxJVg+6AfKqURRKQLfA4JvoVWgIjDMNlGLVKZxNRFsZsoHGAgREZHKPlJEi2t7if3r2KKS9nVOo0rtNZ3yR7M/VGTqTy5Y4o/scWHBbKfIq0/eZ+x3850OZpaTTxlu/4D3ssuA72uxrYS2rFYjh+aRbmb24LpTVu1IqVKG8P/lmUEaNMxeh6fmquOhkMBE8JJ2yPfwPjdVhiDbiX6AAAAABJRU5ErkJggg==',
					);
					assert.equal(!!$img.attr('width'), true);
					assert.equal(!!$img.attr('height'), true);
				});

				it('support images from public', () => {
					let $img = $('#public img');
					assert.equal($img.attr('src'), '/penguin3.jpg');
					assert.equal(!!$img.attr('width'), true);
					assert.equal(!!$img.attr('height'), true);
				});
			});

			it('error if no width and height', async () => {
				logs.length = 0;
				let res = await fixture.fetch('/remote-error-no-dimensions');
				await res.text();

				assert.equal(logs.length, 1);
				assert.equal(logs[0].message.includes('Missing width and height attributes'), true);
			});

			it('error if no height', async () => {
				logs.length = 0;
				let res = await fixture.fetch('/remote-error-no-height');
				await res.text();

				assert.equal(logs.length, 1);
				assert.equal(logs[0].message.includes('Missing height attribute'), true);
			});

			it('supports aliases', async () => {
				let res = await fixture.fetch('/alias');
				let html = await res.text();
				let $ = cheerio.load(html);

				let $img = $('img');
				assert.equal($img.length, 1);
				assert.equal($img.attr('src').includes('penguin1.jpg'), true);
			});
		});

		describe('markdown', () => {
			let $;
			before(async () => {
				let res = await fixture.fetch('/post');
				let html = await res.text();
				$ = cheerio.load(html);
			});

			it('Adds the <img> tag', () => {
				let $img = $('img');
				assert.equal($img.length, 2);

				// Verbose test for the full URL to make sure the image went through the full pipeline
				assert.equal(
					$img.attr('src').startsWith('/_image') && $img.attr('src').endsWith('f=webp'),
					true,
				);
			});

			it('has width and height attributes', () => {
				let $img = $('img');
				assert.equal(!!$img.attr('width'), true);
				assert.equal(!!$img.attr('height'), true);
			});

			it('Supports aliased paths', async () => {
				let res = await fixture.fetch('/aliasMarkdown');
				let html = await res.text();
				$ = cheerio.load(html);

				let $img = $('img');
				assert.equal($img.attr('src').startsWith('/_image'), true);
			});

			it('Supports special characters in file name', async () => {
				let res = await fixture.fetch('/specialChars');
				let html = await res.text();
				$ = cheerio.load(html);

				let $img = $('img');
				assert.equal($img.length, 4);
				$img.each((_, el) => {
					assert.equal(el.attribs.src?.startsWith('/_image'), true);
				});
			});

			it('properly handles remote images', async () => {
				let res = await fixture.fetch('/httpImage');
				let html = await res.text();
				$ = cheerio.load(html);

				let $img = $('img');
				assert.equal($img.length, 2);
				const remoteUrls = ['https://example.com/image.png', '/image.png'];
				$img.each((index, element) => {
					assert.equal(element.attribs['src'], remoteUrls[index]);
				});
			});
		});

		describe('getImage', () => {
			let $;
			before(async () => {
				let res = await fixture.fetch('/get-image');
				let html = await res.text();
				$ = cheerio.load(html);
			});

			it('Adds the <img> tag', () => {
				let $img = $('img');
				assert.equal($img.length, 1);
				assert.equal($img.attr('src').startsWith('/_image'), true);
			});

			it('includes the provided alt', () => {
				let $img = $('img');
				assert.equal($img.attr('alt'), 'a penguin');
			});
		});

		describe('content collections', () => {
			let $;
			before(async () => {
				let res = await fixture.fetch('/blog/one');
				let html = await res.text();
				$ = cheerio.load(html);
			});

			it('Adds the <img> tags', () => {
				let $img = $('img');
				assert.equal($img.length, 8);
			});

			it('image in cc folder is processed', () => {
				let $imgs = $('img');
				let $blogfolderimg = $($imgs[7]);
				assert.equal($blogfolderimg.attr('src').includes('blogfolder.jpg'), true);
				assert.equal($blogfolderimg.attr('src').endsWith('f=webp'), true);
			});

			it('has proper source for directly used image', () => {
				let $img = $('#direct-image img');
				assert.equal($img.attr('src').startsWith('/'), true);
			});

			it('has proper source for refined image', () => {
				let $img = $('#refined-image img');
				assert.equal($img.attr('src').startsWith('/'), true);
			});

			it('has proper sources for array of images', () => {
				let $img = $('#array-of-images img');
				const imgsSrcs = [];
				$img.each((_i, img) => imgsSrcs.push(img.attribs['src']));
				assert.equal($img.length, 2);
				assert.equal(
					imgsSrcs.every((img) => img.startsWith('/')),
					true,
				);
			});

			it('has proper attributes for optimized image through getImage', () => {
				let $img = $('#optimized-image-get-image img');
				assert.equal($img.attr('src').startsWith('/_image'), true);
				assert.equal($img.attr('width'), '207');
				assert.equal($img.attr('height'), '243');
			});

			it('has proper attributes for optimized image through Image component', () => {
				let $img = $('#optimized-image-component img');
				assert.equal($img.attr('src').startsWith('/_image'), true);
				assert.equal($img.attr('width'), '207');
				assert.equal($img.attr('height'), '243');
				assert.equal($img.attr('alt'), 'A penguin!');
			});

			it('properly handles nested images', () => {
				let $img = $('#nested-image img');
				assert.equal($img.attr('src').startsWith('/'), true);
			});
		});

		describe('regular img tag', () => {
			/** @type {ReturnType<import('cheerio')['load']>} */
			let $;
			before(async () => {
				let res = await fixture.fetch('/regular-img');
				let html = await res.text();
				$ = cheerio.load(html);
			});

			it('does not have a file url', async () => {
				assert.equal($('img').attr('src').startsWith('file://'), false);
			});

			it('includes /src in the path', async () => {
				assert.equal($('img').attr('src').includes('/src'), true);
			});
		});

		describe('custom service', () => {
			it('custom service implements getHTMLAttributes', async () => {
				const response = await fixture.fetch('/');
				const html = await response.text();

				const $ = cheerio.load(html);
				assert.equal($('#local img').attr('data-service'), 'my-custom-service');
			});

			it('custom service works in Markdown', async () => {
				const response = await fixture.fetch('/post');
				const html = await response.text();

				const $ = cheerio.load(html);
				assert.equal($('img').attr('data-service'), 'my-custom-service');
			});

			it('gets service config', async () => {
				const response = await fixture.fetch('/');
				const html = await response.text();

				const $ = cheerio.load(html);
				assert.equal($('#local img').attr('data-service-config'), 'bar');
			});
		});

		describe('custom endpoint', async () => {
			/** @type {import('./test-utils').DevServer} */
			let customEndpointDevServer;

			/** @type {import('./test-utils.js').Fixture} */
			let customEndpointFixture;

			before(async () => {
				customEndpointFixture = await loadFixture({
					root: './fixtures/core-image/',
					image: {
						endpoint: { entrypoint: './src/custom-endpoint.ts' },
						service: testImageService({ foo: 'bar' }),
						domains: ['avatars.githubusercontent.com'],
					},
				});

				customEndpointDevServer = await customEndpointFixture.startDevServer({
					server: { port: 4324 },
				});
			});

			it('custom endpoint works', async () => {
				const response = await customEndpointFixture.fetch('/');
				const html = await response.text();

				const $ = cheerio.load(html);
				const src = $('#local img').attr('src');

				let res = await customEndpointFixture.fetch(src);
				assert.equal(res.status, 200);
				assert.equal(
					await res.text(),
					""You fool! I'm not a image endpoint at all, I just return this!"",
				);
			});

			after(async () => {
				await customEndpointDevServer.stop();
			});
		});
	});

	describe('proper errors', () => {
		/** @type {import('./test-utils').DevServer} */
		let devServer;
		/** @type {Array<{ type: any, level: 'error', message: string; }>} */
		let logs = [];

		before(async () => {
			fixture = await loadFixture({
				root: './fixtures/core-image-errors/',
				image: {
					service: testImageService(),
				},
			});

			devServer = await fixture.startDevServer({
				logger: new Logger({
					level: 'error',
					dest: new Writable({
						objectMode: true,
						write(event, _, callback) {
							logs.push(event);
							callback();
						},
					}),
				}),
			});
		});

		after(async () => {
			await devServer.stop();
		});

		it(""properly error when getImage's first parameter isn't filled"", async () => {
			logs.length = 0;
			let res = await fixture.fetch('/get-image-empty');
			await res.text();

			assert.equal(logs.length >= 1, true);
			assert.equal(logs[0].message.includes('Expected getImage() parameter'), true);
		});

		it('properly error when src is undefined', async () => {
			logs.length = 0;
			let res = await fixture.fetch('/get-image-undefined');
			await res.text();

			assert.equal(logs.length >= 1, true);
			assert.equal(logs[0].message.includes('Expected `src` property'), true);
		});

		it('errors when an ESM imported image is passed directly to getImage', async () => {
			logs.length = 0;
			let res = await fixture.fetch('/get-image-import-passed');
			await res.text();
			assert.equal(logs.length >= 1, true);
			assert.equal(
				logs[0].message.includes('An ESM-imported image cannot be passed directly'),
				true,
			);
		});

		it('properly error image in Markdown frontmatter is not found', async () => {
			logs.length = 0;
			let res = await fixture.fetch('/blog/one');
			await res.text();

			assert.equal(logs.length, 1);
			assert.equal(logs[0].message.includes('does not exist. Is the path correct?'), true);
		});

		it('properly error image in Markdown content is not found', async () => {
			logs.length = 0;
			let res = await fixture.fetch('/post');
			await res.text();
			assert.equal(logs.length, 1);
			assert.equal(logs[0].message.includes('Could not find requested image'), true);
		});
	});

	describe('support base option correctly', () => {
		before(async () => {
			fixture = await loadFixture({
				root: './fixtures/core-image-base/',
				image: {
					service: testImageService(),
				},
				base: '/blog',
			});
			await fixture.build();
		});

		it('has base path prefix when using the Image component', async () => {
			const html = await fixture.readFile('/index.html');
			const $ = cheerio.load(html);
			const src = $('#local img').attr('src');
			assert.equal(src.length > 0, true);
			assert.equal(src.startsWith('/blog'), true);
		});

		it('has base path prefix when using getImage', async () => {
			const html = await fixture.readFile('/get-image/index.html');
			const $ = cheerio.load(html);
			const src = $('img').attr('src');
			assert.equal(src.length > 0, true);
			assert.equal(src.startsWith('/blog'), true);
		});

		it('has base path prefix when using image directly', async () => {
			const html = await fixture.readFile('/direct/index.html');
			const $ = cheerio.load(html);
			const src = $('img').attr('src');
			assert.equal(src.length > 0, true);
			assert.equal(src.startsWith('/blog'), true);
		});

		it('has base path prefix in Markdown', async () => {
			const html = await fixture.readFile('/post/index.html');
			const $ = cheerio.load(html);
			const src = $('img').attr('src');
			assert.equal(src.length > 0, true);
			assert.equal(src.startsWith('/blog'), true);
		});

		it('has base path prefix in Content Collection frontmatter', async () => {
			const html = await fixture.readFile('/blog/one/index.html');
			const $ = cheerio.load(html);
			const src = $('img').attr('src');
			assert.equal(src.length > 0, true);
			assert.equal(src.startsWith('/blog'), true);
		});

		it('has base path prefix in SSR', async () => {
			const fixtureWithBase = await loadFixture({
				root: './fixtures/core-image-ssr/',
				output: 'server',
				outDir: './dist/server-base-path',
				adapter: testAdapter(),
				image: {
					endpoint: {
						entrypoint: 'astro/assets/endpoint/node',
					},
					service: testImageService(),
				},
				base: '/blog',
			});
			await fixtureWithBase.build();
			const app = await fixtureWithBase.loadTestAdapterApp();
			const request = new Request('http://example.com/blog/');
			const response = await app.render(request);
			assert.equal(response.status, 200);
			const html = await response.text();
			const $ = cheerio.load(html);
			const src = $('#local img').attr('src');
			assert.equal(src.startsWith('/blog'), true);
			const img = await app.render(new Request(`https://example.com${src}`));
			assert.equal(img.status, 200);
		});

		it('returns 403 when loading a relative pattern iamge', async () => {
			const fixtureWithBase = await loadFixture({
				root: './fixtures/core-image-ssr/',
				output: 'server',
				outDir: './dist/server-base-path',
				adapter: testAdapter(),
			});
			await fixtureWithBase.build();
			const app = await fixtureWithBase.loadTestAdapterApp();
			let request = new Request('http://example.com/');
			let response = await app.render(request);
			// making sure that the app works
			assert.equal(response.status, 200);
			request = new Request(
				'http://example.com/_image/?href=//secure0x.netlify.app/secure0x.svg&f=svg',
			);
			response = await app.render(request);
			assert.equal(response.status, 403);
		});
	});

	describe('build ssg', () => {
		before(async () => {
			fixture = await loadFixture({
				root: './fixtures/core-image-ssg/',
				image: {
					service: testImageService(),
					domains: [
						'astro.build',
						'avatars.githubusercontent.com',
						'kaleidoscopic-biscotti-6fe98c.netlify.app',
					],
				},
			});
			// Remove cache directory
			removeDir(new URL('./fixtures/core-image-ssg/node_modules/.astro', import.meta.url));

			await fixture.build();
		});

		it('writes out images to dist folder', async () => {
			const html = await fixture.readFile('/index.html');
			const $ = cheerio.load(html);
			const src = $('#local img').attr('src');
			assert.equal(src.length > 0, true);
			const data = await fixture.readFile(src, null);
			assert.equal(data instanceof Buffer, true);
		});

		it('writes out allowed remote images', async () => {
			const html = await fixture.readFile('/remote/index.html');
			const $ = cheerio.load(html);
			const src = $('#remote img').attr('src');
			assert.equal(src.length > 0, true);
			const data = await fixture.readFile(src, null);
			assert.equal(data instanceof Buffer, true);
		});

		it('writes out images to dist folder with proper extension if no format was passed', async () => {
			const html = await fixture.readFile('/index.html');
			const $ = cheerio.load(html);
			const src = $('#local img').attr('src');
			assert.equal(src.endsWith('.webp'), true);
		});

		it('getImage() usage also written', async () => {
			const html = await fixture.readFile('/get-image/index.html');
			const $ = cheerio.load(html);
			let $img = $('img');

			// <img> tag
			assert.equal($img.length, 1);
			assert.equal($img.attr('alt'), 'a penguin');

			// image itself
			const src = $img.attr('src');
			const data = await fixture.readFile(src, null);
			assert.equal(data instanceof Buffer, true);
		});

		it('handles remote images with special characters', async () => {
			const html = await fixture.readFile('/special-chars/index.html');
			const $ = cheerio.load(html);
			const $img = $('img');
			assert.equal($img.length, 1);
			const src = $img.attr('src');
			// The filename should be encoded and sanitized
			assert.ok(src.startsWith('/_astro/c_23'));
			const data = await fixture.readFile(src, null);
			assert.ok(data instanceof Buffer);
		});

		it('Picture component images are written', async () => {
			const html = await fixture.readFile('/picturecomponent/index.html');
			const $ = cheerio.load(html);
			let $img = $('img');
			let $source = $('source');

			assert.equal($img.length, 1);
			assert.equal($source.length, 2);

			const srcset = parseSrcset($source.attr('srcset'));
			let hasExistingSrc = await Promise.all(
				srcset.map(async (src) => {
					const data = await fixture.readFile(src.url, null);
					return data instanceof Buffer;
				}),
			);

			assert.deepEqual(
				hasExistingSrc.every((src) => src === true),
				true,
			);
		});

		it('markdown images are written', async () => {
			const html = await fixture.readFile('/post/index.html');
			const $ = cheerio.load(html);
			let $img = $('img');

			// <img> tag
			assert.equal($img.length, 1);
			assert.equal($img.attr('alt'), 'My article cover');

			// image itself
			const src = $img.attr('src');
			const data = await fixture.readFile(src, null);
			assert.equal(data instanceof Buffer, true);
		});

		it('aliased images are written', async () => {
			const html = await fixture.readFile('/alias/index.html');

			const $ = cheerio.load(html);
			let $img = $('img');

			// <img> tag
			assert.equal($img.length, 1);
			assert.equal($img.attr('alt'), 'A penguin!');

			// image itself
			const src = $img.attr('src');
			const data = await fixture.readFile(src, null);
			assert.equal(data instanceof Buffer, true);
		});

		it('aliased images in Markdown are written', async () => {
			const html = await fixture.readFile('/aliasMarkdown/index.html');

			const $ = cheerio.load(html);
			let $img = $('img');

			// <img> tag
			assert.equal($img.length, 1);
			assert.equal($img.attr('alt'), 'A penguin');

			// image itself
			const src = $img.attr('src');
			const data = await fixture.readFile(src, null);
			assert.equal(data instanceof Buffer, true);
		});

		it('output files for content collections images', async () => {
			const html = await fixture.readFile('/blog/one/index.html');

			const $ = cheerio.load(html);
			let $img = $('img');
			assert.equal($img.length, 2);

			const srcdirect = $('#direct-image img').attr('src');
			const datadirect = await fixture.readFile(srcdirect, null);
			assert.equal(datadirect instanceof Buffer, true);

			const srcnested = $('#nested-image img').attr('src');
			const datanested = await fixture.readFile(srcnested, null);
			assert.equal(datanested instanceof Buffer, true);
		});

		it('quality attribute produces a different file', async () => {
			const html = await fixture.readFile('/quality/index.html');
			const $ = cheerio.load(html);
			assert.notEqual($('#no-quality img').attr('src'), $('#quality-low img').attr('src'));
		});

		it('quality can be a number between 0-100', async () => {
			const html = await fixture.readFile('/quality/index.html');
			const $ = cheerio.load(html);
			assert.notEqual($('#no-quality img').attr('src'), $('#quality-num img').attr('src'));
		});

		it('format attribute produces a different file', async () => {
			const html = await fixture.readFile('/format/index.html');
			const $ = cheerio.load(html);
			assert.notEqual($('#no-format img').attr('src'), $('#format-avif img').attr('src'));
		});

		it('has cache entries', async () => {
			const generatedImages = (await fixture.glob('_astro/**/*.webp'))
				.map((path) => basename(path))
				.sort();
			const cachedImages = [...(await fixture.glob('../node_modules/.astro/assets/**/*.webp'))]
				.map((path) => basename(path))
				.sort();

			assert.deepEqual(generatedImages, cachedImages);
		});

		it('uses cache entries', async () => {
			const logs = [];
			const logging = {
				dest: {
					write(chunk) {
						logs.push(chunk);
					},
				},
			};

			await fixture.build({ logging });
			const generatingImageIndex = logs.findIndex((logLine) =>
				logLine.message.includes('generating optimized images'),
			);
			const relevantLogs = logs.slice(generatingImageIndex + 1, -1);
			const isReusingCache = relevantLogs.every((logLine) =>
				logLine.message.includes('(reused cache entry)'),
			);

			assert.equal(isReusingCache, true);
		});

		it('writes remote image cache metadata', async () => {
			const html = await fixture.readFile('/remote/index.html');
			const $ = cheerio.load(html);
			const metaSrc =
				'../node_modules/.astro/assets/' + basename($('#remote img').attr('src')) + '.json';
			const data = await fixture.readFile(metaSrc, null);
			assert.equal(data instanceof Buffer, true);
			const metadata = JSON.parse(data.toString());
			assert.equal(typeof metadata.expires, 'number');
		});

		it('client images are written to build', async () => {
			const html = await fixture.readFile('/client/index.html');
			const $ = cheerio.load(html);
			let $script = $('script');

			// Find image
			const regex = /src:""([^""]*)/;
			const imageSrc = regex.exec($script.html())[1];
			const data = await fixture.readFile(imageSrc, null);
			assert.equal(data instanceof Buffer, true);
		});

		it('client images srcset parsed correctly', async () => {
			const html = await fixture.readFile('/srcset/index.html');
			const $ = cheerio.load(html);
			const srcset = $('#local-2-widths-with-spaces img').attr('srcset');

			// Find image
			const regex = /^(.+?) \d+[wx]$/m;
			const imageSrcset = regex.exec(srcset)[1];
			assert.notEqual(imageSrcset.includes(' '), true);
		});

		it('supports images with encoded characters in url', async () => {
			const html = await fixture.readFile('/index.html');
			const $ = cheerio.load(html);
			const img = $('#encoded-chars img');
			const src = img.attr('src');
			const data = await fixture.readFile(src);
			assert.notEqual(data, undefined);
		});

		describe('custom service in build', () => {
			it('uses configured hashes properties', async () => {
				await fixture.build();
				const html = await fixture.readFile('/imageDeduplication/index.html');

				const $ = cheerio.load(html);

				const allTheSamePath = $('#all-the-same img')
					.map((_, el) => $(el).attr('src'))
					.get();

				assert.equal(
					allTheSamePath.every((path) => path === allTheSamePath[0]),
					true,
				);

				const useCustomHashProperty = $('#use-data img')
					.map((_, el) => $(el).attr('src'))
					.get();
				assert.equal(
					useCustomHashProperty.every((path) => path === useCustomHashProperty[0]),
					false,
				);

				assert.notEqual(useCustomHashProperty[1], useCustomHashProperty[0]);
			});
		});
	});

	describe('dev ssr', () => {
		/** @type {import('./test-utils').DevServer} */
		let devServer;
		before(async () => {
			fixture = await loadFixture({
				root: './fixtures/core-image-ssr/',
				output: 'server',
				outDir: './dist/server-dev',
				adapter: testAdapter(),
				base: 'some-base',
				image: {
					service: testImageService(),
				},
			});
			devServer = await fixture.startDevServer();
		});

		after(async () => {
			await devServer.stop();
		});

		it('serves the image at /_image', async () => {
			const params = new URLSearchParams();
			params.set('href', '/src/assets/penguin1.jpg?origWidth=207&origHeight=243&origFormat=jpg');
			params.set('f', 'webp');
			const response = await fixture.fetch('/some-base/_image?' + String(params));
			assert.equal(response.status, 200);
			assert.equal(response.headers.get('content-type'), 'image/webp');
		});

		it('returns HEAD method ok for /_image', async () => {
			const params = new URLSearchParams();
			params.set('href', '/src/assets/penguin1.jpg?origWidth=207&origHeight=243&origFormat=jpg');
			params.set('f', 'webp');
			const response = await fixture.fetch('/some-base/_image?' + String(params), {
				method: 'HEAD',
			});
			assert.equal(response.status, 200);
			assert.equal(response.body, null);
			assert.equal(response.headers.get('content-type'), 'image/webp');
		});

		it('does not interfere with query params', async () => {
			let res = await fixture.fetch('/api?src=image.png');
			const html = await res.text();
			assert.equal(html, 'An image: ""image.png""');
		});
	});

	describe('prod ssr', () => {
		before(async () => {
			fixture = await loadFixture({
				root: './fixtures/core-image-ssr/',
				output: 'server',
				outDir: './dist/server-prod',
				adapter: testAdapter(),
				image: {
					endpoint: { entrypoint: 'astro/assets/endpoint/node' },
					service: testImageService(),
				},
			});
			await fixture.build();
		});

		it('dynamic route images are built at response time', async () => {
			const app = await fixture.loadTestAdapterApp();
			let request = new Request('http://example.com/');
			let response = await app.render(request);
			assert.equal(response.status, 200);
			const html = await response.text();
			const $ = cheerio.load(html);
			const src = $('#local img').attr('src');
			request = new Request('http://example.com' + src);
			response = await app.render(request);
			assert.equal(response.status, 200);
		});

		it('endpoint handle malformed requests', async () => {
			const badPaths = [
				'../../../../../../../../../../../../etc/hosts%00',
				'../../../../../../../../../../../../etc/hosts',
				'../../boot.ini',
				'/../../../../../../../../%2A',
				'../../../../../../../../../../../../etc/passwd%00',
				'../../../../../../../../../../../../etc/passwd',
				'../../../../../../../../../../../../etc/shadow%00',
				'../../../../../../../../../../../../etc/shadow',
				'/../../../../../../../../../../etc/passwd^^',
				'/../../../../../../../../../../etc/shadow^^',
				'/../../../../../../../../../../etc/passwd',
				'/../../../../../../../../../../etc/shadow',
				'/./././././././././././etc/passwd',
				'/./././././././././././etc/shadow',
				'....................etcpasswd',
				'....................etcshadow',
				'....................etcpasswd',
				'....................etcshadow',
				'/..../..../..../..../..../..../etc/passwd',
				'/..../..../..../..../..../..../etc/shadow',
				'.\\./.\\./.\\./.\\./.\\./.\\./etc/passwd',
				'.\\./.\\./.\\./.\\./.\\./.\\./etc/shadow',
				'....................etcpasswd%00',
				'....................etcshadow%00',
				'....................etcpasswd%00',
				'....................etcshadow%00',
				'%0a/bin/cat%20/etc/passwd',
				'%0a/bin/cat%20/etc/shadow',
				'%00/etc/passwd%00',
				'%00/etc/shadow%00',
				'%00../../../../../../etc/passwd',
				'%00../../../../../../etc/shadow',
				'/../../../../../../../../../../../etc/passwd%00.jpg',
				'/../../../../../../../../../../../etc/passwd%00.html',
				'/..%c0%af../..%c0%af../..%c0%af../..%c0%af../..%c0%af../..%c0%af../etc/passwd',
				'/..%c0%af../..%c0%af../..%c0%af../..%c0%af../..%c0%af../..%c0%af../etc/shadow',
				'/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd,',
				'/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/shadow,',
				'%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%,25%5c..%25%5c..%25%5c..%25%5c..%00',
				'/%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..,%25%5c..%25%5c..%25%5c..%25%5c..%00',
				'%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%,25%5c..%25%5c..%	25%5c..%25%5c..%00',
				'%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%,25%5c..%25%5c..%		25%5c..%25%5c..%255cboot.ini',
				'/%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..,%25%5c..%25%5c..%25%5c..%25%5c..winnt/desktop.ini',
				'\\&apos;/bin/cat%20/etc/passwd\\&apos;',
				'\\&apos;/bin/cat%20/etc/shadow\\&apos;',
				'../../../../../../../../conf/server.xml',
				'/../../../../../../../../bin/id|',
				'C:/inetpub/wwwroot/global.asa',
				'C:inetpubwwwrootglobal.asa',
				'C:/boot.ini',
				'C:\boot.ini',
				'../../../../../../../../../../../../localstart.asp%00',
				'../../../../../../../../../../../../localstart.asp',
				'../../../../../../../../../../../../boot.ini%00',
				'../../../../../../../../../../../../boot.ini',
				'/./././././././././././boot.ini',
				'/../../../../../../../../../../../boot.ini%00',
				'/../../../../../../../../../../../boot.ini',
				'/..../..../..../..../..../..../boot.ini',
				'/.\\./.\\./.\\./.\\./.\\./.\\./boot.ini',
				'....................\boot.ini',
				'....................\boot.ini%00',
				'....................\boot.ini',
				'/../../../../../../../../../../../boot.ini%00.html',
				'/../../../../../../../../../../../boot.ini%00.jpg',
				'/.../.../.../.../.../	',
				'..%c0%af../..%c0%af../..%c0%af../..%c0%af../..%c0%af../..%c0%af../boot.ini',
				'/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/boot.ini',
				'../prerender/index.html',
			];

			const app = await fixture.loadTestAdapterApp();

			for (const path of badPaths) {
				let request = new Request('http://example.com/_image?href=' + path);
				let response = await app.render(request);
				const body = await response.text();

				// Most paths are malformed local paths (500), but some backslash patterns
				// are now correctly detected as remote and get 403
				const { isRemotePath } = await import('@astrojs/internal-helpers/path');
				const isDetectedAsRemote = isRemotePath(path);
				const expectedStatus = isDetectedAsRemote ? 403 : 500;
				const expectedBodyText = isDetectedAsRemote ? 'Forbidden' : 'Internal Server Error';

				assert.equal(
					response.status,
					expectedStatus,
					`Path ""${path}"" should return ${expectedStatus}`,
				);
				assert.equal(
					body.includes(expectedBodyText),
					true,
					`Path ""${path}"" body should include ""${expectedBodyText}""`,
				);
			}

			// Server should still be running
			let request = new Request('http://example.com/');
			let response = await app.render(request);
			assert.equal(response.status, 200);
		});

		it('prerendered routes images are built', async () => {
			const html = await fixture.readFile('/client/prerender/index.html');
			const $ = cheerio.load(html);
			const src = $('img').attr('src');
			const imgData = await fixture.readFile('/client' + src, null);
			assert.equal(imgData instanceof Buffer, true);
		});
	});

	describe('trailing slash on the endpoint', () => {
		/** @type {import('./test-utils').DevServer} */
		let devServer;
",1
"								pattern: '/foo',
								params: [],
								origin: 'external',
							},
							{
								isPrerendered: false,
								entrypoint: '../../../../dist/assets/endpoint/node.js',
								pattern: '/_image',
								params: [],
								origin: 'internal',
							},
							{
								isPrerendered: false,
								entrypoint: 'astro-default-404.astro',
								pattern: '/404',
								params: [],
								origin: 'internal',
							},
						].sort((a, b) => a.pattern.localeCompare(b.pattern)),
					);

					await fixture.writeFile('/src/pages/bar.astro', '');
					container.viteServer.watcher.emit(
						'add',
						fixture.getPath('/src/pages/bar.astro').replace(/\\/g, '/'),
					);
					await new Promise((r) => setTimeout(r, 100));

					assert.deepEqual(
						routes,
						[
							{
								isPrerendered: false,
								entrypoint: '_server-islands.astro',
								pattern: '/_server-islands/[name]',
								params: ['name'],
								origin: 'internal',
							},
							{
								isPrerendered: false,
								entrypoint: '../../../../dist/actions/runtime/route.js',
								pattern: '/_actions/[...path]',
								params: ['...path'],
								origin: 'internal',
							},
							{
								isPrerendered: true,
								entrypoint: 'src/pages/about.astro',
								pattern: '/about',
								params: [],
								origin: 'project',
							},
							{
								isPrerendered: true,
								entrypoint: 'src/pages/bar.astro',
								pattern: '/bar',
								params: [],
								origin: 'project',
							},
							{
								isPrerendered: true,
								entrypoint: 'src/foo.astro',
								pattern: '/foo',
								params: [],
								origin: 'external',
							},
							{
								isPrerendered: false,
								entrypoint: '../../../../dist/assets/endpoint/node.js',
								pattern: '/_image',
								params: [],
								origin: 'internal',
							},
							{
								isPrerendered: false,
								entrypoint: 'astro-default-404.astro',
								pattern: '/404',
								params: [],
								origin: 'internal',
							},
						].sort((a, b) => a.pattern.localeCompare(b.pattern)),
					);

					await fixture.writeFile('/src/pages/about.astro', '---\nexport const prerender=false\n');
					container.viteServer.watcher.emit(
						'change',
						fixture.getPath('/src/pages/about.astro').replace(/\\/g, '/'),
					);
					await new Promise((r) => setTimeout(r, 100));

					assert.deepEqual(
						routes,
						[
							{
								isPrerendered: false,
								entrypoint: '_server-islands.astro',
								pattern: '/_server-islands/[name]',
								params: ['name'],
								origin: 'internal',
							},
							{
								isPrerendered: false,
								entrypoint: '../../../../dist/actions/runtime/route.js',
								pattern: '/_actions/[...path]',
								params: ['...path'],
								origin: 'internal',
							},
							{
								isPrerendered: false,
								entrypoint: 'src/pages/about.astro',
								pattern: '/about',
								params: [],
								origin: 'project',
							},
							{
								isPrerendered: true,
								entrypoint: 'src/pages/bar.astro',
								pattern: '/bar',
								params: [],
								origin: 'project',
							},
							{
								isPrerendered: true,
								entrypoint: 'src/foo.astro',
								pattern: '/foo',
								params: [],
								origin: 'external',
							},
							{
								isPrerendered: false,
								entrypoint: '../../../../dist/assets/endpoint/node.js',
								pattern: '/_image',
								params: [],
								origin: 'internal',
							},
							{
								isPrerendered: false,",1
"		} else {
			// Redirect here because it is safer than a proxy, remote image will be served by remote domain and not own domain
			return Response.redirect(href, 302);
		}
	}

	return fetch(new URL(href, ctx.url.origin));
};",1
"	let _options: Options;
	let _config: AstroConfig | undefined = undefined;
	let _routeToHeaders: RouteToHeaders | undefined = undefined;
	return {
		name: '@astrojs/node',
		hooks: {
			'astro:config:setup': async ({ updateConfig, config, logger }) => {
				let session = config.session;
				_config = config;
				if (!session?.driver) {
					logger.info('Enabling sessions with filesystem storage');
					session = {
						...session,
						driver: 'fs-lite',
						options: {
							base: fileURLToPath(new URL('sessions', config.cacheDir)),
						},
					};
				}

				updateConfig({
					image: {
						endpoint: {
							route: config.image.endpoint.route ?? '_image',
							entrypoint: config.image.endpoint.entrypoint ?? 'astro/assets/endpoint/node',
						},
					},
					session,
					vite: {
						ssr: {
							noExternal: ['@astrojs/node'],",1
"	});

	after(async () => {
		await devPreview.stop();
	});

	it('it returns local images', { skip: 'Check why the infer remote size fails' }, async () => {
		const res = await fixture.fetch('/');
		assert.equal(res.status, 200);
		const html = await res.text();
		const $ = cheerio.load(html);

		const img = $('img[alt=Penguins]').attr('src');
		const size = await inferRemoteSize(`http://localhost:4321${img}`);
		assert.equal(size.format, 'webp');
		assert.equal(size.width, 50);
		assert.equal(size.height, 33);
	});

	it('it returns remote images', { skip: 'Check why the infer remote size fails' }, async () => {
		const res = await fixture.fetch('/');
		assert.equal(res.status, 200);
		const html = await res.text();
		const $ = cheerio.load(html);
		const img = $('img[alt=Cornwall]').attr('src');
		const size = await inferRemoteSize(`http://localhost:4321${img}`);
		assert.equal(size.format, 'webp');
		assert.equal(size.width, 400);
		assert.equal(size.height, 300);
	});
});",1
"}

export function isRelativePath(path: string) {
	return startsWithDotDotSlash(path) || startsWithDotSlash(path);
}

function isString(path: unknown): path is string {
	return typeof path === 'string' || path instanceof String;
}

const INTERNAL_PREFIXES = new Set(['/_', '/@', '/.', '//']);
const JUST_SLASHES = /^\/{2,}$/;

export function isInternalPath(path: string) {
	return INTERNAL_PREFIXES.has(path.slice(0, 2)) && !JUST_SLASHES.test(path);
}

export function joinPaths(...paths: (string | undefined)[]) {
	return paths
		.filter(isString)
		.map((path, i) => {
			if (i === 0) {
				return removeTrailingForwardSlash(path);
			} else if (i === paths.length - 1) {
				return removeLeadingForwardSlash(path);
			} else {
				return trimSlashes(path);
			}
		})
		.join('/');
}

export function removeFileExtension(path: string) {
	let idx = path.lastIndexOf('.');
	return idx === -1 ? path : path.slice(0, idx);
}

export function removeQueryString(path: string) {
	const index = path.lastIndexOf('?');
	return index > 0 ? path.substring(0, index) : path;
}

/**
 * Regex that matches the following URLs like:
 * - http://example.com
 * - https://example.com
 * - ftp://example.com
 * - ws://example.com
 * - //example.com (protocol-relative URLs)
 */
const URL_PROTOCOL_REGEX = /^(?:(?:http|ftp|https|ws):?\/\/|\/\/)/;

/**
 * Checks whether the path is considered a remote path. Paths need to start with:
 * - `http://`
 * - `https://`
 * - `ftp://`
 * - `ws://`
 * - `//` (protocol-relative URLs)
 * - `data:` (base64 images)
 * - Backslash variants (e.g., `\\example.com`) that could normalize to remote URLs
 * - URL-encoded backslash variants (e.g., `%5C%5Cexample.com`)
 * @param src
 */
export function isRemotePath(src: string) {
	// First decode any URL-encoded backslashes
	const decoded = src.replace(/%5C/gi, '\\');

	// Check for any backslash at the start (single or multiple)
	// These can be normalized to protocol-relative URLs
	if (decoded[0] === '\\') {
		return true;
	}

	// Check for protocols with backslashes (e.g., http:\\ or https:\\)
	if (/^(?:http|https|ftp|ws):\\/.test(decoded)) {
		return true;
	}

	// Check standard URL patterns
	return URL_PROTOCOL_REGEX.test(decoded) || decoded.startsWith('data:');
}

export function slash(path: string) {
	return path.replace(/\\/g, '/');
}
",1
"): boolean {
	if (!URL.canParse(src)) {
		return false;
	}

	const url = new URL(src);
	return (
		domains.some((domain) => matchHostname(url, domain)) ||
		remotePatterns.some((remotePattern) => matchPattern(url, remotePattern))
	);
}",1
"import assert from 'node:assert/strict';
import { describe, it } from 'node:test';
import { isRemotePath } from '../dist/path.js';

describe('isRemotePath', () => {
	it('should return true if the path is remote', () => {
		assert.equal(isRemotePath('https://example.com/foo/bar.js'), true, 'should be a remote path');
		assert.equal(isRemotePath('http://example.com/foo/bar.js'), true, 'should be a remote path');
		assert.equal(isRemotePath('//example.com/foo/bar.js'), true, 'should be a remote path');
		assert.equal(isRemotePath('ws://example.com/foo/bar.js'), true, 'should be a remote path');
		assert.equal(isRemotePath('ftp://example.com/foo/bar.js'), true, 'should be a remote path');
		assert.equal(isRemotePath('data:someCode'), true, 'should be a remote path');
		// false
		assert.equal(isRemotePath('/local/path/file.js'), false, 'should not be a remote path');
		assert.equal(isRemotePath('relative/path/file.js'), false, 'should not be a remote path');
		assert.equal(isRemotePath('./relative/path/file.js'), false, 'should not be a remote path');
		assert.equal(isRemotePath('../relative/path/file.js'), false, 'should not be a remote path');
		assert.equal(isRemotePath('C:\\windows\\path\\file.js'), false, 'should not be a remote path');
		assert.equal(
			isRemotePath('file://example.com/foo/bar.js'),
			false,
			'should not be a remote path',
		);
		assert.equal(
			isRemotePath('sftp://example.com/foo/bar.js'),
			false,
			'should not be a remote path',
		);
		assert.equal(
			isRemotePath('wss://example.com/foo/bar.js'),
			false,
			'should not be a remote path',
		);
		assert.equal(isRemotePath('mailto:example@example.com'), false, 'should not be a remote path');

		// Backslash bypass attempts - these SHOULD be treated as remote paths
		// to prevent SSRF via URL normalization in downstream code
		assert.equal(
			isRemotePath('\\\\example.com/foo/bar.js'),
			true,
			'double backslash should be detected as remote',
		);
		assert.equal(
			isRemotePath('\\example.com/foo/bar.js'),
			true,
			'single backslash should be detected as remote',
		);
		assert.equal(
			isRemotePath('\\\\\\example.com/foo/bar.js'),
			true,
			'triple backslash should be detected as remote',
		);

		// Encoded backslash attempts - these should also be caught
		assert.equal(
			isRemotePath('%5C%5Cexample.com/foo/bar.js'),
			true,
			'encoded double backslash should be detected as remote',
		);
		assert.equal(
			isRemotePath('%5Cexample.com/foo/bar.js'),
			true,
			'encoded single backslash should be detected as remote',
		);

		// Mixed forward and backslashes
		assert.equal(
			isRemotePath('\\//example.com/foo/bar.js'),
			true,
			'mixed backslash-forward should be detected as remote',
		);
		assert.equal(
			isRemotePath('/\\example.com/foo/bar.js'),
			false,
			'forward-backslash in path should not be remote',
		);

		// Backslashes with protocols (malformed but could be normalized)
		assert.equal(
			isRemotePath('http:\\\\example.com/foo/bar.js'),
			true,
			'http with backslashes should be detected as remote',
		);
		assert.equal(
			isRemotePath('https:\\\\example.com/foo/bar.js'),
			true,
			'https with backslashes should be detected as remote',
		);
		assert.equal(
			isRemotePath('http:\\example.com/foo/bar.js'),
			true,
			'http with single backslash should be detected as remote',
		);

		// Other backslash edge cases
		assert.equal(
			isRemotePath('\\raw.githubusercontent.com/test.svg'),
			true,
			'backslash with real domain should be detected as remote',
		);
		assert.equal(
			isRemotePath('\\\\raw.githubusercontent.com/test.svg'),
			true,
			'double backslash with real domain should be detected as remote',
		);
	});
});",1
"		} catch {
			// Invalid URL
			return false;
		}
	}

	/**
	 * Creates a pipeline by reading the stored manifest
	 *
	 * @param streaming
	 * @private
	 */
	#createPipeline(streaming = false) {
		return AppPipeline.create({
			logger: this.#logger,
			manifest: this.#manifest,
			runtimeMode: 'production',
			renderers: this.#manifest.renderers,
			defaultRoutes: createDefaultRoutes(this.#manifest),
			resolve: async (specifier: string) => {
				if (!(specifier in this.#manifest.entryModules)) {
					throw new Error(`Unable to resolve [${specifier}]`);
				}
				const bundlePath = this.#manifest.entryModules[specifier];
				if (bundlePath.startsWith('data:') || bundlePath.length === 0) {
					return bundlePath;
				} else {
					return createAssetLink(bundlePath, this.#manifest.base, this.#manifest.assetsPrefix);
				}
			},
			serverLike: true,
			streaming,
		});
	}

	set setManifestData(newManifestData: RoutesList) {
		this.#manifestData = newManifestData;
	}

	removeBase(pathname: string) {
		if (pathname.startsWith(this.#manifest.base)) {
			return pathname.slice(this.#baseWithoutTrailingSlash.length + 1);
		}
		return pathname;
	}

	/**
	 * It removes the base from the request URL, prepends it with a forward slash and attempts to decoded it.
	 *
	 * If the decoding fails, it logs the error and return the pathname as is.
	 * @param request
	 * @private
	 */
	#getPathnameFromRequest(request: Request): string {
		const url = new URL(request.url);
		const pathname = prependForwardSlash(this.removeBase(url.pathname));
		try {
			return decodeURI(pathname);
		} catch (e: any) {
			this.getAdapterLogger().error(e.toString());
			return pathname;
		}
	}

	/**
	 * Given a `Request`, it returns the `RouteData` that matches its `pathname`. By default, prerendered
	 * routes aren't returned, even if they are matched.
	 *
	 * When `allowPrerenderedRoutes` is `true`, the function returns matched prerendered routes too.
	 * @param request
	 * @param allowPrerenderedRoutes
	 */
	match(request: Request, allowPrerenderedRoutes = false): RouteData | undefined {
		const url = new URL(request.url);
		// ignore requests matching public assets
		if (this.#manifest.assets.has(url.pathname)) return undefined;
		let pathname = this.#computePathnameFromDomain(request);
		if (!pathname) {
			pathname = prependForwardSlash(this.removeBase(url.pathname));
		}
		let routeData = matchRoute(decodeURI(pathname), this.#manifestData);

		if (!routeData) return undefined;
		if (allowPrerenderedRoutes) {
			return routeData;
		}
		// missing routes fall-through, pre rendered are handled by static layer
		else if (routeData.prerender) {
			return undefined;
		}
		return routeData;
	}

	#computePathnameFromDomain(request: Request): string | undefined {
		let pathname: string | undefined = undefined;
		const url = new URL(request.url);

		if (
			this.#manifest.i18n &&
			(this.#manifest.i18n.strategy === 'domains-prefix-always' ||
				this.#manifest.i18n.strategy === 'domains-prefix-other-locales' ||
				this.#manifest.i18n.strategy === 'domains-prefix-always-no-redirect')
		) {
			// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Host
			let forwardedHost = request.headers.get('X-Forwarded-Host');
			// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Proto
			let protocol = request.headers.get('X-Forwarded-Proto');
			if (protocol) {
				// this header doesn't have a colon at the end, so we add to be in line with URL#protocol, which does have it
				protocol = protocol + ':';
			} else {
				// we fall back to the protocol of the request
				protocol = url.protocol;
			}

			// Validate X-Forwarded-Host against allowedDomains if configured
			if (forwardedHost && !this.matchesAllowedDomains(forwardedHost, protocol?.replace(':', ''))) {
				// If not allowed, ignore the X-Forwarded-Host header
				forwardedHost = null;
			}

			let host = forwardedHost;
			if (!host) {
				// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Host
				host = request.headers.get('Host');
			}
			// If we don't have a host and a protocol, it's impossible to proceed
			if (host && protocol) {
				// The header might have a port in their name, so we remove it
				host = host.split(':')[0];
				try {
					let locale;",1
"import fs from 'node:fs';
import type { IncomingMessage, ServerResponse } from 'node:http';
import { Http2ServerResponse } from 'node:http2';
import type { Socket } from 'node:net';
// matchPattern is used in App.validateForwardedHost, no need to import here
import type { RemotePattern } from '../../types/public/config.js';
import type { RouteData } from '../../types/public/internal.js';
import { clientAddressSymbol, nodeRequestAbortControllerCleanupSymbol } from '../constants.js';
import { deserializeManifest } from './common.js';
import { createOutgoingHttpHeaders } from './createOutgoingHttpHeaders.js';
import type { RenderOptions } from './index.js';
import { App } from './index.js';
import type { NodeAppHeadersJson, SerializedSSRManifest, SSRManifest } from './types.js';

export { apply as applyPolyfills } from '../polyfill.js';

/**
 * Allow the request body to be explicitly overridden. For example, this
 * is used by the Express JSON middleware.
 */
interface NodeRequest extends IncomingMessage {
	body?: unknown;
}

export class NodeApp extends App {
	headersMap: NodeAppHeadersJson | undefined = undefined;

	public setHeadersMap(headers: NodeAppHeadersJson) {
		this.headersMap = headers;
	}

	match(req: NodeRequest | Request, allowPrerenderedRoutes = false) {
		if (!(req instanceof Request)) {
			req = NodeApp.createRequest(req, {
				skipBody: true,
				allowedDomains: this.manifest.allowedDomains,
			});
		}
		return super.match(req, allowPrerenderedRoutes);
	}
	render(request: NodeRequest | Request, options?: RenderOptions): Promise<Response>;
	/**
	 * @deprecated Instead of passing `RouteData` and locals individually, pass an object with `routeData` and `locals` properties.
	 * See https://github.com/withastro/astro/pull/9199 for more information.
	 */
	render(request: NodeRequest | Request, routeData?: RouteData, locals?: object): Promise<Response>;
	render(
		req: NodeRequest | Request,
		routeDataOrOptions?: RouteData | RenderOptions,
		maybeLocals?: object,
	) {
		if (!(req instanceof Request)) {
			req = NodeApp.createRequest(req, {
				allowedDomains: this.manifest.allowedDomains,
			});
		}
		// @ts-expect-error The call would have succeeded against the implementation, but implementation signatures of overloads are not externally visible.
		return super.render(req, routeDataOrOptions, maybeLocals);
	}

	/**
	 * Converts a NodeJS IncomingMessage into a web standard Request.
	 * ```js
	 * import { NodeApp } from 'astro/app/node';
	 * import { createServer } from 'node:http';
	 *
	 * const server = createServer(async (req, res) => {
	 *     const request = NodeApp.createRequest(req);
	 *     const response = await app.render(request);
	 *     await NodeApp.writeResponse(response, res);
	 * })
	 * ```
	 */
	static createRequest(
		req: NodeRequest,
		{
			skipBody = false,
			allowedDomains = [],
		}: { skipBody?: boolean; allowedDomains?: Partial<RemotePattern>[] } = {},
	): Request {
		const controller = new AbortController();

		const isEncrypted = 'encrypted' in req.socket && req.socket.encrypted;

		// Parses multiple header and returns first value if available.
		const getFirstForwardedValue = (multiValueHeader?: string | string[]) => {
			return multiValueHeader
				?.toString()
				?.split(',')
				.map((e) => e.trim())?.[0];
		};

		// Get the used protocol between the end client and first proxy.
		// NOTE: Some proxies append values with spaces and some do not.
		// We need to handle it here and parse the header correctly.
		// @example ""https, http,http"" => ""http""
		const forwardedProtocol = getFirstForwardedValue(req.headers['x-forwarded-proto']);
		const providedProtocol = isEncrypted ? 'https' : 'http';
		const protocol = forwardedProtocol ?? providedProtocol;

		// @example ""example.com,www2.example.com"" => ""example.com""
		let forwardedHostname = getFirstForwardedValue(req.headers['x-forwarded-host']);
		const providedHostname = req.headers.host ?? req.headers[':authority'];

		// Validate X-Forwarded-Host against allowedDomains if configured
		if (
			forwardedHostname &&
			!App.validateForwardedHost(
				forwardedHostname,
				allowedDomains,
				forwardedProtocol ?? providedProtocol,
			)
		) {
			// If not allowed, ignore the X-Forwarded-Host header
			forwardedHostname = undefined;
		}

		const hostname = forwardedHostname ?? providedHostname;

		// @example ""443,8080,80"" => ""443""
		const port = getFirstForwardedValue(req.headers['x-forwarded-port']);

		let url: URL;
		try {
			const hostnamePort = getHostnamePort(hostname, port);
			url = new URL(`${protocol}://${hostnamePort}${req.url}`);
		} catch {",1
"						host: 'example.com',
						'x-forwarded-host': ':123',
					},
				});
				assert.equal(result.url, 'https://example.com/');
			});
		});

		describe('x-forwarded-proto', () => {
			it('parses protocol from single-value x-forwarded-proto header', () => {
				const result = NodeApp.createRequest({
					...mockNodeRequest,
					headers: {
						host: 'example.com',
						'x-forwarded-proto': 'http',
						'x-forwarded-port': '80',
					},
				});
				assert.equal(result.url, 'http://example.com/');
			});

			it('parses protocol from multi-value x-forwarded-proto header', () => {
				const result = NodeApp.createRequest({
					...mockNodeRequest,
					headers: {
						host: 'example.com',
						'x-forwarded-proto': 'http,https',
						'x-forwarded-port': '80,443',
					},
				});
				assert.equal(result.url, 'http://example.com/');
			});

			it('fallbacks to encrypted property when no x-forwarded-proto header is present', () => {
				const result = NodeApp.createRequest({
					...mockNodeRequest,
					headers: {
						host: 'example.com',
					},
				});
				assert.equal(result.url, 'https://example.com/');
			});
		});

		describe('x-forwarded-port', () => {
			it('parses port from single-value x-forwarded-port header', () => {
				const result = NodeApp.createRequest({
					...mockNodeRequest,
					headers: {
						host: 'example.com',
						'x-forwarded-port': '8443',
					},
				});
				assert.equal(result.url, 'https://example.com:8443/');
			});

			it('parses port from multi-value x-forwarded-port header', () => {
				const result = NodeApp.createRequest({
					...mockNodeRequest,
					headers: {
						host: 'example.com',
						'x-forwarded-port': '8443,3000',
					},
				});
				assert.equal(result.url, 'https://example.com:8443/');
			});

			it('prefers port from host', () => {
				const result = NodeApp.createRequest({
					...mockNodeRequest,
					headers: {
						host: 'example.com:3000',
						'x-forwarded-port': '443',
					},
				});
				assert.equal(result.url, 'https://example.com:3000/');
			});

			it('prefers port from x-forwarded-host', () => {
				const result = NodeApp.createRequest(
					{
						...mockNodeRequest,
						headers: {
							host: 'example.com:443',
							'x-forwarded-host': 'example.com:3000',
							'x-forwarded-port': '443',
						},
					},
					{ allowedDomains: [{ hostname: 'example.com' }] },
				);
				assert.equal(result.url, 'https://example.com:3000/');
			});",1
"export default defineConfig({
	output: 'server',
	adapter: nodejs({ mode: 'standalone' }),
	security: {
		allowedDomains: [
			{
				hostname: 'abc.xyz'
			}
		]
	}
});",1
"		const $ = cheerio.load(html);

		// Should use the Host header, not X-Forwarded-Host when allowedDomains is not configured
		assert.equal($('body').text(), 'https://legitimate.example.com/');
	});

	it('accepts any port when port not specified in allowedDomains', async () => {
		const { handler } = await import('./fixtures/url/dist/server/entry.mjs');
		const { req, res, text } = createRequestAndResponse({
			headers: {
				'X-Forwarded-Proto': 'https',
				'X-Forwarded-Host': 'abc.xyz:8080',
				Host: 'localhost:3000',
			},
			url: '/',
		});

		handler(req, res);
		req.send();

		const html = await text();
		const $ = cheerio.load(html);

		// When no port is specified in allowedDomains pattern, any port is accepted
		// This validates that port validation works (it's checking and passing)
		assert.equal($('body').text(), 'https://abc.xyz:8080/');
	});
});",1
"}

export function trailingSlashMismatchTemplate(
	pathname: string,
	trailingSlash: 'always' | 'never' | 'ignore',
) {
	const corrected =
		trailingSlash === 'always'
			? appendForwardSlash(pathname)
			: removeTrailingForwardSlash(pathname);
	return template({
		pathname,
		statusCode: 404,
		title: 'Not found',
		tabTitle: '404: Not Found',
		body: `<p>Your site is configured with <code>trailingSlash</code> set to <code>${trailingSlash}</code>. Do you want to go to <a href=""${corrected}"">${corrected}</a> instead?</p>",1
"
			for (const path of badPaths) {
				let request = new Request('http://example.com/_image?href=' + path);
				let response = await app.render(request);
				const body = await response.text();

				assert.equal(response.status, 500);
				assert.equal(body.includes('Internal Server Error'), true);
			}

			// Server should still be running
			let request = new Request('http://example.com/');
			let response = await app.render(request);
			assert.equal(response.status, 200);",1
" * - `http://`
 * - `https://`
 * - `ftp://`
 * - `ws://`
 * - `//` (protocol-relative URLs)
 * - `data:` (base64 images)
 * @param src
 */
export function isRemotePath(src: string) {
	return URL_PROTOCOL_REGEX.test(src) || src.startsWith('data:');
}

export function slash(path: string) {
	return path.replace(/\\/g, '/');
}
",1
"		assert.equal(
			isRemotePath('wss://example.com/foo/bar.js'),
			false,
			'should not be a remote path',
		);
		assert.equal(isRemotePath('mailto:example@example.com'), false, 'should not be a remote path');
	});
});",1
"                             matches as arguments.
    
      -p<pattern> --default=<pattern>
                             If no positional arguments are provided, glob will use
                             this pattern
    
      -A --all               By default, the glob cli command will not expand any
                             arguments that are an exact match to a file on disk.
    
                             This prevents double-expanding, in case the shell
                             expands an argument whose filename is a glob
                             expression.",1
"import { spawn, SpawnOptions } from 'child_process'
import { readFileSync } from 'fs'
import { sep } from 'path'
import t from 'tap'
import { fileURLToPath } from 'url'
const { version } = JSON.parse(
  readFileSync(
    fileURLToPath(new URL('../package.json', import.meta.url)),
    'utf8',
  ),
)
const bin = fileURLToPath(new URL('../dist/esm/bin.mjs', import.meta.url))

t.cleanSnapshot = s => s.split(version).join('{VERSION}')

interface Result {
  args: string[]
  options: SpawnOptions
  stdout: string
  stderr: string
  code: number | null
  signal: NodeJS.Signals | null
}
const run = async (args: string[], options = {}) => {
  const proc = spawn(
    process.execPath,
    ['--enable-source-maps', bin, ...args],
    options,
  )
  const out: Buffer[] = []
  const err: Buffer[] = []
  proc.stdout.on('data', c => out.push(c))
  proc.stderr.on('data', c => err.push(c))
  return new Promise<Result>(res => {
    proc.on('close', (code, signal) => {
      res({
        args,
        options,
        stdout: Buffer.concat(out).toString(),
        stderr: Buffer.concat(err).toString(),
        code,
        signal,
      })
    })
  })
}

t.test('usage', async t => {
  t.matchSnapshot(await run(['-h']), '-h shows usage')
  const res = await run([])
  t.equal(res.code, 1, 'exit with code 1 when no args')
  t.match(res.stderr, 'No patterns provided')
  t.match(res.stderr, /-h --help +Show this usage information$/m)
  const badp = await run(['--platform=glorb'])
  t.equal(badp.code, 1, 'exit with code 1 on bad platform arg')
  t.match(badp.stderr, 'Invalid value provided for --platform: ""glorb""\n')
})

t.test('version', async t => {
  t.matchSnapshot(await run(['-V']), '-V shows version')
  t.matchSnapshot(await run(['--version']), '--version shows version')
})

t.test('finds matches for a pattern', async t => {
  const cwd = t.testdir({
    a: {
      'x.y': '',
      'x.a': '',
      b: {
        'z.y': '',
        'z.a': '',
      },
    },
  })
  const res = await run(['**/*.y'], { cwd })
  t.match(res.stdout, `a${sep}x.y\n`)
  t.match(res.stdout, `a${sep}b${sep}z.y\n`)

  const c = `node -p ""process.argv.map(s=>s.toUpperCase())""`
  const cmd = await run(['**/*.y', '-c', c], { cwd })
  t.match(cmd.stdout, `'a${sep.replace(/\\/g, '\\\\')}x.y'`.toUpperCase())
  t.match(
    cmd.stdout,
    `'a${sep.replace(/\\/g, '\\\\')}b${sep.replace(
      /\\/g,
      '\\\\',
    )}z.y'`.toUpperCase(),
  )
})

t.test('prioritizes exact match if exists, unless --all', async t => {
  const cwd = t.testdir({
    routes: {
      '[id].tsx': '',
      'i.tsx': '',
      'd.tsx': '',",1
"import gql from 'graphql-tag';
import {
  assertCompositionSuccess,
  composeAsFed2Subgraphs,
} from ""./testHelper"";
import {InterfaceType} from ""@apollo/federation-internals"";

describe('authorization tests', () => {
  describe(""@requires"", () => {
    it('works with explicit auth', () => {
      const subgraph1 = {
        name: 'Subgraph1',
        url: 'https://Subgraph1',
        typeDefs: gql`
          type Query {
            t: T
          }

          type T @key(fields: ""id"") {
            id: ID
            extra: String @external
            requiresExtra: String @requires(fields: ""extra"") @authenticated
          }
        `
      }

      const subgraph2 = {
        name: 'Subgraph2',
        url: 'https://Subgraph2',
        typeDefs: gql`
          type T @key(fields: ""id"") {
            id: ID
            extra: String @authenticated
          }
        `
      }

      const result = composeAsFed2Subgraphs([subgraph1, subgraph2]);
      assertCompositionSuccess(result);
    })

    it('works with auth on the type', () => {
      const subgraph1 = {
        name: 'Subgraph1',
        url: 'https://Subgraph1',
        typeDefs: gql`
          type Query {
            t: T
          }

          type T @key(fields: ""id"") @policy(policies: [[""P1""]]) {
            id: ID
            extra: String @external
            requiresExtra: String @requires(fields: ""extra"")
          }
        `
      }

      const subgraph2 = {
        name: 'Subgraph2',
        url: 'https://Subgraph2',
        typeDefs: gql`
          type T @key(fields: ""id"") {
            id: ID
            extra: String @policy(policies: [[""P1""]])
          }
        `
      }

      const result = composeAsFed2Subgraphs([subgraph1, subgraph2]);
      assertCompositionSuccess(result);
    })

    it('works with valid subset of auth', () => {
      const subgraph1 = {
        name: 'Subgraph1',
        url: 'https://Subgraph1',
        typeDefs: gql`
          type Query {
            t: T
          }

          type T @key(fields: ""id"") {
            id: ID
            extra: String @external
            requiresExtra: String @requires(fields: ""extra"") @requiresScopes(scopes: [[""S2"", ""S1""]])
          }
        `
      }

      const subgraph2 = {
        name: 'Subgraph2',
        url: 'https://Subgraph2',
        typeDefs: gql`
          type T @key(fields: ""id"") {
            id: ID
            extra: String @requiresScopes(scopes: [[""S1"", ""S2""], [""S3""]])
          }
        `
      }

      const result = composeAsFed2Subgraphs([subgraph1, subgraph2]);
      assertCompositionSuccess(result);
    })

    it('works with auth on nested selection', () => {
      const subgraph1 = {
        name: 'Subgraph1',
        url: 'https://Subgraph1',
        typeDefs: gql`
          type Query {
            t: T
          }

          type T @key(fields: ""id"") @authenticated {
            id: ID
            extra: I @external
            requiresExtra: String @requires(fields: ""extra { i ... on I1 { i1 } ... on I2 { i2 } }"")
              @requiresScopes(scopes: [[""S1""][""S2""]]) @policy(policies: [[""P1""]])
          }

          interface I {
            i: String
          }

          type I1 implements I @external {
            i: String
            i1: String
          }

          type I2 implements I @external {
            i: String
            i2: Int
          }
        `
      }

      const subgraph2 = {
        name: 'Subgraph2',
        url: 'https://Subgraph2',
        typeDefs: gql`
          type T @key(fields: ""id"") {
            id: ID
            extra: I @authenticated
          }

          interface I {
            i: String
          }

          type I1 implements I {
            i: String @requiresScopes(scopes: [[""S1""]])
            i1: String @requiresScopes(scopes: [[""S2""]])
          }

          type I2 implements I {
            i: String
            i2: Int @policy(policies: [[""P1""]])
          }
        `
      }

      const result = composeAsFed2Subgraphs([subgraph1, subgraph2]);
      assertCompositionSuccess(result);
    })

    it('does not work when missing auth', () => {
      const subgraph1 = {
        name: 'Subgraph1',
        url: 'https://Subgraph1',
        typeDefs: gql`
          type Query {
            t: T
          }

          type T @key(fields: ""id"") {
            id: ID
            extra: String @external
            requiresExtra: String @requires(fields: ""extra"")
          }
        `
      }

      const subgraph2 = {
        name: 'Subgraph2',
        url: 'https://Subgraph2',
        typeDefs: gql`
          type T @key(fields: ""id"") {
            id: ID
            extra: String @authenticated
          }
        `
      }

      const result = composeAsFed2Subgraphs([subgraph1, subgraph2]);
      expect(result.schema).toBeUndefined();
      expect(result.errors?.length).toBe(1);
      expect(result.errors?.[0].message).toBe(
          '[Subgraph1] Field ""T.requiresExtra"" does not specify necessary @authenticated, @requiresScopes and/or ' +
          '@policy auth requirements to access the transitive field ""T.extra"" data from @requires selection set.'
      );
    })

    it('does not work with invalid subset of auth', () => {
      const subgraph1 = {
        name: 'Subgraph1',
        url: 'https://Subgraph1',
        typeDefs: gql`
          type Query {
            t: T
          }

          type T @key(fields: ""id"") {
            id: ID
            extra: String @external
            requiresExtra: String @requires(fields: ""extra"") @requiresScopes(scopes: [[""S1""]])
          }
        `
      }

      const subgraph2 = {
        name: 'Subgraph2',
        url: 'https://Subgraph2',
        typeDefs: gql`
          type T @key(fields: ""id"") {
            id: ID
            extra: String @requiresScopes(scopes: [[""S1"", ""S2""]])
          }
        `
      }

      const result = composeAsFed2Subgraphs([subgraph1, subgraph2]);
      expect(result.schema).toBeUndefined();
      expect(result.errors?.length).toBe(1);
      expect(result.errors?.[0].message).toBe(
          '[Subgraph1] Field ""T.requiresExtra"" does not specify necessary @authenticated, @requiresScopes and/or @policy ' +
          'auth requirements to access the transitive field ""T.extra"" data from @requires selection set.'
      );
    })

    it('does not work when missing auth on a nested selection', () => {
      const subgraph1 = {
        name: 'Subgraph1',
        url: 'https://Subgraph1',
        typeDefs: gql`
          type Query {
            t: T
          }

          type T @key(fields: ""id"") {
            id: ID
            extra: I @external
            requiresExtra: String @requires(fields: ""extra { i ... on I1 { i1 } ... on I2 { i2 } }"")
          }

          interface I {
            i: String
          }

          type I1 implements I @external {
            i: String
            i1: String
          }

          type I2 implements I @external {
            i: String
            i2: Int
          }
        `
      }

      const subgraph2 = {
        name: 'Subgraph2',
        url: 'https://Subgraph2',
        typeDefs: gql`
          type T @key(fields: ""id"") {
            id: ID
            extra: I
          }

          interface I {
            i: String
          }

          type I1 implements I {
            i: String
            i1: String
          }

          type I2 implements I {
            i: String
            i2: Int @policy(policies: [[""P1""]])
          }
        `
      }

      const result = composeAsFed2Subgraphs([subgraph1, subgraph2]);
      expect(result.schema).toBeUndefined();
      expect(result.errors?.length).toBe(1);
      expect(result.errors?.[0].message).toBe(
          '[Subgraph1] Field ""T.requiresExtra"" does not specify necessary @authenticated, @requiresScopes and/or @policy ' +
          'auth requirements to access the transitive field ""I2.i2"" data from @requires selection set.'
      );
    })

    it('does not work when missing explicit auth on an interface field selection', () => {
      const subgraph1 = {
        name: 'Subgraph1',
        url: 'https://Subgraph1',
        typeDefs: gql`
          type Query {
            t: T
          }

          type T @key(fields: ""id"") {
            id: ID
            extra: I @external
            requiresExtra: String @requires(fields: ""extra { i }"")
          }

          interface I {
            i: String
          }

          type I1 implements I @external {
            i: String
          }
        `
      }

      const subgraph2 = {
        name: 'Subgraph2',
        url: 'https://Subgraph2',
        typeDefs: gql`
          type T @key(fields: ""id"") {
            id: ID
            extra: I
          }

          interface I {
            i: String
          }

          type I1 implements I {
            i: String @requiresScopes(scopes: [[""S1""]])
          }
        `
      }

      const result = composeAsFed2Subgraphs([subgraph1, subgraph2]);
      expect(result.schema).toBeUndefined();
      expect(result.errors?.length).toBe(1);
      expect(result.errors?.[0].message).toBe(
          '[Subgraph1] Field ""T.requiresExtra"" does not specify necessary @authenticated, @requiresScopes and/or @policy ' +
          'auth requirements to access the transitive field ""I1.i"" data from @requires selection set.'
      );
    })

    it('does not work when missing inherited auth on a interface field selection', () => {
      const subgraph1 = {
        name: 'Subgraph1',
        url: 'https://Subgraph1',
        typeDefs: gql`
          type Query {
            t: T
          }

          type T @key(fields: ""id"") {
            id: ID
            extra: I @external
            requiresExtra: String @requires(fields: ""extra { i }"")
          }

          interface I {
            i: String
          }

          type I1 implements I @external {
            i: String
          }
        `
      }

      const subgraph2 = {
        name: 'Subgraph2',
        url: 'https://Subgraph2',
        typeDefs: gql`
          type T @key(fields: ""id"") {
            id: ID
            extra: I
          }

          interface I {
            i: String
          }

          type I1 implements I @authenticated {
            i: String
          }
        `
      }

      const result = composeAsFed2Subgraphs([subgraph1, subgraph2]);
      expect(result.schema).toBeUndefined();
      expect(result.errors?.length).toBe(1);
      expect(result.errors?.[0].message).toBe(
          '[Subgraph1] Field ""T.requiresExtra"" does not specify necessary @authenticated, @requiresScopes and/or @policy ' +
          'auth requirements to access the transitive field ""T.extra"" data from @requires selection set.'
      );
    })

    it('does not work when missing auth on type condition in a field selection', () => {
      const subgraph1 = {
        name: 'Subgraph1',
        url: 'https://Subgraph1',
        typeDefs: gql`
          type Query {
            t: T
          }

          type T @key(fields: ""id"") {
            id: ID
            extra: I @external
            requiresExtra: String @requires(fields: ""extra { ... on I1 { i1 } ... on I2 { i2 }}"")
          }

          interface I {
            i: String
          }

          type I1 implements I @external {
            i: String
            i1: Int
          }
          
          type I2 implements I @external {
            i: String
            i2: String
          }
        `
      }

      const subgraph2 = {
        name: 'Subgraph2',
        url: 'https://Subgraph2',
        typeDefs: gql`
          type T @key(fields: ""id"") {
            id: ID
            extra: I
          }

          interface I {
            i: String
          }

          type I1 implements I @requiresScopes(scopes: [[""S1""]]) {
            i: String 
            i1: Int
          }

          type I2 implements I {
            i: String
            i2: String
          }
        `
      }

      const result = composeAsFed2Subgraphs([subgraph1, subgraph2]);
      expect(result.schema).toBeUndefined();
      expect(result.errors?.length).toBe(1);
      expect(result.errors?.[0].message).toBe(
          '[Subgraph1] Field ""T.requiresExtra"" does not specify necessary @authenticated, @requiresScopes and/or @policy' +
          ' auth requirements to access the transitive field ""T.extra"" data from @requires selection set.'
      );
    })

    it('works with chain of requires', () => {
      const subgraph1 = {
        name: 'Subgraph1',
        url: 'https://Subgraph1',
        typeDefs: gql`
          type Query {
            t: T
          }

          type T @key(fields: ""id"") {
            id: ID
            extra: String @external
            requiresExtra: String @requires(fields: ""extra"") @authenticated
          }
        `
      }

      const subgraph2 = {
        name: 'Subgraph2',
        url: 'https://Subgraph2',
        typeDefs: gql`
          type T @key(fields: ""id"") {
            id: ID
            secret: String @external
            extra: String @requires(fields: ""secret"") @authenticated
          }
        `
      }

      const subgraph3 = {
        name: 'Subgraph3',
        url: 'https://Subgraph3',
        typeDefs: gql`
          type T @key(fields: ""id"") {
            id: ID
            secret: String @authenticated @inaccessible
          }
        `
      }

      const result = composeAsFed2Subgraphs([subgraph1, subgraph2, subgraph3]);
      assertCompositionSuccess(result);
    })
  });

  describe(""@context"", () => {
    it('works with explicit auth', () => {
      const subgraph1 = {
        name: 'Subgraph1',
        url: 'https://Subgraph1',
        typeDefs: gql`
          type Query {
            t: T!
          }

          type T @key(fields: ""id"") @context(name: ""context"") {
            id: ID!
            u: U!
            prop: String! @authenticated
          }

          type U @key(fields: ""id"") {
            id: ID!
            field(a: String @fromContext(field: ""$context { prop }"")): Int! @authenticated
          }
        `
      }

      const subgraph2 = {
        name: 'Subgraph2',
        url: 'https://Subgraph2',
        typeDefs: gql`
          type Query {
            a: Int!
          }

          type U @key(fields: ""id"") {
            id: ID!
          }
        `
      }

      const result = composeAsFed2Subgraphs([subgraph1, subgraph2]);
      assertCompositionSuccess(result);
    })

    it('works with explicit auth and multiple contexts', () => {
      const subgraph1 = {
        name: ""Subgraph1"",
        utl: ""https://Subgraph1"",
        typeDefs: gql`
          type Query {
            foo: Foo!
            bar: Bar!
          }

          type Foo @key(fields: ""id"") @context(name: ""context"") {
            id: ID!
            u: U!
            prop: String! @requiresScopes(scopes: [[""S1""]])
          }

          type Bar @key(fields: ""id"") @context(name: ""context"") {
            id: ID!
            u: U!
            prop: String! @requiresScopes(scopes: [[""S2""]])
          }

          type U @key(fields: ""id"") {
            id: ID!
            field(a: String @fromContext(field: ""$context { prop }"")): Int! @requiresScopes(scopes: [[""S1""], [""S2""]])
          }
        `,
      };

      const subgraph2 = {
        name: ""Subgraph2"",
        utl: ""https://Subgraph2"",
        typeDefs: gql`
          type Query {
            a: Int!
          }

          type U @key(fields: ""id"") {
            id: ID!
          }
        `,
      };

      const result = composeAsFed2Subgraphs([subgraph1, subgraph2]);
      assertCompositionSuccess(result);
    })

    it('works with explicit auth and multiple contexts using type conditions', () => {
      const subgraph1 = {
        name: ""Subgraph1"",
        utl: ""https://Subgraph1"",
        typeDefs: gql`
          type Query {
            foo: Foo!
            bar: Bar!
          }

          type Foo @key(fields: ""id"") @context(name: ""context"") {
            id: ID!
            u: U!
            prop: String! @requiresScopes(scopes: [[""S1""]])
          }

          type Bar @key(fields: ""id"") @context(name: ""context"") {
            id: ID!
            u: U!
            prop2: String! @policy(policies: [[""P1""]])
          }

          type U @key(fields: ""id"") {
            id: ID!
            field(
              a: String
              @fromContext(
                field: ""$context ... on Foo { prop } ... on Bar { prop2 }""
              )
            ): Int! @requiresScopes(scopes: [[""S1""]]) @policy(policies: [[""P1""]])
          }
        `,
      };

      const subgraph2 = {
        name: ""Subgraph2"",
        utl: ""https://Subgraph2"",
        typeDefs: gql`
          type Query {
            a: Int!
          }

          type U @key(fields: ""id"") {
            id: ID!
          }
        `,
      };

      const result = composeAsFed2Subgraphs([subgraph1, subgraph2]);
      assertCompositionSuccess(result);
    })

    it('does not work with missing auth', () => {
      const subgraph1 = {
        name: 'Subgraph1',
        url: 'https://Subgraph1',
        typeDefs: gql`
          type Query {
            t: T!
          }

          type T @key(fields: ""id"") @context(name: ""context"") {
            id: ID!
            u: U!
            prop: String! @authenticated
          }

          type U @key(fields: ""id"") {
            id: ID!
            field(a: String @fromContext(field: ""$context { prop }"")): Int!
          }
        `
      }

      const subgraph2 = {
        name: 'Subgraph2',
        url: 'https://Subgraph2',
        typeDefs: gql`
          type Query {
            a: Int!
          }

          type U @key(fields: ""id"") {
            id: ID!
          }
        `
      }

      const result = composeAsFed2Subgraphs([subgraph1, subgraph2]);
      expect(result.schema).toBeUndefined();
      expect(result.errors?.length).toBe(1);
      expect(result.errors?.[0].message).toBe(
          '[Subgraph1] Field ""U.field"" does not specify necessary @authenticated, @requiresScopes and/or @policy ' +
          'auth requirements to access the transitive field ""T.prop"" data from @fromContext selection set.'
      );
    })

    it('does not work with missing auth on one of the contexts', () => {
      const subgraph1 = {
        name: ""Subgraph1"",
        utl: ""https://Subgraph1"",
        typeDefs: gql`
          type Query {
            foo: Foo!
            bar: Bar!
          }

          type Foo @key(fields: ""id"") @context(name: ""context"") @authenticated {
            id: ID!
            u: U!
            prop: String!
          }

          type Bar @key(fields: ""id"") @context(name: ""context"") {
            id: ID!
            u: U!
            prop: String!
          }

          type U @key(fields: ""id"") {
            id: ID!
            field(a: String @fromContext(field: ""$context { prop }"")): Int!
          }
        `,
      };

      const subgraph2 = {
        name: ""Subgraph2"",
        utl: ""https://Subgraph2"",
        typeDefs: gql`
          type Query {
            a: Int!
          }

          type U @key(fields: ""id"") {
            id: ID!
          }
        `,
      };

      const result = composeAsFed2Subgraphs([subgraph1, subgraph2]);
      expect(result.schema).toBeUndefined();
      expect(result.errors?.length).toBe(1);
      expect(result.errors?.[0].message).toBe(
          '[Subgraph1] Field ""U.field"" does not specify necessary @authenticated, @requiresScopes and/or @policy auth ' +
          'requirements to access the transitive data in context Subgraph1__context from @fromContext selection set.'
      );
    })
  });

  describe(""interfaces"", () => {
    it('propagates @authenticated from type', () => {
      const subgraph1 = {
        name: 'Subgraph1',
        url: 'https://Subgraph1',
        typeDefs: gql`
          type Query {
            i: I!
          }

          interface I {
            id: ID
          }

          type T implements I @key(fields: ""id"") @authenticated {
            id: ID
            value1: String
          }

          type U implements I @key(fields: ""id"") {
            id: ID
            value2: String
          }
        `
      }

      const subgraph2 = {
        name: 'Subgraph2',
        url: 'https://Subgraph2',
        typeDefs: gql`
          type Query {
            t: T
          }

          type T @key(fields: ""id"") {
            id: ID!
            other: Int
          }
        `
      }

      const result = composeAsFed2Subgraphs([subgraph1, subgraph2]);
      assertCompositionSuccess(result);
      expect(
          result.schema.type('I')?.appliedDirectivesOf(""authenticated"")?.[0]
      );
    })

    it('propagates @requiresScopes from type', () => {
      const subgraph1 = {
        name: 'Subgraph1',
        url: 'https://Subgraph1',
        typeDefs: gql`
          type Query {
            i: I!
          }

          interface I {
            id: ID
          }

          type T implements I @key(fields: ""id"") @requiresScopes(scopes: [[""S1""], [""S2""]]) {
            id: ID
            vT: String
          }

          type U implements I @key(fields: ""id"") @requiresScopes(scopes: [[""S1""], [""S2"", ""S3""]]) {
            id: ID
            vU: String
          }

          type V implements I @key(fields: ""id"") {
            id: ID
            vV: String
          }
        `
      }

      const subgraph2 = {
        name: 'Subgraph2',
        url: 'https://Subgraph2',
        typeDefs: gql`
          type Query {
            t: T
          }

          type T @key(fields: ""id"") {
            id: ID!
            other: Int
          }
        `
      }

      const result = composeAsFed2Subgraphs([subgraph1, subgraph2]);
      assertCompositionSuccess(result);
      expect(
          result.schema.type('I')
              ?.appliedDirectivesOf(""requiresScopes"")
              ?.[0]?.arguments()?.[""scopes""]).toStrictEqual(
          [
            ['S1'],
            ['S2', 'S3'],
          ]
      );
    })

    it('propagates @policy from type', () => {
      const subgraph1 = {
        name: 'Subgraph1',
        url: 'https://Subgraph1',
        typeDefs: gql`
          type Query {
            i: I!
          }

          interface I {
            id: ID
          }

          type T implements I @key(fields: ""id"") @policy(policies: [[""P1""]]) {
            id: ID
            vT: String
          }

          type U implements I @key(fields: ""id"") @policy(policies: [[""P2""]]) {
            id: ID
            vU: String
          }

          type V implements I @key(fields: ""id"") {
            id: ID
            vV: String
          }
        `
      }

      const subgraph2 = {
        name: 'Subgraph2',
        url: 'https://Subgraph2',
        typeDefs: gql`
          type Query {
            t: T
          }

          type T @key(fields: ""id"") {
            id: ID!
            other: Int
          }
        `
      }

      const result = composeAsFed2Subgraphs([subgraph1, subgraph2]);
      assertCompositionSuccess(result);
      expect(
          result.schema.type('I')
              ?.appliedDirectivesOf(""policy"")
              ?.[0]?.arguments()?.[""policies""]).toStrictEqual(
          [
            ['P1', 'P2'],
          ]
      );
    })

    it('propagates @authenticated from fields', () => {
      const subgraph1 = {
        name: 'Subgraph1',
        url: 'https://Subgraph1',
        typeDefs: gql`
          type Query {
            i: I!
          }

          interface I {
            id: ID
            i1: Int
            i2: String
            i3: String
          }

          type T1 implements I @key(fields: ""id"") {
            id: ID
            i1: Int
            i2: String @shareable
            i3: String
            value1: String
          }

          type T2 implements I @key(fields: ""id"") {
            id: ID
            i1: Int @authenticated
            i2: String
            i3: String
            value2: String
          }
        `
      }

      const subgraph2 = {
        name: 'Subgraph2',
        url: 'https://Subgraph2',
        typeDefs: gql`
          type Query {
            t: T1
          }

          type T1 @key(fields: ""id"") {
            id: ID!
            i2: String @shareable @authenticated
            other: Int
          }
        `
      }

      const result = composeAsFed2Subgraphs([subgraph1, subgraph2]);
      assertCompositionSuccess(result);
      const i = result.schema.type('I');
      expect(i).toBeDefined();
      expect(i).toBeInstanceOf(InterfaceType);
      const field1 = (i as InterfaceType).field(""i1"");
      const field2 = (i as InterfaceType).field(""i2"");
      expect(field1?.appliedDirectivesOf(""authenticated"")?.[0]).toBeDefined();
      expect(field2?.appliedDirectivesOf(""authenticated"")?.[0]).toBeDefined();
    })

    it('propagates @requiresScopes from field', () => {
      const subgraph1 = {
        name: 'Subgraph1',
        url: 'https://Subgraph1',
        typeDefs: gql`
          type Query {
            i: I!
          }

          interface I {
            id: ID
            i1: Int
            i2: String
            i3: String
          }

          type T1 implements I @key(fields: ""id"") {
            id: ID
            i1: Int @requiresScopes(scopes: [[""S1""]])
            i2: String @shareable
            i3: String
            value1: String
          }

          type T2 implements I @key(fields: ""id"") {
            id: ID
            i1: Int @requiresScopes(scopes: [[""S1"", ""S2""]])
            i2: String
            i3: String
            value2: String
          }

          type T3 implements I @key(fields: ""id"") {
            id: ID
            i1: Int
            i2: String
            i3: String
            value2: String
          }
        `
      }

      const subgraph2 = {
        name: 'Subgraph2',
        url: 'https://Subgraph2',
        typeDefs: gql`
          type Query {
            t: T1
          }

          type T1 @key(fields: ""id"") {
            id: ID!
            i2: String @shareable @requiresScopes(scopes: [[""S3""]])
            other: Int
          }
        `
      }

      const result = composeAsFed2Subgraphs([subgraph1, subgraph2]);
      assertCompositionSuccess(result);
      const i = result.schema.type('I');
      expect(i).toBeDefined();
      expect(i).toBeInstanceOf(InterfaceType);
      const field1 = (i as InterfaceType).field(""i1"");
      expect(field1?.appliedDirectivesOf(""requiresScopes"")
          ?.[0]?.arguments()?.[""scopes""]).toStrictEqual(
          [
            ['S1', 'S2'],
          ]
      );
      const field2 = (i as InterfaceType).field(""i2"");
      expect(field2?.appliedDirectivesOf(""requiresScopes"")
          ?.[0]?.arguments()?.[""scopes""]).toStrictEqual(
          [
            ['S3'],
          ]
      );
    })

    it('propagates @policy on field', () => {
      const subgraph1 = {
        name: 'Subgraph1',
        url: 'https://Subgraph1',
        typeDefs: gql`
          type Query {
            i: I!
          }

          interface I {
            id: ID
            i1: Int
            i2: String
            i3: String
          }

          type T1 implements I @key(fields: ""id"") {
            id: ID
            i1: Int @policy(policies: [[""P1""], [""P2""]])
            i2: String @shareable
            i3: String
            value1: String
          }

          type T2 implements I @key(fields: ""id"") {
            id: ID
            i1: Int @policy(policies: [[""P1""], [""P2"", ""P3""]])
            i2: String
            i3: String
            value2: String
          }

          type T3 implements I @key(fields: ""id"") {
            id: ID
            i1: Int
            i2: String
            i3: String
            value2: String
          }
        `
      }

      const subgraph2 = {
        name: 'Subgraph2',
        url: 'https://Subgraph2',
        typeDefs: gql`
          type Query {
            t: T1
          }

          type T1 @key(fields: ""id"") {
            id: ID!
            i2: String @shareable @policy(policies: [[""P4""]])
            other: Int
          }
        `
      }

      const result = composeAsFed2Subgraphs([subgraph1, subgraph2]);
      assertCompositionSuccess(result);
      const i = result.schema.type('I');
      expect(i).toBeDefined();
      expect(i).toBeInstanceOf(InterfaceType);
      const field1 = (i as InterfaceType).field(""i1"");
      expect(field1?.appliedDirectivesOf(""policy"")
          ?.[0]?.arguments()?.[""policies""]).toStrictEqual(
          [
            ['P1'],
            ['P2', 'P3'],
          ]
      );
      const field2 = (i as InterfaceType).field(""i2"");
      expect(field2?.appliedDirectivesOf(""policy"")
          ?.[0]?.arguments()?.[""policies""]).toStrictEqual(
          [
            ['P4'],
          ]
      );
    })
  });
});",1
"      }
    `;

      expect(buildForErrors(doc, { includeAllImports: true })).toStrictEqual([
        [
          'AUTHENTICATION_APPLIED_ON_INTERFACE',
          `[S] Invalid use of ${directiveName} on field ""I.x"": ${directiveName} cannot be applied on interfaces, interface objects or their fields`,
        ],
        [
          'AUTHENTICATION_APPLIED_ON_INTERFACE',
          `[S] Invalid use of ${directiveName} on interface ""I"": ${directiveName} cannot be applied on interfaces, interface objects or their fields`,
        ],
        [
          'AUTHENTICATION_APPLIED_ON_INTERFACE',
          `[S] Invalid use of ${directiveName} on field ""O.y"": ${directiveName} cannot be applied on interfaces, interface objects or their fields`,
        ],
        [
          'AUTHENTICATION_APPLIED_ON_INTERFACE',
          `[S] Invalid use of ${directiveName} on interface object ""O"": ${directiveName} cannot be applied on interfaces, interface objects or their fields`,
        ],
      ]);
    },
  );
});",1
"  'The maximum number of validation subgraph paths has been exceeded.',
  { addedIn: '2.8.0' },
);

const AUTHENTICATION_APPLIED_ON_INTERFACE = makeCodeDefinition(
    'AUTHENTICATION_APPLIED_ON_INTERFACE',
    'The @authenticated, @requiresScopes and @policy directive cannot be applied on interface, interface object or their fields.',
    { addedIn: '2.9.4' },
);

const MISSING_TRANSITIVE_AUTH_REQUIREMENTS = makeCodeDefinition(
    'MISSING_TRANSITIVE_AUTH_REQUIREMENTS',
    'Field missing transitive @authenticated, @requiresScopes and/or @policy auth requirements needed to access dependent data.',",1
"      validateListSizeAppliedToList(application, parent, errorCollector);
      validateAssumedSizeNotNegative(application, parent, errorCollector);
      validateSlicingArgumentsAreValidIntegers(application, parent, errorCollector);
      validateSizedFieldsAreValidLists(application, parent, errorCollector);
    }

    // Validate @authenticated, @requireScopes and @policy
    validateNoAuthenticationOnInterfaces(metadata, errorCollector);

    return errorCollector;
  }

  validationRules(): readonly SDLValidationRule[] {
    return FEDERATION_VALIDATION_RULES;
  }

  onUnknownDirectiveValidationError(schema: Schema, unknownDirectiveName: string, error: GraphQLError): GraphQLError {
    const metadata = federationMetadata(schema);
    assert(metadata, `This method should only have been called on a subgraph schema`)
    if (ALL_DEFAULT_FEDERATION_DIRECTIVE_NAMES.includes(unknownDirectiveName)) {
      // The directive name is ""unknown"" but it is a default federation directive name. So it means one of a few things
      // happened:
      //  1. it's a fed1 schema but the directive is a fed2 only one (only possible case for fed1 schema).
      //  2. the directive has not been imported at all (so needs to be prefixed for it to work).
      //  3. the directive has an `import`, but it's been aliased to another name.
      if (metadata.isFed2Schema()) {
        const federationFeature = metadata.federationFeature();
        assert(federationFeature, 'Fed2 subgraph _must_ link to the federation feature')
        const directiveNameInSchema = federationFeature.directiveNameInSchema(unknownDirectiveName);
        if (directiveNameInSchema.startsWith(federationFeature.nameInSchema + '__')) {
          // There is no import for that directive
          return withModifiedErrorMessage(
            error,
            `${error.message} If you meant the ""@${unknownDirectiveName}"" federation directive, you should use fully-qualified name ""@${directiveNameInSchema}"" or add ""@${unknownDirectiveName}"" to the \`import\` argument of the @link to the federation specification.`
          );
        } else {
          // There's an import, but it's renamed
          return withModifiedErrorMessage(
            error,
            `${error.message} If you meant the ""@${unknownDirectiveName}"" federation directive, you should use ""@${directiveNameInSchema}"" as it is imported under that name in the @link to the federation specification of this schema.`
          );
        }
      } else {
        return withModifiedErrorMessage(
          error,
          `${error.message} If you meant the ""@${unknownDirectiveName}"" federation 2 directive, note that this schema is a federation 1 schema. To be a federation 2 schema, it needs to @link to the federation specifcation v2.`
        );
      }
    } else if (!metadata.isFed2Schema()) {
      // We could get here in the case where a fed1 schema has tried to use a fed2 directive but mispelled it.
      const suggestions = suggestionList(unknownDirectiveName, ALL_DEFAULT_FEDERATION_DIRECTIVE_NAMES);
      if (suggestions.length > 0) {
        return withModifiedErrorMessage(
          error,
          `${error.message}${didYouMean(suggestions.map((s) => '@' + s))} If so, note that ${suggestions.length === 1 ? 'it is a federation 2 directive' : 'they are federation 2 directives'} but this schema is a federation 1 one. To be a federation 2 schema, it needs to @link to the federation specifcation v2.`
        );
      }
    }
    return error;
  }

  applyDirectivesAfterParsing() {
    return true;
  }
}

function findUnusedNamedForLinkDirective(schema: Schema): string | undefined {
  if (!schema.directive(linkSpec.url.name)) {
    return undefined;
  }

  // The schema already defines a directive named `@link` so we need to use an alias.
  // To keep it simple, we add a number in the end (so we try `@link1`, and if that's taken `@link2`, ...)
  const baseName = linkSpec.url.name;
  const n = 1;
  for (;;) {
    const candidate = baseName + n;
    if (!schema.directive(candidate)) {
      return candidate;
    }
  }
}

export function setSchemaAsFed2Subgraph(schema: Schema, useLatest: boolean = false) {
  let core = schema.coreFeatures;
  let spec: CoreSpecDefinition;
  if (core) {
    spec = core.coreDefinition;
    // We don't accept pre-1.0 @core: this avoid having to care about what the name
    // of the argument below is, and why would be bother?
    assert(spec.url.version.satisfies(linkSpec.version), `Fed2 schema must use @link with version >= 1.0, but schema uses ${spec.url}`);
  } else {
    const alias = findUnusedNamedForLinkDirective(schema);
    const errors = linkSpec.addToSchema(schema, alias);
    if (errors.length > 0) {
      throw ErrGraphQLValidationFailed(errors);
    }
    spec = linkSpec;
    core = schema.coreFeatures;
    assert(core, 'Schema should now be a core schema');
  }

  const fedSpec = useLatest ? latestFederationSpec : autoExpandedFederationSpec;

  assert(!core.getByIdentity(fedSpec.identity), 'Schema already set as a federation subgraph');
  schema.schemaDefinition.applyDirective(
    core.coreItself.nameInSchema,
    {
      // note that there is a mismatch between url and directives that are imported. This is because
      // we want to maintain backward compatibility for those who have already upgraded and we had been upgrading the url to
      // latest, but we never automatically import directives that exist past 2.4
      url: fedSpec.url.toString(),
      import: autoExpandedFederationSpec.directiveSpecs().map((spec) => `@${spec.name}`),
    }
  );
  const errors = completeSubgraphSchema(schema);
  if (errors.length > 0) {
    throw ErrGraphQLValidationFailed(errors);
  }
}

// This is the full @link declaration as added by `asFed2SubgraphDocument`. It's here primarily for uses by tests that print and match
// subgraph schema to avoid having to update 20+ tests every time we use a new directive or the order of import changes ...
export const FEDERATION2_LINK_WITH_FULL_IMPORTS = '@link(url: ""https://specs.apollo.dev/federation/v2.12"", import: [""@key"", ""@requires"", ""@provides"", ""@external"", ""@tag"", ""@extends"", ""@shareable"", ""@inaccessible"", ""@override"", ""@composeDirective"", ""@interfaceObject"", ""@authenticated"", ""@requiresScopes"", ""@policy"", ""@context"", ""@fromContext"", ""@cost"", ""@listSize"", ""@cacheTag""])';
// This is the full @link declaration that is added when upgrading fed v1 subgraphs to v2 version. It should only be used by tests.
export const FEDERATION2_LINK_WITH_AUTO_EXPANDED_IMPORTS = '@link(url: ""https://specs.apollo.dev/federation/v2.12"", import: [""@key"", ""@requires"", ""@provides"", ""@external"", ""@tag"", ""@extends"", ""@shareable"", ""@inaccessible"", ""@override"", ""@composeDirective"", ""@interfaceObject""])';

// This is the federation @link for tests that go through the SchemaUpgrader.
export const FEDERATION2_LINK_WITH_AUTO_EXPANDED_IMPORTS_UPGRADED = '@link(url: ""https://specs.apollo.dev/federation/v2.4"", import: [""@key"", ""@requires"", ""@provides"", ""@external"", ""@tag"", ""@extends"", ""@shareable"", ""@inaccessible"", ""@override"", ""@composeDirective"", ""@interfaceObject""])';

/**
 * Given a document that is assumed to _not_ be a fed2 schema (it does not have a `@link` to the federation spec),
 * returns an equivalent document that `@link` to the last known federation spec.
 *
 * @param document - the document to ""augment"".
 * @param options.addAsSchemaExtension - defines whether the added `@link` is added as a schema extension (`extend schema`) or
 *   added to the schema definition. Defaults to `true` (added as an extension), as this mimics what we tends to write manually.
 * @param options.includeAllImports - defines whether we should auto import ALL latest federation v2 directive definitions or include
 *   only limited set of directives (i.e. federation v2.4 definitions)
 */
export function asFed2SubgraphDocument(document: DocumentNode, options?: { addAsSchemaExtension?: boolean, includeAllImports?: boolean }): DocumentNode {
  const importedDirectives = options?.includeAllImports ? latestFederationSpec.directiveSpecs() : autoExpandedFederationSpec.directiveSpecs();
  const directiveToAdd: ConstDirectiveNode = ({
    kind: Kind.DIRECTIVE,
    name: { kind: Kind.NAME, value: linkDirectiveDefaultName },
    arguments: [
      {
        kind: Kind.ARGUMENT,
        name: { kind: Kind.NAME, value: 'url' },
        value: { kind: Kind.STRING, value: latestFederationSpec.url.toString() }
      },
      {
        kind: Kind.ARGUMENT,
        name: { kind: Kind.NAME, value: 'import' },
        value: { kind: Kind.LIST, values: importedDirectives.map((spec) => ({ kind: Kind.STRING, value: `@${spec.name}` })) }
      }
    ]
  });
  if (options?.addAsSchemaExtension ?? true) {
    return {
      kind: Kind.DOCUMENT,
      loc: document.loc,
      definitions: document.definitions.concat({
        kind: Kind.SCHEMA_EXTENSION,
        directives: [directiveToAdd]
      }),
    }
  }

  // We can't add a new schema definition if it already exists. If it doesn't we need to know if there is a mutation type or
  // not.
  const existingSchemaDefinition = document.definitions.find((d): d is SchemaDefinitionNode => d.kind == Kind.SCHEMA_DEFINITION);
  if (existingSchemaDefinition) {
    return {
      kind: Kind.DOCUMENT,
      loc: document.loc,
      definitions: document.definitions.filter((d) => d !== existingSchemaDefinition).concat([{
        ...existingSchemaDefinition,
        directives: [directiveToAdd].concat(existingSchemaDefinition.directives ?? []),
      }]),
    }
  } else {
    const hasMutation = document.definitions.some((d) => d.kind === Kind.OBJECT_TYPE_DEFINITION && d.name.value === 'Mutation');
    const makeOpType = (opType: OperationTypeNode, name: string): OperationTypeDefinitionNode => ({
      kind: Kind.OPERATION_TYPE_DEFINITION,
      operation: opType,
      type: {
        kind: Kind.NAMED_TYPE,
        name: {
          kind: Kind.NAME,
          value: name,
        }
      },
    });
    return {
      kind: Kind.DOCUMENT,
      loc: document.loc,
      definitions: document.definitions.concat({
        kind: Kind.SCHEMA_DEFINITION,
        directives: [directiveToAdd],
        operationTypes: [ makeOpType(OperationTypeNode.QUERY, 'Query') ].concat(hasMutation ? makeOpType(OperationTypeNode.MUTATION, 'Mutation') : []),
      }),
    }
  }
}

export function printSubgraphNames(names: string[]): string {
  return printHumanReadableList(
    names.map(n => `""${n}""`),
    {
      prefix: 'subgraph',
      prefixPlural: 'subgraphs',
    }
  );
}

export function federationMetadata(schema: Schema): FederationMetadata | undefined {
  return (schema as any)['_federationMetadata'];
}

export function isFederationSubgraphSchema(schema: Schema): boolean {
  return !!federationMetadata(schema);
}

export function isFederationField(field: FieldDefinition<CompositeType>): boolean {
  if (field.parent === field.schema().schemaDefinition.root(""query"")?.type) {
    return FEDERATION_OPERATION_FIELDS.includes(field.name);
  }
  return false;
}

export function isEntityType(type: NamedType): boolean {
  if (!isObjectType(type) && !isInterfaceType(type)) {
    return false;
  }
  const metadata = federationMetadata(type.schema());
  return !!metadata && type.hasAppliedDirective(metadata.keyDirective());
}

export function isInterfaceObjectType(type: NamedType): boolean {
  if (!isObjectType(type)) {
    return false;
  }
  const metadata = federationMetadata(type.schema());
  return !!metadata && metadata.isInterfaceObjectType(type);
}

export function buildSubgraph(
  name: string,
  url: string,
  source: DocumentNode | string,
  withRootTypeRenaming: boolean = true,
): Subgraph {
  const buildOptions = {
    blueprint: new FederationBlueprint(withRootTypeRenaming),
    validate: false,
  };
  let subgraph: Subgraph;
  try {
    const schema = typeof source === 'string'
      ? buildSchema(new Source(source, name), buildOptions)
      : buildSchemaFromAST(source, buildOptions)
    subgraph = new Subgraph(name, url, schema);
  } catch (e) {
    if (e instanceof GraphQLError && name !== FEDERATION_UNNAMED_SUBGRAPH_NAME) {
      throw addSubgraphToError(e, name, ERRORS.INVALID_GRAPHQL);
    } else {
      throw e;
    }
  }
  return subgraph.validate();
}

export function newEmptyFederation2Schema(config?: SchemaConfig): Schema {
  const schema = new Schema(new FederationBlueprint(true), config);
  setSchemaAsFed2Subgraph(schema, true);
  return schema;
}

function completeSubgraphSchema(schema: Schema): GraphQLError[] {
  const coreFeatures = schema.coreFeatures;
  if (coreFeatures) {
    const fedFeature = coreFeatures.getByIdentity(federationIdentity);
    if (fedFeature) {
      return completeFed2SubgraphSchema(schema);
    } else {
      return completeFed1SubgraphSchema(schema);
    }
  } else {
    const fedLink = schema.schemaDefinition.appliedDirectivesOf(linkDirectiveDefaultName).find(isFedSpecLinkDirective);
    if (fedLink) {
      const errors = linkSpec.addToSchema(schema);
      if (errors.length > 0) {
        return errors;
      }
      return completeFed2SubgraphSchema(schema);
    } else {
      return completeFed1SubgraphSchema(schema);
    }
  }
}

function isFedSpecLinkDirective(directive: Directive<SchemaDefinition>): directive is Directive<SchemaDefinition, LinkDirectiveArgs> {
  const args = directive.arguments();
  return directive.name === linkDirectiveDefaultName && args['url'] && (args['url'] as string).startsWith(federationIdentity);
}

function completeFed1SubgraphSchema(schema: Schema): GraphQLError[] {
  // We special case @key, @requires and @provides because we've seen existing user schema where those
  // have been defined in an invalid way, but in a way that fed1 wasn't rejecting. So for convenience,
  // if we detect one of those case, we just remove the definition and let the code afteward add the
  // proper definition back.
  // Note that, in a perfect world, we'd do this within the `SchemaUpgrader`. But the way the code
  // is organised, this method is called before we reach the `SchemaUpgrader`, and it doesn't seem
  // worth refactoring things drastically for that minor convenience.
  for (const name of [FederationDirectiveName.KEY, FederationDirectiveName.PROVIDES, FederationDirectiveName.REQUIRES]) {
    const directive = schema.directive(name);
    if (!directive) {
      continue;
    }

    // We shouldn't have applications at the time of this writing because `completeSubgraphSchema`, which calls this,
    // is only called:
    // 1. during schema parsing, by `FederationBluePrint.onDirectiveDefinitionAndSchemaParsed`, and that is called
    //   before we process any directive applications.
    // 2. by `setSchemaAsFed2Subgraph`, but as the name imply, this trickles to `completeFed2SubgraphSchema`, not
    //   this one method.
    // In other words, there is currently no way to create a full fed1 schema first, and get that method called
    // second. If that changes (no real reason but...), we'd have to modify this because when we remove the
    // definition to re-add the ""correct"" version, we'd have to re-attach existing applications (doable but not
    // done). This assert is so we notice it quickly if that ever happens (again, unlikely, because fed1 schema
    // is a backward compatibility thing and there is no reason to expand that too much in the future).
    assert(directive.applications().size === 0, `${directive} shouldn't have had validation at that places`);

    // The patterns we recognize and ""correct"" (by essentially ignoring the definition)
    // are:
    //  1. if the definition has no arguments at all.
    //  2. if the `fields` argument is declared as nullable.
    //  3. if the `fields` argument type is named ""FieldSet"" instead of ""_FieldSet"".
    //
    // Note that they all correspong to things we've seen in use schema.
    const fieldType = directive.argument('fields')?.type?.toString();
    // Note that to be on the safe side, we check that `fields` is the only argument. That's
    // because while fed2 accepts the optional `resolvable` arg for @key, fed1 only ever
    // accepted that one argument for all those directives. But if the use had definited
    // more arguments _and_ provided value for such extra argument in some applications,
    // us removing the definition would create validation errors that would be hard to
    // understand for the user.
    const fieldTypeIsWrongInKnownWays = !!fieldType
      && directive.arguments().length === 1
      && (fieldType === 'String' || fieldType === '_FieldSet' || fieldType === 'FieldSet');

    if (directive.arguments().length === 0 || fieldTypeIsWrongInKnownWays) {
      directive.remove();
    }
  }

  const errors = FEDERATION1_TYPES.map((spec) => spec.checkOrAdd(schema, FAKE_FED1_CORE_FEATURE_TO_RENAME_TYPES))
    .concat(FEDERATION1_DIRECTIVES.map((spec) => spec.checkOrAdd(schema)))
    .flat();

  return errors.length === 0 ? expandKnownFeatures(schema) : errors;
}

function completeFed2SubgraphSchema(schema: Schema): GraphQLError[] {
  const coreFeatures = schema.coreFeatures;
  assert(coreFeatures, 'This method should not have been called on a non-core schema');

  const fedFeature = coreFeatures.getByIdentity(federationIdentity);
  assert(fedFeature, 'This method should not have been called on a schema with no @link for federation');

  const spec = FEDERATION_VERSIONS.find(fedFeature.url.version);
  if (!spec) {
    return [ERRORS.UNKNOWN_FEDERATION_LINK_VERSION.err(
      `Invalid version ${fedFeature.url.version} for the federation feature in @link directive on schema`,
      { nodes: fedFeature.directive.sourceAST },
    )];
  }

  const errors = spec.addElementsToSchema(schema);
  return errors.length === 0 ? expandKnownFeatures(schema) : errors;
}

function expandKnownFeatures(schema: Schema): GraphQLError[] {
  const coreFeatures = schema.coreFeatures;
  if (!coreFeatures) {
    return [];
  }

  let errors: GraphQLError[] = [];
  for (const feature of coreFeatures.allFeatures()) {
    // We should already have dealt with the core/link spec and federation at this point. Also, we shouldn't have the `join` spec in subgraphs,
    // but some tests play with the idea and currently the join spec is implemented in a way that is not idempotent (it doesn't use
    // `DirectiveSpecification.checkAndAdd`; we should clean it up at some point, but not exactly urgent).
    if (feature === coreFeatures.coreItself || feature.url.identity === federationIdentity  || feature.url.identity === joinIdentity) {
      continue;
    }

    const spec = coreFeatureDefinitionIfKnown(feature.url);
    if (!spec) {
      continue;
    }

    errors = errors.concat(spec.addElementsToSchema(schema));
  }
  return errors;
}

export function parseFieldSetArgument({
  parentType,
  directive,
  fieldAccessor,
  validate,
  decorateValidationErrors = true,
  normalize = false,
}: {
  parentType: CompositeType,
  directive: Directive<SchemaElement<any, any>, {fields: any}>,
  fieldAccessor?: (type: CompositeType, fieldName: string) => FieldDefinition<any> | undefined,
  validate?: boolean,
  decorateValidationErrors?: boolean,
  normalize?: boolean,
}): SelectionSet {
  try {
    const selectionSet = parseSelectionSet({
      parentType,
      source: validateFieldSetValue(directive),
      fieldAccessor,
      validate,
    });
    if (validate ?? true) {
      selectionSet.forEachElement((elt) => {
        if (elt.kind === 'Field' && elt.alias) {
          // Note that this will be caught by the surrounding catch and ""decorated"".
          throw new GraphQLError(`Cannot use alias ""${elt.alias}"" in ""${elt}"": aliases are not currently supported in @${directive.name}`);
        }
      });
    }
    return normalize
      ? selectionSet.normalize({ parentType, recursive: true })
      : selectionSet;
  } catch (e) {
    if (!(e instanceof GraphQLError) || !decorateValidationErrors) {
      throw e;
    }

    throw handleFieldSetValidationError(
      directive,
      e,
      (msg: string) => {
        if (msg.startsWith('Cannot query field')) {
          if (msg.endsWith('.')) {
            msg = msg.slice(0, msg.length - 1);
          }
          if (directive.name === FederationDirectiveName.KEY) {
            msg = msg + ' (the field should either be added to this subgraph or, if it should not be resolved by this subgraph, you need to add it to this subgraph with @external).';
          } else {
            msg = msg + ' (if the field is defined in another subgraph, you need to add it to this subgraph with @external).';
          }
        }
        return msg;
      },
    );
  }
}

export function collectTargetFields({
  parentType,
  directive,
  includeInterfaceFieldsImplementations,
  validate = true,
}: {
  parentType: CompositeType,
  directive: Directive<NamedType | FieldDefinition<CompositeType>, {fields: any}>,
  includeInterfaceFieldsImplementations: boolean,
  validate?: boolean,
}): FieldDefinition<CompositeType>[] {
  const fields: FieldDefinition<CompositeType>[] = [];
  try {
    parseFieldSetArgument({
      parentType,
      directive,
      fieldAccessor: (t, f) => {
        const field = t.field(f);
        if (field) {
          fields.push(field);
          if (includeInterfaceFieldsImplementations && isInterfaceType(t)) {
            for (const implType of t.possibleRuntimeTypes()) {
              const implField = implType.field(f);
              if (implField) {
                fields.push(implField);
              }
            }
          }
        }
        return field;
      },
      validate,
    });
  } catch (e) {
    // If we explicitly requested no validation, then we shouldn't throw a (graphQL) error, but if we do, we swallow it
    // (returning a partial result, but we assume it is fine).
    const isGraphQLError = errorCauses(e) !== undefined
    if (!isGraphQLError || validate) {
      throw e;
    }
  }
  return fields;
}

function validateFieldSetValue(directive: Directive<SchemaElement<any, any>, {fields: any}>): string {
  const fields = directive.arguments().fields;
  const nodes = directive.sourceAST;
  if (typeof fields !== 'string') {
    throw ERROR_CATEGORIES.DIRECTIVE_INVALID_FIELDS_TYPE.get(directive.name).err(
      `Invalid value for argument ""${directive.definition!.argument('fields')!.name}"": must be a string.`,
      { nodes },
    );
  }
  // While validating if the field is a string will work in most cases, this will not catch the case where the field argument was
  // unquoted but parsed as an enum value (see federation/issues/850 in particular). So if we have the AST (which we will usually
  // have in practice), use that to check that the argument was truly a string.
  if (nodes && nodes.kind === 'Directive') {
    for (const argNode of nodes.arguments ?? []) {
      if (argNode.name.value === 'fields') {
        if (argNode.value.kind !== 'StringValue') {
          throw ERROR_CATEGORIES.DIRECTIVE_INVALID_FIELDS_TYPE.get(directive.name).err(
            `Invalid value for argument ""${directive.definition!.argument('fields')!.name}"": must be a string.`,
            { nodes },
          );
        }
        break;
      }
    }
  }

  return fields;
}

export interface ServiceDefinition {
  typeDefs: DocumentNode;
  name: string;
  url?: string;
}
export function subgraphsFromServiceList(serviceList: ServiceDefinition[]): Subgraphs | GraphQLError[] {
  let errors: GraphQLError[] = [];
  const subgraphs = new Subgraphs();
  for (const service of serviceList) {
    try {
      subgraphs.add(buildSubgraph(service.name, service.url ?? '', service.typeDefs));
    } catch (e) {
      const causes = errorCauses(e);
      if (causes) {
        errors = errors.concat(causes);
      } else {
        throw e;
      }
    }
  }
  return errors.length === 0 ? subgraphs : errors;
}

// Simple wrapper around a Subgraph[] that ensures that 1) we never mistakenly get 2 subgraph with the same name,
// 2) keep the subgraphs sorted by name (makes iteration more predictable). It also allow convenient access to
// a subgraph by name so behave like a map<string, Subgraph> in most ways (but with the previously mentioned benefits).
export class Subgraphs {
  private readonly subgraphs = new OrderedMap<string, Subgraph>();

  add(subgraph: Subgraph): Subgraph {
    if (this.subgraphs.has(subgraph.name)) {
      throw new Error(`A subgraph named ${subgraph.name} already exists` + (subgraph.url ? ` (with url '${subgraph.url}')` : ''));
    }

    this.subgraphs.add(subgraph.name, subgraph);
    return subgraph;
  }

  get(name: string): Subgraph | undefined {
    return this.subgraphs.get(name);
  }

  size(): number {
    return this.subgraphs.size;
  }

  names(): readonly string[] {
    return this.subgraphs.keys();
  }

  values(): readonly Subgraph[] {
    return this.subgraphs.values();
  }

  *[Symbol.iterator]() {
    for (const subgraph of this.subgraphs) {
      yield subgraph;
    }
  }

  validate(): GraphQLError[] | undefined {
    let errors: GraphQLError[] = [];
    for (const subgraph of this.values()) {
      try {
        subgraph.validate();
      } catch (e) {
        const causes = errorCauses(e);
        if (!causes) {
          throw e;
        }
        errors = errors.concat(causes);
      }
    }
    return errors.length === 0 ? undefined : errors;
  }

  toString(): string {
    return '[' + this.subgraphs.keys().join(', ') + ']'
  }
}

export const anyTypeSpec = createScalarTypeSpecification({ name: '_Any' });

export const serviceTypeSpec = createObjectTypeSpecification({
  name: '_Service',
  fieldsFct: (schema) => [{ name: 'sdl', type: schema.stringType() }],
});

export const entityTypeSpec = createUnionTypeSpecification({
  name: '_Entity',
  membersFct: (schema) => {
    // Please note that `_Entity` cannot use ""interface entities"" since interface types cannot be in unions.
    // It is ok in practice because _Entity is only use as return type for `_entities`, and even when interfaces
    // are involve, the result of an `_entities` call will always be an object type anyway, and since we force
    // all implementations of an interface entity to be entity themselves in a subgraph, we're fine.
    return schema.objectTypes().filter(isEntityType).map((t) => t.name);
  },
});

export const FEDERATION_OPERATION_TYPES = [ anyTypeSpec, serviceTypeSpec, entityTypeSpec ];

export const serviceFieldName = '_service';
export const entitiesFieldName = '_entities';

export const FEDERATION_OPERATION_FIELDS: readonly string[] = [ serviceFieldName, entitiesFieldName ];

export class Subgraph {
  constructor(
    readonly name: string,
    readonly url: string,
    readonly schema: Schema,
  ) {
    if (name === FEDERATION_RESERVED_SUBGRAPH_NAME) {
      throw ERRORS.INVALID_SUBGRAPH_NAME.err(`Invalid name ${FEDERATION_RESERVED_SUBGRAPH_NAME} for a subgraph: this name is reserved`);
    }
  }

  metadata(): FederationMetadata {
    const metadata = federationMetadata(this.schema);
    assert(metadata, 'The subgraph schema should have built with the federation built-ins.');
    return metadata;
  }

  isFed2Subgraph(): boolean {
    return this.metadata().isFed2Schema();
  }

  // Adds the _entities and _service fields to the root query type.
  private addFederationOperations() {
    const metadata = this.metadata();

    for (const type of FEDERATION_OPERATION_TYPES) {
      type.checkOrAdd(this.schema);
    }

    const queryRoot = this.schema.schemaDefinition.root(""query"");
    const queryType = queryRoot ? queryRoot.type : this.schema.addType(new ObjectType(""Query""));

    const entityField = queryType.field(entitiesFieldName);
    const entityType = metadata.entityType();
    if (entityType) {
      const entityFieldType = new NonNullType(new ListType(entityType));
      if (!entityField) {
        queryType.addField(entitiesFieldName, entityFieldType)
          .addArgument('representations', new NonNullType(new ListType(new NonNullType(metadata.anyType()))));
      } else if (!entityField.type) {
        // This can happen when the schema had an empty redefinition of _Entity as we've removed it in
        // that clear and that would have clear the type of the correspond field. Let's re-populate it
        // in that case.
        entityField.type = entityType;
      }
    } else if (entityField) {
      entityField.remove();
    }

    if (!queryType.field(serviceFieldName)) {
      queryType.addField(serviceFieldName, new NonNullType(metadata.serviceType()));
    }
  }

  /**
   * Same as `Schema.assumeValid`. Use carefully.
   */
  assumeValid(): Subgraph {
    this.addFederationOperations();
    this.schema.assumeValid();
    return this;
  }

  validate(): Subgraph {
    try {
      this.addFederationOperations();
      this.schema.validate();
      return this;
    } catch (e) {
      if (e instanceof GraphQLError) {
        // Note that `addSubgraphToError` only adds the provided code if the original error
        // didn't have one, and the only one that will not have a code are GraphQL errors
        // (since we assign specific codes to the federation errors).
        throw addSubgraphToError(e, this.name, ERRORS.INVALID_GRAPHQL);
      } else {
        throw e;
      }
    }
  }

  private isPrintedDirective(d: DirectiveDefinition): boolean {
    if (this.metadata().allFederationDirectives().includes(d)) {
      return false;
    }

    const core = this.schema.coreFeatures;
    return !core || core.sourceFeature(d)?.feature.url.identity !== linkIdentity;
  }

  private isPrintedType(t: NamedType): boolean {
    if (this.metadata().allFederationTypes().includes(t)) {
      return false;
    }

    // If the query type only have our federation specific fields, then that (almost surely) means the original subgraph
    // had no Query type and so we save printing it.
    if (isObjectType(t) && t.isQueryRootType() && t.fields().filter((f) => !isFederationField(f)).length === 0) {
      return false;
    }

    const core = this.schema.coreFeatures;
    return !core || core.sourceFeature(t)?.feature.url.identity !== linkIdentity;
  }

  private isPrintedDirectiveApplication(d: Directive): boolean {
    // We print almost all directive application, but the one we skip is the `@link` to the link spec itself.
    // The reason is that it is one of the things that usually not provided by users but is instead auto-added
    // and so this keep the output a tad ""cleaner"".
    // Do note that it is only auto-added if it uses the `@link` name. If it is renamed, we need to include
    // the application (and more generally, if there is more argument set than just the url, we print
    // the directive to make sure we're not hidding something relevant).
    if (!this.schema.coreFeatures || d.name !== linkSpec.url.name) {
      return true;
    }
    const args = d.arguments();
    let urlArg: FeatureUrl | undefined = undefined;
    if ('url' in args) {
      try {
        urlArg = FeatureUrl.parse(args['url']);
      } catch (e) {
        // ignored on purpose: if the 'url' arg don't parse properly as a Feature url, then `urlArg` will
        // be `undefined` which we want.
      }
    }
    const isDefaultLinkToLink = urlArg?.identity === linkIdentity && Object.keys(args).length === 1;
    return !isDefaultLinkToLink;
  }

  /**
   * Returns a representation of the subgraph without any auto-imported directive definitions or ""federation private""
   * types and fiels (`_service` et al.).
   *
   * In other words, this will correspond to what a user would usually write.
   *
   * Note that if one just want a representation of the full schema, then it can simply call `printSchema(this.schema)`.
   */
  toString(basePrintOptions: PrintOptions = defaultPrintOptions) {
    return printSchema(
      this.schema,
      {
        ...basePrintOptions,
        directiveDefinitionFilter: (d) => this.isPrintedDirective(d),
        typeFilter: (t) => this.isPrintedType(t),
        fieldFilter: (f) => !isFederationField(f),
        directiveApplicationFilter: (d) => this.isPrintedDirectiveApplication(d),
      }
    );
  }
}

export type SubgraphASTNode = ASTNode & { subgraph: string };

export function addSubgraphToASTNode(node: ASTNode, subgraph: string): SubgraphASTNode {
  // We won't override a existing subgraph info: it's not like the subgraph an ASTNode can come
  // from can ever change and this allow the provided to act as a ""default"" rather than a
  // hard setter, which is convenient in `addSubgraphToError` below if some of the AST of
  // the provided error already have a subgraph ""origin"".
  if ('subgraph' in (node as any)) {
    return node as SubgraphASTNode;
  }
  return {
    ...node,
    subgraph
  };
}

export function addSubgraphToError(e: GraphQLError, subgraphName: string, errorCode?: ErrorCodeDefinition): GraphQLError {
  const updatedCauses = errorCauses(e)!.map(cause => {
    const message = `[${subgraphName}] ${cause.message}`;
    const nodes = cause.nodes
      ? cause.nodes.map(node => addSubgraphToASTNode(node, subgraphName))
      : undefined;

    const code = errorCodeDef(cause) ?? errorCode;
    const options: GraphQLErrorOptions = {
      ...extractGraphQLErrorOptions(cause),
      nodes,
      originalError: cause,
    };

    return code
      ? code.err(message, options)
      : new GraphQLError(message, options);
  });

  return updatedCauses.length === 1 ? updatedCauses[0] : ErrGraphQLValidationFailed(updatedCauses);
}

class ExternalTester {
  private readonly fakeExternalFields = new Set<string>();
  private readonly providedFields = new Set<string>();
  private readonly externalDirective: DirectiveDefinition<{}>;
  private readonly externalFieldsOnType = new Set<string>();

  constructor(readonly schema: Schema, private readonly isFed2Schema: boolean) {
    this.externalDirective = this.metadata().externalDirective();
    this.collectFakeExternals();
    this.collectProvidedFields();
    this.collectExternalsOnType();
  }

  private metadata(): FederationMetadata {
    const metadata = federationMetadata(this.schema);
    assert(metadata, 'Schema should be a subgraphs schema');
    return metadata;
  }

  private collectFakeExternals() {
    const metadata = this.metadata();
    const extendsDirective =  metadata.extendsDirective();
    for (const key of metadata.keyDirective().applications()) {
      const parentType = key.parent as CompositeType;
      if (!(key.ofExtension() || parentType.hasAppliedDirective(extendsDirective))) {
        continue;
      }
      collectTargetFields({
        parentType,
        directive: key as Directive<any, {fields: any}>,
        includeInterfaceFieldsImplementations: false,
        validate: false,
      }).filter((field) => field.hasAppliedDirective(this.externalDirective))
        .forEach((field) => this.fakeExternalFields.add(field.coordinate));
    }
  }

  private collectProvidedFields() {
    for (const provides of this.metadata().providesDirective().applications()) {
      const parent = provides.parent as FieldDefinition<CompositeType>;
      const parentType = baseType(parent.type!);
      // If `parentType` is not a composite, that means an invalid @provides, but we ignore such errors
      // for now (also why we pass 'validate: false'). Proper errors will be thrown later during validation.
      if (isCompositeType(parentType)) {
        collectTargetFields({
          parentType,
          directive: provides as Directive<any, {fields: any}>,
          includeInterfaceFieldsImplementations: true,
          validate: false,
        }).forEach((f) => this.providedFields.add(f.coordinate));
      }
    }
  }

  private collectExternalsOnType() {
    // We do not collect @external on types for fed1 schema since those will be discarded by the schema upgrader.
    // The schema upgrader, through calls to `isExternal`, relies on the populated `externalFieldsOnType` object to
    // inform when @shareable should be automatically added. In the fed1 case, if the map is populated then @shareable won't
    // be added in places where it should have.
    if (!this.isFed2Schema) {
      return;
    }

    for (const type of this.schema.objectTypes()) {
      if (type.hasAppliedDirective(this.externalDirective)) {
        for (const field of type.fields()) {
          this.externalFieldsOnType.add(field.coordinate);
        }
      }
    }
  }

  isExternal(field: FieldDefinition<any> | InputFieldDefinition) {
    return (field.hasAppliedDirective(this.externalDirective) || this.externalFieldsOnType.has(field.coordinate)) && !this.isFakeExternal(field);
  }

  isFakeExternal(field: FieldDefinition<any> | InputFieldDefinition) {
    return this.fakeExternalFields.has(field.coordinate);
  }

  selectsAnyExternalField(selectionSet: SelectionSet): boolean {
    for (const selection of selectionSet.selections()) {
      if (selection.kind === 'FieldSelection' && this.isExternal(selection.element.definition)) {
        return true;
      }
      if (selection.selectionSet) {
        if (this.selectsAnyExternalField(selection.selectionSet)) {
          return true;
        }
      }
    }
    return false;
  }

  isPartiallyExternal(field: FieldDefinition<any> | InputFieldDefinition) {
    return this.isExternal(field) && this.providedFields.has(field.coordinate);
  }

  isFullyExternal(field: FieldDefinition<any> | InputFieldDefinition) {
    return this.isExternal(field) && !this.providedFields.has(field.coordinate);
  }
}

export type ProvidesOrRequiresApplication = Directive<FieldDefinition<ObjectType | InterfaceType>, {fields: any}>

/*
 * It makes no sense to have a @provides/@requires on a non-external leaf field, and we usually reject it during schema
 * validation but this method allows to remove those for:
 *  1. when we extract subgraphs from a fed 1 supergraph, where such validation hadn't been run.
 *  2. for the fed 1 -> fed 2 upgader code.
 *
 * The reason we do this (and generally reject it) is that such provides/requires have a negative impact on later query
 * planning, because it sometimes make us to try type-exploding some interfaces unecessarily. Besides, if a use add
 * something useless, there is a change it hasn't fully understood something, and warning it about that fact through
 * an error is more helpful.
 */
export function removeInactiveProvidesAndRequires(
  schema: Schema,
  onModified: (field: FieldDefinition<any>, original: ProvidesOrRequiresApplication, updated?: ProvidesOrRequiresApplication) => void = () => {},
) {
  const metadata = federationMetadata(schema);
  if (!metadata) {
    return;
  }
  const providesDirective = metadata.providesDirective();
  const requiresDirective = metadata.requiresDirective();

  for (const type of schema.types()) {
    if (!isObjectType(type) && !isInterfaceType(type)) {
      continue;
    }

    for (const field of type.fields()) {
      const fieldBaseType = baseType(field.type!) as CompositeType;
      removeInactiveApplications(providesDirective, field, fieldBaseType, onModified);
      removeInactiveApplications(requiresDirective, field, type, onModified);
    }
  }
}

function removeInactiveApplications(
  directiveDefinition: DirectiveDefinition<{fields: any}>,
  field: FieldDefinition<any>,
  parentType: CompositeType,
  onModified: (field: FieldDefinition<any>, original: ProvidesOrRequiresApplication, updated?: ProvidesOrRequiresApplication) => void
) {
  for (const application of field.appliedDirectivesOf(directiveDefinition)) {
    let selection;
    try {
      selection = parseFieldSetArgument({parentType, directive: application});
    } catch (e) {
      // This method is sometimes called on federation directives that haven't been validated, and so parsing the
      // `fields` argument may throw. In that case, we just silently ignore that particular directive application:
      // it's not the job of this method to do validation, but we will always validate things in other places
      // when needed so whatever error that directive has will be caught in a more appropriate place.
      continue;
    }
    if (selectsNonExternalLeafField(selection)) {
      application.remove();
      const updated = withoutNonExternalLeafFields(selection);
      if (!updated.isEmpty()) {
        const updatedDirective = field.applyDirective(directiveDefinition, { fields: updated.toString(true, false) });
        onModified(field, application, updatedDirective);
      } else {
        onModified(field, application);
      }
    }
  }
}

function isExternalOrHasExternalImplementations(field: FieldDefinition<CompositeType>): boolean {
  const metadata = federationMetadata(field.schema());
  if (!metadata) {
    return false;
  }
  if (field.hasAppliedDirective(metadata.externalDirective())) {
    return true;
  }
  const parentType = field.parent;
  if (isInterfaceType(parentType)) {
    for (const implem of parentType.possibleRuntimeTypes()) {
      const fieldInImplem = implem.field(field.name);
      if (fieldInImplem && fieldInImplem.hasAppliedDirective(metadata.externalDirective())) {
        return true;
      }
    }
  }
  return false;
}

function selectsNonExternalLeafField(selection: SelectionSet): boolean {
  return selection.selections().some(s => {
    if (s.kind === 'FieldSelection') {
      // If it's external, we're good and don't need to recurse.
      if (isExternalOrHasExternalImplementations(s.element.definition)) {
        return false;
      }
      // Otherwise, we select a non-external if it's a leaf, or the sub-selection does.
      return !s.selectionSet || selectsNonExternalLeafField(s.selectionSet);
    } else {
      return selectsNonExternalLeafField(s.selectionSet);
    }
  });
}

function withoutNonExternalLeafFields(selectionSet: SelectionSet): SelectionSet {
  return selectionSet.lazyMap((selection) => {
    if (selection.kind === 'FieldSelection') {
      if (isExternalOrHasExternalImplementations(selection.element.definition)) {
        // That field is external, so we can add the selection back entirely.
        return selection;
      }
    }
    if (selection.selectionSet) {
      // Note that for fragments this will always be true (and we just recurse), while
      // for fields, we'll only get here if the field is not external, and so
      // we want to add the selection only if it's not a leaf and even then, only
      // the part where we've recursed.
      const updated = withoutNonExternalLeafFields(selection.selectionSet);
      if (!updated.isEmpty()) {
        return selection.withUpdatedSelectionSet(updated);
      }
    }
    // We skip that selection.
    return undefined;
  });
}

function validateNoAuthenticationOnInterfaces(metadata: FederationMetadata, errorCollector: GraphQLError[]) {
  const authenticatedDirective = metadata.authenticatedDirective();
  const requiresScopesDirective = metadata.requiresScopesDirective();
  const policyDirective = metadata.policyDirective();
  [authenticatedDirective, requiresScopesDirective, policyDirective].forEach((directive) => {
    for (const application of directive.applications()) {
      const element = application.parent;
      function isAppliedOnInterface(type: Type) {
        return isInterfaceType(type) || isInterfaceObjectType(baseType(type));
      }
      function isAppliedOnInterfaceField(elem: SchemaElement<any, any>) {
        return isFieldDefinition(elem) && isAppliedOnInterface(elem.parent);
      }

      if (isAppliedOnInterface(element) || isAppliedOnInterfaceField(element)) {
        let kind = '';
        switch (element.kind) {
          case 'FieldDefinition':
            kind = 'field';
            break;
          case 'InterfaceType':
            kind = 'interface';
            break;
          case 'ObjectType':
            kind = 'interface object';
            break;
        }
        errorCollector.push(ERRORS.AUTHENTICATION_APPLIED_ON_INTERFACE.err(
            `Invalid use of @${directive.name} on ${kind} ""${element.coordinate}"": @${directive.name} cannot be applied on interfaces, interface objects or their fields`,
            {nodes: sourceASTs(application, element.parent)},
        ));
      }
    }
  });
}",1
"<script setup lang=""ts"">
import api from '@/api';
import { useCollectionsStore } from '@/stores/collections';
import { unexpectedError } from '@/utils/unexpected-error';
import EditorJS from '@editorjs/editorjs';
import { cloneDeep, isEqual } from 'lodash';
import { onMounted, onUnmounted, ref, watch } from 'vue';
import { useI18n } from 'vue-i18n';
import { useRouter } from 'vue-router';
import { useBus } from './bus';
import getTools from './tools';
import { useFileHandler } from './use-file-handler';

import './editorjs-overrides.css';

// https://github.com/codex-team/editor.js/blob/057bf17a6fc2d5e05c662107918d7c3e943d077c/src/components/events/RedactorDomChanged.ts#L4
const RedactorDomChanged = 'redactor dom changed';

const props = withDefaults(
	defineProps<{
		disabled?: boolean;
		autofocus?: boolean;
		value?: Record<string, any> | null;
		bordered?: boolean;
		placeholder?: string;
		tools?: string[];
		folder?: string;
		font?: 'sans-serif' | 'monospace' | 'serif';
	}>(),
	{
		value: null,
		bordered: true,
		tools: () => ['header', 'nestedlist', 'code', 'image', 'paragraph', 'checklist', 'quote', 'underline'],
		font: 'sans-serif',
	},
);

const bus = useBus();

const emit = defineEmits<{ input: [value: EditorJS.OutputData | null] }>();

const { t } = useI18n();

const collectionStore = useCollectionsStore();

const { currentPreview, setCurrentPreview, fileHandler, setFileHandler, unsetFileHandler, handleFile } =
	useFileHandler();

const editorjsRef = ref<EditorJS>();
const editorjsIsReady = ref(false);
const uploaderComponentElement = ref<HTMLElement>();
const editorElement = ref<HTMLElement>();
const haveFilesAccess = Boolean(collectionStore.getCollection('directus_files'));
const haveValuesChanged = ref(false);
const router = useRouter();

const tools = getTools(
	{
		baseURL: api.defaults.baseURL,
		setFileHandler,
		setCurrentPreview,
		getUploadFieldElement: () => uploaderComponentElement,
	},
	props.tools,
	haveFilesAccess,
);

bus.on(async (event) => {
	if (event.type === 'open-url') {
		router.push(event.payload);
	}
});

onMounted(async () => {
	editorjsRef.value = new EditorJS({
		logLevel: 'ERROR' as EditorJS.LogLevels,
		holder: editorElement.value,
		readOnly: false,
		placeholder: props.placeholder,
		minHeight: 72,
		onChange: (api) => emitValue(api),
		tools: tools,
	});

	await editorjsRef.value.isReady;

	const sanitizedValue = sanitizeValue(props.value);

	if (sanitizedValue) {
		await editorjsRef.value.render(sanitizedValue);
	}

	if (props.autofocus) {
		editorjsRef.value.focus();
	}

	editorjsRef.value.on(RedactorDomChanged, () => {
		emitValue(editorjsRef.value!);
	});

	editorjsIsReady.value = true;
});

onUnmounted(() => {
	editorjsRef.value?.destroy();
	bus.reset();
});

watch(
	() => props.value,
	async (newVal, oldVal) => {
		// First value will be set in 'onMounted'
		if (!editorjsRef.value || !editorjsIsReady.value) return;

		if (haveValuesChanged.value) {
			haveValuesChanged.value = false;
			return;
		}

		if (isEqual(newVal?.blocks, oldVal?.blocks)) return;

		try {
			const sanitizedValue = sanitizeValue(newVal);

			if (sanitizedValue) {
				await editorjsRef.value.render(sanitizedValue);
			} else {
				editorjsRef.value.clear();
			}
		} catch (error) {
			unexpectedError(error);
		}
	},
);

async function emitValue(context: EditorJS.API | EditorJS) {
	if (props.disabled || !context || !context.saver) return;

	try {
		const result = await context.saver.save();

		haveValuesChanged.value = true;

		if (!result || result.blocks.length < 1) {
			emit('input', null);
			return;
		}

		if (isEqual(result.blocks, props.value?.blocks)) return;

		emit('input', result);
	} catch (error) {
		unexpectedError(error);
	}
}

function sanitizeValue(value: any): EditorJS.OutputData | null {
	if (!value || typeof value !== 'object' || !value.blocks || value.blocks.length < 1) return null;

	return cloneDeep({
		time: value?.time || Date.now(),
		version: value?.version || '0.0.0',
		blocks: value.blocks,
	});
}
</script>

<template>
	<div class=""input-block-editor"">
		<div ref=""editorElement"" :class=""{ [font]: true, disabled, bordered }""></div>
",1
"							collection: { _eq: collection },
							field: { _eq: field },
						},
					},
					{ emitEvents: false },
				);
			});

			const actionEvent = {
				event: 'fields.delete',
				meta: {
					payload: [field],",1
"/**
 * Check if requested collection exists, and save it to req.collection
 */

import type { RequestHandler } from 'express';
import { ForbiddenError } from '@directus/errors';
import { systemCollectionRows } from '@directus/system-data';
import asyncHandler from '../utils/async-handler.js';

const collectionExists: RequestHandler = asyncHandler(async (req, _res, next) => {
	if (!req.params['collection']) return next();

	if (req.params['collection'] in req.schema.collections === false) {
		throw new ForbiddenError();
	}

	req.collection = req.params['collection'];

	const systemCollectionRow = systemCollectionRows.find((collection) => {
		return collection?.collection === req.collection;",1
"import { ForbiddenError } from '@directus/errors';
import type { Accountability, Filter, Item, PermissionsAction } from '@directus/types';
import { parseFilter, validatePayload } from '@directus/utils';
import { FailedValidationError, joiValidationErrorItemToErrorExtensions } from '@directus/validation';
import { assign, difference, uniq } from 'lodash-es';
import { fetchPermissions } from '../../lib/fetch-permissions.js';
import { fetchPolicies } from '../../lib/fetch-policies.js';
import type { Context } from '../../types.js';
import { extractRequiredDynamicVariableContext } from '../../utils/extract-required-dynamic-variable-context.js';
import { fetchDynamicVariableData } from '../../utils/fetch-dynamic-variable-data.js';
import { contextHasDynamicVariables } from '../process-ast/utils/context-has-dynamic-variables.js';
import { isFieldNullable } from './lib/is-field-nullable.js';

export interface ProcessPayloadOptions {
	accountability: Accountability;
	action: PermissionsAction;
	collection: string;
	payload: Item;
	nested: string[];
}

/**
 * @note this only validates the top-level fields. The expectation is that this function is called
 * for each level of nested insert separately
 */
export async function processPayload(options: ProcessPayloadOptions, context: Context) {
	let permissions;
	let permissionValidationRules: (Filter | null)[] = [];

	let policies: string[] = [];

	if (!options.accountability.admin) {
		policies = await fetchPolicies(options.accountability, context);

		permissions = await fetchPermissions(
			{ action: options.action, policies, collections: [options.collection], accountability: options.accountability },
			context,
		);

		if (permissions.length === 0) {
			throw new ForbiddenError({
				reason: `You don't have permission to ""${options.action}"" from collection ""${options.collection}"" or it does not exist.`,
			});
		}

		const fieldsAllowed = uniq(permissions.map(({ fields }) => fields ?? []).flat());

		if (fieldsAllowed.includes('*') === false) {
			const fieldsUsed = Object.keys(options.payload);
			const notAllowed = difference(fieldsUsed, fieldsAllowed);

			if (notAllowed.length > 0) {
				const fieldStr = notAllowed.map((field) => `""${field}""`).join(', ');

				throw new ForbiddenError({
					reason:
						notAllowed.length === 1
							? `You don't have permission to access field ${fieldStr} in collection ""${options.collection}"" or it does not exist.`
							: `You don't have permission to access fields ${fieldStr} in collection ""${options.collection}"" or they do not exist.`,
				});
			}
		}

		permissionValidationRules = permissions.map(({ validation }) => validation);
	}
",1
"import { ForbiddenError } from '@directus/errors';
import type { Accountability, PermissionsAction, PrimaryKey } from '@directus/types';
import type { Context } from '../../types.js';
import { validateCollectionAccess } from './lib/validate-collection-access.js';
import { validateItemAccess } from './lib/validate-item-access.js';

export interface ValidateAccessOptions {
	accountability: Accountability;
	action: PermissionsAction;
	collection: string;
	primaryKeys?: PrimaryKey[];
	fields?: string[];
	skipCollectionExistsCheck?: boolean;
}

/**
 * Validate if the current user has access to perform action against the given collection and
 * optional primary keys. This is done by reading the item from the database using the access
 * control rules and checking if we got the expected result back
 */
export async function validateAccess(options: ValidateAccessOptions, context: Context) {
	// Skip further validation if the collection does not exist
	if (!options.skipCollectionExistsCheck && options.collection in context.schema.collections === false) {
		throw new ForbiddenError({
			reason: `You don't have permission to ""${options.action}"" from collection ""${options.collection}"" or it does not exist.`,
		});
	}

	if (options.accountability.admin === true) {
		return;
	}
",1
"	.collection('test', (c) => {
		c.field('id').uuid().primary();
		c.field('text').text();
		c.field('string').string();
		c.field('float').float();
		c.field('integer').integer();
	})
	.build();

const permissions = [
	{
		collection: 'test',
		action: 'read',
		fields: ['text', 'float', 'integer', 'id'],
		permissions: {
			text: {},
		},
	},
] as unknown as Permission[];

for (const number of ['0x56071c902718e681e274DB0AaC9B4Ed2d027924d', '0b11111', '0.42e3', 'Infinity', '42.000']) {
	test(`Prevent ${number} from being cast to number`, async () => {
		const db = vi.mocked(knex.default({ client: Client_SQLite3 }));
		const queryBuilder = db.queryBuilder();

		applySearch(db as any, schema, queryBuilder, number, 'test', {}, permissions);

		const rawQuery = queryBuilder.toSQL();

		expect(rawQuery.sql).toEqual(`select * where ((LOWER(""test"".""text"") LIKE ?))`);
		expect(rawQuery.bindings).toEqual([`%${number.toLowerCase()}%`]);
	});
}

for (const number of ['1234', '-128', '12.34']) {
	test(`Casting number ${number}`, async () => {
		const db = vi.mocked(knex.default({ client: Client_SQLite3 }));
		const queryBuilder = db.queryBuilder();

		applySearch(db as any, schema, queryBuilder, number, 'test', {}, permissions);

		const rawQuery = queryBuilder.toSQL();

		expect(rawQuery.sql).toEqual(
			`select * where ((LOWER(""test"".""text"") LIKE ?) or (""test"".""float"" = ?) or (""test"".""integer"" = ?))`,
		);

		expect(rawQuery.bindings).toEqual([`%${number.toLowerCase()}%`, Number(number), Number(number)]);
	});
}

test(`Query is falsy if no other clause is added`, async () => {
	const db = vi.mocked(knex.default({ client: Client_SQLite3 }));
	const queryBuilder = db.queryBuilder();

	const schema = new SchemaBuilder()
		.collection('test', (c) => {
			c.field('id').uuid().primary();
			c.field('string').string();
			c.field('float').float();
			c.field('integer').integer();
		})
		.build();

	applySearch(db as any, schema, queryBuilder, 'searchstring', 'test', {}, permissions);

	const rawQuery = queryBuilder.toSQL();

	expect(rawQuery.sql).toEqual(`select * where (1 = 0)`);
	expect(rawQuery.bindings).toEqual([]);
});

test(`Exclude non uuid searchable field(s) when searchQuery has valid uuid value`, async () => {
	const db = vi.mocked(knex.default({ client: Client_SQLite3 }));
	const queryBuilder = db.queryBuilder();

	applySearch(db as any, schema, queryBuilder, '4b9adc65-4ad8-4242-9144-fbfc58400d74', 'test', {}, [
		{
			collection: 'test',
			action: 'read',
			fields: ['id', 'text'],
			permissions: null,
		} as unknown as Permission,
	]);

	const rawQuery = queryBuilder.toSQL();

	expect(rawQuery.sql).toEqual(`select * where ((""test"".""id"" = ?) or (LOWER(""test"".""text"") LIKE ?))`);
	expect(rawQuery.bindings).toEqual(['4b9adc65-4ad8-4242-9144-fbfc58400d74', '%4b9adc65-4ad8-4242-9144-fbfc58400d74%']);
});

test(`Remove forbidden field(s) from search`, async () => {
	const db = vi.mocked(knex.default({ client: Client_SQLite3 }));
	const queryBuilder = db.queryBuilder();

	applySearch(db as any, schema, queryBuilder, 'directus', 'test', {}, [
		{
			collection: 'test',
			action: 'read',
			fields: ['string'],
			permissions: {
				text: {},
			},
		} as unknown as Permission,
	]);

	const rawQuery = queryBuilder.toSQL();

	expect(rawQuery.sql).toEqual(`select * where ((LOWER(""test"".""string"") LIKE ?))`);
	expect(rawQuery.bindings).toEqual(['%directus%']);
});

test(`Add all fields for * field rule`, async () => {
	const db = vi.mocked(knex.default({ client: Client_SQLite3 }));
	const queryBuilder = db.queryBuilder();

	applySearch(db as any, schema, queryBuilder, '1', 'test', {}, [
		{",1
"
	const allowedFields = new Set(permissions.filter((p) => p.collection === collection).flatMap((p) => p.fields ?? []));

	let fields = Object.entries(schema.collections[collection]!.fields);

	// filter out fields that are not searchable
	fields = fields.filter(([_name, field]) => field.searchable !== false);

	const { cases, caseMap } = getCases(collection, permissions, []);

	// Add field restrictions if non-admin and ""everything"" is not allowed
	if (cases.length !== 0 && !allowedFields.has('*')) {
		fields = fields.filter((field) => allowedFields.has(field[0]));",1
"        nstack.push(evaluate(n1 ? n2 : n3, expr, values));
      } else {
        f = expr.ternaryOps[item.value];
        nstack.push(f(resolveExpression(n1, values), resolveExpression(n2, values), resolveExpression(n3, values)));
      }
    } else if (type === IVAR) {
      if (item.value in expr.functions) {
        nstack.push(expr.functions[item.value]);
      } else if (item.value in expr.unaryOps && expr.parser.isOperatorEnabled(item.value)) {
        nstack.push(expr.unaryOps[item.value]);
      } else {
        var v = values[item.value];",1
"  return String.fromCharCode(
    ((c - 0x010000) >> 10) + 0xD800,
    ((c - 0x010000) & 0x03FF) + 0xDC00
  );
}

var simpleEscapeCheck = new Array(256); // integer, for fast access
var simpleEscapeMap = new Array(256);
for (var i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}


function State(input, options) {
  this.input = input;

  this.filename  = options['filename']  || null;
  this.schema    = options['schema']    || DEFAULT_SCHEMA;
  this.onWarning = options['onWarning'] || null;
  // (Hidden) Remove? makes the loader to expect YAML 1.1 documents
  // if such documents have no explicit %YAML directive
  this.legacy    = options['legacy']    || false;

  this.json      = options['json']      || false;
  this.listener  = options['listener']  || null;

  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap       = this.schema.compiledTypeMap;

  this.length     = input.length;
  this.position   = 0;
  this.line       = 0;
  this.lineStart  = 0;
  this.lineIndent = 0;

  // position of first leading tab in the current line,
  // used to make sure there are no tabs in the indentation
  this.firstTabInLine = -1;

  this.documents = [];

  /*
  this.version;
  this.checkLineBreaks;
  this.tagMap;
  this.anchorMap;
  this.tag;
  this.anchor;
  this.kind;
  this.result;*/

}


function generateError(state, message) {
  var mark = {
    name:     state.filename,
    buffer:   state.input.slice(0, -1), // omit trailing \0
    position: state.position,
    line:     state.line,
    column:   state.position - state.lineStart
  };

  mark.snippet = makeSnippet(mark);

  return new YAMLException(message, mark);
}

function throwError(state, message) {
  throw generateError(state, message);
}

function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}


var directiveHandlers = {

  YAML: function handleYamlDirective(state, name, args) {

    var match, major, minor;

    if (state.version !== null) {
      throwError(state, 'duplication of %YAML directive');
    }

    if (args.length !== 1) {
      throwError(state, 'YAML directive accepts exactly one argument');
    }

    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

    if (match === null) {
      throwError(state, 'ill-formed argument of the YAML directive');
    }

    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);

    if (major !== 1) {
      throwError(state, 'unacceptable YAML version of the document');
    }

    state.version = args[0];
    state.checkLineBreaks = (minor < 2);

    if (minor !== 1 && minor !== 2) {
      throwWarning(state, 'unsupported YAML version of the document');
    }
  },

  TAG: function handleTagDirective(state, name, args) {

    var handle, prefix;

    if (args.length !== 2) {
      throwError(state, 'TAG directive accepts exactly two arguments');
    }

    handle = args[0];
    prefix = args[1];

    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
    }

    if (_hasOwnProperty.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for ""' + handle + '"" tag handle');
    }

    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
    }

    try {
      prefix = decodeURIComponent(prefix);
    } catch (err) {
      throwError(state, 'tag prefix is malformed: ' + prefix);
    }

    state.tagMap[handle] = prefix;
  }
};


function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;

  if (start < end) {
    _result = state.input.slice(start, end);

    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 0x09 ||
              (0x20 <= _character && _character <= 0x10FFFF))) {
          throwError(state, 'expected valid JSON character');
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, 'the stream contains non-printable characters');
    }

    state.result += _result;
  }
}

function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;

  if (!common.isObject(source)) {
    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
  }

  sourceKeys = Object.keys(source);

  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];

    if (!_hasOwnProperty.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}

function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode,
  startLine, startLineStart, startPos) {

  var index, quantity;

  // The output is a plain object here, so keys can only be strings.
  // We need to convert keyNode to a string, but doing so can hang the process
  // (deeply nested arrays that explode exponentially using aliases).
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);

    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state, 'nested arrays are not supported inside keys');
      }

      if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {
        keyNode[index] = '[object Object]';
      }
    }
  }

  // Avoid code execution in load() via toString property
  // (still use its own toString for arrays, timestamps,
  // and whatever user schema extensions happen to have @@toStringTag)
  if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {
    keyNode = '[object Object]';
  }


  keyNode = String(keyNode);

  if (_result === null) {
    _result = {};
  }

  if (keyTag === 'tag:yaml.org,2002:merge') {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json &&
        !_hasOwnProperty.call(overridableKeys, keyNode) &&
        _hasOwnProperty.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.lineStart = startLineStart || state.lineStart;
      state.position = startPos || state.position;
      throwError(state, 'duplicated mapping key');
    }

    // used for this specific key only because Object.defineProperty is slow
    if (keyNode === '__proto__') {
      Object.defineProperty(_result, keyNode, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: valueNode
      });
    } else {
      _result[keyNode] = valueNode;
    }
    delete overridableKeys[keyNode];
  }

  return _result;
}
",1
"
const assert = require('assert');
const yaml = require('../../');


it('should define __proto__ as a value (not invoke setter)', function () {
  let object = yaml.load('{ __proto__: {foo: bar} }');

  assert.strictEqual(({}).hasOwnProperty.call(yaml.load('{}'), '__proto__'), false);
  assert.strictEqual(({}).hasOwnProperty.call(object, '__proto__'), true);
  assert(!object.foo);
});",1
"'use strict';

const Parse = require('parse/node');
const request = require('../lib/request');
const ParseServerRESTController = require('../lib/ParseServerRESTController').ParseServerRESTController;
const ParseServer = require('../lib/ParseServer').default;

const masterKeyHeaders = {
  'X-Parse-Application-Id': 'test',
  'X-Parse-Rest-API-Key': 'test',
  'X-Parse-Master-Key': 'test',
  'Content-Type': 'application/json',
};

const masterKeyOptions = {
  headers: masterKeyHeaders,
};

const BoxedNumber = Parse.Object.extend({
  className: 'BoxedNumber',
});

describe('Parse.Query testing', () => {
  it('basic query', function (done) {
    const baz = new TestObject({ foo: 'baz' });
    const qux = new TestObject({ foo: 'qux' });
    Parse.Object.saveAll([baz, qux]).then(function () {
      const query = new Parse.Query(TestObject);
      query.equalTo('foo', 'baz');
      query.find().then(function (results) {
        equal(results.length, 1);
        equal(results[0].get('foo'), 'baz');
        done();
      });
    });
  });

  it_only_db('mongo')('gracefully handles invalid explain values', async () => {
    // Note that anything that is not truthy (like 0) does not cause an exception, as they get swallowed up by ClassesRouter::optionsFromBody
    const values = [1, 'yolo', { a: 1 }, [1, 2, 3]];
    for (const value of values) {
      try {
        await request({
          method: 'GET',
          url: `http://localhost:8378/1/classes/_User?explain=${value}`,
          json: true,
          headers: masterKeyHeaders,
        });
        fail('request did not throw');
      } catch (e) {
        // Expect that Parse Server did not crash
        expect(e.code).not.toEqual('ECONNRESET');
        // Expect that Parse Server validates the explain value and does not crash;
        // see https://jira.mongodb.org/browse/NODE-3463
        equal(e.data.code, Parse.Error.INVALID_QUERY);
        equal(e.data.error, 'Invalid value for explain');
      }
      // get queries (of the form '/classes/:className/:objectId' cannot have the explain key, see ClassesRouter.js)
      // so it is enough that we test find queries
    }
  });

  it_only_db('mongo')('supports valid explain values', async () => {
    const values = [
      false,
      true,
      'queryPlanner',
      'executionStats',
      'allPlansExecution',
      // 'queryPlannerExtended' is excluded as it only applies to MongoDB Data Lake which is currently not available in our CI environment
    ];
    for (const value of values) {
      const response = await request({
        method: 'GET',
        url: `http://localhost:8378/1/classes/_User?explain=${value}`,
        json: true,
        headers: masterKeyHeaders,
      });
      expect(response.status).toBe(200);
      if (value) {
        expect(response.data.results.ok).toBe(1);
      }
    }
  });

  it('searching for null', function (done) {
    const baz = new TestObject({ foo: null });
    const qux = new TestObject({ foo: 'qux' });
    const qux2 = new TestObject({});
    Parse.Object.saveAll([baz, qux, qux2]).then(function () {
      const query = new Parse.Query(TestObject);
      query.equalTo('foo', null);
      query.find().then(function (results) {
        equal(results.length, 2);
        qux.set('foo', null);
        qux.save().then(function () {
          query.find().then(function (results) {
            equal(results.length, 3);
            done();
          });
        });
      });
    });
  });

  it('searching for not null', function (done) {
    const baz = new TestObject({ foo: null });
    const qux = new TestObject({ foo: 'qux' });
    const qux2 = new TestObject({});
    Parse.Object.saveAll([baz, qux, qux2]).then(function () {
      const query = new Parse.Query(TestObject);
      query.notEqualTo('foo', null);
      query.find().then(function (results) {
        equal(results.length, 1);
        qux.set('foo', null);
        qux.save().then(function () {
          query.find().then(function (results) {
            equal(results.length, 0);
            done();
          });
        });
      });
    });
  });

  it('notEqualTo with Relation is working', function (done) {
    const user = new Parse.User();
    user.setPassword('asdf');
    user.setUsername('zxcv');

    const user1 = new Parse.User();
    user1.setPassword('asdf');
    user1.setUsername('qwerty');

    const user2 = new Parse.User();
    user2.setPassword('asdf');
    user2.setUsername('asdf');

    const Cake = Parse.Object.extend('Cake');
    const cake1 = new Cake();
    const cake2 = new Cake();
    const cake3 = new Cake();

    user
      .signUp()
      .then(function () {
        return user1.signUp();
      })
      .then(function () {
        return user2.signUp();
      })
      .then(function () {
        const relLike1 = cake1.relation('liker');
        relLike1.add([user, user1]);

        const relDislike1 = cake1.relation('hater');
        relDislike1.add(user2);

        return cake1.save();
      })
      .then(function () {
        const rellike2 = cake2.relation('liker');
        rellike2.add([user, user1]);

        const relDislike2 = cake2.relation('hater');
        relDislike2.add(user2);

        const relSomething = cake2.relation('something');
        relSomething.add(user);

        return cake2.save();
      })
      .then(function () {
        const rellike3 = cake3.relation('liker');
        rellike3.add(user);

        const relDislike3 = cake3.relation('hater');
        relDislike3.add([user1, user2]);
        return cake3.save();
      })
      .then(function () {
        const query = new Parse.Query(Cake);
        // User2 likes nothing so we should receive 0
        query.equalTo('liker', user2);
        return query.find().then(function (results) {
          equal(results.length, 0);
        });
      })
      .then(function () {
        const query = new Parse.Query(Cake);
        // User1 likes two of three cakes
        query.equalTo('liker', user1);
        return query.find().then(function (results) {
          // It should return 2 -> cake 1 and cake 2
          equal(results.length, 2);
        });
      })
      .then(function () {
        const query = new Parse.Query(Cake);
        // We want to know which cake the user1 is not appreciating -> cake3
        query.notEqualTo('liker', user1);
        return query.find().then(function (results) {
          // Should return 1 -> the cake 3
          equal(results.length, 1);
        });
      })
      .then(function () {
        const query = new Parse.Query(Cake);
        // User2 is a hater of everything so we should receive 0
        query.notEqualTo('hater', user2);
        return query.find().then(function (results) {
          equal(results.length, 0);
        });
      })
      .then(function () {
        const query = new Parse.Query(Cake);
        // Only cake3 is liked by user
        query.notContainedIn('liker', [user1]);
        return query.find().then(function (results) {
          equal(results.length, 1);
        });
      })
      .then(function () {
        const query = new Parse.Query(Cake);
        // All the users
        query.containedIn('liker', [user, user1, user2]);
        // Exclude user 1
        query.notEqualTo('liker', user1);
        // Only cake3 is liked only by user1
        return query.find().then(function (results) {
          equal(results.length, 1);
          const cake = results[0];
          expect(cake.id).toBe(cake3.id);
        });
      })
      .then(function () {
        const query = new Parse.Query(Cake);
        // Exclude user1
        query.notEqualTo('liker', user1);
        // Only cake1
        query.equalTo('objectId', cake1.id);
        // user1 likes cake1 so this should return no results
        return query.find().then(function (results) {
          equal(results.length, 0);
        });
      })
      .then(function () {
        const query = new Parse.Query(Cake);
        query.notEqualTo('hater', user2);
        query.notEqualTo('liker', user2);
        // user2 doesn't like any cake so this should be 0
        return query.find().then(function (results) {
          equal(results.length, 0);
        });
      })
      .then(function () {
        const query = new Parse.Query(Cake);
        query.equalTo('hater', user);
        query.equalTo('liker', user);
        // user doesn't hate any cake so this should be 0
        return query.find().then(function (results) {
          equal(results.length, 0);
        });
      })
      .then(function () {
        const query = new Parse.Query(Cake);
        query.equalTo('hater', null);
        query.equalTo('liker', null);
        // user doesn't hate any cake so this should be 0
        return query.find().then(function (results) {
          equal(results.length, 0);
        });
      })
      .then(function () {
        const query = new Parse.Query(Cake);
        query.equalTo('something', null);
        // user doesn't hate any cake so this should be 0
        return query.find().then(function (results) {
          equal(results.length, 0);
        });
      })
      .then(function () {
        done();
      })
      .catch(err => {
        jfail(err);
        done();
      });
  });

  it('query notContainedIn on empty array', async () => {
    const object = new TestObject();
    object.set('value', 100);
    await object.save();

    const query = new Parse.Query(TestObject);
    query.notContainedIn('value', []);

    const results = await query.find();
    equal(results.length, 1);
  });

  it('query containedIn on empty array', async () => {
    const object = new TestObject();
    object.set('value', 100);
    await object.save();

    const query = new Parse.Query(TestObject);
    query.containedIn('value', []);

    const results = await query.find();
    equal(results.length, 0);
  });

  it('query without limit respects default limit', async () => {
    await reconfigureServer({ defaultLimit: 1 });
    const obj1 = new TestObject({ foo: 'baz' });
    const obj2 = new TestObject({ foo: 'qux' });
    await Parse.Object.saveAll([obj1, obj2]);
    const query = new Parse.Query(TestObject);
    const result = await query.find();
    expect(result.length).toBe(1);
  });

  it('query with limit', async () => {
    const obj1 = new TestObject({ foo: 'baz' });
    const obj2 = new TestObject({ foo: 'qux' });
    await Parse.Object.saveAll([obj1, obj2]);
    const query = new Parse.Query(TestObject);
    query.limit(1);
    const result = await query.find();
    expect(result.length).toBe(1);
  });

  it('query with limit overrides default limit', async () => {
    await reconfigureServer({ defaultLimit: 2 });
    const obj1 = new TestObject({ foo: 'baz' });
    const obj2 = new TestObject({ foo: 'qux' });
    await Parse.Object.saveAll([obj1, obj2]);
    const query = new Parse.Query(TestObject);
    query.limit(1);
    const result = await query.find();
    expect(result.length).toBe(1);
  });

  it('query with limit equal to maxlimit', async () => {
    await reconfigureServer({ maxLimit: 1 });
    const obj1 = new TestObject({ foo: 'baz' });
    const obj2 = new TestObject({ foo: 'qux' });
    await Parse.Object.saveAll([obj1, obj2]);
    const query = new Parse.Query(TestObject);
    query.limit(1);
    const result = await query.find();
    expect(result.length).toBe(1);
  });

  it('query with limit exceeding maxlimit', async () => {
    await reconfigureServer({ maxLimit: 1 });
    const obj1 = new TestObject({ foo: 'baz' });
    const obj2 = new TestObject({ foo: 'qux' });
    await Parse.Object.saveAll([obj1, obj2]);
    const query = new Parse.Query(TestObject);
    query.limit(2);
    const result = await query.find();
    expect(result.length).toBe(1);
  });

  it('containedIn object array queries', function (done) {
    const messageList = [];
    for (let i = 0; i < 4; ++i) {
      const message = new TestObject({});
      if (i > 0) {
        message.set('prior', messageList[i - 1]);
      }
      messageList.push(message);
    }

    Parse.Object.saveAll(messageList).then(
      function () {
        equal(messageList.length, 4);

        const inList = [];
        inList.push(messageList[0]);
        inList.push(messageList[2]);

        const query = new Parse.Query(TestObject);
        query.containedIn('prior', inList);
        query.find().then(
          function (results) {
            equal(results.length, 2);
            done();
          },
          function (e) {
            jfail(e);
            done();
          }
        );
      },
      e => {
        jfail(e);
        done();
      }
    );
  });

  it('containedIn null array', done => {
    const emails = ['contact@xyz.com', 'contact@zyx.com', null];
    const user = new Parse.User();
    user.setUsername(emails[0]);
    user.setPassword('asdf');
    user
      .signUp()
      .then(() => {
        const query = new Parse.Query(Parse.User);
        query.containedIn('username', emails);
        return query.find({ useMasterKey: true });
      })
      .then(results => {
        equal(results.length, 1);
        done();
      }, done.fail);
  });

  it('nested equalTo string with single quote', async () => {
    const obj = new TestObject({ nested: { foo: ""single'quote"" } });
    await obj.save();
    const query = new Parse.Query(TestObject);
    query.equalTo('nested.foo', ""single'quote"");
    const result = await query.get(obj.id);
    equal(result.get('nested').foo, ""single'quote"");
  });

  it('nested containedIn string with single quote', async () => {
    const obj = new TestObject({ nested: { foo: [""single'quote""] } });
    await obj.save();
    const query = new Parse.Query(TestObject);
    query.containedIn('nested.foo', [""single'quote""]);
    const result = await query.get(obj.id);
    equal(result.get('nested').foo[0], ""single'quote"");
  });

  it('nested containedIn string', done => {
    const sender1 = { group: ['A', 'B'] };
    const sender2 = { group: ['A', 'C'] };
    const sender3 = { group: ['B', 'C'] };
    const obj1 = new TestObject({ sender: sender1 });
    const obj2 = new TestObject({ sender: sender2 });
    const obj3 = new TestObject({ sender: sender3 });
    Parse.Object.saveAll([obj1, obj2, obj3])
      .then(() => {
        const query = new Parse.Query(TestObject);
        query.containedIn('sender.group', ['A']);
        return query.find();
      })
      .then(results => {
        equal(results.length, 2);
        done();
      }, done.fail);
  });

  it('nested containedIn number', done => {
    const sender1 = { group: [1, 2] };
    const sender2 = { group: [1, 3] };
    const sender3 = { group: [2, 3] };
    const obj1 = new TestObject({ sender: sender1 });
    const obj2 = new TestObject({ sender: sender2 });
    const obj3 = new TestObject({ sender: sender3 });
    Parse.Object.saveAll([obj1, obj2, obj3])
      .then(() => {
        const query = new Parse.Query(TestObject);
        query.containedIn('sender.group', [1]);
        return query.find();
      })
      .then(results => {
        equal(results.length, 2);
        done();
      }, done.fail);
  });

  it('containsAll number array queries', function (done) {
    const NumberSet = Parse.Object.extend({ className: 'NumberSet' });

    const objectsList = [];
    objectsList.push(new NumberSet({ numbers: [1, 2, 3, 4, 5] }));
    objectsList.push(new NumberSet({ numbers: [1, 3, 4, 5] }));

    Parse.Object.saveAll(objectsList)
      .then(function () {
        const query = new Parse.Query(NumberSet);
        query.containsAll('numbers', [1, 2, 3]);
        query.find().then(
          function (results) {
            equal(results.length, 1);
            done();
          },
          function (err) {
            jfail(err);
            done();
          }
        );
      })
      .catch(err => {
        jfail(err);
        done();
      });
  });

  it('containsAll string array queries', function (done) {
    const StringSet = Parse.Object.extend({ className: 'StringSet' });

    const objectsList = [];
    objectsList.push(new StringSet({ strings: ['a', 'b', 'c', 'd', 'e'] }));
    objectsList.push(new StringSet({ strings: ['a', 'c', 'd', 'e'] }));

    Parse.Object.saveAll(objectsList)
      .then(function () {
        const query = new Parse.Query(StringSet);
        query.containsAll('strings', ['a', 'b', 'c']);
        query.find().then(function (results) {
          equal(results.length, 1);
          done();
        });
      })
      .catch(err => {
        jfail(err);
        done();
      });
  });

  it('containsAll date array queries', function (done) {
    const DateSet = Parse.Object.extend({ className: 'DateSet' });

    function parseDate(iso8601) {
      const regexp = new RegExp(
        '^([0-9]{1,4})-([0-9]{1,2})-([0-9]{1,2})' +
          'T' +
          '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2})' +
          '(.([0-9]+))?' +
          'Z$'
      );
      const match = regexp.exec(iso8601);
      if (!match) {
        return null;
      }

      const year = match[1] || 0;
      const month = (match[2] || 1) - 1;
      const day = match[3] || 0;
      const hour = match[4] || 0;
      const minute = match[5] || 0;
      const second = match[6] || 0;
      const milli = match[8] || 0;

      return new Date(Date.UTC(year, month, day, hour, minute, second, milli));
    }

    const makeDates = function (stringArray) {
      return stringArray.map(function (dateStr) {
        return parseDate(dateStr + 'T00:00:00Z');
      });
    };

    const objectsList = [];
    objectsList.push(
      new DateSet({
        dates: makeDates(['2013-02-01', '2013-02-02', '2013-02-03', '2013-02-04']),
      })
    );
    objectsList.push(
      new DateSet({
        dates: makeDates(['2013-02-01', '2013-02-03', '2013-02-04']),
      })
    );

    Parse.Object.saveAll(objectsList).then(function () {
      const query = new Parse.Query(DateSet);
      query.containsAll('dates', makeDates(['2013-02-01', '2013-02-02', '2013-02-03']));
      query.find().then(
        function (results) {
          equal(results.length, 1);
          done();
        },
        function (e) {
          jfail(e);
          done();
        }
      );
    });
  });

  it_id('25bb35a6-e953-4d6d-a31c-66324d5ae076')(it)('containsAll object array queries', function (done) {
    const MessageSet = Parse.Object.extend({ className: 'MessageSet' });

    const messageList = [];
    for (let i = 0; i < 4; ++i) {
      messageList.push(new TestObject({ i: i }));
    }

    Parse.Object.saveAll(messageList).then(function () {
      equal(messageList.length, 4);

      const messageSetList = [];
      messageSetList.push(new MessageSet({ messages: messageList }));

      const someList = [];
      someList.push(messageList[0]);
      someList.push(messageList[1]);
      someList.push(messageList[3]);
      messageSetList.push(new MessageSet({ messages: someList }));

      Parse.Object.saveAll(messageSetList).then(function () {
        const inList = [];
        inList.push(messageList[0]);
        inList.push(messageList[2]);

        const query = new Parse.Query(MessageSet);
        query.containsAll('messages', inList);
        query.find().then(function (results) {
          equal(results.length, 1);
          done();
        });
      });
    });
  });

  it('containsAllStartingWith should match all strings that starts with string', done => {
    const object = new Parse.Object('Object');
    object.set('strings', ['the', 'brown', 'lazy', 'fox', 'jumps']);
    const object2 = new Parse.Object('Object');
    object2.set('strings', ['the', 'brown', 'fox', 'jumps']);
    const object3 = new Parse.Object('Object');
    object3.set('strings', ['over', 'the', 'lazy', 'dog']);

    const objectList = [object, object2, object3];

    Parse.Object.saveAll(objectList).then(results => {
      equal(objectList.length, results.length);

      return request({
        url: Parse.serverURL + '/classes/Object',
        qs: {
          where: JSON.stringify({
            strings: {
              $all: [{ $regex: '^\\Qthe\\E' }, { $regex: '^\\Qfox\\E' }, { $regex: '^\\Qlazy\\E' }],
            },
          }),
        },
        headers: {
          'X-Parse-Application-Id': Parse.applicationId,
          'X-Parse-Javascript-Key': Parse.javaScriptKey,
          'Content-Type': 'application/json',
        },
      })
        .then(function (response) {
          const results = response.data;
          equal(results.results.length, 1);
          arrayContains(results.results, object);

          return request({
            url: Parse.serverURL + '/classes/Object',
            qs: {
              where: JSON.stringify({
                strings: {
                  $all: [{ $regex: '^\\Qthe\\E' }, { $regex: '^\\Qlazy\\E' }],
                },
              }),
            },
            headers: {
              'X-Parse-Application-Id': Parse.applicationId,
              'X-Parse-Javascript-Key': Parse.javaScriptKey,
              'Content-Type': 'application/json',
            },
          });
        })
        .then(function (response) {
          const results = response.data;
          equal(results.results.length, 2);
          arrayContains(results.results, object);
          arrayContains(results.results, object3);

          return request({
            url: Parse.serverURL + '/classes/Object',
            qs: {
              where: JSON.stringify({
                strings: {
                  $all: [{ $regex: '^\\Qhe\\E' }, { $regex: '^\\Qlazy\\E' }],
                },
              }),
            },
            headers: {
              'X-Parse-Application-Id': Parse.applicationId,
              'X-Parse-Javascript-Key': Parse.javaScriptKey,
              'Content-Type': 'application/json',
            },
          });
        })
        .then(function (response) {
          const results = response.data;
          equal(results.results.length, 0);

          done();
        });
    });
  });

  it_id('3ea6ae04-bcc2-453d-8817-4c64d059c2f6')(it)('containsAllStartingWith values must be all of type starting with regex', done => {
    const object = new Parse.Object('Object');
    object.set('strings', ['the', 'brown', 'lazy', 'fox', 'jumps']);

    object
      .save()
      .then(() => {
        equal(object.isNew(), false);

        return request({
          url: Parse.serverURL + '/classes/Object',
          qs: {
            where: JSON.stringify({
              strings: {
                $all: [
                  { $regex: '^\\Qthe\\E' },
                  { $regex: '^\\Qlazy\\E' },
                  { $regex: '^\\Qfox\\E' },
                  { $unknown: /unknown/ },
                ],
              },
            }),
          },
          headers: {
            'X-Parse-Application-Id': Parse.applicationId,
            'X-Parse-Javascript-Key': Parse.javaScriptKey,
            'Content-Type': 'application/json',
          },
        });
      })
      .then(done.fail, function () {
        done();
      });
  });

  it('containsAllStartingWith empty array values should return empty results', done => {
    const object = new Parse.Object('Object');
    object.set('strings', ['the', 'brown', 'lazy', 'fox', 'jumps']);

    object
      .save()
      .then(() => {
        equal(object.isNew(), false);

        return request({
          url: Parse.serverURL + '/classes/Object',
          qs: {
            where: JSON.stringify({
              strings: {
                $all: [],
              },
            }),
          },
          headers: {
            'X-Parse-Application-Id': Parse.applicationId,
            'X-Parse-Javascript-Key': Parse.javaScriptKey,
            'Content-Type': 'application/json',
          },
        });
      })
      .then(
        function (response) {
          const results = response.data;
          equal(results.results.length, 0);
          done();
        },
        function () {}
      );
  });

  it('containsAllStartingWith single empty value returns empty results', done => {
    const object = new Parse.Object('Object');
    object.set('strings', ['the', 'brown', 'lazy', 'fox', 'jumps']);

    object
      .save()
      .then(() => {
        equal(object.isNew(), false);

        return request({
          url: Parse.serverURL + '/classes/Object',
          qs: {
            where: JSON.stringify({
              strings: {
                $all: [{}],
              },
            }),
          },
          headers: {
            'X-Parse-Application-Id': Parse.applicationId,
            'X-Parse-Javascript-Key': Parse.javaScriptKey,
            'Content-Type': 'application/json',
          },
        });
      })
      .then(
        function (response) {
          const results = response.data;
          equal(results.results.length, 0);
          done();
        },
        function () {}
      );
  });

  it('containsAllStartingWith single regex value should return corresponding matching results', done => {
    const object = new Parse.Object('Object');
    object.set('strings', ['the', 'brown', 'lazy', 'fox', 'jumps']);
    const object2 = new Parse.Object('Object');
    object2.set('strings', ['the', 'brown', 'fox', 'jumps']);
    const object3 = new Parse.Object('Object');
    object3.set('strings', ['over', 'the', 'lazy', 'dog']);

    const objectList = [object, object2, object3];

    Parse.Object.saveAll(objectList)
      .then(results => {
        equal(objectList.length, results.length);

        return request({
          url: Parse.serverURL + '/classes/Object',
          qs: {
            where: JSON.stringify({
              strings: {
                $all: [{ $regex: '^\\Qlazy\\E' }],
              },
            }),
          },
          headers: {
            'X-Parse-Application-Id': Parse.applicationId,
            'X-Parse-Javascript-Key': Parse.javaScriptKey,
            'Content-Type': 'application/json',
          },
        });
      })
      .then(
        function (response) {
          const results = response.data;
          equal(results.results.length, 2);
          done();
        },
        function () {}
      );
  });

  it('containsAllStartingWith single invalid regex returns empty results', done => {
    const object = new Parse.Object('Object');
    object.set('strings', ['the', 'brown', 'lazy', 'fox', 'jumps']);

    object
      .save()
      .then(() => {
        equal(object.isNew(), false);

        return request({
          url: Parse.serverURL + '/classes/Object',
          qs: {
            where: JSON.stringify({
              strings: {
                $all: [{ $unknown: '^\\Qlazy\\E' }],
              },
            }),
          },
          headers: {
            'X-Parse-Application-Id': Parse.applicationId,
            'X-Parse-Javascript-Key': Parse.javaScriptKey,
          },
        });
      })
      .then(
        function (response) {
          const results = response.data;
          equal(results.results.length, 0);
          done();
        },
        function () {}
      );
  });

  it_id('01a15195-dde2-4368-b996-d746a4ede3a1')(it)('containedBy pointer array', done => {
    const objects = Array.from(Array(10).keys()).map(idx => {
      const obj = new Parse.Object('Object');
      obj.set('key', idx);
      return obj;
    });

    const parent = new Parse.Object('Parent');
    const parent2 = new Parse.Object('Parent');
    const parent3 = new Parse.Object('Parent');

    Parse.Object.saveAll(objects)
      .then(() => {
        // [0, 1, 2]
        parent.set('objects', objects.slice(0, 3));

        const shift = objects.shift();
        // [2, 0]
        parent2.set('objects', [objects[1], shift]);

        // [1, 2, 3, 4]
        parent3.set('objects', objects.slice(1, 4));

        return Parse.Object.saveAll([parent, parent2, parent3]);
      })
      .then(() => {
        // [1, 2, 3, 4, 5, 6, 7, 8, 9]
        const pointers = objects.map(object => object.toPointer());

        // Return all Parent where all parent.objects are contained in objects
        return request({
          url: Parse.serverURL + '/classes/Parent',
          qs: {
            where: JSON.stringify({
              objects: {
                $containedBy: pointers,
              },
            }),
          },
          headers: {
            'X-Parse-Application-Id': Parse.applicationId,
            'X-Parse-Javascript-Key': Parse.javaScriptKey,
            'Content-Type': 'application/json',
          },
        });
      })
      .then(response => {
        const results = response.data;
        expect(results.results[0].objectId).not.toBeUndefined();
        expect(results.results[0].objectId).toBe(parent3.id);
        expect(results.results.length).toBe(1);
        done();
      });
  });

  it('containedBy number array', done => {
    const options = Object.assign({}, masterKeyOptions, {
      qs: {
        where: JSON.stringify({
          numbers: { $containedBy: [1, 2, 3, 4, 5, 6, 7, 8, 9] },
        }),
      },
    });
    const obj1 = new TestObject({ numbers: [0, 1, 2] });
    const obj2 = new TestObject({ numbers: [2, 0] });
    const obj3 = new TestObject({ numbers: [1, 2, 3, 4] });
    Parse.Object.saveAll([obj1, obj2, obj3])
      .then(() => {
        return request(Object.assign({ url: Parse.serverURL + '/classes/TestObject' }, options));
      })
      .then(response => {
        const results = response.data;
        expect(results.results[0].objectId).not.toBeUndefined();
        expect(results.results[0].objectId).toBe(obj3.id);
        expect(results.results.length).toBe(1);
        done();
      });
  });

  it('containedBy empty array', done => {
    const options = Object.assign({}, masterKeyOptions, {
      qs: {
        where: JSON.stringify({ numbers: { $containedBy: [] } }),
      },
    });
    const obj1 = new TestObject({ numbers: [0, 1, 2] });
    const obj2 = new TestObject({ numbers: [2, 0] });
    const obj3 = new TestObject({ numbers: [1, 2, 3, 4] });
    Parse.Object.saveAll([obj1, obj2, obj3])
      .then(() => {
        return request(Object.assign({ url: Parse.serverURL + '/classes/TestObject' }, options));
      })
      .then(response => {
        const results = response.data;
        expect(results.results.length).toBe(0);
        done();
      });
  });

  it('containedBy invalid query', done => {
    const options = Object.assign({}, masterKeyOptions, {
      qs: {
        where: JSON.stringify({ objects: { $containedBy: 1234 } }),
      },
    });
    const obj = new TestObject();
    obj
      .save()
      .then(() => {
        return request(Object.assign({ url: Parse.serverURL + '/classes/TestObject' }, options));
      })
      .then(done.fail)
      .catch(response => {
        equal(response.data.code, Parse.Error.INVALID_JSON);
        equal(response.data.error, 'bad $containedBy: should be an array');
        done();
      });
  });

  it('equalTo queries', function (done) {
    const makeBoxedNumber = function (i) {
      return new BoxedNumber({ number: i });
    };
    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {
      const query = new Parse.Query(BoxedNumber);
      query.equalTo('number', 3);
      query.find().then(function (results) {
        equal(results.length, 1);
        done();
      });
    });
  });

  it('equalTo undefined', function (done) {
    const makeBoxedNumber = function (i) {
      return new BoxedNumber({ number: i });
    };
    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {
      const query = new Parse.Query(BoxedNumber);
      query.equalTo('number', undefined);
      query.find().then(function (results) {
        equal(results.length, 0);
        done();
      });
    });
  });

  it('lessThan queries', function (done) {
    const makeBoxedNumber = function (i) {
      return new BoxedNumber({ number: i });
    };
    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {
      const query = new Parse.Query(BoxedNumber);
      query.lessThan('number', 7);
      query.find().then(function (results) {
        equal(results.length, 7);
        done();
      });
    });
  });

  it('lessThanOrEqualTo queries', function (done) {
    const makeBoxedNumber = function (i) {
      return new BoxedNumber({ number: i });
    };
    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {
      const query = new Parse.Query(BoxedNumber);
      query.lessThanOrEqualTo('number', 7);
      query.find().then(function (results) {
        equal(results.length, 8);
        done();
      });
    });
  });

  it('lessThan zero queries', done => {
    const makeBoxedNumber = i => {
      return new BoxedNumber({ number: i });
    };
    const numbers = [-3, -2, -1, 0, 1];
    const boxedNumbers = numbers.map(makeBoxedNumber);
    Parse.Object.saveAll(boxedNumbers)
      .then(() => {
        const query = new Parse.Query(BoxedNumber);
        query.lessThan('number', 0);
        return query.find();
      })
      .then(results => {
        equal(results.length, 3);
        done();
      });
  });

  it('lessThanOrEqualTo zero queries', done => {
    const makeBoxedNumber = i => {
      return new BoxedNumber({ number: i });
    };
    const numbers = [-3, -2, -1, 0, 1];
    const boxedNumbers = numbers.map(makeBoxedNumber);
    Parse.Object.saveAll(boxedNumbers)
      .then(() => {
        const query = new Parse.Query(BoxedNumber);
        query.lessThanOrEqualTo('number', 0);
        return query.find();
      })
      .then(results => {
        equal(results.length, 4);
        done();
      });
  });

  it('greaterThan queries', function (done) {
    const makeBoxedNumber = function (i) {
      return new BoxedNumber({ number: i });
    };
    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {
      const query = new Parse.Query(BoxedNumber);
      query.greaterThan('number', 7);
      query.find().then(function (results) {
        equal(results.length, 2);
        done();
      });
    });
  });

  it('greaterThanOrEqualTo queries', function (done) {
    const makeBoxedNumber = function (i) {
      return new BoxedNumber({ number: i });
    };
    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {
      const query = new Parse.Query(BoxedNumber);
      query.greaterThanOrEqualTo('number', 7);
      query.find().then(function (results) {
        equal(results.length, 3);
        done();
      });
    });
  });

  it('greaterThan zero queries', done => {
    const makeBoxedNumber = i => {
      return new BoxedNumber({ number: i });
    };
    const numbers = [-3, -2, -1, 0, 1];
    const boxedNumbers = numbers.map(makeBoxedNumber);
    Parse.Object.saveAll(boxedNumbers)
      .then(() => {
        const query = new Parse.Query(BoxedNumber);
        query.greaterThan('number', 0);
        return query.find();
      })
      .then(results => {
        equal(results.length, 1);
        done();
      });
  });

  it('greaterThanOrEqualTo zero queries', done => {
    const makeBoxedNumber = i => {
      return new BoxedNumber({ number: i });
    };
    const numbers = [-3, -2, -1, 0, 1];
    const boxedNumbers = numbers.map(makeBoxedNumber);
    Parse.Object.saveAll(boxedNumbers)
      .then(() => {
        const query = new Parse.Query(BoxedNumber);
        query.greaterThanOrEqualTo('number', 0);
        return query.find();
      })
      .then(results => {
        equal(results.length, 2);
        done();
      });
  });

  it('lessThanOrEqualTo greaterThanOrEqualTo queries', function (done) {
    const makeBoxedNumber = function (i) {
      return new BoxedNumber({ number: i });
    };
    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {
      const query = new Parse.Query(BoxedNumber);
      query.lessThanOrEqualTo('number', 7);
      query.greaterThanOrEqualTo('number', 7);
      query.find().then(function (results) {
        equal(results.length, 1);
        done();
      });
    });
  });

  it('lessThan greaterThan queries', function (done) {
    const makeBoxedNumber = function (i) {
      return new BoxedNumber({ number: i });
    };
    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {
      const query = new Parse.Query(BoxedNumber);
      query.lessThan('number', 9);
      query.greaterThan('number', 3);
      query.find().then(function (results) {
        equal(results.length, 5);
        done();
      });
    });
  });

  it('notEqualTo queries', function (done) {
    const makeBoxedNumber = function (i) {
      return new BoxedNumber({ number: i });
    };
    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {
      const query = new Parse.Query(BoxedNumber);
      query.notEqualTo('number', 5);
      query.find().then(function (results) {
        equal(results.length, 9);
        done();
      });
    });
  });

  it('notEqualTo zero queries', done => {
    const makeBoxedNumber = i => {
      return new BoxedNumber({ number: i });
    };
    const numbers = [-3, -2, -1, 0, 1];
    const boxedNumbers = numbers.map(makeBoxedNumber);
    Parse.Object.saveAll(boxedNumbers)
      .then(() => {
        const query = new Parse.Query(BoxedNumber);
        query.notEqualTo('number', 0);
        return query.find();
      })
      .then(results => {
        equal(results.length, 4);
        done();
      });
  });

  it('equalTo zero queries', done => {
    const makeBoxedNumber = i => {
      return new BoxedNumber({ number: i });
    };
    const numbers = [-3, -2, -1, 0, 1];
    const boxedNumbers = numbers.map(makeBoxedNumber);
    Parse.Object.saveAll(boxedNumbers)
      .then(() => {
        const query = new Parse.Query(BoxedNumber);
        query.equalTo('number', 0);
        return query.find();
      })
      .then(results => {
        equal(results.length, 1);
        done();
      });
  });

  it('number equalTo boolean queries', done => {
    const makeBoxedNumber = i => {
      return new BoxedNumber({ number: i });
    };
    const numbers = [-3, -2, -1, 0, 1];
    const boxedNumbers = numbers.map(makeBoxedNumber);
    Parse.Object.saveAll(boxedNumbers)
      .then(() => {
        const query = new Parse.Query(BoxedNumber);
        query.equalTo('number', false);
        return query.find();
      })
      .then(results => {
        equal(results.length, 0);
        done();
      });
  });

  it('equalTo false queries', done => {
    const obj1 = new TestObject({ field: false });
    const obj2 = new TestObject({ field: true });
    Parse.Object.saveAll([obj1, obj2])
      .then(() => {
        const query = new Parse.Query(TestObject);
        query.equalTo('field', false);
        return query.find();
      })
      .then(results => {
        equal(results.length, 1);
        done();
      });
  });

  it('where $eq false queries (rest)', done => {
    const options = Object.assign({}, masterKeyOptions, {
      qs: {
        where: JSON.stringify({ field: { $eq: false } }),
      },
    });
    const obj1 = new TestObject({ field: false });
    const obj2 = new TestObject({ field: true });
    Parse.Object.saveAll([obj1, obj2]).then(() => {
      request(Object.assign({ url: Parse.serverURL + '/classes/TestObject' }, options)).then(
        resp => {
          equal(resp.data.results.length, 1);
          done();
        }
      );
    });
  });

  it('where $eq null queries (rest)', done => {
    const options = Object.assign({}, masterKeyOptions, {
      qs: {
        where: JSON.stringify({ field: { $eq: null } }),
      },
    });
    const obj1 = new TestObject({ field: false });
    const obj2 = new TestObject({ field: null });
    Parse.Object.saveAll([obj1, obj2]).then(() => {
      return request(Object.assign({ url: Parse.serverURL + '/classes/TestObject' }, options)).then(
        resp => {
          equal(resp.data.results.length, 1);
          done();
        }
      );
    });
  });

  it('containedIn queries', function (done) {
    const makeBoxedNumber = function (i) {
      return new BoxedNumber({ number: i });
    };
    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {
      const query = new Parse.Query(BoxedNumber);
      query.containedIn('number', [3, 5, 7, 9, 11]);
      query.find().then(function (results) {
        equal(results.length, 4);
        done();
      });
    });
  });

  it('containedIn false queries', done => {
    const makeBoxedNumber = i => {
      return new BoxedNumber({ number: i });
    };
    const numbers = [-3, -2, -1, 0, 1];
    const boxedNumbers = numbers.map(makeBoxedNumber);
    Parse.Object.saveAll(boxedNumbers)
      .then(() => {
        const query = new Parse.Query(BoxedNumber);
        query.containedIn('number', false);
        return query.find();
      })
      .then(done.fail)
      .catch(error => {
        equal(error.code, Parse.Error.INVALID_JSON);
        equal(error.message, 'bad $in value');
        done();
      });
  });

  it('notContainedIn false queries', done => {
    const makeBoxedNumber = i => {
      return new BoxedNumber({ number: i });
    };
    const numbers = [-3, -2, -1, 0, 1];
    const boxedNumbers = numbers.map(makeBoxedNumber);
    Parse.Object.saveAll(boxedNumbers)
      .then(() => {
        const query = new Parse.Query(BoxedNumber);
        query.notContainedIn('number', false);
        return query.find();
      })
      .then(done.fail)
      .catch(error => {
        equal(error.code, Parse.Error.INVALID_JSON);
        equal(error.message, 'bad $nin value');
        done();
      });
  });

  it('notContainedIn queries', function (done) {
    const makeBoxedNumber = function (i) {
      return new BoxedNumber({ number: i });
    };
    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {
      const query = new Parse.Query(BoxedNumber);
      query.notContainedIn('number', [3, 5, 7, 9, 11]);
      query.find().then(function (results) {
        equal(results.length, 6);
        done();
      });
    });
  });

  it('objectId containedIn queries', function (done) {
    const makeBoxedNumber = function (i) {
      return new BoxedNumber({ number: i });
    };
    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function (list) {
      const query = new Parse.Query(BoxedNumber);
      query.containedIn('objectId', [list[2].id, list[3].id, list[0].id, 'NONSENSE']);
      query.ascending('number');
      query.find().then(function (results) {
        if (results.length != 3) {
          fail('expected 3 results');
        } else {
          equal(results[0].get('number'), 0);
          equal(results[1].get('number'), 2);
          equal(results[2].get('number'), 3);
        }
        done();
      });
    });
  });

  it('objectId equalTo queries', function (done) {
    const makeBoxedNumber = function (i) {
      return new BoxedNumber({ number: i });
    };
    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function (list) {
      const query = new Parse.Query(BoxedNumber);
      query.equalTo('objectId', list[4].id);
      query.find().then(function (results) {
        if (results.length != 1) {
          fail('expected 1 result');
          done();
        } else {
          equal(results[0].get('number'), 4);
        }
        done();
      });
    });
  });

  it('find no elements', function (done) {
    const makeBoxedNumber = function (i) {
      return new BoxedNumber({ number: i });
    };
    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {
      const query = new Parse.Query(BoxedNumber);
      query.equalTo('number', 17);
      query.find().then(function (results) {
        equal(results.length, 0);
        done();
      });
    });
  });

  it('find with error', function (done) {
    const query = new Parse.Query(BoxedNumber);
    query.equalTo('$foo', 'bar');
    query
      .find()
      .then(done.fail)
      .catch(error => expect(error.code).toBe(Parse.Error.INVALID_KEY_NAME))
      .then(done);
  });

  it('get', function (done) {
    Parse.Object.saveAll([new TestObject({ foo: 'bar' })]).then(function (items) {
      ok(items[0]);
      const objectId = items[0].id;
      const query = new Parse.Query(TestObject);
      query.get(objectId).then(function (result) {
        ok(result);
        equal(result.id, objectId);
        equal(result.get('foo'), 'bar');
        ok(result.createdAt instanceof Date);
        ok(result.updatedAt instanceof Date);
        done();
      });
    });
  });

  it('get undefined', function (done) {
    Parse.Object.saveAll([new TestObject({ foo: 'bar' })]).then(function (items) {
      ok(items[0]);
      const query = new Parse.Query(TestObject);
      query.get(undefined).then(fail, () => done());
    });
  });

  it('get error', function (done) {
    Parse.Object.saveAll([new TestObject({ foo: 'bar' })]).then(function (items) {
      ok(items[0]);
      const query = new Parse.Query(TestObject);
      query.get('InvalidObjectID').then(
        function () {
          ok(false, 'The get should have failed.');
          done();
        },
        function (error) {
          equal(error.code, Parse.Error.OBJECT_NOT_FOUND);
          done();
        }
      );
    });
  });

  it('first', function (done) {
    Parse.Object.saveAll([new TestObject({ foo: 'bar' })]).then(function () {
      const query = new Parse.Query(TestObject);
      query.equalTo('foo', 'bar');
      query.first().then(function (result) {
        equal(result.get('foo'), 'bar');
        done();
      });
    });
  });

  it('first no result', function (done) {
    Parse.Object.saveAll([new TestObject({ foo: 'bar' })]).then(function () {
      const query = new Parse.Query(TestObject);
      query.equalTo('foo', 'baz');
      query.first().then(function (result) {
        equal(result, undefined);
        done();
      });
    });
  });

  it('first with two results', function (done) {
    Parse.Object.saveAll([new TestObject({ foo: 'bar' }), new TestObject({ foo: 'bar' })]).then(
      function () {
        const query = new Parse.Query(TestObject);
        query.equalTo('foo', 'bar');
        query.first().then(function (result) {
          equal(result.get('foo'), 'bar');
          done();
        });
      }
    );
  });

  it('first with error', function (done) {
    const query = new Parse.Query(BoxedNumber);
    query.equalTo('$foo', 'bar');
    query
      .first()
      .then(done.fail)
      .catch(e => expect(e.code).toBe(Parse.Error.INVALID_KEY_NAME))
      .then(done);
  });

  const Container = Parse.Object.extend({
    className: 'Container',
  });

  it('notEqualTo object', function (done) {
    const item1 = new TestObject();
    const item2 = new TestObject();
    const container1 = new Container({ item: item1 });
    const container2 = new Container({ item: item2 });
    Parse.Object.saveAll([item1, item2, container1, container2]).then(function () {
      const query = new Parse.Query(Container);
      query.notEqualTo('item', item1);
      query.find().then(function (results) {
        equal(results.length, 1);
        done();
      });
    });
  });

  it('skip', function (done) {
    Parse.Object.saveAll([new TestObject(), new TestObject()]).then(function () {
      const query = new Parse.Query(TestObject);
      query.skip(1);
      query.find().then(function (results) {
        equal(results.length, 1);
        query.skip(3);
        query.find().then(function (results) {
          equal(results.length, 0);
          done();
        });
      });
    });
  });

  it(""skip doesn't affect count"", function (done) {
    Parse.Object.saveAll([new TestObject(), new TestObject()]).then(function () {
      const query = new Parse.Query(TestObject);
      query.count().then(function (count) {
        equal(count, 2);
        query.skip(1);
        query.count().then(function (count) {
          equal(count, 2);
          query.skip(3);
          query.count().then(function (count) {
            equal(count, 2);
            done();
          });
        });
      });
    });
  });

  it('count', function (done) {
    const makeBoxedNumber = function (i) {
      return new BoxedNumber({ number: i });
    };
    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {
      const query = new Parse.Query(BoxedNumber);
      query.greaterThan('number', 1);
      query.count().then(function (count) {
        equal(count, 8);
        done();
      });
    });
  });

  it('order by ascending number', function (done) {
    const makeBoxedNumber = function (i) {
      return new BoxedNumber({ number: i });
    };
    Parse.Object.saveAll([3, 1, 2].map(makeBoxedNumber)).then(function () {
      const query = new Parse.Query(BoxedNumber);
      query.ascending('number');
      query.find().then(function (results) {
        equal(results.length, 3);
        equal(results[0].get('number'), 1);
        equal(results[1].get('number'), 2);
        equal(results[2].get('number'), 3);
        done();
      });
    });
  });

  it('order by descending number', function (done) {
    const makeBoxedNumber = function (i) {
      return new BoxedNumber({ number: i });
    };
    Parse.Object.saveAll([3, 1, 2].map(makeBoxedNumber)).then(function () {
      const query = new Parse.Query(BoxedNumber);
      query.descending('number');
      query.find().then(function (results) {
        equal(results.length, 3);
        equal(results[0].get('number'), 3);
        equal(results[1].get('number'), 2);
        equal(results[2].get('number'), 1);
        done();
      });
    });
  });

  it('can order on an object string field', function (done) {
    const testSet = [
      { sortField: { value: 'Z' } },
      { sortField: { value: 'A' } },
      { sortField: { value: 'M' } },
    ];

    const objects = testSet.map(e => new Parse.Object('Test', e));
    Parse.Object.saveAll(objects)
      .then(() => new Parse.Query('Test').addDescending('sortField.value').first())
      .then(result => {
        expect(result.get('sortField').value).toBe('Z');
        return new Parse.Query('Test').addAscending('sortField.value').first();
      })
      .then(result => {
        expect(result.get('sortField').value).toBe('A');
        done();
      })
      .catch(done.fail);
  });

  it('can order on an object string field (level 2)', function (done) {
    const testSet = [
      { sortField: { value: { field: 'Z' } } },
      { sortField: { value: { field: 'A' } } },
      { sortField: { value: { field: 'M' } } },
    ];

    const objects = testSet.map(e => new Parse.Object('Test', e));
    Parse.Object.saveAll(objects)
      .then(() => new Parse.Query('Test').addDescending('sortField.value.field').first())
      .then(result => {
        expect(result.get('sortField').value.field).toBe('Z');
        return new Parse.Query('Test').addAscending('sortField.value.field').first();
      })
      .then(result => {
        expect(result.get('sortField').value.field).toBe('A');
        done();
      })
      .catch(done.fail);
  });

  it_id('65c8238d-cf02-49d0-a919-8a17f5a58280')(it)('can order on an object number field', function (done) {
    const testSet = [
      { sortField: { value: 10 } },
      { sortField: { value: 1 } },
      { sortField: { value: 5 } },
    ];

    const objects = testSet.map(e => new Parse.Object('Test', e));
    Parse.Object.saveAll(objects)
      .then(() => new Parse.Query('Test').addDescending('sortField.value').first())
      .then(result => {
        expect(result.get('sortField').value).toBe(10);
        return new Parse.Query('Test').addAscending('sortField.value').first();
      })
      .then(result => {
        expect(result.get('sortField').value).toBe(1);
        done();
      })
      .catch(done.fail);
  });

  it_id('d8f0bead-b931-4d66-8b0c-28c5705e463c')(it)('can order on an object number field (level 2)', function (done) {
    const testSet = [
      { sortField: { value: { field: 10 } } },
      { sortField: { value: { field: 1 } } },
      { sortField: { value: { field: 5 } } },
    ];

    const objects = testSet.map(e => new Parse.Object('Test', e));
    Parse.Object.saveAll(objects)
      .then(() => new Parse.Query('Test').addDescending('sortField.value.field').first())
      .then(result => {
        expect(result.get('sortField').value.field).toBe(10);
        return new Parse.Query('Test').addAscending('sortField.value.field').first();
      })
      .then(result => {
        expect(result.get('sortField').value.field).toBe(1);
        done();
      })
      .catch(done.fail);
  });

  it('order by ascending number then descending string', function (done) {
    const strings = ['a', 'b', 'c', 'd'];
    const makeBoxedNumber = function (num, i) {
      return new BoxedNumber({ number: num, string: strings[i] });
    };
    Parse.Object.saveAll([3, 1, 3, 2].map(makeBoxedNumber)).then(function () {
      const query = new Parse.Query(BoxedNumber);
      query.ascending('number').addDescending('string');
      query.find().then(function (results) {
        equal(results.length, 4);
        equal(results[0].get('number'), 1);
        equal(results[0].get('string'), 'b');
        equal(results[1].get('number'), 2);
        equal(results[1].get('string'), 'd');
        equal(results[2].get('number'), 3);
        equal(results[2].get('string'), 'c');
        equal(results[3].get('number'), 3);
        equal(results[3].get('string'), 'a');
        done();
      });
    });
  });

  it('order by non-existing string', async () => {
    const strings = ['a', 'b', 'c', 'd'];
    const makeBoxedNumber = function (num, i) {
      return new BoxedNumber({ number: num, string: strings[i] });
    };
    await Parse.Object.saveAll([3, 1, 3, 2].map(makeBoxedNumber));
    const results = await new Parse.Query(BoxedNumber).ascending('foo').find();
    expect(results.length).toBe(4);
  });

  it('order by descending number then ascending string', function (done) {
    const strings = ['a', 'b', 'c', 'd'];
    const makeBoxedNumber = function (num, i) {
      return new BoxedNumber({ number: num, string: strings[i] });
    };

    const objects = [3, 1, 3, 2].map(makeBoxedNumber);
    Parse.Object.saveAll(objects)
      .then(() => {
        const query = new Parse.Query(BoxedNumber);
        query.descending('number').addAscending('string');
        return query.find();
      })
      .then(
        results => {
          equal(results.length, 4);
          equal(results[0].get('number'), 3);
          equal(results[0].get('string'), 'a');
          equal(results[1].get('number'), 3);
          equal(results[1].get('string'), 'c');
          equal(results[2].get('number'), 2);
          equal(results[2].get('string'), 'd');
          equal(results[3].get('number'), 1);
          equal(results[3].get('string'), 'b');
          done();
        },
        err => {
          jfail(err);
          done();
        }
      );
  });

  it('order by descending number and string', function (done) {
    const strings = ['a', 'b', 'c', 'd'];
    const makeBoxedNumber = function (num, i) {
      return new BoxedNumber({ number: num, string: strings[i] });
    };
    Parse.Object.saveAll([3, 1, 3, 2].map(makeBoxedNumber)).then(function () {
      const query = new Parse.Query(BoxedNumber);
      query.descending('number,string');
      query.find().then(function (results) {
        equal(results.length, 4);
        equal(results[0].get('number'), 3);
        equal(results[0].get('string'), 'c');
        equal(results[1].get('number'), 3);
        equal(results[1].get('string'), 'a');
        equal(results[2].get('number'), 2);
        equal(results[2].get('string'), 'd');
        equal(results[3].get('number'), 1);
        equal(results[3].get('string'), 'b');
        done();
      });
    });
  });

  it('order by descending number and string, with space', function (done) {
    const strings = ['a', 'b', 'c', 'd'];
    const makeBoxedNumber = function (num, i) {
      return new BoxedNumber({ number: num, string: strings[i] });
    };
    Parse.Object.saveAll([3, 1, 3, 2].map(makeBoxedNumber)).then(
      function () {
        const query = new Parse.Query(BoxedNumber);
        query.descending('number, string');
        query.find().then(function (results) {
          equal(results.length, 4);
          equal(results[0].get('number'), 3);
          equal(results[0].get('string'), 'c');
          equal(results[1].get('number'), 3);
          equal(results[1].get('string'), 'a');
          equal(results[2].get('number'), 2);
          equal(results[2].get('string'), 'd');
          equal(results[3].get('number'), 1);
          equal(results[3].get('string'), 'b');
          done();
        });
      },
      err => {
        jfail(err);
        done();
      }
    );
  });

  it('order by descending number and string, with array arg', function (done) {
    const strings = ['a', 'b', 'c', 'd'];
    const makeBoxedNumber = function (num, i) {
      return new BoxedNumber({ number: num, string: strings[i] });
    };
    Parse.Object.saveAll([3, 1, 3, 2].map(makeBoxedNumber)).then(function () {
      const query = new Parse.Query(BoxedNumber);
      query.descending(['number', 'string']);
      query.find().then(function (results) {
        equal(results.length, 4);
        equal(results[0].get('number'), 3);
        equal(results[0].get('string'), 'c');
        equal(results[1].get('number'), 3);
        equal(results[1].get('string'), 'a');
        equal(results[2].get('number'), 2);
        equal(results[2].get('string'), 'd');
        equal(results[3].get('number'), 1);
        equal(results[3].get('string'), 'b');
        done();
      });
    });
  });

  it('order by descending number and string, with multiple args', function (done) {
    const strings = ['a', 'b', 'c', 'd'];
    const makeBoxedNumber = function (num, i) {
      return new BoxedNumber({ number: num, string: strings[i] });
    };
    Parse.Object.saveAll([3, 1, 3, 2].map(makeBoxedNumber)).then(function () {
      const query = new Parse.Query(BoxedNumber);
      query.descending('number', 'string');
      query.find().then(function (results) {
        equal(results.length, 4);
        equal(results[0].get('number'), 3);
        equal(results[0].get('string'), 'c');
        equal(results[1].get('number'), 3);
        equal(results[1].get('string'), 'a');
        equal(results[2].get('number'), 2);
        equal(results[2].get('string'), 'd');
        equal(results[3].get('number'), 1);
        equal(results[3].get('string'), 'b');
        done();
      });
    });
  });

  it(""can't order by password"", function (done) {
    const makeBoxedNumber = function (i) {
      return new BoxedNumber({ number: i });
    };
    Parse.Object.saveAll([3, 1, 2].map(makeBoxedNumber)).then(function () {
      const query = new Parse.Query(BoxedNumber);
      query.ascending('_password');
      query
        .find()
        .then(done.fail)
        .catch(e => expect(e.code).toBe(Parse.Error.INVALID_KEY_NAME))
        .then(done);
    });
  });

  it('order by _created_at', function (done) {
    const makeBoxedNumber = function (i) {
      return new BoxedNumber({ number: i });
    };
    const numbers = [3, 1, 2].map(makeBoxedNumber);
    numbers[0]
      .save()
      .then(() => {
        return numbers[1].save();
      })
      .then(() => {
        return numbers[2].save();
      })
      .then(function () {
        const query = new Parse.Query(BoxedNumber);
        query.ascending('_created_at');
        query.find().then(function (results) {
          equal(results.length, 3);
          equal(results[0].get('number'), 3);
          equal(results[1].get('number'), 1);
          equal(results[2].get('number'), 2);
          done();
        }, done.fail);
      });
  });

  it('order by createdAt', function (done) {
    const makeBoxedNumber = function (i) {
      return new BoxedNumber({ number: i });
    };
    const numbers = [3, 1, 2].map(makeBoxedNumber);
    numbers[0]
      .save()
      .then(() => {
        return numbers[1].save();
      })
      .then(() => {
        return numbers[2].save();
      })
      .then(function () {
        const query = new Parse.Query(BoxedNumber);
        query.descending('createdAt');
        query.find().then(function (results) {
          equal(results.length, 3);
          equal(results[0].get('number'), 2);
          equal(results[1].get('number'), 1);
          equal(results[2].get('number'), 3);
          done();
        });
      });
  });

  it('order by _updated_at', function (done) {
    const makeBoxedNumber = function (i) {
      return new BoxedNumber({ number: i });
    };
    const numbers = [3, 1, 2].map(makeBoxedNumber);
    numbers[0]
      .save()
      .then(() => {
        return numbers[1].save();
      })
      .then(() => {
        return numbers[2].save();
      })
      .then(function () {
        numbers[1].set('number', 4);
        numbers[1].save().then(function () {
          const query = new Parse.Query(BoxedNumber);
          query.ascending('_updated_at');
          query.find().then(function (results) {
            equal(results.length, 3);
            equal(results[0].get('number'), 3);
            equal(results[1].get('number'), 2);
            equal(results[2].get('number'), 4);
            done();
          });
        });
      });
  });

  it('order by updatedAt', function (done) {
    const makeBoxedNumber = function (i) {
      return new BoxedNumber({ number: i });
    };
    const numbers = [3, 1, 2].map(makeBoxedNumber);
    numbers[0]
      .save()
      .then(() => {
        return numbers[1].save();
      })
      .then(() => {
        return numbers[2].save();
      })
      .then(function () {
        numbers[1].set('number', 4);
        numbers[1].save().then(function () {
          const query = new Parse.Query(BoxedNumber);
          query.descending('_updated_at');
          query.find().then(function (results) {
            equal(results.length, 3);
            equal(results[0].get('number'), 4);
            equal(results[1].get('number'), 2);
            equal(results[2].get('number'), 3);
            done();
          });
        });
      });
  });

  // Returns a promise
  function makeTimeObject(start, i) {
    const time = new Date();
    time.setSeconds(start.getSeconds() + i);
    const item = new TestObject({ name: 'item' + i, time: time });
    return item.save();
  }

  // Returns a promise for all the time objects
  function makeThreeTimeObjects() {
    const start = new Date();
    let one, two, three;
    return makeTimeObject(start, 1)
      .then(o1 => {
        one = o1;
        return makeTimeObject(start, 2);
      })
      .then(o2 => {
        two = o2;
        return makeTimeObject(start, 3);
      })
      .then(o3 => {
        three = o3;
        return [one, two, three];
      });
  }

  it('time equality', function (done) {
    makeThreeTimeObjects().then(function (list) {
      const query = new Parse.Query(TestObject);
      query.equalTo('time', list[1].get('time'));
      query.find().then(function (results) {
        equal(results.length, 1);
        equal(results[0].get('name'), 'item2');
        done();
      });
    });
  });

  it('time lessThan', function (done) {
    makeThreeTimeObjects().then(function (list) {
      const query = new Parse.Query(TestObject);
      query.lessThan('time', list[2].get('time'));
      query.find().then(function (results) {
        equal(results.length, 2);
        done();
      });
    });
  });

  // This test requires Date objects to be consistently stored as a Date.
  it('time createdAt', function (done) {
    makeThreeTimeObjects().then(function (list) {
      const query = new Parse.Query(TestObject);
      query.greaterThanOrEqualTo('createdAt', list[0].createdAt);
      query.find().then(function (results) {
        equal(results.length, 3);
        done();
      });
    });
  });

  it('matches string', function (done) {
    const thing1 = new TestObject();
    thing1.set('myString', 'football');
    const thing2 = new TestObject();
    thing2.set('myString', 'soccer');
    Parse.Object.saveAll([thing1, thing2]).then(function () {
      const query = new Parse.Query(TestObject);
      query.matches('myString', '^fo*\\wb[^o]l+$');
      query.find().then(function (results) {
        equal(results.length, 1);
        done();
      });
    });
  });

  it('matches regex', function (done) {
    const thing1 = new TestObject();
    thing1.set('myString', 'football');
    const thing2 = new TestObject();
    thing2.set('myString', 'soccer');
    Parse.Object.saveAll([thing1, thing2]).then(function () {
      const query = new Parse.Query(TestObject);
      query.matches('myString', /^fo*\wb[^o]l+$/);
      query.find().then(function (results) {
        equal(results.length, 1);
        done();
      });
    });
  });

  it('case insensitive regex success', function (done) {
    const thing = new TestObject();
    thing.set('myString', 'football');
    Parse.Object.saveAll([thing]).then(function () {
      const query = new Parse.Query(TestObject);
      query.matches('myString', 'FootBall', 'i');
      query.find().then(done);
    });
  });

  it('regexes with invalid options fail', function (done) {
    const query = new Parse.Query(TestObject);
    query.matches('myString', 'FootBall', 'some invalid option');
    query
      .find()
      .then(done.fail)
      .catch(e => expect(e.code).toBe(Parse.Error.INVALID_QUERY))
      .then(done);
  });

  it_id('351f57a8-e00a-4da2-887d-6e25c9e359fc')(it)('regex with unicode option', async function () {
    const thing = new TestObject();
    thing.set('myString', 'hello 世界');
    await Parse.Object.saveAll([thing]);
    const query = new Parse.Query(TestObject);
    query.matches('myString', '世界', 'u');
    const results = await query.find();
    equal(results.length, 1);
  });

  it_id('823852f6-1de5-45ba-a2b9-ed952fcc6012')(it)('Use a regex that requires all modifiers', function (done) {
    const thing = new TestObject();
    thing.set('myString', 'PArSe\nCom');
    Parse.Object.saveAll([thing]).then(function () {
      const query = new Parse.Query(TestObject);
      query.matches(
        'myString',
        ""parse # First fragment. We'll write this in one case but match insensitively\n"" +
          '.com  # Second fragment. This can be separated by any character, including newline;' +
          'however, this comment must end with a newline to recognize it as a comment\n',
        'mixs'
      );
      query.find().then(
        function (results) {
          equal(results.length, 1);
          done();
        },
        function (err) {
          jfail(err);
          done();
        }
      );
    });
  });

  it('Regular expression constructor includes modifiers inline', function (done) {
    const thing = new TestObject();
    thing.set('myString', '\n\nbuffer\n\nparse.COM');
    Parse.Object.saveAll([thing]).then(function () {
      const query = new Parse.Query(TestObject);
      query.matches('myString', /parse\.com/im);
      query.find().then(function (results) {
        equal(results.length, 1);
        done();
      });
    });
  });

  const someAscii =
    ""\\E' !\""#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTU"" +
    ""VWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~'"";

  it('contains', function (done) {
    Parse.Object.saveAll([
      new TestObject({ myString: 'zax' + someAscii + 'qub' }),
      new TestObject({ myString: 'start' + someAscii }),
      new TestObject({ myString: someAscii + 'end' }),
      new TestObject({ myString: someAscii }),
    ]).then(function () {
      const query = new Parse.Query(TestObject);
      query.contains('myString', someAscii);
      query.find().then(function (results) {
        equal(results.length, 4);
        done();
      });
    });
  });

  it('nested contains', done => {
    const sender1 = { group: ['A', 'B'] };
    const sender2 = { group: ['A', 'C'] };
    const sender3 = { group: ['B', 'C'] };
    const obj1 = new TestObject({ sender: sender1 });
    const obj2 = new TestObject({ sender: sender2 });
    const obj3 = new TestObject({ sender: sender3 });
    Parse.Object.saveAll([obj1, obj2, obj3])
      .then(() => {
        const query = new Parse.Query(TestObject);
        query.contains('sender.group', 'A');
        return query.find();
      })
      .then(results => {
        equal(results.length, 2);
        done();
      }, done.fail);
  });

  it('startsWith', function (done) {
    Parse.Object.saveAll([
      new TestObject({ myString: 'zax' + someAscii + 'qub' }),
      new TestObject({ myString: 'start' + someAscii }),
      new TestObject({ myString: someAscii + 'end' }),
      new TestObject({ myString: someAscii }),
    ]).then(function () {
      const query = new Parse.Query(TestObject);
      query.startsWith('myString', someAscii);
      query.find().then(function (results) {
        equal(results.length, 2);
        done();
      });
    });
  });

  it('endsWith', function (done) {
    Parse.Object.saveAll([
      new TestObject({ myString: 'zax' + someAscii + 'qub' }),
      new TestObject({ myString: 'start' + someAscii }),
      new TestObject({ myString: someAscii + 'end' }),
      new TestObject({ myString: someAscii }),
    ]).then(function () {
      const query = new Parse.Query(TestObject);
      query.endsWith('myString', someAscii);
      query.find().then(function (results) {
        equal(results.length, 2);
        done();
      });
    });
  });

  it('exists', function (done) {
    const objects = [];
    for (const i of [0, 1, 2, 3, 4, 5, 6, 7, 8]) {
      const item = new TestObject();
      if (i % 2 === 0) {
        item.set('x', i + 1);
      } else {
        item.set('y', i + 1);
      }
      objects.push(item);
    }
    Parse.Object.saveAll(objects).then(function () {
      const query = new Parse.Query(TestObject);
      query.exists('x');
      query.find().then(function (results) {
        equal(results.length, 5);
        for (const result of results) {
          ok(result.get('x'));
        }
        done();
      });
    });
  });

  it('doesNotExist', function (done) {
    const objects = [];
    for (const i of [0, 1, 2, 3, 4, 5, 6, 7, 8]) {
      const item = new TestObject();
      if (i % 2 === 0) {
        item.set('x', i + 1);
      } else {
        item.set('y', i + 1);
      }
      objects.push(item);
    }
    Parse.Object.saveAll(objects).then(function () {
      const query = new Parse.Query(TestObject);
      query.doesNotExist('x');
      query.find().then(function (results) {
        equal(results.length, 4);
        for (const result of results) {
          ok(result.get('y'));
        }
        done();
      });
    });
  });

  it('exists relation', function (done) {
    const objects = [];
    for (const i of [0, 1, 2, 3, 4, 5, 6, 7, 8]) {
      const container = new Container();
      if (i % 2 === 0) {
        const item = new TestObject();
        item.set('x', i);
        container.set('x', item);
        objects.push(item);
      } else {
        container.set('y', i);
      }
      objects.push(container);
    }
    Parse.Object.saveAll(objects).then(function () {
      const query = new Parse.Query(Container);
      query.exists('x');
      query.find().then(function (results) {
        equal(results.length, 5);
        for (const result of results) {
          ok(result.get('x'));
        }
        done();
      });
    });
  });

  it('doesNotExist relation', function (done) {
    const objects = [];
    for (const i of [0, 1, 2, 3, 4, 5, 6, 7]) {
      const container = new Container();
      if (i % 2 === 0) {
        const item = new TestObject();
        item.set('x', i);
        container.set('x', item);
        objects.push(item);
      } else {
        container.set('y', i);
      }
      objects.push(container);
    }
    Parse.Object.saveAll(objects).then(function () {
      const query = new Parse.Query(Container);
      query.doesNotExist('x');
      query.find().then(function (results) {
        equal(results.length, 4);
        for (const result of results) {
          ok(result.get('y'));
        }
        done();
      });
    });
  });

  it(""don't include by default"", function (done) {
    const child = new TestObject();
    const parent = new Container();
    child.set('foo', 'bar');
    parent.set('child', child);
    Parse.Object.saveAll([child, parent]).then(function () {
      child._clearServerData();
      const query = new Parse.Query(Container);
      query.find().then(function (results) {
        equal(results.length, 1);
        const parentAgain = results[0];
        const goodURL = Parse.serverURL;
        Parse.serverURL = 'YAAAAAAAAARRRRRGGGGGGGGG';
        const childAgain = parentAgain.get('child');
        ok(childAgain);
        equal(childAgain.get('foo'), undefined);
        Parse.serverURL = goodURL;
        done();
      });
    });
  });

  it('include relation', function (done) {
    const child = new TestObject();
    const parent = new Container();
    child.set('foo', 'bar');
    parent.set('child', child);
    Parse.Object.saveAll([child, parent]).then(function () {
      const query = new Parse.Query(Container);
      query.include('child');
      query.find().then(function (results) {
        equal(results.length, 1);
        const parentAgain = results[0];
        const goodURL = Parse.serverURL;
        Parse.serverURL = 'YAAAAAAAAARRRRRGGGGGGGGG';
        const childAgain = parentAgain.get('child');
        ok(childAgain);
        equal(childAgain.get('foo'), 'bar');
        Parse.serverURL = goodURL;
        done();
      });
    });
  });

  it('include relation array', function (done) {
    const child = new TestObject();
    const parent = new Container();
    child.set('foo', 'bar');
    parent.set('child', child);
    Parse.Object.saveAll([child, parent]).then(function () {
      const query = new Parse.Query(Container);
      query.include(['child']);
      query.find().then(function (results) {
        equal(results.length, 1);
        const parentAgain = results[0];
        const goodURL = Parse.serverURL;
        Parse.serverURL = 'YAAAAAAAAARRRRRGGGGGGGGG';
        const childAgain = parentAgain.get('child');
        ok(childAgain);
        equal(childAgain.get('foo'), 'bar');
        Parse.serverURL = goodURL;
        done();
      });
    });
  });

  it('nested include', function (done) {
    const Child = Parse.Object.extend('Child');
    const Parent = Parse.Object.extend('Parent');
    const Grandparent = Parse.Object.extend('Grandparent');
    const objects = [];
    for (let i = 0; i < 5; ++i) {
      const grandparent = new Grandparent({
        z: i,
        parent: new Parent({
          y: i,
          child: new Child({
            x: i,
          }),
        }),
      });
      objects.push(grandparent);
    }

    Parse.Object.saveAll(objects).then(function () {
      const query = new Parse.Query(Grandparent);
      query.include(['parent.child']);
      query.find().then(function (results) {
        equal(results.length, 5);
        for (const object of results) {
          equal(object.get('z'), object.get('parent').get('y'));
          equal(object.get('z'), object.get('parent').get('child').get('x'));
        }
        done();
      });
    });
  });

  it(""include doesn't make dirty wrong"", function (done) {
    const Parent = Parse.Object.extend('ParentObject');
    const Child = Parse.Object.extend('ChildObject');
    const parent = new Parent();
    const child = new Child();
    child.set('foo', 'bar');
    parent.set('child', child);

    Parse.Object.saveAll([child, parent]).then(function () {
      const query = new Parse.Query(Parent);
      query.include('child');
      query.find().then(function (results) {
        equal(results.length, 1);
        const parentAgain = results[0];
        const childAgain = parentAgain.get('child');
        equal(childAgain.id, child.id);
        equal(parentAgain.id, parent.id);
        equal(childAgain.get('foo'), 'bar');
        equal(false, parentAgain.dirty());
        equal(false, childAgain.dirty());
        done();
      });
    });
  });

  it('properly includes array', done => {
    const objects = [];
    let total = 0;
    while (objects.length != 5) {
      const object = new Parse.Object('AnObject');
      object.set('key', objects.length);
      total += objects.length;
      objects.push(object);
    }
    Parse.Object.saveAll(objects)
      .then(() => {
        const object = new Parse.Object('AContainer');
        object.set('objects', objects);
        return object.save();
      })
      .then(() => {
        const query = new Parse.Query('AContainer');
        query.include('objects');
        return query.find();
      })
      .then(
        results => {
          expect(results.length).toBe(1);
          const res = results[0];
          const objects = res.get('objects');
          expect(objects.length).toBe(5);
          objects.forEach(object => {
            total -= object.get('key');
          });
          expect(total).toBe(0);
          done();
        },
        () => {
          fail('should not fail');
          done();
        }
      );
  });

  it('properly includes array of mixed objects', done => {
    const objects = [];
    let total = 0;
    while (objects.length != 5) {
      const object = new Parse.Object('AnObject');
      object.set('key', objects.length);
      total += objects.length;
      objects.push(object);
    }
    while (objects.length != 10) {
      const object = new Parse.Object('AnotherObject');
      object.set('key', objects.length);
      total += objects.length;
      objects.push(object);
    }
    Parse.Object.saveAll(objects)
      .then(() => {
        const object = new Parse.Object('AContainer');
        object.set('objects', objects);
        return object.save();
      })
      .then(() => {
        const query = new Parse.Query('AContainer');
        query.include('objects');
        return query.find();
      })
      .then(
        results => {
          expect(results.length).toBe(1);
          const res = results[0];
          const objects = res.get('objects');
          expect(objects.length).toBe(10);
          objects.forEach(object => {
            total -= object.get('key');
          });
          expect(total).toBe(0);
          done();
        },
        e => {
          fail('should not fail');
          fail(JSON.stringify(e));
          done();
        }
      );
  });

  it('properly nested array of mixed objects with bad ids', done => {
    const objects = [];
    let total = 0;
    while (objects.length != 5) {
      const object = new Parse.Object('AnObject');
      object.set('key', objects.length);
      objects.push(object);
    }
    while (objects.length != 10) {
      const object = new Parse.Object('AnotherObject');
      object.set('key', objects.length);
      objects.push(object);
    }
    Parse.Object.saveAll(objects)
      .then(() => {
        const object = new Parse.Object('AContainer');
        for (let i = 0; i < objects.length; i++) {
          if (i % 2 == 0) {
            objects[i].id = 'randomThing';
          } else {
            total += objects[i].get('key');
          }
        }
        object.set('objects', objects);
        return object.save();
      })
      .then(() => {
        const query = new Parse.Query('AContainer');
        query.include('objects');
        return query.find();
      })
      .then(
        results => {
          expect(results.length).toBe(1);
          const res = results[0];
          const objects = res.get('objects');
          expect(objects.length).toBe(5);
          objects.forEach(object => {
            total -= object.get('key');
          });
          expect(total).toBe(0);
          done();
        },
        err => {
          jfail(err);
          fail('should not fail');
          done();
        }
      );
  });

  it('properly fetches nested pointers', done => {
    const color = new Parse.Object('Color');
    color.set('hex', '#133733');
    const circle = new Parse.Object('Circle');
    circle.set('radius', 1337);

    Parse.Object.saveAll([color, circle])
      .then(() => {
        circle.set('color', color);
        const badCircle = new Parse.Object('Circle');
        badCircle.id = 'badId';
        const complexFigure = new Parse.Object('ComplexFigure');
        complexFigure.set('consistsOf', [circle, badCircle]);
        return complexFigure.save();
      })
      .then(() => {
        const q = new Parse.Query('ComplexFigure');
        q.include('consistsOf.color');
        return q.find();
      })
      .then(
        results => {
          expect(results.length).toBe(1);
          const figure = results[0];
          expect(figure.get('consistsOf').length).toBe(1);
          expect(figure.get('consistsOf')[0].get('color').get('hex')).toBe('#133733');
          done();
        },
        () => {
          fail('should not fail');
          done();
        }
      );
  });

  it('result object creation uses current extension', function (done) {
    const ParentObject = Parse.Object.extend({ className: 'ParentObject' });
    // Add a foo() method to ChildObject.
    let ChildObject = Parse.Object.extend('ChildObject', {
      foo: function () {
        return 'foo';
      },
    });

    const parent = new ParentObject();
    const child = new ChildObject();
    parent.set('child', child);
    Parse.Object.saveAll([child, parent]).then(function () {
      // Add a bar() method to ChildObject.
      ChildObject = Parse.Object.extend('ChildObject', {
        bar: function () {
          return 'bar';
        },
      });

      const query = new Parse.Query(ParentObject);
      query.include('child');
      query.find().then(function (results) {
        equal(results.length, 1);
        const parentAgain = results[0];
        const childAgain = parentAgain.get('child');
        equal(childAgain.foo(), 'foo');
        equal(childAgain.bar(), 'bar');
        done();
      });
    });
  });

  it('matches query', function (done) {
    const ParentObject = Parse.Object.extend('ParentObject');
    const ChildObject = Parse.Object.extend('ChildObject');
    const objects = [];
    for (let i = 0; i < 10; ++i) {
      objects.push(
        new ParentObject({
          child: new ChildObject({ x: i }),
          x: 10 + i,
        })
      );
    }
    Parse.Object.saveAll(objects).then(function () {
      const subQuery = new Parse.Query(ChildObject);
      subQuery.greaterThan('x', 5);
      const query = new Parse.Query(ParentObject);
      query.matchesQuery('child', subQuery);
      query.find().then(function (results) {
        equal(results.length, 4);
        for (const object of results) {
          ok(object.get('x') > 15);
        }
        const query = new Parse.Query(ParentObject);
        query.doesNotMatchQuery('child', subQuery);
        query.find().then(function (results) {
          equal(results.length, 6);
          for (const object of results) {
            ok(object.get('x') >= 10);
            ok(object.get('x') <= 15);
            done();
          }
        });
      });
    });
  });

  it('select query', function (done) {
    const RestaurantObject = Parse.Object.extend('Restaurant');
    const PersonObject = Parse.Object.extend('Person');
    const objects = [
      new RestaurantObject({ ratings: 5, location: 'Djibouti' }),
      new RestaurantObject({ ratings: 3, location: 'Ouagadougou' }),
      new PersonObject({ name: 'Bob', hometown: 'Djibouti' }),
      new PersonObject({ name: 'Tom', hometown: 'Ouagadougou' }),
      new PersonObject({ name: 'Billy', hometown: 'Detroit' }),
    ];

    Parse.Object.saveAll(objects).then(function () {
      const query = new Parse.Query(RestaurantObject);
      query.greaterThan('ratings', 4);
      const mainQuery = new Parse.Query(PersonObject);
      mainQuery.matchesKeyInQuery('hometown', 'location', query);
      mainQuery.find().then(function (results) {
        equal(results.length, 1);
        equal(results[0].get('name'), 'Bob');
        done();
      });
    });
  });

  it('$select inside $or', done => {
    const Restaurant = Parse.Object.extend('Restaurant');
    const Person = Parse.Object.extend('Person');
    const objects = [
      new Restaurant({ ratings: 5, location: 'Djibouti' }),
      new Restaurant({ ratings: 3, location: 'Ouagadougou' }),
      new Person({ name: 'Bob', hometown: 'Djibouti' }),
      new Person({ name: 'Tom', hometown: 'Ouagadougou' }),
      new Person({ name: 'Billy', hometown: 'Detroit' }),
    ];

    Parse.Object.saveAll(objects)
      .then(() => {
        const subquery = new Parse.Query(Restaurant);
        subquery.greaterThan('ratings', 4);
        const query1 = new Parse.Query(Person);
        query1.matchesKeyInQuery('hometown', 'location', subquery);
        const query2 = new Parse.Query(Person);
        query2.equalTo('name', 'Tom');
        const query = Parse.Query.or(query1, query2);
        return query.find();
      })
      .then(
        results => {
          expect(results.length).toEqual(2);
          done();
        },
        error => {
          jfail(error);
          done();
        }
      );
  });

  it('$nor valid query', done => {
    const objects = Array.from(Array(10).keys()).map(rating => {
      return new TestObject({ rating: rating });
    });

    const highValue = 5;
    const lowValue = 3;
    const options = Object.assign({}, masterKeyOptions, {
      qs: {
        where: JSON.stringify({
          $nor: [{ rating: { $gt: highValue } }, { rating: { $lte: lowValue } }],
        }),
      },
    });

    Parse.Object.saveAll(objects)
      .then(() => {
        return request(Object.assign({ url: Parse.serverURL + '/classes/TestObject' }, options));
      })
      .then(response => {
        const results = response.data;
        expect(results.results.length).toBe(highValue - lowValue);
        expect(results.results.every(res => res.rating > lowValue && res.rating <= highValue)).toBe(
          true
        );
        done();
      });
  });

  it('$nor invalid query - empty array', done => {
    const options = Object.assign({}, masterKeyOptions, {
      qs: {
        where: JSON.stringify({ $nor: [] }),
      },
    });
    const obj = new TestObject();
    obj
      .save()
      .then(() => {
        return request(Object.assign({ url: Parse.serverURL + '/classes/TestObject' }, options));
      })
      .then(done.fail)
      .catch(response => {
        equal(response.data.code, Parse.Error.INVALID_QUERY);
        done();
      });
  });

  it('$nor invalid query - wrong type', done => {
    const options = Object.assign({}, masterKeyOptions, {
      qs: {
        where: JSON.stringify({ $nor: 1337 }),
      },
    });
    const obj = new TestObject();
    obj
      .save()
      .then(() => {
        return request(Object.assign({ url: Parse.serverURL + '/classes/TestObject' }, options));
      })
      .then(done.fail)
      .catch(response => {
        equal(response.data.code, Parse.Error.INVALID_QUERY);
        done();
      });
  });

  it('dontSelect query', function (done) {
    const RestaurantObject = Parse.Object.extend('Restaurant');
    const PersonObject = Parse.Object.extend('Person');
    const objects = [
      new RestaurantObject({ ratings: 5, location: 'Djibouti' }),
      new RestaurantObject({ ratings: 3, location: 'Ouagadougou' }),
      new PersonObject({ name: 'Bob', hometown: 'Djibouti' }),
      new PersonObject({ name: 'Tom', hometown: 'Ouagadougou' }),
      new PersonObject({ name: 'Billy', hometown: 'Djibouti' }),
    ];

    Parse.Object.saveAll(objects).then(function () {
      const query = new Parse.Query(RestaurantObject);
      query.greaterThan('ratings', 4);
      const mainQuery = new Parse.Query(PersonObject);
      mainQuery.doesNotMatchKeyInQuery('hometown', 'location', query);
      mainQuery.find().then(function (results) {
        equal(results.length, 1);
        equal(results[0].get('name'), 'Tom');
        done();
      });
    });
  });

  it('dontSelect query without conditions', function (done) {
    const RestaurantObject = Parse.Object.extend('Restaurant');
    const PersonObject = Parse.Object.extend('Person');
    const objects = [
      new RestaurantObject({ location: 'Djibouti' }),
      new RestaurantObject({ location: 'Ouagadougou' }),
      new PersonObject({ name: 'Bob', hometown: 'Djibouti' }),
      new PersonObject({ name: 'Tom', hometown: 'Yoloblahblahblah' }),
      new PersonObject({ name: 'Billy', hometown: 'Ouagadougou' }),
    ];

    Parse.Object.saveAll(objects).then(function () {
      const query = new Parse.Query(RestaurantObject);
      const mainQuery = new Parse.Query(PersonObject);
      mainQuery.doesNotMatchKeyInQuery('hometown', 'location', query);
      mainQuery.find().then(results => {
        equal(results.length, 1);
        equal(results[0].get('name'), 'Tom');
        done();
      });
    });
  });

  it('equalTo on same column as $dontSelect should not break $dontSelect functionality (#3678)', function (done) {
    const AuthorObject = Parse.Object.extend('Author');
    const BlockedObject = Parse.Object.extend('Blocked');
    const PostObject = Parse.Object.extend('Post');

    let postAuthor = null;
    let requestUser = null;

    return new AuthorObject({ name: 'Julius' })
      .save()
      .then(user => {
        postAuthor = user;
        return new AuthorObject({ name: 'Bob' }).save();
      })
      .then(user => {
        requestUser = user;
        const objects = [
          new PostObject({ author: postAuthor, title: 'Lorem ipsum' }),
          new PostObject({ author: requestUser, title: 'Kafka' }),
          new PostObject({ author: requestUser, title: 'Brown fox' }),
          new BlockedObject({
            blockedBy: postAuthor,
            blockedUser: requestUser,
          }),
        ];
        return Parse.Object.saveAll(objects);
      })
      .then(() => {
        const banListQuery = new Parse.Query(BlockedObject);
        banListQuery.equalTo('blockedUser', requestUser);

        return new Parse.Query(PostObject)
          .equalTo('author', postAuthor)
          .doesNotMatchKeyInQuery('author', 'blockedBy', banListQuery)
          .find()
          .then(r => {
            expect(r.length).toEqual(0);
            done();
          }, done.fail);
      });
  });

  it('multiple dontSelect query', function (done) {
    const RestaurantObject = Parse.Object.extend('Restaurant');
    const PersonObject = Parse.Object.extend('Person');
    const objects = [
      new RestaurantObject({ ratings: 7, location: 'Djibouti2' }),
      new RestaurantObject({ ratings: 5, location: 'Djibouti' }),
      new RestaurantObject({ ratings: 3, location: 'Ouagadougou' }),
      new PersonObject({ name: 'Bob2', hometown: 'Djibouti2' }),
      new PersonObject({ name: 'Bob', hometown: 'Djibouti' }),
      new PersonObject({ name: 'Tom', hometown: 'Ouagadougou' }),
    ];

    Parse.Object.saveAll(objects).then(function () {
      const query = new Parse.Query(RestaurantObject);
      query.greaterThan('ratings', 6);
      const query2 = new Parse.Query(RestaurantObject);
      query2.lessThan('ratings', 4);
      const subQuery = new Parse.Query(PersonObject);
      subQuery.matchesKeyInQuery('hometown', 'location', query);
      const subQuery2 = new Parse.Query(PersonObject);
      subQuery2.matchesKeyInQuery('hometown', 'location', query2);
      const mainQuery = new Parse.Query(PersonObject);
      mainQuery.doesNotMatchKeyInQuery('objectId', 'objectId', Parse.Query.or(subQuery, subQuery2));
      mainQuery.find().then(function (results) {
        equal(results.length, 1);
        equal(results[0].get('name'), 'Bob');
        done();
      });
    });
  });

  it('include user', function (done) {
    Parse.User.signUp('bob', 'password', { age: 21 }).then(function (user) {
      const TestObject = Parse.Object.extend('TestObject');
      const obj = new TestObject();
      obj
        .save({
          owner: user,
        })
        .then(function (obj) {
          const query = new Parse.Query(TestObject);
          query.include('owner');
          query.get(obj.id).then(function (objAgain) {
            equal(objAgain.id, obj.id);
            ok(objAgain.get('owner') instanceof Parse.User);
            equal(objAgain.get('owner').get('age'), 21);
            done();
          }, done.fail);
        }, done.fail);
    }, done.fail);
  });

  it('or queries', function (done) {
    const objects = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(function (x) {
      const object = new Parse.Object('BoxedNumber');
      object.set('x', x);
      return object;
    });
    Parse.Object.saveAll(objects).then(function () {
      const query1 = new Parse.Query('BoxedNumber');
      query1.lessThan('x', 2);
      const query2 = new Parse.Query('BoxedNumber');
      query2.greaterThan('x', 5);
      const orQuery = Parse.Query.or(query1, query2);
      orQuery.find().then(function (results) {
        equal(results.length, 6);
        for (const number of results) {
          ok(number.get('x') < 2 || number.get('x') > 5);
        }
        done();
      });
    });
  });

  // This relies on matchesQuery aka the $inQuery operator
  it('or complex queries', function (done) {
    const objects = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(function (x) {
      const child = new Parse.Object('Child');
      child.set('x', x);
      const parent = new Parse.Object('Parent');
      parent.set('child', child);
      parent.set('y', x);
      return parent;
    });

    Parse.Object.saveAll(objects).then(function () {
      const subQuery = new Parse.Query('Child');
      subQuery.equalTo('x', 4);
      const query1 = new Parse.Query('Parent');
      query1.matchesQuery('child', subQuery);
      const query2 = new Parse.Query('Parent');
      query2.lessThan('y', 2);
      const orQuery = Parse.Query.or(query1, query2);
      orQuery.find().then(function (results) {
        equal(results.length, 3);
        done();
      });
    });
  });

  it('async methods', function (done) {
    const saves = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(function (x) {
      const obj = new Parse.Object('TestObject');
      obj.set('x', x + 1);
      return obj;
    });

    Parse.Object.saveAll(saves)
      .then(function () {
        const query = new Parse.Query('TestObject');
        query.ascending('x');
        return query.first();
      })
      .then(function (obj) {
        equal(obj.get('x'), 1);
        const query = new Parse.Query('TestObject');
        query.descending('x');
        return query.find();
      })
      .then(function (results) {
        equal(results.length, 10);
        const query = new Parse.Query('TestObject');
        return query.get(results[0].id);
      })
      .then(function (obj1) {
        equal(obj1.get('x'), 10);
        const query = new Parse.Query('TestObject');
        return query.count();
      })
      .then(function (count) {
        equal(count, 10);
      })
      .then(function () {
        done();
      });
  });

  it('query.each', function (done) {
    const TOTAL = 50;
    const COUNT = 25;

    const items = range(TOTAL).map(function (x) {
      const obj = new TestObject();
      obj.set('x', x);
      return obj;
    });

    Parse.Object.saveAll(items).then(function () {
      const query = new Parse.Query(TestObject);
      query.lessThan('x', COUNT);

      const seen = [];
      query
        .each(
          function (obj) {
            seen[obj.get('x')] = (seen[obj.get('x')] || 0) + 1;
          },
          {
            batchSize: 10,
          }
        )
        .then(function () {
          equal(seen.length, COUNT);
          for (let i = 0; i < COUNT; i++) {
            equal(seen[i], 1, 'Should have seen object number ' + i);
          }
          done();
        }, done.fail);
    });
  });

  it('query.each async', function (done) {
    const TOTAL = 50;
    const COUNT = 25;

    expect(COUNT + 1);

    const items = range(TOTAL).map(function (x) {
      const obj = new TestObject();
      obj.set('x', x);
      return obj;
    });

    const seen = [];

    Parse.Object.saveAll(items)
      .then(function () {
        const query = new Parse.Query(TestObject);
        query.lessThan('x', COUNT);
        return query.each(
          function (obj) {
            return new Promise(resolve => {
              process.nextTick(function () {
                seen[obj.get('x')] = (seen[obj.get('x')] || 0) + 1;
                resolve();
              });
            });
          },
          {
            batchSize: 10,
          }
        );
      })
      .then(function () {
        equal(seen.length, COUNT);
        for (let i = 0; i < COUNT; i++) {
          equal(seen[i], 1, 'Should have seen object number ' + i);
        }
        done();
      });
  });

  it('query.each fails with order', function (done) {
    const TOTAL = 50;
    const COUNT = 25;

    const items = range(TOTAL).map(function (x) {
      const obj = new TestObject();
      obj.set('x', x);
      return obj;
    });

    const seen = [];

    Parse.Object.saveAll(items)
      .then(function () {
        const query = new Parse.Query(TestObject);
        query.lessThan('x', COUNT);
        query.ascending('x');
        return query.each(function (obj) {
          seen[obj.get('x')] = (seen[obj.get('x')] || 0) + 1;
        });
      })
      .then(
        function () {
          ok(false, 'This should have failed.');
          done();
        },
        function () {
          done();
        }
      );
  });

  it('query.each fails with skip', function (done) {
    const TOTAL = 50;
    const COUNT = 25;

    const items = range(TOTAL).map(function (x) {
      const obj = new TestObject();
      obj.set('x', x);
      return obj;
    });

    const seen = [];

    Parse.Object.saveAll(items)
      .then(function () {
        const query = new Parse.Query(TestObject);
        query.lessThan('x', COUNT);
        query.skip(5);
        return query.each(function (obj) {
          seen[obj.get('x')] = (seen[obj.get('x')] || 0) + 1;
        });
      })
      .then(
        function () {
          ok(false, 'This should have failed.');
          done();
        },
        function () {
          done();
        }
      );
  });

  it('query.each fails with limit', function (done) {
    const TOTAL = 50;
    const COUNT = 25;

    expect(0);

    const items = range(TOTAL).map(function (x) {
      const obj = new TestObject();
      obj.set('x', x);
      return obj;
    });

    const seen = [];

    Parse.Object.saveAll(items)
      .then(function () {
        const query = new Parse.Query(TestObject);
        query.lessThan('x', COUNT);
        query.limit(5);
        return query.each(function (obj) {
          seen[obj.get('x')] = (seen[obj.get('x')] || 0) + 1;
        });
      })
      .then(
        function () {
          ok(false, 'This should have failed.');
          done();
        },
        function () {
          done();
        }
      );
  });

  it('select keys query JS SDK', async () => {
    const obj = new TestObject({ foo: 'baz', bar: 1, qux: 2 });
    await obj.save();
    obj._clearServerData();
    const query1 = new Parse.Query(TestObject);
    query1.select('foo');
    const result1 = await query1.first();
    ok(result1.id, 'expected object id to be set');
    ok(result1.createdAt, 'expected object createdAt to be set');
    ok(result1.updatedAt, 'expected object updatedAt to be set');
    ok(!result1.dirty(), 'expected result not to be dirty');
    strictEqual(result1.get('foo'), 'baz');
    strictEqual(result1.get('bar'), undefined, ""expected 'bar' field to be unset"");
    strictEqual(result1.get('qux'), undefined, ""expected 'qux' field to be unset"");

    const result2 = await result1.fetch();
    strictEqual(result2.get('foo'), 'baz');
    strictEqual(result2.get('bar'), 1);
    strictEqual(result2.get('qux'), 2);

    obj._clearServerData();
    const query2 = new Parse.Query(TestObject);
    query2.select();
    const result3 = await query2.first();
    ok(result3.id, 'expected object id to be set');
    ok(result3.createdAt, 'expected object createdAt to be set');
    ok(result3.updatedAt, 'expected object updatedAt to be set');
    ok(!result3.dirty(), 'expected result not to be dirty');
    strictEqual(result3.get('foo'), undefined, ""expected 'foo' field to be unset"");
    strictEqual(result3.get('bar'), undefined, ""expected 'bar' field to be unset"");
    strictEqual(result3.get('qux'), undefined, ""expected 'qux' field to be unset"");

    obj._clearServerData();
    const query3 = new Parse.Query(TestObject);
    query3.select([]);
    const result4 = await query3.first();
    ok(result4.id, 'expected object id to be set');
    ok(result4.createdAt, 'expected object createdAt to be set');
    ok(result4.updatedAt, 'expected object updatedAt to be set');
    ok(!result4.dirty(), 'expected result not to be dirty');
    strictEqual(result4.get('foo'), undefined, ""expected 'foo' field to be unset"");
    strictEqual(result4.get('bar'), undefined, ""expected 'bar' field to be unset"");
    strictEqual(result4.get('qux'), undefined, ""expected 'qux' field to be unset"");

    obj._clearServerData();
    const query4 = new Parse.Query(TestObject);
    query4.select(['foo']);
    const result5 = await query4.first();
    ok(result5.id, 'expected object id to be set');
    ok(result5.createdAt, 'expected object createdAt to be set');
    ok(result5.updatedAt, 'expected object updatedAt to be set');
    ok(!result5.dirty(), 'expected result not to be dirty');
    strictEqual(result5.get('foo'), 'baz');
    strictEqual(result5.get('bar'), undefined, ""expected 'bar' field to be unset"");
    strictEqual(result5.get('qux'), undefined, ""expected 'qux' field to be unset"");

    obj._clearServerData();
    const query5 = new Parse.Query(TestObject);
    query5.select(['foo', 'bar']);
    const result6 = await query5.first();
    ok(result6.id, 'expected object id to be set');
    ok(!result6.dirty(), 'expected result not to be dirty');
    strictEqual(result6.get('foo'), 'baz');
    strictEqual(result6.get('bar'), 1);
    strictEqual(result6.get('qux'), undefined, ""expected 'qux' field to be unset"");

    obj._clearServerData();
    const query6 = new Parse.Query(TestObject);
    query6.select(['foo', 'bar', 'qux']);
    const result7 = await query6.first();
    ok(result7.id, 'expected object id to be set');
    ok(!result7.dirty(), 'expected result not to be dirty');
    strictEqual(result7.get('foo'), 'baz');
    strictEqual(result7.get('bar'), 1);
    strictEqual(result7.get('qux'), 2);

    obj._clearServerData();
    const query7 = new Parse.Query(TestObject);
    query7.select('foo', 'bar');
    const result8 = await query7.first();
    ok(result8.id, 'expected object id to be set');
    ok(!result8.dirty(), 'expected result not to be dirty');
    strictEqual(result8.get('foo'), 'baz');
    strictEqual(result8.get('bar'), 1);
    strictEqual(result8.get('qux'), undefined, ""expected 'qux' field to be unset"");

    obj._clearServerData();
    const query8 = new Parse.Query(TestObject);
    query8.select('foo', 'bar', 'qux');
    const result9 = await query8.first();
    ok(result9.id, 'expected object id to be set');
    ok(!result9.dirty(), 'expected result not to be dirty');
    strictEqual(result9.get('foo'), 'baz');
    strictEqual(result9.get('bar'), 1);
    strictEqual(result9.get('qux'), 2);
  });

  it('select keys (arrays)', async () => {
    const obj = new TestObject({ foo: 'baz', bar: 1, hello: 'world' });
    await obj.save();

    const response = await request({
      url: Parse.serverURL + '/classes/TestObject',
      qs: {
        keys: 'hello',
        where: JSON.stringify({ objectId: obj.id }),
      },
      headers: masterKeyHeaders,
    });
    expect(response.data.results[0].foo).toBeUndefined();
    expect(response.data.results[0].bar).toBeUndefined();
    expect(response.data.results[0].hello).toBe('world');

    const response2 = await request({
      url: Parse.serverURL + '/classes/TestObject',
      qs: {
        keys: ['foo', 'hello'],
        where: JSON.stringify({ objectId: obj.id }),
      },
      headers: masterKeyHeaders,
    });
    expect(response2.data.results[0].foo).toBe('baz');
    expect(response2.data.results[0].bar).toBeUndefined();
    expect(response2.data.results[0].hello).toBe('world');

    const response3 = await request({
      url: Parse.serverURL + '/classes/TestObject',
      qs: {
        keys: ['foo', 'bar', 'hello'],
        where: JSON.stringify({ objectId: obj.id }),
      },
      headers: masterKeyHeaders,
    });
    expect(response3.data.results[0].foo).toBe('baz');
    expect(response3.data.results[0].bar).toBe(1);
    expect(response3.data.results[0].hello).toBe('world');

    const response4 = await request({
      url: Parse.serverURL + '/classes/TestObject',
      qs: {
        keys: [''],
        where: JSON.stringify({ objectId: obj.id }),
      },
      headers: masterKeyHeaders,
    });
    ok(response4.data.results[0].objectId, 'expected objectId to be set');
    ok(response4.data.results[0].createdAt, 'expected object createdAt to be set');
    ok(response4.data.results[0].updatedAt, 'expected object updatedAt to be set');
    expect(response4.data.results[0].foo).toBeUndefined();
    expect(response4.data.results[0].bar).toBeUndefined();
    expect(response4.data.results[0].hello).toBeUndefined();

    const response5 = await request({
      url: Parse.serverURL + '/classes/TestObject',
      qs: {
        keys: [],
        where: JSON.stringify({ objectId: obj.id }),
      },
      headers: masterKeyHeaders,
    });
    ok(response5.data.results[0].objectId, 'expected objectId to be set');
    ok(response5.data.results[0].createdAt, 'expected object createdAt to be set');
    ok(response5.data.results[0].updatedAt, 'expected object updatedAt to be set');
    expect(response5.data.results[0].foo).toBe('baz');
    expect(response5.data.results[0].bar).toBe(1);
    expect(response5.data.results[0].hello).toBe('world');
  });

  it('select keys (strings)', async () => {
    const obj = new TestObject({ foo: 'baz', bar: 1, hello: 'world' });
    await obj.save();

    const response = await request({
      url: Parse.serverURL + '/classes/TestObject',
      qs: {
        keys: '',
        where: JSON.stringify({ objectId: obj.id }),
      },
      headers: masterKeyHeaders,
    });
    ok(response.data.results[0].objectId, 'expected objectId to be set');
    ok(response.data.results[0].createdAt, 'expected object createdAt to be set');
    ok(response.data.results[0].updatedAt, 'expected object updatedAt to be set');
    expect(response.data.results[0].foo).toBeUndefined();
    expect(response.data.results[0].bar).toBeUndefined();
    expect(response.data.results[0].hello).toBeUndefined();

    const response2 = await request({
      url: Parse.serverURL + '/classes/TestObject',
      qs: {
        keys: '[""foo"", ""hello""]',
        where: JSON.stringify({ objectId: obj.id }),
      },
      headers: masterKeyHeaders,
    });
    ok(response2.data.results[0].objectId, 'expected objectId to be set');
    ok(response2.data.results[0].createdAt, 'expected object createdAt to be set');
    ok(response2.data.results[0].updatedAt, 'expected object updatedAt to be set');
    expect(response2.data.results[0].foo).toBe('baz');
    expect(response2.data.results[0].bar).toBeUndefined();
    expect(response2.data.results[0].hello).toBe('world');

    const response3 = await request({
      url: Parse.serverURL + '/classes/TestObject',
      qs: {
        keys: '[""foo"", ""bar"", ""hello""]',
        where: JSON.stringify({ objectId: obj.id }),
      },
      headers: masterKeyHeaders,
    });
    ok(response3.data.results[0].objectId, 'expected objectId to be set');
    ok(response3.data.results[0].createdAt, 'expected object createdAt to be set');
    ok(response3.data.results[0].updatedAt, 'expected object updatedAt to be set');
    expect(response3.data.results[0].foo).toBe('baz');
    expect(response3.data.results[0].bar).toBe(1);
    expect(response3.data.results[0].hello).toBe('world');
  });

  it('exclude keys query JS SDK', async () => {
    const obj = new TestObject({ foo: 'baz', bar: 1, qux: 2 });

    await obj.save();
    obj._clearServerData();
    const query1 = new Parse.Query(TestObject);
    query1.exclude('foo');
    const result1 = await query1.first();
    ok(result1.id, 'expected object id to be set');
    ok(result1.createdAt, 'expected object createdAt to be set');
    ok(result1.updatedAt, 'expected object updatedAt to be set');
    ok(!result1.dirty(), 'expected result not to be dirty');
    strictEqual(result1.get('foo'), undefined, ""expected 'bar' field to be unset"");
    strictEqual(result1.get('bar'), 1);
    strictEqual(result1.get('qux'), 2);

    const result2 = await result1.fetch();
    strictEqual(result2.get('foo'), 'baz');
    strictEqual(result2.get('bar'), 1);
    strictEqual(result2.get('qux'), 2);

    obj._clearServerData();
    const query2 = new Parse.Query(TestObject);
    query2.exclude();
    const result3 = await query2.first();
    ok(result3.id, 'expected object id to be set');
    ok(result3.createdAt, 'expected object createdAt to be set');
    ok(result3.updatedAt, 'expected object updatedAt to be set');
    ok(!result3.dirty(), 'expected result not to be dirty');
    strictEqual(result3.get('foo'), 'baz');
    strictEqual(result3.get('bar'), 1);
    strictEqual(result3.get('qux'), 2);

    obj._clearServerData();
    const query3 = new Parse.Query(TestObject);
    query3.exclude([]);
    const result4 = await query3.first();
    ok(result4.id, 'expected object id to be set');
    ok(result4.createdAt, 'expected object createdAt to be set');
    ok(result4.updatedAt, 'expected object updatedAt to be set');
    ok(!result4.dirty(), 'expected result not to be dirty');
    strictEqual(result4.get('foo'), 'baz');
    strictEqual(result4.get('bar'), 1);
    strictEqual(result4.get('qux'), 2);

    obj._clearServerData();
    const query4 = new Parse.Query(TestObject);
    query4.exclude(['foo']);
    const result5 = await query4.first();
    ok(result5.id, 'expected object id to be set');
    ok(result5.createdAt, 'expected object createdAt to be set');
    ok(result5.updatedAt, 'expected object updatedAt to be set');
    ok(!result5.dirty(), 'expected result not to be dirty');
    strictEqual(result5.get('foo'), undefined, ""expected 'bar' field to be unset"");
    strictEqual(result5.get('bar'), 1);
    strictEqual(result5.get('qux'), 2);

    obj._clearServerData();
    const query5 = new Parse.Query(TestObject);
    query5.exclude(['foo', 'bar']);
    const result6 = await query5.first();
    ok(result6.id, 'expected object id to be set');
    ok(!result6.dirty(), 'expected result not to be dirty');
    strictEqual(result6.get('foo'), undefined, ""expected 'bar' field to be unset"");
    strictEqual(result6.get('bar'), undefined, ""expected 'bar' field to be unset"");
    strictEqual(result6.get('qux'), 2);

    obj._clearServerData();
    const query6 = new Parse.Query(TestObject);
    query6.exclude(['foo', 'bar', 'qux']);
    const result7 = await query6.first();
    ok(result7.id, 'expected object id to be set');
    ok(!result7.dirty(), 'expected result not to be dirty');
    strictEqual(result7.get('foo'), undefined, ""expected 'bar' field to be unset"");
    strictEqual(result7.get('bar'), undefined, ""expected 'bar' field to be unset"");
    strictEqual(result7.get('qux'), undefined, ""expected 'bar' field to be unset"");

    obj._clearServerData();
    const query7 = new Parse.Query(TestObject);
    query7.exclude('foo');
    const result8 = await query7.first();
    ok(result8.id, 'expected object id to be set');
    ok(!result8.dirty(), 'expected result not to be dirty');
    strictEqual(result8.get('foo'), undefined, ""expected 'bar' field to be unset"");
    strictEqual(result8.get('bar'), 1);
    strictEqual(result8.get('qux'), 2);

    obj._clearServerData();
    const query8 = new Parse.Query(TestObject);
    query8.exclude('foo', 'bar');
    const result9 = await query8.first();
    ok(result9.id, 'expected object id to be set');
    ok(!result9.dirty(), 'expected result not to be dirty');
    strictEqual(result9.get('foo'), undefined, ""expected 'bar' field to be unset"");
    strictEqual(result9.get('bar'), undefined, ""expected 'bar' field to be unset"");
    strictEqual(result9.get('qux'), 2);

    obj._clearServerData();
    const query9 = new Parse.Query(TestObject);
    query9.exclude('foo', 'bar', 'qux');
    const result10 = await query9.first();
    ok(result10.id, 'expected object id to be set');
    ok(!result10.dirty(), 'expected result not to be dirty');
    strictEqual(result10.get('foo'), undefined, ""expected 'bar' field to be unset"");
    strictEqual(result10.get('bar'), undefined, ""expected 'bar' field to be unset"");
    strictEqual(result10.get('qux'), undefined, ""expected 'bar' field to be unset"");
  });

  it('exclude keys (arrays)', async () => {
    const obj = new TestObject({ foo: 'baz', hello: 'world' });
    await obj.save();

    const response = await request({
      url: Parse.serverURL + '/classes/TestObject',
      qs: {
        excludeKeys: ['foo'],
        where: JSON.stringify({ objectId: obj.id }),
      },
      headers: masterKeyHeaders,
    });
    ok(response.data.results[0].objectId, 'expected objectId to be set');
    ok(response.data.results[0].createdAt, 'expected object createdAt to be set');
    ok(response.data.results[0].updatedAt, 'expected object updatedAt to be set');
    expect(response.data.results[0].foo).toBeUndefined();
    expect(response.data.results[0].hello).toBe('world');

    const response2 = await request({
      url: Parse.serverURL + '/classes/TestObject',
      qs: {
        excludeKeys: ['foo', 'hello'],
        where: JSON.stringify({ objectId: obj.id }),
      },
      headers: masterKeyHeaders,
    });
    ok(response2.data.results[0].objectId, 'expected objectId to be set');
    ok(response2.data.results[0].createdAt, 'expected object createdAt to be set');
    ok(response2.data.results[0].updatedAt, 'expected object updatedAt to be set');
    expect(response2.data.results[0].foo).toBeUndefined();
    expect(response2.data.results[0].hello).toBeUndefined();

    const response3 = await request({
      url: Parse.serverURL + '/classes/TestObject',
      qs: {
        excludeKeys: [],
        where: JSON.stringify({ objectId: obj.id }),
      },
      headers: masterKeyHeaders,
    });
    ok(response3.data.results[0].objectId, 'expected objectId to be set');
    ok(response3.data.results[0].createdAt, 'expected object createdAt to be set');
    ok(response3.data.results[0].updatedAt, 'expected object updatedAt to be set');
    expect(response3.data.results[0].foo).toBe('baz');
    expect(response3.data.results[0].hello).toBe('world');

    const response4 = await request({
      url: Parse.serverURL + '/classes/TestObject',
      qs: {
        excludeKeys: [''],
        where: JSON.stringify({ objectId: obj.id }),
      },
      headers: masterKeyHeaders,
    });
    ok(response4.data.results[0].objectId, 'expected objectId to be set');
    ok(response4.data.results[0].createdAt, 'expected object createdAt to be set');
    ok(response4.data.results[0].updatedAt, 'expected object updatedAt to be set');
    expect(response4.data.results[0].foo).toBe('baz');
    expect(response4.data.results[0].hello).toBe('world');
  });

  it('exclude keys (strings)', async () => {
    const obj = new TestObject({ foo: 'baz', hello: 'world' });
    await obj.save();

    const response = await request({
      url: Parse.serverURL + '/classes/TestObject',
      qs: {
        excludeKeys: 'foo',
        where: JSON.stringify({ objectId: obj.id }),
      },
      headers: masterKeyHeaders,
    });
    ok(response.data.results[0].objectId, 'expected objectId to be set');
    ok(response.data.results[0].createdAt, 'expected object createdAt to be set');
    ok(response.data.results[0].updatedAt, 'expected object updatedAt to be set');
    expect(response.data.results[0].foo).toBeUndefined();
    expect(response.data.results[0].hello).toBe('world');

    const response2 = await request({
      url: Parse.serverURL + '/classes/TestObject',
      qs: {
        excludeKeys: '',
        where: JSON.stringify({ objectId: obj.id }),
      },
      headers: masterKeyHeaders,
    });
    ok(response2.data.results[0].objectId, 'expected objectId to be set');
    ok(response2.data.results[0].createdAt, 'expected object createdAt to be set');
    ok(response2.data.results[0].updatedAt, 'expected object updatedAt to be set');
    expect(response2.data.results[0].foo).toBe('baz');
    expect(response2.data.results[0].hello).toBe('world');

    const response3 = await request({
      url: Parse.serverURL + '/classes/TestObject',
      qs: {
        excludeKeys: '[""hello""]',
        where: JSON.stringify({ objectId: obj.id }),
      },
      headers: masterKeyHeaders,
    });
    ok(response3.data.results[0].objectId, 'expected objectId to be set');
    ok(response3.data.results[0].createdAt, 'expected object createdAt to be set');
    ok(response3.data.results[0].updatedAt, 'expected object updatedAt to be set');
    expect(response3.data.results[0].foo).toBe('baz');
    expect(response3.data.results[0].hello).toBeUndefined();

    const response4 = await request({
      url: Parse.serverURL + '/classes/TestObject',
      qs: {
        excludeKeys: '[""foo"", ""hello""]',
        where: JSON.stringify({ objectId: obj.id }),
      },
      headers: masterKeyHeaders,
    });
    ok(response4.data.results[0].objectId, 'expected objectId to be set');
    ok(response4.data.results[0].createdAt, 'expected object createdAt to be set');
    ok(response4.data.results[0].updatedAt, 'expected object updatedAt to be set');
    expect(response4.data.results[0].foo).toBeUndefined();
    expect(response4.data.results[0].hello).toBeUndefined();
  });

  it('exclude keys with select same key', async () => {
    const obj = new TestObject({ foo: 'baz', hello: 'world' });
    await obj.save();

    const response = await request({
      url: Parse.serverURL + '/classes/TestObject',
      qs: {
        keys: 'foo',
        excludeKeys: 'foo',
        where: JSON.stringify({ objectId: obj.id }),
      },
      headers: masterKeyHeaders,
    });
    expect(response.data.results[0].foo).toBeUndefined();
    expect(response.data.results[0].hello).toBeUndefined();
  });

  it('exclude keys with select different key', async () => {
    const obj = new TestObject({ foo: 'baz', hello: 'world' });
    await obj.save();

    const response = await request({
      url: Parse.serverURL + '/classes/TestObject',
      qs: {
        keys: 'foo,hello',
        excludeKeys: 'foo',
        where: JSON.stringify({ objectId: obj.id }),
      },
      headers: masterKeyHeaders,
    });
    expect(response.data.results[0].foo).toBeUndefined();
    expect(response.data.results[0].hello).toBe('world');
  });

  it('exclude keys with include same key', async () => {
    const pointer = new TestObject();
    await pointer.save();
    const obj = new TestObject({ child: pointer, hello: 'world' });
    await obj.save();

    const response = await request({
      url: Parse.serverURL + '/classes/TestObject',
      qs: {
        include: 'child',
        excludeKeys: 'child',
        where: JSON.stringify({ objectId: obj.id }),
      },
      headers: masterKeyHeaders,
    });
    expect(response.data.results[0].child).toBeUndefined();
    expect(response.data.results[0].hello).toBe('world');
  });

  it('exclude keys with include different key', async () => {
    const pointer = new TestObject();
    await pointer.save();
    const obj = new TestObject({
      child1: pointer,
      child2: pointer,
      hello: 'world',
    });
    await obj.save();

    const response = await request({
      url: Parse.serverURL + '/classes/TestObject',
      qs: {
        include: 'child1,child2',
        excludeKeys: 'child1',
        where: JSON.stringify({ objectId: obj.id }),
      },
      headers: masterKeyHeaders,
    });
    expect(response.data.results[0].child1).toBeUndefined();
    expect(response.data.results[0].child2.objectId).toEqual(pointer.id);
    expect(response.data.results[0].hello).toBe('world');
  });

  it('exclude keys with includeAll', async () => {
    const pointer = new TestObject();
    await pointer.save();
    const obj = new TestObject({
      child1: pointer,
      child2: pointer,
      hello: 'world',
    });
    await obj.save();

    const response = await request({
      url: Parse.serverURL + '/classes/TestObject',
      qs: {
        includeAll: true,
        excludeKeys: 'child1',
        where: JSON.stringify({ objectId: obj.id }),
      },
      headers: masterKeyHeaders,
    });
    expect(response.data.results[0].child).toBeUndefined();
    expect(response.data.results[0].child2.objectId).toEqual(pointer.id);
    expect(response.data.results[0].hello).toBe('world');
  });

  it('select keys with each query', function (done) {
    const obj = new TestObject({ foo: 'baz', bar: 1 });

    obj.save().then(function () {
      obj._clearServerData();
      const query = new Parse.Query(TestObject);
      query.select('foo');
      query
        .each(function (result) {
          ok(result.id, 'expected object id to be set');
          ok(result.createdAt, 'expected object createdAt to be set');
          ok(result.updatedAt, 'expected object updatedAt to be set');
          ok(!result.dirty(), 'expected result not to be dirty');
          strictEqual(result.get('foo'), 'baz');
          strictEqual(result.get('bar'), undefined, 'expected ""bar"" field to be unset');
        })
        .then(
          function () {
            done();
          },
          function (err) {
            jfail(err);
            done();
          }
        );
    });
  });

  it_id('56b09b92-c756-4bae-8c32-1c32b5b4c397')(it)('notEqual with array of pointers', done => {
    const children = [];
    const parents = [];
    const promises = [];
    for (let i = 0; i < 2; i++) {
      const proc = iter => {
        const child = new Parse.Object('Child');
        children.push(child);
        const parent = new Parse.Object('Parent');
        parents.push(parent);
        promises.push(
          child.save().then(() => {
            parents[iter].set('child', [children[iter]]);
            return parents[iter].save();
          })
        );
      };
      proc(i);
    }
    Promise.all(promises)
      .then(() => {
        const query = new Parse.Query('Parent');
        query.notEqualTo('child', children[0]);
        return query.find();
      })
      .then(results => {
        expect(results.length).toEqual(1);
        expect(results[0].id).toEqual(parents[1].id);
        done();
      })
      .catch(error => {
        console.log(error);
      });
  });

  // PG don't support creating a null column
  it_exclude_dbs(['postgres'])('querying for null value', done => {
    const obj = new Parse.Object('TestObject');
    obj.set('aNull', null);
    obj
      .save()
      .then(() => {
        const query = new Parse.Query('TestObject');
        query.equalTo('aNull', null);
        return query.find();
      })
      .then(results => {
        expect(results.length).toEqual(1);
        expect(results[0].get('aNull')).toEqual(null);
        done();
      });
  });

  it('query within dictionary', done => {
    const promises = [];
    for (let i = 0; i < 2; i++) {
      const proc = iter => {
        const obj = new Parse.Object('TestObject');
        obj.set('aDict', { x: iter + 1, y: iter + 2 });
        promises.push(obj.save());
      };
      proc(i);
    }
    Promise.all(promises)
      .then(() => {
        const query = new Parse.Query('TestObject');
        query.equalTo('aDict.x', 1);
        return query.find();
      })
      .then(
        results => {
          expect(results.length).toEqual(1);
          done();
        },
        error => {
          console.log(error);
        }
      );
  });

  it('supports include on the wrong key type (#2262)', function (done) {
    const childObject = new Parse.Object('TestChildObject');
    childObject.set('hello', 'world');
    childObject
      .save()
      .then(() => {
        const obj = new Parse.Object('TestObject');
        obj.set('foo', 'bar');
        obj.set('child', childObject);
        return obj.save();
      })
      .then(() => {
        const q = new Parse.Query('TestObject');
        q.include('child');
        q.include('child.parent');
        q.include('createdAt');
        q.include('createdAt.createdAt');
        return q.find();
      })
      .then(
        objs => {
          expect(objs.length).toBe(1);
          expect(objs[0].get('child').get('hello')).toEqual('world');
          expect(objs[0].createdAt instanceof Date).toBe(true);
          done();
        },
        () => {
          fail('should not fail');
          done();
        }
      );
  });

  it('query match on array with single object', done => {
    const target = {
      __type: 'Pointer',
      className: 'TestObject',
      objectId: 'abc123',
    };
    const obj = new Parse.Object('TestObject');
    obj.set('someObjs', [target]);
    obj
      .save()
      .then(() => {
        const query = new Parse.Query('TestObject');
        query.equalTo('someObjs', target);
        return query.find();
      })
      .then(
        results => {
          expect(results.length).toEqual(1);
          done();
        },
        error => {
          console.log(error);
        }
      );
  });

  it('query match on array with multiple objects', done => {
    const target1 = {
      __type: 'Pointer',
      className: 'TestObject',
      objectId: 'abc',
    };
    const target2 = {
      __type: 'Pointer',
      className: 'TestObject',
      objectId: '123',
    };
    const obj = new Parse.Object('TestObject');
    obj.set('someObjs', [target1, target2]);
    obj
      .save()
      .then(() => {
        const query = new Parse.Query('TestObject');
        query.equalTo('someObjs', target1);
        return query.find();
      })
      .then(
        results => {
          expect(results.length).toEqual(1);
          done();
        },
        error => {
          console.log(error);
        }
      );
  });

  it('query should not match on array when searching for null', done => {
    const target = {
      __type: 'Pointer',
      className: 'TestObject',
      objectId: '123',
    };
    const obj = new Parse.Object('TestObject');
    obj.set('someKey', 'someValue');
    obj.set('someObjs', [target]);
    obj
      .save()
      .then(() => {
        const query = new Parse.Query('TestObject');
        query.equalTo('someKey', 'someValue');
        query.equalTo('someObjs', null);
        return query.find();
      })
      .then(
        results => {
          expect(results.length).toEqual(0);
          done();
        },
        error => {
          console.log(error);
        }
      );
  });

  // #371
  it('should properly interpret a query v1', done => {
    const query = new Parse.Query('C1');
    const auxQuery = new Parse.Query('C1');
    query.matchesKeyInQuery('A1', 'A2', auxQuery);
    query.include('A3');
    query.include('A2');
    query.find().then(
      () => {
        done();
      },
      err => {
        jfail(err);
        fail('should not failt');
        done();
      }
    );
  });

  it_id('7079f0ef-47b3-4a1e-aac0-32654dadaa27')(it)('should properly interpret a query v2', done => {
    const user = new Parse.User();
    user.set('username', 'foo');
    user.set('password', 'bar');
    return user
      .save()
      .then(user => {
        const objIdQuery = new Parse.Query('_User').equalTo('objectId', user.id);
        const blockedUserQuery = user.relation('blockedUsers').query();

        const aResponseQuery = new Parse.Query('MatchRelationshipActivityResponse');
        aResponseQuery.equalTo('userA', user);
        aResponseQuery.equalTo('userAResponse', 1);

        const bResponseQuery = new Parse.Query('MatchRelationshipActivityResponse');
        bResponseQuery.equalTo('userB', user);
        bResponseQuery.equalTo('userBResponse', 1);

        const matchOr = Parse.Query.or(aResponseQuery, bResponseQuery);
        const matchRelationshipA = new Parse.Query('_User');
        matchRelationshipA.matchesKeyInQuery('objectId', 'userAObjectId', matchOr);
        const matchRelationshipB = new Parse.Query('_User');
        matchRelationshipB.matchesKeyInQuery('objectId', 'userBObjectId', matchOr);

        const orQuery = Parse.Query.or(
          objIdQuery,
          blockedUserQuery,
          matchRelationshipA,
          matchRelationshipB
        );
        const query = new Parse.Query('_User');
        query.doesNotMatchQuery('objectId', orQuery);
        return query.find();
      })
      .then(
        () => {
          done();
        },
        err => {
          jfail(err);
          fail('should not fail');
          done();
        }
      );
  });

  it('should match a key in an array (#3195)', function (done) {
    const AuthorObject = Parse.Object.extend('Author');
    const GroupObject = Parse.Object.extend('Group');
    const PostObject = Parse.Object.extend('Post');

    return new AuthorObject()
      .save()
      .then(user => {
        const post = new PostObject({
          author: user,
        });

        const group = new GroupObject({
          members: [user],
        });

        return Promise.all([post.save(), group.save()]);
      })
      .then(results => {
        const p = results[0];
        return new Parse.Query(PostObject)
          .matchesKeyInQuery('author', 'members', new Parse.Query(GroupObject))
          .find()
          .then(r => {
            expect(r.length).toEqual(1);
            if (r.length > 0) {
              expect(r[0].id).toEqual(p.id);
            }
            done();
          }, done.fail);
      });
  });

  it_id('d95818c0-9e3c-41e6-be20-e7bafb59eefb')(it)('should find objects with array of pointers', done => {
    const objects = [];
    while (objects.length != 5) {
      const object = new Parse.Object('ContainedObject');
      object.set('index', objects.length);
      objects.push(object);
    }

    Parse.Object.saveAll(objects)
      .then(objects => {
        const container = new Parse.Object('Container');
        const pointers = objects.map(obj => {
          return {
            __type: 'Pointer',
            className: 'ContainedObject',
            objectId: obj.id,
          };
        });
        container.set('objects', pointers);
        const container2 = new Parse.Object('Container');
        container2.set('objects', pointers.slice(2, 3));
        return Parse.Object.saveAll([container, container2]);
      })
      .then(() => {
        const inQuery = new Parse.Query('ContainedObject');
        inQuery.greaterThanOrEqualTo('index', 1);
        const query = new Parse.Query('Container');
        query.matchesQuery('objects', inQuery);
        return query.find();
      })
      .then(results => {
        if (results) {
          expect(results.length).toBe(2);
        }
        done();
      })
      .catch(err => {
        jfail(err);
        fail('should not fail');
        done();
      });
  });

  it('query with two OR subqueries (regression test #1259)', done => {
    const relatedObject = new Parse.Object('Class2');
    relatedObject
      .save()
      .then(relatedObject => {
        const anObject = new Parse.Object('Class1');
        const relation = anObject.relation('relation');
        relation.add(relatedObject);
        return anObject.save();
      })
      .then(anObject => {
        const q1 = anObject.relation('relation').query();
        q1.doesNotExist('nonExistantKey1');
        const q2 = anObject.relation('relation').query();
        q2.doesNotExist('nonExistantKey2');
        Parse.Query.or(q1, q2)
          .find()
          .then(results => {
            expect(results.length).toEqual(1);
            if (results.length == 1) {
              expect(results[0].objectId).toEqual(q1.objectId);
            }
            done();
          });
      });
  });

  it('objectId containedIn with multiple large array', done => {
    const obj = new Parse.Object('MyClass');
    obj
      .save()
      .then(obj => {
        const longListOfStrings = [];
        for (let i = 0; i < 130; i++) {
          longListOfStrings.push(i.toString());
        }
        longListOfStrings.push(obj.id);
        const q = new Parse.Query('MyClass');
        q.containedIn('objectId', longListOfStrings);
        q.containedIn('objectId', longListOfStrings);
        return q.find();
      })
      .then(results => {
        expect(results.length).toEqual(1);
        done();
      });
  });

  it('containedIn with pointers should work with string array', done => {
    const obj = new Parse.Object('MyClass');
    const child = new Parse.Object('Child');
    child
      .save()
      .then(() => {
        obj.set('child', child);
        return obj.save();
      })
      .then(() => {
        const objs = [];
        for (let i = 0; i < 10; i++) {
          objs.push(new Parse.Object('MyClass'));
        }
        return Parse.Object.saveAll(objs);
      })
      .then(() => {
        const query = new Parse.Query('MyClass');
        query.containedIn('child', [child.id]);
        return query.find();
      })
      .then(results => {
        expect(results.length).toBe(1);
      })
      .then(done)
      .catch(done.fail);
  });

  it('containedIn with pointers should work with string array, with many objects', done => {
    const objs = [];
    const children = [];
    for (let i = 0; i < 10; i++) {
      const obj = new Parse.Object('MyClass');
      const child = new Parse.Object('Child');
      objs.push(obj);
      children.push(child);
    }
    Parse.Object.saveAll(children)
      .then(() => {
        return Parse.Object.saveAll(
          objs.map((obj, i) => {
            obj.set('child', children[i]);
            return obj;
          })
        );
      })
      .then(() => {
        const query = new Parse.Query('MyClass');
        const subset = children.slice(0, 5).map(child => {
          return child.id;
        });
        query.containedIn('child', subset);
        return query.find();
      })
      .then(results => {
        expect(results.length).toBe(5);
      })
      .then(done)
      .catch(done.fail);
  });

  it('include for specific object', function (done) {
    const child = new Parse.Object('Child');
    const parent = new Parse.Object('Parent');
    child.set('foo', 'bar');
    parent.set('child', child);
    Parse.Object.saveAll([child, parent]).then(function (response) {
      const savedParent = response[1];
      const parentQuery = new Parse.Query('Parent');
      parentQuery.include('child');
      parentQuery.get(savedParent.id).then(function (parentObj) {
        const childPointer = parentObj.get('child');
        ok(childPointer);
        equal(childPointer.get('foo'), 'bar');
        done();
      });
    });
  });

  it('select keys for specific object', function (done) {
    const Foobar = new Parse.Object('Foobar');
    Foobar.set('foo', 'bar');
    Foobar.set('fizz', 'buzz');
    Foobar.save().then(function (savedFoobar) {
      const foobarQuery = new Parse.Query('Foobar');
      foobarQuery.select('fizz');
      foobarQuery.get(savedFoobar.id).then(function (foobarObj) {
        equal(foobarObj.get('fizz'), 'buzz');
        equal(foobarObj.get('foo'), undefined);
        done();
      });
    });
  });

  it('select nested keys (issue #1567)', function (done) {
    const Foobar = new Parse.Object('Foobar');
    const BarBaz = new Parse.Object('Barbaz');
    BarBaz.set('key', 'value');
    BarBaz.set('otherKey', 'value');
    BarBaz.save()
      .then(() => {
        Foobar.set('foo', 'bar');
        Foobar.set('fizz', 'buzz');
        Foobar.set('barBaz', BarBaz);
        return Foobar.save();
      })
      .then(function (savedFoobar) {
        const foobarQuery = new Parse.Query('Foobar');
        foobarQuery.select(['fizz', 'barBaz.key']);
        foobarQuery.get(savedFoobar.id).then(function (foobarObj) {
          equal(foobarObj.get('fizz'), 'buzz');
          equal(foobarObj.get('foo'), undefined);
          if (foobarObj.has('barBaz')) {
            equal(foobarObj.get('barBaz').get('key'), 'value');
            equal(foobarObj.get('barBaz').get('otherKey'), undefined);
          } else {
            fail('barBaz should be set');
          }
          done();
        });
      });
  });

  it('select nested keys 2 level (issue #1567)', function (done) {
    const Foobar = new Parse.Object('Foobar');
    const BarBaz = new Parse.Object('Barbaz');
    const Bazoo = new Parse.Object('Bazoo');

    Bazoo.set('some', 'thing');
    Bazoo.set('otherSome', 'value');
    Bazoo.save()
      .then(() => {
        BarBaz.set('key', 'value');
        BarBaz.set('otherKey', 'value');
        BarBaz.set('bazoo', Bazoo);
        return BarBaz.save();
      })
      .then(() => {
        Foobar.set('foo', 'bar');
        Foobar.set('fizz', 'buzz');
        Foobar.set('barBaz', BarBaz);
        return Foobar.save();
      })
      .then(function (savedFoobar) {
        const foobarQuery = new Parse.Query('Foobar');
        foobarQuery.select(['fizz', 'barBaz.key', 'barBaz.bazoo.some']);
        foobarQuery.get(savedFoobar.id).then(function (foobarObj) {
          equal(foobarObj.get('fizz'), 'buzz');
          equal(foobarObj.get('foo'), undefined);
          if (foobarObj.has('barBaz')) {
            equal(foobarObj.get('barBaz').get('key'), 'value');
            equal(foobarObj.get('barBaz').get('otherKey'), undefined);
            equal(foobarObj.get('barBaz').get('bazoo').get('some'), 'thing');
            equal(foobarObj.get('barBaz').get('bazoo').get('otherSome'), undefined);
          } else {
            fail('barBaz should be set');
          }
          done();
        });
      });
  });

  it('exclude nested keys', async () => {
    const Foobar = new Parse.Object('Foobar');
    const BarBaz = new Parse.Object('Barbaz');
    BarBaz.set('key', 'value');
    BarBaz.set('otherKey', 'value');
    await BarBaz.save();

    Foobar.set('foo', 'bar');
    Foobar.set('fizz', 'buzz');
    Foobar.set('barBaz', BarBaz);
    const savedFoobar = await Foobar.save();

    const foobarQuery = new Parse.Query('Foobar');
    foobarQuery.exclude(['foo', 'barBaz.otherKey']);
    const foobarObj = await foobarQuery.get(savedFoobar.id);
    equal(foobarObj.get('fizz'), 'buzz');
    equal(foobarObj.get('foo'), undefined);
    if (foobarObj.has('barBaz')) {
      equal(foobarObj.get('barBaz').get('key'), 'value');
      equal(foobarObj.get('barBaz').get('otherKey'), undefined);
    } else {
      fail('barBaz should be set');
    }
  });

  it('exclude nested keys 2 level', async () => {
    const Foobar = new Parse.Object('Foobar');
    const BarBaz = new Parse.Object('Barbaz');
    const Bazoo = new Parse.Object('Bazoo');

    Bazoo.set('some', 'thing');
    Bazoo.set('otherSome', 'value');
    await Bazoo.save();

    BarBaz.set('key', 'value');
    BarBaz.set('otherKey', 'value');
    BarBaz.set('bazoo', Bazoo);
    await BarBaz.save();

    Foobar.set('foo', 'bar');
    Foobar.set('fizz', 'buzz');
    Foobar.set('barBaz', BarBaz);
    const savedFoobar = await Foobar.save();

    const foobarQuery = new Parse.Query('Foobar');
    foobarQuery.exclude(['foo', 'barBaz.otherKey', 'barBaz.bazoo.otherSome']);
    const foobarObj = await foobarQuery.get(savedFoobar.id);
    equal(foobarObj.get('fizz'), 'buzz');
    equal(foobarObj.get('foo'), undefined);
    if (foobarObj.has('barBaz')) {
      equal(foobarObj.get('barBaz').get('key'), 'value');
      equal(foobarObj.get('barBaz').get('otherKey'), undefined);
      equal(foobarObj.get('barBaz').get('bazoo').get('some'), 'thing');
      equal(foobarObj.get('barBaz').get('bazoo').get('otherSome'), undefined);
    } else {
      fail('barBaz should be set');
    }
  });

  it('include with *', async () => {
    const child1 = new TestObject({ foo: 'bar', name: 'ac' });
    const child2 = new TestObject({ foo: 'baz', name: 'flo' });
    const child3 = new TestObject({ foo: 'bad', name: 'mo' });
    const parent = new Container({ child1, child2, child3 });
    await Parse.Object.saveAll([parent, child1, child2, child3]);
    const options = Object.assign({}, masterKeyOptions, {
      qs: {
        where: JSON.stringify({ objectId: parent.id }),
        include: '*',
      },
    });
    const resp = await request(
      Object.assign({ url: Parse.serverURL + '/classes/Container' }, options)
    );
    const result = resp.data.results[0];
    equal(result.child1.foo, 'bar');
    equal(result.child2.foo, 'baz');
    equal(result.child3.foo, 'bad');
    equal(result.child1.name, 'ac');
    equal(result.child2.name, 'flo');
    equal(result.child3.name, 'mo');
  });

  it('include with [""*""]', async () => {
    const child1 = new TestObject({ foo: 'bar', name: 'ac' });
    const child2 = new TestObject({ foo: 'baz', name: 'flo' });
    const child3 = new TestObject({ foo: 'bad', name: 'mo' });
    const parent = new Container({ child1, child2, child3 });
    await Parse.Object.saveAll([parent, child1, child2, child3]);
    const options = Object.assign({}, masterKeyOptions, {
      qs: {
        where: JSON.stringify({ objectId: parent.id }),
        include: '[""*""]',
      },
    });
    const resp = await request(
      Object.assign({ url: Parse.serverURL + '/classes/Container' }, options)
    );
    const result = resp.data.results[0];
    equal(result.child1.foo, 'bar');
    equal(result.child2.foo, 'baz');
    equal(result.child3.foo, 'bad');
    equal(result.child1.name, 'ac');
    equal(result.child2.name, 'flo');
    equal(result.child3.name, 'mo');
  });

  it('include with * overrides', async () => {
    const child1 = new TestObject({ foo: 'bar', name: 'ac' });
    const child2 = new TestObject({ foo: 'baz', name: 'flo' });
    const child3 = new TestObject({ foo: 'bad', name: 'mo' });
    const parent = new Container({ child1, child2, child3 });
    await Parse.Object.saveAll([parent, child1, child2, child3]);
    const options = Object.assign({}, masterKeyOptions, {
      qs: {
        where: JSON.stringify({ objectId: parent.id }),
        include: 'child2,*',
      },
    });
    const resp = await request(
      Object.assign({ url: Parse.serverURL + '/classes/Container' }, options)
    );
    const result = resp.data.results[0];
    equal(result.child1.foo, 'bar');
    equal(result.child2.foo, 'baz');
    equal(result.child3.foo, 'bad');
    equal(result.child1.name, 'ac');
    equal(result.child2.name, 'flo');
    equal(result.child3.name, 'mo');
  });

  it('include with [""*""] overrides', async () => {
    const child1 = new TestObject({ foo: 'bar', name: 'ac' });
    const child2 = new TestObject({ foo: 'baz', name: 'flo' });
    const child3 = new TestObject({ foo: 'bad', name: 'mo' });
    const parent = new Container({ child1, child2, child3 });
    await Parse.Object.saveAll([parent, child1, child2, child3]);
    const options = Object.assign({}, masterKeyOptions, {
      qs: {
        where: JSON.stringify({ objectId: parent.id }),
        include: '[""child2"",""*""]',
      },
    });
    const resp = await request(
      Object.assign({ url: Parse.serverURL + '/classes/Container' }, options)
    );
    const result = resp.data.results[0];
    equal(result.child1.foo, 'bar');
    equal(result.child2.foo, 'baz');
    equal(result.child3.foo, 'bad');
    equal(result.child1.name, 'ac');
    equal(result.child2.name, 'flo');
    equal(result.child3.name, 'mo');
  });

  it('includeAll', done => {
    const child1 = new TestObject({ foo: 'bar', name: 'ac' });
    const child2 = new TestObject({ foo: 'baz', name: 'flo' });
    const child3 = new TestObject({ foo: 'bad', name: 'mo' });
    const parent = new Container({ child1, child2, child3 });
    Parse.Object.saveAll([parent, child1, child2, child3])
      .then(() => {
        const options = Object.assign({}, masterKeyOptions, {
          qs: {
            where: JSON.stringify({ objectId: parent.id }),
            includeAll: true,
          },
        });
        return request(Object.assign({ url: Parse.serverURL + '/classes/Container' }, options));
      })
      .then(resp => {
        const result = resp.data.results[0];
        equal(result.child1.foo, 'bar');
        equal(result.child2.foo, 'baz');
        equal(result.child3.foo, 'bad');
        equal(result.child1.name, 'ac');
        equal(result.child2.name, 'flo');
        equal(result.child3.name, 'mo');
        done();
      });
  });

  it('include pointer and pointer array', function (done) {
    const child = new TestObject();
    const child2 = new TestObject();
    child.set('foo', 'bar');
    child2.set('hello', 'world');
    Parse.Object.saveAll([child, child2]).then(function () {
      const parent = new Container();
      parent.set('child', child.toPointer());
      parent.set('child2', [child2.toPointer()]);
      parent.save().then(function () {
        const query = new Parse.Query(Container);
        query.include(['child', 'child2']);
        query.find().then(function (results) {
          equal(results.length, 1);
          const parentAgain = results[0];
          const childAgain = parentAgain.get('child');
          ok(childAgain);
          equal(childAgain.get('foo'), 'bar');
          const child2Again = parentAgain.get('child2');
          equal(child2Again.length, 1);
          ok(child2Again);
          equal(child2Again[0].get('hello'), 'world');
          done();
        });
      });
    });
  });

  it('include pointer and pointer array (keys switched)', function (done) {
    const child = new TestObject();
    const child2 = new TestObject();
    child.set('foo', 'bar');
    child2.set('hello', 'world');
    Parse.Object.saveAll([child, child2]).then(function () {
      const parent = new Container();
      parent.set('child', child.toPointer());
      parent.set('child2', [child2.toPointer()]);
      parent.save().then(function () {
        const query = new Parse.Query(Container);
        query.include(['child2', 'child']);
        query.find().then(function (results) {
          equal(results.length, 1);
          const parentAgain = results[0];
          const childAgain = parentAgain.get('child');
          ok(childAgain);
          equal(childAgain.get('foo'), 'bar');
          const child2Again = parentAgain.get('child2');
          equal(child2Again.length, 1);
          ok(child2Again);
          equal(child2Again[0].get('hello'), 'world');
          done();
        });
      });
    });
  });

  it('includeAll pointer and pointer array', function (done) {
    const child = new TestObject();
    const child2 = new TestObject();
    child.set('foo', 'bar');
    child2.set('hello', 'world');
    Parse.Object.saveAll([child, child2]).then(function () {
      const parent = new Container();
      parent.set('child', child.toPointer());
      parent.set('child2', [child2.toPointer()]);
      parent.save().then(function () {
        const query = new Parse.Query(Container);
        query.includeAll();
        query.find().then(function (results) {
          equal(results.length, 1);
          const parentAgain = results[0];
          const childAgain = parentAgain.get('child');
          ok(childAgain);
          equal(childAgain.get('foo'), 'bar');
          const child2Again = parentAgain.get('child2');
          equal(child2Again.length, 1);
          ok(child2Again);
          equal(child2Again[0].get('hello'), 'world');
          done();
        });
      });
    });
  });

  it('select nested keys 2 level includeAll', done => {
    const Foobar = new Parse.Object('Foobar');
    const BarBaz = new Parse.Object('Barbaz');
    const Bazoo = new Parse.Object('Bazoo');
    const Tang = new Parse.Object('Tang');

    Bazoo.set('some', 'thing');
    Bazoo.set('otherSome', 'value');
    Bazoo.save()
      .then(() => {
        BarBaz.set('key', 'value');
        BarBaz.set('otherKey', 'value');
        BarBaz.set('bazoo', Bazoo);
        return BarBaz.save();
      })
      .then(() => {
        Tang.set('clan', 'wu');
        return Tang.save();
      })
      .then(() => {
        Foobar.set('foo', 'bar');
        Foobar.set('fizz', 'buzz');
        Foobar.set('barBaz', BarBaz);
        Foobar.set('group', Tang);
        return Foobar.save();
      })
      .then(savedFoobar => {
        const options = Object.assign(
          {
            url: Parse.serverURL + '/classes/Foobar',
          },
          masterKeyOptions,
          {
            qs: {
              where: JSON.stringify({ objectId: savedFoobar.id }),
              includeAll: true,
              keys: 'fizz,barBaz.key,barBaz.bazoo.some',
            },
          }
        );
        return request(options);
      })
      .then(resp => {
        const result = resp.data.results[0];
        equal(result.group.clan, 'wu');
        equal(result.foo, undefined);
        equal(result.fizz, 'buzz');
        equal(result.barBaz.key, 'value');
        equal(result.barBaz.otherKey, undefined);
        equal(result.barBaz.bazoo.some, 'thing');
        equal(result.barBaz.bazoo.otherSome, undefined);
        done();
      })
      .catch(done.fail);
  });

  it('select nested keys 2 level without include (issue #3185)', function (done) {
    const Foobar = new Parse.Object('Foobar');
    const BarBaz = new Parse.Object('Barbaz');
    const Bazoo = new Parse.Object('Bazoo');

    Bazoo.set('some', 'thing');
    Bazoo.set('otherSome', 'value');
    Bazoo.save()
      .then(() => {
        BarBaz.set('key', 'value');
        BarBaz.set('otherKey', 'value');
        BarBaz.set('bazoo', Bazoo);
        return BarBaz.save();
      })
      .then(() => {
        Foobar.set('foo', 'bar');
        Foobar.set('fizz', 'buzz');
        Foobar.set('barBaz', BarBaz);
        return Foobar.save();
      })
      .then(function (savedFoobar) {
        const foobarQuery = new Parse.Query('Foobar');
        foobarQuery.select(['fizz', 'barBaz.key', 'barBaz.bazoo.some']);
        return foobarQuery.get(savedFoobar.id);
      })
      .then(foobarObj => {
        equal(foobarObj.get('fizz'), 'buzz');
        equal(foobarObj.get('foo'), undefined);
        if (foobarObj.has('barBaz')) {
          equal(foobarObj.get('barBaz').get('key'), 'value');
          equal(foobarObj.get('barBaz').get('otherKey'), undefined);
          if (foobarObj.get('barBaz').has('bazoo')) {
            equal(foobarObj.get('barBaz').get('bazoo').get('some'), 'thing');
            equal(foobarObj.get('barBaz').get('bazoo').get('otherSome'), undefined);
          } else {
            fail('bazoo should be set');
          }
        } else {
          fail('barBaz should be set');
        }
        done();
      });
  });

  it('properly handles nested ors', function (done) {
    const objects = [];
    while (objects.length != 4) {
      const obj = new Parse.Object('Object');
      obj.set('x', objects.length);
      objects.push(obj);
    }
    Parse.Object.saveAll(objects)
      .then(() => {
        const q0 = new Parse.Query('Object');
        q0.equalTo('x', 0);
        const q1 = new Parse.Query('Object');
        q1.equalTo('x', 1);
        const q2 = new Parse.Query('Object');
        q2.equalTo('x', 2);
        const or01 = Parse.Query.or(q0, q1);
        return Parse.Query.or(or01, q2).find();
      })
      .then(results => {
        expect(results.length).toBe(3);
        done();
      })
      .catch(error => {
        fail('should not fail');
        jfail(error);
        done();
      });
  });

  it('should not depend on parameter order #3169', function (done) {
    const score1 = new Parse.Object('Score', { scoreId: '1' });
    const score2 = new Parse.Object('Score', { scoreId: '2' });
    const game1 = new Parse.Object('Game', { gameId: '1' });
    const game2 = new Parse.Object('Game', { gameId: '2' });
    Parse.Object.saveAll([score1, score2, game1, game2])
      .then(() => {
        game1.set('score', [score1]);
        game2.set('score', [score2]);
        return Parse.Object.saveAll([game1, game2]);
      })
      .then(() => {
        const where = {
          score: {
            objectId: score1.id,
            className: 'Score',
            __type: 'Pointer',
          },
        };
        return request({
          method: 'POST',
          url: Parse.serverURL + '/classes/Game',
          body: { where, _method: 'GET' },
          headers: {
            'X-Parse-Application-Id': Parse.applicationId,
            'X-Parse-Javascript-Key': Parse.javaScriptKey,
            'Content-Type': 'application/json',
          },
        });
      })
      .then(
        response => {
          const results = response.data;
          expect(results.results.length).toBe(1);
          done();
        },
        res => done.fail(res.data)
      );
  });

  it('should not interfere with has when using select on field with undefined value #3999', done => {
    const obj1 = new Parse.Object('TestObject');
    const obj2 = new Parse.Object('OtherObject');
    obj2.set('otherField', 1);
    obj1.set('testPointerField', obj2);
    obj1.set('shouldBe', true);
    const obj3 = new Parse.Object('TestObject');
    obj3.set('shouldBe', false);
    Parse.Object.saveAll([obj1, obj3])
      .then(() => {
        const query = new Parse.Query('TestObject');
        query.include('testPointerField');
        query.select(['testPointerField', 'testPointerField.otherField', 'shouldBe']);
        return query.find();
      })
      .then(results => {
        results.forEach(result => {
          equal(result.has('testPointerField'), result.get('shouldBe'));
        });
        done();
      })
      .catch(done.fail);
  });

  it('should handle relative times correctly', async () => {
    const now = Date.now();
    const obj1 = new Parse.Object('MyCustomObject', {
      name: 'obj1',
      ttl: new Date(now + 2 * 24 * 60 * 60 * 1000), // 2 days from now
    });
    const obj2 = new Parse.Object('MyCustomObject', {
      name: 'obj2',
      ttl: new Date(now - 2 * 24 * 60 * 60 * 1000), // 2 days ago
    });

    await Parse.Object.saveAll([obj1, obj2]);
    const q1 = new Parse.Query('MyCustomObject');
    q1.greaterThan('ttl', { $relativeTime: 'in 1 day' });
    const results1 = await q1.find({ useMasterKey: true });
    expect(results1.length).toBe(1);

    const q2 = new Parse.Query('MyCustomObject');
    q2.greaterThan('ttl', { $relativeTime: '1 day ago' });
    const results2 = await q2.find({ useMasterKey: true });
    expect(results2.length).toBe(1);

    const q3 = new Parse.Query('MyCustomObject');
    q3.lessThan('ttl', { $relativeTime: '5 days ago' });
    const results3 = await q3.find({ useMasterKey: true });
    expect(results3.length).toBe(0);

    const q4 = new Parse.Query('MyCustomObject');
    q4.greaterThan('ttl', { $relativeTime: '3 days ago' });
    const results4 = await q4.find({ useMasterKey: true });
    expect(results4.length).toBe(2);

    const q5 = new Parse.Query('MyCustomObject');
    q5.greaterThan('ttl', { $relativeTime: 'now' });
    const results5 = await q5.find({ useMasterKey: true });
    expect(results5.length).toBe(1);

    const q6 = new Parse.Query('MyCustomObject');
    q6.greaterThan('ttl', { $relativeTime: 'now' });
    q6.lessThan('ttl', { $relativeTime: 'in 1 day' });
    const results6 = await q6.find({ useMasterKey: true });
    expect(results6.length).toBe(0);

    const q7 = new Parse.Query('MyCustomObject');
    q7.greaterThan('ttl', { $relativeTime: '1 year 3 weeks ago' });
    const results7 = await q7.find({ useMasterKey: true });
    expect(results7.length).toBe(2);
  });

  it('should error on invalid relative time', async () => {
    const obj1 = new Parse.Object('MyCustomObject', {
      name: 'obj1',
      ttl: new Date(Date.now() + 2 * 24 * 60 * 60 * 1000), // 2 days from now
    });
    await obj1.save({ useMasterKey: true });
    const q = new Parse.Query('MyCustomObject');
    q.greaterThan('ttl', { $relativeTime: '-12 bananas ago' });
    try {
      await q.find({ useMasterKey: true });
      fail('Should have thrown error');
    } catch (error) {
      expect(error.code).toBe(Parse.Error.INVALID_JSON);
    }
  });

  it('should error when using $relativeTime on non-Date field', async () => {
    const obj1 = new Parse.Object('MyCustomObject', {
      name: 'obj1',
      nonDateField: 'abcd',
      ttl: new Date(Date.now() + 2 * 24 * 60 * 60 * 1000), // 2 days from now
    });
    await obj1.save({ useMasterKey: true });
    const q = new Parse.Query('MyCustomObject');
    q.greaterThan('nonDateField', { $relativeTime: '1 day ago' });
    try {
      await q.find({ useMasterKey: true });
      fail('Should have thrown error');
    } catch (error) {
      expect(error.code).toBe(Parse.Error.INVALID_JSON);
    }
  });

  it('should match complex structure with dot notation when using matchesKeyInQuery', function (done) {
    const group1 = new Parse.Object('Group', {
      name: 'Group #1',
    });

    const group2 = new Parse.Object('Group', {
      name: 'Group #2',
    });

    Parse.Object.saveAll([group1, group2])
      .then(() => {
        const role1 = new Parse.Object('Role', {
          name: 'Role #1',
          type: 'x',
          belongsTo: group1,
        });

        const role2 = new Parse.Object('Role', {
          name: 'Role #2',
          type: 'y',
          belongsTo: group1,
        });

        return Parse.Object.saveAll([role1, role2]);
      })
      .then(() => {
        const rolesOfTypeX = new Parse.Query('Role');
        rolesOfTypeX.equalTo('type', 'x');

        const groupsWithRoleX = new Parse.Query('Group');
        groupsWithRoleX.matchesKeyInQuery('objectId', 'belongsTo.objectId', rolesOfTypeX);

        groupsWithRoleX.find().then(function (results) {
          equal(results.length, 1);
          equal(results[0].get('name'), group1.get('name'));
          done();
        });
      });
  });

  it('should match complex structure with dot notation when using doesNotMatchKeyInQuery', function (done) {
    const group1 = new Parse.Object('Group', {
      name: 'Group #1',
    });

    const group2 = new Parse.Object('Group', {
      name: 'Group #2',
    });

    Parse.Object.saveAll([group1, group2])
      .then(() => {
        const role1 = new Parse.Object('Role', {
          name: 'Role #1',
          type: 'x',
          belongsTo: group1,
        });

        const role2 = new Parse.Object('Role', {
          name: 'Role #2',
          type: 'y',
          belongsTo: group1,
        });

        return Parse.Object.saveAll([role1, role2]);
      })
      .then(() => {
        const rolesOfTypeX = new Parse.Query('Role');
        rolesOfTypeX.equalTo('type', 'x');

        const groupsWithRoleX = new Parse.Query('Group');
        groupsWithRoleX.doesNotMatchKeyInQuery('objectId', 'belongsTo.objectId', rolesOfTypeX);

        groupsWithRoleX.find().then(function (results) {
          equal(results.length, 1);
          equal(results[0].get('name'), group2.get('name'));
          done();
        });
      });
  });

  it('should not throw error with undefined dot notation when using matchesKeyInQuery', async () => {
    const group = new Parse.Object('Group', { name: 'Group #1' });
    await group.save();

    const role1 = new Parse.Object('Role', {
      name: 'Role #1',
      type: 'x',
      belongsTo: group,
    });

    const role2 = new Parse.Object('Role', {
      name: 'Role #2',
      type: 'y',
      belongsTo: undefined,
    });
    await Parse.Object.saveAll([role1, role2]);

    const rolesOfTypeX = new Parse.Query('Role');
    rolesOfTypeX.equalTo('type', 'x');

    const groupsWithRoleX = new Parse.Query('Group');
    groupsWithRoleX.matchesKeyInQuery('objectId', 'belongsTo.objectId', rolesOfTypeX);

    const results = await groupsWithRoleX.find();
    equal(results.length, 1);
    equal(results[0].get('name'), group.get('name'));
  });

  it('should not throw error with undefined dot notation when using doesNotMatchKeyInQuery', async () => {
    const group1 = new Parse.Object('Group', { name: 'Group #1' });
    const group2 = new Parse.Object('Group', { name: 'Group #2' });
    await Parse.Object.saveAll([group1, group2]);

    const role1 = new Parse.Object('Role', {
      name: 'Role #1',
      type: 'x',
      belongsTo: group1,
    });

    const role2 = new Parse.Object('Role', {
      name: 'Role #2',
      type: 'y',
      belongsTo: undefined,
    });
    await Parse.Object.saveAll([role1, role2]);

    const rolesOfTypeX = new Parse.Query('Role');
    rolesOfTypeX.equalTo('type', 'x');

    const groupsWithRoleX = new Parse.Query('Group');
    groupsWithRoleX.doesNotMatchKeyInQuery('objectId', 'belongsTo.objectId', rolesOfTypeX);

    const results = await groupsWithRoleX.find();
    equal(results.length, 1);
    equal(results[0].get('name'), group2.get('name'));
  });

  it_id('8886b994-fbb8-487d-a863-43bbd2b24b73')(it)('withJSON supports geoWithin.centerSphere', done => {
    const inbound = new Parse.GeoPoint(1.5, 1.5);
    const onbound = new Parse.GeoPoint(10, 10);
    const outbound = new Parse.GeoPoint(20, 20);
    const obj1 = new Parse.Object('TestObject', { location: inbound });
    const obj2 = new Parse.Object('TestObject', { location: onbound });
    const obj3 = new Parse.Object('TestObject', { location: outbound });
    const center = new Parse.GeoPoint(0, 0);
    const distanceInKilometers = 1569 + 1; // 1569km is the approximate distance between {0, 0} and {10, 10}.
    Parse.Object.saveAll([obj1, obj2, obj3])
      .then(() => {
        const q = new Parse.Query(TestObject);
        const jsonQ = q.toJSON();
        jsonQ.where.location = {
          $geoWithin: {
            $centerSphere: [center, distanceInKilometers / 6371.0],
          },
        };
        q.withJSON(jsonQ);
        return q.find();
      })
      .then(results => {
        equal(results.length, 2);
        const q = new Parse.Query(TestObject);
        const jsonQ = q.toJSON();
        jsonQ.where.location = {
          $geoWithin: {
            $centerSphere: [[0, 0], distanceInKilometers / 6371.0],
          },
        };
        q.withJSON(jsonQ);
        return q.find();
      })
      .then(results => {
        equal(results.length, 2);
        done();
      })
      .catch(error => {
        fail(error);
        done();
      });
  });

  it('withJSON with geoWithin.centerSphere fails without parameters', done => {
    const q = new Parse.Query(TestObject);
    const jsonQ = q.toJSON();
    jsonQ.where.location = {
      $geoWithin: {
        $centerSphere: [],
      },
    };
    q.withJSON(jsonQ);
    q.find()
      .then(done.fail)
      .catch(e => expect(e.code).toBe(Parse.Error.INVALID_JSON))
      .then(done);
  });

  it('withJSON with geoWithin.centerSphere fails with invalid distance', done => {
    const q = new Parse.Query(TestObject);
    const jsonQ = q.toJSON();
    jsonQ.where.location = {
      $geoWithin: {
        $centerSphere: [[0, 0], 'invalid_distance'],
      },
    };
    q.withJSON(jsonQ);
    q.find()
      .then(done.fail)
      .catch(e => expect(e.code).toBe(Parse.Error.INVALID_JSON))
      .then(done);
  });

  it('withJSON with geoWithin.centerSphere fails with invalid coordinate', done => {
    const q = new Parse.Query(TestObject);
    const jsonQ = q.toJSON();
    jsonQ.where.location = {
      $geoWithin: {
        $centerSphere: [[-190, -190], 1],
      },
    };
    q.withJSON(jsonQ);
    q.find()
      .then(done.fail)
      .catch(() => done());
  });

  it('withJSON with geoWithin.centerSphere fails with invalid geo point', done => {
    const q = new Parse.Query(TestObject);
    const jsonQ = q.toJSON();
    jsonQ.where.location = {
      $geoWithin: {
        $centerSphere: [{ longitude: 0, dummytude: 0 }, 1],
      },
    };
    q.withJSON(jsonQ);
    q.find()
      .then(done.fail)
      .catch(() => done());
  });

  it_id('02d4e7e6-859a-4ab6-878d-135ccc77040e')(it)('can add new config to existing config', async () => {
    await request({
      method: 'PUT',
      url: 'http://localhost:8378/1/config',
      json: true,
      body: {
        params: {
          files: [{ __type: 'File', name: 'name', url: 'http://url' }],
        },
      },
      headers: masterKeyHeaders,
    });

    await request({
      method: 'PUT',
      url: 'http://localhost:8378/1/config',
      json: true,
      body: {
        params: { newConfig: 'good' },
      },
      headers: masterKeyHeaders,
    });

    const result = await Parse.Config.get();
    equal(result.get('files')[0].toJSON(), {
      __type: 'File',
      name: 'name',
      url: 'http://url',
    });
    equal(result.get('newConfig'), 'good');
  });

  it('can set object type key', async () => {
    const data = { bar: true, baz: 100 };
    const object = new TestObject();
    object.set('objectField', data);
    await object.save();

    const query = new Parse.Query(TestObject);
    let result = await query.get(object.id);
    equal(result.get('objectField'), data);

    object.set('objectField.baz', 50, { ignoreValidation: true });
    await object.save();

    result = await query.get(object.id);
    equal(result.get('objectField'), { bar: true, baz: 50 });
  });

  it('can update numeric array', async () => {
    const data1 = [0, 1.1, 1, -2, 3];
    const data2 = [0, 1.1, 1, -2, 3, 4];
    const obj1 = new TestObject();
    obj1.set('array', data1);
    await obj1.save();
    equal(obj1.get('array'), data1);

    const query = new Parse.Query(TestObject);
    query.equalTo('objectId', obj1.id);

    const result = await query.first();
    equal(result.get('array'), data1);

    result.set('array', data2);
    equal(result.get('array'), data2);
    await result.save();
    equal(result.get('array'), data2);

    const results = await query.find();
    equal(results[0].get('array'), data2);
  });

  it('can update mixed array', async () => {
    const data1 = [0, 1.1, 'hello world', { foo: 'bar' }];
    const data2 = [0, 1, { foo: 'bar' }, [], [1, 2, 'bar']];
    const obj1 = new TestObject();
    obj1.set('array', data1);
    await obj1.save();
    equal(obj1.get('array'), data1);

    const query = new Parse.Query(TestObject);
    query.equalTo('objectId', obj1.id);

    const result = await query.first();
    equal(result.get('array'), data1);

    result.set('array', data2);
    equal(result.get('array'), data2);

    await result.save();
    equal(result.get('array'), data2);

    const results = await query.find();
    equal(results[0].get('array'), data2);
  });

  it('can query regex with unicode', async () => {
    const object = new TestObject();
    object.set('field', 'autoöo');
    await object.save();

    const query = new Parse.Query(TestObject);
    query.contains('field', 'autoöo');
    const results = await query.find();

    expect(results.length).toBe(1);
    expect(results[0].get('field')).toBe('autoöo');
  });

  it('can update mixed array more than 100 elements', async () => {
    const array = [0, 1.1, 'hello world', { foo: 'bar' }, null];
    const obj = new TestObject({ array });
    await obj.save();

    const query = new Parse.Query(TestObject);
    const result = await query.get(obj.id);
    equal(result.get('array').length, 5);

    for (let i = 0; i < 100; i += 1) {
      array.push(i);
    }
    obj.set('array', array);
    await obj.save();

    const results = await query.find();
    equal(results[0].get('array').length, 105);
  });

  xit('todo: exclude keys with select key (sdk query get)', async done => {
    // there is some problem with js sdk caching

    const obj = new TestObject({ foo: 'baz', hello: 'world' });
    await obj.save();

    const query = new Parse.Query('TestObject');

    query.withJSON({
      keys: 'hello',
      excludeKeys: 'hello',
    });

    const object = await query.get(obj.id);
    expect(object.get('foo')).toBeUndefined();
    expect(object.get('hello')).toBeUndefined();
    done();
  });

  it_only_db('mongo')('can use explain on User class', async () => {
    // Create user
    const user = new Parse.User();
    user.set('username', 'foo');
    user.set('password', 'bar');
    await user.save();
    // Query for user with explain
    const query = new Parse.Query('_User');
    query.equalTo('objectId', user.id);
    query.explain();
    const result = await query.find();
    // Validate
    expect(result.executionStats).not.toBeUndefined();
  });

  it('should query with distinct within eachBatch and direct access enabled', async () => {
    await reconfigureServer({
      directAccess: true,
    });

    Parse.CoreManager.setRESTController(
      ParseServerRESTController(Parse.applicationId, ParseServer.promiseRouter({ appId: Parse.applicationId }))
    );

    const user = new Parse.User();
    user.set('username', 'foo');
    user.set('password', 'bar');
    await user.save();

    const score = new Parse.Object('Score');
    score.set('player', user);
    score.set('score', 1);
    await score.save();

    await new Parse.Query('_User')
      .equalTo('objectId', user.id)
      .eachBatch(async ([user]) => {
        const score = await new Parse.Query('Score')
          .equalTo('player', user)
          .distinct('score', { useMasterKey: true });
        expect(score).toEqual([1]);
      }, { useMasterKey: true });
  });

  describe_only_db('mongo')('query nested keys', () => {
    it('queries nested key using equalTo', async () => {
      const child = new Parse.Object('Child');
      child.set('key', 'value');
      await child.save();

      const parent = new Parse.Object('Parent');
      parent.set('some', {
        nested: {
          key: {
            child,
          },
        },
      });
      await parent.save();

      const query1 = await new Parse.Query('Parent')
        .equalTo('some.nested.key.child', child)
        .find();

      expect(query1.length).toEqual(1);
    });

    it('queries nested key using containedIn', async () => {
      const child = new Parse.Object('Child');
      child.set('key', 'value');
      await child.save();

      const parent = new Parse.Object('Parent');
      parent.set('some', {
        nested: {
          key: {
            child,
          },
        },
      });
      await parent.save();

      const query1 = await new Parse.Query('Parent')
        .containedIn('some.nested.key.child', [child])
        .find();

      expect(query1.length).toEqual(1);
    });

    it('queries nested key using matchesQuery', async () => {
      const child = new Parse.Object('Child');
      child.set('key', 'value');
      await child.save();

      const parent = new Parse.Object('Parent');
      parent.set('some', {
        nested: {
          key: {
            child,
          },
        },
      });
      await parent.save();

      const query1 = await new Parse.Query('Parent')
        .matchesQuery('some.nested.key.child', new Parse.Query('Child').equalTo('key', 'value'))
        .find();

      expect(query1.length).toEqual(1);
    });
  });
});",1
"      expect(group.checks()[0].checkState()).toBe(CheckState.fail);
      expect(group.checks()[1].checkState()).toBe(CheckState.fail);
      expect(group.checks()[2].checkState()).toBe(CheckState.fail);
      expect(group.checks()[4].checkState()).toBe(CheckState.fail);
      expect(group.checks()[5].checkState()).toBe(CheckState.fail);
    });
  });

  describe('CheckGroupDatabase', () => {
    it('is subclassed correctly', async () => {
      const group = new CheckGroupDatabase();
      expect(group.name()).toBeDefined();",1
"    }
    if (databaseOptions.schemaCacheTtl === undefined) {
      databaseOptions.schemaCacheTtl = DatabaseOptions.schemaCacheTtl.default;
    } else if (typeof databaseOptions.schemaCacheTtl !== 'number') {
      throw `databaseOptions.schemaCacheTtl must be a number`;
    }
  }

  static validateRateLimit(rateLimit) {
    if (!rateLimit) {
      return;
    }",1
" *
 * If there are no deprecations, this must return an empty array.
 */
module.exports = [
  { optionKey: 'encodeParseObjectInCloudFunction', changeNewDefault: 'true' },
  { optionKey: 'enableInsecureAuthAdapters', changeNewDefault: 'false' },
];",1
"    help:
      'The MongoDB driver event name to listen for. See the [MongoDB driver events documentation](https://www.mongodb.com/docs/drivers/node/current/fundamentals/monitoring/) for available events.',
    required: true,
  },
};
module.exports.DatabaseOptions = {
  appName: {
    env: 'PARSE_SERVER_DATABASE_APP_NAME',
    help:
      'The MongoDB driver option to specify the name of the application that created this MongoClient instance.',
  },
  authMechanism: {",1
" * @property {String} logLevel The log level to use for this event. See [LogLevel](LogLevel.html) for available values. Defaults to `'info'`.
 * @property {String} name The MongoDB driver event name to listen for. See the [MongoDB driver events documentation](https://www.mongodb.com/docs/drivers/node/current/fundamentals/monitoring/) for available events.
 */

/**
 * @interface DatabaseOptions
 * @property {String} appName The MongoDB driver option to specify the name of the application that created this MongoClient instance.
 * @property {String} authMechanism The MongoDB driver option to specify the authentication mechanism that MongoDB will use to authenticate the connection.
 * @property {Any} authMechanismProperties The MongoDB driver option to specify properties for the specified authMechanism as a comma-separated list of colon-separated key-value pairs.
 * @property {String} authSource The MongoDB driver option to specify the database name associated with the user's credentials.
 * @property {Boolean} autoSelectFamily The MongoDB driver option to set whether the socket attempts to connect to IPv6 and IPv4 addresses until a connection is established. If available, the driver will select the first IPv6 address.
 * @property {Number} autoSelectFamilyAttemptTimeout The MongoDB driver option to specify the amount of time in milliseconds to wait for a connection attempt to finish before trying the next address when using the autoSelectFamily option. If set to a positive integer less than 10, the value 10 is used instead.",1
"        check: () => {
          if (config.graphQLPublicIntrospection !== false) {
            throw 1;
          }
        },
      }),
    ];
  }
}

module.exports = CheckGroupServerConfig;",1
"  clientSDK,
  context,
  options = {}
) {
  const { isGet } = options;

  // Run beforeFind trigger - may modify query or return objects directly
  const result = await triggers.maybeRunQueryTrigger(
    triggers.Types.beforeFind,
    className,
    restWhere,
    restOptions,",1
"    appName?: string;
    authMechanism?: string;
    authMechanismProperties?: any;
    authSource?: string;
    autoSelectFamily?: boolean;
    autoSelectFamilyAttemptTimeout?: number;
    compressors?: string[] | string;
    connectTimeoutMS?: number;
    directConnection?: boolean;
    forceServerObjectId?: boolean;
    heartbeatFrequencyMS?: number;
    loadBalanced?: boolean;",1
"        expect(response.status).toBe(400);
        const body = response.text;
        expect(body).toEqual('{""code"":122,""error"":""Filename not provided.""}');
        done();
      });
    });
  });

  describe('deleting files', () => {
    it('fails to delete an unkown file', done => {
      const headers = {
        'Content-Type': 'application/octet-stream',",1
"import BodyParser from 'body-parser';
import * as Middlewares from '../middlewares';
import Parse from 'parse/node';
import Config from '../Config';
import logger from '../logger';
const triggers = require('../triggers');
const http = require('http');
const Utils = require('../Utils');

const downloadFileFromURI = uri => {
  return new Promise((res, rej) => {
    http
      .get(uri, response => {
        response.setDefaultEncoding('base64');
        let body = `data:${response.headers['content-type']};base64,`;
        response.on('data', data => (body += data));
        response.on('end', () => res(body));
      })
      .on('error', e => {
        rej(`Error downloading file from ${uri}: ${e.message}`);
      });
  });
};

const addFileDataIfNeeded = async file => {
  if (file._source.format === 'uri') {
    const base64 = await downloadFileFromURI(file._source.uri);
    file._previousSave = file;
    file._data = base64;
    file._requestTask = null;
  }
  return file;
};

export class FilesRouter {
  expressRouter({ maxUploadSize = '20Mb' } = {}) {
    var router = express.Router();
    router.get('/files/:appId/:filename', this.getHandler);
    router.get('/files/:appId/metadata/:filename', this.metadataHandler);

    router.post('/files', function (req, res, next) {
      next(new Parse.Error(Parse.Error.INVALID_FILE_NAME, 'Filename not provided.'));
    });

    router.post(
      '/files/:filename',
      BodyParser.raw({
        type: () => {
          return true;
        },
        limit: maxUploadSize,
      }), // Allow uploads without Content-Type, or with any Content-Type.
      Middlewares.handleParseHeaders,
      Middlewares.handleParseSession,
      this.createHandler
    );

    router.delete(
      '/files/:filename',
      Middlewares.handleParseHeaders,
      Middlewares.handleParseSession,
      Middlewares.enforceMasterKeyAccess,
      this.deleteHandler
    );
    return router;
  }

  async getHandler(req, res) {
    const config = Config.get(req.params.appId);
    if (!config) {
      res.status(403);
      const err = new Parse.Error(Parse.Error.OPERATION_FORBIDDEN, 'Invalid application ID.');
      res.json({ code: err.code, error: err.message });
      return;
    }
    const filesController = config.filesController;
    const filename = req.params.filename;
    const mime = (await import('mime')).default;
    const contentType = mime.getType(filename);
    if (isFileStreamable(req, filesController)) {
      filesController.handleFileStream(config, filename, req, res, contentType).catch(() => {
        res.status(404);
        res.set('Content-Type', 'text/plain');
        res.end('File not found.');
      });
    } else {
      filesController
        .getFileData(config, filename)
        .then(data => {
          res.status(200);
          res.set('Content-Type', contentType);
          res.set('Content-Length', data.length);
          res.end(data);
        })
        .catch(() => {
          res.status(404);
          res.set('Content-Type', 'text/plain');
          res.end('File not found.');
        });
    }
  }

  async createHandler(req, res, next) {
    const config = req.config;
    const user = req.auth.user;
    const isMaster = req.auth.isMaster;
    const isLinked = user && Parse.AnonymousUtils.isLinked(user);
    if (!isMaster && !config.fileUpload.enableForAnonymousUser && isLinked) {
      next(
        new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by anonymous user is disabled.')
      );
      return;
    }
    if (!isMaster && !config.fileUpload.enableForAuthenticatedUser && !isLinked && user) {
      next(
        new Parse.Error(
          Parse.Error.FILE_SAVE_ERROR,
          'File upload by authenticated user is disabled.'
        )
      );
      return;
    }
    if (!isMaster && !config.fileUpload.enableForPublic && !user) {
      next(new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by public is disabled.'));
      return;
    }
    const filesController = config.filesController;
    const { filename } = req.params;
    const contentType = req.get('Content-type');

    if (!req.body || !req.body.length) {
      next(new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'Invalid file upload.'));
      return;
    }

    const error = filesController.validateFilename(filename);
    if (error) {
      next(error);
      return;
    }

    const fileExtensions = config.fileUpload?.fileExtensions;
    if (!isMaster && fileExtensions) {
      const isValidExtension = extension => {
        return fileExtensions.some(ext => {
          if (ext === '*') {
            return true;
          }
          const regex = new RegExp(ext);
          if (regex.test(extension)) {
            return true;
          }
        });
      };
      let extension = contentType;
      if (filename && filename.includes('.')) {
        extension = filename.substring(filename.lastIndexOf('.') + 1);
      } else if (contentType && contentType.includes('/')) {
        extension = contentType.split('/')[1];
      }
      extension = extension?.split(' ')?.join('');

      if (extension && !isValidExtension(extension)) {
        next(
          new Parse.Error(
            Parse.Error.FILE_SAVE_ERROR,
            `File upload of extension ${extension} is disabled.`
          )
        );
        return;
      }
    }

    const base64 = req.body.toString('base64');
    const file = new Parse.File(filename, { base64 }, contentType);
    const { metadata = {}, tags = {} } = req.fileData || {};
    try {
      // Scan request data for denied keywords
      Utils.checkProhibitedKeywords(config, metadata);
      Utils.checkProhibitedKeywords(config, tags);
    } catch (error) {
      next(new Parse.Error(Parse.Error.INVALID_KEY_NAME, error));
      return;
    }
    file.setTags(tags);
    file.setMetadata(metadata);
    const fileSize = Buffer.byteLength(req.body);
    const fileObject = { file, fileSize };
    try {
      // run beforeSaveFile trigger
      const triggerResult = await triggers.maybeRunFileTrigger(
        triggers.Types.beforeSave,
        fileObject,
        config,
        req.auth
      );
      let saveResult;
      // if a new ParseFile is returned check if it's an already saved file
      if (triggerResult instanceof Parse.File) {
        fileObject.file = triggerResult;
        if (triggerResult.url()) {
          // set fileSize to null because we wont know how big it is here
          fileObject.fileSize = null;
          saveResult = {
            url: triggerResult.url(),
            name: triggerResult._name,
          };
        }
      }
      // if the file returned by the trigger has already been saved skip saving anything
      if (!saveResult) {
        // if the ParseFile returned is type uri, download the file before saving it
        await addFileDataIfNeeded(fileObject.file);
        // update fileSize
        const bufferData = Buffer.from(fileObject.file._data, 'base64');
        fileObject.fileSize = Buffer.byteLength(bufferData);
        // prepare file options
        const fileOptions = {
          metadata: fileObject.file._metadata,",1
"    public_id_and_format = PreloadedFile.split_format(this.filename);
    this.public_id = public_id_and_format[0];
    this.format = public_id_and_format[1];
  }

  is_valid() {
    let expected_signature;
    expected_signature = utils.api_sign_request({
      public_id: this.public_id,
      version: this.version
    }, config().api_secret);
    return this.signature === expected_signature;
  }

  static split_format(identifier) {
    let format, last_dot, public_id;
    last_dot = identifier.lastIndexOf(""."");
    if (last_dot === -1) {",1
"  background = background && background.replace(/^#/, ""rgb:"");
  let color = consumeOption(options, ""color"");
  color = color && color.replace(/^#/, ""rgb:"");
  let base_transformations = toArray(consumeOption(options, ""transformation"", []));
  let named_transformation = [];
  if (base_transformations.some(isObject)) {
    base_transformations = base_transformations.map(tr => utils.generate_transformation_string(
      isObject(tr) ? clone(tr) : {transformation: tr}
    ));
  } else {
    named_transformation = base_transformations.join(""."");
    base_transformations = [];
  }
  let effect = consumeOption(options, ""effect"");
  if (isArray(effect)) {
    effect = effect.join("":"");
  } else if (isObject(effect)) {
    effect = entries(effect).map(
      ([key, value]) => `${key}:${value}`
    );
  }
  let border = consumeOption(options, ""border"");
  if (isObject(border)) {
    border = `${border.width != null ? border.width : 2}px_solid_${(border.color != null ? border.color : ""black"").replace(/^#/, 'rgb:')}`;
  } else if (/^\d+$/.exec(border)) { // fallback to html border attributes
    options.border = border;
    border = void 0;
  }
  let flags = toArray(consumeOption(options, ""flags"")).join(""."");
  let dpr = consumeOption(options, ""dpr"", config().dpr);
  if (options.offset != null) {
    [options.start_offset, options.end_offset] = split_range(consumeOption(options, ""offset""));
  }
  if (options.start_offset) {
    options.start_offset = normalize_expression(options.start_offset);
  }
  if (options.end_offset) {
    options.end_offset = normalize_expression(options.end_offset);
  }
  let overlay = process_layer(consumeOption(options, ""overlay""));
  let radius = process_radius(consumeOption(options, ""radius""));
  let underlay = process_layer(consumeOption(options, ""underlay""));
  let ifValue = process_if(consumeOption(options, ""if""));
  let custom_function = process_custom_function(consumeOption(options, ""custom_function""));
  let custom_pre_function = process_custom_pre_function(consumeOption(options, ""custom_pre_function""));
  let fps = consumeOption(options, 'fps');
  if (isArray(fps)) {
    fps = fps.join('-');
  }
  let params = {
    a: normalize_expression(angle),
    ar: normalize_expression(consumeOption(options, ""aspect_ratio"")),
    b: background,
    bo: border,
    c: crop,
    co: color,
    dpr: normalize_expression(dpr),
    e: normalize_expression(effect),
    fl: flags,
    fn: custom_function || custom_pre_function,
    fps: fps,
    h: normalize_expression(height),
    ki: normalize_expression(consumeOption(options, ""keyframe_interval"")),
    l: overlay,
    o: normalize_expression(consumeOption(options, ""opacity"")),
    q: normalize_expression(consumeOption(options, ""quality"")),
    r: radius,
    t: named_transformation,
    u: underlay,
    w: normalize_expression(width),
    x: normalize_expression(consumeOption(options, ""x"")),
    y: normalize_expression(consumeOption(options, ""y"")),
    z: normalize_expression(consumeOption(options, ""zoom""))
  };

  SIMPLE_PARAMS.forEach(([name, short]) => {
    let value = consumeOption(options, name);
    if (value !== undefined) {
      params[short] = value;
    }
  });
  if (params.vc != null) {
    params.vc = process_video_params(params.vc);
  }
  [""so"", ""eo"", ""du""].forEach((short) => {
    if (params[short] !== undefined) {
      params[short] = norm_range_value(params[short]);
    }
  });

  let variablesParam = consumeOption(options, ""variables"", []);
  let variables = entries(options)
    .filter(([key, value]) => key.startsWith('$'))
    .map(([key, value]) => {
      delete options[key];
      return `${key}_${normalize_expression(value)}`;
    }).sort().concat(
      variablesParam.map(([name, value]) => `${name}_${normalize_expression(value)}`)
    ).join(',');

  let transformations = entries(params)
    .filter(([key, value]) => utils.present(value))
    .map(([key, value]) => key + '_' + value)
    .sort()
    .join(',');

  let raw_transformation = consumeOption(options, 'raw_transformation');
  transformations = compact([ifValue, variables, transformations, raw_transformation]).join("","");
  base_transformations.push(transformations);
  transformations = base_transformations;
  if (responsive_width) {
    let responsive_width_transformation = config().responsive_width_transformation
      || DEFAULT_RESPONSIVE_WIDTH_TRANSFORMATION;

    transformations.push(utils.generate_transformation_string(clone(responsive_width_transformation)));
  }
  if (String(width).startsWith(""auto"") || responsive_width) {
    options.responsive = true;
  }
  if (dpr === ""auto"") {
    options.hidpi = true;
  }
  return filter(transformations, utils.present).join(""/"");
}

function updateable_resource_params(options, params = {}) {
  if (options.access_control != null) {
    params.access_control = utils.jsonArrayParam(options.access_control);
  }
  if (options.auto_tagging != null) {
    params.auto_tagging = options.auto_tagging;
  }
  if (options.background_removal != null) {
    params.background_removal = options.background_removal;
  }
  if (options.categorization != null) {
    params.categorization = options.categorization;
  }
  if (options.context != null) {
    params.context = utils.encode_context(options.context);
  }
  if (options.metadata != null) {
    params.metadata = utils.encode_context(options.metadata);
  }
  if (options.custom_coordinates != null) {
    params.custom_coordinates = encodeDoubleArray(options.custom_coordinates);
  }
  if (options.detection != null) {
    params.detection = options.detection;
  }
  if (options.face_coordinates != null) {
    params.face_coordinates = encodeDoubleArray(options.face_coordinates);
  }
  if (options.headers != null) {
    params.headers = utils.build_custom_headers(options.headers);
  }
  if (options.notification_url != null) {
    params.notification_url = options.notification_url;
  }
  if (options.ocr != null) {
    params.ocr = options.ocr;
  }
  if (options.raw_convert != null) {
    params.raw_convert = options.raw_convert;
  }
  if (options.similarity_search != null) {
    params.similarity_search = options.similarity_search;
  }
  if (options.tags != null) {
    params.tags = toArray(options.tags).join("","");
  }
  if (options.quality_override != null) {
    params.quality_override = options.quality_override;
  }
  if (options.asset_folder != null) {
    params.asset_folder = options.asset_folder;
  }
  if (options.display_name != null) {
    params.display_name = options.display_name;
  }
  if (options.unique_display_name != null) {
    params.unique_display_name = options.unique_display_name;
  }
  if (options.visual_search != null) {
    params.visual_search = options.visual_search;
  }
  if (options.regions != null) {
    params.regions = JSON.stringify(options.regions);
  }
  const autoTranscription = options.auto_transcription;
  if (autoTranscription != null) {
    if (typeof autoTranscription === 'boolean') {
      params.auto_transcription = utils.as_safe_bool(autoTranscription);
    } else {
      const isAutoTranscriptionObject = typeof autoTranscription === 'object' && !Array.isArray(autoTranscription);
      if (isAutoTranscriptionObject && Object.keys(autoTranscription).includes('translate')) {
        params.auto_transcription = JSON.stringify(autoTranscription);
      }
    }
  }
  return params;
}

/**
 * A list of keys used by the url() function.
 * @private
 */
const URL_KEYS = [
  'api_secret',
  'auth_token',
  'cdn_subdomain',
  'cloud_name',
  'cname',
  'format',
  'long_url_signature',
  'private_cdn',
  'resource_type',
  'secure',
  'secure_cdn_subdomain',
  'secure_distribution',
  'shorten',
  'sign_url',
  'ssl_detected',
  'type',
  'url_suffix',
  'use_root_path',
  'version'
];

/**
 * Create a new object with only URL parameters
 * @param {object} options The source object
 * @return {Object} An object containing only URL parameters
 */

function extractUrlParams(options) {
  return pickOnlyExistingValues(options, ...URL_KEYS);
}

/**
 * Create a new object with only transformation parameters
 * @param {object} options The source object
 * @return {Object} An object containing only transformation parameters
 */

function extractTransformationParams(options) {
  return pickOnlyExistingValues(options, ...TRANSFORMATION_PARAMS);
}

/**
 * Handle the format parameter for fetch urls
 * @private
 * @param options url and transformation options. This argument may be changed by the function!
 */

function patchFetchFormat(options = {}) {
  if (options.type === ""fetch"") {
    if (options.fetch_format == null) {
      options.fetch_format = consumeOption(options, ""format"");
    }
  }
}

function build_distribution_domain(source, options) {
  const cloud_name = consumeOption(options, 'cloud_name', config().cloud_name);
  if (!cloud_name) {
    throw new Error('Must supply cloud_name in tag or in configuration');
  }

  let secure = consumeOption(options, 'secure', true);
  const ssl_detected = consumeOption(options, 'ssl_detected', config().ssl_detected);
  if (secure === null) {
    secure = ssl_detected || config().secure;
  }

  const private_cdn = consumeOption(options, 'private_cdn', config().private_cdn);
  const cname = consumeOption(options, 'cname', config().cname);
  const secure_distribution = consumeOption(options, 'secure_distribution', config().secure_distribution);
  const cdn_subdomain = consumeOption(options, 'cdn_subdomain', config().cdn_subdomain);
  const secure_cdn_subdomain = consumeOption(options, 'secure_cdn_subdomain', config().secure_cdn_subdomain);

  return unsigned_url_prefix(source, cloud_name, private_cdn, cdn_subdomain, secure_cdn_subdomain, cname, secure, secure_distribution);
}

function url(public_id, options = {}) {
  let signature, source_to_sign;
  utils.patchFetchFormat(options);
  let type = consumeOption(options, ""type"", null);
  let transformation = utils.generate_transformation_string(options);

  let resource_type = consumeOption(options, ""resource_type"", ""image"");
  let version = consumeOption(options, ""version"");
  let force_version = consumeOption(options, ""force_version"", config().force_version);
  if (force_version == null) {
    force_version = true;
  }
  let long_url_signature = !!consumeOption(options, ""long_url_signature"", config().long_url_signature);
  let format = consumeOption(options, ""format"");
  let shorten = consumeOption(options, ""shorten"", config().shorten);
  let sign_url = consumeOption(options, ""sign_url"", config().sign_url);
  let api_secret = consumeOption(options, ""api_secret"", config().api_secret);
  let url_suffix = consumeOption(options, ""url_suffix"");
  let use_root_path = consumeOption(options, ""use_root_path"", config().use_root_path);
  let signature_algorithm = consumeOption(options, ""signature_algorithm"", config().signature_algorithm || DEFAULT_SIGNATURE_ALGORITHM);
  if (long_url_signature) {
    signature_algorithm = 'sha256';
  }
  let auth_token = consumeOption(options, ""auth_token"");
  if (auth_token !== false) {
    auth_token = exports.merge(config().auth_token, auth_token);
  }
  let preloaded = /^(image|raw)\/([a-z0-9_]+)\/v(\d+)\/([^#]+)$/.exec(public_id);
  if (preloaded) {
    resource_type = preloaded[1];
    type = preloaded[2];
    version = preloaded[3];
    public_id = preloaded[4];
  }
  let original_source = public_id;
  if (public_id == null) {
    return original_source;
  }
  public_id = public_id.toString();
  if (type === null && public_id.match(/^https?:\//i)) {
    return original_source;
  }
  [resource_type, type] = finalize_resource_type(resource_type, type, url_suffix, use_root_path, shorten);
  [public_id, source_to_sign] = finalize_source(public_id, format, url_suffix);

  if (version == null && force_version && source_to_sign.indexOf(""/"") >= 0 && !source_to_sign.match(/^v[0-9]+/) && !source_to_sign.match(/^https?:\//)) {
    version = 1;
  }
  if (version != null) {
    version = `v${version}`;
  } else {
    version = null;
  }

  transformation = transformation.replace(/([^:])\/\//g, '$1/');
  if (sign_url && isEmpty(auth_token)) {
    let to_sign = [transformation, source_to_sign].filter(function (part) {
      return (part != null) && part !== '';
    }).join('/');

    const signatureConfig = {};
    if (long_url_signature) {
      signatureConfig.algorithm = 'sha256';
      signatureConfig.signatureLength = 32;
    } else {
      signatureConfig.algorithm = signature_algorithm;
      signatureConfig.signatureLength = 8;
    }

    const truncated = compute_hash(to_sign + api_secret, signatureConfig.algorithm, 'base64')
      .slice(0, signatureConfig.signatureLength)
      .replace(/\//g, '_')
      .replace(/\+/g, '-');
    signature = `s--${truncated}--`;
  }

  let prefix = build_distribution_domain(public_id, options);
  let resultUrl = [prefix, resource_type, type, signature, transformation, version, public_id].filter(function (part) {
    return (part != null) && part !== '';
  }).join('/').replace(/ /g, '%20');
  if (sign_url && !isEmpty(auth_token)) {
    auth_token.url = urlParse(resultUrl).path;
    let token = generate_token(auth_token);
    resultUrl += `?${token}`;
  }

  const urlAnalytics = ensureOption(options, 'urlAnalytics', ensureOption(options, 'analytics', true));

  if (urlAnalytics === true) {
    let {
      sdkCode: sdkCodeDefault,
      sdkSemver: sdkSemverDefault,
      techVersion: techVersionDefault,
      product: productDefault
    } = getSDKVersions();
    const sdkCode = ensureOption(options, 'sdkCode', ensureOption(options, 'sdk_code', sdkCodeDefault));
    const sdkSemver = ensureOption(options, 'sdkSemver', ensureOption(options, 'sdk_semver', sdkSemverDefault));
    const techVersion = ensureOption(options, 'techVersion', ensureOption(options, 'tech_version', techVersionDefault));
    const product = ensureOption(options, 'product', productDefault);

    let sdkVersions = {
      sdkCode: sdkCode,
      sdkSemver: sdkSemver,
      techVersion: techVersion,
      product: product,
      urlAnalytics
    };

    let analyticsOptions = getAnalyticsOptions(
      Object.assign({}, options, sdkVersions)
    );

    let sdkAnalyticsSignature = getSDKAnalyticsSignature(analyticsOptions);

    // url might already have a '?' query param
    let appender = '?';
    if (resultUrl.indexOf('?') >= 0) {
      appender = '&';
    }
    resultUrl = `${resultUrl}${appender}_a=${sdkAnalyticsSignature}`;
  }

  return resultUrl;
}

function video_url(public_id, options) {
  options = extend({
    resource_type: 'video'
  }, options);
  return utils.url(public_id, options);
}

function finalize_source(source, format, url_suffix) {
  let source_to_sign;
  source = source.replace(/([^:])\/\//g, '$1/');
  if (source.match(/^https?:\//i)) {
    source = smart_escape(source);
    source_to_sign = source;
  } else {
    source = encodeURIComponent(decodeURIComponent(source)).replace(/%3A/g, "":"").replace(/%2F/g, ""/"");
    source_to_sign = source;
    if (url_suffix) {
      if (url_suffix.match(/[\.\/]/)) {
        throw new Error('url_suffix should not include . or /');
      }
      source = source + '/' + url_suffix;
    }
    if (format != null) {
      source = source + '.' + format;
      source_to_sign = source_to_sign + '.' + format;
    }
  }
  return [source, source_to_sign];
}

function video_thumbnail_url(public_id, options) {
  options = extend({}, DEFAULT_POSTER_OPTIONS, options);
  return utils.url(public_id, options);
}

function finalize_resource_type(resource_type, type, url_suffix, use_root_path, shorten) {
  if (type == null) {
    type = 'upload';
  }
  if (url_suffix != null) {
    if (resource_type === 'image' && type === 'upload') {
      resource_type = ""images"";
      type = null;
    } else if (resource_type === 'image' && type === 'private') {
      resource_type = 'private_images';
      type = null;
    } else if (resource_type === 'image' && type === 'authenticated') {
      resource_type = 'authenticated_images';
      type = null;
    } else if (resource_type === 'raw' && type === 'upload') {
      resource_type = 'files';
      type = null;
    } else if (resource_type === 'video' && type === 'upload') {
      resource_type = 'videos';
      type = null;
    } else {
      throw new Error(""URL Suffix only supported for image/upload, image/private, image/authenticated, video/upload and raw/upload"");
    }
  }
  if (use_root_path) {
    if ((resource_type === 'image' && type === 'upload') || (resource_type === 'images' && (type == null))) {
      resource_type = null;
      type = null;
    } else {
      throw new Error(""Root path only supported for image/upload"");
    }
  }
  if (shorten && resource_type === 'image' && type === 'upload') {
    resource_type = 'iu';
    type = null;
  }
  return [resource_type, type];
}

// cdn_subdomain and secure_cdn_subdomain
// 1) Customers in shared distribution (e.g. res.cloudinary.com)
//    if cdn_domain is true uses res-[1-5].cloudinary.com for both http and https.
//    Setting secure_cdn_subdomain to false disables this for https.
// 2) Customers with private cdn
//    if cdn_domain is true uses cloudname-res-[1-5].cloudinary.com for http
//    if secure_cdn_domain is true uses cloudname-res-[1-5].cloudinary.com for https
//      (please contact support if you require this)
// 3) Customers with cname
//    if cdn_domain is true uses a[1-5].cname for http.
//    For https, uses the same naming scheme as 1 for shared distribution and as 2 for private distribution.

function unsigned_url_prefix(
  source,
  cloud_name,
  private_cdn,
  cdn_subdomain,
  secure_cdn_subdomain,
  cname,
  secure,
  secure_distribution
) {
  let prefix;
  if (cloud_name.indexOf(""/"") === 0) {
    return '/res' + cloud_name;
  }
  let shared_domain = !private_cdn;
  if (secure) {
    if ((secure_distribution == null) || secure_distribution === exports.OLD_AKAMAI_SHARED_CDN) {
      secure_distribution = private_cdn ? cloud_name + ""-res.cloudinary.com"" : exports.SHARED_CDN;
    }
    if (shared_domain == null) {
      shared_domain = secure_distribution === exports.SHARED_CDN;
    }
    if ((secure_cdn_subdomain == null) && shared_domain) {
      secure_cdn_subdomain = cdn_subdomain;
    }
    if (secure_cdn_subdomain) {
      secure_distribution = secure_distribution.replace('res.cloudinary.com', 'res-' + ((crc32(source) % 5) + 1 + '.cloudinary.com'));
    }
    prefix = 'https://' + secure_distribution;
  } else if (cname) {
    let subdomain = cdn_subdomain ? 'a' + ((crc32(source) % 5) + 1) + '.' : '';
    prefix = 'http://' + subdomain + cname;
  } else {
    let cdn_part = private_cdn ? cloud_name + '-' : '';
    let subdomain_part = cdn_subdomain ? '-' + ((crc32(source) % 5) + 1) : '';
    let host = [cdn_part, 'res', subdomain_part, '.cloudinary.com'].join('');
    prefix = 'http://' + host;
  }
  if (shared_domain) {
    prefix += '/' + cloud_name;
  }
  return prefix;
}

function base_api_url_v1_1() {
  return base_api_url('v1_1');
}

function base_api_url_v2() {
  return base_api_url('v2');
}

function base_api_url(api_version) {
  if (!api_version || api_version.length === 0) {
    throw new Error('api_version needs to be a non-empty string');
  }

  return (path = [], options = []) => {
    let cloudinary = ensureOption(options, ""upload_prefix"", UPLOAD_PREFIX);
    let cloud_name = ensureOption(options, ""cloud_name"");
    let encode_path = unencoded_path => encodeURIComponent(unencoded_path).replace(""'"", '%27');
    let encoded_path = Array.isArray(path) ? path.map(encode_path) : encode_path(path);
    return [cloudinary, api_version, cloud_name].concat(encoded_path).join(""/"");
  };
}

function api_url(action = 'upload', options = {}) {
  let resource_type = options.resource_type || ""image"";
  return base_api_url_v1_1()([resource_type, action], options);
}

function random_public_id() {
  return crypto.randomBytes(12).toString('base64').replace(/[^a-z0-9]/g, """");
}

function signed_preloaded_image(result) {
  return `${result.resource_type}/upload/v${result.version}/${filter([result.public_id, result.format], utils.present).join(""."")}#${result.signature}`;
}

function api_sign_request(params_to_sign, api_secret) {
  let to_sign = entries(params_to_sign).filter(
    ([k, v]) => utils.present(v)
  ).map(
    ([k, v]) => `${k}=${toArray(v).join("","")}`
  ).sort().join(""&"");
  return compute_hash(to_sign + api_secret, config().signature_algorithm || DEFAULT_SIGNATURE_ALGORITHM, 'hex');
}

/**
 * Computes hash from input string using specified algorithm.
 * @private
 * @param {string} input string which to compute hash from
 * @param {string} signature_algorithm algorithm to use for computing hash
 * @param {string} encoding type of encoding
 * @return {string} computed hash value
 */
function compute_hash(input, signature_algorithm, encoding) {
  if (!SUPPORTED_SIGNATURE_ALGORITHMS.includes(signature_algorithm)) {
    throw new Error(`Signature algorithm ${signature_algorithm} is not supported. Supported algorithms: ${SUPPORTED_SIGNATURE_ALGORITHMS.join(', ')}`);
  }
  const hash = crypto.createHash(signature_algorithm).update(input).digest();
  return Buffer.from(hash).toString(encoding);
}

function clear_blank(hash) {
  let filtered_hash = {};
  entries(hash).filter(
    ([k, v]) => utils.present(v)
  ).forEach(
    ([k, v]) => {
      filtered_hash[k] = v.filter ? v.filter(x => x) : v;
    }
  );
  return filtered_hash;
}

function sort_object_by_key(object) {
  return Object.keys(object).sort().reduce((obj, key) => {
    obj[key] = object[key];
    return obj;
  }, {});
}

function merge(hash1, hash2) {
  return {...hash1, ...hash2};
}

function sign_request(params, options = {}) {
  let apiKey = ensureOption(options, 'api_key');
  let apiSecret = ensureOption(options, 'api_secret');
  params = exports.clear_blank(params);
  params.signature = exports.api_sign_request(params, apiSecret);
  params.api_key = apiKey;
  return params;
}

function webhook_signature(data, timestamp, options = {}) {
  ensurePresenceOf({
    data,
    timestamp
  });

  let api_secret = ensureOption(options, 'api_secret');
  let signature_algorithm = ensureOption(options, 'signature_algorithm', DEFAULT_SIGNATURE_ALGORITHM);
  return compute_hash(data + timestamp + api_secret, signature_algorithm, 'hex');
}

/**
 * Verifies the authenticity of a notification signature
 *
 * @param {string} body JSON of the request's body
 * @param {number} timestamp Unix timestamp in seconds. Can be retrieved from the X-Cld-Timestamp header
 * @param {string} signature Actual signature. Can be retrieved from the X-Cld-Signature header
 * @param {number} [valid_for=7200] The desired time in seconds for considering the request valid
 *
 * @return {boolean}
 */
function verifyNotificationSignature(body, timestamp, signature, valid_for = 7200) {
  // verify that signature is valid for the given timestamp
  if (timestamp < Math.round(Date.now() / 1000) - valid_for) {
    return false;
  }
  const payload_hash = utils.webhook_signature(body, timestamp, {
    api_secret: config().api_secret,
    signature_algorithm: config().signature_algorithm
  });
  return signature === payload_hash;
}

function process_request_params(params, options) {
  if ((options.unsigned != null) && options.unsigned) {
    params = exports.clear_blank(params);
    delete params.timestamp;
  } else if (options.oauth_token || config().oauth_token) {
    params = exports.clear_blank(params);
  } else if (options.signature) {
    params = exports.clear_blank(options);
  } else {
    params = exports.sign_request(params, options);
  }

  return params;
}

function private_download_url(public_id, format, options = {}) {
  let params = exports.sign_request({
    timestamp: options.timestamp || exports.timestamp(),
    public_id: public_id,
    format: format,
    type: options.type,
    attachment: options.attachment,
    expires_at: options.expires_at
  }, options);
  return exports.api_url(""download"", options) + ""?"" + querystring.stringify(params);
}

/**
 * Utility method that uses the deprecated ZIP download API.
 * @deprecated Replaced by {download_zip_url} that uses the more advanced and robust archive generation and download API
 */

function zip_download_url(tag, options = {}) {
  let params = exports.sign_request({
    timestamp: options.timestamp || exports.timestamp(),
    tag: tag,
    transformation: utils.generate_transformation_string(options)
  }, options);
  return exports.api_url(""download_tag.zip"", options) + ""?"" + hashToQuery(params);
}

/**
 * The returned url should allow downloading the backedup asset based on the
 * version and asset id
 * asset and version id are returned with resource(<PUBLIC_ID1>, { versions: true })
 * @param asset_id
 * @param version_id
 * @param options
 * @returns {string }
 */
function download_backedup_asset(asset_id, version_id, options = {}) {
  let params = exports.sign_request({
    timestamp: options.timestamp || exports.timestamp(),
    asset_id: asset_id,
    version_id: version_id
  }, options);
  return exports.base_api_url_v1()(['download_backup'], options) + ""?"" + hashToQuery(params);
}

/**
 * Utility method to create a signed URL for specified resources.
 * @param action
 * @param params
 * @param options
 */
function api_download_url(action, params, options) {
  const download_params = {
    ...params,
    mode: ""download""
  }
  let cloudinary_params = exports.sign_request(download_params, options);
  return exports.api_url(action, options) + ""?"" + hashToQuery(cloudinary_params);
}

/**
 * Returns a URL that when invokes creates an archive and returns it.
 * @param {object} options
 * @param {string} [options.resource_type=""image""] The resource type of files to include in the archive.
 *   Must be one of :image | :video | :raw
 * @param {string} [options.type=""upload""] The specific file type of resources: :upload|:private|:authenticated
 * @param {string|Array} [options.tags] list of tags to include in the archive
 * @param {string|Array<string>} [options.public_ids] list of public_ids to include in the archive
 * @param {string|Array<string>} [options.prefixes]  list of prefixes of public IDs (e.g., folders).
 * @param {string|Array<string>} [options.fully_qualified_public_ids] list of fully qualified public_ids to include
 *   in the archive.
 * @param {string|Array<string>} [options.transformations]  list of transformations.
 *   The derived images of the given transformations are included in the archive. Using the string representation of
 *   multiple chained transformations as we use for the 'eager' upload parameter.
 * @param {string} [options.mode=""create""] return the generated archive file or to store it as a raw resource and
 *   return a JSON with URLs for accessing the archive. Possible values: :download, :create
 * @param {string} [options.target_format=""zip""]
 * @param {string} [options.target_public_id]  public ID of the generated raw resource.
 *   Relevant only for the create mode. If not specified, random public ID is generated.
 * @param {boolean} [options.flatten_folders=false] If true, flatten public IDs with folders to be in the root
 *   of the archive. Add numeric counter to the file name in case of a name conflict.
 * @param {boolean} [options.flatten_transformations=false] If true, and multiple transformations are given,
 *   flatten the folder structure of derived images and store the transformation details on the file name instead.
 * @param {boolean} [options.use_original_filename] Use the original file name of included images
 *   (if available) instead of the public ID.
 * @param {boolean} [options.async=false] If true, return immediately and perform archive creation in the background.
 *   Relevant only for the create mode.
 * @param {string} [options.notification_url] URL to send an HTTP post request (webhook) to when the
 *   archive creation is completed.
 * @param {string|Array<string>} [options.target_tags=] Allows assigning one or more tags to the generated archive file
 *   (for later housekeeping via the admin API).
 * @param {string} [options.keep_derived=false] keep the derived images used for generating the archive
 * @return {String} archive url
 */
function download_archive_url(options = {}) {
  const params = exports.archive_params(merge(options, {
    mode: ""download""
  }))
  return api_download_url(""generate_archive"", params, options)
}

/**
 * Returns a URL that when invokes creates an zip archive and returns it.
 * @see download_archive_url
 */

function download_zip_url(options = {}) {
  return exports.download_archive_url(merge(options, {
    target_format: ""zip""
  }));
}

/**
 * Creates and returns a URL that when invoked creates an archive of a folder
 * @param {string} folder_path Full path (from the root) of the folder to download
 * @param {object} options Additional options
 * @returns {string} Url for downloading an archive of a folder
 */
function download_folder(folder_path, options = {}) {
  options.resource_type = options.resource_type || ""all"";
  options.prefixes = folder_path;
  let cloudinary_params = exports.sign_request(exports.archive_params(merge(options, {
    mode: ""download""
  })), options);
  return exports.api_url(""generate_archive"", options) + ""?"" + hashToQuery(cloudinary_params);
}

/**
 * Render the key/value pair as an HTML tag attribute
 * @private
 * @param {string} key
 * @param {string|boolean|number} [value]
 * @return {string} A string representing the HTML attribute
 */
function join_pair(key, value) {
  if (!value) {
    return void 0;
  }
  return value === true ? key : key + ""='"" + value + ""'"";
}

/**
 * If the given value is a string, replaces single or double quotes with character entities
 * @private
 * @param {*} value The string to encode quotes in
 * @return {*} Encoded string or original value if not a string
 */
function escapeQuotes(value) {
  return isString(value) ? value.replace(/\""/g, '&#34;').replace(/\'/g, '&#39;') : value;
}

/**
 *
 * @param attrs
 * @return {*}
 */
exports.html_attrs = function html_attrs(attrs) {
  return filter(map(attrs, function (value, key) {
    return join_pair(key, escapeQuotes(value));
  })).sort().join("" "");
};

const CLOUDINARY_JS_CONFIG_PARAMS = ['api_key', 'cloud_name', 'private_cdn', 'secure_distribution', 'cdn_subdomain'];

function cloudinary_js_config() {
  let params = pickOnlyExistingValues(config(), ...CLOUDINARY_JS_CONFIG_PARAMS);
  return `<script type='text/javascript'>\n$.cloudinary.config(${JSON.stringify(params)});\n</script>`;
}

function v1_result_adapter(callback) {
  if (callback == null) {
    return undefined;
  }
  return function (result) {
    if (result.error != null) {
      return callback(result.error);
    }
    return callback(void 0, result);
  };
}

function v1_adapter(name, num_pass_args, v1) {
  return function (...args) {
    let pass_args = take(args, num_pass_args);
    let options = args[num_pass_args];
    let callback = args[num_pass_args + 1];
    if ((callback == null) && isFunction(options)) {
      callback = options;
      options = {};
    }
    callback = v1_result_adapter(callback);
    args = pass_args.concat([callback, options]);
    return v1[name].apply(this, args);
  };
}

function v1_adapters(exports, v1, mapping) {
  return Object.keys(mapping).map((name) => {
    let num_pass_args = mapping[name];
    exports[name] = v1_adapter(name, num_pass_args, v1);
    return exports[name];
  });
}

function as_safe_bool(value) {
  if (value == null) {
    return void 0;
  }
  if (value === true || value === 'true' || value === '1') {
    value = 1;
  }
  if (value === false || value === 'false' || value === '0') {
    value = 0;
  }
  return value;
}

const NUMBER_PATTERN = ""([0-9]*)\\.([0-9]+)|([0-9]+)"";

const OFFSET_ANY_PATTERN = `(${NUMBER_PATTERN})([%pP])?`;
const RANGE_VALUE_RE = RegExp(`^${OFFSET_ANY_PATTERN}$`);
const OFFSET_ANY_PATTERN_RE = RegExp(`(${OFFSET_ANY_PATTERN})\\.\\.(${OFFSET_ANY_PATTERN})`);

// Split a range into the start and end values
function split_range(range) { // :nodoc:
  switch (range.constructor) {
  case String:
    if (!OFFSET_ANY_PATTERN_RE.test(range)) {
      return range;
    }
    return range.split("".."");
  case Array:
    return [first(range), last(range)];
  default:
    return [null, null];
  }
}

function norm_range_value(value) { // :nodoc:
  let offset = String(value).match(RANGE_VALUE_RE);
  if (offset) {
    let modifier = offset[5] ? 'p' : '';
    value = `${offset[1] || offset[4]}${modifier}`;
  }
  return value;
}

/**
 * A video codec parameter can be either a String or a Hash.
 * @param {Object} param <code>vc_<codec>[ : <profile> : [<level>]]</code>
 *                       or <code>{ codec: 'h264', profile: 'basic', level: '3.1' }</code>
 * @return {String} <code><codec> : <profile> : [<level>]]</code> if a Hash was provided
 *                   or the param if a String was provided.
 *                   Returns null if param is not a Hash or String
 */
function process_video_params(param) {
  switch (param.constructor) {
  case Object: {
    let video = """";
    if ('codec' in param) {
      video = param.codec;
      if ('profile' in param) {
        video += "":"" + param.profile;
        if ('level' in param) {
          video += "":"" + param.level;
        }
      }
    }
    return video;
  }
  case String:
    return param;
  default:
    return null;
  }
}

/**
 * Returns a Hash of parameters used to create an archive
 * @private
 * @param {object} options
 * @return {object} Archive API parameters
 */

function archive_params(options = {}) {
  return {
    allow_missing: exports.as_safe_bool(options.allow_missing),
    async: exports.as_safe_bool(options.async),
    expires_at: options.expires_at,
    flatten_folders: exports.as_safe_bool(options.flatten_folders),
    flatten_transformations: exports.as_safe_bool(options.flatten_transformations),
    keep_derived: exports.as_safe_bool(options.keep_derived),
    mode: options.mode,
    notification_url: options.notification_url,
    prefixes: options.prefixes && toArray(options.prefixes),
    fully_qualified_public_ids: options.fully_qualified_public_ids && toArray(options.fully_qualified_public_ids),
    public_ids: options.public_ids && toArray(options.public_ids),
    skip_transformation_name: exports.as_safe_bool(options.skip_transformation_name),
    tags: options.tags && toArray(options.tags),
    target_format: options.target_format,
    target_public_id: options.target_public_id,
    target_tags: options.target_tags && toArray(options.target_tags),
    timestamp: options.timestamp || exports.timestamp(),
    transformations: utils.build_eager(options.transformations),
    type: options.type,
    use_original_filename: exports.as_safe_bool(options.use_original_filename)
  };
}

exports.process_layer = process_layer;

exports.create_source_tag = function create_source_tag(src, source_type, codecs = null) {
  let video_type = source_type === 'ogv' ? 'ogg' : source_type;
  let mime_type = `video/${video_type}`;
  if (!isEmpty(codecs)) {
    let codecs_str = isArray(codecs) ? codecs.join(', ') : codecs;
    mime_type += `; codecs=${codecs_str}`;
  }
  return `<source ${utils.html_attrs({
    src,
    type: mime_type
  })}>`;
};

function build_explicit_api_params(public_id, options = {}) {
  return [exports.build_upload_params(extend({}, {public_id}, options))];
}

function generate_responsive_breakpoints_string(breakpoints) {
  if (breakpoints == null) {
    return null;
  }
  breakpoints = clone(breakpoints);
  if (!isArray(breakpoints)) {
    breakpoints = [breakpoints];
  }
  for (let j = 0; j < breakpoints.length; j++) {
    let breakpoint_settings = breakpoints[j];
    if (breakpoint_settings != null) {
      if (breakpoint_settings.transformation) {
        breakpoint_settings.transformation = utils.generate_transformation_string(
          clone(breakpoint_settings.transformation)
        );
      }
    }
  }
  return JSON.stringify(breakpoints);
}

function build_streaming_profiles_param(options = {}) {
  let params = pickOnlyExistingValues(options, ""display_name"", ""representations"");
  if (isArray(params.representations)) {
    params.representations = JSON.stringify(params.representations.map(
      r => ({
        transformation: utils.generate_transformation_string(r.transformation)
      })
    ));
  }
  return params;
}

function hashToParameters(hash) {
  return entries(hash).reduce((parameters, [key, value]) => {
    if (isArray(value)) {
      key = key.endsWith('[]') ? key : key + '[]';
      const items = value.map(v => [key, v]);
      parameters = parameters.concat(items);
    } else {
      parameters.push([key, value]);
    }
    return parameters;
  }, []);
}

/**
 * Convert a hash of values to a URI query string.
 * Array values are spread as individual parameters.
 * @param {object} hash Key-value parameters
 * @return {string} A URI query string.
 */
function hashToQuery(hash) {
  return hashToParameters(hash).map(
    ([key, value]) => `${querystring.escape(key)}=${querystring.escape(value)}`
  ).join('&');
}

/**
 * Verify that the parameter `value` is defined and it's string value is not zero.
 * <br>This function should not be confused with `isEmpty()`.
 * @private
 * @param {string|number} value The value to check.
 * @return {boolean} True if the value is defined and not empty.
 */

function present(value) {
  return value != null && ("""" + value).length > 0;
}

/**
 * Returns a new object with key values from source based on the keys.
 * `null` or `undefined` values are not copied.
 * @private
 * @param {object} source The object to pick values from.
 * @param {...string} keys One or more keys to copy from source.
 * @return {object} A new object with the required keys and values.
 */

function pickOnlyExistingValues(source, ...keys) {
  let result = {};
  if (source) {
    keys.forEach((key) => {
      if (source[key] != null) {
        result[key] = source[key];
      }
    });
  }
  return result;
}

/**
 * Returns a JSON array as String.
 * Yields the array before it is converted to JSON format
 * @private
 * @param {object|String|Array<object>} data
 * @param {function(*):*} [modifier] called with the array before the array is stringified
 * @return {String|null} a JSON array string or `null` if data is `null`
 */

function jsonArrayParam(data, modifier) {
  if (!data) {
    return null;
  }
  if (isString(data)) {
    data = JSON.parse(data);
  }
  if (!isArray(data)) {
    data = [data];
  }
  if (isFunction(modifier)) {
    data = modifier(data);
  }
  return JSON.stringify(data);
}

/**
 * Empty function - do nothing
 *
 */
exports.NOP = function () {
};
exports.generate_auth_token = generate_auth_token;
exports.getUserAgent = getUserAgent;
exports.build_upload_params = build_upload_params;
exports.build_multi_and_sprite_params = build_multi_and_sprite_params;
exports.api_download_url = api_download_url;
exports.timestamp = () => Math.floor(new Date().getTime() / 1000);
exports.option_consume = consumeOption; // for backwards compatibility
exports.build_array = toArray; // for backwards compatibility
exports.encode_double_array = encodeDoubleArray;
exports.encode_key_value = encode_key_value;
exports.encode_context = encode_context;
exports.build_eager = build_eager;
exports.build_custom_headers = build_custom_headers;
exports.generate_transformation_string = generate_transformation_string;
exports.updateable_resource_params = updateable_resource_params;
exports.extractUrlParams = extractUrlParams;
exports.extractTransformationParams = extractTransformationParams;
exports.patchFetchFormat = patchFetchFormat;
exports.url = url;
exports.video_url = video_url;
exports.video_thumbnail_url = video_thumbnail_url;
exports.api_url = api_url;
exports.random_public_id = random_public_id;
exports.signed_preloaded_image = signed_preloaded_image;
exports.api_sign_request = api_sign_request;
exports.clear_blank = clear_blank;
exports.merge = merge;
exports.sign_request = sign_request;
exports.webhook_signature = webhook_signature;
exports.verifyNotificationSignature = verifyNotificationSignature;
exports.process_request_params = process_request_params;
exports.private_download_url = private_download_url;
exports.zip_download_url = zip_download_url;
exports.download_archive_url = download_archive_url;
exports.download_zip_url = download_zip_url;
exports.cloudinary_js_config = cloudinary_js_config;
exports.v1_adapters = v1_adapters;
exports.as_safe_bool = as_safe_bool;
exports.archive_params = archive_params;
exports.build_explicit_api_params = build_explicit_api_params;
exports.generate_responsive_breakpoints_string = generate_responsive_breakpoints_string;
exports.build_streaming_profiles_param = build_streaming_profiles_param;
exports.hashToParameters = hashToParameters;
exports.present = present;
exports.only = pickOnlyExistingValues; // for backwards compatibility
exports.pickOnlyExistingValues = pickOnlyExistingValues;
exports.jsonArrayParam = jsonArrayParam;
exports.download_folder = download_folder;
exports.base_api_url_v1 = base_api_url_v1_1;
exports.base_api_url_v2 = base_api_url_v2;
exports.download_backedup_asset = download_backedup_asset;
exports.compute_hash = compute_hash;
exports.build_distribution_domain = build_distribution_domain;
exports.sort_object_by_key = sort_object_by_key;

// was exported before, so kept for backwards compatibility
exports.DEFAULT_POSTER_OPTIONS = DEFAULT_POSTER_OPTIONS;
exports.DEFAULT_VIDEO_SOURCE_TYPES = DEFAULT_VIDEO_SOURCE_TYPES;

Object.assign(module.exports, {
  normalize_expression,
  at,
  clone,
  extend,
  filter,
  includes,
  isArray,
  isEmpty,
  isNumber,
  isObject,
  isRemoteUrl,
  isString,
  isUndefined,
  keys: source => Object.keys(source),
  ensurePresenceOf
});",1
"      const getVersionsResp = await API_V2.resource(PUBLIC_ID_BACKUP_1, {versions: true});

      const firstAssetVersion = getVersionsResp.versions[0].version_id;
      const secondAssetVersion = getVersionsResp.versions[1].version_id;

      // Restore first version, ensure it's equal to the upload size
      await wait(1000)();
      const firstVerRestore = await API_V2.restore([PUBLIC_ID_BACKUP_1], {versions: [firstAssetVersion]});
      expect(firstVerRestore[PUBLIC_ID_BACKUP_1].bytes).to.eql(firstUpload.bytes);

      // Restore second version, ensure it's equal to the upload size
      await wait(1000)();
      const secondVerRestore = await API_V2.restore([PUBLIC_ID_BACKUP_1], {versions: [secondAssetVersion]});
      expect(secondVerRestore[PUBLIC_ID_BACKUP_1].bytes).to.eql(secondUpload.bytes);

      // Cleanup,
      const finalDeleteResp = await API_V2.delete_resources([PUBLIC_ID_BACKUP_1]);
      expect(finalDeleteResp).to.have.property(""deleted"");",1
"const METADATA_FIELD_VALUE = 'metadata_field_value_' + TEST_ID;
const METADATA_SAMPLE_DATA = { metadata_color: ""red"", metadata_shape: ""dodecahedron"" };
const METADATA_SAMPLE_DATA_ENCODED = ""metadata_color=red|metadata_shape=dodecahedron"";
const createTestConfig = require('../../../testUtils/createTestConfig');

const testConstants = require('../../../testUtils/testConstants');
const {shouldTestFeature, DYNAMIC_FOLDERS} = require(""../../../spechelper"");
const UPLOADER_V2 = cloudinary.v2.uploader;

const {
  TIMEOUT,
  TAGS,
  TEST_EVAL_STR,
  TEST_IMG_WIDTH
} = testConstants;

const {
  TEST_TAG,
  UPLOAD_TAGS
} = TAGS;

const SAMPLE_IMAGE_URL_1 = ""https://res.cloudinary.com/demo/image/upload/sample""
const SAMPLE_IMAGE_URL_2 = ""https://res.cloudinary.com/demo/image/upload/car""

require('jsdom-global')();

describe(""uploader"", function () {
  this.timeout(TIMEOUT.LONG);
  after(function () {
    var config = cloudinary.config(true);
    if (!(config.api_key && config.api_secret)) {
      expect().fail(""Missing key and secret. Please set CLOUDINARY_URL."");
    }
    return Q.allSettled([
      !cloudinary.config().keep_test_products ? cloudinary.v2.api.delete_resources_by_tag(TEST_TAG) : void 0,
      !cloudinary.config().keep_test_products ? cloudinary.v2.api.delete_resources_by_tag(TEST_TAG,
        {
          resource_type: ""video""
        }) : void 0
    ]);
  });
  beforeEach(function () {
    cloudinary.config(true);
    cloudinary.config(createTestConfig());
  });
  it(""should successfully upload file"", function () {
    this.timeout(TIMEOUT.LONG);
    return uploadImage().then(function (result) {
      var expected_signature;
      expect(result.width).to.eql(241);
      expect(result.height).to.eql(51);
      expected_signature = cloudinary.utils.api_sign_request({
        public_id: result.public_id,
        version: result.version
      }, cloudinary.config().api_secret);
      expect(result.signature).to.eql(expected_signature);
    });
  });
  it(""should successfully upload with metadata"", function () {
    return helper.provideMockObjects(function (mockXHR, writeSpy, requestSpy) {
      uploadImage({ metadata: METADATA_SAMPLE_DATA });
      sinon.assert.calledWith(requestSpy, sinon.match({
        method: sinon.match(""POST"")
      }));
      sinon.assert.calledWith(writeSpy, sinon.match(helper.uploadParamMatcher(""metadata"", METADATA_SAMPLE_DATA_ENCODED)));
    });
  });
  it('should upload a file with correctly encoded transformation string', () => {
    return helper.provideMockObjects(function (mockXHR, writeSpy, requestSpy) {
      const uploadResult = cloudinary.v2.uploader.upload('irrelevant', { transformation: { overlay: { text: 'test / 火' } } });
      sinon.assert.calledWith(writeSpy, sinon.match(helper.uploadParamMatcher('transformation', 'l_text:test %2F 火')));
    });
  });
  it('should upload a file with correctly encoded transformation string incl 4bytes characters', () => {
    return helper.provideMockObjects(function (mockXHR, writeSpy, requestSpy) {
      cloudinary.v2.uploader.upload('irrelevant', { transformation: { overlay: { text: 'test 𩸽 🍺' } } })
        .then((uploadResult) => {
          sinon.assert.calledWith(writeSpy, sinon.match(helper.uploadParamMatcher('transformation', 'l_text:test 𩸽 🍺')));
          expect(uploadResult).to.have.key(""created_at"");
        });
    });
  });
  it(""should successfully upload url"", function () {
    return cloudinary.v2.uploader.upload(""https://cloudinary.com/images/old_logo.png"", {
      tags: UPLOAD_TAGS
    }).then(function (result) {
      var expected_signature;
      expect(result.width).to.eql(241);
      expect(result.height).to.eql(51);
      expected_signature = cloudinary.utils.api_sign_request({
        public_id: result.public_id,
        version: result.version
      }, cloudinary.config().api_secret);
      expect(result.signature).to.eql(expected_signature);
    });
  });
  it(""should successfully override original_filename"", function () {
    return cloudinary.v2.uploader.upload(""https://cloudinary.com/images/old_logo.png"", {
      filename_override: 'overridden'
    }).then((result) => {
      expect(result.original_filename).to.eql('overridden');
    });
  });
  it(""Should upload a valid docx file as base64"", function () {
    let data = 'data:application/vnd.openxmlformats-officedocument.wordprocessingml.document;base64,UEsDBBQACAgIAI02LlAAAAAAAAAAAAAAAAASAAAAd29yZC9udW1iZXJpbmcueG1spZNNTsMwEIVPwB0i79skFSAUNe2CCjbsgAO4jpNYtT3W2Eno7XGbv1IklIZV5Izf98bj5/X2S8mg5mgF6JTEy4gEXDPIhC5S8vnxsngigXVUZ1SC5ik5cku2m7t1k+hK7Tn6fYFHaJsolpLSOZOEoWUlV9QuwXDtizmgos4vsQgVxUNlFgyUoU7shRTuGK6i6JF0GEhJhTrpEAslGIKF3J0kCeS5YLz79Aqc4ttKdsAqxbU7O4bIpe8BtC2FsT1NzaX5YtlD6r8OUSvZ72vMFLcMaePnrGRr1ABmBoFxa/3fXVsciHE0YYAnxKCY0sJPz74TRYUeMKd0XIEG76X37oZ2Ro0HGWdh5ZRG2tKb2CPF4+8u6Ix5XuqNmJTiK4JXuQqHQM5BsJKi6wFyDkECO/DsmeqaDmHOiklxviJlghZI1RhSe9PNxtFVXN5LavhIK/5He0WozBj3+zm0ixcYP9wGWPWAcPMNUEsHCEkTQ39oAQAAPQUAAFBLAwQUAAgICACNNi5QAAAAAAAAAAAAAAAAEQAAAHdvcmQvc2V0dGluZ3MueG1spZXNbtswDMefYO8Q6J74o0k2GHV6WLHtsJ7SPQAjybYQfUGS4+XtJ8eW1aRA4WanSH+SP9IMTT8+/RV8caLGMiVLlK1StKASK8JkXaI/rz+W39DCOpAEuJK0RGdq0dPuy2NXWOqc97ILT5C2ELhEjXO6SBKLGyrArpSm0hsrZQQ4fzV1IsAcW73ESmhw7MA4c+ckT9MtGjGqRK2RxYhYCoaNsqpyfUihqophOv6ECDMn7xDyrHArqHSXjImh3NegpG2YtoEm7qV5YxMgp48e4iR48Ov0nGzEQOcbLfiQqFOGaKMwtdarz4NxImbpjAb2iCliTgnXOUMlApicMP1w3ICm3Cufe2zaBRUfJPbC8jmFDKbf7GDAnN9XAXf08228ZrOm+Ibgo1xrpoG8B4EbMC4A+D0ErvCRku8gTzANM6lnjfMNiTCoDYg4pPZT/2yW3ozLvgFNI63+P9pPo1odx319D+3NG5htPgfIA2DnVyChFbTcvcJh75RedMUJ/BR/zVOU9OZhy8XTftiYwS/bIH+UIPybc7UQXxShvak1bH5xfcrkKic3+z6IvoDWQ9pDnZWIs7pxWc93/kb8Qr5cDnU+2vKLLR9slwtg7Pec9x4PUcuD9sbvIWgPUVsHbR21TdA2UdsGbdtrzVlTw5k8+jaEY69XinPVUfIr2t9JYz/CV2r3D1BLBwiOs8OkBQIAAOoGAABQSwMEFAAICAgAjTYuUAAAAAAAAAAAAAAAABIAAAB3b3JkL2ZvbnRUYWJsZS54bWyllE1OwzAQhU/AHSLv26QIEIqaVAgEG3bAAQbHSazaHmvsNPT2uDQ/UCSUhlWUjN/3xuMXrzcfWkU7QU6iydhqmbBIGI6FNFXG3l4fF7csch5MAQqNyNheOLbJL9ZtWqLxLgpy41LNM1Z7b9M4drwWGtwSrTChWCJp8OGVqlgDbRu74KgtePkulfT7+DJJbliHwYw1ZNIOsdCSEzos/UGSYllKLrpHr6ApvkfJA/JGC+O/HGMSKvSAxtXSup6m59JCse4hu782sdOqX9faKW4FQRvOQqujUYtUWEIunAtfH47FgbhKJgzwgBgUU1r46dl3okGaAXNIxglo8F4G725oX6hxI+MsnJrSyLH0LN8JaP+7C5gxz+96Kyel+IQQVL6hIZBzELwG8j1AzSEo5FtR3IPZwRDmopoU5xNSIaEi0GNI3Vknu0pO4vJSgxUjrfof7YmwsWPcr+bQvv2Bq+vzAJc9IO/uv6hNDegQ/juSoFicr+PuYsw/AVBLBwith20AeQEAAFoFAABQSwMEFAAICAgAjTYuUAAAAAAAAAAAAAAAAA8AAAB3b3JkL3N0eWxlcy54bWzVlt1u2jAUx59g74By3yYkgSFUWnWt2k2qumrtrqeDY4hVx7ZsB8qefs43JKFKAxIdXICPff7n+Ofjj4urt4gOVlgqwtnMGp471gAzxAPCljPr98vd2cQaKA0sAMoZnlkbrKyryy8X66nSG4rVwPgzNY3QzAq1FlPbVijEEahzLjAznQsuI9CmKZd2BPI1FmeIRwI0mRNK9MZ2HWds5TJ8ZsWSTXOJs4ggyRVf6MRlyhcLgnD+U3jILnEzl1uO4ggznUa0JaYmB85USIQq1KK+aqYzLERW701iFdFi3Fp0iRZIWJvFiGgWaM1lICRHWCljvc06S8Wh0wFgIlF6dElhN2aRSQSElTJJadSEytjnJnYOLZWqJlKxULRLIlnXA5lLkJtmFtCD57a/IJ2quKZgvHQsy4LsI4FCkLoQoH0UKEevOLgBtoKymINlp3KuKQUElhKiqkjVh1Z26NTK5TkEgSu15WFq95LHoip3v4/a1g4cjj4m4BYCl+YADDi6xQuIqVZJUz7JvJm30p87zrQarKegECEz61oSMOHXU6S2GhiUvlYEtkzhNVPleDuRUn+NeQVmo7huYblRdRsFtixsmP25/5aY7Twfu56lqLdSWQGIpCqUJPva/Tq28savmBoDxJrnsiKX3RayG2jSq8JI6I0w7gJkUmIiTFTTrh/BzHpMSjKdepB5mtsoxcwgwsWMWDYoi526NuU1zCnekX5JLJ3005GDxw5R2ifxHUNyczaFw6xjMMxWaQ4KBz9Z0VsFNF74TbfZ88V5xVg8bg3JBRPzg1kgVbNXawkLjc1lOXSdJOM5NkeAmYbvOO+vbVnJVfn5TrP8MttWnfXB5u7F5n4ybN64K7Z5oezUd7HXsosz24EYvb0YvVNjnOxSdPtSRJxyWdael3wbh+Sk5ZCcHAGvvxev/7nwupOueHdwjtNPA6ffgtM/As7RXpyjT4bTPybOvVf4gTjHe3GO/1ecpCZ8ErwvRJtXReO9kFpPzHW8w/Xj9/moBdboIFjP8Vy38io7TozMc3sxO+Jrvizqthutvai9lneXt+fdVfxTl/8AUEsHCCmXCZwiAwAA4hEAAFBLAwQUAAgICACNNi5QAAAAAAAAAAAAAAAAEQAAAHdvcmQvZG9jdW1lbnQueG1spZXdbtsgFMefYO9gcd/YTrOuteL0YtGmSdsUtekDEMA2Khh0wM6ypx/4Mx9V5Wa+Qecczu/8gWNYPv6RIqgZGK7KFMWzCAWsJIryMk/Ry/bbzT0KjMUlxUKVLEUHZtDj6tNyn1BFKslKGzhCaRJJUlRYq5MwNKRgEpuZ0qx0wUyBxNaZkIcSw2ulb4iSGlu+44LbQziPojvUYVSKKiiTDnEjOQFlVGZ9SqKyjBPWDX0GTKnbpqw7yU3FEJhwGlRpCq5NT5PX0lyw6CH1e4uopejn7fWUahTw3h2HFG2hvQKqQRFmjPOu2+BAjKMJG+gRQ8YUCac1eyUS83LA+OY4Aw21Z652t2kNalzIuBdGTBHShn7yHWA4XKrAV+zncb7mk7r4jOCybAVDQ16DIAUG2wPENQShyCujX3FZ46GZaT6pnc9IlOMcsByb1HzoZOPorF2eC6zZSMv/j/YdVKXHdl9cQzv6A+PPHwPMe8DKXYE7RQ9+1ME+cTcofUpR1H2oc62ZuHRuLl1Pa5bhStg3Ihs4ccaLRGPAP+jgjRsxegN+gA2Eq2U42u8JeUPwabmO2AxWuCk19hjUlugizROQGI2JuwM0MMOgZmi1Zca6Awvi+a2fbNuUVptPM4zYFqDz57+OXbgH6O7+duGluGspjh+iB1/JT/iF/UJ2ylrlejpeLBrBVunRECyzowU8L47MgmHK3Mq+zBszU8r2ZlfhdyW3B81c0L134FO7VfY6w/7Aw/HxW/0DUEsHCMFLkk43AgAAQQcAAFBLAwQUAAgICACNNi5QAAAAAAAAAAAAAAAAHAAAAHdvcmQvX3JlbHMvZG9jdW1lbnQueG1sLnJlbHOtkk1qwzAQhU/QO4jZ17LTH0qJnE0IZFvcAyjy+IdaIyFNSn37ipQkDgTThZfviXnzzYzWmx87iG8MsXekoMhyEEjG1T21Cj6r3eMbiMiaaj04QgUjRtiUD+sPHDSnmtj1PooUQlFBx+zfpYymQ6tj5jxSemlcsJqTDK302nzpFuUqz19lmGZAeZMp9rWCsK8LENXo8T/Zrml6g1tnjhaJ77SQnGoxBerQIis4yT+zyFIYyPsMqyUZIjKn5cYrxtmZQ3haEqFxxJU+DJNVXKw5iOclIehoDxjS3FeIizUH8bLoMXgccHqKkz63lzefvPwFUEsHCJAAq+vxAAAALAMAAFBLAwQUAAgICACNNi5QAAAAAAAAAAAAAAAACwAAAF9yZWxzLy5yZWxzjc87DsIwDAbgE3CHyDtNy4AQatIFIXVF5QBR4qYRzUNJePT2ZGAAxMBo+/dnue0ediY3jMl4x6CpaiDopFfGaQbn4bjeAUlZOCVm75DBggk6vmpPOItcdtJkQiIFcYnBlHPYU5rkhFakygd0ZTL6aEUuZdQ0CHkRGummrrc0vhvAP0zSKwaxVw2QYQn4j+3H0Ug8eHm16PKPE1+JIouoMTO4+6ioerWrwgLlLf14kT8BUEsHCC1ozyKxAAAAKgEAAFBLAwQUAAgICACNNi5QAAAAAAAAAAAAAAAAFQAAAHdvcmQvdGhlbWUvdGhlbWUxLnhtbO1ZS2/bNhy/D9h3IHRvZdlW6gR1itix261NGyRuhx5piZbYUKJA0kl8G9rjgAHDumGHFdhth2FbgRbYpfs02TpsHdCvsL8elimbzqNNtw6tDzZJ/f7vB0n58pXDiKF9IiTlcdtyLtYsRGKP+zQO2tbtQf9Cy0JS4djHjMekbU2ItK6sf/jBZbymQhIRBPSxXMNtK1QqWbNt6cEylhd5QmJ4NuIiwgqmIrB9gQ+Ab8Tseq22YkeYxhaKcQRsb41G1CNokLK01qfMewy+YiXTBY+JXS+TqFNkWH/PSX/kRHaZQPuYtS2Q4/ODATlUFmJYKnjQtmrZx7LXL9slEVNLaDW6fvYp6AoCf6+e0YlgWBI6/ebqpc2Sfz3nv4jr9XrdnlPyywDY88BSZwHb7LeczpSnBsqHi7y7NbfWrOI1/o0F/Gqn03FXK/jGDN9cwLdqK82NegXfnOHdRf07G93uSgXvzvArC/j+pdWVZhWfgUJG470FdBrPMjIlZMTZNSO8BfDWNAFmKFvLrpw+VstyLcL3uOgDIAsuVjRGapKQEfYA18WMDgVNBeA1grUn+ZInF5ZSWUh6giaqbX2cYKiIGeTlsx9fPnuCju4/Pbr/y9GDB0f3fzZQXcNxoFO9+P6Lvx99iv568t2Lh1+Z8VLH//7TZ7/9+qUZqHTg868f//H08fNvPv/zh4cG+IbAQx0+oBGR6CY5QDs8AsMMAshQnI1iEGKqU2zEgcQxTmkM6J4KK+ibE8ywAdchVQ/eEdACTMCr43sVhXdDMVbUALweRhXgFuesw4XRpuupLN0L4zgwCxdjHbeD8b5Jdncuvr1xArlMTSy7Iamouc0g5DggMVEofcb3CDGQ3aW04tct6gku+UihuxR1MDW6ZECHykx0jUYQl4lJQYh3xTdbd1CHMxP7TbJfRUJVYGZiSVjFjVfxWOHIqDGOmI68gVVoUnJ3IryKw6WCSAeEcdTziZQmmltiUlH3OrQOc9i32CSqIoWieybkDcy5jtzke90QR4lRZxqHOvYjuQcpitE2V0YleLVC0jnEAcdLw32HEnW22r5Ng9CcIOmTsTCVBOHVepywESZx0eErvTqi8XGNO4K+jc+7cUOrfP7to/9Ry94AJ5hqZr5RL8PNt+cuFz59+7vzJh7H2wQK4n1zft+c38XmvKyez78lz7qwrR+0MzbR0lP3iDK2qyaM3JBZ/5Zgnt+HxWySEZWH/CSEYSGuggsEzsZIcPUJVeFuiBMQ42QSAlmwDiRKuISrhbWUd3Y/pWBztuZOL5WAxmqL+/lyQ79slmyyWSB1QY2UwWmFNS69njAnB55SmuOapbnHSrM1b0LdIJy+SnBW6rloSBTMiJ/6PWcwDcsbDJFT02IUYp8YljX7nMYb8aZ7JiXOx8m1BSfbi9XE4uoMHbStVbfuWsjDSdsawWkJhlEC/GTaaTAL4rblqdzAk2txzuJVc1Y5NXeZwRURiZBqE8swp8oeTV+lxDP9624z9cP5GGBoJqfTotFy/kMt7PnQktGIeGrJymxaPONjRcRu6B+gIRuLHQx6N/Ps8qmETl+fTgTkdrNIvGrhFrUx/8qmqBnMkhAX2d7SYp/Ds3GpQzbT1LOX6P6KpjTO0RT33TUlzVw4nzb87NIEu7jAKM3RtsWFCjl0oSSkXl/Avp/JAr0QlEWqEmLpC+hUV7I/61s5j7zJBaHaoQESFDqdCgUh26qw8wRmTl3fHqeMij5TqiuT/HdI9gkbpNW7ktpvoXDaTQpHZLj5oNmm6hoG/bf44NJ8pY1nJqh5ls2vqTV9bStYfT0VTrMBa+LqZovr7tKdZ36rTeCWgdIvaNxUeGx2PB3wHYg+Kvd5BIl4oVWUX7k4BJ1bmnEpq3/rFNRaEu/zPDtqzm4scfbx4l7d2a7B1+7xrrYXS9TW7iHZbOGPKD68B7I34XozZvmKTGCWD7ZFZvCQ+5NiyGTeEnJHTFs6i3fICFH/cBrWOY8W//SUm/lOLiC1vSRsnExY4GebSElcP5m4pJje8Uri7BZnYsBmknN8HuWyRZaeYvHruOwUyptdZsze07rsFIF6BZepw+NdVnjKNiUeOVQCd6d/XUH+2rOUXf8HUEsHCCFaooQsBgAA2x0AAFBLAwQUAAgICACNNi5QAAAAAAAAAAAAAAAAEwAAAFtDb250ZW50X1R5cGVzXS54bWy1k01uwjAQhU/QO0TeVsTQRVVVBBb9WbZd0AMMzgSs+k+egcLtOwmQBQKplZqNZfvNvPd5JE/nO++KLWayMVRqUo5VgcHE2oZVpT4Xr6MHVRBDqMHFgJXaI6n57Ga62CekQpoDVWrNnB61JrNGD1TGhEGUJmYPLMe80gnMF6xQ343H99rEwBh4xK2Hmk2fsYGN4+LpcN9aVwpSctYAC5cWM1W87EQ8YLZn/Yu+bajPYEZHkDKj62pobRPdngeISm3Cu0wm2xr/FBGbxhqso9l4aSm/Y65TjgaJZKjelYTMsjumfkDmN/Biq9tKfVLL4yOHQeC9w2sAnTZofCNeC1g6vEzQy4NChI1fYpb9ZYheHhSiVzzYcBmkL/lHDpaPemX4nXRYJ6dI3f322Q9QSwcIM68PtywBAAAtBAAAUEsBAhQAFAAICAgAjTYuUEkTQ39oAQAAPQUAABIAAAAAAAAAAAAAAAAAAAAAAHdvcmQvbnVtYmVyaW5nLnhtbFBLAQIUABQACAgIAI02LlCOs8OkBQIAAOoGAAARAAAAAAAAAAAAAAAAAKgBAAB3b3JkL3NldHRpbmdzLnhtbFBLAQIUABQACAgIAI02LlCth20AeQEAAFoFAAASAAAAAAAAAAAAAAAAAOwDAAB3b3JkL2ZvbnRUYWJsZS54bWxQSwECFAAUAAgICACNNi5QKZcJnCIDAADiEQAADwAAAAAAAAAAAAAAAAClBQAAd29yZC9zdHlsZXMueG1sUEsBAhQAFAAICAgAjTYuUMFLkk43AgAAQQcAABEAAAAAAAAAAAAAAAAABAkAAHdvcmQvZG9jdW1lbnQueG1sUEsBAhQAFAAICAgAjTYuUJAAq+vxAAAALAMAABwAAAAAAAAAAAAAAAAAegsAAHdvcmQvX3JlbHMvZG9jdW1lbnQueG1sLnJlbHNQSwECFAAUAAgICACNNi5QLWjPIrEAAAAqAQAACwAAAAAAAAAAAAAAAAC1DAAAX3JlbHMvLnJlbHNQSwECFAAUAAgICACNNi5QIVqihCwGAADbHQAAFQAAAAAAAAAAAAAAAACfDQAAd29yZC90aGVtZS90aGVtZTEueG1sUEsBAhQAFAAICAgAjTYuUDOvD7csAQAALQQAABMAAAAAAAAAAAAAAAAADhQAAFtDb250ZW50X1R5cGVzXS54bWxQSwUGAAAAAAkACQBCAgAAexUAAAAA';

    return cloudinary.v2.uploader.upload(data, {
      resource_type: 'auto', // this defaults to 'image' if not specified
      tags: UPLOAD_TAGS
    });
  });
  it('should allow upload with url safe base64 in overlay', function () {
    const overlayUrl = 'https://res.cloudinary.com/demo/image/upload/logos/cloudinary_full_logo_white_small.png';
    const baseImageUrl ='https://cloudinary.com/images/old_logo.png';

    const options = {transformation: {overlay: { url: overlayUrl }}};
    return cloudinary.v2.uploader.upload(baseImageUrl, options)
      .then((result) => {
        expect(result).to.have.key(""created_at"");
      });
  });
  describe(""remote urls "", function () {
    const mocked = helper.mockTest();
    it(""should send s3:// URLs to server"", function () {
      cloudinary.v2.uploader.upload(""s3://test/1.jpg"", {
        tags: UPLOAD_TAGS
      });
      sinon.assert.calledWith(mocked.write, sinon.match(helper.uploadParamMatcher('file', ""s3://test/1.jpg"")));
    });
    it(""should send gs:// URLs to server"", function () {
      cloudinary.v2.uploader.upload(""gs://test/1.jpg"", {
        tags: UPLOAD_TAGS
      });
      sinon.assert.calledWith(mocked.write, sinon.match(helper.uploadParamMatcher('file', ""gs://test/1.jpg"")));
    });
    it(""should send ftp:// URLs to server"", function () {
      cloudinary.v2.uploader.upload(""ftp://example.com/1.jpg"", {
        tags: UPLOAD_TAGS
      });
      sinon.assert.calledWith(mocked.write, sinon.match(helper.uploadParamMatcher('file', ""ftp://example.com/1.jpg"")));
    });
  });
  describe(""rename"", function () {
    this.timeout(TIMEOUT.LONG);
    it(""should successfully rename a file"", function () {
      return uploadImage().then(function (result) {
        return cloudinary.v2.uploader.rename(result.public_id, result.public_id + ""2"").then(function () {
          return result.public_id;
        });
      }).then(function (public_id) {
        return cloudinary.v2.api.resource(public_id + ""2"");
      });
    });
    it(""should not rename to an existing public_id"", function () {
      return Promise.all([uploadImage(), uploadImage()]).then(function (results) {
        return cloudinary.v2.uploader.rename(results[0].public_id, results[1].public_id);
      }).then(function () {
        expect().fail();
      }).catch(function (error) {
        expect(error).to.be.ok();
      });
    });
    it(""should allow to rename to an existing ID, if overwrite is true"", function () {
      return Promise.all([uploadImage(), uploadImage()]).then(function (results) {
        return cloudinary.v2.uploader.rename(results[0].public_id, results[1].public_id, {
          overwrite: true
        });
      }).then(function ({ public_id }) {
        return cloudinary.v2.api.resource(public_id);
      }).then(function ({ format }) {
        expect(format).to.eql(""png"");
      });
    });
    it('should include tags in rename response if requested explicitly', async () => {
      const uploadResult = await cloudinary.v2.uploader.upload(IMAGE_FILE, { context: 'alt=Example|class=Example', tags: ['test-tag'] });

      const renameResult = await cloudinary.v2.uploader.rename(uploadResult.public_id, `${uploadResult.public_id}-renamed`, {tags: true, context: true});

      expect(renameResult).to.have.property('tags');
      expect(renameResult).to.have.property('context');
    });
    it('should include notification_url in rename response if included in the request', async () => {
      return helper.provideMockObjects(function (mockXHR, writeSpy, requestSpy) {
        const renameResult = cloudinary.v2.uploader.rename('irrelevant', 'irrelevant', { notification_url: 'https://notification-url.com' });
        sinon.assert.calledWith(writeSpy, sinon.match(helper.uploadParamMatcher('notification_url', 'https://notification-url.com')));
      });
    });
    return context("":invalidate"", function () {
      var spy, xhr;
      spy = void 0;
      xhr = void 0;
      before(function () {
        xhr = sinon.useFakeXMLHttpRequest();
        spy = sinon.spy(ClientRequest.prototype, 'write');
      });
      after(function () {
        spy.restore();
        return xhr.restore();
      });
      it(""should pass the invalidate value in rename to the server"", function () {
        cloudinary.v2.uploader.rename(""first_id"", ""second_id"", {
          invalidate: true
        });
        expect(spy.calledWith(sinon.match(function (arg) {
          return arg.toString().match(/name=""invalidate""/);
        }))).to.be.ok();
      });
    });
  });
  describe(""destroy"", function () {
    this.timeout(TIMEOUT.MEDIUM);
    it(""should delete a resource"", function () {
      var public_id;
      return uploadImage().then(function (result) {
        public_id = result.public_id;
        return cloudinary.v2.uploader.destroy(public_id);
      }).then(function (result) {
        expect(result.result).to.eql(""ok"");
        return cloudinary.v2.api.resource(public_id);
      }).then(function () {
        expect().fail();
      }).catch(function (error) {
        expect(error).to.be.ok();
      });
    });
    it('should pass notification_url', async () => {
      return helper.provideMockObjects(function (mockXHR, writeSpy, requestSpy) {
        const renameResult = cloudinary.v2.uploader.destroy('irrelevant', { notification_url: 'https://notification-url.com' });
        sinon.assert.calledWith(writeSpy, sinon.match(helper.uploadParamMatcher('notification_url', 'https://notification-url.com')));
      });
    });
  });
  it(""should support `async` option in explicit api"", function () {
    return cloudinary.v2.uploader.explicit(""sample"", {
      type: ""facebook"",
      eager: [
        {
          crop: ""scale"",
          width: ""2.0""
        }
      ],
      async: true
    }).then(function (result) {
      expect(result.status).to.eql('pending');
      expect(result.resource_type).to.eql('image');
      expect(result.type).to.eql('facebook');
      expect(result.public_id).to.eql('sample');
    });
  });
  it(""should successfully call explicit api"", function () {
    return cloudinary.v2.uploader.explicit(""sample"", {
      type: ""upload"",
      eager: [
        {
          crop: ""scale"",
          width: ""2.0""
        }
      ]
    }).then(function (result) {
      var url = cloudinary.utils.url(""sample"", {
        type: ""upload"",
        crop: ""scale"",
        width: ""2.0"",
        format: ""jpg"",
        version: result.version
      });
      expect(result.eager[0].secure_url).to.eql(url);
    });
  });
  it(""should support eager in upload"", function () {
    this.timeout(TIMEOUT.SHORT);
    return cloudinary.v2.uploader.upload(IMAGE_FILE, {
      eager: [
        {
          crop: ""scale"",
          width: ""2.0""
        }
      ],
      tags: UPLOAD_TAGS
    });
  });
  describe(""extra headers"", function () {
    it(""should support extra headers in object format e.g. {Link: \""1\""}"", function () {
      return helper.provideMockObjects(function (mockXHR, writeSpy, requestSpy) {
        cloudinary.v2.uploader.upload(IMAGE_FILE, {
          extra_headers: {
            Link: ""1""
          }
        });
        assert.ok(requestSpy.args[0][0].headers.Link);
        assert.equal(requestSpy.args[0][0].headers.Link, ""1"");
      });
    });
  });
  describe(""text images"", function () {
    it(""should successfully generate text image"", function () {
      return cloudinary.v2.uploader.text(""hello world"", {
        tags: UPLOAD_TAGS
      }).then(function (result) {
        expect(result.width).to.within(50, 70);
        expect(result.height).to.within(5, 15);
      });
    });
    var mocked = helper.mockTest();
    it(""should pass text image parameters to server"", function () {
      cloudinary.v2.uploader.text(""hello word"",
        {
          font_family: ""Arial"",
          font_size: 12,
          font_weight: ""black""
        });
      sinon.assert.calledWith(mocked.write, sinon.match(helper.uploadParamMatcher(""font_family"", ""Arial"")));
      sinon.assert.calledWith(mocked.write, sinon.match(helper.uploadParamMatcher(""font_size"", ""12"")));
      sinon.assert.calledWith(mocked.write, sinon.match(helper.uploadParamMatcher(""font_weight"", ""black"")));
    });
  });
  it(""should successfully upload stream"", function (done) {
    var file_reader, stream;
    stream = cloudinary.v2.uploader.upload_stream({
      tags: UPLOAD_TAGS
    }, function (error, result) {
      var expected_signature;
      expect(result.width).to.eql(241);
      expect(result.height).to.eql(51);
      expected_signature = cloudinary.utils.api_sign_request({
        public_id: result.public_id,
        version: result.version
      }, cloudinary.config().api_secret);
      expect(result.signature).to.eql(expected_signature);
      done();
    });
    file_reader = fs.createReadStream(IMAGE_FILE, {
      encoding: 'binary'
    });
    file_reader.on('data', function (chunk) {
      stream.write(chunk, 'binary');
    });
    file_reader.on('end', function () {
      stream.end();
    });
  });
  describe(""tags"", function () {
    this.timeout(TIMEOUT.MEDIUM);
    it(""should add tags to existing resources"", function () {
      return uploadImage().then(function (result) {
        return uploadImage().then(function (res) {
          return [result.public_id, res.public_id];
        });
      }).then(function ([firstId, secondId]) {
        return cloudinary.v2.uploader.add_tag(""tag1"", [firstId, secondId]).then(function () {
          return [firstId, secondId];
        });
      }).then(function ([firstId, secondId]) {
        return cloudinary.v2.api.resource(secondId).then(function (r1) {
          expect(r1.tags).to.contain(""tag1"");
        }).then(function () {
          return [firstId, secondId];
        });
      }).then(function ([firstId, secondId]) {
        return cloudinary.v2.uploader.remove_all_tags([firstId, secondId, 'noSuchId']).then(function (result) {
          return [firstId, secondId, result];
        });
      }).then(function ([firstId, secondId, result]) {
        expect(result.public_ids).to.contain(firstId);
        expect(result.public_ids).to.contain(secondId);
        expect(result.public_ids).to.not.contain('noSuchId');
      });
    });
    it(""should keep existing tags when adding a new tag"", function () {
      return uploadImage().then(function (result) {
        return cloudinary.v2.uploader.add_tag(""tag1"", result.public_id).then(function () {
          return result.public_id;
        });
      }).then(function (publicId) {
        return cloudinary.v2.uploader.add_tag(""tag2"", publicId).then(function () {
          return publicId;
        });
      }).then(function (publicId) {
        return cloudinary.v2.api.resource(publicId);
      }).then(function (result) {
        expect(result.tags).to.contain(""tag1"").and.contain(""tag2"");
      });
    });
    it(""should replace existing tag"", function () {
      return cloudinary.v2.uploader.upload(IMAGE_FILE, {
        tags: [""tag1"", ""tag2"", TEST_TAG]
      }).then(function (result) {
        var public_id = result.public_id;
        return cloudinary.v2.uploader.replace_tag(""tag3Å"", public_id).then(function () {
          return public_id;
        });
      }).then(function (public_id) { // TODO this also tests non ascii characters
        return cloudinary.v2.api.resource(public_id);
      }).then(function (result) {
        expect(result.tags).to.eql([""tag3Å""]);
      });
    });
  });
  describe(""context"", function () {
    this.timeout(TIMEOUT.MEDIUM);
    before(function () {
      return Q.all([uploadImage(), uploadImage()]).spread((result1, result2) => {
        this.first_id = result1.public_id;
        this.second_id = result2.public_id;
      });
    });
    it(""should add context to existing resources"", function () {
      return cloudinary.v2.uploader
        .add_context('alt=testAlt|custom=testCustom', [this.first_id, this.second_id])
        .then(() => cloudinary.v2.uploader.add_context({
          alt2: ""testAlt2"",
          custom2: ""testCustom2""
        }, [this.first_id, this.second_id]))
        .then(() => cloudinary.v2.api.resource(this.second_id))
        .then(({ context }) => {
          expect(context.custom.alt).to.equal('testAlt');
          expect(context.custom.alt2).to.equal('testAlt2');
          expect(context.custom.custom).to.equal('testCustom');
          expect(context.custom.custom2).to.equal('testCustom2');
          return cloudinary.v2.uploader.remove_all_context([this.first_id, this.second_id, 'noSuchId']);
        }).then(({ public_ids }) => {
          expect(public_ids).to.contain(this.first_id);
          expect(public_ids).to.contain(this.second_id);
          expect(public_ids).to.not.contain('noSuchId');
          return cloudinary.v2.api.resource(this.second_id);
        }).then(function ({ context }) {
          expect(context).to.be(void 0);
        });
    });
    it(""should upload with context containing reserved characters"", function () {
      var context = {
        key1: 'value1',
        key2: 'valu\e2',
        key3: 'val=u|e3',
        key4: 'val\=ue'
      };
      return cloudinary.v2.uploader.upload(IMAGE_FILE, {
        context: context
      }).then(function (result) {
        return cloudinary.v2.api.resource(result.public_id, {
          context: true
        });
      }).then(function (result) {
        expect(result.context.custom).to.eql(context);
      });
    });
  });
  it(""should support timeouts"", function () {
    // testing a 1ms timeout, nobody is that fast.
    return cloudinary.v2.uploader.upload(""https://cloudinary.com/images/old_logo.png"", {
      timeout: 1,
      tags: UPLOAD_TAGS
    }).then(function () {
      expect().fail();
    }).catch(function ({ error }) {
      expect(error.http_code).to.eql(499);
      expect(error.message).to.eql(""Request Timeout"");
    });
  });
  it(""should upload a file and base public id on the filename if use_filename is set to true"", function () {
    this.timeout(TIMEOUT.MEDIUM);
    return cloudinary.v2.uploader.upload(IMAGE_FILE, {
      use_filename: true,
      tags: UPLOAD_TAGS
    }).then(function ({ public_id }) {
      expect(public_id).to.match(/logo_[a-zA-Z0-9]{6}/);
    });
  });
  it(""should upload a file and set the filename as the public_id if use_filename is set to true and unique_filename is set to false"", function () {
    return cloudinary.v2.uploader.upload(IMAGE_FILE, {
      use_filename: true,
      unique_filename: false,
      tags: UPLOAD_TAGS
    }).then(function (result) {
      expect(result.public_id).to.eql(""logo"");
    });
  });
  describe(""allowed_formats"", function () {
    it(""should allow whitelisted formats"", function () {
      return cloudinary.v2.uploader.upload(IMAGE_FILE, {
        allowed_formats: [""png""],
        tags: UPLOAD_TAGS
      }).then(function (result) {
        expect(result.format).to.eql(""png"");
      });
    });
    it(""should prevent non whitelisted formats from being uploaded"", function () {
      return cloudinary.v2.uploader.upload(IMAGE_FILE, {
        allowed_formats: [""jpg""],
        tags: UPLOAD_TAGS
      }).then(function () {
        expect().fail();
      }).catch(function (error) {
        expect(error.http_code).to.eql(400);
      });
    });
    it(""should allow non whitelisted formats if type is specified and convert to that type"", function () {
      return cloudinary.v2.uploader.upload(IMAGE_FILE, {
        allowed_formats: [""jpg""],
        format: ""jpg"",
        tags: UPLOAD_TAGS
      }).then(function (result) {
        expect(result.format).to.eql(""jpg"");
      });
    });
  });
  it(""should allow sending face coordinates"", function () {
    var coordinates, custom_coordinates, different_coordinates, out_coordinates;
    this.timeout(TIMEOUT.LONG);
    coordinates = [[120, 30, 109, 150], [121, 31, 110, 151]];
    out_coordinates = [
      [120,
        30,
        109,
        51],
      [
        121,
        31,
        110,
        51 // coordinates are limited to the image dimensions
      ]
    ];
    different_coordinates = [[122, 32, 111, 152]];
    custom_coordinates = [1, 2, 3, 4];
    return cloudinary.v2.uploader.upload(IMAGE_FILE, {
      face_coordinates: coordinates,
      faces: true,
      tags: UPLOAD_TAGS
    }).then(function (result) {
      expect(result.faces).to.eql(out_coordinates);
      return cloudinary.v2.uploader.explicit(result.public_id, {
        faces: true,
        face_coordinates: different_coordinates,
        custom_coordinates: custom_coordinates,
        type: ""upload""
      });
    }).then(function (result) {
      expect(result.faces).not.to.be(void 0);
      return cloudinary.v2.api.resource(result.public_id, {
        faces: true,
        coordinates: true
      });
    }).then(function (info) {
      expect(info.faces).to.eql(different_coordinates);
      expect(info.coordinates).to.eql({
        faces: different_coordinates,
        custom: [custom_coordinates]
      });
    });
  });
  it(""should allow sending context"", function () {
    this.timeout(TIMEOUT.LONG);
    return cloudinary.v2.uploader.upload(IMAGE_FILE, {
      context: {
        caption: ""some caption"",
        alt: ""alternative""
      },
      tags: UPLOAD_TAGS
    }).then(function ({ public_id }) {
      return cloudinary.v2.api.resource(public_id, {
        context: true
      });
    }).then(function ({ context }) {
      expect(context.custom.caption).to.eql(""some caption"");
      expect(context.custom.alt).to.eql(""alternative"");
    });
  });
  it(""should support requesting manual moderation"", function () {
    this.timeout(TIMEOUT.LONG);
    return cloudinary.v2.uploader.upload(IMAGE_FILE, {
      moderation: ""manual"",
      tags: UPLOAD_TAGS
    }).then(function (result) {
      expect(result.moderation[0].status).to.eql(""pending"");
      expect(result.moderation[0].kind).to.eql(""manual"");
    });
  });
  it(""should support requesting raw conversion"", function () {
    return cloudinary.v2.uploader.upload(RAW_FILE, {
      raw_convert: ""illegal"",
      resource_type: ""raw"",
      tags: UPLOAD_TAGS
    }).then(function () {
      expect().fail();
    }).catch(function (error) {
      expect(error != null).to.be(true);
      expect(error.message).to.contain(""Raw convert is invalid"");
    });
  });
  it(""should support requesting categorization"", function () {
    return cloudinary.v2.uploader.upload(IMAGE_FILE, {
      categorization: ""illegal"",
      tags: UPLOAD_TAGS
    }).then(function () {
      expect().fail();
    }).catch(function (error) {
      expect(error != null).to.be(true);
    });
  });
  it(""should support requesting detection"", function () {
    return cloudinary.v2.uploader.upload(IMAGE_FILE, {
      detection: ""illegal"",
      tags: UPLOAD_TAGS
    }).then(function () {
      expect().fail();
    }).catch(function (error) {
      expect(error).not.to.be(void 0);
      expect(error.message).to.contain(""Detection invalid model 'illegal'"");
    });
  });
  it(""should support requesting background_removal"", function () {
    return cloudinary.v2.uploader.upload(IMAGE_FILE, {
      background_removal: ""illegal"",
      tags: UPLOAD_TAGS
    }).then(function () {
      expect().fail();
    }).catch(function (error) {
      expect(error != null).to.be(true);
      expect(error.message).to.contain(""is invalid"");
    });
  });
  it(""should support requesting analysis"", function () {
    return cloudinary.v2.uploader.upload(IMAGE_FILE, {
      quality_analysis: true,
      tags: UPLOAD_TAGS
    }).then(function (result) {
      expect(result).to.have.key(""quality_analysis"");
    });
  });

  describe('when passing visual_search in parameters', () => {
    var spy, xhr;
    spy = void 0;
    xhr = void 0;
    before(function () {
      xhr = sinon.useFakeXMLHttpRequest();
      spy = sinon.spy(ClientRequest.prototype, 'write');
    });
    after(function () {
      spy.restore();
      return xhr.restore();
    });

    it('should pass its value to the upload api', () => {
      cloudinary.v2.uploader.upload(IMAGE_FILE, {
        visual_search: true
      });

      expect(spy.calledWith(sinon.match((arg) => {
        return arg.toString().match(/visual_search=true/);
      })));
    });
  });

  describe('when passing on_success in parameters', () => {
    var spy, xhr;
    spy = void 0;
    xhr = void 0;
    before(function () {
      xhr = sinon.useFakeXMLHttpRequest();
      spy = sinon.spy(ClientRequest.prototype, 'write');
    });
    after(function () {
      spy.restore();
      return xhr.restore();
    });

    it('should pass its value to the upload api', () => {
      cloudinary.v2.uploader.upload(IMAGE_FILE, {
        on_success: 'current_asset.update({tags: [""autocaption""]});'
      });

      expect(spy.calledWith(sinon.match((arg) => {
        return arg.toString().match(/on_success='current_asset.update({tags: [""autocaption""]});'/);
      })));
    });
  });

  describe(""upload_chunked"", function () {
    this.timeout(TIMEOUT.LONG * 10);
    it(""should specify chunk size"", function (done) {
      return fs.stat(LARGE_RAW_FILE, function (err, stat) {
        cloudinary.v2.uploader.upload_large(LARGE_RAW_FILE, {
          chunk_size: 7000000,
          timeout: TIMEOUT.LONG,
          tags: UPLOAD_TAGS
        }, function (error, result) {
          if (error != null) {
            done(new Error(error.message));
          }
          expect(result.bytes).to.eql(stat.size);
          expect(result.etag).to.eql(""4c13724e950abcb13ec480e10f8541f5"");
          return done();
        });
      });
    });
    it(""should return error if value is less than 5MB"", function (done) {
      fs.stat(LARGE_RAW_FILE, function (err, stat) {
        cloudinary.v2.uploader.upload_large(LARGE_RAW_FILE, {
          chunk_size: 40000,
          tags: UPLOAD_TAGS
        }, function (error, result) {
          expect(error.message).to.eql(""All parts except EOF-chunk must be larger than 5mb"");
          done();
        });
      });
    });
    it(""should use file name"", function (done) {
      fs.stat(LARGE_RAW_FILE, function (err, stat) {
        return cloudinary.v2.uploader.upload_large(LARGE_RAW_FILE, {
          use_filename: true
        }, function (error, result) {
          if (error != null) {
            done(new Error(error.message));
          }
          expect(result.public_id).to.match(/TheCompleteWorksOfShakespeare_[a-zA-Z0-9]{6}/);
          done();
        });
      });
    });
    it(""should support uploading a small raw file"", function (done) {
      fs.stat(RAW_FILE, function (err, stat) {
        cloudinary.v2.uploader.upload_large(RAW_FILE, {
          tags: UPLOAD_TAGS
        }, function (error, result) {
          if (error != null) {
            done(new Error(error.message));
          }
          expect(result.bytes).to.eql(stat.size);
          expect(result.etag).to.eql(""ffc265d8d1296247972b4d478048e448"");
          done();
        });
      });
    });
    it(""should add original filename on upload large"", function (done) {
      fs.stat(RAW_FILE, function (err, stat) {
        cloudinary.v2.uploader.upload_large(RAW_FILE, {
          filename: 'my_file_name'
        }, function (error, result) {
          if (error != null) {
            done(new Error(error.message));
          }
          expect(result.original_filename).to.eql('my_file_name');
          done();
        });
      });
    });
    it(""should support uploading a small image file"", function (done) {
      fs.stat(IMAGE_FILE, function (err, stat) {
        return cloudinary.v2.uploader.upload_chunked(IMAGE_FILE, {
          tags: UPLOAD_TAGS
        }, function (error, result) {
          if (error != null) {
            done(new Error(error.message));
          }
          expect(result.bytes).to.eql(stat.size);
          expect(result.etag).to.eql(""7dc60722d4653261648038b579fdb89e"");
          done();
        });
      });
    });
    it(""should support uploading large video files"", function () {
      var stat, writeSpy;
      this.timeout(TIMEOUT.LONG * 10);
      writeSpy = sinon.spy(ClientRequest.prototype, 'write');
      stat = fs.statSync(LARGE_VIDEO);
      expect(stat).to.be.ok();
      return Q.denodeify(cloudinary.v2.uploader.upload_chunked)(LARGE_VIDEO, {
        chunk_size: 6000000,
        resource_type: 'video',
        timeout: TIMEOUT.LONG * 10,
        tags: UPLOAD_TAGS
      }).then(function (result) {
        var timestamps;
        expect(result.bytes).to.eql(stat.size);
        expect(result.etag).to.eql(""ff6c391d26be0837ee5229885b5bd571"");
        timestamps = writeSpy.args.map(function (a) {
          return a[0].toString();
        }).filter(function (p) {
          return p.match(/timestamp/);
        }).map(function (p) {
          return p.match(/""timestamp""\s+(\d+)/)[1];
        });
        expect(timestamps.length).to.be.greaterThan(1);
        expect(uniq(timestamps)).to.eql(uniq(timestamps)); // uniq b/c last timestamp may be duplicated
      }).finally(function () {
        writeSpy.restore();
      });
    });
    it(""should update timestamp for each chunk"", function () {
      var writeSpy = sinon.spy(ClientRequest.prototype, 'write');
      return Q.denodeify(cloudinary.v2.uploader.upload_chunked)(LARGE_VIDEO, {
        chunk_size: 6000000,
        resource_type: 'video',
        timeout: TIMEOUT.LONG * 10,
        tags: UPLOAD_TAGS
      }).then(function () {
        var timestamps = writeSpy.args.map(function (a) {
          return a[0].toString();
        }).filter(function (p) {
          return p.match(/timestamp/);
        }).map(function (p) {
          return p.match(/""timestamp""\s+(\d+)/)[1];
        });
        expect(timestamps.length).to.be.greaterThan(1);
        expect(uniq(timestamps)).to.eql(uniq(timestamps));
      }).finally(function () {
        writeSpy.restore();
      });
    });
    it(""should support uploading based on a url"", function (done) {
      this.timeout(TIMEOUT.MEDIUM);
      cloudinary.v2.uploader.upload_large(""https://cloudinary.com/images/old_logo.png"", {
        tags: UPLOAD_TAGS
      }, function (error, result) {
        if (error != null) {
          done(new Error(error.message));
        }
        expect(result.etag).to.eql(""7dc60722d4653261648038b579fdb89e"");
        done();
      });
    });
  });
  describe(""dynamic folders"", () => {
    const mocked = helper.mockTest();
    it('should pass dynamic folder params', () => {
      const public_id_prefix = ""fd_public_id_prefix"";
      const asset_folder = ""asset_folder"";
      const display_name = ""display_name"";
      const use_filename_as_display_name = true;
      const folder = ""folder/test"";
      UPLOADER_V2.upload(IMAGE_FILE, {
        public_id_prefix,
        asset_folder,
        display_name,
        use_filename_as_display_name,
        folder
      });
      sinon.assert.calledWithMatch(mocked.write, helper.uploadParamMatcher(""public_id_prefix"", public_id_prefix));
      sinon.assert.calledWithMatch(mocked.write, helper.uploadParamMatcher(""asset_folder"", asset_folder));
      sinon.assert.calledWithMatch(mocked.write, helper.uploadParamMatcher(""display_name"", display_name));
      sinon.assert.calledWithMatch(mocked.write, helper.uploadParamMatcher(""use_filename_as_display_name"", 1));
      sinon.assert.calledWithMatch(mocked.write, helper.uploadParamMatcher(""folder"", folder));
    });

    it('should not contain asset_folder in public_id', async function () {
      if (!shouldTestFeature(DYNAMIC_FOLDERS)) {
        this.skip();
      }

      const asset_folder = ""asset_folder"";
      return UPLOADER_V2.upload(IMAGE_FILE, {
        asset_folder
      }).then((result) => {
        expect(result.public_id).to.not.contain('asset_folder')
      });
    });

    it('should not contain asset_folder in public_id when use_asset_folder_as_public_id_prefix is false', async function () {
      if (!shouldTestFeature(DYNAMIC_FOLDERS)) {
        this.skip();
      }

      const asset_folder = ""asset_folder"";
      return UPLOADER_V2.upload(IMAGE_FILE, {
        asset_folder,
        use_asset_folder_as_public_id_prefix: false
      }).then((result) => {
        expect(result.public_id).to.not.contain('asset_folder')
      });
    });

    it('should contain asset_folder in public_id when use_asset_folder_as_public_id_prefix is true', async function () {
      if (!shouldTestFeature(DYNAMIC_FOLDERS)) {
        this.skip();
      }

      const asset_folder = ""asset_folder"";
      return UPLOADER_V2.upload(IMAGE_FILE, {
        asset_folder,
        use_asset_folder_as_public_id_prefix: true
      }).then((result) => {
        expect(result.public_id).to.contain('asset_folder')
      });
    });
  });
  it(""should support unsigned uploading using presets"", async function () {
    this.timeout(TIMEOUT.LONG);

    let preset = await cloudinary.v2.api.create_upload_preset({
      folder: ""upload_folder"",
      unsigned: true,
      tags: UPLOAD_TAGS
    }).catch((err) => {
      console.log(err);
      throw new Error('create_upload_preset failed');
    });

    let uploadResponse = await cloudinary.v2.uploader.unsigned_upload(IMAGE_FILE, preset.name, {
      tags: UPLOAD_TAGS
    }).catch((err) => {
      console.log(err);
      throw new Error('unsigned_upload failed');
    });

    expect(uploadResponse.public_id).to.match(/^upload_folder\/[a-z0-9]+$/);

    await cloudinary.v2.api.delete_upload_preset(preset.name).catch((err) => {
      console.log(err);
      // we don't fail the test if the delete fails
    });
  });

  it(""should reject with promise rejection if disable_promises: false"", function (done) {
    const spy = sinon.spy();

    cloudinary.v2.uploader.upload_large(EMPTY_IMAGE, { disable_promises: false }, () => {});

    function unhandledRejection() {
      spy();
    }
    process.on('unhandledRejection', unhandledRejection);

    // Promises are not disabled meaning we should throw unhandledRejection
    setTimeout(() => {
      expect(sinon.assert.called(spy));
      process.removeListener('unhandledRejection', unhandledRejection);
      done();
    }, 2000);
  });

  it(""should reject with promise rejection by default"", function (done) {
    const spy = sinon.spy();

    cloudinary.v2.uploader.upload_large(EMPTY_IMAGE, () => {});

    function unhandledRejection() {
      spy();
    }
    process.on('unhandledRejection', unhandledRejection);

    // Promises are not disabled meaning we should throw unhandledRejection
    setTimeout(() => {
      expect(sinon.assert.called(spy));
      process.removeListener('unhandledRejection', unhandledRejection);
      done();
    }, 2000);
  });

  it(""should reject without promise rejection if disable_promises: true"", function (done) {
    const spy = sinon.spy();

    cloudinary.v2.uploader.upload_large(EMPTY_IMAGE, { disable_promises: true }, () => {});

    function unhandledRejection() {
      spy();
    }
    process.on('unhandledRejection', unhandledRejection);

    // Promises are  disabled meaning unhandledRejection was not called
    setTimeout(() => {
      expect(sinon.assert.notCalled(spy));
      process.removeListener('unhandledRejection', unhandledRejection);
      done();
    }, 2000);
  });


  it(""should reject promise if error code is returned from the server"", function () {
    return cloudinary.v2.uploader.upload(EMPTY_IMAGE, {
      tags: UPLOAD_TAGS
    }).then(function () {
      expect().fail(""server should return an error when uploading an empty file"");
    }).catch(function (error) {
      expect(error.message.toLowerCase()).to.contain(""empty"");
    });
  });
  it(""should successfully upload with pipes"", function (done) {
    this.timeout(TIMEOUT.LONG);
    const upload = cloudinary.v2.uploader.upload_stream({
      tags: UPLOAD_TAGS
    }, function (error, result) {
      var expected_signature;
      expect(result.width).to.eql(241);
      expect(result.height).to.eql(51);
      expected_signature = cloudinary.utils.api_sign_request({
        public_id: result.public_id,
        version: result.version
      }, cloudinary.config().api_secret);
      expect(result.signature).to.eql(expected_signature);
      done();
    });
    fs.createReadStream(IMAGE_FILE).pipe(upload);
  });
  it(""should successfully upload in chunks with pipes"", (done) => {
    this.timeout(TIMEOUT.LONG);
    const upload = cloudinary.v2.uploader.upload_chunked_stream({
      chunk_size: 7000000,
      timeout: TIMEOUT.LONG
    }, (error, result) => {
      assert.strictEqual(error, undefined);
      assert.ok(result.public_id);
      done();
    });
    fs.createReadStream(LARGE_IMAGE_FILE).pipe(upload);
  });
  it(""should fail with http.Agent (non secure)"", function () {
    this.timeout(TIMEOUT.LONG);
    expect(cloudinary.v2.uploader.upload_stream).withArgs({
      agent: new http.Agent()
    }, function (error, result) {}).to.throwError();
  });
  it(""should successfully override https agent"", function () {
    var file_reader, upload;
    upload = cloudinary.v2.uploader.upload_stream({
      agent: new https.Agent(),
      tags: UPLOAD_TAGS
    }, function (error, result) {
      var expected_signature;
      expect(result.width).to.eql(241);
      expect(result.height).to.eql(51);
      expected_signature = cloudinary.utils.api_sign_request({
        public_id: result.public_id,
        version: result.version
      }, cloudinary.config().api_secret);
      expect(result.signature).to.eql(expected_signature);
    });
    file_reader = fs.createReadStream(IMAGE_FILE);
    file_reader.pipe(upload);
  });
  context("":responsive_breakpoints"", function () {
    context("":create_derived with different transformation settings"", function () {
      before(function () {
        helper.setupCache();
      });
      it('should return a responsive_breakpoints in the response', function () {
        return cloudinary.v2.uploader.upload(IMAGE_FILE, {
          responsive_breakpoints: [
            {
              transformation: {
                effect: ""sepia""
              },
              format: ""jpg"",
              bytes_step: 20000,
              create_derived: true,
              min_width: 200,
              max_width: 1000,
              max_images: 20
            },
            {
              transformation: {
                angle: 10
              },
              format: ""gif"",
              create_derived: true,
              bytes_step: 20000,
              min_width: 200,
              max_width: 1000,
              max_images: 20
            }
          ],
          tags: UPLOAD_TAGS
        }).then(function (result) {
          expect(result).to.have.key('responsive_breakpoints');
          expect(result.responsive_breakpoints).to.have.length(2);
          expect(at(result, ""responsive_breakpoints[0].transformation"")[0]).to.eql(""e_sepia"");
          expect(at(result, ""responsive_breakpoints[0].breakpoints[0].url"")[0]).to.match(/\.jpg$/);
          expect(at(result, ""responsive_breakpoints[1].transformation"")[0]).to.eql(""a_10"");
          expect(at(result, ""responsive_breakpoints[1].breakpoints[0].url"")[0]).to.match(/\.gif$/);
          result.responsive_breakpoints.forEach(function (bp) {
            var cached, format;
            format = path.extname(bp.breakpoints[0].url).slice(1);
            cached = cloudinary.Cache.get(result.public_id, {
              raw_transformation: bp.transformation,
              format
            });
            expect(cached).to.be.ok();
            expect(cached.length).to.be(bp.breakpoints.length);
            bp.breakpoints.forEach(function (o) {
              expect(cached).to.contain(o.width);
            });
          });
        });
      });
    });
  });
  describe(""async upload"", function () {
    var mocked = helper.mockTest();
    it(""should pass `async` value to the server"", function () {
      cloudinary.v2.uploader.upload(IMAGE_FILE, {
        async: true,
        transformation: {
          effect: ""sepia""
        }
      });
      sinon.assert.calledWith(mocked.write, sinon.match(helper.uploadParamMatcher(""async"", 1)));
    });
  });
  it(""should pass `accessibility_analysis` option to the server"", function () {
    return helper.provideMockObjects((mockXHR, writeSpy, requestSpy) => {
      cloudinary.v2.uploader.upload(IMAGE_FILE, { accessibility_analysis: true });
      return sinon.assert.calledWith(writeSpy, sinon.match(helper.uploadParamMatcher(""accessibility_analysis"", 1)));
    });
  });
  describe(""explicit"", function () {
    var spy, xhr;
    spy = void 0;
    xhr = void 0;
    before(function () {
      xhr = sinon.useFakeXMLHttpRequest();
      spy = sinon.spy(ClientRequest.prototype, 'write');
    });
    after(function () {
      spy.restore();
      xhr.restore();
    });
    describe("":invalidate"", function () {
      it(""should pass the invalidate value to the server"", function () {
        cloudinary.v2.uploader.explicit(""cloudinary"", {
          type: ""twitter_name"",
          eager: [
            {
              crop: ""scale"",
              width: ""2.0""
            }
          ],
          invalidate: true,
          quality_analysis: true,
          tags: [TEST_TAG]
        });
        sinon.assert.calledWith(spy, sinon.match(helper.uploadParamMatcher('invalidate', 1)));
        sinon.assert.calledWith(spy, sinon.match(helper.uploadParamMatcher('quality_analysis', 1)));
      });
    });
    it(""should support metadata"", function () {
      cloudinary.v2.uploader.explicit(""cloudinary"", { metadata: METADATA_SAMPLE_DATA });
      sinon.assert.calledWith(spy, sinon.match(helper.uploadParamMatcher(""metadata"", METADATA_SAMPLE_DATA_ENCODED)));
    });
    it(""should support raw_convert"", function () {
      cloudinary.v2.uploader.explicit(""cloudinary"", {
        raw_convert: ""google_speech"",
        tags: [TEST_TAG]
      });
      sinon.assert.calledWith(spy, sinon.match(helper.uploadParamMatcher('raw_convert', 'google_speech')));
    });
    it(""should pass `accessibility_analysis` to server"", function () {
      cloudinary.v2.uploader.explicit(""cloudinary"", { accessibility_analysis: true });
      sinon.assert.calledWith(spy, sinon.match(helper.uploadParamMatcher('accessibility_analysis', 1)));
    });
  });
  it(""should create an image upload tag with required properties"", function () {
    var fakeDiv, input_element, tag;
    this.timeout(TIMEOUT.LONG);
    tag = cloudinary.v2.uploader.image_upload_tag(""image_id"", {
      chunk_size: ""1234""
    });
    expect(tag).to.match(/^<input/);
    // Create an HTMLElement from the returned string to validate attributes
    fakeDiv = document.createElement('div');
    fakeDiv.innerHTML = tag;
    input_element = fakeDiv.firstChild;
    expect(input_element.tagName.toLowerCase()).to.be('input');
    expect(input_element.getAttribute(""data-url"")).to.be.ok();
    expect(input_element.getAttribute(""data-form-data"")).to.be.ok();
    expect(input_element.getAttribute(""data-cloudinary-field"")).to.match(/image_id/);
    expect(input_element.getAttribute(""data-max-chunk-size"")).to.match(/1234/);
    expect(input_element.getAttribute(""class"")).to.match(/cloudinary-fileupload/);
    expect(input_element.getAttribute(""name"")).to.be('file');
    expect(input_element.getAttribute(""type"")).to.be('file');
  });
  describe("":quality_override"", function () {
    const mocked = helper.mockTest();
    const qualityValues = [""auto:advanced"", ""auto:best"", ""80:420"", ""none""];
    function testValue(quality) {
      return it(""should pass '"" + quality + ""'"", function () {
        cloudinary.v2.uploader.upload(IMAGE_FILE, {
          ""quality_override"": quality
        });
        sinon.assert.calledWithMatch(mocked.write, helper.uploadParamMatcher(""quality_override"", quality));
      });
    }
    qualityValues.forEach(value => testValue(value));
    it(""should be supported by explicit api"", function () {
      cloudinary.v2.uploader.explicit(""cloudinary"", {
        ""quality_override"": ""auto:best""
      });
      sinon.assert.calledWithMatch(mocked.write, helper.uploadParamMatcher(""quality_override"", ""auto:best""));
    });
  });
  describe(""update_metadata"", function () {
    it(""should update metadata of existing resources"", function () {
      const metadata_fields = { metadata_color: ""red"", metadata_shape: """" };
      const public_ids = [""test_id_1"", ""test_id_2""];
      return helper.provideMockObjects(function (mockXHR, writeSpy, requestSpy) {
        cloudinary.v2.uploader.update_metadata(metadata_fields, public_ids);
        sinon.assert.calledWith(requestSpy, sinon.match({
          method: sinon.match(""POST"")
        }));
        sinon.assert.calledWith(writeSpy, sinon.match(helper.uploadParamMatcher(""metadata"", ""metadata_color=red|metadata_shape="")));
        sinon.assert.calledWith(writeSpy, sinon.match(helper.uploadParamMatcher(""public_ids[]"", public_ids[0])));
        sinon.assert.calledWith(writeSpy, sinon.match(helper.uploadParamMatcher(""public_ids[]"", public_ids[1])));
      });
    });
    it(""should support updating metadata with clear_invalid"", function () {
      const metadata_fields = { metadata_color: ""red"" };
      const public_ids = [""test_id_1""];
      return helper.provideMockObjects(function (mockXHR, writeSpy, requestSpy) {
        cloudinary.v2.uploader.update_metadata(metadata_fields, public_ids, { clear_invalid: true });
        sinon.assert.calledWith(requestSpy, sinon.match({
          method: sinon.match(""POST"")
        }));
        sinon.assert.calledWith(writeSpy, sinon.match(helper.uploadParamMatcher(""clear_invalid"", true)));
      });
    })
  });
  describe(""access_control"", function () {
    var acl, acl_string, options, requestSpy, writeSpy;
    writeSpy = void 0;
    requestSpy = void 0;
    options = void 0;
    beforeEach(function () {
      writeSpy = sinon.spy(ClientRequest.prototype, 'write');
      requestSpy = sinon.spy(http, 'request');
      options = {
        public_id: TEST_TAG,
        tags: [...UPLOAD_TAGS, 'access_control_test']
      };
    });
    afterEach(function () {
      requestSpy.restore();
      writeSpy.restore();
    });
    acl = {
      access_type: 'anonymous',
      start: new Date(Date.UTC(2019, 1, 22, 16, 20, 57)),
      end: '2019-03-22 00:00 +0200'
    };
    acl_string = '{""access_type"":""anonymous"",""start"":""2019-02-22T16:20:57.000Z"",""end"":""2019-03-22 00:00 +0200""}';
    it(""should allow the user to define ACL in the upload parameters"", function () {
      options.access_control = [acl];
      return uploadImage(options).then((resource) => {
        var response_acl;
        sinon.assert.calledWith(writeSpy, sinon.match(helper.uploadParamMatcher('access_control', `[${acl_string}]`)));
        expect(resource).to.have.key('access_control');
        response_acl = resource.access_control;
        expect(response_acl.length).to.be(1);
        expect(response_acl[0].access_type).to.be(""anonymous"");
        expect(Date.parse(response_acl[0].start)).to.be(Date.parse(acl.start));
        expect(Date.parse(response_acl[0].end)).to.be(Date.parse(acl.end));
      });
    });
  });
  describe("":ocr"", function () {
    const ocrType = ""adv_ocr"";

    it(""should support requesting ocr when uploading"", async function () {
      if (!shouldTestAddOn(ADDON_OCR)) {
        this.skip();
      }
      // Upload an image and request ocr details in the response
      const result = await UPLOADER_V2.upload(IMAGE_FILE, {ocr: ocrType, tags: [TEST_TAG]});

      // Ensure result includes properly structured ocr details
      expect(result).not.to.be.empty();
      expect(result.info).to.be.an(""object"");
      expect(result.info.ocr).to.be.an(""object"");
      expect(result.info.ocr).to.have.key(ocrType);
      expect(result.info.ocr[ocrType]).to.have.key(""status"");
      expect(result.info.ocr[ocrType]).to.have.key(""data"");
    });

    it(""should support ocr parameter in explicit"", async function () {
      if (!shouldTestAddOn(ADDON_OCR)) {
        this.skip();
      }
      // Upload an image
      const uploadResult = await UPLOADER_V2.upload(IMAGE_FILE, {
        tags: [TEST_TAG]
      });

      // Call explicit on the uploaded image with ocr parameter
      const explicitResult = await UPLOADER_V2.explicit(uploadResult.public_id, {
        ocr: ocrType,
        ""tags"": [TEST_TAG],
        type: ""upload""
      });

      // Ensure result isn't an error
      expect(explicitResult).not.to.be.empty();
      expect(explicitResult.public_id).to.eql(uploadResult.public_id);
    });
  });

  describe(""structured metadata fields"", function () {
    const metadata_fields = { [METADATA_FIELD_UNIQUE_EXTERNAL_ID]: METADATA_FIELD_VALUE };
    before(function () {
      return cloudinary.v2.api.add_metadata_field({
        external_id: METADATA_FIELD_UNIQUE_EXTERNAL_ID,
        label: METADATA_FIELD_UNIQUE_EXTERNAL_ID,
        type: ""string""
      }).finally(function () {});
    });
    after(function () {
      return cloudinary.v2.api.delete_metadata_field(METADATA_FIELD_UNIQUE_EXTERNAL_ID)
        .finally(function () {});
    });
    it(""should be set when calling upload with metadata"", function () {
      return uploadImage({
        tags: UPLOAD_TAGS,
        metadata: metadata_fields
      }).then((result) => {
        expect(result.metadata[METADATA_FIELD_UNIQUE_EXTERNAL_ID]).to.eql(METADATA_FIELD_VALUE);
      });
    });
    it(""should be set when calling explicit with metadata"", function () {
      return uploadImage({
        tags: UPLOAD_TAGS
      })
        .then(result => cloudinary.v2.uploader.explicit(result.public_id, {
          type: ""upload"",
          metadata: metadata_fields
        }))
        .then((result) => {
          expect(result.metadata[METADATA_FIELD_UNIQUE_EXTERNAL_ID]).to.eql(METADATA_FIELD_VALUE);
        });
    });
    it('should allow passing both string and a number for a number smd field', () => {
      const smdNumberField = 'smd_number_field';
      cloudinary.v2.api.add_metadata_field({
        external_id: smdNumberField,
        label: smdNumberField,
        type: 'number'
      }).then(() => {
        return Promise.all([
          uploadImage({
            tags: UPLOAD_TAGS,
            metadata: {
              [smdNumberField]: 123
            }
          }),
          uploadImage({
            tags: UPLOAD_TAGS,
            metadata: {
              [smdNumberField]: '123'
            }
          })
        ]);
      }).then(([firstUpload, secondUpload]) => {
        expect(firstUpload.metadata[smdNumberField]).to.eql(123);
        expect(secondUpload.metadata[smdNumberField]).to.eql(123);
      });
    });
    it(""should be updatable with uploader.update_metadata on an existing resource"", function () {
      let publicId;
      return uploadImage({
        tags: UPLOAD_TAGS
      })
        .then((result) => {
          publicId = result.public_id;
          return cloudinary.v2.uploader.update_metadata(metadata_fields, [publicId]);
        })
        .then((result) => {
          expect(result).not.to.be.empty();
          expect(result.public_ids.length).to.eql(1);
          expect(result.public_ids).to.contain(publicId);
        });
    });
    it(""should be updatable with uploader.update_metadata on multiple existing resources"", function () {
      let resource_1;
      let resource_2;

      return Q.allSettled(
        [
          uploadImage({
            tags: UPLOAD_TAGS
          }),
          uploadImage({
            tags: UPLOAD_TAGS
          })
        ]
      ).then(function ([result_1, result_2]) {
        resource_1 = result_1.value;
        resource_2 = result_2.value;
        return cloudinary.v2.uploader.update_metadata(metadata_fields, [resource_1.public_id, resource_2.public_id]);
      })
        .then((result) => {
          expect(result.public_ids.length).to.eql(2);
          expect(result.public_ids).to.contain(resource_1.public_id);
          expect(result.public_ids).to.contain(resource_2.public_id);
        });
    });
  });

  it('should add the eval parameter to an uploaded asset', async () => {
    const result = await UPLOADER_V2.upload(IMAGE_FILE, {
      tags: [TEST_TAG],
      eval: TEST_EVAL_STR
    });

    expect(result).not.to.be.empty();
    expect(result.context).to.be.an(""object"");
    expect(result.context.custom).to.be.an(""object"");
    expect(result.context.custom.width).to.eql(TEST_IMG_WIDTH);
    expect(result.quality_analysis).to.be.an(""object"");
    expect(result.quality_analysis.focus).to.be.an(""number"");
  });

  describe(""sign requests"", function () {
    var configBck2 = void 0;
    var writeSpy;
    writeSpy = void 0;
    beforeEach(function () {
      writeSpy = sinon.spy(ClientRequest.prototype, 'write');
      configBck2 = cloneDeep(cloudinary.config());
      cloudinary.config({
        api_key: ""1234"",
        api_secret: """"
      });
    });
    afterEach(function () {
      cloudinary.config(configBck2);
      writeSpy.restore();
    });
    it(""should allow a signature and timestamp parameter on uploads"", function () {
      cloudinary.v2.uploader.upload(IMAGE_FILE, {
        public_id: 'folder/file',
        version: '1234',
        timestamp: 1569707219,
        signature: 'b77fc0b0dffbf7e74bdad36b615225fb6daff81e'
      });
      sinon.assert.calledWith(writeSpy, sinon.match(helper.uploadParamMatcher('signature', ""b77fc0b0dffbf7e74bdad36b615225fb6daff81e"")));
      sinon.assert.calledWith(writeSpy, sinon.match(helper.uploadParamMatcher('timestamp', '1569707219')));
    });
  });

  describe("":cinemagraph_analysis"", function () {
    it(""should support requesting a cinemagraph_analysis when uploading"", async function () {
      // Upload an image and request a cinemagraph analysis value in the response
      const result = await UPLOADER_V2.upload(IMAGE_FILE, {
        ""cinemagraph_analysis"": true,
        ""tags"": [TEST_TAG]
      });

      // Ensure result includes a cinemagraph_analysis with a cinemagraph_score
      expect(result).not.to.be.empty();
      expect(result.cinemagraph_analysis).to.be.an(""object"");
      expect(result.cinemagraph_analysis).to.have.property(""cinemagraph_score"");
    });

    it(""should support requesting a cinemagraph_analysis when calling explicit"", async function () {
      // Upload an image
      const uploadResult = await UPLOADER_V2.upload(IMAGE_FILE, {
        ""tags"": [TEST_TAG]
      });

      // Call explicit on the uploaded image and request a cinemagraph analysis value in the response
      const explicitResult = await UPLOADER_V2.explicit(uploadResult.public_id, {
        ""cinemagraph_analysis"": true,
        ""tags"": [TEST_TAG],
        type: ""upload""
      });

      // Ensure result includes a cinemagraph_analysis with a cinemagraph_score
      expect(explicitResult).not.to.be.empty();
      expect(explicitResult.cinemagraph_analysis).to.be.an(""object"");
      expect(explicitResult.cinemagraph_analysis).to.have.property(""cinemagraph_score"");
    });
  });
  describe(""sprite"", function () {
    const SPRITE_TEST_TAG = `SPRITE_TEST_TAG${TEST_TAG}`

    let uploaded_url_1, uploaded_url_2;

    before(async function () {
      // Upload images to be used by sprite and multi
      const uploads = await Promise.all([
        uploadImage({tags: [SPRITE_TEST_TAG, ...UPLOAD_TAGS]}),
        uploadImage({tags: [SPRITE_TEST_TAG, ...UPLOAD_TAGS]})
      ]);
      uploaded_url_1 = uploads[0].url;
      uploaded_url_2 = uploads[1].url;
    });

    it(""should generate a sprite by tag"", async function () {
      const result = await UPLOADER_V2.generate_sprite(SPRITE_TEST_TAG);
      expect(result).to.beASprite();
      expect(Object.entries(result.image_infos).length).to.eql(2);
    });
    it(""should generate a sprite by tag with raw transformation"", async function () {
      const result = await UPLOADER_V2.generate_sprite(SPRITE_TEST_TAG, {
        transformation: {raw_transformation: 'w_100'}
      });
      expect(result).to.beASprite();
      expect(result.css_url).to.contain('w_100');
    });
    it(""should generate a sprite by tag with transformation params"", async function () {
      const result = await UPLOADER_V2.generate_sprite(SPRITE_TEST_TAG, {width: 100, format: 'jpg'});
      expect(result).to.beASprite('jpg');
      expect(result.css_url).to.contain('f_jpg,w_100');
    });
    it(""should generate a sprite by URLs array"", async function () {
      const result = await UPLOADER_V2.generate_sprite({'urls': [uploaded_url_1, uploaded_url_2]});
      expect(result).to.beASprite();
      expect(Object.entries(result.image_infos).length).to.eql(2);
    });
    it(""should generate an url to download a sprite by URLs array"", function () {
      const url = UPLOADER_V2.download_generated_sprite({'urls': [SAMPLE_IMAGE_URL_1, SAMPLE_IMAGE_URL_2]});
      expect(url).to.beASignedDownloadUrl(""image/sprite"", { urls: [SAMPLE_IMAGE_URL_1, SAMPLE_IMAGE_URL_2] });
    });
    it(""should generate an url to download a sprite by tag"", async function () {
      const url = UPLOADER_V2.download_generated_sprite(SPRITE_TEST_TAG);
      expect(url).to.beASignedDownloadUrl(""image/sprite"", { tag: SPRITE_TEST_TAG });
    });
  })
  describe(""multi"", function () {
    const MULTI_TEST_TAG = `MULTI_TEST_TAG${TEST_TAG}`

    let uploaded_url_1, uploaded_url_2;

    before(async function () {
      // Upload images to be used by sprite and multi
      const uploads = await Promise.all([
        uploadImage({tags: [MULTI_TEST_TAG, ...UPLOAD_TAGS]}),
        uploadImage({tags: [MULTI_TEST_TAG, ...UPLOAD_TAGS]})
      ]);
      uploaded_url_1 = uploads[0].url;
      uploaded_url_2 = uploads[1].url;
    });

    it(""should create a pdf by tag"", async function () {
      const result = await UPLOADER_V2.multi(MULTI_TEST_TAG, {format: ""pdf""});
      expect(result).to.beAMulti();
      expect(result.url).to.match(new RegExp(`\.pdf$`));
    });
    it(""should create a gif with a transformation by tag"", async function () {
      const options = { width: 0.5, crop: ""crop"" };
      const transformation = cloudinary.utils.generate_transformation_string(Object.assign({}, options));
      const result = await UPLOADER_V2.multi(MULTI_TEST_TAG, {transformation: options });
      expect(result).to.beAMulti();
      expect(result.url).to.match(new RegExp(`/image/multi/${transformation}/.*\.gif$`));
    });
    it(""should generate a gif with a transformation by URLs array"", async function () {
      const options = { width: 0.5, crop: ""crop"" };
      const transformation = cloudinary.utils.generate_transformation_string(Object.assign({}, options));
      const result = await UPLOADER_V2.multi({ urls: [uploaded_url_1, uploaded_url_2], transformation: options});
      expect(result).to.beAMulti();
      expect(result.url).to.match(new RegExp(`/image/multi/${transformation}/.*\.gif$`));
    });
    it(""should generate a download URL for a gif by URLs array"", function () {
      const url = UPLOADER_V2.download_multi({ urls: [SAMPLE_IMAGE_URL_1, SAMPLE_IMAGE_URL_2]});
      expect(url).to.beASignedDownloadUrl(""image/multi"", { urls: [SAMPLE_IMAGE_URL_1, SAMPLE_IMAGE_URL_2] });
    });
    it(""should generate a download URL for a gif by tag"", function () {
      const url = UPLOADER_V2.download_multi(MULTI_TEST_TAG);
      expect(url).to.beASignedDownloadUrl(""image/multi"", { tag: MULTI_TEST_TAG });
    });
  });
  describe(""proxy support"", function () {
    const mocked = helper.mockTest();
    const proxy = ""https://myuser:mypass@example.com""
    it(""should support proxy for upload calls"", function () {
      cloudinary.config({api_proxy: proxy});
      UPLOADER_V2.upload(IMAGE_FILE, {""tags"": [TEST_TAG]});
      sinon.assert.calledWith(mocked.request, sinon.match(
        arg => arg.agent instanceof https.Agent
      ));
    });
    it(""should prioritize custom agent"", function () {
      cloudinary.config({api_proxy: proxy});
      const custom_agent = https.Agent()
      UPLOADER_V2.upload(IMAGE_FILE, {""tags"": [TEST_TAG], agent: custom_agent});
      sinon.assert.calledWith(mocked.request, sinon.match(
        arg => arg.agent === custom_agent
      ));
    });
    it(""should support api_proxy as options key"", function () {
      cloudinary.config({});
      UPLOADER_V2.upload(IMAGE_FILE, {""tags"": [TEST_TAG], api_proxy: proxy});
      sinon.assert.calledWith(mocked.request, sinon.match(
        arg => arg.agent instanceof https.Agent
      ));
    });
  })
});",1
"const cloudinary = require(""../../cloudinary"");
const createTestConfig = require('../testUtils/createTestConfig');

describe(""cloudinary"", function () {
  beforeEach(function () {
    cloudinary.config(createTestConfig({
      cloud_name: ""test123"",
      api_key: 'a',
      api_secret: 'b',
      responsive_width_transformation: null,
      signature_algorithm: 'sha1'
    }));
  });
  it(""should use cloud_name from config"", function () {
    var result = cloudinary.utils.url(""test"");
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/test"");
  });
  it(""should allow overriding cloud_name in options"", function () {
    var options, result;
    options = {
      cloud_name: ""test321""
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test321/image/upload/test"");
  });
  it(""should use format from options"", function () {
    var options, result;
    options = {
      format: ""jpg""
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/test.jpg"");
  });
  it(""should use default secure distribution if secure=true"", function () {
    var options, result;
    options = {
      secure: true
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/test"");
  });
  it(""should default to akamai if secure is given with private_cdn and no secure_distribution"", function () {
    var options, result;
    options = {
      secure: true,
      private_cdn: true
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://test123-res.cloudinary.com/image/upload/test"");
  });
  it(""should not add cloud_name if secure private_cdn and secure non akamai secure_distribution"", function () {
    var options, result;
    options = {
      secure: true,
      private_cdn: true,
      secure_distribution: ""something.cloudfront.net""
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://something.cloudfront.net/image/upload/test"");
  });
  it(""should not add cloud_name if private_cdn and not secure"", function () {
    var options, result;
    options = {
      private_cdn: true
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://test123-res.cloudinary.com/image/upload/test"");
  });
  it(""should use width and height from options only if crop is given"", function () {
    var options, result;
    options = {
      width: 100,
      height: 100
    };
    result = cloudinary.utils.url(""test"", options);
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/h_100,w_100/test"");
    expect(options).to.eql({
      width: 100,
      height: 100
    });
    options = {
      width: 100,
      height: 100,
      crop: ""crop""
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({
      width: 100,
      height: 100
    });
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/c_crop,h_100,w_100/test"");
  });
  it(""should not pass width and height to html in case of fit or limit crop"", function () {
    var options, result;
    options = {
      width: 100,
      height: 100,
      crop: ""limit""
    };
    result = cloudinary.utils.url(""test"", options);
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/c_limit,h_100,w_100/test"");
    expect(options).to.eql({});
    options = {
      width: 100,
      height: 100,
      crop: ""fit""
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/c_fit,h_100,w_100/test"");
  });
  it(""should not pass width and height to html in case angle was used"", function () {
    var options, result;
    options = {
      width: 100,
      height: 100,
      crop: ""scale"",
      angle: ""auto""
    };
    result = cloudinary.utils.url(""test"", options);
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/a_auto,c_scale,h_100,w_100/test"");
    expect(options).to.eql({});
  });
  it(""should use x, y, radius, opacity, prefix, gravity and quality from options"", function () {
    var options, result;
    options = {
      x: 1,
      y: 2,
      radius: 3,
      gravity: ""center"",
      quality: 0.4,
      prefix: ""a"",
      opacity: 20
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/g_center,o_20,p_a,q_0.4,r_3,x_1,y_2/test"");
  });
  describe("":gravity"", function () {
    it(""should support 'ocr_text' as a value for gravity parameter"", function () {
      const options = {
        gravity: ""ocr_text"",
        crop: ""crop"",
        width: 0.5
      };
      const result = cloudinary.utils.url(""test"", options);
      expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/c_crop,g_ocr_text,w_0.5/test"");
      expect(options).to.eql({});
    });
    it(""should support 'auto:ocr_text' as a value for gravity parameter"", function () {
      const options = {
        gravity: ""auto:ocr_text"",
        crop: ""crop"",
        width: 0.5
      };
      const result = cloudinary.utils.url(""test"", options);
      expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/c_crop,g_auto:ocr_text,w_0.5/test"");
      expect(options).to.eql({});
    });
  });
  describe("":quality"", function () {
    var upload_path = ""https://res.cloudinary.com/test123/image/upload"";
    it(""support a percent value"", function () {
      expect(cloudinary.utils.url(""test"", {
        x: 1,
        y: 2,
        radius: 3,
        gravity: ""center"",
        quality: 80,
        prefix: ""a""
      })).to.eql(`${upload_path}/g_center,p_a,q_80,r_3,x_1,y_2/test`);
      expect(cloudinary.utils.url(""test"", {
        x: 1,
        y: 2,
        radius: 3,
        gravity: ""center"",
        quality: ""80:444"",
        prefix: ""a""
      })).to.eql(`${upload_path}/g_center,p_a,q_80:444,r_3,x_1,y_2/test`);
    });
    it(""should support auto value"", function () {
      expect(cloudinary.utils.url(""test"", {
        x: 1,
        y: 2,
        radius: 3,
        gravity: ""center"",
        quality: ""auto"",
        prefix: ""a""
      })).to.eql(`${upload_path}/g_center,p_a,q_auto,r_3,x_1,y_2/test`);
      expect(cloudinary.utils.url(""test"", {
        x: 1,
        y: 2,
        radius: 3,
        gravity: ""center"",
        quality: ""auto:good"",
        prefix: ""a""
      })).to.eql(`${upload_path}/g_center,p_a,q_auto:good,r_3,x_1,y_2/test`);
    });
  });
  describe("":radius"", function() {
    const upload_path = 'https://res.cloudinary.com/test123/image/upload';
    it(""should support a single value"", function() {
      expect(cloudinary.utils.url(""test"", {
        radius: 10
      })).to.eql(`${upload_path}/r_10/test`);
      expect(cloudinary.utils.url(""test"", {
        radius: '10'
      })).to.eql(`${upload_path}/r_10/test`);
      expect(cloudinary.utils.url(""test"", {
        variables: [['$v', 10]],
        radius: '$v'
      })).to.eql(`${upload_path}/$v_10,r_$v/test`);
    });
    it(""should support an array of values"", function() {
      expect(cloudinary.utils.url(""test"", {
        radius: [10, 20, 30]
      })).to.eql(`${upload_path}/r_10:20:30/test`);
      expect(cloudinary.utils.url(""test"", {
        variables: [['$v', 10]],
        radius: [10, 20, '$v']
      })).to.eql(`${upload_path}/$v_10,r_10:20:$v/test`);
      expect(cloudinary.utils.url(""test"", {
        variables: [['$v', 10]],
        radius: [10, 20, '$v', 40]
      })).to.eql(`${upload_path}/$v_10,r_10:20:$v:40/test`);
    })
    it(""should support colon separated values"", function() {
      expect(cloudinary.utils.url(""test"", {
        radius: ""10:20""
      })).to.eql(`${upload_path}/r_10:20/test`);
      expect(cloudinary.utils.url(""test"", {
        variables: [['$v', 10]],
        radius: ""10:20:$v:40""
      })).to.eql(`${upload_path}/$v_10,r_10:20:$v:40/test`);
    })
  })
  it(""should support named transformation"", function() {
    var options, result;
    options = {
      transformation: ""blip""
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/t_blip/test"");
  });
  it(""should support array of named transformations"", function () {
    var options, result;
    options = {
      transformation: [""blip"", ""blop""]
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/t_blip.blop/test"");
  });
  it(""should support base transformation"", function () {
    var options, result;
    options = {
      transformation: {
        x: 100,
        y: 100,
        crop: ""fill""
      },
      crop: ""crop"",
      width: 100
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({
      width: 100
    });
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/c_fill,x_100,y_100/c_crop,w_100/test"");
  });
  it(""should support array of base transformations"", function () {
    var options, result;
    options = {
      transformation: [
        {
          x: 100,
          y: 100,
          width: 200,
          crop: ""fill""
        },
        {
          radius: 10
        }
      ],
      crop: ""crop"",
      width: 100
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({
      width: 100
    });
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/c_fill,w_200,x_100,y_100/r_10/c_crop,w_100/test"");
  });
  it(""should not include empty transformations"", function () {
    var options, result;
    options = {
      transformation: [
        {},
        {
          x: 100,
          y: 100,
          crop: ""fill""
        },
        {}
      ]
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/c_fill,x_100,y_100/test"");
  });
  it(""should support size"", function () {
    var options, result;
    options = {
      size: ""10x10"",
      crop: ""crop""
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({
      width: ""10"",
      height: ""10""
    });
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/c_crop,h_10,w_10/test"");
  });
  it(""should use type from options"", function () {
    var options, result;
    options = {
      type: ""facebook""
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/facebook/test"");
  });
  it(""should use resource_type from options"", function () {
    var options, result;
    options = {
      resource_type: ""raw""
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/raw/upload/test"");
  });
  it(""should ignore http links only if type is not given "", function () {
    var options, result;
    options = {
      type: null
    };
    result = cloudinary.utils.url(""https://example.com/"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://example.com/"");
    options = {
      type: ""fetch""
    };
    result = cloudinary.utils.url(""https://example.com/"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/fetch/https://example.com/"");
  });
  it(""should escape fetch urls"", function () {
    var options, result;
    options = {
      type: ""fetch""
    };
    result = cloudinary.utils.url(""https://blah.com/hello?a=b"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/fetch/https://blah.com/hello%3Fa%3Db"");
  });
  it(""should escape http urls"", function () {
    var options, result;
    options = {
      type: ""youtube""
    };
    result = cloudinary.utils.url(""https://www.youtube.com/watch?v=d9NF2edxy-M"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/youtube/https://www.youtube.com/watch%3Fv%3Dd9NF2edxy-M"");
  });
  it(""should support background"", function () {
    var options, result;
    options = {
      background: ""red""
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/b_red/test"");
    options = {
      background: ""#112233""
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/b_rgb:112233/test"");
  });
  it(""should support default_image"", function () {
    var options, result;
    options = {
      default_image: ""default""
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/d_default/test"");
  });
  it(""should support angle"", function () {
    var options, result;
    options = {
      angle: 12
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/a_12/test"");
  });
  it(""should support format for fetch urls"", function () {
    var options, result;
    options = {
      format: ""jpg"",
      type: ""fetch""
    };
    result = cloudinary.utils.url(""https://cloudinary.com/images/logo.png"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/fetch/f_jpg/https://cloudinary.com/images/logo.png"");
  });
  it(""should support effect"", function () {
    var options, result;
    options = {
      effect: ""sepia""
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/e_sepia/test"");
  });
  it(""should support effect with param"", function () {
    var options, result;
    options = {
      effect: [""sepia"", 10]
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/e_sepia:10/test"");
  });
  [
    [""overlay"", ""l""],
    [""underlay"", ""u""]
  ].forEach(([layer, short]) => {
    it(`should support ${layer}`, function () {
      var result;
      let options = {};
      options[layer] = ""text:hello"";
      result = cloudinary.utils.url(""test"", options);
      expect(options).to.eql({});
      expect(result).to.eql(`https://res.cloudinary.com/test123/image/upload/${short}_text:hello/test`);
    });
    it(`should not pass width/height to html for ${layer}`, function () {
      var options, result;
      options = {
        height: 100,
        width: 100
      };
      options[layer] = ""text:hello"";
      result = cloudinary.utils.url(""test"", options);
      expect(options).to.eql({});
      expect(result).to.eql(`https://res.cloudinary.com/test123/image/upload/h_100,${short}_text:hello,w_100/test`);
    });
  });
  it(""should correctly sign api requests"", function () {
    expect(cloudinary.utils.api_sign_request({
      hello: null,
      goodbye: 12,
      world: ""problem"",
      undef: void 0
    }, ""1234"")).to.eql(""f05cfe85cee78e7e997b3c7da47ba212dcbf1ea5"");
  });
  it(""should correctly sign api requests with signature algorithm SHA1"", function () {
    cloudinary.config({ signature_algorithm: 'sha1' });
    expect(cloudinary.utils.api_sign_request({
      username: ""user@cloudinary.com"",
      timestamp: 1568810420,
      cloud_name: ""dn6ot3ged""
    }, ""hdcixPpR2iKERPwqvH6sHdK9cyac"")).to.eql(""14c00ba6d0dfdedbc86b316847d95b9e6cd46d94"");
  });
  it(""should correctly sign api requests with signature algorithm SHA1 as default"", function () {
    cloudinary.config({ signature_algorithm: null });
    expect(cloudinary.utils.api_sign_request({
      username: ""user@cloudinary.com"",
      timestamp: 1568810420,
      cloud_name: ""dn6ot3ged""
    }, ""hdcixPpR2iKERPwqvH6sHdK9cyac"")).to.eql(""14c00ba6d0dfdedbc86b316847d95b9e6cd46d94"");
  });
  it(""should correctly sign api requests with signature algorithm SHA256"", function () {
    cloudinary.config({ signature_algorithm: 'sha256' });
    expect(cloudinary.utils.api_sign_request({
      username: ""user@cloudinary.com"",
      timestamp: 1568810420,
      cloud_name: ""dn6ot3ged""
    }, ""hdcixPpR2iKERPwqvH6sHdK9cyac"")).to.eql(""45ddaa4fa01f0c2826f32f669d2e4514faf275fe6df053f1a150e7beae58a3bd"");
  });
  it(""should correctly build signed preloaded image"", function () {
    expect(cloudinary.utils.signed_preloaded_image({
      resource_type: ""image"",
      version: 1251251251,
      public_id: ""abcd"",
      format: ""jpg"",
      signature: ""123515adfa151""
    })).to.eql(""image/upload/v1251251251/abcd.jpg#123515adfa151"");
  });
  it('should support custom function of type wasm with a source', function () {
    var options, result;
    options = {
      custom_function: { function_type: 'wasm', source: 'blur.wasm' }
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/fn_wasm:blur.wasm/test"");
  });
  it('should support arbitrary custom function types', function () {
    var options, result;
    options = {
      custom_function: { function_type: 'amazing', source: 'awesome' }
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/fn_amazing:awesome/test"");
  });
  it('should support custom function with no source', function () {
    var options, result;
    options = {
      custom_function: { function_type: 'wasm' }
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/fn_wasm:/test"");
  });
  it('should support custom function with no function_type', function () {
    var options, result;
    options = {
      custom_function: { source: 'blur.wasm' }
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/fn_:blur.wasm/test"");
  });
  it('should support custom function that is not an object', function () {
    var options, result;
    options = {
      custom_function: []
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/fn_:/test"");
  });
  it('should support custom function with no function_type or source', function () {
    var options, result;
    options = {
      custom_function: {}
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/fn_:/test"");
  });
  it('should support custom function of type remote', function () {
    var options, result;
    options = {
      custom_function: {
        function_type: 'remote',
        source:
          'https://df34ra4a.execute-api.us-west-2.amazonaws.com/default/cloudinaryFunction'
      }
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/fn_remote:aHR0cHM6Ly9kZjM0cmE0YS5leGVjdXRlLWFwaS51cy13ZXN0LTIuYW1hem9uYXdzLmNvbS9kZWZhdWx0L2Nsb3VkaW5hcnlGdW5jdGlvbg/test"");
  });
  it('should not include custom function with undefined value', function () {
    var options, result;
    options = {
      custom_function: undefined
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/test"");
  });
  it('should support custom pre function', function () {
    var options, result;
    options = {
      custom_pre_function: {
        function_type: 'remote',
        source:
          'https://df34ra4a.execute-api.us-west-2.amazonaws.com/default/cloudinaryFunction'
      }
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/fn_pre:remote:aHR0cHM6Ly9kZjM0cmE0YS5leGVjdXRlLWFwaS51cy13ZXN0LTIuYW1hem9uYXdzLmNvbS9kZWZhdWx0L2Nsb3VkaW5hcnlGdW5jdGlvbg/test"");
  });
  it('should generate url safe base64 in remote custom pre function', function () {
    var options, result;
    options = {
      custom_pre_function: {
        function_type: 'remote',
        source:
          ""https://opengraphimg.com/.netlify/functions/generate-opengraph?author=opengraphimg&title=Hey%20Chris%20this%20is%20working""
      }
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/fn_pre:remote:aHR0cHM6Ly9vcGVuZ3JhcGhpbWcuY29tLy5uZXRsaWZ5L2Z1bmN0aW9ucy9nZW5lcmF0ZS1vcGVuZ3JhcGg_YXV0aG9yPW9wZW5ncmFwaGltZyZ0aXRsZT1IZXklMjBDaHJpcyUyMHRoaXMlMjBpcyUyMHdvcmtpbmc/test"");
  });
  it('should support custom pre function with no function_type or source', function () {
    var options, result;
    options = {
      custom_pre_function: {}
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/fn_pre::/test"");
  });
  it(""should support density"", function () {
    var options, result;
    options = {
      density: 150
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/dn_150/test"");
  });
  it(""should support page"", function () {
    var options, result;
    options = {
      page: 5
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/pg_5/test"");
  });
  it(""should support external cname"", function () {
    var options, result;
    options = {
      cname: ""hello.com"",
      secure: false
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""http://hello.com/test123/image/upload/test"");
  });
  it(""should support external cname with cdn_subdomain on"", function () {
    var options, result;
    options = {
      cname: ""hello.com"",
      cdn_subdomain: true,
      secure: false
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""http://a2.hello.com/test123/image/upload/test"");
  });
  it(""should support border"", function () {
    var options, result;
    options = {
      border: {
        width: 5
      }
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/bo_5px_solid_black/test"");
    options = {
      border: {
        width: 5,
        color: ""#ffaabbdd""
      }
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/bo_5px_solid_rgb:ffaabbdd/test"");
    options = {
      border: ""1px_solid_blue""
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/bo_1px_solid_blue/test"");
  });
  it(""should support flags"", function () {
    var options, result;
    options = {
      flags: ""abc""
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/fl_abc/test"");
    options = {
      flags: [""abc"", ""def""]
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/fl_abc.def/test"");
  });
  it(""should add version if public_id contains /"", function () {
    var result = cloudinary.utils.url(""folder/test"");
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/v1/folder/test"");
    result = cloudinary.utils.url(""folder/test"", {
      version: 123
    });
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/v123/folder/test"");
  });
  it(""should not add version if public_id contains version already"", function () {
    var result = cloudinary.utils.url(""v1234/test"");
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/v1234/test"");
  });
  it(""should allow to shorted image/upload urls"", function () {
    var result = cloudinary.utils.url(""test"", {
      shorten: true
    });
    expect(result).to.eql(""https://res.cloudinary.com/test123/iu/test"");
  });
  it(""should escape public_ids"", function () {
    const tests = [
      // [source, target]
      [""a b"", ""a%20b""],
      [""a+b"", ""a%2Bb""],
      [""a%20b"", ""a%20b""],
      [""a-b"", ""a-b""],
      [""a??b"", ""a%3F%3Fb""]
    ];
    tests.forEach(([source, target]) => {
      let result = cloudinary.utils.url(source);
      expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/"" + target);
    });
  });
  it(""should correctly sign a url"", function () {
    var actual, expected;
    expected = ""https://res.cloudinary.com/test123/image/upload/s--Ai4Znfl3--/c_crop,h_20,w_10/v1234/image.jpg"";
    actual = cloudinary.utils.url(""image.jpg"", {
      version: 1234,
      crop: ""crop"",
      width: 10,
      height: 20,
      sign_url: true
    });
    expect(actual).to.eql(expected);
    expected = ""https://res.cloudinary.com/test123/image/upload/s----SjmNDA--/v1234/image.jpg"";
    actual = cloudinary.utils.url(""image.jpg"", {
      version: 1234,
      sign_url: true
    });
    expect(actual).to.eql(expected);
    expected = ""https://res.cloudinary.com/test123/image/upload/s--Ai4Znfl3--/c_crop,h_20,w_10/image.jpg"";
    actual = cloudinary.utils.url(""image.jpg"", {
      crop: ""crop"",
      width: 10,
      height: 20,
      sign_url: true
    });
    expect(actual).to.eql(expected);
  });
  it(""should correctly sign_request"", function () {
    var params = cloudinary.utils.sign_request({
      public_id: ""folder/file"",
      version: ""1234""
    }, {
      api_key: '1234',
      api_secret: 'b'
    });
    expect(params).to.eql({
      public_id: ""folder/file"",
      version: ""1234"",
      signature: ""7a3349cbb373e4812118d625047ede50b90e7b67"",
      api_key: ""1234""
    });
  });
  it(""should correctly process_request_params"", function () {
    var params = cloudinary.utils.process_request_params({
      public_id: ""folder/file"",
      version: ""1234"",
      colors: void 0
    }, {
      api_key: '1234',
      api_secret: 'b',
      unsigned: true
    });
    expect(params).to.eql({
      public_id: ""folder/file"",
      version: ""1234""
    });
    params = cloudinary.utils.process_request_params({
      public_id: ""folder/file"",
      version: ""1234""
    }, {
      api_key: '1234',
      api_secret: 'b'
    });
    expect(params).to.eql({
      public_id: ""folder/file"",
      version: ""1234"",
      signature: ""7a3349cbb373e4812118d625047ede50b90e7b67"",
      api_key: ""1234""
    });
  });

  it(""should support preloaded identifier format"", function () {
    var result = cloudinary.utils.url(""raw/private/v123456/document.docx"");
    expect(result).to.eql(""https://res.cloudinary.com/test123/raw/private/v123456/document.docx"");
    result = cloudinary.utils.url(""image/private/v123456/img.jpg"", {
      crop: ""scale"",
      width: ""1.0""
    });
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/private/c_scale,w_1.0/v123456/img.jpg"");
  });

  it(""should add responsive width transformation"", function () {
    var options, result;
    options = {
      width: 100,
      height: 100,
      crop: ""crop"",
      responsive_width: true
    };
    result = cloudinary.utils.url(""test"", options);
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/c_crop,h_100,w_100/c_limit,w_auto/test"");
    expect(options).to.eql({
      responsive: true
    });
    cloudinary.config({
      responsive_width_transformation: {
        width: ""auto"",
        crop: ""pad""
      }
    });
    options = {
      width: 100,
      height: 100,
      crop: ""crop"",
      responsive_width: true
    };
    result = cloudinary.utils.url(""test"", options);
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/c_crop,h_100,w_100/c_pad,w_auto/test"");
    expect(options).to.eql({
      responsive: true
    });
  });
  it(""should generate urls with a 32 character signature when both sign_url and long_url_signature are true"", function () {
    var options, result;
    options = {
      sign_url: true,
      long_url_signature: true
    };
    result = cloudinary.utils.url(""sample.jpg"", options);
    expect(result).to.eql('https://res.cloudinary.com/test123/image/upload/s--2hbrSMPOjj5BJ4xV7SgFbRDevFaQNUFf--/sample.jpg');
  });
  it(""should generate urls with a 8 character signature when sign_url is true"", function () {
    var options, result;
    options = {
      sign_url: true
    };
    result = cloudinary.utils.url(""sample.jpg"", options);
    expect(result).to.eql('https://res.cloudinary.com/test123/image/upload/s--v2fTPYTu--/sample.jpg');
  });
  it(""should generate urls with signature algorithm SHA256 when sign_url is true"", function () {
    var options, result;
    options = {
      sign_url: true,
      signature_algorithm: 'sha256'
    };
    result = cloudinary.utils.url(""sample.jpg"", options);
    expect(result).to.eql('https://res.cloudinary.com/test123/image/upload/s--2hbrSMPO--/sample.jpg');
  });

  it(""should not affect user variable names containing predefined names"", function() {
    const options = { transformation: [
      {
        $mywidth: ""100"",
        $aheight: 300
      },
      {
        width: ""3 + $mywidth * 3 + 4 / 2 * initialWidth * $mywidth"",
        height: ""3 * initialHeight + $aheight"",
        crop: 'scale'
      }
    ]};
    const result = cloudinary.utils.url(""sample"", options);
    expect(result).to.contain(""$aheight_300,$mywidth_100/c_scale,h_3_mul_ih_add_$aheight,w_3_add_$mywidth_mul_3_add_4_div_2_mul_iw_mul_$mywidth"");
  });
});",1
"              },
            },
          },
        ]);
      });
    });
  });

  describe('custom download function', () => {
    it('should use custom download function to fetch URL content', async () => {
      const mockDownload = vi.fn().mockResolvedValue([
        {",1
"
  // download in parallel:
  const downloadedFiles = await download(plannedDownloads);

  return Object.fromEntries(
    downloadedFiles
      .filter(
        (
          downloadedFile,
        ): downloadedFile is {
          mediaType: string | undefined;
          data: Uint8Array;
        } => downloadedFile?.data != null,
      )
      .map(({ data, mediaType }, index) => [
        plannedDownloads[index].url.toString(),
        { data, mediaType },
      ]),
  );
}

/**
 * Convert part of a message to a LanguageModelV2Part.
 * @param part The part to convert.",1
"      res.end('Missing request body');
      return;
    }

    const {url} = req.body as {url: string};

    await open(url);

    res.writeHead(200);
    res.end();
  }
",1
"  try {
    fd = fs.openSync(file, 'r')
    const stat: fs.Stats = fs.fstatSync(fd)
    const readSize: number = opt.maxReadSize || 16 * 1024 * 1024
    if (stat.size < readSize) {
      const buf = Buffer.allocUnsafe(stat.size)
      fs.readSync(fd, buf, 0, stat.size, 0)
      p.end(buf)
    } else {
      let pos = 0
      const buf = Buffer.allocUnsafe(readSize)
      while (pos < stat.size) {
        const bytesRead = fs.readSync(fd, buf, 0, readSize, pos)
        pos += bytesRead
        p.write(buf.subarray(0, bytesRead))
      }
      p.end()
    }
  } finally {",1
"import fs, { readFileSync } from 'fs'
//@ts-ignore
import mutateFS from 'mutate-fs'
import { dirname, resolve } from 'path'
import t, { Test } from 'tap'
import { fileURLToPath } from 'url'
import { list } from '../dist/esm/list.js'
import { Parser } from '../dist/esm/parse.js'
import { ReadEntry } from '../dist/esm/read-entry.js'

const __filename = fileURLToPath(import.meta.url)
const __dirname = dirname(__filename)

const lp = JSON.parse(
  readFileSync(__dirname + '/fixtures/parse/long-paths.json', 'utf8'),
) as (
  | ['meta', string]
  | ['entry', Record<string, any>]
  | ['nullBlock' | 'eof' | 'end']
)[]

t.test('basic', t => {
  const file = resolve(__dirname, 'fixtures/tars/long-paths.tar')
  const expect = (lp as any[])
    .filter(e => Array.isArray(e) && e[0] === 'entry')
    .map((e: ['entry', Record<string, any>]) => e[1].path as string)

  const check = (actual: string[], t: Test) => {
    t.same(actual, expect)
    return Promise.resolve(null)
  }

  ;[1000, undefined].forEach(maxReadSize => {
    t.test('file maxReadSize=' + maxReadSize, t => {
      t.test('sync', t => {
        const actual: string[] = []
        const onReadEntry = (entry: ReadEntry) =>
          actual.push(entry.path)
        list({
          file: file,
          sync: true,
          onReadEntry,
          maxReadSize,
        })
        return check(actual, t)
      })

      t.test('async promise', async t => {
        const actual: string[] = []
        const onReadEntry = (entry: ReadEntry) =>
          actual.push(entry.path)
        return await list({
          file,
          onReadEntry,
          maxReadSize,
        }).then(() => check(actual, t))
      })

      t.test('async cb', t => {
        const actual: string[] = []
        const onReadEntry = (entry: ReadEntry) =>
          actual.push(entry.path)
        list(
          {
            file: file,
            onReadEntry: onReadEntry,
            maxReadSize: maxReadSize,
          },
          (er?: Error) => {
            if (er) {
              throw er
            }
            check(actual, t)
            t.end()
          },
        )
      })
      t.end()
    })
  })

  t.test('stream', t => {
    t.test('sync', t => {
      const actual: string[] = []
      const onReadEntry = (entry: ReadEntry) =>
        actual.push(entry.path)
      const l = list({ sync: true, onReadEntry })
      l.end(fs.readFileSync(file))
      return check(actual, t)
    })

    t.test('async', t => {
      const actual: string[] = []
      const onReadEntry = (entry: ReadEntry) =>
        actual.push(entry.path)
      const l = list()
      l.on('entry', onReadEntry)
      l.on('end', _ => check(actual, t).then(_ => t.end()))
      fs.createReadStream(file).pipe(l)
    })
    t.end()
  })

  t.test('no onReadEntry function', () => list({ file: file }))

  t.test('limit to specific files', t => {
    const fileList = [
      'long-path/r/e/a/l/l/y/-/d/e/e/p/-/f/o/l/d/e/r/-/p/a/t',
      '170-byte-filename-cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc///',
    ]

    const expect = [
      '170-byte-filename-cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc',
      'long-path/r/e/a/l/l/y/-/d/e/e/p/-/f/o/l/d/e/r/-/p/a/t/',
      'long-path/r/e/a/l/l/y/-/d/e/e/p/-/f/o/l/d/e/r/-/p/a/t/h/',
      'long-path/r/e/a/l/l/y/-/d/e/e/p/-/f/o/l/d/e/r/-/p/a/t/h/a.txt',
      'long-path/r/e/a/l/l/y/-/d/e/e/p/-/f/o/l/d/e/r/-/p/a/t/h/cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc',
      'long-path/r/e/a/l/l/y/-/d/e/e/p/-/f/o/l/d/e/r/-/p/a/t/h/cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc',
      'long-path/r/e/a/l/l/y/-/d/e/e/p/-/f/o/l/d/e/r/-/p/a/t/h/xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxcccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc',
      'long-path/r/e/a/l/l/y/-/d/e/e/p/-/f/o/l/d/e/r/-/p/a/t/h/Ω.txt',
    ]

    t.test('no filter function', async t => {
      const check = () => t.same(actual, expect)
      const actual: string[] = []
      return list(
        {
          file: file,
          onReadEntry: entry => actual.push(entry.path),
        },
        fileList,
      ).then(check)
    })

    t.test('no filter function, stream', t => {
      const check = () => t.same(actual, expect)
      const actual: string[] = []
      const onReadEntry = (entry: ReadEntry) =>
        actual.push(entry.path)
      fs.createReadStream(file).pipe(
        list(fileList)
          .on('entry', onReadEntry)
          .on('end', _ => {
            check()
            t.end()
          }),
      )
    })

    t.test('filter function', async t => {
      const check = () => t.same(actual, expect.slice(0, 1))
      const actual: string[] = []
      return list(
        {
          file: file,
          filter: path => path === expect[0],
          onReadEntry: entry => actual.push(entry.path),
        },
        fileList,
      ).then(check)
    })

    return t.test('list is unmunged', t => {
      t.same(fileList, [
        'long-path/r/e/a/l/l/y/-/d/e/e/p/-/f/o/l/d/e/r/-/p/a/t',
        '170-byte-filename-cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc///',
      ])
      t.end()
    })
  })

  t.end()
})

t.test('bad args', t => {
  t.throws(
    () => list({ file: __filename, sync: true }, () => {}),
    new TypeError('callback not supported for sync tar functions'),
  )
  t.throws(
    () => list({}, () => {}),
    new TypeError('callback only supported with file option'),
  )
  t.end()
})

t.test('stat fails', t => {
  const poop = new Error('poop')
  t.teardown(mutateFS.statFail(poop))
  t.test('sync', t => {
    t.plan(1)
    t.throws(() => list({ file: __filename, sync: true }), poop)
  })
  t.test('cb', t => {
    t.plan(1)
    list({ file: __filename }, er => t.equal(er, poop))
  })
  t.test('promise', t => {
    t.plan(1)
    list({ file: __filename }).catch(er => t.equal(er, poop))
  })
  t.end()
})

t.test('read fail', t => {
  t.test('sync', t => {
    const poop = new Error('poop')
    t.teardown(mutateFS.fail('read', poop))
    t.plan(1)
    t.throws(
      () =>
        list({
          file: __filename,
          sync: true,
          maxReadSize: 10,
        }),
      poop,
    )
  })
  t.test('cb', t => {
    const poop = new Error('poop')
    t.teardown(mutateFS.fail('read', poop))
    t.plan(1)
    list({ file: __filename }, er => t.equal(er, poop))
  })
  t.test('promise', t => {
    const poop = new Error('poop')
    t.teardown(mutateFS.fail('read', poop))
    t.plan(1)
    list({ file: __filename }).catch(er => t.equal(er, poop))
  })
  t.end()
})

t.test('noResume option', t => {
  const file = resolve(__dirname, 'fixtures/tars/file.tar')
  t.test('sync', t => {
    let e!: ReadEntry
    list({
      file: file,
      onReadEntry: entry => {
        e = entry
        process.nextTick(() => {
          t.notOk(entry.flowing)
          entry.resume()
        })
      },
      sync: true,
      noResume: true,
    })
    t.ok(e)
    t.notOk(e.flowing)
    e.on('end', () => t.end())
  })

  t.test('async', t =>
    list({
      file: file,
      onReadEntry: entry => {
        process.nextTick(() => {
          t.notOk(entry.flowing)
          entry.resume()
        })
      },
      noResume: true,
    }),
  )

  t.end()
})

t.test('typechecks', t => {
  const p = list()
  //@ts-expect-error
  p.then
  t.type(p, Parser)
  t.end()
})",1
"	/**
	 * Whether to disable HTML sandboxing for webhooks. The sandboxing mechanism uses CSP headers now,
	 * but the name is kept for backwards compatibility.
	 */
	@Env('N8N_INSECURE_DISABLE_WEBHOOK_IFRAME_SANDBOX')
	disableWebhookHtmlSandboxing: boolean = false;
}",1
"			restrictFileAccessTo: '',
			blockFileAccessToN8nFiles: true,
			daysAbandonedWorkflow: 90,
			contentSecurityPolicy: '{}',
			contentSecurityPolicyReportOnly: false,
			disableWebhookHtmlSandboxing: false,
		},
		executions: {
			timeout: -1,
			maxTimeout: 3600,
			pruneData: true,
			pruneDataMaxAge: 336,",1
"
	beforeEach(() => {
		// Ignore environment variables coming in from the environment when running
		// this test suite.
		process.env = {
			N8N_BLOCK_ENV_ACCESS_IN_NODE: 'false',
		};

		jest.resetAllMocks();
	});

	describe('N8N_PARTIAL_EXECUTION_VERSION_DEFAULT', () => {
		test('supports multiple warnings for the same environment variable', () => {
			// ARRANGE
			process.env.N8N_PARTIAL_EXECUTION_VERSION_DEFAULT = '1';
			const dataCaptor = captor();

			// ACT
			deprecationService.warn();

			// ASSERT
			expect(logger.warn).toHaveBeenCalledTimes(1);
			expect(logger.warn).toHaveBeenCalledWith(dataCaptor);
			expect(dataCaptor.value.split('\n')).toEqual(
				expect.arrayContaining([
					' - N8N_PARTIAL_EXECUTION_VERSION_DEFAULT -> Version 1 of partial executions is deprecated and will be removed as early as v1.85.0',
					' - N8N_PARTIAL_EXECUTION_VERSION_DEFAULT -> This environment variable is internal and should not be set.',
				]),
			);
		});
	});

	const toTest = (envVar: string, value: string | undefined, mustWarn: boolean) => {
		const originalEnv = process.env[envVar];
		try {
			// ARRANGE
			if (value) {
				process.env[envVar] = value;
			} else {
				delete process.env[envVar];
			}

			// ACT
			deprecationService.warn();

			// ASSERT
			if (mustWarn) {
				expect(logger.warn).toHaveBeenCalledTimes(1);
				expect(logger.warn.mock.lastCall?.[0]).toMatch(envVar);
			} else {
				expect(logger.warn.mock.lastCall?.[0] ?? '').not.toMatch(envVar);
			}
		} finally {
			// CLEANUP
			if (originalEnv) {
				process.env[envVar] = originalEnv;
			} else {
				delete process.env[envVar];
			}
		}
	};

	test.each([
		['N8N_BINARY_DATA_TTL', '1', true],
		['N8N_PERSISTED_BINARY_DATA_TTL', '1', true],
		['EXECUTIONS_DATA_PRUNE_TIMEOUT', '1', true],
		['N8N_CONFIG_FILES', '1', true],
		['N8N_SKIP_WEBHOOK_DEREGISTRATION_SHUTDOWN', '1', true],
		['N8N_PARTIAL_EXECUTION_VERSION_DEFAULT', '1', true],
		['N8N_PARTIAL_EXECUTION_VERSION_DEFAULT', '2', true],
		['N8N_PARTIAL_EXECUTION_VERSION_DEFAULT', undefined, false],
	])('should detect when %s is `%s`', (envVar, value, mustWarn) => {
		toTest(envVar, value, mustWarn);
	});

	test.each([
		['default', true],
		['filesystem', false],
		['s3', false],
	])('should handle N8N_BINARY_DATA_MODE as %s', (mode, mustWarn) => {
		toTest('N8N_BINARY_DATA_MODE', mode, mustWarn);
	});

	test.each([
		['sqlite', false],
		['postgresdb', false],
		['mysqldb', true],
		['mariadb', true],
	])('should handle DB_TYPE as %s', (dbType, mustWarn) => {
		toTest('DB_TYPE', dbType, mustWarn);
	});

	describe('N8N_RUNNERS_ENABLED', () => {
		const envVar = 'N8N_RUNNERS_ENABLED';

		test.each([
			['false', true],
			['', true],
			['true', false],
			[undefined /* warnIfMissing */, true],
		])('should handle value: %s', (value, mustWarn) => {
			toTest(envVar, value, mustWarn);
		});

		test('should not warn when Code node is excluded', () => {
			process.env[envVar] = 'false';

			const globalConfig = mockInstance(GlobalConfig, {
				nodes: {
					exclude: ['n8n-nodes-base.code'],
				},
			});

			new DeprecationService(logger, globalConfig, instanceSettings).warn();

			expect(logger.warn).not.toHaveBeenCalled();
		});
	});

	describe('OFFLOAD_MANUAL_EXECUTIONS_TO_WORKERS', () => {
		const envVar = 'OFFLOAD_MANUAL_EXECUTIONS_TO_WORKERS';

		beforeEach(() => {
			process.env = {
				N8N_RUNNERS_ENABLED: 'true',
				N8N_BLOCK_ENV_ACCESS_IN_NODE: 'false',
			};

			jest.spyOn(config, 'getEnv').mockImplementation((key) => {
				if (key === 'executions.mode') return 'queue';
				return undefined;
			});
		});

		describe('when executions.mode is not queue', () => {
			test.each([['main'], ['worker'], ['webhook']])(
				'should not warn for instanceType %s',
				(instanceType: InstanceType) => {
					jest.spyOn(config, 'getEnv').mockImplementation((key) => {
						if (key === 'executions.mode') return 'regular';
						return;
					});
					process.env[envVar] = 'false';
					const service = new DeprecationService(
						logger,
						globalConfig,
						mock<InstanceSettings>({ instanceType }),
					);
					service.warn();
					expect(logger.warn).not.toHaveBeenCalled();
				},
			);
		});

		describe('when executions.mode is queue', () => {
			describe('when instanceType is worker', () => {
				test.each([
					['false', 'false'],
					['empty string', ''],
				])(`should not warn when ${envVar} is %s`, (_description, envValue) => {
					process.env[envVar] = envValue;
					const service = new DeprecationService(
						logger,
						globalConfig,
						mock<InstanceSettings>({ instanceType: 'worker' }),
					);
					service.warn();
					expect(logger.warn).not.toHaveBeenCalled();
				});
			});

			describe('when instanceType is webhook', () => {
				test.each([
					['false', 'false'],
					['empty string', ''],
				])(`should not warn when ${envVar} is %s`, (_description, envValue) => {
					process.env[envVar] = envValue;
					const service = new DeprecationService(
						logger,
						globalConfig,
						mock<InstanceSettings>({ instanceType: 'webhook' }),
					);
					service.warn();
					expect(logger.warn).not.toHaveBeenCalled();
				});
			});

			describe('when instanceType is main', () => {
				test.each([
					['false', 'false'],
					['empty string', ''],
				])(`should warn when ${envVar} is %s`, (_description, envValue) => {
					process.env[envVar] = envValue;
					const service = new DeprecationService(logger, globalConfig, instanceSettings);
					service.warn();
					expect(logger.warn).toHaveBeenCalled();
				});

				test('should not warn when OFFLOAD_MANUAL_EXECUTIONS_TO_WORKERS is true', () => {
					process.env[envVar] = 'true';

					const service = new DeprecationService(logger, globalConfig, instanceSettings);
					service.warn();

					expect(logger.warn).not.toHaveBeenCalled();
				});

				test('should warn when OFFLOAD_MANUAL_EXECUTIONS_TO_WORKERS is undefined', () => {
					delete process.env[envVar];

					const service = new DeprecationService(logger, globalConfig, instanceSettings);
					service.warn();

					expect(logger.warn).toHaveBeenCalledTimes(1);
					const warningMessage = logger.warn.mock.calls[0][0];
					expect(warningMessage).toContain(envVar);
				});
			});
		});
	});

	describe('N8N_BLOCK_ENV_ACCESS_IN_NODE', () => {
		beforeEach(() => {
			process.env = {
				N8N_RUNNERS_ENABLED: 'true',
			};

			jest.resetAllMocks();
		});

		test('should warn when N8N_BLOCK_ENV_ACCESS_IN_NODE is not set', () => {
			delete process.env.N8N_BLOCK_ENV_ACCESS_IN_NODE;
			deprecationService.warn();
			expect(logger.warn).toHaveBeenCalled();
		});

		test.each(['false', 'true'])(
			'should not warn when N8N_BLOCK_ENV_ACCESS_IN_NODE is %s',
			(value) => {
				process.env.N8N_BLOCK_ENV_ACCESS_IN_NODE = value;
				deprecationService.warn();
				expect(logger.warn).not.toHaveBeenCalled();
			},
		);
	});
});",1
"		{
			envVar: 'N8N_BLOCK_ENV_ACCESS_IN_NODE',
			message:
				'The default value of N8N_BLOCK_ENV_ACCESS_IN_NODE will be changed from false to true in a future version. If you need to access environment variables from the Code Node or from expressions, please set N8N_BLOCK_ENV_ACCESS_IN_NODE=false. Learn more: https://docs.n8n.io/hosting/configuration/environment-variables/security/',
			checkValue: (value: string | undefined) => value === undefined || value === '',
		},
	];

	/** Runtime state of deprecation-related env vars. */
	private readonly state: Map<Deprecation, { mustWarn: boolean }> = new Map();

	constructor(",1
"	commitFields,
	logFields,
	pushFields,
	switchBranchFields,
	tagFields,
} from './descriptions';

export class Git implements INodeType {
	description: INodeTypeDescription = {
		displayName: 'Git',
		name: 'git',
		icon: 'file:git.svg',
		group: ['transform'],
		version: 1,
		description: 'Control git.',
		defaults: {
			name: 'Git',
		},
		usableAsTool: true,
		inputs: [NodeConnectionTypes.Main],
		outputs: [NodeConnectionTypes.Main],
		credentials: [
			{
				name: 'gitPassword',
				required: true,
				displayOptions: {
					show: {
						authentication: ['gitPassword'],
					},
				},
			},
		],
		properties: [
			{
				displayName: 'Authentication',
				name: 'authentication',
				type: 'options',
				options: [
					{
						name: 'Authenticate',
						value: 'gitPassword',
					},
					{
						name: 'None',
						value: 'none',
					},
				],
				displayOptions: {
					show: {
						operation: ['clone', 'push'],
					},
				},
				default: 'none',
				description: 'The way to authenticate',
			},
			{
				displayName: 'Operation',
				name: 'operation',
				type: 'options',
				noDataExpression: true,
				default: 'log',
				options: [
					{
						name: 'Add',
						value: 'add',
						description: 'Add a file or folder to commit',
						action: 'Add a file or folder to commit',
					},
					{
						name: 'Add Config',
						value: 'addConfig',
						description: 'Add configuration property',
						action: 'Add configuration property',
					},
					{
						name: 'Clone',
						value: 'clone',
						description: 'Clone a repository',
						action: 'Clone a repository',
					},
					{
						name: 'Commit',
						value: 'commit',
						description: 'Commit files or folders to git',
						action: 'Commit files or folders to git',
					},
					{
						name: 'Fetch',
						value: 'fetch',
						description: 'Fetch from remote repository',
						action: 'Fetch from remote repository',
					},
					{
						name: 'List Config',
						value: 'listConfig',
						description: 'Return current configuration',
						action: 'Return current configuration',
					},
					{
						name: 'Log',
						value: 'log',
						description: 'Return git commit history',
						action: 'Return git commit history',
					},
					{
						name: 'Pull',
						value: 'pull',
						description: 'Pull from remote repository',
						action: 'Pull from remote repository',
					},
					{
						name: 'Push',
						value: 'push',
						description: 'Push to remote repository',
						action: 'Push to remote repository',
					},
					{
						name: 'Push Tags',
						value: 'pushTags',
						description: 'Push Tags to remote repository',
						action: 'Push tags to remote repository',
					},
					{
						name: 'Status',
						value: 'status',
						description: 'Return status of current repository',
						action: 'Return status of current repository',
					},
					{
						name: 'Switch Branch',
						value: 'switchBranch',
						description: 'Switch to a different branch',
						action: 'Switch to a different branch',
					},
					{
						name: 'Tag',
						value: 'tag',
						description: 'Create a new tag',
						action: 'Create a new tag',
					},
					{
						name: 'User Setup',
						value: 'userSetup',
						description: 'Set the user',
						action: 'Set up a user',
					},
				],
			},

			{
				displayName: 'Repository Path',
				name: 'repositoryPath',
				type: 'string',
				displayOptions: {
					hide: {
						operation: ['clone'],
					},
				},
				default: '',
				placeholder: '/tmp/repository',
				required: true,
				description: 'Local path of the git repository to operate on',
			},
			{
				displayName: 'New Repository Path',
				name: 'repositoryPath',
				type: 'string',
				displayOptions: {
					show: {
						operation: ['clone'],
					},
				},
				default: '',
				placeholder: '/tmp/repository',
				required: true,
				description: 'Local path to which the git repository should be cloned into',
			},

			...addFields,
			...addConfigFields,
			...cloneFields,
			...commitFields,
			...logFields,
			...pushFields,
			...switchBranchFields,
			...tagFields,
			// ...userSetupFields,
		],
	};

	async execute(this: IExecuteFunctions): Promise<INodeExecutionData[][]> {
		const items = this.getInputData();

		const prepareRepository = async (repositoryPath: string): Promise<string> => {
			const authentication = this.getNodeParameter('authentication', 0) as string;

			if (authentication === 'gitPassword') {
				const gitCredentials = await this.getCredentials('gitPassword');

				const url = new URL(repositoryPath);
				url.username = gitCredentials.username as string;
				url.password = gitCredentials.password as string;

				return url.toString();
			}

			return repositoryPath;
		};

		interface CheckoutBranchOptions {
			branchName: string;
			createBranch?: boolean;
			startPoint?: string;
			force?: boolean;
			setUpstream?: boolean;
			remoteName?: string;
		}

		const checkoutBranch = async (
			git: SimpleGit,
			options: CheckoutBranchOptions,
		): Promise<void> => {
			const {
				branchName,
				createBranch = true,
				startPoint,
				force = false,
				setUpstream = false,
				remoteName = 'origin',
			} = options;
			try {
				if (force) {
					await git.checkout(['-f', branchName]);
				} else {
					await git.checkout(branchName);
				}
			} catch (error) {
				if (createBranch) {
					// Try to create the branch when checkout fails
					if (startPoint) {
						await git.checkoutBranch(branchName, startPoint);
					} else {
						await git.checkoutLocalBranch(branchName);
					}
					// If we reach here, branch creation succeeded
				} else {
					// Don't create branch, throw original error
					throw error;
				}
			}

			if (setUpstream) {
				try {
					await git.addConfig(`branch.${branchName}.remote`, remoteName);
					await git.addConfig(`branch.${branchName}.merge`, `refs/heads/${branchName}`);
				} catch (upstreamError) {
					// Upstream setup failed but that's non-fatal
				}
			}
		};

		const operation = this.getNodeParameter('operation', 0);
		const returnItems: INodeExecutionData[] = [];
		for (let itemIndex = 0; itemIndex < items.length; itemIndex++) {
			try {
				const repositoryPath = this.getNodeParameter('repositoryPath', itemIndex, '') as string;
				const options = this.getNodeParameter('options', itemIndex, {});

				if (operation === 'clone') {
					// Create repository folder if it does not exist
					try {
						await access(repositoryPath);
					} catch (error) {
						await mkdir(repositoryPath);
					}
				}

				const gitOptions: Partial<SimpleGitOptions> = {
					baseDir: repositoryPath,
				};

				const git: SimpleGit = simpleGit(gitOptions)
					// Tell git not to ask for any information via the terminal like for
					// example the username. As nobody will be able to answer it would
					// n8n keep on waiting forever.",1
"                        : true,
                dateStrings: options.dateStrings,
                debug: options.debug,
                trace: options.trace,
                multipleStatements: options.multipleStatements,
                flags: options.flags,
            },
            {
                host: credentials.host,
                user: credentials.username,
                password: credentials.password,
                database: credentials.database,
                port: credentials.port,
                ssl: options.ssl,
                socketPath: credentials.socketPath,
            },
            options.acquireTimeout === undefined
                ? {}
                : { acquireTimeout: options.acquireTimeout },
            { connectionLimit: options.poolSize },
            options.extra || {},
        )
    }

    /**
     * Creates a new connection pool for a given database credentials.",1
"  } else if (provider.type === ""email"") {
    let email: string = body?.email
    if (!email) return { redirect: `${url}/error?error=EmailSignin` }
    const normalizer: (identifier: string) => string =
      provider.normalizeIdentifier ??
      ((identifier) => {
        // Get the first two elements only,
        // separated by `@` from user input.
        let [local, domain] = identifier.toLowerCase().trim().split(""@"")
        // The part before ""@"" can contain a "",""
        // but we remove it on the domain part
        domain = domain.split("","")[0]
        return `${local}@${domain}`
      })

    try {
      email = normalizer(body?.email)
    } catch (error) {",1
"  )

  app.get('/api/abc', (c) => {
    return c.json({ success: true })
  })

  app.get('/api2/abc', (c) => {
    return c.json({ success: true })
  })

  app.get('/api3/abc', (c) => {
    return c.json({ success: true })
  })

  app.get('/api4/abc', (c) => {
    return c.json({ success: true })
  })

  app.get('/api5/abc', () => {
    return new Response(JSON.stringify({ success: true }))
  })

  app.get('/api7/abc', () => {
    return new Response(JSON.stringify({ success: true }))
  })

  it('GET default', async () => {
    const res = await app.request('http://localhost/api/abc')

    expect(res.status).toBe(200)
    expect(res.headers.get('Access-Control-Allow-Origin')).toBe('*')
    expect(res.headers.get('Vary')).toBeNull()
  })

  it('Preflight default', async () => {
    const req = new Request('https://localhost/api/abc', { method: 'OPTIONS' })
    req.headers.append('Access-Control-Request-Headers', 'X-PINGOTHER, Content-Type')
    const res = await app.request(req)

    expect(res.status).toBe(204)
    expect(res.statusText).toBe('No Content')
    expect(res.headers.get('Access-Control-Allow-Methods')?.split(',')[0]).toBe('GET')
    expect(res.headers.get('Access-Control-Allow-Headers')?.split(',')).toEqual([
      'X-PINGOTHER',
      'Content-Type',
    ])
  })

  it('Preflight with options', async () => {
    const req = new Request('https://localhost/api2/abc', {
      method: 'OPTIONS',
      headers: { origin: 'http://example.com' },
    })
    const res = await app.request(req)

    expect(res.headers.get('Access-Control-Allow-Origin')).toBe('http://example.com')
    expect(res.headers.get('Vary')?.split(/\s*,\s*/)).toEqual(expect.arrayContaining(['Origin']))
    expect(res.headers.get('Access-Control-Allow-Headers')?.split(/\s*,\s*/)).toEqual([
      'X-Custom-Header',
      'Upgrade-Insecure-Requests',
    ])
    expect(res.headers.get('Access-Control-Allow-Methods')?.split(/\s*,\s*/)).toEqual([
      'POST',
      'GET',
      'OPTIONS',
    ])
    expect(res.headers.get('Access-Control-Expose-Headers')?.split(/\s*,\s*/)).toEqual([
      'Content-Length',
      'X-Kuma-Revision',
    ])
    expect(res.headers.get('Access-Control-Max-Age')).toBe('600')
    expect(res.headers.get('Access-Control-Allow-Credentials')).toBe('true')
  })

  it('Disallow an unmatched origin', async () => {
    const req = new Request('https://localhost/api2/abc', {
      method: 'OPTIONS',
      headers: { origin: 'http://example.net' },
    })
    const res = await app.request(req)
    expect(res.headers.has('Access-Control-Allow-Origin')).toBeFalsy()
  })

  it('Allow multiple origins', async () => {
    let req = new Request('http://localhost/api3/abc', {
      headers: {
        Origin: 'http://example.org',
      },
    })
    let res = await app.request(req)
    expect(res.headers.get('Access-Control-Allow-Origin')).toBe('http://example.org')

    req = new Request('http://localhost/api3/abc')
    res = await app.request(req)
    expect(
      res.headers.has('Access-Control-Allow-Origin'),
      'An unmatched origin should be disallowed'
    ).toBeFalsy()

    req = new Request('http://localhost/api3/abc', {
      headers: {
        Referer: 'http://example.net/',
      },
    })
    res = await app.request(req)
    expect(
      res.headers.has('Access-Control-Allow-Origin'),
      'An unmatched origin should be disallowed'
    ).toBeFalsy()
  })

  it('Allow different Vary header value', async () => {
    const res = await app.request('http://localhost/api3/abc', {
      headers: {
        Vary: 'accept-encoding',
        Origin: 'http://example.com',
      },
    })

    expect(res.status).toBe(200)
    expect(res.headers.get('Access-Control-Allow-Origin')).toBe('http://example.com')
    expect(res.headers.get('Vary')).toBe('accept-encoding')
  })

  it('Allow origins by function', async () => {
    let req = new Request('http://localhost/api4/abc', {
      headers: {
        Origin: 'http://subdomain.example.com',",1
"
    const allowOrigin = await findAllowOrigin(c.req.header('origin') || '', c)
    if (allowOrigin) {
      set('Access-Control-Allow-Origin', allowOrigin)
    }

    // Suppose the server sends a response with an Access-Control-Allow-Origin value with an explicit origin (rather than the ""*"" wildcard).
    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin
    if (opts.origin !== '*') {
      const existingVary = c.req.header('Vary')

      if (existingVary) {
        set('Vary', existingVary)
      } else {
        set('Vary', 'Origin')
      }
    }

    if (opts.credentials) {
      set('Access-Control-Allow-Credentials', 'true')
    }

    if (opts.exposeHeaders?.length) {
      set('Access-Control-Expose-Headers', opts.exposeHeaders.join(','))
    }

    if (c.req.method === 'OPTIONS') {
      if (opts.maxAge != null) {
        set('Access-Control-Max-Age', opts.maxAge.toString())
      }

      const allowMethods = await findAllowMethods(c.req.header('origin') || '', c)
      if (allowMethods.length) {
        set('Access-Control-Allow-Methods', allowMethods.join(','))
      }

      let headers = opts.allowHeaders
      if (!headers?.length) {
        const requestHeaders = c.req.header('Access-Control-Request-Headers')
        if (requestHeaders) {
          headers = requestHeaders.split(/\s*,\s*/)
        }
      }
      if (headers?.length) {
        set('Access-Control-Allow-Headers', headers.join(','))
        c.res.headers.append('Vary', 'Access-Control-Request-Headers')
      }

      c.res.headers.delete('Content-Length')
      c.res.headers.delete('Content-Type')

      return new Response(null, {
        headers: c.res.headers,
        status: 204,
        statusText: 'No Content',
      })
    }
    await next()
  }
}",1
"import { AlgorithmTypes } from './jwa'
import { signing } from './jws'
import * as JWT from './jwt'
import { verifyWithJwks } from './jwt'
import {
  JwtAlgorithmNotImplemented,
  JwtTokenExpired,
  JwtTokenInvalid,
  JwtTokenIssuedAt,
  JwtTokenIssuer,
  JwtTokenNotBefore,
  JwtTokenSignatureMismatched,
} from './types'
import { utf8Encoder } from './utf8'

describe('isTokenHeader', () => {
  it('should return true for valid TokenHeader', () => {
    const validTokenHeader: JWT.TokenHeader = {
      alg: AlgorithmTypes.HS256,
      typ: 'JWT',
    }

    expect(JWT.isTokenHeader(validTokenHeader)).toBe(true)
  })

  it('should return false for invalid TokenHeader', () => {
    const invalidTokenHeader = {
      alg: 'invalid',
      typ: 'JWT',
    }

    expect(JWT.isTokenHeader(invalidTokenHeader)).toBe(false)
  })

  it('returns true even if the typ field is absent in a TokenHeader', () => {
    const validTokenHeader: JWT.TokenHeader = {
      alg: AlgorithmTypes.HS256,
    }

    expect(JWT.isTokenHeader(validTokenHeader)).toBe(true)
  })

  it('returns false when the typ field is present but empty', () => {
    const invalidTokenHeader = {
      alg: AlgorithmTypes.HS256,
      typ: '',
    }

    expect(JWT.isTokenHeader(invalidTokenHeader)).toBe(false)
  })
})

describe('JWT', () => {
  it('JwtAlgorithmNotImplemented', async () => {
    const payload = { message: 'hello world' }
    const secret = 'a-secret'
    const alg = ''
    let tok = ''
    let err: JwtAlgorithmNotImplemented
    try {
      tok = await JWT.sign(payload, secret, alg as AlgorithmTypes)
    } catch (e) {
      err = e as JwtAlgorithmNotImplemented
    }
    expect(tok).toBe('')
    // @ts-ignore
    expect(err).toEqual(new JwtAlgorithmNotImplemented(alg))
  })

  it('JwtTokenInvalid', async () => {
    const tok = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJtZXNzYWdlIjoiaGVsbG8gd29ybGQifQ'
    const secret = 'a-secret'
    let err: JwtTokenInvalid
    let authorized
    try {
      authorized = await JWT.verify(tok, secret, AlgorithmTypes.HS256)
    } catch (e) {
      err = e as JwtTokenInvalid
    }
    // @ts-ignore
    expect(err).toEqual(new JwtTokenInvalid(tok))
    expect(authorized).toBeUndefined()
  })

  it('JwtTokenNotBefore', async () => {
    const tok =
      'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpYXQiOjE2NjQ2MDYzMzQsImV4cCI6MTY2NDYwOTkzNCwibmJmIjoiMzEwNDYwNjI2NCJ9.hpSDT_cfkxeiLWEpWVT8TDxFP3dFi27q1K7CcMcLXHc'
    const secret = 'a-secret'
    let err: JwtTokenNotBefore
    let authorized
    try {
      authorized = await JWT.verify(tok, secret, AlgorithmTypes.HS256)
    } catch (e) {
      err = e as JwtTokenNotBefore
    }
    // @ts-ignore
    expect(err).toEqual(new JwtTokenNotBefore(tok))
    expect(authorized).toBeUndefined()
  })

  it('JwtTokenExpired', async () => {
    const tok =
      'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpYXQiOjE2MzMwNDYxMDAsImV4cCI6MTYzMzA0NjQwMH0.H-OI1TWAbmK8RonvcpPaQcNvOKS9sxinEOsgKwjoiVo'
    const secret = 'a-secret'
    let err
    let authorized
    try {
      authorized = await JWT.verify(tok, secret, AlgorithmTypes.HS256)
    } catch (e) {
      err = e
    }
    expect(err).toEqual(new JwtTokenExpired(tok))
    expect(authorized).toBeUndefined()
  })

  it('JwtTokenIssuedAt', async () => {
    const now = 1633046400
    vi.useFakeTimers().setSystemTime(new Date().setTime(now * 1000))

    const iat = now + 1000 // after 1s
    const payload = { role: 'api_role', iat }
    const secret = 'a-secret'
    const tok = await JWT.sign(payload, secret, AlgorithmTypes.HS256)

    let err
    let authorized
    try {
      authorized = await JWT.verify(tok, secret, AlgorithmTypes.HS256)
    } catch (e) {
      err = e
    }
    expect(err).toEqual(new JwtTokenIssuedAt(now, iat))
    expect(authorized).toBeUndefined()
  })

  it('JwtTokenIssuer (none)', async () => {
    const tok =
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE2MzMwNDY0MDB9.Ha3tPZzmnLGyFfZYd7GSV0iCn2F9kbZffFVZcTe5kJo'
    const secret = 'a-secret'
    let err
    let authorized
    try {
      authorized = await JWT.verify(tok, secret, {
        alg: AlgorithmTypes.HS256,
        iss: 'some',
      })
    } catch (e) {
      err = e
    }
    expect(err).toEqual(new JwtTokenIssuer('some', null))
    expect(authorized).toBeUndefined()
  })

  it('JwtTokenIssuer (wrong - string)', async () => {
    const tok =
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE2MzMwNDY0MDAsImlzcyI6ImZha2UtaXNzdWVyIn0.miyPU40DBvhxpAUsndssJOMBsP1aqc8JClGnriPHfXk'
    const secret = 'a-secret'
    let err
    let authorized
    try {
      authorized = await JWT.verify(tok, secret, {
        alg: AlgorithmTypes.HS256,
        iss: 'expected-issuer',
      })
    } catch (e) {
      err = e
    }
    expect(err).toEqual(new JwtTokenIssuer('expected-issuer', 'fake-issuer'))
    expect(authorized).toBeUndefined()
  })

  it('JwtTokenIssuer (wrong - RegExp)', async () => {
    const tok =
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE2MzMwNDY0MDAsImlzcyI6ImhleSJ9.Q0NJwoj-meWy42pFFrPNlREe2lOagWioJUjR4eJCx0k'
    const secret = 'a-secret'
    let err
    let authorized
    try {
      authorized = await JWT.verify(tok, secret, {
        alg: AlgorithmTypes.HS256,
        iss: /^(hello|hi)$/,
      })
    } catch (e) {
      err = e
    }
    expect(err).toEqual(new JwtTokenIssuer(/^(hello|hi)$/, 'hey'))
    expect(authorized).toBeUndefined()
  })

  it('JwtTokenIssuer (correct - string)', async () => {
    const tok =
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE2MzMwNDY0MDAsImlzcyI6ImNvcnJlY3QtaXNzdWVyIn0.gF8S6M2QcfTTscgxeyihNk28JAOa8mfL1bXPb3_E3rk'
    const secret = 'a-secret'
    let err
    let authorized
    try {
      authorized = await JWT.verify(tok, secret, {
        alg: AlgorithmTypes.HS256,
        iss: 'correct-issuer',
      })
    } catch (e) {
      err = e
    }
    expect(err).toBeUndefined()
    expect(authorized?.iss).toEqual('correct-issuer')
  })

  it('JwtTokenIssuer (correct - RegExp)', async () => {
    const tok =
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE2MzMwNDY0MDAsImlzcyI6ImhlbGxvIn0.5DDuValGGQu4EfS3DY7C4hwwHyTNSTD93K_YEjBzgAc'
    const secret = 'a-secret'
    let err
    let authorized
    try {
      authorized = await JWT.verify(tok, secret, {
        alg: AlgorithmTypes.HS256,
        iss: /^(hello|hi)$/,
      })
    } catch (e) {
      err = e
    }
    expect(err).toBeUndefined()
    expect(authorized?.iss).toEqual('hello')
  })

  it('HS256 sign & verify & decode', async () => {
    const payload = { message: 'hello world' }
    const secret = 'a-secret'
    const tok = await JWT.sign(payload, secret, AlgorithmTypes.HS256)
    const expected =
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJtZXNzYWdlIjoiaGVsbG8gd29ybGQifQ.B54pAqIiLbu170tGQ1rY06Twv__0qSHTA0ioQPIOvFE'",1
"import type { SignatureAlgorithm } from './jwa'
import { signing, verifying } from './jws'
import type { HonoJsonWebKey, SignatureKey } from './jws'
import {
  JwtHeaderInvalid,
  JwtHeaderRequiresKid,
  JwtTokenExpired,
  JwtTokenInvalid,
  JwtTokenIssuedAt,
  JwtTokenIssuer,
  JwtTokenNotBefore,
  JwtTokenSignatureMismatched,
} from './types'
import type { JWTPayload } from './types'
import { utf8Decoder, utf8Encoder } from './utf8'

const encodeJwtPart = (part: unknown): string =>
  encodeBase64Url(utf8Encoder.encode(JSON.stringify(part)).buffer).replace(/=/g, '')
const encodeSignaturePart = (buf: ArrayBufferLike): string => encodeBase64Url(buf).replace(/=/g, '')

const decodeJwtPart = (part: string): TokenHeader | JWTPayload | undefined =>
  JSON.parse(utf8Decoder.decode(decodeBase64Url(part)))

export interface TokenHeader {
  alg: SignatureAlgorithm
  typ?: 'JWT'
  kid?: string
}

export function isTokenHeader(obj: unknown): obj is TokenHeader {
  if (typeof obj === 'object' && obj !== null) {
    const objWithAlg = obj as { [key: string]: unknown }
    return (
      'alg' in objWithAlg &&
      Object.values(AlgorithmTypes).includes(objWithAlg.alg as AlgorithmTypes) &&
      (!('typ' in objWithAlg) || objWithAlg.typ === 'JWT')
    )
  }
  return false
}

export const sign = async (
  payload: JWTPayload,
  privateKey: SignatureKey,
  alg: SignatureAlgorithm = 'HS256'
): Promise<string> => {
  const encodedPayload = encodeJwtPart(payload)
  let encodedHeader
  if (typeof privateKey === 'object' && 'alg' in privateKey) {
    alg = privateKey.alg as SignatureAlgorithm
    encodedHeader = encodeJwtPart({ alg, typ: 'JWT', kid: privateKey.kid })
  } else {
    encodedHeader = encodeJwtPart({ alg, typ: 'JWT' })
  }

  const partialToken = `${encodedHeader}.${encodedPayload}`

  const signaturePart = await signing(privateKey, alg, utf8Encoder.encode(partialToken))
  const signature = encodeSignaturePart(signaturePart)

  return `${partialToken}.${signature}`
}

export type VerifyOptions = {
  /** The expected issuer used for verifying the token */
  iss?: string | RegExp
  /** Verify the `nbf` claim (default: `true`) */
  nbf?: boolean
  /** Verify the `exp` claim (default: `true`) */
  exp?: boolean
  /** Verify the `iat` claim (default: `true`) */
  iat?: boolean
}

export type VerifyOptionsWithAlg = {
  /** The algorithm used for decoding the token */
  alg?: SignatureAlgorithm
} & VerifyOptions

type StrictVerifyOptions = {
  iss?: string | RegExp
  nbf: boolean
  exp: boolean
  iat: boolean
}

type StrictVerifyOptionsWithAlg = {
  alg: SignatureAlgorithm
} & StrictVerifyOptions

export const verify = async (
  token: string,
  publicKey: SignatureKey,
  algOrOptions?: SignatureAlgorithm | VerifyOptionsWithAlg
): Promise<JWTPayload> => {
  const optsIn = typeof algOrOptions === 'string' ? { alg: algOrOptions } : algOrOptions || {}
  const opts: StrictVerifyOptionsWithAlg = {
    alg: optsIn.alg ?? 'HS256',
    iss: optsIn.iss,
    nbf: optsIn.nbf ?? true,
    exp: optsIn.exp ?? true,
    iat: optsIn.iat ?? true,
  }

  const tokenParts = token.split('.')
  if (tokenParts.length !== 3) {
    throw new JwtTokenInvalid(token)
  }

  const { header, payload } = decode(token)
  if (!isTokenHeader(header)) {
    throw new JwtHeaderInvalid(header)
  }
  const now = (Date.now() / 1000) | 0
  if (opts.nbf && payload.nbf && payload.nbf > now) {
    throw new JwtTokenNotBefore(token)
  }
  if (opts.exp && payload.exp && payload.exp <= now) {
    throw new JwtTokenExpired(token)
  }
  if (opts.iat && payload.iat && now < payload.iat) {
    throw new JwtTokenIssuedAt(now, payload.iat)
  }
  if (opts.iss) {
    if (!payload.iss) {
      throw new JwtTokenIssuer(opts.iss, null)
    }
    if (typeof opts.iss === 'string' && payload.iss !== opts.iss) {
      throw new JwtTokenIssuer(opts.iss, payload.iss)
    }
    if (opts.iss instanceof RegExp && !opts.iss.test(payload.iss)) {
      throw new JwtTokenIssuer(opts.iss, payload.iss)
    }
  }

  const headerPayload = token.substring(0, token.lastIndexOf('.'))
  const verified = await verifying(
    publicKey,
    opts.alg,
    decodeBase64Url(tokenParts[2]),
    utf8Encoder.encode(headerPayload)",1
"  constructor(token: string) {
    super(`token(${token}) signature mismatched`)
    this.name = 'JwtTokenSignatureMismatched'
  }
}

export enum CryptoKeyUsage {
  Encrypt = 'encrypt',
  Decrypt = 'decrypt',
  Sign = 'sign',
  Verify = 'verify',
  DeriveKey = 'deriveKey',
  DeriveBits = 'deriveBits',
  WrapKey = 'wrapKey',
  UnwrapKey = 'unwrapKey',
}

/**
 * JWT Payload
 */
export type JWTPayload = {
  [key: string]: unknown
  /**
   * The token is checked to ensure it has not expired.
   */
  exp?: number
  /**
   * The token is checked to ensure it is not being used before a specified time.
   */
  nbf?: number
  /**
   * The token is checked to ensure it is not issued in the future.
   */
  iat?: number
  /**
   * The token is checked to ensure it has been issued by a trusted issuer.
   */
  iss?: string
}

export type { HonoJsonWebKey } from './jws'",1
"function merge() {
  var i,
    src,
    copy,
    clone,
    name,
    result = {},
    current = null,
    length = arguments.length;

  for (i = 0; i < length; i++) {
    current = arguments[i];
    if (current == null) {",1
"}

function set(obj, path, value) {
  if (!obj) {
    return;
  }
  var keys = path.split('.');
  var len = keys.length;
  if (len < 1) {
    return;
  }
  if (len === 1) {",1
"    expect(e.payload.environment).to.eql('foo');
    expect(e.payload.fuzz).to.eql('buzz');
    expect(e.payload.other).to.eql('bar');
    expect(e.amihere).to.eql('yes');
    done();
  });
});

import traverse from '../src/utility/traverse.js';
describe('traverse', function () {
  describe('should call the func for every key,value', function () {
    it('simple object', function (done) {
      var obj = { a: 1, b: 2 };
      var expectedOutput = { a: 2, b: 3 };
      var callCount = 0;
      var result = traverse(obj, function (k, v) {
        callCount++;
        return v + 1;
      });
      expect(result).to.eql(expectedOutput);
      expect(callCount).to.eql(2);

      done();
    });
    it('nested object', function (done) {
      var obj = { a: 1, b: 2, c: { ca: 11 } };
      var expectedOutput = { a: 2, b: 3, c: { ca: 12 } };
      var callCount = 0;
      var result = traverse(obj, function (k, v) {
        callCount++;
        if (k === 'c') {
          return { ca: v.ca + 1 };
        }
        return v + 1;
      });
      expect(result).to.eql(expectedOutput);
      expect(callCount).to.eql(3);

      done();
    });
    it('array', function (done) {
      var obj = [1, 2, 3];
      var expected = [0, 1, 2];
      var callCount = 0;
      var result = traverse(
        obj,
        function (k, v) {
          callCount++;
          return v - 1;
        },
        [],
      );
      expect(result).to.eql(expected);
      expect(callCount).to.eql(3);
      done();
    });
  });
});

describe('uuid4', function () {
  it('should return a version 4 uuid', function (done) {
    var id = _.uuid4();
    var otherId = _.uuid4();
    expect(id).to.not.eql(otherId);
    var parts = id.split('-');
    expect(parts.length).to.eql(5);
    expect(parts[2][0]).to.eql('4');
    expect(parts[0].length).to.eql(8);
    expect(parts[1].length).to.eql(4);
    expect(parts[2].length).to.eql(4);
    expect(parts[3].length).to.eql(4);
    expect(parts[4].length).to.eql(12);
    done();
  });
});

describe('redact', function () {
  it('should return a string of stars', function (done) {
    var s1 = 'thisIsApasswrD';
    var s2 = 'short';
    var o = { a: 123 };
    var a = [12, 34, 56];

    expect(_.redact(s1)).to.not.match(/[^*]/);
    expect(_.redact(s2)).to.not.match(/[^*]/);
    expect(_.redact(s1)).to.eql(_.redact(s2));
    expect(_.redact(o)).to.not.match(/[^*]/);
    expect(_.redact(a)).to.not.match(/[^*]/);

    done();
  });
});

describe('LEVELS', function () {
  it('should include debug', function () {
    expect(_.LEVELS['debug']).to.not.eql(undefined);
  });
  it('should have critical higher than debug', function () {
    expect(_.LEVELS['critical']).to.be.greaterThan(_.LEVELS['debug']);
  });
});

describe('formatUrl', function () {
  it('should handle a missing protocol', function () {
    var u = { hostname: 'a.b.com', path: '/wooza/', port: 42 };
    expect(_.formatUrl(u)).to.eql('https://a.b.com:42/wooza/');
  });
  it('should use a forced protocol', function () {
    var u = { hostname: 'a.b.com', path: '/wooza/', port: 42 };
    expect(_.formatUrl(u, 'file:')).to.eql('file://a.b.com:42/wooza/');
  });
  it('should pick a protocol based on port if others are missing', function () {
    var u = { hostname: 'a.b.com', port: 80, path: '/woo' };
    expect(_.formatUrl(u)).to.eql('http://a.b.com:80/woo');
    u.protocol = 'https:';
    expect(_.formatUrl(u)).to.eql('https://a.b.com:80/woo');
  });
  it('should handle missing parts', function () {
    var u = { hostname: 'a.b.com' };
    expect(_.formatUrl(u)).to.eql('https://a.b.com');
    expect(_.formatUrl(u, 'http:')).to.eql('http://a.b.com');
  });
  it('should return null without a hostname', function () {
    var u = {};
    expect(_.formatUrl(u)).to.not.be.ok;
    expect(_.formatUrl(u, 'https:')).to.not.be.ok;
  });
});

describe('addParamsAndAccessTokenToPath', function () {
  var accessToken = 'abc123';
  it('should handle no params and no path', function () {
    var options = {};
    _.addParamsAndAccessTokenToPath(accessToken, options);
    expect(options.path).to.eql('?access_token=abc123');
  });
  it('should handle existing params', function () {
    var options = { path: '/api?a=b' };
    _.addParamsAndAccessTokenToPath(accessToken, options);
    expect(options.path).to.eql('/api?access_token=abc123&a=b');
  });
  it('should handle a hash with params', function () {
    var options = { path: '/api?a=b#moreStuff??here' };
    _.addParamsAndAccessTokenToPath(accessToken, options);
    expect(options.path).to.eql('/api?access_token=abc123&a=b#moreStuff??here');
  });
  it('should handle a hash without params', function () {
    var options = { path: '/api#moreStuff??here' };
    _.addParamsAndAccessTokenToPath(accessToken, options);
    expect(options.path).to.eql('/api?access_token=abc123#moreStuff??here');
  });
  it('should handle a hash without params and no ?', function () {
    var options = { path: '/api#moreStuff' };
    _.addParamsAndAccessTokenToPath(accessToken, options);
    expect(options.path).to.eql('/api?access_token=abc123#moreStuff');
  });
  it('should handle extra params', function () {
    var options = { path: '/api#moreStuff' };
    _.addParamsAndAccessTokenToPath(accessToken, options, { foo: 'boo' });
    expect(options.path).to.eql('/api?access_token=abc123&foo=boo#moreStuff');
  });
});

describe('get', function () {
  it('should get a deeply nested value', function () {
    var o = { a: { b: { c: { d: 42 } } } };
    expect(_.get(o, 'a.b.c.d')).to.eql(42);
  });
  it('should be undefined for a missing value', function () {
    var o = { a: { b: { c: { d: 42 } } } };
    expect(_.get(o, 'a.b.x.d')).to.not.be.ok;
  });
  it('should handle bad input', function () {
    var o = 'hello';
    expect(_.get(o, 'oops.1.2.3')).to.not.be.ok;
  });
  it('should actually work with arrays too', function () {
    var o = { a: [{ b: { c: [1, { d: 42 }, null] } }, 99] };
    expect(_.get(o, 'a.0.b.c.1.d')).to.eql(42);
  });
  it('should handle undefined input', function () {
    var u = undefined;
    expect(_.get(u, 'a.b.c')).to.not.be.ok;
  });
});

describe('filterIp', function () {
  it('no user_ip', function () {
    var requestData = { something: 'but no ip' };
    _.filterIp(requestData, false);
    expect(requestData['user_ip']).to.not.be.ok;
  });
  it('capture true', function () {
    var ip = '123.32.394.99';
    var requestData = { user_ip: ip };
    _.filterIp(requestData, true);
    expect(requestData['user_ip']).to.eql(ip);
  });
  it('anonymize ip4', function () {
    var ip = '123.32.394.99';
    var requestData = { user_ip: ip };
    _.filterIp(requestData, 'anonymize');
    expect(requestData['user_ip']).to.not.eql(ip);
    expect(requestData['user_ip']).to.be.ok;
  });
  it('capture false', function () {
    var ip = '123.32.394.99';
    var requestData = { user_ip: ip };
    _.filterIp(requestData, false);
    expect(requestData['user_ip']).to.not.eql(ip);
    expect(requestData['user_ip']).to.not.be.ok;
  });
  it('ipv6 capture false', function () {
    var ip = '2607:f0d0:1002:51::4';
    var requestData = { user_ip: ip };
    _.filterIp(requestData, false);
    expect(requestData['user_ip']).to.not.eql(ip);
    expect(requestData['user_ip']).to.not.be.ok;
  });
  it('ipv6 anonymize', function () {
    var ips = [
      'FE80:0000:0000:0000:0202:B3FF:FE1E:8329',
      'FE80::0202:B3FF:FE1E:8329',
      '2607:f0d0:1002:51::4',
    ];
    for (var i = 0; i < ips.length; i++) {
      var ip = ips[i];
      var requestData = { user_ip: ip };
      _.filterIp(requestData, 'anonymize');
      expect(requestData['user_ip']).to.not.eql(ip);
      expect(requestData['user_ip']).to.be.ok;
    }
  });
});

describe('set', function () {
  it('should handle a top level key', function () {
    var o = { a: 42 };
    _.set(o, 'b', 1);
    expect(o.b).to.eql(1);
    expect(o.a).to.eql(42);
  });
  it('should handle a top level key', function () {
    var o = { a: 42, b: { c: 44, d: { e: 99 } } };
    _.set(o, 'f', 1);
    expect(o.f).to.eql(1);
    expect(o.a).to.eql(42);
    expect(o.b.c).to.eql(44);
    expect(o.b.d.e).to.eql(99);
  });
  it('should replace a value that is already there', function () {
    var o = { a: 42 };
    _.set(o, 'a', 1);
    expect(o.a).to.eql(1);
  });
  it('should set a nested value with missing keys', function () {
    var o = { baz: 21 };
    _.set(o, 'foo.bar', [42]);
    expect(o.baz).to.eql(21);
    expect(o.foo.bar).to.eql([42]);
  });
  it('should replace a nested value', function () {
    var o = { woo: 99, foo: { bar: { baz: 42, buzz: 97 }, a: 98 } };
    _.set(o, 'foo.bar.baz', 1);
    expect(o.woo).to.eql(99);
    expect(o.foo.a).to.eql(98);
    expect(o.foo.bar.buzz).to.eql(97);
    expect(o.foo.bar.baz).to.eql(1);
  });
  it('should set a nested value with some missing keys', function () {
    var o = { woo: 99, foo: { bar: { buzz: 97 }, a: 98 } };
    _.set(o, 'foo.bar.baz.fizz', 1);
    expect(o.woo).to.eql(99);
    expect(o.foo.a).to.eql(98);
    expect(o.foo.bar.buzz).to.eql(97);
    expect(o.foo.bar.baz.fizz).to.eql(1);
  });
});

import scrub from '../src/scrub.js';
describe('scrub', function () {
  it('should not redact fields that are okay', function () {
    var data = { a: 'somestring', password: 'abc123', tempWorker: 'cool' };",1
"function merge() {
  var i,
    src,
    copy,
    clone,
    name,
    result = {},
    current = null,
    length = arguments.length;

  for (i = 0; i < length; i++) {
    current = arguments[i];
    if (current == null) {",1
"}

function set(obj, path, value) {
  if (!obj) {
    return;
  }
  var keys = path.split('.');
  var len = keys.length;
  if (len < 1) {
    return;
  }
  if (len === 1) {",1
"    expect(e.payload.environment).to.eql('foo');
    expect(e.payload.fuzz).to.eql('buzz');
    expect(e.payload.other).to.eql('bar');
    expect(e.amihere).to.eql('yes');
    done();
  });
});

var traverse = require('../src/utility/traverse');
describe('traverse', function () {
  describe('should call the func for every key,value', function () {
    it('simple object', function (done) {
      var obj = { a: 1, b: 2 };
      var expectedOutput = { a: 2, b: 3 };
      var callCount = 0;
      var result = traverse(obj, function (k, v) {
        callCount++;
        return v + 1;
      });
      expect(result).to.eql(expectedOutput);
      expect(callCount).to.eql(2);

      done();
    });
    it('nested object', function (done) {
      var obj = { a: 1, b: 2, c: { ca: 11 } };
      var expectedOutput = { a: 2, b: 3, c: { ca: 12 } };
      var callCount = 0;
      var result = traverse(obj, function (k, v) {
        callCount++;
        if (k === 'c') {
          return { ca: v.ca + 1 };
        }
        return v + 1;
      });
      expect(result).to.eql(expectedOutput);
      expect(callCount).to.eql(3);

      done();
    });
    it('array', function (done) {
      var obj = [1, 2, 3];
      var expected = [0, 1, 2];
      var callCount = 0;
      var result = traverse(
        obj,
        function (k, v) {
          callCount++;
          return v - 1;
        },
        [],
      );
      expect(result).to.eql(expected);
      expect(callCount).to.eql(3);
      done();
    });
  });
});

describe('uuid4', function () {
  it('should return a version 4 uuid', function (done) {
    var id = _.uuid4();
    var otherId = _.uuid4();
    expect(id).to.not.eql(otherId);
    var parts = id.split('-');
    expect(parts.length).to.eql(5);
    expect(parts[2][0]).to.eql('4');
    expect(parts[0].length).to.eql(8);
    expect(parts[1].length).to.eql(4);
    expect(parts[2].length).to.eql(4);
    expect(parts[3].length).to.eql(4);
    expect(parts[4].length).to.eql(12);
    done();
  });
});

describe('redact', function () {
  it('should return a string of stars', function (done) {
    var s1 = 'thisIsApasswrD';
    var s2 = 'short';
    var o = { a: 123 };
    var a = [12, 34, 56];

    expect(_.redact(s1)).to.not.match(/[^*]/);
    expect(_.redact(s2)).to.not.match(/[^*]/);
    expect(_.redact(s1)).to.eql(_.redact(s2));
    expect(_.redact(o)).to.not.match(/[^*]/);
    expect(_.redact(a)).to.not.match(/[^*]/);

    done();
  });
});

describe('LEVELS', function () {
  it('should include debug', function () {
    expect(_.LEVELS['debug']).to.not.eql(undefined);
  });
  it('should have critical higher than debug', function () {
    expect(_.LEVELS['critical']).to.be.greaterThan(_.LEVELS['debug']);
  });
});

describe('formatUrl', function () {
  it('should handle a missing protocol', function () {
    var u = {
      hostname: 'a.b.com',
      path: '/wooza/',
      port: 42,
    };
    expect(_.formatUrl(u)).to.eql('https://a.b.com:42/wooza/');
  });
  it('should use a forced protocol', function () {
    var u = {
      hostname: 'a.b.com',
      path: '/wooza/',
      port: 42,
    };
    expect(_.formatUrl(u, 'file:')).to.eql('file://a.b.com:42/wooza/');
  });
  it('should pick a protocol based on port if others are missing', function () {
    var u = {
      hostname: 'a.b.com',
      port: 80,
      path: '/woo',
    };
    expect(_.formatUrl(u)).to.eql('http://a.b.com:80/woo');
    u.protocol = 'https:';
    expect(_.formatUrl(u)).to.eql('https://a.b.com:80/woo');
  });
  it('should handle missing parts', function () {
    var u = {
      hostname: 'a.b.com',
    };
    expect(_.formatUrl(u)).to.eql('https://a.b.com');
    expect(_.formatUrl(u, 'http:')).to.eql('http://a.b.com');
  });
  it('should return null without a hostname', function () {
    var u = {};
    expect(_.formatUrl(u)).to.not.be.ok();
    expect(_.formatUrl(u, 'https:')).to.not.be.ok();
  });
});

describe('addParamsAndAccessTokenToPath', function () {
  var accessToken = 'abc123';
  it('should handle no params and no path', function () {
    var options = {};
    _.addParamsAndAccessTokenToPath(accessToken, options);
    expect(options.path).to.eql('?access_token=abc123');
  });
  it('should handle existing params', function () {
    var options = { path: '/api?a=b' };
    _.addParamsAndAccessTokenToPath(accessToken, options);
    expect(options.path).to.eql('/api?access_token=abc123&a=b');
  });
  it('should handle a hash with params', function () {
    var options = { path: '/api?a=b#moreStuff??here' };
    _.addParamsAndAccessTokenToPath(accessToken, options);
    expect(options.path).to.eql('/api?access_token=abc123&a=b#moreStuff??here');
  });
  it('should handle a hash without params', function () {
    var options = { path: '/api#moreStuff??here' };
    _.addParamsAndAccessTokenToPath(accessToken, options);
    expect(options.path).to.eql('/api?access_token=abc123#moreStuff??here');
  });
  it('should handle a hash without params and no ?', function () {
    var options = { path: '/api#moreStuff' };
    _.addParamsAndAccessTokenToPath(accessToken, options);
    expect(options.path).to.eql('/api?access_token=abc123#moreStuff');
  });
  it('should handle extra params', function () {
    var options = { path: '/api#moreStuff' };
    _.addParamsAndAccessTokenToPath(accessToken, options, { foo: 'boo' });
    expect(options.path).to.eql('/api?access_token=abc123&foo=boo#moreStuff');
  });
});

describe('json3', function () {
  var setupCustomJSON = require('../vendor/JSON-js/json3.js');
  it('should replace stringify if not there', function () {
    var j = {};
    setupCustomJSON(j);
    expect(j.stringify({ a: 1 })).to.eql('{""a"":1}');
  });
  it('should replace parse if not there', function () {
    var j = {};
    setupCustomJSON(j);
    expect(j.parse('{""a"":1}').a).to.eql(1);
  });
  it('should not replace parse if there', function () {
    var j = {
      parse: function (s) {
        return 42;
      },
    };
    setupCustomJSON(j);
    expect(j.parse('{""a"":1}')).to.eql(42);
    expect(j.stringify({ a: 1 })).to.eql('{""a"":1}');
  });
  it('should not replace stringify if there', function () {
    var j = {
      stringify: function (s) {
        return '42';
      },
    };
    setupCustomJSON(j);
    expect(j.stringify({ a: 1 })).to.eql('42');
    expect(j.parse('{""a"":1}').a).to.eql(1);
  });
});

describe('get', function () {
  it('should get a deeply nested value', function () {
    var o = { a: { b: { c: { d: 42 } } } };
    expect(_.get(o, 'a.b.c.d')).to.eql(42);
  });
  it('should be undefined for a missing value', function () {
    var o = { a: { b: { c: { d: 42 } } } };
    expect(_.get(o, 'a.b.x.d')).to.not.be.ok();
  });
  it('should handle bad input', function () {
    var o = 'hello';
    expect(_.get(o, 'oops.1.2.3')).to.not.be.ok();
  });
  it('should actually work with arrays too', function () {
    var o = { a: [{ b: { c: [1, { d: 42 }, null] } }, 99] };
    expect(_.get(o, 'a.0.b.c.1.d')).to.eql(42);
  });
  it('should handle undefined input', function () {
    var u = undefined;
    expect(_.get(u, 'a.b.c')).to.not.be.ok();
  });
});

describe('filterIp', function () {
  it('no user_ip', function () {
    var requestData = { something: 'but no ip' };
    _.filterIp(requestData, false);
    expect(requestData['user_ip']).to.not.be.ok();
  });
  it('capture true', function () {
    var ip = '123.32.394.99';
    var requestData = { user_ip: ip };
    _.filterIp(requestData, true);
    expect(requestData['user_ip']).to.eql(ip);
  });
  it('anonymize ip4', function () {
    var ip = '123.32.394.99';
    var requestData = { user_ip: ip };
    _.filterIp(requestData, 'anonymize');
    expect(requestData['user_ip']).to.not.eql(ip);
    expect(requestData['user_ip']).to.be.ok();
  });
  it('capture false', function () {
    var ip = '123.32.394.99';
    var requestData = { user_ip: ip };
    _.filterIp(requestData, false);
    expect(requestData['user_ip']).to.not.eql(ip);
    expect(requestData['user_ip']).to.not.be.ok();
  });
  it('ipv6 capture false', function () {
    var ip = '2607:f0d0:1002:51::4';
    var requestData = { user_ip: ip };
    _.filterIp(requestData, false);
    expect(requestData['user_ip']).to.not.eql(ip);
    expect(requestData['user_ip']).to.not.be.ok();
  });
  it('ipv6 anonymize', function () {
    var ips = [
      'FE80:0000:0000:0000:0202:B3FF:FE1E:8329',
      'FE80::0202:B3FF:FE1E:8329',
      '2607:f0d0:1002:51::4',
    ];
    for (var i = 0; i < ips.length; i++) {
      var ip = ips[i];
      var requestData = { user_ip: ip };
      _.filterIp(requestData, 'anonymize');
      expect(requestData['user_ip']).to.not.eql(ip);
      expect(requestData['user_ip']).to.be.ok();
    }
  });
});

describe('set', function () {
  it('should handle a top level key', function () {
    var o = { a: 42 };
    _.set(o, 'b', 1);
    expect(o.b).to.eql(1);
    expect(o.a).to.eql(42);
  });
  it('should handle a top level key', function () {
    var o = { a: 42, b: { c: 44, d: { e: 99 } } };
    _.set(o, 'f', 1);
    expect(o.f).to.eql(1);
    expect(o.a).to.eql(42);
    expect(o.b.c).to.eql(44);
    expect(o.b.d.e).to.eql(99);
  });
  it('should replace a value that is already there', function () {
    var o = { a: 42 };
    _.set(o, 'a', 1);
    expect(o.a).to.eql(1);
  });
  it('should set a nested value with missing keys', function () {
    var o = { baz: 21 };
    _.set(o, 'foo.bar', [42]);
    expect(o.baz).to.eql(21);
    expect(o.foo.bar).to.eql([42]);
  });
  it('should replace a nested value', function () {
    var o = { woo: 99, foo: { bar: { baz: 42, buzz: 97 }, a: 98 } };
    _.set(o, 'foo.bar.baz', 1);
    expect(o.woo).to.eql(99);
    expect(o.foo.a).to.eql(98);
    expect(o.foo.bar.buzz).to.eql(97);
    expect(o.foo.bar.baz).to.eql(1);
  });
  it('should set a nested value with some missing keys', function () {
    var o = { woo: 99, foo: { bar: { buzz: 97 }, a: 98 } };
    _.set(o, 'foo.bar.baz.fizz', 1);
    expect(o.woo).to.eql(99);
    expect(o.foo.a).to.eql(98);
    expect(o.foo.bar.buzz).to.eql(97);
    expect(o.foo.bar.baz.fizz).to.eql(1);
  });
});

var scrub = require('../src/scrub');
describe('scrub', function () {
  it('should not redact fields that are okay', function () {
    var data = {",1
"    const fileCreator = new FileCreator({
      projectDir,
      usingTsc: projectSetupData.useTypeScript,
    })
    fileCreator.createProject({
      projectName,
    })

    if (options.skipInstall || projectSetupData.skipPackageInstallation) {
      // Skip package installation
      console.log(chalk.yellow('Skipping package installation'))
    } else {",1
"import path from 'path'
import fs from 'fs'
import { dataSourcesTypeData, DataSourceType } from '@kottster/common'
import { FileTemplateManager } from './fileTemplateManager.service'
import { VERSION } from '../version'

interface FileCreatorOptions {
  projectDir?: string
  usingTsc?: boolean
}

interface CreateProjectOptions {
  projectName: string;
}

interface PackageJsonOptions {
  name: string
  type?: 'module'
  version?: string
  dependencies?: Record<string, string>
  devDependencies?: Record<string, string>
}

type EnvOptions = {
  key: string;
  comment?: string;
  value: string;
}[];

/**
 * Service for creating files in the project.
 */
export class FileCreator {
  private readonly projectDir: string;
  private readonly usingTsc: boolean;
  private readonly fileTemplateManager: FileTemplateManager;

  constructor (options?: FileCreatorOptions) {
    this.projectDir = options?.projectDir ?? process.cwd();
    this.usingTsc = options?.usingTsc ?? false;
    this.fileTemplateManager = new FileTemplateManager(this.usingTsc);
  }

  get jsExt () {
    return this.usingTsc ? 'ts' : 'js';
  }
  
  get jsxExt () {
    return this.usingTsc ? 'tsx' : 'jsx';
  }

  /**
   * Create a new project files.
   * @param options The new project options.
   */
  public createProject (options: CreateProjectOptions): void {
    // Check if project directory already exists
    if (fs.existsSync(this.projectDir) && options.projectName !== '.') {
      throw new Error(`Project directory already exists: ${this.projectDir}`)
    };

    // Create directories
    this.createDir()
    this.createDir('app')
    this.createDir('app/pages')
    this.createDir('app/_server')
    this.createDir('app/_server/data-sources')

    // Create root files
    this.createPackageJson({ 
      name: options.projectName,
      dependencies: {},
      devDependencies: this.usingTsc ? this.getTypescriptDependencies() : {}
    })
    this.createGitIgnore()
    
    // Create files
    this.createFileFromTemplate('vite.config.js', path.join(this.projectDir, `vite.config.${this.jsExt}`));
    this.createFileFromTemplate('Dockerfile', path.join(this.projectDir, 'Dockerfile'));
    this.createFileFromTemplate('docker-compose.yml', path.join(this.projectDir, 'docker-compose.yml'));
    this.createFileFromTemplate('app/index.html', path.join(this.projectDir, `app/index.html`));
    this.createFileFromTemplate('app/main.jsx', path.join(this.projectDir, `app/main.${this.jsxExt}`));
    this.createFileFromTemplate('app/_server/app.js', path.join(this.projectDir, `app/_server/app.${this.jsExt}`));
    this.createFileFromTemplate('app/_server/server.js', path.join(this.projectDir, `app/_server/server.${this.jsExt}`));
    if (this.usingTsc) {
      this.createFileFromTemplate('tsconfig.json', path.join(this.projectDir, 'tsconfig.json'));
    }
    
    this.createSchema()
  }

  /**
   * Get the additional dependencies for a TypeScript project.
   * @returns The TypeScript dependencies.
   */
  private getTypescriptDependencies(): Record<string, string> {
    return {
      'typescript': '^5.x',
      '@types/node': '^20.x',
      '@types/react': '^19.x',
      '@types/react-dom': ""^19.x"",
    };
  }

  /**
   * Add a data source to the project.
   * @param dataSourceType The type of the data source.
   * @returns The path to the data source file.
   */
  public addDataSource (dataSourceType: DataSourceType, dataSourceName?: string, data: Record<string, unknown> = {}): string {
    const dataSourceTypeData = dataSourcesTypeData[dataSourceType];
    const { fileTemplateName } = dataSourceTypeData;

    const finalDataSourceName = dataSourceName || `${dataSourceType}-db`;
    const directory = `app/_server/data-sources/${finalDataSourceName}`;

    // Create directory
    this.createDir(directory);

    // Create file with adapter
    const filePath = path.join(directory, `index.${this.jsExt}`)
    const fileContent = this.fileTemplateManager.getTemplate(fileTemplateName as keyof typeof FileTemplateManager.templates, data);
    this.writeFile(filePath, fileContent)

    // Create dataSource.json file
    const dataSourceJsonPath = path.join(directory, 'dataSource.json');
    const dataSourceJsonContent = JSON.stringify({
      type: dataSourceType,
      tablesConfig: {},
    }, null, 2);
    this.writeFile(dataSourceJsonPath, dataSourceJsonContent);

    return filePath;
  }

  /**
   * Create a package.json file
   * @param options The package.json content
   */
  private createPackageJson (options: PackageJsonOptions) {
    const packageJsonPath = path.join(this.projectDir, 'package.json')

    const {
      KOTTSTER_COMMON_DEP_VER,
      KOTTSTER_CLI_DEP_VER,
      KOTTSTER_SERVER_DEP_VER,
      KOTTSTER_REACT_DEP_VER,
    } = process.env;

    const packageJson = {
      name: options.name,
      version: options.version || '1.0.0',
      type: 'module',
      private: true,
      sideEffects: false,
      scripts: {
        'dev': 'kottster dev',
        'dev:add-data-source': 'kottster add-data-source',
        'dev:upgrade-kottster': 'kottster upgrade',
        ""build"": ""vite build && kottster build:server"",
        ""start"": ""node dist/server/server.cjs""
      },
      dependencies: {
        'react': '^19.x',
        'react-dom': '^19.x',
        'react-router-dom': '^7.x',
        'better-sqlite3': '^12.x',

        // Using exact same version as the CLI.
        // This ensures compatibility between the core packages
        '@kottster/common': KOTTSTER_COMMON_DEP_VER ?? VERSION,
        '@kottster/cli': KOTTSTER_CLI_DEP_VER ?? VERSION,
        '@kottster/server': KOTTSTER_SERVER_DEP_VER ?? VERSION,
        '@kottster/react': KOTTSTER_REACT_DEP_VER ?? VERSION,

        ...(options.dependencies ?? {}),
      },
      devDependencies: {
        'vite': ""^6.x"",
        'vite-tsconfig-paths': ""^4.x"",
        ""@vitejs/plugin-react"": ""^4.x"",
        
        // Using tsx to run TS/JS files directly
        'tsx': '^4.x',
        ...(options.devDependencies ?? {}),
      },
      engines: {
        node: '>=20',
      },
    }
    const packageJsonContent = JSON.stringify(packageJson, null, 2)

    this.writeFile(packageJsonPath, packageJsonContent)
  }
",1
export const VERSION = '3.3.1';,1
"import { DashboardPageConfig, DashboardPageConfigCard, DashboardPageConfigStat } from ""./dashboardPage.model"";
import { RelationalDatabaseSchema } from ""./databaseSchema.model"";
import { DataSourceType, PublicDataSource } from ""./dataSource.model"";
import { Page, PageFileStructure } from ""./page.model"";
import { TablePageConfig } from ""./tablePage.model"";
import { Template } from ""./template.model"";
import { ClientIdentityProviderRole, ClientIdentityProviderUser, IdentityProviderUserPermission, User } from ""./idp.model"";

export interface InternalApiSchema {
  getUsers: {
    body: unknown;
    result: {
      users: ClientIdentityProviderUser[];
    };
  };

  createUser: {
    body: {
      user: Pick<ClientIdentityProviderUser, 'firstName' | 'email' | 'avatarUrl' | 'lastName' | 'username' | 'roleIds' | 'temporaryPassword'>;
      password: string;
    };
    result: {
      user: ClientIdentityProviderUser;
    };
  };

  updateUser: {
    body: {
      userId: ClientIdentityProviderUser['id'];
      user: Partial<ClientIdentityProviderUser>;
      newPassword?: string;
    };
    result: {
      user: ClientIdentityProviderUser;
    };
  };

  deleteUser: {
    body: {
      userId: ClientIdentityProviderUser['id'];
    };
    result: void;
  };

  createRole: {
    body: {
      role: Pick<ClientIdentityProviderRole, 'name' | 'permissions'>;
    };
    result: {
      role: ClientIdentityProviderRole;
    };
  };

  updateRole: {
    body: {
      roleId: ClientIdentityProviderRole['id'];
      role: Partial<ClientIdentityProviderRole>;
    };
    result: {
      role: ClientIdentityProviderRole;
    };
  };

  deleteRole: {
    body: {
      roleId: ClientIdentityProviderRole['id'];
    };
    result: void;
  };

  getApp: {
    body: unknown;
    result: {
      schema: ClientAppSchema; 

      // Pass only if user is authenticated
      user?: ClientIdentityProviderUser;
      roles?: ClientIdentityProviderRole[];
      userPermissions?: (keyof typeof IdentityProviderUserPermission | string)[];
    };
  };

  generateSql: {",1
"  jwtTokenCheck?: string;
  settings?: Record<string, any>;
  createdAt?: Date | string;
  updatedAt?: Date | string;
}

export interface ClientIdentityProviderUser extends Omit<
  IdentityProviderUser, 
  'passwordHash' | 'passwordResetToken' | 'twoFactorSecret' | 'jwtTokenSecret'
> {}

export interface IdentityProviderRole {
  id: number | string;
  name?: string;
  permissions?: (keyof typeof IdentityProviderUserPermission)[];
  createdAt?: Date | string;
  updatedAt?: Date | string;
}

export interface ClientIdentityProviderRole extends IdentityProviderRole {}",1
"
interface BasePage {
  version: string;
  key: string;
  title?: string;
  icon?: string;
  allowedRoleIds?: string[];
  hideInSidebar?: boolean;
}

interface TablePage extends BasePage {
  type: 'table';
  config: TablePageConfig;
}

interface DashboardPage extends BasePage {
  type: 'dashboard';
  config: DashboardPageConfig;
}

interface CustomPage extends BasePage {
  type: 'custom';
  key: string;
  title: string;
}

export type Page = TablePage | DashboardPage | CustomPage;

interface PublicTablePage extends Pick<TablePage, 'key' | 'title' | 'icon' | 'type' | 'allowedRoleIds' | 'version' | 'hideInSidebar'> {
  config: TablePage['config'];
}

interface PublicDashboardPage extends Pick<DashboardPage, 'key' | 'title' | 'icon' | 'type' | 'allowedRoleIds' | 'version' | 'hideInSidebar'> {
  config: DashboardPage['config'];
}

interface PublicCustomPage extends Pick<CustomPage, 'key' | 'title' | 'icon' | 'type' | 'allowedRoleIds' | 'version' | 'hideInSidebar'> {}

export type PublicPage = PublicTablePage | PublicDashboardPage | PublicCustomPage;

export interface PageFileStructure {
  pageKey: string;
",1
"  sorting?: {
    column: string;
    direction: 'asc' | 'desc';
  };
  filters?: FilterItem[];
  
  getByForeignRecord?: {
    relationship: OneToManyRelationship;
    recordPrimaryKeyValue: string | number;
  };
}

export interface TablePageInitiateRecordsExportInput extends TablePageGetRecordsInput {
  format: 'csv' | 'json' | 'xlsx';
}

export interface TablePageCustomDataFetcherInput extends TablePageInputBase {
  page: number;
  pageSize: number;
  search?: string;
}

export interface TablePageGetRecordInput extends TablePageInputBase {
  nestedTableKey?: TablePageNestedTableKey;

  /** For selecting particular records */
  primaryKeyValues?: any[];

  forPreview?: boolean;
}

export interface TablePageCreateRecordInput extends TablePageInputBase {
  nestedTableKey?: TablePageNestedTableKey;
  values: Record<string, any>;
}

export interface TablePageUpdateRecordInput extends TablePageInputBase {
  nestedTableKey?: TablePageNestedTableKey;
  primaryKeyValue: any;
  values: Record<string, any>;
}

export interface TablePageDeleteRecordInput extends TablePageInputBase {
  nestedTableKey?: TablePageNestedTableKey;
  primaryKeyValues: any[];
}

export enum TablePageFieldRequirement {
  none = 'none',
  notEmpty = 'notEmpty',
  notZero = 'notZero',
}

export interface TablePageConfigColumn {
  /** Column name in the database table or any other unique identifier */
  column: string;

  /** Display name for the column */
  label?: string;

  /** Prefix for the column value (goes before the value) */
  prefix?: string;

  /** Suffix for the column value (goes after the value) */
  suffix?: string;
  
  /** 
   * Whether the column is hidden in the table 
   * @default false
   */
  hiddenInTable?: boolean;

  /** Whether the column is sortable */
  sortable?: boolean;

  /** Whether the column is searchable */
  searchable?: boolean;

  /** Whether the column is filterable */
  filterable?: boolean;
  
  /** 
   * Whether the column is hidden in the form
   * @default false
   */
  hiddenInForm?: boolean;

  /**
   * Form input type and its properties
   */
  fieldInput?: FieldInput;

  /** 
   * Validation rule for the column
   */
  fieldRequirement?: string | keyof typeof TablePageFieldRequirement;

  /** Grid field span for the field in the form (12, 8, 6, 4) */
  formFieldSpan?: string;
  
  /** If the column is a foreign key, this specifies the column in the related table to be displayed as the label */
  relationshipPreviewColumns?: string[];
  
  /** Client-side index of the column in the table */
  position?: number;

  /** 
   * Client-side custom render function for the column 
   * 
   * @param record - The record object containing all columns
   * @param recordIndex - The index of the record in the current page
   * @param data - Additional data including all records and total count
   * 
   * @example render: (record) => <span>{record.first_name} {record.last_name}</span>
   * 
   * @returns The rendered React element or content for the column
   */
  render?: (
    record: TablePageRecord,
    recordIndex: number, 
    data: {
      records: TablePageRecord[];
      total: number;
    }
  ) => any;

  /** Client-side custom width for the column */
  width?: number;
}

export interface TablePageConfigCalculatedColumn {
  /** Display name for the column */
  label?: string;

  /** Client-side index of the column in the table */
  position?: number;

  /**
   * Raw SQL expression for the calculated column
   * Use 'main' as the alias for the main table
   * @example 'SELECT COUNT(*) FROM orders WHERE orders.user_id = main.id'
   */
  sqlExpression: string;

  /**
   * Alias for the calculated column in SQL results and display
   * This will be used as both the SQL alias and the property name in result objects
   */
  alias: string;
}

export enum TableFetchStrategy {
  databaseTable = 'databaseTable',
  rawSqlQuery = 'rawSqlQuery',
  customFetch = 'customFetch',
}

export interface TablePageConfig {
  /** 
   * Set up using no-code 
   */

  table?: string;
  dataSource?: string;
  fetchStrategy: keyof typeof TableFetchStrategy;

  primaryKeyColumn?: string;
  
  /** 
   * @deprecated Deprecated since now users can now set page size in the UI 
   */
  pageSize?: number;
  
  columns?: TablePageConfigColumn[];
  calculatedColumns?: TablePageConfigCalculatedColumn[];

  allowInsert?: boolean;
  allowUpdate?: boolean;
  allowDelete?: boolean;

  allowedRoleIdsToInsert?: string[];
  allowedRoleIdsToUpdate?: string[];
  allowedRoleIdsToDelete?: string[];

  customSqlQuery?: string;
  customSqlCountQuery?: string;

  /** 
   * Set up using manual configuration
   */

  /**
   * Custom fetcher function to retrieve data.",1
"import { ROOT_USER_ID } from ""../constants/idp"";
import { ClientIdentityProviderUser, IdentityProviderUser, User } from ""../models/idp.model"";

export function checkUserForRoles(user: IdentityProviderUser | ClientIdentityProviderUser | User | ClientIdentityProviderUser, roleIds: string[]) {
  if (!user) {
    return false;
  }

  // It's assumed that the root user has all roles
  if (user.id === ROOT_USER_ID) {
    return true;
  }
  
  const userRoleIds = (('roles' in user ? user.roles?.map(r => r.id) : user.roleIds) || []).map(v => v.toString());
  return roleIds.some(rid => userRoleIds.includes(rid.toString()));
}",1
"      hiddenColumns,
      
      relationships: sortedRelationships,
      hiddenRelationships,
  
      allowInsert,
      allowedRoleIdsToInsert: tablePageConfig?.allowedRoleIdsToInsert,
      allowUpdate,
      allowedRoleIdsToUpdate: tablePageConfig?.allowedRoleIdsToUpdate,
      allowDelete,
      allowedRoleIdsToDelete: tablePageConfig?.allowedRoleIdsToDelete,

      pageSize: tablePageConfig?.pageSize ?? defaultTablePageSize,

      defaultSortColumn: tablePageConfig?.defaultSortColumn ?? primaryKeyColumn,
      defaultSortDirection: tablePageConfig?.defaultSortDirection ?? 'desc',
    },
  };
}",1
"import { IdentityProviderUser, InternalApiBody, InternalApiResult } from ""@kottster/common"";
import { Action } from ""../models/action.model"";

/**
 * Change the password of a current user
 */
export class ChangePassword extends Action {
  public async execute({ password, newPassword }: InternalApiBody<'changePassword'>, user: IdentityProviderUser): Promise<InternalApiResult<'changePassword'>> {
    const isPasswordVerified = user.passwordHash && await this.app.identityProvider.verifyPassword(password, user.passwordHash);
    if (!isPasswordVerified) {
      throw new Error('Password is incorrect');
    }

    await this.app.identityProvider.updateUserPassword(user.id, newPassword);",1
" * Delete the role
 */
export class DeleteRole extends Action {
  protected requiredPermissions = [IdentityProviderUserPermission.manage_users];
  
  public async execute({ roleId }: InternalApiBody<'deleteRole'>): Promise<InternalApiResult<'deleteRole'>> {
    await this.app.identityProvider.deleteRole(roleId);
  }
}",1
"import { IdentityProviderUser, InternalApiBody, InternalApiResult, Page, Stage } from ""@kottster/common"";
import { Action } from ""../models/action.model"";
import { FileReader } from ""../services/fileReader.service"";

/**
 * Get the app data
 */
export class GetApp extends Action {
  private cachedPages: Page[] | null = null;

  public async execute(_: InternalApiBody<'getApp'>, user?: IdentityProviderUser): Promise<InternalApiResult<'getApp'>> {
    
    const roles = user ? await this.app.identityProvider.getRoles() : [];
    const userPermissions = user ? await this.app.identityProvider.getUserPermissions(user.id) : [];
    const fileReader = new FileReader(this.app.stage === Stage.development);

    // Cache pages in production to avoid reading files every time
    const pages = this.app.stage === Stage.production && this.cachedPages
      ? this.cachedPages
      : this.app.loadedPageConfigs;
    
    if (this.app.stage === Stage.production && !this.cachedPages) {
      this.cachedPages = pages;
    }
    
    // In production, use the in-memory schema; in development, read from file
    const appSchema = this.app.stage === Stage.production ? this.app.schema : fileReader.readSchemaJsonFile();

    return {
      schema: {
        ...appSchema,
        pages,
        dataSources: this.app.dataSources.map((dataSource) => {
          return {
            name: dataSource.name,
            type: dataSource.type,
          };
        }),
        enterpriseHub: appSchema.enterpriseHub,
      },

      user,
      roles,
      userPermissions,
    };
  }
}",1
"import { IdentityProviderUser, InternalApiBody, InternalApiResult } from ""@kottster/common"";
import { Action } from ""../models/action.model"";
import { KottsterApi } from ""../services/kottsterApi.service"";

const emptyResult: InternalApiResult<'getKottsterContext'> = {
  imposedLimits: {},
};

/**
 * Get the information about the current Kottster version, 
 * and what limits are in place for the kottster api token in use
 */
export class GetKottsterContext extends Action {
  public async execute(_: InternalApiBody<'getKottsterContext'>, user: IdentityProviderUser): Promise<InternalApiResult<'getKottsterContext'>> {
    const kottsterApi = new KottsterApi();
    const kottsterApiToken = this.app.getKottsterApiToken();
    if (!kottsterApiToken) {
      return emptyResult;
    }
",1
"import { generateRandomString, InternalApiBody, InternalApiResult } from ""@kottster/common"";
import { DevAction } from ""../models/action.model"";
import { FileWriter } from ""../services/fileWriter.service"";
import { randomUUID } from ""crypto"";
import { KottsterApi } from ""../services/kottsterApi.service"";

/**
 * Get the data source info
 */
export class InitApp extends DevAction {
  public async execute({ name, rootUsername, rootPassword }: InternalApiBody<'initApp'>): Promise<InternalApiResult<'initApp'>> {
    const fileWrtier = new FileWriter({ usingTsc: this.app.usingTsc });
    const id = randomUUID();

    // Get API token from Kottster API
    let apiToken: string | undefined = undefined;
    try {",1
" * Install the required packages for the data source
 */
export class InstallPackagesForDataSource extends DevAction {
  public async execute(data: InternalApiBody<'installPackagesForDataSource'>): Promise<InternalApiResult<'installPackagesForDataSource'>> {
    return new Promise((resolve, reject) => {
      const { type } = data;

      const command = this.getCommand(type);
      exec(command, { cwd: PROJECT_DIR }, (error) => {
        if (error) {
          console.error(`Error executing command: ${error}`);
          reject(error);",1
"import { IdentityProviderUser, InternalApiBody, InternalApiResult } from ""@kottster/common"";
import { Action } from ""../models/action.model"";

/**
 * Log out all sessions of a current user
 */
export class LogOutAllSessions extends Action {
  public async execute({ password }: InternalApiBody<'logOutAllSessions'>, user: IdentityProviderUser): Promise<InternalApiResult<'logOutAllSessions'>> {
    const isPasswordVerified = user.passwordHash && await this.app.identityProvider.verifyPassword(password, user.passwordHash);
    if (!isPasswordVerified) {
      throw new Error('Current password is incorrect');
    }

    await this.app.identityProvider.invalidateAllSessions(user.id);",1
"import { IdentityProviderUser, InternalApiBody, InternalApiResult } from ""@kottster/common"";
import { Action } from ""../models/action.model"";
import { Request } from ""express"";

/**
 * Login into an account
 */
export class Login extends Action {
  public async execute({ usernameOrEmail, password, newPassword }: InternalApiBody<'login'>, _: IdentityProviderUser, req?: Request): Promise<InternalApiResult<'login'>> {
    const rootUser = this.app.identityProvider.getRootUserByUsername(usernameOrEmail);
    const ipAddress = this.getClientIp(req);

    // Fake await to mitigate timing attacks
    await new Promise((resolve) => setTimeout(resolve, 500));
",1
"export class UpdateRole extends Action {
  protected requiredPermissions = [IdentityProviderUserPermission.manage_users];

  public async execute({ roleId, role }: InternalApiBody<'updateRole'>): Promise<InternalApiResult<'updateRole'>> {
    const updatedRole = await this.app.identityProvider.updateRole(roleId, role);

    return {
      role: this.app.identityProvider.prepareRoleForClient(updatedRole),
    }
  }
}",1
"import { IdentityProviderUser, IdentityProviderUserPermission, InternalApiBody, InternalApiResult } from ""@kottster/common"";
import { Action } from ""../models/action.model"";

/**
 * Update the user
 */
export class UpdateUser extends Action {
  public async execute({ userId, user, newPassword }: InternalApiBody<'updateUser'>, currentUser: IdentityProviderUser): Promise<InternalApiResult<'updateUser'>> {
    const hasPermission = await this.app.identityProvider.userHasPermissions(currentUser.id, [IdentityProviderUserPermission.manage_users]);
    if (!hasPermission && currentUser.id !== userId) {
      throw new Error(""You don't have permission to update this user"");
    }

    const updatedUser = await this.app.identityProvider.updateUser(userId, user);",1
"import { ExtendAppContextFunction } from '../models/appContext.model';
import { PROJECT_DIR } from '../constants/projectDir';
import { AppSchema, checkTsUsage, DataSource, Stage, RpcActionBody, TablePageGetRecordsInput, TablePageDeleteRecordInput, TablePageUpdateRecordInput, TablePageCreateRecordInput, isSchemaEmpty, schemaPlaceholder, TablePageGetRecordInput, Page, TablePageConfig, TablePageCustomDataFetcherInput, TablePageGetRecordsResult, DashboardPageConfig, DashboardPageGetStatDataInput, DashboardPageGetCardDataInput, DashboardPageGetStatDataResult, DashboardPageGetCardDataResult, checkUserForRoles, IdentityProviderUser, InternalApiSchema, PartialTablePageConfig, transformStringToTablePageNestedTableKey, PartialDashboardPageConfig, DashboardPageConfigStat, DashboardPageConfigCard, TablePageInitiateRecordsExportInput, TablePageInitiateRecordsExportResult, Procedure, ProcedureContext, normalizeAppBasePath } from '@kottster/common';
import { DataSourceRegistry } from './dataSourceRegistry';
import { ActionService } from '../services/action.service';
import { DataSourceAdapter } from '../models/dataSourceAdapter.model';
import { parse as parseCookie } from 'cookie';
import { Request, Response, NextFunction } from 'express';
import { createServer } from '../factories/createServer';
import { IdentityProvider } from './identityProvider';
import { HttpException, UnauthorizedException } from '../exceptions/httpException';
import { FileReader } from '../services/fileReader.service';
import { Exporter } from '../services/exporter.service';
import dayjs from 'dayjs';

type RequestHandler = (req: Request, res: Response, next: NextFunction) => void;

type PostAuthMiddleware = (user: IdentityProviderUser, request: Request) => void | Promise<void>;

export interface KottsterAppOptions {
  schema: AppSchema | Record<string, never>;

  /**
   * The secret key used to sign JWT tokens
   */
  secretKey?: string;

  /**
   * The root admin username
   */
  rootUsername?: string;

  /**
   * The root admin password
   */
  rootPassword?: string;

  /**
   * The root admin custom permissions
   */
  rootCustomPermissions?: string[];

  /**
   * The salt used to sign JWT tokens
   */
  jwtSecretSalt?: string;

  /**
   * The identity provider configuration
   */
  identityProvider?: IdentityProvider;

  /**
   * The Kottster API token for the appen.
   * If not provided, some features that require server-side requests to Kottster API will not work (e.g. sql query generation, AI features, etc.)
   */
  kottsterApiToken?: string;

  /** 
   * Custom validation middleware
   * @description This middleware will be called after the JWT token is validated. You can use it to perform additional checks or modify the request object.
   * @example https://kottster.app/docs/security/authentication#custom-validation-middleware 
   */
  postAuthMiddleware?: PostAuthMiddleware;

  /** Enable read-only mode */
  __readOnlyMode?: boolean;

  /** Custom token validation function */
  __ensureValidToken?: (request: Request) => Promise<EnsureValidTokenResponse>;
}

interface EnsureValidTokenResponse {
  isTokenValid: boolean;
  user: IdentityProviderUser | null;
  invalidTokenErrorMessage?: string;
}

/**
 * The main app class
 */
export class KottsterApp {
  public readonly appId: string;

  private readonly secretKey: string;
  private readonly kottsterApiToken?: string;

  public readonly usingTsc: boolean;
  public readonly readOnlyMode: boolean = false;
  public readonly stage: Stage = process.env.KOTTSTER_APP_STAGE === Stage.development ? Stage.development : Stage.production;
  public readonly basePath: string = '/';

  // TODO: store registry instead of data sources
  public dataSources: DataSource[] = [];

  public identityProvider: IdentityProvider;
  public exporter: Exporter;

  public schema: AppSchema;
  private customEnsureValidToken?: (request: Request) => Promise<EnsureValidTokenResponse>;
  private postAuthMiddleware?: PostAuthMiddleware;

  public loadedPageConfigs: Page[] = [];

  public loadPageConfigs(): Page[] {
    const isDevelopment = this.stage === Stage.development;
    const fileReader = new FileReader(isDevelopment);
    this.loadedPageConfigs = fileReader.getPageConfigs();

    return this.loadedPageConfigs;
  }

  public extendContext: ExtendAppContextFunction;

  public getSecretKey() {
    return `${this.secretKey}`;
  }

  public getKottsterApiToken() {
    return this.kottsterApiToken;
  }

  constructor(options: KottsterAppOptions) {
    this.appId = options.schema.id ?? '';
    this.secretKey = options.secretKey ?? '';
    this.kottsterApiToken = options.kottsterApiToken;
    this.usingTsc = checkTsUsage(PROJECT_DIR);
    this.schema = (!isSchemaEmpty(options.schema) ? options.schema : schemaPlaceholder) as AppSchema;
    this.customEnsureValidToken = options.__ensureValidToken;
    this.postAuthMiddleware = options.postAuthMiddleware;
    this.readOnlyMode = options.__readOnlyMode ?? false;
    
    // Set base path
    const basePath = options.schema.basePath;
    if (basePath) {
      this.basePath = normalizeAppBasePath(basePath);
    }

    // Set identity provider
    if (!options.identityProvider) {
      throw new Error('Your KottsterApp must be configured with an identity provider. See https://kottster.app/docs/upgrade-to-v3-2 for more details.');
    } else {
      this.identityProvider = options.identityProvider;
      this.identityProvider.setApp(this);
    }

    // Set up exporter
    this.exporter = new Exporter();
  }

  async initialize() {
    await this.identityProvider.initialize();
  }

  /**
   * Load from a data source registry
   * @param registry The data source registry
   */
  public loadFromDataSourceRegistry(registry: DataSourceRegistry<{}>) {
    this.dataSources = Object.values(registry.dataSources);

    this.dataSources.forEach(dataSource => {
      const adapter = dataSource.adapter as DataSourceAdapter;

      if (this) {
        adapter.setApp(this);
        adapter.setData(dataSource);
        adapter.setTablesConfig(dataSource.tablesConfig);
        adapter.connect();
      };
    });
  }

  /**
   * Register a context middleware
   * @param fn The function to extend the context
   */
  public registerContextMiddleware(fn: ExtendAppContextFunction) {
    this.extendContext = fn;
  }

  public async executeAction(action: string, data: any, user?: IdentityProviderUser, req?: Request): Promise<any> {
    return await ActionService.getAction(this, action).executeWithCheckings(data, user, req);
  }

  /**
   * Get the middleware for the app
   * @param req The request object
   * @returns The middleware function
   */
  public getInternalApiRoute() {
    return async (req: Request, res: Response, next: NextFunction) => {
      if (req.method === 'GET') {
        next();
        return;
      }

      try {
        const result = await this.handleInternalApiRequest(req);

        if (result) {
          res.setHeader('Content-Type', 'application/json');
          res.status(200).json(result);
          return;
        } else {
          res.status(404).json({ error: 'Not Found' });
          return;
        }
      } catch (error) {
        if (error instanceof HttpException) {
          res.status(error.statusCode).json({
            status: 'error',
            statusCode: error.statusCode,
            message: error.message
          });
          return;
        }

        console.error('Internal API error:', error);
        res.status(500).json({ error: 'Internal Server Error' });
        return;
      }
    }
  }

  public getDownloadRoute() {
    return async (req: Request, res: Response) => {
      try {
        if (req.method !== 'GET') {
          res.status(405).json({ error: 'Method Not Allowed' });
          return;
        }

        const operationId = req.params.operationId;
        if (!operationId) {
          res.status(400).json({ error: 'Bad Request' });
          return;
        }

        const operation = this.exporter.getOperation(operationId);
        const dataSource = this.dataSources.find(ds => ds.name === operation?.dataSourceName);
        if (!operation || !dataSource) {
          res.status(404).json({ error: 'Not Found' });
          return;
        }

        const dataSourceAdapter = dataSource.adapter as DataSourceAdapter | undefined;
        if (!dataSourceAdapter) {
          throw new Error(`Data source adapter for ""${dataSource.name}"" not found`);
        }

        const stream = await dataSourceAdapter.getTableRecordsStream(
          ...operation.parameters
        );

        const filename = `export-${dayjs().format('YYYY-MM-DD-HH-mm-ss')}-${operationId}`;
        const headers = this.exporter.getHeadersByFormat(operation.format, filename);
        Object.entries(headers).forEach(([key, value]) => {
          res.setHeader(key, value);
        });

        switch (operation.format) {
          case 'json': {
            this.exporter.convertToJSON(stream, res);
            break;
          };
          case 'csv': {
            this.exporter.convertToCSV(stream, res);
            break;
          }
          case 'xlsx': {
            this.exporter.convertToXLSX(stream, res);
            break;
          }
          default: {
            throw new Error('Unsupported export format');
          }
        };
      } catch (error) {
        console.error('Export route error:', error);
        if (!res.headersSent) {
          res.status(500).json({ error: 'Export failed' });
        }
      }
    };
  }

  private async handleInternalApiRequest(request: Request): Promise<{
    status: 'success' | 'error';
    result?: any;
    error?: string;
  }> {
    try {
      const { isTokenValid, invalidTokenErrorMessage, user } = await this.ensureValidToken(request);

      const action = request.query.action as keyof InternalApiSchema | undefined;
      const actionData = request.body;

      if (!action) {
        throw new Error('Action not found in request');
      }

      if (!isTokenValid && action && !(['getApp', 'initApp', 'login'] as (keyof InternalApiSchema)[]).includes(action)) {
        throw new UnauthorizedException(`Invalid JWT token: ${invalidTokenErrorMessage}`);
      }

      return {
        status: 'success',
        result: await this.executeAction(action, actionData, user ?? undefined, request),
      };
    } catch (error) {
      // If the error is an instance of HttpException, we can rethrow it
      if (error instanceof HttpException) {
        throw error;
      }

      console.error('Kottster API error:', error);

      return {
        status: 'error',
        error: error.message,
      };
    }
  }

  /**
   * Define a custom controller
   * @param procedures The procedures
   * @returns The express request handler
   */
  public defineCustomController<T extends Record<string, Procedure>>(
    procedures: T
  ): RequestHandler & { procedures: T } {
    const func: RequestHandler = async (req, res) => {
      const { isTokenValid, user, invalidTokenErrorMessage } = await this.ensureValidToken(req);
      if (!isTokenValid || !user) {
        res.status(401).json({ error: `Invalid JWT token: ${invalidTokenErrorMessage}` });
        return;
      }

      const body = await req.body as RpcActionBody<'custom'>;
      const { procedure, procedureInput } = body.input;
      const ctx: ProcedureContext = {
        user: {
          id: user.id,
          username: user.username,
          email: user.email,
          firstName: user.firstName,
          lastName: user.lastName,
          roleIds: user.roleIds,
        },
        req,
      };

      if (procedure in procedures) {
        try {
          const result = await procedures[procedure](procedureInput, ctx);
          res.json({
            status: 'success',
            result,
          });
          return;
        } catch (error) {
          console.error(`Error executing procedure ""${procedure}"":`, error);
          res.status(500).json({
            status: 'error',
            error: error.message,
          });
          return;
        }
      }

      res.status(404).json({ error: `Procedure ""${procedure}"" not found` });
      return;
    };

    // Attach the procedures to the function for later reference
    (func as any).procedures = procedures;

    return func as RequestHandler & { procedures: T };
  }

  /**
   * Define a dashboard controller
   * @param dashboardPageConfig The dashboard page config
   * @returns The express request handler
   */
  public defineDashboardController(partialDashboardPageConfig: PartialDashboardPageConfig) {
    const func: RequestHandler = async (req, res) => {
      const { isTokenValid, user, invalidTokenErrorMessage } = await this.ensureValidToken(req);
      if (!isTokenValid || !user) {
        res.status(401).json({ error: `Invalid JWT token: ${invalidTokenErrorMessage}` });
        return;
      }

      const page = (req as Request & { page?: Page }).page;
      if (!page || page.type !== 'dashboard') {
        res.status(404).json({ error: 'Specified page not found' });
        return;
      }

      // Merge the partial config with the page config
      const dashboardPageConfig: DashboardPageConfig = {
        ...page.config,
        ...partialDashboardPageConfig as Partial<DashboardPageConfig>,
        stats: [
          ...(page.config.stats ?? []),
          ...(partialDashboardPageConfig.stats ?? [])
        ].reduce((acc, stat) => {
          const existingIndex = acc.findIndex(s => s.key === stat.key);
          if (existingIndex >= 0) {
            acc[existingIndex] = { ...acc[existingIndex], ...stat } as DashboardPageConfigStat;
          } else {
            acc.push(stat as DashboardPageConfigStat);
          }
          return acc;
        }, [] as NonNullable<DashboardPageConfig['stats']>),
        cards: [
          ...(page.config.cards ?? []),
          ...(partialDashboardPageConfig.cards ?? [])
        ].reduce((acc, card) => {
          const existingIndex = acc.findIndex(c => c.key === card.key);
          if (existingIndex >= 0) {
            acc[existingIndex] = { ...acc[existingIndex], ...card } as DashboardPageConfigCard;
          } else {
            acc.push(card as DashboardPageConfigCard);
          }
          return acc;
        }, [] as NonNullable<DashboardPageConfig['cards']>)
      };

      try {
        const body = await req.body as RpcActionBody<'dashboard_getCardData' | 'dashboard_getStatData'>;
        let result: any;

        try {
          if (page.allowedRoleIds?.length && !checkUserForRoles(user, page.allowedRoleIds) && this.stage === Stage.production) {
            throw new Error('You do not have access to this page');
          }

          if (body.action === 'dashboard_getStatData') {
            const input = body.input as DashboardPageGetStatDataInput;
            const stat = dashboardPageConfig.stats?.find(s => s.key === input.statKey);
            if (!stat) {
              res.status(404).json({ error: `Specified stat ""${input.statKey}"" not found` });
              return;
            }

            if (stat.fetchStrategy === 'rawSqlQuery') {
              if (!stat.dataSource) {
                throw new Error(`Data source for stat not specified`);
              }

              const dataSource = this.dataSources.find(ds => ds.name === stat.dataSource);
              if (!dataSource) {
                throw new Error(`Data source ""${stat.dataSource}"" not found`);
              }

              const dataSourceAdapter = dataSource.adapter as DataSourceAdapter | undefined;
              if (!dataSourceAdapter) {
                throw new Error(`Data source adapter for ""${stat.dataSource}"" not found`);
              }

              result = await dataSourceAdapter.getStatData(input, stat);
            } else if (stat.fetchStrategy === 'customFetch') {
              if (!stat.customDataFetcher) {
                // Fallback to default result if no custom fetcher is provided
                console.warn(`Custom data fetcher for stat ""${stat.key}"" not specified`);
                result = {
                  value: 0,
                  total: 0,
                } as DashboardPageGetStatDataResult;
              } else {
                result = await stat.customDataFetcher(input);
              }
            }
          }
          else if (body.action === 'dashboard_getCardData') {
            const input = body.input as DashboardPageGetCardDataInput;
            const card = dashboardPageConfig.cards?.find(c => c.key === input.cardKey);
            if (!card) {
              res.status(404).json({ error: `Specified card ""${input.cardKey}"" not found` });
              return;
            }

            if (card.fetchStrategy === 'rawSqlQuery') {
              if (!card.dataSource) {
                throw new Error(`Data source for card not specified`);
              }

              const dataSource = this.dataSources.find(ds => ds.name === card.dataSource);
              if (!dataSource) {
                throw new Error(`Data source ""${card.dataSource}"" not found`);
              }

              const dataSourceAdapter = dataSource.adapter as DataSourceAdapter | undefined;
              if (!dataSourceAdapter) {
                throw new Error(`Data source adapter for ""${card.dataSource}"" not found`);
              }

              result = await dataSourceAdapter.getCardData(input, card);
            } else if (card.fetchStrategy === 'customFetch') {
              if (!card.customDataFetcher) {
                // Fallback to default result if no custom fetcher is provided
                console.warn(`Custom data fetcher for card ""${card.key}"" not specified`);
                result = {
                  items: [],
                } as DashboardPageGetCardDataResult;
              } else {
                result = await card.customDataFetcher(input);
              }
            }
          }
        } catch (error) {
          throw new Error(error);
        }

        res.json({
          status: 'success',
          result,
        });
      } catch (error) {
        if (error instanceof Error && error.message === 'Unauthorized') {
          return new Response('Unauthorized', { status: 401 });
        }

        console.error('Error executing dashboard RPC:', error);
        res.status(500).json({
          status: 'error',
          error: error.message,
        });
        return;
      }
    }

    return func;
  }

  /**
   * Define a table controller
   * @param dataSource The data source
   * @param pageSettings The page settings
   * @returns The express request handler
   */
  public defineTableController<T extends Record<string, Procedure>>(
    partialTablePageConfig: PartialTablePageConfig,
    procedures?: T
  ): RequestHandler & { procedures: T } {
    const func: RequestHandler = async (req, res, next) => {
      const { isTokenValid, user, invalidTokenErrorMessage } = await this.ensureValidToken(req);
      if (!isTokenValid || !user) {
        res.status(401).json({ error: `Invalid JWT token: ${invalidTokenErrorMessage}` });
        return;
      }

      const page = (req as Request & { page?: Page }).page;
      if (!page || page.type !== 'table') {
        res.status(404).json({ error: 'Specified page not found' });
        return;
      }

      // Merge the partial config with the page config
      const tablePageConfig: TablePageConfig = {
        ...page.config,
        ...partialTablePageConfig as Partial<TablePageConfig>,
        nested: {
          ...page.config.nested,
          ...Object.keys(partialTablePageConfig.nested || {}).reduce((acc, key) => {
            const tablePageNestedTableKey = transformStringToTablePageNestedTableKey(key);
            acc[key] = {
              // We need to pass these required properties for nested table config
              table: tablePageNestedTableKey[tablePageNestedTableKey.length - 1]?.table,
              fetchStrategy: 'databaseTable',

              ...page.config.nested?.[key],
              ...partialTablePageConfig.nested?.[key] as Partial<TablePageConfig>,
            };
            return acc;
          }, {} as Record<string, TablePageConfig>)
        }
      };


      try {
        // Check if specified data source exists
        const dataSource = this.dataSources.find(ds => ds.name === tablePageConfig.dataSource);
        if (!dataSource && (tablePageConfig.fetchStrategy === 'databaseTable' || tablePageConfig.fetchStrategy === 'rawSqlQuery')) {
          throw new Error(`Data source ""${tablePageConfig.dataSource}"" not found`);
        }

        const body = await req.body as RpcActionBody<'table_getRecords' | 'table_initiateRecordsExport' | 'table_getRecord' | 'table_createRecord' | 'table_updateRecord' | 'table_deleteRecord' | 'custom'>;
        const action = body.action;
        
        // TODO: add typeing for result
        let result: any;

        // If the request is a custom one, handle it by the custom controller
        if (action === 'custom') {
          return this.defineCustomController(procedures as T)(req, res, next);
        }

        try {
          const dataSourceAdapter = dataSource?.adapter as DataSourceAdapter | undefined;
          const databaseSchema = dataSourceAdapter ? await dataSourceAdapter.getDatabaseSchema() : undefined;

          if (page.allowedRoleIds?.length && !checkUserForRoles(user, page.allowedRoleIds) && this.stage === Stage.production) {
            throw new Error('You do not have access to this page');
          }

          // If the table select action is used and fetch strategy is 'customFetch', we need to execute the custom query right away
          if (body.action === 'table_getRecords' && tablePageConfig.fetchStrategy === 'customFetch') {
            result = tablePageConfig.customDataFetcher ? await tablePageConfig.customDataFetcher(body.input as TablePageCustomDataFetcherInput) : {
              records: [],
            } as TablePageGetRecordsResult;
          } else {
            if (!dataSource) {
              throw new Error(`Data source ""${tablePageConfig.dataSource}"" not found`);
            }
            if (!dataSourceAdapter) {
              throw new Error(`Data source adapter for ""${tablePageConfig.dataSource}"" not found`);
            }
            if (!databaseSchema) {
              throw new Error(`Database schema for ""${tablePageConfig.dataSource}"" not found`);
            }

            if (body.action === 'table_getRecords') {
              result = await dataSourceAdapter?.getTableRecords(tablePageConfig, body.input as TablePageGetRecordsInput, databaseSchema);
            } else if (body.action === 'table_initiateRecordsExport') {
              const operationId = this.exporter.createOperation({
                parameters: [
                  tablePageConfig, body.input as TablePageGetRecordsInput, databaseSchema,
                ],
                dataSourceName: dataSource.name,
                format: (body.input as TablePageInitiateRecordsExportInput).format,
              });
              result = {
                operationId
              } as TablePageInitiateRecordsExportResult;
            } else if (body.action === 'table_getRecord') {
              result = await dataSourceAdapter.getOneTableRecord(tablePageConfig, body.input as TablePageGetRecordInput, databaseSchema);
            } else if (body.action === 'table_createRecord') {
              if (tablePageConfig.allowedRoleIdsToInsert?.length && this.stage === Stage.production && !checkUserForRoles(user, tablePageConfig.allowedRoleIdsToInsert)) {
                throw new Error('You do not have permission to create records in this table');
              }

              result = await dataSourceAdapter.insertTableRecord(tablePageConfig, body.input as TablePageCreateRecordInput, databaseSchema);
            } else if (body.action === 'table_updateRecord') {
              if (tablePageConfig.allowedRoleIdsToUpdate?.length && this.stage === Stage.production && !checkUserForRoles(user, tablePageConfig.allowedRoleIdsToUpdate)) {
                throw new Error('You do not have permission to update records in this table');
              }

              result = await dataSourceAdapter.updateTableRecords(tablePageConfig, body.input as TablePageUpdateRecordInput, databaseSchema);
            } else if (body.action === 'table_deleteRecord') {
              if (tablePageConfig.allowedRoleIdsToDelete?.length && this.stage === Stage.production && !checkUserForRoles(user, tablePageConfig.allowedRoleIdsToDelete)) {
                throw new Error('You do not have permission to delete records in this table');
              }

              result = await dataSourceAdapter.deleteTableRecords(tablePageConfig, body.input as TablePageDeleteRecordInput, databaseSchema);
            };
          };
        } catch (error) {
          throw new Error(error);
        }

        res.json({
          status: 'success',
          result,
        });
      } catch (error) {
        if (error instanceof Error && error.message === 'Unauthorized') {
          return new Response('Unauthorized', { status: 401 });
        }

        console.error('Error executing table RPC:', error);
        res.status(500).json({
          status: 'error',
          error: error.message,
        });
        return;
      }
    };

    // Attach the procedures to the function for later reference
    (func as any).procedures = procedures;

    return func as RequestHandler & { procedures: T };
  };

  public createRequestWithPageDataMiddleware(pageConfig: Page): RequestHandler {
    const handler: RequestHandler = (req, res, next) => {
      (req as Request & { page?: Page }).page = pageConfig;

      next();
    };

    return handler;
  }

  private async ensureValidToken(request: Request): Promise<EnsureValidTokenResponse> {
    try {
      // If a custom token validation function is provided, use it
      if (this.customEnsureValidToken) {
        return this.customEnsureValidToken(request);
      }

      let token = request.get('authorization')?.replace('Bearer ', '');
      if (!token) {
        const cookieHeader = request.get('Cookie');
        const cookieData = parseCookie(cookieHeader ?? '');
        token = cookieData.jwtToken;
      }
      if (!token) {
        return {
          isTokenValid: false,
          user: null,
          invalidTokenErrorMessage: 'Invalid JWT token: token not passed'
        };
      }

      const user = await this.identityProvider.verifyTokenAndGetUser(token);

      // If a post-auth middleware is provided, call it
      if (this.postAuthMiddleware) {
        await this.postAuthMiddleware(user, request);
      }

      return {
        isTokenValid: true,
        user,
      };
    } catch (error) {
      return {
        isTokenValid: false,
        user: null,
        invalidTokenErrorMessage: error.message",1
"import { IdentityProviderUser, IdentityProviderRole, IdentityProviderUserPermission, ROOT_USER_ID, ClientIdentityProviderUser, IdentityProviderLoginAttempt, generateRandomString, Stage } from ""@kottster/common"";
import crypto from 'crypto';
import bcrypt from 'bcryptjs';
import { SignJWT, jwtVerify } from 'jose';
import { KottsterApp } from ""./app"";
import knex, { Knex } from ""knex"";

/**
 * Supported hashing algorithms
 */
export enum HashAlgorithm {
  bcrypt = 'bcrypt',
  sha256 = 'sha256',
}

/**
 * JWT payload interface
 */
export interface JwtPayload {
  id: IdentityProviderUser['id'];
  check: string;
  iat?: number;
  exp?: number;
}

export enum IdentityProviderStrategyType {
  sqlite = 'sqlite',
}

export interface IdentityProviderOptions {
  fileName: string;
  passwordHashAlgorithm: keyof typeof HashAlgorithm;
  jwtSecretSalt?: string;
  rootUsername?: string;
  rootPassword?: string;
  rootCustomPermissions?: string[];
}

/**
 * The identity provider
 */
export class IdentityProvider {
  private app: KottsterApp;
  
  private jwtSecretSalt?: string;
  private passwordHashAlgorithm: keyof typeof HashAlgorithm;
  private rootUserUsername?: string;
  private rootUserPassword?: string;
  private rootUserSalt?: string;
  private rootCustomPermissions: string[] = [];

  private db: Knex;

  constructor({ 
    fileName,
    jwtSecretSalt,
    passwordHashAlgorithm = HashAlgorithm.bcrypt,
    rootUsername,
    rootPassword,
    rootCustomPermissions,
  }: IdentityProviderOptions) {
    this.jwtSecretSalt = jwtSecretSalt;
    this.passwordHashAlgorithm = passwordHashAlgorithm;
    this.rootUserUsername = rootUsername;
    this.rootUserPassword = rootPassword;
    this.rootCustomPermissions = rootCustomPermissions || [];

    this.db = knex({
      client: 'better-sqlite3',
      connection: {
        filename: fileName
      },
      useNullAsDefault: true
    });
  }

  /**
   * Prepare a user object for sending to the client by removing sensitive fields
   * @param user - The user object to prepare
   * @returns The prepared user object
   */
  public prepareUserForClient(user: IdentityProviderUser): ClientIdentityProviderUser {
    user.passwordHash = '';
    user.twoFactorSecret = undefined;
    user.jwtTokenCheck = undefined;

    return user as ClientIdentityProviderUser; 
  }

  /**
   * Prepare a role object for sending to the client by removing sensitive fields
   * @param role - The role object to prepare
   * @returns The prepared role object
   */
  public prepareRoleForClient(role: IdentityProviderRole): IdentityProviderRole {
    return role; 
  }

  get jwtSecret(): string | undefined {
    const appId = this.app.appId;
    const secretKey = this.app ? this.app.getSecretKey() : '';

    return `${appId}${secretKey}${this.jwtSecretSalt || ''}`;
  }

  setApp(app: KottsterApp): void {
    this.app = app;
  }

  recordLoginAttempt(attempt: Omit<IdentityProviderLoginAttempt, ""id"" | ""attemptedAt"">): Promise<void> {
    return this.createdLoginAttempt(attempt);
  }

  getRootUserSalt(): string {
    if (this.rootUserSalt) {
      return this.rootUserSalt;
    }

    // Generate a random salt for the root user but only for production
    const salt = this.app.stage === Stage.development ? '' : generateRandomString(24);

    this.rootUserSalt = salt;
    return salt;
  }

  async updateRole(roleId: IdentityProviderRole['id'], role: Partial<IdentityProviderRole>): Promise<IdentityProviderRole> {
    const existingRole = await this.getRoleBy('id', roleId);
    if (!existingRole) {
      throw new Error(`Role with ID ""${roleId}"" not found`);
    }

    const roleData: any = {};
    if (role.name !== undefined) roleData.name = role.name;
    if (role.permissions !== undefined) roleData.permissions = JSON.stringify(role.permissions);
    roleData.updated_at = this.db.fn.now();
    await this.db('roles').where({ id: roleId }).update(roleData);

    const updatedRole = await this.getRoleBy('id', roleId);
    if (!updatedRole) {
      throw new Error(`Failed to update role with ID ""${roleId}""`);
    }

    return updatedRole;
  }

  async deleteRole(roleId: IdentityProviderRole['id']): Promise<void> {
    const existingRole = await this.getRoleBy('id', roleId);
    if (!existingRole) {
      throw new Error(`Role with ID ""${roleId}"" not found`);
    }

    await this.db('roles').where({ id: roleId }).delete();
  }

  async createUser(user: Omit<IdentityProviderUser, 'id' | 'passwordHash'>, password: string): Promise<IdentityProviderUser> {
    if (user.username && await this.getUserBy('username', user.username)) {
      throw new Error(`Username ""${user.username}"" is already taken`);
    }
    if (user.email && await this.getUserBy('email', user.email)) {
      throw new Error(`Email ""${user.email}"" is already taken`);
    }

    const passwordHash = password && await this.hashPassword(password);

    const finalData: any = {
      username: user.username,
      email: user.email,
      first_name: user.firstName,
      last_name: user.lastName,
      password_hash: passwordHash,
      avatar_url: user.avatarUrl,
      temporary_password: user.temporaryPassword,
      password_reset_token: user.passwordResetToken,
      two_factor_secret: user.twoFactorSecret,
      last_login_at: user.lastLoginAt,
      jwt_token_check: user.jwtTokenCheck,
      settings: user.settings ? JSON.stringify(user.settings) : null
    };
    
    const [userId] = await this.db('users').insert(finalData);
    
    if (user.roleIds && user.roleIds.length > 0) {
      const userRoles = user.roleIds.map(roleId => ({ user_id: userId, role_id: roleId }));
      await this.db('user_roles').insert(userRoles);
    }

    const createdUser = await this.getUserBy('id', userId);
    if (!createdUser) {
      throw new Error('Failed to create user');
    }

    return createdUser;
  }

  async updateUser(userId: IdentityProviderUser['id'], data: Partial<IdentityProviderUser>): Promise<IdentityProviderUser> {
    const existingUser = await this.getUserBy('id', userId);
    if (!existingUser) {
      throw new Error(`User with ID ""${userId}"" not found`);
    }

    if (data.username) {
      const otherUserWithSameUsername = await this.getUserWhere(q => q.where({ username: data.username }).whereNot({ id: existingUser.id }));
      if (otherUserWithSameUsername) {
        throw new Error(`Username ""${data.username}"" is already taken`);
      }
    }
    if (data.email) {
      const otherUserWithSameEmail = await this.getUserWhere(q => q.where({ email: data.email }).whereNot({ id: existingUser.id }));
      if (otherUserWithSameEmail) {
        throw new Error(`Email ""${data.email}"" is already taken`);
      }
    }

    if (Object.keys(data).length > 0 || data.settings !== undefined) {
      const finalData: any = {};
      if (data.username !== undefined) finalData.username = data.username;
      if (data.email !== undefined) finalData.email = data.email;
      if (data.firstName !== undefined) finalData.first_name = data.firstName;
      if (data.lastName !== undefined) finalData.last_name = data.lastName;
      if (data.avatarUrl !== undefined) finalData.avatar_url = data.avatarUrl;
      if (data.temporaryPassword !== undefined) finalData.temporary_password = data.temporaryPassword;
      if (data.passwordResetToken !== undefined) finalData.password_reset_token = data.passwordResetToken;
      if (data.twoFactorSecret !== undefined) finalData.two_factor_secret = data.twoFactorSecret;
      if (data.lastLoginAt !== undefined) finalData.last_login_at = data.lastLoginAt;
      if (data.jwtTokenCheck !== undefined) finalData.jwt_token_check = data.jwtTokenCheck;
      if (data.settings !== undefined) finalData.settings = JSON.stringify(data.settings);

      finalData.updated_at = this.db.fn.now();

      await this.db('users').where({ id: userId }).update(finalData);
    }

    if (data.roleIds !== undefined) {
      await this.db('user_roles').where({ user_id: userId }).delete();
      if (data.roleIds.length > 0) {
        const userRoles = data.roleIds.map(roleId => ({ user_id: userId, role_id: roleId }));
        await this.db('user_roles').insert(userRoles);
      }
    }

    const updatedUser = await this.getUserBy('id', userId);
    if (!updatedUser) {
      throw new Error(`Failed to update user with ID ""${userId}""`);
    }

    return updatedUser;
  }

  async updateUserPassword(userId: IdentityProviderUser['id'], newPassword: string, temporaryPassword?: boolean): Promise<void> {
    const existingUser = await this.getUserBy('id', userId);
    if (!existingUser) {
      throw new Error(`User with ID ""${userId}"" not found`);
    }

    const passwordHash = await this.hashPassword(newPassword);
    await this.db('users').where({ id: userId }).update({ password_hash: passwordHash, temporary_password: temporaryPassword ?? undefined });
  }

  async deleteUser(userId: IdentityProviderUser['id']): Promise<void> {
    if (this.isUserRoot(userId)) {
      throw new Error('Cannot delete root user');
    }

    const existingUser = await this.getUserBy('id', userId);
    if (!existingUser) {
      throw new Error(`User with ID ""${userId}"" not found`);
    }

    await this.db('users').where({ id: userId }).delete();
  }

  async getUserPermissions(userId: number | string): Promise<string[]> {
    if (this.isUserRoot(userId)) {
      return [
        ...Object.keys(IdentityProviderUserPermission) as string[],
        ...this.rootCustomPermissions,
      ];
    }

    const user = await this.getUserBy('id', userId);
    if (!user) return [];
    
    const userRoles = await this.getRolesByIds(user.roleIds || []);
    const permissions: string[] = [];

    userRoles.forEach(role => {
      if (role.permissions) {
        role.permissions.forEach(permission => {
          if (!permissions.includes(permission)) {
            permissions.push(permission);
          }
        });
      }
    });

    return permissions;
  }

  /**
   * Hash a password using the configured algorithm
   */
  async hashPassword(password: string): Promise<string> {
    switch (this.passwordHashAlgorithm) {
      case HashAlgorithm.bcrypt:
        return bcrypt.hash(password, 10);
      
      case HashAlgorithm.sha256:
        return crypto.createHash('sha256').update(password).digest('hex');
      
      default:
        throw new Error(`Unsupported hash algorithm: ${this.passwordHashAlgorithm}`);
    }
  }

  /**
   * Verify a password against a hash
   */
  async verifyPassword(password: string, hash: string): Promise<boolean> {
    switch (this.passwordHashAlgorithm) {
      case HashAlgorithm.bcrypt:
        return bcrypt.compare(password, hash);
      case HashAlgorithm.sha256: {
        const testHash = crypto.createHash('sha256').update(password).digest('hex');
        return testHash === hash;
      };
      default:
        throw new Error(`Unsupported hash algorithm: ${this.passwordHashAlgorithm}`);
    }
  }

  public getRootUserByUsername(username: string): IdentityProviderUser | undefined {
    if (!this.rootUserUsername || !this.rootUserPassword) {
      return undefined;
    }
    if (username !== this.rootUserUsername) {
      return undefined;
    }

    return {
      id: ROOT_USER_ID,
      username: this.rootUserUsername,
      passwordHash: '',
      roleIds: [],
      jwtTokenCheck: this.getRootUserSalt(),
    }
  };

  public getRootUserById(userId: number | string): IdentityProviderUser | undefined {
    if (!this.rootUserUsername || !this.rootUserPassword) {
      return undefined;
    }

    if (userId !== ROOT_USER_ID) {
      return undefined;
    }

    return {
      id: ROOT_USER_ID,
      username: this.rootUserUsername,
      passwordHash: '',
      roleIds: [],
      jwtTokenCheck: this.getRootUserSalt(),
    };
  }

  isUserRoot(userId: number | string): boolean {
    return userId === ROOT_USER_ID;
  }

  async authenticateRootUser(username: string, password: string): Promise<IdentityProviderUser> {
    if (!this.rootUserUsername || !this.rootUserPassword) {
      throw new Error('Root user not configured');
    }
    if (username !== this.rootUserUsername) {
      throw new Error('Invalid username/email or password');
    }

    const isValid = password === this.rootUserPassword;
    if (!isValid) {
      throw new Error('Invalid username/email or password');
    }

    const rootUser = this.getRootUserByUsername(username);
    if (!rootUser) {
      throw new Error('Root user not configured');
    }
    return rootUser;
  }

  /**
   * Authenticate a user by username/email and password
   * @param usernameOrEmail - Username or email to identify the user
   * @param password - Plain text password to check
   * @returns Authenticated user
   */
  async authenticateUser(usernameOrEmail: string, password: string): Promise<IdentityProviderUser> {
    const rootUser = this.getRootUserByUsername(usernameOrEmail);
    if (rootUser) {
      const isValid = await this.verifyPassword(password, this.rootUserPassword!);
      if (!isValid) {
        throw new Error('Invalid username/email or password');
      }

      return { ...rootUser };
    } else {
      const user = await this.getUserBy('username', usernameOrEmail) || await this.getUserBy('email', usernameOrEmail);
      if (!user) {
        throw new Error('Invalid username/email or password');
      }
      if (!user.passwordHash) {
        throw new Error('User has no password set');
      }
      
      const isValid = await this.verifyPassword(password, user.passwordHash);
      if (!isValid) {
        throw new Error('Invalid username/email or password');
      }
      return { ...user };
    }
  }

  /**
   * Generate a JWT token for the root user
   * @param expiresIn - Token expiration in seconds (default: 24h = 86400s)
   * @returns JWT token string
   */
  async generateTokenForRootUser(expiresIn: number = 86400, providedJwtSecret?: string): Promise<string> {
    const payload: JwtPayload = {
      id: ROOT_USER_ID,
      check: this.getRootUserSalt(),
    };

    const secret = new TextEncoder().encode(providedJwtSecret ?? this.jwtSecret);
    
    return await new SignJWT({ ...payload })
      .setProtectedHeader({ alg: 'HS256' })
      .setIssuedAt()
      .setExpirationTime(Math.floor(Date.now() / 1000) + expiresIn)
      .sign(secret);
  }

  /**
   * Generate a JWT token for a user
   * @param usernameOrEmail - Username or email to identify the user
   * @param expiresIn - Token expiration in seconds (default: 24h = 86400s)
   * @returns JWT token string
   */
  async generateToken(userId: number | string, expiresIn: number = 86400): Promise<string> {
    if (!this.jwtSecret) {
      throw new Error('JWT secret not configured');
    }

    const user = await this.getUserBy('id', userId);
    if (!user) {
      throw new Error('User not found');
    }

    let jwtTokenCheck = user.jwtTokenCheck;
    if (!jwtTokenCheck) {
      jwtTokenCheck = crypto.randomBytes(16).toString('hex');
      await this.updateUser(user.id, { jwtTokenCheck });
    }

    const payload: JwtPayload = {
      id: user.id,
      check: jwtTokenCheck,
    };

    const secret = new TextEncoder().encode(`${this.jwtSecret}`);
    
    return await new SignJWT({ ...payload })
      .setProtectedHeader({ alg: 'HS256' })
      .setIssuedAt()
      .setExpirationTime(Math.floor(Date.now() / 1000) + expiresIn)
      .sign(secret);
  }

  /**
   * Verify and decode a JWT token
   * @param token - JWT token to verify
   * @returns Decoded JWT payload or null if invalid
   */
  async verifyToken(token: string): Promise<JwtPayload | null> {
    if (!this.jwtSecret) {
      throw new Error('JWT secret not configured');
    }

    try {
      const secret = new TextEncoder().encode(this.jwtSecret);
      const { payload } = await jwtVerify(token, secret);
      return payload as unknown as JwtPayload;
    } catch (error) {
      return null;
    }
  }

  async verifyTokenAndGetUser(token: string): Promise<IdentityProviderUser> {
    const payload = await this.verifyToken(token);
    if (!payload || !payload.id) {
      throw new Error('Invalid token');
    }

    // If it's the root user, return the root user
    const rootUser = this.getRootUserById(payload.id);
    if (rootUser) {
      if (rootUser.jwtTokenCheck !== payload.check) {
        throw new Error('Invalid token');
      }

      return { ...rootUser };
    }
    
    const user = await this.getUserBy('id', payload.id);
    if (!user) {
      throw new Error('Invalid token');
    }
    if (user.jwtTokenCheck !== payload.check) {
      throw new Error('Invalid token');
    }
    
    return { ...user };
  }

  /**
   * Check if a user has a specific role by role ID
   */
  async userHasRole(userId: number | string, roleId: number | string): Promise<boolean> {
    const isRoot = this.isUserRoot(userId);
    if (isRoot) {
      return true;
    }
    
    const user = await this.getUserBy('id', userId);
    if (!user) return false;
    
    return user.roleIds?.includes(roleId) ?? false;
  }

  async userHasPermissions(userId: number | string, permissions: (keyof typeof IdentityProviderUserPermission | string)[]): Promise<boolean> {
    const isRoot = this.isUserRoot(userId);
    if (isRoot) {
      return true;
    }
    
    const userPermissions = await this.getUserPermissions(userId);
    for (const permission of permissions) {
      if (!userPermissions.includes(permission)) {
        return false;
      }
    }
    return true;
  }

  /**
   * Check if a user has a specific role by role name
   */
  async userHasRoleByName(userId: number | string, roleName: string): Promise<boolean> {
    const user = await this.getUserBy('id', userId);
    if (!user) return false;

    const role = await this.getRoleBy('name', roleName);
    if (!role) return false;
    
    return user.roleIds?.includes(role.id) ?? false;
  }

  /**
   * Get all roles for a specific user
   */
  async getUserRoles(userId: number | string): Promise<IdentityProviderRole[]> {
    const user = await this.getUserBy('id', userId);
    if (!user || !user.roleIds) return [];

    const roles = await this.getRolesByIds(user.roleIds);
    return roles;
  }

  public async initialize(): Promise<void> {
    await this.ensureTablesExist();
  }

  private async ensureTablesExist(): Promise<void> {
    const usersTableExists = await this.db.schema.hasTable('users');
    if (!usersTableExists) {
      await this.createUsersTable();
    }

    const rolesTableExists = await this.db.schema.hasTable('roles');
    if (!rolesTableExists) {
      await this.createRolesTable();
    }

    const userRolesTableExists = await this.db.schema.hasTable('user_roles');
    if (!userRolesTableExists) {
      await this.createUserRolesTable();
    }

    const loginAttemptsTableExists = await this.db.schema.hasTable('login_attempts');
    if (!loginAttemptsTableExists) {
      await this.createLoginAttemptsTable();
    }

    const schemaVersionsTableExists = await this.db.schema.hasTable('schema_versions');
    if (!schemaVersionsTableExists) {
      await this.createSchemaVersionsTable();
    }
  }

  private async createUsersTable(): Promise<void> {
    await this.db.schema.createTable('users', (table) => {
      table.increments('id').primary();
      table.string('username').nullable().index();
      table.string('email').nullable().index();
      table.string('first_name').nullable();
      table.string('last_name').nullable();
      table.string('password_hash').nullable();
      table.string('avatar_url').nullable();
      table.boolean('temporary_password').nullable().defaultTo(false);
      table.string('password_reset_token').nullable();
      table.string('two_factor_secret').nullable();
      table.timestamp('last_login_at').nullable();
      table.string('jwt_token_check').nullable();
      table.json('settings').nullable();
      table.timestamps(true, true);
    });
  }

  private async createRolesTable(): Promise<void> {
    await this.db.schema.createTable('roles', (table) => {
      table.increments('id').primary();
      table.string('name').nullable();
      table.json('permissions').nullable();
      table.timestamps(true, true);
    });
  }

  private async createUserRolesTable(): Promise<void> {
    await this.db.schema.createTable('user_roles', (table) => {
      table.integer('user_id').references('id').inTable('users').onDelete('CASCADE');
      table.integer('role_id').references('id').inTable('roles').onDelete('CASCADE');
      table.primary(['user_id', 'role_id']);
    });
  }

  private async createLoginAttemptsTable(): Promise<void> {
    await this.db.schema.createTable('login_attempts', (table) => {
      table.increments('id').primary();
      table.string('ip_address').nullable().index();
      table.string('identifier').nullable().index();
      table.integer('user_id').nullable().references('id').inTable('users').onDelete('SET NULL');
      table.boolean('success').nullable().defaultTo(false);
      table.string('failure_reason').nullable();
      table.string('user_agent').nullable();
      table.timestamp('attempted_at').defaultTo(this.db.fn.now()).index();
    });
  }

  private async createSchemaVersionsTable(): Promise<void> {
    await this.db.schema.createTable('schema_versions', (table) => {
      table.string('table_name').primary();
      table.integer('version').notNullable();
      table.timestamps(true, true);
    });

    // Insert initial version records for all tables
    await this.db('schema_versions').insert([
      { table_name: 'users', version: 1 },
      { table_name: 'roles', version: 1 },
      { table_name: 'user_roles', version: 1 },
      { table_name: 'login_attempts', version: 1 },
      { table_name: 'schema_versions', version: 1 }
    ]);
  }

  async getUserBy(field: 'id' | 'email' | 'username', value: string | number): Promise<IdentityProviderUser | null> {
    const user = await this.db('users').where({ [field]: value }).first();
    if (!user) return null;
    
    const roleIds = await this.db('user_roles')
      .where({ user_id: user.id })
      .pluck('role_id');
    
    return this.mapUserFromDb(user, roleIds);
  }

  async getUserWhere(where: Record<string, any> | ((qb: Knex.QueryBuilder) => void)): Promise<IdentityProviderUser | null> {
    const query = this.db('users');
    
    if (typeof where === 'function') {
      where(query);
    } else {
      query.where(where);
    }
    
    const user = await query.first();
    if (!user) return null;
    
    const roleIds = await this.db('user_roles')
      .where({ user_id: user.id })
      .pluck('role_id');
    
    return this.mapUserFromDb(user, roleIds);
  }

  async getUsers(): Promise<IdentityProviderUser[]> {
    const users = await this.db('users').select().orderBy('id', 'desc');
    
    const usersWithRoles = await Promise.all(
      users.map(async (user) => {
        const roleIds = await this.db('user_roles')
          .where({ user_id: user.id })
          .pluck('role_id');
        return this.mapUserFromDb(user, roleIds);
      })
    );
    
    return usersWithRoles;
  }

  private mapUserFromDb(dbUser: any, roleIds: any[]): IdentityProviderUser {
    return {
      id: dbUser.id,
      username: dbUser.username,
      email: dbUser.email,
      firstName: dbUser.first_name,
      lastName: dbUser.last_name,
      passwordHash: dbUser.password_hash,
      avatarUrl: dbUser.avatar_url,
      temporaryPassword: dbUser.temporary_password,
      passwordResetToken: dbUser.password_reset_token,
      twoFactorSecret: dbUser.two_factor_secret,
      lastLoginAt: dbUser.last_login_at,
      jwtTokenCheck: dbUser.jwt_token_check,
      settings: dbUser.settings ? JSON.parse(dbUser.settings) : undefined,
      createdAt: dbUser.created_at,
      updatedAt: dbUser.updated_at,
      roleIds
    };
  }

  // Role CRUD methods
  async createRole(role: Omit<IdentityProviderRole, 'id'>): Promise<IdentityProviderRole> {
    const roleData: any = {
      name: role.name,
      permissions: role.permissions ? JSON.stringify(role.permissions) : null,
    };
    
    const [roleId] = await this.db('roles').insert(roleData);",1
"import { IdentityProviderUser, IdentityProviderUserPermission, Stage } from ""@kottster/common"";
import { KottsterApp } from ""../core/app"";
import { Request } from ""express"";

/**
 * The base class for actions
 * @abstract
 */
export abstract class Action {
  constructor(protected readonly app: KottsterApp) {}

  protected requiredPermissions: (keyof typeof IdentityProviderUserPermission)[] = [];

  public async executeWithCheckings(data: unknown, user?: IdentityProviderUser, req?: Request): Promise<unknown> {
    // Ensure that user has the required permissions
    if (this.requiredPermissions.length > 0) {
      if (!user) {
        throw new Error(""This action requires authentication."");
      }

      for (const permission of this.requiredPermissions) {
        const hasPermission = await this.app.identityProvider.userHasPermissions(user.id, [permission]);

        if (!hasPermission) {
          throw new Error(`This action requires the '${permission}' permission.`);
        }
      }
    }

    return this.execute(data, user, req);
  };

  protected abstract execute(data: unknown, user?: IdentityProviderUser, req?: Request): Promise<unknown>;
}

/**
 * The base class for developer actions
 * @abstract
 */",1
"    }

    const tableAlias = 'main';
    let query = this.client(table).from({ [tableAlias]: table });
    let countQuery = options.includeCount ? this.client(table).from({ [tableAlias]: table }) : null;

    // Foreign record filter
    if (input.getByForeignRecord) {
      const { relationship, recordPrimaryKeyValue } = input.getByForeignRecord;
      if (relationship.relation === 'oneToMany' && relationship.targetTableForeignKeyColumn) {
        query.where(relationship.targetTableForeignKeyColumn, recordPrimaryKeyValue);
        countQuery?.where(relationship.targetTableForeignKeyColumn, recordPrimaryKeyValue);",1
export const VERSION = '3.3.1';,1
"const { describe, it } = require('node:test')
const assert = require('node:assert/strict')
const context = require('../../test-helpers/context')

describe('ctx.back([alt])', () => {
  it('should redirect to Referrer', () => {
    const ctx = context()
    ctx.req.headers.referrer = '/login'
    ctx.back()
    assert.equal(ctx.response.header.location, '/login')
  })

  it('should redirect to the same origin referrer', () => {
    const ctx = context()
    ctx.req.headers.host = 'example.com'
    ctx.req.headers.referrer = 'https://example.com/login'
    ctx.back()
    assert.equal(ctx.response.header.location, 'https://example.com/login')
  })

  it('should redirect to root if the same origin referrer is not present', () => {
    const ctx = context()
    ctx.req.headers.host = 'example.com'
    ctx.req.headers.referrer = 'https://other.com/login'
    ctx.back()
    assert.equal(ctx.response.header.location, '/')
  })

  it('should redirect to Referer', () => {
    const ctx = context()
    ctx.req.headers.referer = '/login'
    ctx.back()
    assert.equal(ctx.response.header.location, '/login')
  })

  it('should default to alt', () => {
    const ctx = context()
    ctx.back('/index.html')
    assert.equal(ctx.response.header.location, '/index.html')
  })

  it('should default redirect to /', () => {
    const ctx = context()
    ctx.back()
    assert.equal(ctx.response.header.location, '/')
  })
})",1
"   * @api public
   */

  back (alt) {
    const referrer = this.ctx.get('Referrer')
    if (referrer) {
      // referrer is a relative path
      if (referrer.startsWith('/')) {
        this.redirect(referrer)
        return
      }

      // referrer is an absolute URL, check if it's the same origin
      const url = new URL(referrer, this.ctx.href)
      if (url.host === this.ctx.host) {
        this.redirect(referrer)
        return
      }",1
"  filePath: string,
): boolean {
  const { fs } = config.server

  if (!fs.strict) return true

  if (config.fsDenyGlob(filePath)) return false

  if (config.safeModulePaths.has(filePath)) return true

  if (fs.allow.some((uri) => isFileInTargetPath(uri, filePath))) return true

  return false",1
"  expect,
  test,
} from 'vitest'
import type { Page } from 'playwright-chromium'
import WebSocket from 'ws'
import testJSON from '../safe.json'
import { browser, isServe, page, viteServer, viteTestUrl } from '~utils'

const __dirname = path.dirname(fileURLToPath(import.meta.url))

const getViteTestIndexHtmlUrl = () => {
  const srcPrefix = viteTestUrl.endsWith('/') ? '' : '/'
  // NOTE: viteTestUrl is set lazily
  return viteTestUrl + srcPrefix + 'src/'
}

const stringified = JSON.stringify(testJSON)

describe.runIf(isServe)('main', () => {
  beforeAll(async () => {
    await page.goto(getViteTestIndexHtmlUrl())
  })

  test('default import', async () => {
    await expect.poll(() => page.textContent('.full')).toBe(stringified)
  })

  test('named import', async () => {
    await expect.poll(() => page.textContent('.named')).toBe(testJSON.msg)
  })

  test('virtual svg module', async () => {
    await expect.poll(() => page.textContent('.virtual-svg')).toMatch('<svg')
  })

  test('safe fetch', async () => {
    await expect.poll(() => page.textContent('.safe-fetch')).toMatch('KEY=safe')
    await expect.poll(() => page.textContent('.safe-fetch-status')).toBe('200')
  })

  test('safe fetch with query', async () => {
    await expect
      .poll(() => page.textContent('.safe-fetch-query'))
      .toMatch('KEY=safe')
    await expect
      .poll(() => page.textContent('.safe-fetch-query-status'))
      .toBe('200')
  })

  test('safe fetch with special characters', async () => {
    await expect
      .poll(() => page.textContent('.safe-fetch-subdir-special-characters'))
      .toMatch('KEY=safe')
    await expect
      .poll(() =>
        page.textContent('.safe-fetch-subdir-special-characters-status'),
      )
      .toBe('200')
  })

  test('unsafe fetch', async () => {
    await expect
      .poll(() => page.textContent('.unsafe-fetch'))
      .toMatch('403 Restricted')
    await expect
      .poll(() => page.textContent('.unsafe-fetch-status'))
      .toBe('403')
  })

  test('unsafe HTML fetch', async () => {
    await expect
      .poll(() => page.textContent('.unsafe-fetch-html'))
      .toMatch('403 Restricted')
    await expect
      .poll(() => page.textContent('.unsafe-fetch-html-status'))
      .toBe('403')
  })

  test('unsafe fetch with special characters (#8498)', async () => {
    await expect.poll(() => page.textContent('.unsafe-fetch-8498')).toBe('')
    await expect
      .poll(() => page.textContent('.unsafe-fetch-8498-status'))
      .toBe('404')
  })

  test('unsafe fetch with special characters 2 (#8498)', async () => {
    await expect.poll(() => page.textContent('.unsafe-fetch-8498-2')).toBe('')
    await expect
      .poll(() => page.textContent('.unsafe-fetch-8498-2-status'))
      .toBe('404')
  })

  test('unsafe fetch import inline', async () => {
    await expect
      .poll(() => page.textContent('.unsafe-fetch-import-inline-status'))
      .toBe('403')
  })

  test('unsafe fetch raw query import', async () => {
    await expect
      .poll(() => page.textContent('.unsafe-fetch-raw-query-import-status'))
      .toBe('403')
  })

  test('unsafe fetch ?.svg?import', async () => {
    await expect
      .poll(() => page.textContent('.unsafe-fetch-query-dot-svg-import-status'))
      .toBe('403')
  })

  test('unsafe fetch .svg?import', async () => {
    await expect
      .poll(() => page.textContent('.unsafe-fetch-svg-status'))
      .toBe('403')
  })

  test('safe fs fetch', async () => {
    await expect
      .poll(() => page.textContent('.safe-fs-fetch'))
      .toBe(stringified)
    await expect
      .poll(() => page.textContent('.safe-fs-fetch-status'))
      .toBe('200')
  })

  test('safe fs fetch', async () => {
    await expect
      .poll(() => page.textContent('.safe-fs-fetch-query'))
      .toBe(stringified)
    await expect
      .poll(() => page.textContent('.safe-fs-fetch-query-status'))
      .toBe('200')
  })

  test('safe fs fetch with special characters', async () => {
    await expect
      .poll(() => page.textContent('.safe-fs-fetch-special-characters'))
      .toBe(stringified)
    await expect
      .poll(() => page.textContent('.safe-fs-fetch-special-characters-status'))
      .toBe('200')
  })

  test('unsafe fs fetch', async () => {
    await expect.poll(() => page.textContent('.unsafe-fs-fetch')).toBe('')
    await expect
      .poll(() => page.textContent('.unsafe-fs-fetch-status'))
      .toBe('403')
  })

  test('unsafe fs fetch', async () => {
    await expect.poll(() => page.textContent('.unsafe-fs-fetch-raw')).toBe('')
    await expect
      .poll(() => page.textContent('.unsafe-fs-fetch-raw-status'))
      .toBe('403')
  })

  test('unsafe fs fetch query 1', async () => {
    await expect
      .poll(() => page.textContent('.unsafe-fs-fetch-raw-query1'))
      .toBe('')
    await expect
      .poll(() => page.textContent('.unsafe-fs-fetch-raw-query1-status'))
      .toBe('403')
  })

  test('unsafe fs fetch query 2', async () => {
    await expect
      .poll(() => page.textContent('.unsafe-fs-fetch-raw-query2'))
      .toBe('')
    await expect
      .poll(() => page.textContent('.unsafe-fs-fetch-raw-query2-status'))
      .toBe('403')
  })

  test('unsafe fs fetch with special characters (#8498)', async () => {
    await expect.poll(() => page.textContent('.unsafe-fs-fetch-8498')).toBe('')
    await expect
      .poll(() => page.textContent('.unsafe-fs-fetch-8498-status'))
      .toBe('404')
  })

  test('unsafe fs fetch with special characters 2 (#8498)', async () => {
    await expect
      .poll(() => page.textContent('.unsafe-fs-fetch-8498-2'))
      .toBe('')
    await expect
      .poll(() => page.textContent('.unsafe-fs-fetch-8498-2-status'))
      .toBe('404')
  })

  test('unsafe fs fetch import inline', async () => {
    await expect
      .poll(() => page.textContent('.unsafe-fs-fetch-import-inline-status'))
      .toBe('403')
  })

  test('unsafe fs fetch import inline wasm init', async () => {
    await expect
      .poll(() =>
        page.textContent('.unsafe-fs-fetch-import-inline-wasm-init-status'),
      )
      .toBe('403')
  })

  test('unsafe fs fetch with relative path after query status', async () => {
    await expect
      .poll(() =>
        page.textContent('.unsafe-fs-fetch-relative-path-after-query-status'),
      )
      .toBe('404')
  })

  test('nested entry', async () => {
    await expect.poll(() => page.textContent('.nested-entry')).toBe('foobar')
  })

  test('denied', async () => {
    await expect.poll(() => page.textContent('.unsafe-dotenv')).toBe('403')
  })

  test('denied EnV casing', async () => {
    // It is 403 in case insensitive system, 404 in others
    await expect
      .poll(() => page.textContent('.unsafe-dotEnV-casing'))
      .toStrictEqual(expect.toBeOneOf(['403', '404']))
  })

  test('denied env with ?.svg?.wasm?init', async () => {
    await expect
      .poll(() => page.textContent('.unsafe-dotenv-query-dot-svg-wasm-init'))
      .toBe('403')
  })
})

describe('fetch', () => {
  test('serve with configured headers', async () => {
    const res = await fetch(viteTestUrl + '/src/')
    expect(res.headers.get('x-served-by')).toBe('vite')
  })
})

describe('cross origin', () => {
  const fetchStatusFromPage = async (page: Page, url: string) => {
    return await page.evaluate(async (url: string) => {
      try {
        const res = await globalThis.fetch(url)
        return res.status
      } catch {
        return -1
      }
    }, url)
  }

  const connectWebSocketFromPage = async (page: Page, url: string) => {
    return await page.evaluate(async (url: string) => {
      try {
        const ws = new globalThis.WebSocket(url, ['vite-hmr'])
        await new Promise<void>((resolve, reject) => {
          ws.addEventListener('open', () => {
            resolve()
            ws.close()
          })
          ws.addEventListener('error', () => {
            reject()
          })
        })
        return true
      } catch {
        return false
      }
    }, url)
  }

  const connectWebSocketFromServer = async (
    url: string,
    host: string,
    origin: string | undefined,
  ) => {
    try {
      const ws = new WebSocket(url, ['vite-hmr'], {
        headers: {
          Host: host,
          ...(origin ? { Origin: origin } : undefined),
        },
      })
      await new Promise<void>((resolve, reject) => {
        ws.addEventListener('open', () => {
          resolve()
          ws.close()
        })
        ws.addEventListener('error', () => {
          reject()
        })
      })
      return true
    } catch {
      return false
    }
  }

  describe('allowed for same origin', () => {
    beforeEach(async () => {
      await page.goto(getViteTestIndexHtmlUrl())
    })

    test('fetch HTML file', async () => {
      const status = await fetchStatusFromPage(page, viteTestUrl + '/src/')
      expect(status).toBe(200)
    })

    test.runIf(isServe)('fetch JS file', async () => {
      const status = await fetchStatusFromPage(
        page,
        viteTestUrl + '/src/code.js',
      )
      expect(status).toBe(200)
    })

    test.runIf(isServe)('connect WebSocket with valid token', async () => {
      const token = viteServer.config.webSocketToken
      const result = await connectWebSocketFromPage(
        page,
        `${viteTestUrl}?token=${token}`,
      )
      expect(result).toBe(true)
    })

    test('fetch with allowed hosts', async () => {
      const viteTestUrlUrl = new URL(viteTestUrl)
      const res = await fetch(viteTestUrl + '/src/index.html', {
        headers: { Host: viteTestUrlUrl.host },
      })
      expect(res.status).toBe(200)
    })

    test.runIf(isServe)(
      'connect WebSocket with valid token with allowed hosts',
      async () => {
        const viteTestUrlUrl = new URL(viteTestUrl)
        const token = viteServer.config.webSocketToken
        const result = await connectWebSocketFromServer(
          `${viteTestUrl}?token=${token}`,
          viteTestUrlUrl.host,
          viteTestUrlUrl.origin,
        )
        expect(result).toBe(true)
      },
    )

    test.runIf(isServe)(
      'connect WebSocket without a token without the origin header',
      async () => {
        const viteTestUrlUrl = new URL(viteTestUrl)
        const result = await connectWebSocketFromServer(
          viteTestUrl,
          viteTestUrlUrl.host,
          undefined,
        )
        expect(result).toBe(true)
      },
    )
  })

  describe('denied for different origin', async () => {
    let page2: Page
    beforeEach(async () => {
      page2 = await browser.newPage()
      await page2.goto('http://vite.dev/404')
    })
    afterEach(async () => {
      await page2.close()
    })

    test('fetch HTML file', async () => {
      const status = await fetchStatusFromPage(page2, viteTestUrl + '/src/')
      expect(status).not.toBe(200)
    })

    test.runIf(isServe)('fetch JS file', async () => {
      const status = await fetchStatusFromPage(
        page2,
        viteTestUrl + '/src/code.js',
      )
      expect(status).not.toBe(200)
    })

    test.runIf(isServe)('connect WebSocket without token', async () => {
      const result = await connectWebSocketFromPage(page, viteTestUrl)
      expect(result).toBe(false)

      const result2 = await connectWebSocketFromPage(
        page,
        `${viteTestUrl}?token=`,
      )
      expect(result2).toBe(false)
    })

    test.runIf(isServe)('connect WebSocket with invalid token', async () => {
      const token = viteServer.config.webSocketToken
      const result = await connectWebSocketFromPage(
        page,
        `${viteTestUrl}?token=${'t'.repeat(token.length)}`,
      )
      expect(result).toBe(false)

      const result2 = await connectWebSocketFromPage(
        page,
        `${viteTestUrl}?token=${'t'.repeat(token.length)}t`, // different length
      )
      expect(result2).toBe(false)
    })

    test('fetch with non-allowed hosts', async () => {
      // NOTE: fetch cannot be used here as `fetch` sets the correct `Host` header
      const res = await new Promise<http.IncomingMessage>((resolve, reject) => {
        http
          .get(
            viteTestUrl + '/src/index.html',
            {
              headers: {
                Host: 'vite.dev',
              },
            },
            (res) => {
              resolve(res)
            },
          )
          .on('error', (e) => {
            reject(e)
          })
      })
      expect(res.statusCode).toBe(403)
    })

    test.runIf(isServe)(
      'connect WebSocket with valid token with non-allowed hosts',
      async () => {
        const token = viteServer.config.webSocketToken
        const result = await connectWebSocketFromServer(
          `${viteTestUrl}?token=${token}`,
          'vite.dev',
          'http://vite.dev',
        )
        expect(result).toBe(false)

        const result2 = await connectWebSocketFromServer(
          `${viteTestUrl}?token=${token}`,
          'vite.dev',
          undefined,
        )
        expect(result2).toBe(false)
      },
    )
  })
})

describe.runIf(isServe)('invalid request', () => {
  const sendRawRequest = async (baseUrl: string, requestTarget: string) => {
    return new Promise<string>((resolve, reject) => {
      const parsedUrl = new URL(baseUrl)

      const buf: Buffer[] = []
      const client = net.createConnection(
        { port: +parsedUrl.port, host: parsedUrl.hostname },
        () => {
          client.write(
            [
              `GET ${encodeURI(requestTarget)} HTTP/1.1`,
              `Host: ${parsedUrl.host}`,
              'Connection: Close',
              '\r\n',
            ].join('\r\n'),
          )
        },
      )
      client.on('data', (data) => {
        buf.push(data)
      })
      client.on('end', (hadError) => {
        if (!hadError) {
          resolve(Buffer.concat(buf).toString())
        }
      })
      client.on('error', (err) => {
        reject(err)
      })
    })
  }

  const root = path
    .resolve(__dirname.replace('playground', 'playground-temp'), '..')
    .replace(/\\/g, '/')

  test('request with sendRawRequest should work', async () => {
    const response = await sendRawRequest(viteTestUrl, '/src/safe.txt')
    expect(response).toContain('HTTP/1.1 200 OK')
    expect(response).toContain('KEY=safe')
  })

  test('request with sendRawRequest should work with /@fs/', async () => {
    const response = await sendRawRequest(
      viteTestUrl,
      path.posix.join('/@fs/', root, 'root/src/safe.txt'),
    )
    expect(response).toContain('HTTP/1.1 200 OK')
    expect(response).toContain('KEY=safe')
  })

  test('should reject request that has # in request-target', async () => {
    const response = await sendRawRequest(
      viteTestUrl,
      '/src/safe.txt#/../../unsafe.txt',
    )
    expect(response).toContain('HTTP/1.1 400 Bad Request')
  })

  test('should reject request that has # in request-target with /@fs/', async () => {
    const response = await sendRawRequest(
      viteTestUrl,
      path.posix.join('/@fs/', root, 'root/src/safe.txt') +
        '#/../../unsafe.txt',
    )
    expect(response).toContain('HTTP/1.1 400 Bad Request')
  })

  test('should deny request to denied file when a request has /.', async () => {
    const response = await sendRawRequest(viteTestUrl, '/src/dummy.crt/.')
    expect(response).toContain('HTTP/1.1 403 Forbidden')
  })

  test('should deny request with /@fs/ to denied file when a request has /.', async () => {
    const response = await sendRawRequest(
      viteTestUrl,
      path.posix.join('/@fs/', root, 'root/src/dummy.crt/') + '.',
    )
    expect(response).toContain('HTTP/1.1 403 Forbidden')",1
"import path from 'path';
import { inspect } from 'util';

import { isAxiosError } from 'axios';
import express from 'express';

import { sha256String } from '../util/hash.js';
import {
  requestLoggerMiddleware,
  validateSessionMiddleware,
} from '../util/middlewares.js';

import {
  AccountNotLinkedToRequisition,
  GenericGoCardlessError,
  RateLimitError,
  RequisitionNotLinked,
} from './errors.js';
import { goCardlessService } from './services/gocardless-service.js';
import { handleError } from './util/handle-error.js';

const app = express();
app.use(requestLoggerMiddleware);

app.get('/link', function (req, res) {
  res.sendFile('link.html', { root: path.resolve('./src/app-gocardless') });
});

export { app as handlers };
app.use(express.json());
app.use(validateSessionMiddleware);

app.post('/status', async (req, res) => {
  res.send({
    status: 'ok',
    data: {
      configured: goCardlessService.isConfigured(),
    },
  });
});

app.post(
  '/create-web-token',
  handleError(async (req, res) => {
    const { institutionId } = req.body || {};
    const { origin } = req.headers;

    const { link, requisitionId } = await goCardlessService.createRequisition({
      institutionId,
      host: origin,
    });

    res.send({
      status: 'ok',
      data: {
        link,
        requisitionId,
      },
    });
  }),
);

app.post(
  '/get-accounts',
  handleError(async (req, res) => {
    const { requisitionId } = req.body || {};

    try {
      const { requisition, accounts } =
        await goCardlessService.getRequisitionWithAccounts(requisitionId);

      res.send({
        status: 'ok',
        data: {
          ...requisition,
          accounts: await Promise.all(
            accounts.map(async account =>
              account?.iban
                ? { ...account, iban: await sha256String(account.iban) }
                : account,
            ),
          ),
        },
      });
    } catch (error) {
      if (error instanceof RequisitionNotLinked) {
        res.send({
          status: 'ok',
          requisitionStatus: error.details.requisitionStatus,
        });
      } else {
        throw error;
      }
    }
  }),
);

app.post(
  '/get-banks',
  handleError(async (req, res) => {
    const { country, showDemo = false } = req.body || {};

    await goCardlessService.setToken();
    const data = await goCardlessService.getInstitutions(country);

    res.send({
      status: 'ok',
      data: showDemo
        ? [
            {
              id: 'SANDBOXFINANCE_SFIN0000',
              name: 'DEMO bank (used for testing bank-sync)',
            },
            ...data,
          ]
        : data,
    });
  }),
);

app.post(
  '/remove-account',
  handleError(async (req, res) => {
    const { requisitionId } = req.body || {};

    const data = await goCardlessService.deleteRequisition(requisitionId);
    if (data.summary === 'Requisition deleted') {
      res.send({
        status: 'ok',
        data,
      });
    } else {
      res.send({
        status: 'error',
        data: {
          data,
          reason: 'Can not delete requisition',
        },
      });
    }
  }),
);

app.post(
  '/transactions',
  handleError(async (req, res) => {
    const {
      requisitionId,
      startDate,
      endDate,
      accountId,
      includeBalance = true,
    } = req.body || {};

    try {
      if (includeBalance) {
        const {
          balances,
          institutionId,
          startingBalance,
          transactions: { booked, pending, all },
        } = await goCardlessService.getTransactionsWithBalance(
          requisitionId,
          accountId,
          startDate,
          endDate,
        );

        res.send({
          status: 'ok',
          data: {
            balances,
            institutionId,
            startingBalance,
            transactions: {
              booked,
              pending,
              all,
            },
          },
        });
      } else {
        const {
          institutionId,
          transactions: { booked, pending, all },
        } = await goCardlessService.getNormalizedTransactions(
          requisitionId,
          accountId,
          startDate,
          endDate,
        );

        res.send({
          status: 'ok',
          data: {
            institutionId,
            transactions: {
              booked,
              pending,
              all,
            },
          },
        });
      }
    } catch (error) {
      const headers = error.details?.response?.headers ?? {};

      const rateLimitHeaders = Object.fromEntries(
        Object.entries(headers).filter(([key]) =>
          key.startsWith('http_x_ratelimit'),
        ),
      );

      const sendErrorResponse = data =>
        res.send({
          status: 'ok',
          data: { ...data, details: error.details, rateLimitHeaders },
        });

      switch (true) {
        case error instanceof RequisitionNotLinked:
          sendErrorResponse({
            error_type: 'ITEM_ERROR',
            error_code: 'ITEM_LOGIN_REQUIRED',
            status: 'expired',
            reason:
              'Access to account has expired as set in End User Agreement',
          });
          break;
        case error instanceof AccountNotLinkedToRequisition:
          sendErrorResponse({
            error_type: 'INVALID_INPUT',
            error_code: 'INVALID_ACCESS_TOKEN',
            status: 'rejected',
            reason: 'Account not linked with this requisition',
          });
          break;
        case error instanceof RateLimitError:
          sendErrorResponse({
            error_type: 'RATE_LIMIT_EXCEEDED',
            error_code: 'NORDIGEN_ERROR',
            status: 'rejected',
            reason: 'Rate limit exceeded',
          });
          break;
        case error instanceof GenericGoCardlessError:
          console.log('Something went wrong', inspect(error, { depth: null }));
          sendErrorResponse({
            error_type: 'SYNC_ERROR',
            error_code: 'NORDIGEN_ERROR',
          });
          break;
        case isAxiosError(error):
          console.log(
            'Something went wrong',
            inspect(error.response?.data || error, { depth: null }),
          );
          sendErrorResponse({
            error_type: 'SYNC_ERROR',
            error_code: 'NORDIGEN_ERROR',
          });
          break;
        default:
          console.log('Something went wrong', inspect(error, { depth: null }));
          sendErrorResponse({
            error_type: 'UNKNOWN',
            error_code: 'UNKNOWN',
            reason: 'Something went wrong',
          });
          break;",1
"
/** @type {import('./bank.interface.js').IBank} */
export default {
  institutionIds: ['IntegrationBank'],

  normalizeAccount(account) {
    console.debug(
      'Available account properties for new institution integration',
      { account: JSON.stringify(account) },
    );

    return {
      account_id: account.id,
      institution: account.institution,
      mask: (account?.iban || '0000').slice(-4),
      iban: account?.iban || null,
      name: [
        account.name ?? account.displayName ?? account.product,
        printIban(account),
        account.currency,
      ]
        .filter(Boolean)
        .join(' '),
      official_name: account.product ?? `integration-${account.institution_id}`,
      type: 'checking',
    };
  },

  normalizeTransaction(transaction, _booked, editedTransaction = null) {
    const trans = editedTransaction ?? transaction;

    const date =
      trans.date ||
      transaction.bookingDate ||
      transaction.bookingDateTime ||
      transaction.valueDate ||
      transaction.valueDateTime;

    // If we couldn't find a valid date field we filter out this transaction
    // and hope that we will import it again once the bank has processed the
    // transaction further.
    if (!date) {
      return null;
    }

    const notes =
      trans.notes ??
      trans.remittanceInformationUnstructured ??
      trans.remittanceInformationUnstructuredArray?.join(' ');

    transaction.remittanceInformationUnstructuredArrayString =
      transaction.remittanceInformationUnstructuredArray?.join(',');
    transaction.remittanceInformationStructuredArrayString =
      transaction.remittanceInformationStructuredArray?.join(',');

    return {
      ...transaction,
      payeeName: trans.payeeName ?? formatPayeeName(trans),
      date: d.format(d.parseISO(date), 'yyyy-MM-dd'),
      notes,
    };
  },

  sortTransactions(transactions = []) {
    console.debug(
      'Available (first 10) transactions properties for new integration of institution in sortTransactions function',
      { top10Transactions: JSON.stringify(transactions.slice(0, 10)) },
    );
    return sortByBookingDateOrValueDate(transactions);
  },

  calculateStartingBalance(sortedTransactions = [], balances = []) {
    console.debug(
      'Available (first 10) transactions properties for new integration of institution in calculateStartingBalance function',
      {
        balances: JSON.stringify(balances),
        top10SortedTransactions: JSON.stringify(
          sortedTransactions.slice(0, 10),
        ),
      },
    );

    const currentBalance = balances
      .filter(item => SORTED_BALANCE_TYPE_LIST.includes(item.balanceType))
      .sort(
        (a, b) =>
          SORTED_BALANCE_TYPE_LIST.indexOf(a.balanceType) -
          SORTED_BALANCE_TYPE_LIST.indexOf(b.balanceType),",1
"  mockExtendAccountsAboutInstitutions,
  mockInstitution,
} from '../../services/tests/fixtures.js';
import IntegrationBank from '../integration-bank.js';

describe('IntegrationBank', () => {
  let consoleSpy;

  beforeEach(() => {
    consoleSpy = vi.spyOn(console, 'debug');
  });

  describe('normalizeAccount', () => {
    const account = mockExtendAccountsAboutInstitutions[0];

    it('should return a normalized account object', () => {
      const normalizedAccount = IntegrationBank.normalizeAccount(account);
      expect(normalizedAccount).toEqual({
        account_id: account.id,
        institution: mockInstitution,
        mask: '4321',
        iban: account.iban,
        name: 'account-example-one (XXX 4321) PLN',
        official_name: 'Savings Account for Individuals (Retail)',
        type: 'checking',
      });
    });

    it('should return a normalized account object with masked value ""0000"" when no iban property is provided', () => {
      const normalizedAccount = IntegrationBank.normalizeAccount({
        ...account,
        iban: undefined,
      });
      expect(normalizedAccount).toEqual({
        account_id: account.id,
        institution: mockInstitution,
        mask: '0000',
        iban: null,
        name: 'account-example-one PLN',
        official_name: 'Savings Account for Individuals (Retail)',
        type: 'checking',
      });
    });

    it('normalizeAccount logs available account properties', () => {
      IntegrationBank.normalizeAccount(account);
      expect(consoleSpy).toHaveBeenCalledWith(
        'Available account properties for new institution integration',
        {
          account: JSON.stringify(account),
        },
      );
    });
  });

  describe('sortTransactions', () => {
    const transactions = [
      {
        date: '2022-01-01',
        bookingDate: '2022-01-01',
        transactionAmount: { amount: '100', currency: 'EUR' },
      },
      {
        date: '2022-01-03',
        bookingDate: '2022-01-03',
        transactionAmount: { amount: '100', currency: 'EUR' },
      },
      {
        date: '2022-01-02',
        bookingDate: '2022-01-02',
        transactionAmount: { amount: '100', currency: 'EUR' },
      },
    ];
    const sortedTransactions = [
      {
        date: '2022-01-03',
        bookingDate: '2022-01-03',
        transactionAmount: { amount: '100', currency: 'EUR' },
      },
      {
        date: '2022-01-02',
        bookingDate: '2022-01-02',
        transactionAmount: { amount: '100', currency: 'EUR' },
      },
      {
        date: '2022-01-01',
        bookingDate: '2022-01-01',
        transactionAmount: { amount: '100', currency: 'EUR' },
      },
    ];

    it('should return transactions sorted by bookingDate', () => {
      const sortedTransactions = IntegrationBank.sortTransactions(transactions);
      expect(sortedTransactions).toEqual(sortedTransactions);
    });

    it('sortTransactions logs available transactions properties', () => {
      IntegrationBank.sortTransactions(transactions);
      expect(consoleSpy).toHaveBeenCalledWith(
        'Available (first 10) transactions properties for new integration of institution in sortTransactions function',
        { top10Transactions: JSON.stringify(sortedTransactions.slice(0, 10)) },
      );
    });
  });

  describe('calculateStartingBalance', () => {
    /** @type {import('../../gocardless-node.types.js').Transaction[]} */
    const transactions = [
      {
        bookingDate: '2022-01-01',
        transactionAmount: { amount: '100', currency: 'EUR' },
      },
      {
        bookingDate: '2022-02-01',
        transactionAmount: { amount: '100', currency: 'EUR' },
      },
      {
        bookingDate: '2022-03-01',
        transactionAmount: { amount: '100', currency: 'EUR' },
      },
    ];

    /** @type {import('../../gocardless-node.types.js').Balance[]} */
    const balances = [
      {
        balanceAmount: { amount: '1000.00', currency: 'EUR' },
        balanceType: 'interimBooked',
      },
    ];

    it('should return 0 when no transactions or balances are provided', () => {
      const startingBalance = IntegrationBank.calculateStartingBalance([], []);
      expect(startingBalance).toEqual(0);
    });

    it('should return 70000 when transactions and balances are provided', () => {
      const startingBalance = IntegrationBank.calculateStartingBalance(
        transactions,
        balances,
      );
      expect(startingBalance).toEqual(70000);
    });

    it('logs available transactions and balances properties', () => {
      IntegrationBank.calculateStartingBalance(transactions, balances);
      expect(consoleSpy).toHaveBeenCalledWith(
        'Available (first 10) transactions properties for new integration of institution in calculateStartingBalance function',
        {
          balances: JSON.stringify(balances),
          top10SortedTransactions: JSON.stringify(transactions.slice(0, 10)),
        },
      );
    });
  });
});",1
"import { inspect } from 'util';

export function handleError(func) {
  return (req, res) => {
    func(req, res).catch(err => {
      console.log('Error', req.originalUrl, inspect(err, { depth: null }));
      res.send({
        status: 'ok',
        data: {
          error_code: 'INTERNAL_ERROR',
          error_type: err.message ? err.message : 'internal-error',
        },",1
"  let rest = null;
  let auth = null;
  let username = null;
  let password = null;
  let baseUrl = null;
  if (!accessKey || !accessKey.match(/^.*\/\/.*:.*@.*$/)) {
    console.log(`Invalid SimpleFIN access key: ${accessKey}`);
    throw new Error(`Invalid access key`);
  }
  [scheme, rest] = accessKey.split('//');
  [auth, rest] = rest.split('@');
  [username, password] = auth.split(':');
  baseUrl = `${scheme}//${rest}`;",1
"import { CrawlImpl, CrawlSuccessResult } from '../type';
import { NetworkConnectionError, PageNotFoundError, TimeoutError } from '../utils/errorType';
import { htmlToMarkdown } from '../utils/htmlToMarkdown';
import { DEFAULT_TIMEOUT, withTimeout } from '../utils/withTimeout';

const mixinHeaders = {
  // 接受的内容类型
  'Accept':
    'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7',
  // 接受的编码方式
  'Accept-Encoding': 'gzip, deflate, br',
  // 接受的语言
  'Accept-Language': 'en-US,en;q=0.9,zh;q=0.8',
  // 缓存控制
  'Cache-Control': 'max-age=0',
  // 连接类型
  'Connection': 'keep-alive',
  // 表明请求来自哪个站点
  'Referer': 'https://www.google.com/',
  // 升级不安全请求
  'Upgrade-Insecure-Requests': '1',
  // 模拟真实浏览器的 User-Agent
  'User-Agent':
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36',
  // 防止跨站请求伪造
  'sec-ch-ua': '""Google Chrome"";v=""121"", ""Not A(Brand"";v=""99"", ""Chromium"";v=""121""',
  'sec-ch-ua-mobile': '?0',
  'sec-ch-ua-platform': '""Windows""',
  'sec-fetch-dest': 'document',
  'sec-fetch-mode': 'navigate',
  'sec-fetch-site': 'none',
  'sec-fetch-user': '?1',
};

export const naive: CrawlImpl = async (url, { filterOptions }) => {
  let res: Response;

  try {
    res = await withTimeout(
      fetch(url, {
        headers: mixinHeaders,
        signal: new AbortController().signal,
      }),
      DEFAULT_TIMEOUT,
    );
  } catch (e) {",1
"/**
 * Creates a `URL` object from a Node.js `IncomingMessage`, taking into account the protocol, host, and port.
 *
 * @param nodeRequest - The Node.js `IncomingMessage` or `Http2ServerRequest` object to extract URL information from.
 * @returns A `URL` object representing the request URL.
 */
function createRequestUrl(nodeRequest: IncomingMessage | Http2ServerRequest): URL {
  const {
    headers,
    socket,
    url = '',
    originalUrl,
  } = nodeRequest as IncomingMessage & { originalUrl?: string };
  const protocol =
    getFirstHeaderValue(headers['x-forwarded-proto']) ??
    ('encrypted' in socket && socket.encrypted ? 'https' : 'http');
  const hostname =
    getFirstHeaderValue(headers['x-forwarded-host']) ?? headers.host ?? headers[':authority'];

  if (Array.isArray(hostname)) {
    throw new Error('host value cannot be an array.');
  }

  let hostnameWithPort = hostname;
  if (!hostname?.includes(':')) {
    const port = getFirstHeaderValue(headers['x-forwarded-port']);
    if (port) {
      hostnameWithPort += `:${port}`;
    }
  }

  return new URL(originalUrl ?? url, `${protocol}://${hostnameWithPort}`);
}

/**
 * Extracts the first value from a multi-value header string.
 *
 * @param value - A string or an array of strings representing the header values.",1
"        ' the exported array in config/middleware.js'
    );
  }

  return koaCors({
    async origin(ctx) {
      if (!ctx.get('Origin')) {
        return '*';
      }

      let originList: string | string[];

      if (typeof origin === 'function') {
        originList = await origin(ctx);
      } else {
        originList = origin;
      }

      if (Array.isArray(originList)) {
        return originList.includes(ctx.get('Origin')) ? ctx.get('Origin') : '';
      }

      const parsedOrigin = originList.split(',').map((origin) => origin.trim());
      if (parsedOrigin.length > 1) {
        return parsedOrigin.includes(ctx.get('Origin')) ? ctx.get('Origin') : '';
      }

      return originList;
    },
    exposeHeaders: expose,
    maxAge,
    credentials,
    allowMethods: methods,
    allowHeaders: headers,",1
"    .string()
    .min(8, {
      id: translatedErrors.minLength.id,
      defaultMessage: 'Password must be at least 8 characters',
      values: { min: 8 },
    })
    .max(70, {
      id: translatedErrors.maxLength.id,
      defaultMessage: 'Password should be less than 70 characters',
    })
    .matches(/[a-z]/, {
      message: {
        id: 'components.Input.error.contain.lowercase',
        defaultMessage: 'Password must contain at least 1 lowercase letter',
      },
    })
    .matches(/[A-Z]/, {
      message: {
        id: 'components.Input.error.contain.uppercase',
        defaultMessage: 'Password must contain at least 1 uppercase letter',
      },
    })
    .matches(/\d/, {
      message: {
        id: 'components.Input.error.contain.number',
        defaultMessage: 'Password must contain at least 1 number',
      },
    })
    .required({
      id: translatedErrors.required.id,
      defaultMessage: 'Password is required',
    })
    .nullable(),
  confirmPassword: yup
    .string()
    .required({
      id: translatedErrors.required.id,
      defaultMessage: 'Confirm password is required',
    })
    .oneOf([yup.ref('password'), null], {
      id: 'components.Input.error.password.noMatch',
      defaultMessage: 'Passwords must match',
    })
    .nullable(),
  registrationToken: yup.string().required({
    id: translatedErrors.required.id,
    defaultMessage: 'Registration token is required',
  }),
});

const REGISTER_ADMIN_SCHEMA = yup.object().shape({
  firstname: yup
    .string()
    .trim()
    .required({
      id: translatedErrors.required.id,
      defaultMessage: 'Firstname is required',
    })
    .nullable(),
  lastname: yup.string().nullable(),
  password: yup
    .string()
    .min(8, {
      id: translatedErrors.minLength.id,
      defaultMessage: 'Password must be at least 8 characters',
      values: { min: 8 },
    })
    .max(70, {
      id: translatedErrors.maxLength.id,
      defaultMessage: 'Password should be less than 70 characters',
    })
    .matches(/[a-z]/, {
      message: {
        id: 'components.Input.error.contain.lowercase',
        defaultMessage: 'Password must contain at least 1 lowercase letter',
      },",1
"    .string()
    .min(8, {
      id: translatedErrors.minLength.id,
      defaultMessage: 'Password must be at least 8 characters',
      values: { min: 8 },
    })
    .test(
      'required-byte-size',
      'Password must be between 8 and 70 bytes',
      (value) => {
        if (!value) return false;
        const byteSize = new TextEncoder().encode(value).length;
        return byteSize >= 8 && byteSize <= 70;
      }
    )
    .matches(/[a-z]/, {
      message: {
        id: 'components.Input.error.contain.lowercase',
        defaultMessage: 'Password must contain at least 1 lowercase letter',
      },
    })
    .matches(/[A-Z]/, {
      message: {
        id: 'components.Input.error.contain.uppercase',
        defaultMessage: 'Password must contain at least 1 uppercase letter',
      },
    })
    .matches(/\d/, {
      message: {
        id: 'components.Input.error.contain.number',
        defaultMessage: 'Password must contain at least 1 number',
      },
    })
    .required({
      id: translatedErrors.required.id,
      defaultMessage: 'Password is required',
    })
    .nullable(),
  confirmPassword: yup
    .string()
    .required({
      id: translatedErrors.required.id,
      defaultMessage: 'Confirm password is required',
    })
    .oneOf([yup.ref('password'), null], {
      id: 'components.Input.error.password.noMatch',
      defaultMessage: 'Passwords must match',
    })
    .nullable(),
});

const ResetPassword = () => {
  const { formatMessage } = useIntl();
  const dispatch = useTypedDispatch();
  const navigate = useNavigate();
  const { search: searchString } = useLocation();
  const query = React.useMemo(() => new URLSearchParams(searchString), [searchString]);
  const { _unstableFormatAPIError: formatAPIError } = useAPIErrorHandler();

  const [resetPassword, { error }] = useResetPasswordMutation();

  const handleSubmit = async (body: ResetPassword.Request['body']) => {
    const res = await resetPassword(body);

    if ('data' in res) {
      dispatch(login({ token: res.data.token }));
      navigate('/');
    }
  };
  /**
   * If someone doesn't have a reset password token
   * then they should just be redirected back to the login page.
   */
  if (!query.get('code')) {
    return <Navigate to=""/auth/login"" />;
  }

  return (
    <UnauthenticatedLayout>
      <Main>
        <LayoutContent>
          <Column>
            <Logo />
            <Box paddingTop={6} paddingBottom={7}>
              <Typography tag=""h1"" variant=""alpha"">
                {formatMessage({
                  id: 'global.reset-password',
                  defaultMessage: 'Reset password',
                })}
              </Typography>
            </Box>
            {error ? (
              <Typography id=""global-form-error"" role=""alert"" tabIndex={-1} textColor=""danger600"">
                {isBaseQueryError(error)
                  ? formatAPIError(error)
                  : formatMessage({
                    id: 'notification.error',
                    defaultMessage: 'An error occurred',
                  })}
              </Typography>
            ) : null}
          </Column>
          <Form
            method=""POST""
            initialValues={{",1
"    .transform((value) => (value === '' || value === null ? undefined : value))
    .nullable()
    .min(8, {
      ...translatedErrors.minLength,
      values: { min: 8 },
    })
    .matches(/[a-z]/, {
      id: 'components.Input.error.contain.lowercase',
      defaultMessage: 'Password must contain at least one lowercase character',
    })
    .matches(/[A-Z]/, {
      id: 'components.Input.error.contain.uppercase',
      defaultMessage: 'Password must contain at least one uppercase character',
    })
    .matches(/\d/, {
      id: 'components.Input.error.contain.number',
      defaultMessage: 'Password must contain at least one number',
    }),
  confirmPassword: yup
    .string()
    .transform((value) => (value === '' ? null : value))",1
"
export const username = yup.string().min(1);

export const password = yup
  .string()
  .min(8)
  .test(
    'required-byte-size',
    'Password must be between 8 and 70 bytes',
    (value) => {
      if (!value) return false;
      const byteSize = new TextEncoder().encode(value).length;
      return byteSize >= 8 && byteSize <= 70;
    }
  )
  .matches(/[a-z]/, '${path} must contain at least one lowercase character')
  .matches(/[A-Z]/, '${path} must contain at least one uppercase character')
  .matches(/\d/, '${path} must contain at least one number');

export const roles = yup.array(yup.strapiID()).min(1);
",1
"    getService: jest.fn(() => {
      return {
        add: jest.fn((user) => {
          return user;
        }),
        issue: jest.fn(),
      };
    }),
  };
});

describe('user-permissions auth', () => {
  beforeAll(() => {
    global.strapi = mockStrapi;
  });

  describe('register', () => {
    test('accepts valid registration', async () => {
      const ctx = {
        state: {
          auth: {},
        },
        request: {
          body: { username: 'testuser', email: 'test@example.com', password: 'Testpassword1!' },
        },
        send: jest.fn(),
      };
      const authorization = auth({ strapi: global.strapi });
      await authorization.register(ctx);
      expect(ctx.send).toHaveBeenCalledTimes(1);
    });

    test('throws ValidationError when passed extra fields when allowedField is undefined', async () => {
      global.strapi = {
        ...mockStrapi,
        config: {
          get: jest.fn(() => {
            return {
              register: {
                // empty
              },
            };
          }),
        },
      };

      const ctx = {
        state: {
          auth: {},
        },
        request: {
          body: {
            confirmed: true,
            username: 'testuser',
            email: 'test@example.com',
            password: 'Testpassword1!',
          },
        },
        send: jest.fn(),
      };
      const authorization = auth({ strapi: global.strapi });
      await expect(authorization.register(ctx)).rejects.toThrow(errors.ValidationError);
      expect(ctx.send).toHaveBeenCalledTimes(0);
    });

    test('throws ValidationError when passed extra fields when allowedField is []', async () => {
      global.strapi = {
        ...mockStrapi,
        config: {
          get: jest.fn(() => {
            return {
              register: {
                allowedFields: [],
              },
            };
          }),
        },
      };

      const ctx = {
        state: {
          auth: {},
        },
        request: {
          body: {
            confirmed: true,
            username: 'testuser',
            email: 'test@example.com',
            password: 'Testpassword1!',
          },
        },
        send: jest.fn(),
      };
      const authorization = auth({ strapi: global.strapi });
      await expect(authorization.register(ctx)).rejects.toThrow(errors.ValidationError);
      expect(ctx.send).toHaveBeenCalledTimes(0);
    });

    test('allows exceptions from config register.allowedFields', async () => {
      global.strapi = {
        ...mockStrapi,
        config: {
          get: jest.fn(() => {
            return {
              register: {
                allowedFields: ['confirmed'],
              },
            };
          }),
        },
      };

      const ctx = {
        state: {
          auth: {},
        },
        request: {
          body: {
            confirmed: true,
            username: 'testuser',
            email: 'test@example.com',
            password: 'Testpassword1!',
          },
        },
        send: jest.fn(),
      };
      const authorization = auth({ strapi: global.strapi });
      await authorization.register(ctx);
      expect(ctx.send).toHaveBeenCalledTimes(1);
    });

    test('password does not follow custom validation pattern', async () => {
      global.strapi = {
        ...mockStrapi,
        config: {
          get: jest.fn((path) => {
            if (path === 'plugin::users-permissions.validationRules') {
              return {
                validatePassword(value) {
                  // Custom validation logic: at least 1 uppercase, 1 lowercase, and 1 number
                  const hasUpperCase = /[A-Z]/.test(value);
                  const hasLowerCase = /[a-z]/.test(value);
                  const hasNumber = /[0-9]/.test(value);
                  return hasUpperCase && hasLowerCase && hasNumber && value.length >= 6;
                },
              };
            }
            return {
              register: {
                allowedFields: [],
              },
            };
          }),
        },
      };

      const ctx = {
        state: {
          auth: {},
        },
        request: {
          body: {
            username: 'testuser',
            email: 'test@example.com',
            password: 'TestingPassword',
          },
        },
        send: jest.fn(),
      };
      const authorization = auth({ strapi: global.strapi });
      await expect(authorization.register(ctx)).rejects.toThrow(errors.ValidationError);
      expect(ctx.send).toHaveBeenCalledTimes(0);
    });

    test('password follows custom validation pattern', async () => {
      global.strapi = {
        ...mockStrapi,
        config: {
          get: jest.fn((path) => {
            if (path === 'plugin::users-permissions.validationRules') {
              return {
                validatePassword(value) {
                  // Custom validation logic: at least 1 uppercase, 1 lowercase, and 1 number
                  const hasUpperCase = /[A-Z]/.test(value);
                  const hasLowerCase = /[a-z]/.test(value);
                  const hasNumber = /[0-9]/.test(value);
                  return hasUpperCase && hasLowerCase && hasNumber && value.length >= 6;
                },
              };
            }
            return {
              register: {
                allowedFields: [],
              },
            };
          }),
        },
      };

      const ctx = {
        state: {
          auth: {},
        },
        request: {
          body: {
            username: 'testuser',
            email: 'test@example.com',
            password: 'Password123',
          },
        },
        send: jest.fn(),
      };
      const authorization = auth({ strapi: global.strapi });
      await authorization.register(ctx);
      expect(ctx.send).toHaveBeenCalledTimes(1);
    });
  });
});",1
"  yup.object({
    email: yup.string().email().required(),
    username: yup.string().required(),
    password: yup
      .string()
      .required()
      .test(async function (value) {
        if (typeof config?.validatePassword === 'function') {
          try {
            const isValid = await config.validatePassword(value);
            if (!isValid) {
              return this.createError({ message: 'Password validation failed.' });
            }
          } catch (error) {
            return this.createError({ message: error.message || 'An error occurred.' });
          }
        }
        return true;
      }),
  });

const sendEmailConfirmationSchema = yup.object({
  email: yup.string().email().required(),
});

const validateEmailConfirmationSchema = yup.object({
  confirmation: yup.string().required(),
});

const forgotPasswordSchema = yup
  .object({
    email: yup.string().email().required(),
  })
  .noUnknown();

const createResetPasswordSchema = (config) =>
  yup
    .object({
      password: yup
        .string()
        .required()
        .test(async function (value) {
          if (typeof config?.validatePassword === 'function') {
            try {
              const isValid = await config.validatePassword(value);
              if (!isValid) {
                return this.createError({ message: 'Password validation failed.' });
              }
            } catch (error) {
              return this.createError({ message: error.message || 'An error occurred.' });
            }
          }
          return true;
        }),

      passwordConfirmation: yup
        .string()
        .required()
        .oneOf([yup.ref('password')], 'Passwords do not match'),

      code: yup.string().required(),
    })
    .noUnknown();

const createChangePasswordSchema = (config) =>
  yup
    .object({
      password: yup
        .string()
        .required()
        .test(async function (value) {
          if (typeof config?.validatePassword === 'function') {
            try {
              const isValid = await config.validatePassword(value);
              if (!isValid) {
                return this.createError({ message: 'Password validation failed.' });",1
"          password: internals.newPassword,
        },
      });

      expect(res.statusCode).toBe(200);
    });
  });
});",1
" */
const statusToLookup: TransformWithContentType = (contentType, params) => {
  if (!contentTypes.hasDraftAndPublish(contentType)) {
    return params;
  }

  const lookup = params.lookup || {};

  switch (params?.status) {
    case 'published':
      return assoc(['lookup', 'publishedAt'], { $notNull: true }, params);
    case 'draft':",1
"import { omit, assoc, merge, curry } from 'lodash/fp';

import { async, contentTypes as contentTypesUtils, validate } from '@strapi/utils';

import { UID } from '@strapi/types';
import { wrapInTransaction, type RepositoryFactoryMethod } from './common';
import * as DP from './draft-and-publish';
import * as i18n from './internationalization';
import * as components from './components';

import { createEntriesService } from './entries';
import { pickSelectionParams } from './params';
import { createDocumentId } from '../../utils/transform-content-types-to-models';
import { getDeepPopulate } from './utils/populate';
import { transformParamsToQuery } from './transform/query';
import { transformParamsDocumentId } from './transform/id-transform';
import { createEventManager } from './events';
import * as unidirectionalRelations from './utils/unidirectional-relations';
import entityValidator from '../entity-validator';

const { validators } = validate;

// we have to typecast to reconcile the differences between validator and database getModel
const getModel = ((schema: UID.Schema) => strapi.getModel(schema)) as (schema: string) => any;

export const createContentTypeRepository: RepositoryFactoryMethod = (
  uid,
  validator = entityValidator
) => {
  const contentType = strapi.contentType(uid);
  const hasDraftAndPublish = contentTypesUtils.hasDraftAndPublish(contentType);

  // Define the validations that should be performed
  const sortValidations = ['nonAttributesOperators', 'dynamicZones', 'morphRelations'];
  const fieldValidations = ['scalarAttributes'];
  const filtersValidations = ['nonAttributesOperators', 'dynamicZones', 'morphRelations'];
  const populateValidations = {
    sort: sortValidations,
    field: fieldValidations,
    filters: filtersValidations,
    populate: ['nonAttributesOperators'],
  };

  const validateParams = async (params: any) => {
    const ctx = { schema: contentType, getModel };
    await validators.validateFilters(ctx, params.filters, filtersValidations);
    await validators.validateSort(ctx, params.sort, sortValidations);
    await validators.validateFields(ctx, params.fields, fieldValidations);
    await validators.validatePopulate(ctx, params.populate, populateValidations);

    // TODO: add validate status, locale, pagination

    return params;
  };

  const entries = createEntriesService(uid, validator);",1
"          strapi.documents(ARTICLE_UID)[methodName]({
            populate: ['categories', 'fakekey'],
          })
        ).rejects.toThrow(errors.ValidationError);
      });
    });
  });
});",1
"				expect(worker.postedData.length).toBe(1);

				expect(worker.scriptPath.toString()).toBe(
					'file://' + Path.resolve(Path.join('src', 'ServerRendererWorker.js'))
				);

				expect(worker.execArgv).toEqual(['--disallow-code-generation-from-strings']);

				expect(worker.workerData.configuration.cache.directory).toBe(
					Path.resolve(Path.join('happy-dom', 'cache'))
				);
				expect(worker.workerData.configuration.outputDirectory).toBe(
					Path.resolve(Path.join('happy-dom', 'render'))
				);

				expect(worker.workerData.configuration).toEqual({
					...DefaultServerRendererConfiguration,
					outputDirectory: Path.resolve(Path.join('happy-dom', 'render')),
					cache: {
						...DefaultServerRendererConfiguration.cache,
						directory: Path.resolve(Path.join('happy-dom', 'cache'))
					},
					worker: {
						...DefaultServerRendererConfiguration.worker,
						maxConcurrency: 10
					}
				});

				expect(worker.listeners.message.length).toBe(1);
				expect(worker.listeners.error.length).toBe(1);
				expect(worker.listeners.exit.length).toBe(1);
				expect(worker.postedData.length).toBe(1);

				const postedData = worker.postedData[0];
				worker.postedData = [];

				worker.listeners.message[0]({
					results: postedData.items.map((item) => ({
						url: item.url,
						content: '<html></html>',
						outputFile: null,
						error: null,
						pageConsole: '',
						pageErrors: [],
						status: 200,
						statusText: 'OK',
						headers: {
							test: 'value'
						}
					}))
				});
			}

			await new Promise((resolve) => setTimeout(resolve));

			// 10 workers are still open (no workers are terminated)
			expect(MockedWorker.openWorkers.length).toBe(10);

			// 4 workers are busy and are waiting for post message
			for (const worker of MockedWorker.openWorkers.slice(0, 4)) {
				expect(worker.listeners.message.length).toBe(1);
				expect(worker.postedData.length).toBe(1);
				const postedData = worker.postedData[0];
				worker.postedData = [];
				worker.listeners.message[0]({
					results: postedData.items.map((item) => ({
						url: item.url,
						content: '<html></html>',
						outputFile: null,
						error: null,
						pageConsole: '',
						pageErrors: [],
						status: 200,
						statusText: 'OK',
						headers: {
							test: 'value'
						}
					}))
				});
			}

			// 4 workers are free and idle
			for (const worker of MockedWorker.openWorkers.slice(4)) {
				expect(worker.postedData.length).toBe(0);
			}

			await new Promise((resolve) => setTimeout(resolve));

			// All workers have been terminated
			expect(MockedWorker.openWorkers.length).toBe(0);
			expect(MockedWorker.terminatedWorkers.length).toBe(10);

			expect(log).toEqual([
				Chalk.bold(`Rendering ${MockedURLList.length} pages...\n`),
				...MockedURLList.map((url) => Chalk.bold(`• Rendered page ""${url}""`)),
				Chalk.bold(`\nRendered ${MockedURLList.length} pages in 0 seconds\n`)
			]);

			expect(results!).toEqual(
				MockedURLList.map((url) => ({
					url,
					content: '<html></html>',
					outputFile: null,
					error: null,
					pageErrors: [],
					pageConsole: '',
					status: 200,
					statusText: 'OK',
					headers: {
						test: 'value'
					}
				}))
			);
		});

		it('Renders pages in workers with cache warmup.', async () => {
			const renderer = new ServerRenderer({
				cache: {
					warmup: true
				},
				worker: {
					maxConcurrency: 10
				}
			});
			let results: IServerRendererResult[];

			renderer.render(MockedURLList).then((r) => {
				results = r;
			});

			// Cache warmup opens 1 worker first
			expect(MockedWorker.openWorkers.length).toBe(1);

			const worker = MockedWorker.openWorkers[0];
			const postedData = worker.postedData[0];
			worker.postedData = [];
			worker.listeners.message[0]({
				results: postedData.items.map((item) => ({
					url: item.url,
					content: '<html>Warmup</html>',
					outputFile: null,
					error: null,
					pageConsole: '',
					pageErrors: [],
					status: 200,
					statusText: 'OK',
					headers: {
						test: 'value'
					}
				}))
			});

			await new Promise((resolve) => setTimeout(resolve));

			expect(MockedWorker.openWorkers.length).toBe(10);

			for (const worker of MockedWorker.openWorkers) {
				expect(worker.listeners.message.length).toBe(1);
				expect(worker.postedData.length).toBe(1);

				expect(worker.scriptPath.toString()).toBe(
					'file://' + Path.resolve(Path.join('src', 'ServerRendererWorker.js'))
				);

				expect(worker.execArgv).toEqual(['--disallow-code-generation-from-strings']);

				expect(worker.workerData.configuration.cache.directory).toBe(
					Path.resolve(Path.join('happy-dom', 'cache'))
				);
				expect(worker.workerData.configuration.outputDirectory).toBe(
					Path.resolve(Path.join('happy-dom', 'render'))",1
"export function traversePath<T extends object>(
	obj: T,
	realPath: (string | number | symbol)[],
	modifier?: (data: PathData) => undefined | unknown | void
): PathData | undefined {
	if (!realPath.length) return undefined;
	const path = [realPath[0]];

	let parent = obj;

	while (parent && path.length < realPath.length) {
		const key = path[path.length - 1] as keyof typeof parent;",1
"    }

    // Decode HTML entities such as &copy;
    output = he.decode(output);

    // Strip all HTML tags from plaintext output
    output = output.replace(/<(.|\n)+?>/g, '');

    // All done!
    return output;
};

// Validates, parses and returns injectable ejs parameters",1
"import ParseFile from './ParseFile';
import ParseRelation from './ParseRelation';
import TaskQueue from './TaskQueue';
import { RelationOp } from './ParseOp';
import type { Op } from './ParseOp';
import type ParseObject from './ParseObject';

export type AttributeMap = Record<string, any>;
export type OpsMap = Record<string, Op>;
export type ObjectCache = Record<string, string>;

export interface State {
  serverData: AttributeMap;
  pendingOps: OpsMap[];
  objectCache: ObjectCache;
  tasks: TaskQueue;
  existed: boolean;
}

export function defaultState(): State {
  return {
    serverData: {},
    pendingOps: [{}],
    objectCache: {},
    tasks: new TaskQueue(),
    existed: false,
  };
}

export function setServerData(serverData: AttributeMap, attributes: AttributeMap) {
  for (const attr in attributes) {
    if (typeof attributes[attr] !== 'undefined') {
      serverData[attr] = attributes[attr];
    } else {
      delete serverData[attr];
    }
  }
}

export function setPendingOp(pendingOps: OpsMap[], attr: string, op?: Op) {
  const last = pendingOps.length - 1;
  if (op) {
    pendingOps[last][attr] = op;
  } else {
    delete pendingOps[last][attr];
  }
}

export function pushPendingState(pendingOps: OpsMap[]) {
  pendingOps.push({});
}

export function popPendingState(pendingOps: OpsMap[]): OpsMap {
  const first = pendingOps.shift();
  if (!pendingOps.length) {
    pendingOps[0] = {};
  }
  return first;
}

export function mergeFirstPendingState(pendingOps: OpsMap[]) {
  const first = popPendingState(pendingOps);
  const next = pendingOps[0];
  for (const attr in first) {
    if (next[attr] && first[attr]) {
      const merged = next[attr].mergeWith(first[attr]);
      if (merged) {
        next[attr] = merged;
      }
    } else {
      next[attr] = first[attr];
    }
  }
}

export function estimateAttribute(
  serverData: AttributeMap,
  pendingOps: OpsMap[],
  object: ParseObject,
  attr: string
): any {
  let value = serverData[attr];
  for (let i = 0; i < pendingOps.length; i++) {
    if (pendingOps[i][attr]) {
      if (pendingOps[i][attr] instanceof RelationOp) {
        if (object.id) {
          value = (pendingOps[i][attr] as RelationOp).applyTo(value, object, attr);
        }
      } else {
        value = pendingOps[i][attr].applyTo(value);
      }
    }
  }
  return value;
}

export function estimateAttributes(
  serverData: AttributeMap,
  pendingOps: OpsMap[],
  object: ParseObject
): AttributeMap {
  const data = {};
  let attr;
  for (attr in serverData) {
    data[attr] = serverData[attr];
  }
  for (let i = 0; i < pendingOps.length; i++) {
    for (attr in pendingOps[i]) {
      if (pendingOps[i][attr] instanceof RelationOp) {
        if (object.id) {
          data[attr] = (pendingOps[i][attr] as RelationOp).applyTo(data[attr], object, attr);
        }
      } else {
        if (attr.includes('.')) {
          // similar to nestedSet function
          const fields = attr.split('.');
          const last = fields[fields.length - 1];
          let object = data;
          for (let i = 0; i < fields.length - 1; i++) {
            const key = fields[i];
            if (!(key in object)) {
              const nextKey = fields[i + 1];
              if (!isNaN(nextKey)) {
                object[key] = [];
              } else {
                object[key] = {};
              }
            } else {
              if (Array.isArray(object[key])) {
                object[key] = [...object[key]];
              } else {
                object[key] = { ...object[key] };
              }
            }
            object = object[key];
          }
          object[last] = pendingOps[i][attr].applyTo(object[last]);
        } else {
          data[attr] = pendingOps[i][attr].applyTo(data[attr]);
        }
      }
    }
  }
  return data;
}

/**
 * Allows setting properties/variables deep in an object.
 * Converts a.b into { a: { b: value } } for dot notation on Objects
 * Converts a.0.b into { a: [{ b: value }] } for dot notation on Arrays
 *
 * @param obj The object to assign the value to
 * @param key The key to assign. If it's in a deeper path, then use dot notation (`prop1.prop2.prop3`)
 * Note that intermediate object(s) in the nested path are automatically created if they don't exist.
 * @param value The value to assign. If it's an `undefined` then the key is deleted.
 */
function nestedSet(obj, key, value) {
  const paths = key.split('.');
  for (let i = 0; i < paths.length - 1; i++) {
    const path = paths[i];
    if (!(path in obj)) {
      const nextPath = paths[i + 1];
      if (!isNaN(nextPath)) {
        obj[path] = [];
      } else {
        obj[path] = {};
      }
    }
    obj = obj[path];
  }
  if (typeof value === 'undefined') {
    delete obj[paths[paths.length - 1]];
  } else {
    obj[paths[paths.length - 1]] = value;
  }
}

export function commitServerChanges(
  serverData: AttributeMap,
  objectCache: ObjectCache,
  changes: AttributeMap
) {
  const ParseObject = CoreManager.getParseObject();
  for (const attr in changes) {
    const val = changes[attr];
    nestedSet(serverData, attr, val);
    if (
      val &&
      typeof val === 'object' &&
      !(val instanceof ParseObject) &&",1
"type ToJSON<T> = {
  [K in keyof T]: Encode<T[K]>;
};

// Mapping of class names to constructors, so we can populate objects from the
// server with appropriate subclasses of ParseObject
const classMap: AttributeMap = {};

// Global counter for generating unique Ids for non-single-instance objects
let objectCount = 0;
// On web clients, objects are single-instance: any two objects with the same Id
// will have the same attributes. However, this may be dangerous default
// behavior in a server scenario",1
"jest.dontMock('../decode');
jest.dontMock('../encode');
jest.dontMock('../CoreManager');
jest.dontMock('../ObjectStateMutations');
jest.dontMock('../ParseFile');
jest.dontMock('../ParseGeoPoint');
jest.dontMock('../ParseOp');
jest.dontMock('../ParseRelation');
jest.dontMock('../TaskQueue');

const mockObject = function (className) {
  this.className = className;
};
mockObject.registerSubclass = function () {};
jest.setMock('../ParseObject', mockObject);
const CoreManager = require('../CoreManager').default;
CoreManager.setParseObject(mockObject);

const ObjectStateMutations = require('../ObjectStateMutations');
const ParseOps = require('../ParseOp');
const TaskQueue = require('../TaskQueue').default;

describe('ObjectStateMutations', () => {
  it('can apply server data', () => {
    const serverData = {};
    ObjectStateMutations.setServerData(serverData, { counter: 12 });
    expect(serverData).toEqual({ counter: 12 });
    ObjectStateMutations.setServerData(serverData, { counter: undefined });
    expect(serverData).toEqual({});
  });

  it('can set a pending op', () => {
    let pendingOps = [{}];
    const op = new ParseOps.IncrementOp(1);
    ObjectStateMutations.setPendingOp(pendingOps, 'counter', op);
    expect(pendingOps).toEqual([{ counter: op }]);

    pendingOps = [{}, {}];
    ObjectStateMutations.setPendingOp(pendingOps, 'counter', op);
    expect(pendingOps).toEqual([{}, { counter: op }]);

    ObjectStateMutations.setPendingOp(pendingOps, 'counter', null);
    expect(pendingOps).toEqual([{}, {}]);
  });

  it('can push a new pending state', () => {
    const pendingOps = [{}];
    ObjectStateMutations.pushPendingState(pendingOps);
    expect(pendingOps).toEqual([{}, {}]);

    ObjectStateMutations.pushPendingState(pendingOps);
    expect(pendingOps).toEqual([{}, {}, {}]);
  });

  it('can pop a pending state', () => {
    let pendingOps = [{}];
    let first = pendingOps[0];
    expect(ObjectStateMutations.popPendingState(pendingOps)).toBe(first);
    expect(pendingOps).toEqual([{}]);

    const op = new ParseOps.IncrementOp(1);
    pendingOps = [{ counter: op }, {}, {}];
    first = pendingOps[0];
    expect(ObjectStateMutations.popPendingState(pendingOps)).toBe(first);
    expect(pendingOps).toEqual([{}, {}]);
  });

  it('can merge the first op set into the next', () => {
    let pendingOps = [{ counter: new ParseOps.SetOp(1), name: new ParseOps.SetOp('foo') }, {}];
    ObjectStateMutations.mergeFirstPendingState(pendingOps);
    expect(pendingOps).toEqual([
      { counter: new ParseOps.SetOp(1), name: new ParseOps.SetOp('foo') },
    ]);

    pendingOps = [{ counter: new ParseOps.SetOp(1) }, { counter: new ParseOps.IncrementOp(1) }];
    ObjectStateMutations.mergeFirstPendingState(pendingOps);
    expect(pendingOps).toEqual([{ counter: new ParseOps.SetOp(2) }]);
  });

  it('can estimate an attribute value', () => {
    const serverData = { counter: 12 };
    const pendingOps = [{ counter: new ParseOps.IncrementOp(2), name: new ParseOps.SetOp('foo') }];
    expect(
      ObjectStateMutations.estimateAttribute(
        serverData,
        pendingOps,
        { className: 'someClass', id: 'someId' },
        'counter'
      )
    ).toBe(14);
    expect(
      ObjectStateMutations.estimateAttribute(
        serverData,
        pendingOps,
        { className: 'someClass', id: 'someId' },
        'name'
      )
    ).toBe('foo');

    pendingOps.push({
      counter: new ParseOps.IncrementOp(1),
      name: new ParseOps.SetOp('override'),
    });
    expect(
      ObjectStateMutations.estimateAttribute(
        serverData,
        pendingOps,
        { className: 'someClass', id: 'someId' },
        'counter'
      )
    ).toBe(15);
    expect(
      ObjectStateMutations.estimateAttribute(
        serverData,
        pendingOps,
        { className: 'someClass', id: 'someId' },
        'name'
      )
    ).toBe('override');

    pendingOps.push({ likes: new ParseOps.RelationOp([], []) });
    const relation = ObjectStateMutations.estimateAttribute(
      serverData,
      pendingOps,
      { className: 'someClass', id: 'someId' },
      'likes'
    );
    expect(relation.parent.id).toBe('someId');
    expect(relation.parent.className).toBe('someClass');
    expect(relation.key).toBe('likes');
  });

  it('can estimate all attributes', () => {
    const serverData = { counter: 12 };
    const pendingOps = [{ counter: new ParseOps.IncrementOp(2), name: new ParseOps.SetOp('foo') }];
    expect(
      ObjectStateMutations.estimateAttributes(serverData, pendingOps, 'someClass', 'someId')
    ).toEqual({
      counter: 14,
      name: 'foo',
    });

    pendingOps.push({
      counter: new ParseOps.IncrementOp(1),
      name: new ParseOps.SetOp('override'),
    });
    expect(
      ObjectStateMutations.estimateAttributes(serverData, pendingOps, 'someClass', 'someId')
    ).toEqual({
      counter: 15,
      name: 'override',
    });

    pendingOps.push({ likes: new ParseOps.RelationOp([], []) });
    const attributes = ObjectStateMutations.estimateAttributes(serverData, pendingOps, {
      className: 'someClass',
      id: 'someId',
    });
    expect(attributes.likes.parent.id).toBe('someId');
    expect(attributes.likes.parent.className).toBe('someClass');
    expect(attributes.likes.key).toBe('likes');
  });

  it('can estimate attributes for nested documents', () => {
    let serverData = { objectField: { counter: 10, letter: 'a' } };
    let pendingOps = [{ 'objectField.counter': new ParseOps.IncrementOp(2) }];
    expect(
      ObjectStateMutations.estimateAttributes(serverData, pendingOps, 'someClass', 'someId')
    ).toEqual({
      objectField: {
        counter: 12,
        letter: 'a',
      },
    });
    pendingOps = [{ 'objectField.counter': new ParseOps.SetOp(20) }];
    expect(
      ObjectStateMutations.estimateAttributes(serverData, pendingOps, 'someClass', 'someId')
    ).toEqual({
      objectField: {
        counter: 20,
        letter: 'a',
      },
    });
    serverData = {};
    pendingOps = [{ 'objectField.subField.subField.counter': new ParseOps.IncrementOp(20) }];
    expect(
      ObjectStateMutations.estimateAttributes(serverData, pendingOps, 'someClass', 'someId')
    ).toEqual({
      objectField: {
        subField: {
          subField: {
            counter: 20,
          },
        },
      },
    });
  });

  it('can estimate attributes for nested array documents', () => {
    // Test without initial value
    let serverData = { _id: 'someId', className: 'bug' };
    let pendingOps = [{ 'items.0.count': new ParseOps.IncrementOp(1) }];
    expect(
      ObjectStateMutations.estimateAttributes(serverData, pendingOps, 'someClass', 'someId')
    ).toEqual({
      _id: 'someId',
      items: [{ count: 1 }],
      className: 'bug',
    });

    // Test one level nested
    serverData = {
      _id: 'someId',
      items: [
        { value: 'a', count: 5 },
        { value: 'b', count: 1 },
      ],
      className: 'bug',
      number: 2,
    };
    pendingOps = [{ 'items.0.count': new ParseOps.IncrementOp(1) }];
    expect(
      ObjectStateMutations.estimateAttributes(serverData, pendingOps, 'someClass', 'someId')
    ).toEqual({
      _id: 'someId',
      items: [
        { value: 'a', count: 6 },
        { value: 'b', count: 1 },
      ],
      className: 'bug',
      number: 2,
    });

    // Test multiple level nested fields
    serverData = {
      _id: 'someId',
      items: [
        { value: { count: 54 }, count: 5 },
        { value: 'b', count: 1 },
      ],
      className: 'bug',
      number: 2,
    };
    pendingOps = [{ 'items.0.value.count': new ParseOps.IncrementOp(6) }];
    expect(
      ObjectStateMutations.estimateAttributes(serverData, pendingOps, 'someClass', 'someId')
    ).toEqual({
      _id: 'someId',
      items: [
        { value: { count: 60 }, count: 5 },
        { value: 'b', count: 1 },
      ],
      className: 'bug',
      number: 2,
    });
  });

  it('can commit changes from the server', () => {
    const serverData = {};
    const objectCache = {};
    ObjectStateMutations.commitServerChanges(serverData, objectCache, {
      name: 'foo',
      data: { count: 5 },
    });
    expect(serverData).toEqual({ name: 'foo', data: { count: 5 } });
    expect(objectCache).toEqual({ data: '{""count"":5}' });
  });

  it('can commit nested changes from the server', () => {
    const serverData = {};
    const objectCache = {};
    ObjectStateMutations.commitServerChanges(serverData, objectCache, {
      'name.foo': 'bar',
      data: { count: 5 },
    });
    expect(serverData).toEqual({ name: { foo: 'bar' }, data: { count: 5 } });
    expect(objectCache).toEqual({ data: '{""count"":5}' });
  });

  it('can commit dot notation array changes from the server', () => {
    const serverData = {
      items: [
        { value: 'a', count: 5 },
        { value: 'b', count: 1 },
      ],
    };
    ObjectStateMutations.commitServerChanges(
      serverData,
      {},
      {
        'items.0.count': 15,
        'items.1.count': 4,
      }
    );
    expect(serverData).toEqual({
      items: [
        { value: 'a', count: 15 },
        { value: 'b', count: 4 },
      ],
    });
  });

  it('can commit dot notation array changes from the server to empty serverData', () => {
    const serverData = {};
    ObjectStateMutations.commitServerChanges(
      serverData,
      {},
      {
        'items.0.count': 15,
        'items.1.count': 4,
      }
    );
    expect(serverData).toEqual({ items: [{ count: 15 }, { count: 4 }] });
  });

  it('can commit nested json array changes from the server to empty serverData', () => {
    const serverData = {};
    const objectCache = {};
    ObjectStateMutations.commitServerChanges(serverData, objectCache, {
      items: { '0': { count: 20 }, '1': { count: 5 } },
    });
    // Should not transform
    expect(serverData).toEqual({ items: { '0': { count: 20 }, '1': { count: 5 } } });
    expect(objectCache).toEqual({ items: '{""0"":{""count"":20},""1"":{""count"":5}}' });
  });

  it('can commit json array with PushStatus offset fields', () => {
    const serverData = {};
    const objectCache = {};
    ObjectStateMutations.commitServerChanges(serverData, objectCache, {
      sentPerUTCOffset: { '1': { count: 20 } },
      failedPerUTCOffset: { '5': { count: 25 } },
    });
    // Should not transform to an array
    expect(serverData).toEqual({
      sentPerUTCOffset: { '1': { count: 20 } },
      failedPerUTCOffset: { '5': { count: 25 } },
    });
    expect(objectCache).toEqual({
      sentPerUTCOffset: '{""1"":{""count"":20}}',
      failedPerUTCOffset: '{""5"":{""count"":25}}',
    });
  });

  it('can generate a default state for implementations', () => {
    expect(ObjectStateMutations.defaultState()).toEqual({
      serverData: {},
      pendingOps: [{}],
      objectCache: {},
      tasks: new TaskQueue(),
      existed: false,
    });
  });
});",1
"CoreManager.setRESTController(RESTController);
CoreManager.setEventuallyQueue(EventuallyQueue);
CoreManager.setInstallationController({
  currentInstallationId() {
    return Promise.resolve('iid');
  },
  currentInstallation() {},
  updateInstallationOnDisk() {},
});
CoreManager.set('APPLICATION_ID', 'A');
CoreManager.set('JAVASCRIPT_KEY', 'B');
CoreManager.set('MASTER_KEY', 'C');
CoreManager.set('VERSION', 'V');
// Register our mocks
jest.spyOn(CoreManager, 'getParseQuery').mockImplementation(() => mockQuery);
jest.spyOn(CoreManager, 'getEventuallyQueue').mockImplementation(() => EventuallyQueue);
jest.spyOn(CoreManager, 'getParseUser').mockImplementation(() => require('../ParseUser').default);

const { SetOp, UnsetOp, IncrementOp } = require('../ParseOp');

describe('ParseObject', () => {
  beforeEach(() => {
    ParseObject.enableSingleInstance();
    jest.clearAllMocks();
  });

  it('is initially created with no Id', () => {
    const o = new ParseObject('Item');
    expect(o.id).toBe(undefined);
    expect(o._localId).toBe(undefined);
    expect(o.dirty()).toBe(true);
  });

  it('can be created with initial attributes', () => {
    const o = new ParseObject({
      className: 'Item',
      value: 12,
    });
    expect(o.className).toBe('Item');
    expect(o.attributes).toEqual({ value: 12 });
  });

  it('can be created with attributes parameter', () => {
    const o = new ParseObject('Item', {
      value: 12,
    });
    expect(o.className).toBe('Item');
    expect(o.attributes).toEqual({ value: 12 });
  });

  it('can ignore setting invalid key', () => {
    const o = new ParseObject('Item');
    const o2 = o.set(1234);
    expect(o).toEqual(o2);
  });

  it('can ignore setting createdAt', () => {
    const o = new ParseObject('Item');
    o.set('createdAt', '1234');
    expect(o.get('createdAt')).toEqual(undefined);
  });

  it('can handle setting relationOp', () => {
    const child = new ParseObject('Child');
    child.id = 'child1234';
    const relationOpJSON = { __op: 'AddRelation', objects: [child] };
    const o = new ParseObject('Item');
    o.set('friends', relationOpJSON);
    o._handleSaveResponse({});
    expect(o.get('friends').targetClassName).toBe('Child');
  });

  it('cannot create with invalid attributes', () => {
    expect(() => {
      new ParseObject({
        className: 'Item',
        'invalid#name': 'foo',
      });
    }).toThrow(""Can't create an invalid Parse Object"");
  });

  it('can ignore validation if ignoreValidation option is provided', () => {
    class ValidatedObject extends ParseObject {
      validate(attrs) {
        if (Object.hasOwn(attrs, 'badAttr')) {
          return 'you have the bad attr';
        }
      }
    }

    const o = new ValidatedObject(
      {
        className: 'Item',
        value: 12,
        badAttr: true,
      },
      { ignoreValidation: true }
    );

    expect(o.attributes.value).toBe(12);
    expect(o.attributes.badAttr).toBe(true);
  });

  it('can be inflated from server JSON', () => {
    const date = new Date();
    const json = {
      className: 'Item',
      createdAt: '2013-12-14T04:51:19Z',
      objectId: 'I1',
      size: 'medium',
      date: date,
    };
    const o = ParseObject.fromJSON(json);
    expect(o.className).toBe('Item');
    expect(o.id).toBe('I1');
    expect(o.attributes).toEqual({
      size: 'medium',
      createdAt: new Date(Date.UTC(2013, 11, 14, 4, 51, 19)),
      updatedAt: new Date(Date.UTC(2013, 11, 14, 4, 51, 19)),
      date,
    });
    expect(o.dirty()).toBe(false);
    expect(o.get('date')).toBeInstanceOf(Date);
  });

  it('can be dirty with fromJSON', () => {
    const date = new Date();
    const json = {
      className: 'Item',
      createdAt: '2013-12-14T04:51:19Z',
      objectId: 'I1',
      size: 'medium',
      date: date,
    };
    const o = ParseObject.fromJSON(json, false, true);
    expect(o.className).toBe('Item');
    expect(o.id).toBe('I1');
    expect(o.attributes).toEqual({
      size: 'medium',
      createdAt: new Date(Date.UTC(2013, 11, 14, 4, 51, 19)),
      updatedAt: new Date(Date.UTC(2013, 11, 14, 4, 51, 19)),
      date,
    });
    expect(o.dirty()).toBe(true);
    expect(o.dirtyKeys()).toEqual(['size', 'date']);
  });

  it('can override old data when inflating from the server', () => {
    const o = ParseObject.fromJSON({
      className: 'Item',
      objectId: 'I01',
      size: 'small',
    });
    expect(o.get('size')).toBe('small');
    const o2 = ParseObject.fromJSON(
      {
        className: 'Item',
        objectId: 'I01',
        disabled: true,
      },
      true
    );
    expect(o.get('disabled')).toBe(true);
    expect(o.get('size')).toBe(undefined);
    expect(o.has('size')).toBe(false);

    expect(o2.get('disabled')).toBe(true);
    expect(o2.get('size')).toBe(undefined);
    expect(o2.has('size')).toBe(false);
  });

  it('is given a local Id once dirtied', () => {
    const o = new ParseObject('Item');
    o.set('size', 'small');
    expect(o._localId).toBeTruthy();
  });

  it('has a read-only attributes property', () => {
    const o = new ParseObject('Item');
    o.set('size', 'small');
    expect(function () {
      o.attributes.size = 'large';
    }).toThrow();
  });

  it('exposes read-only createdAt and updatedAt', () => {
    const o = new ParseObject('Item');
    expect(o.get('createdAt')).toBe(undefined);
    expect(o.get('updatedAt')).toBe(undefined);
    const created = new Date();
    const updated = new Date();
    o._finishFetch({
      objectId: 'O1',
      createdAt: { __type: 'Date', iso: created.toISOString() },
      updatedAt: { __type: 'Date', iso: updated.toISOString() },
    });
    expect(o.get('createdAt')).toEqual(created);
    expect(o.get('updatedAt')).toEqual(updated);
    expect(o.createdAt).toEqual(created);
    expect(o.updatedAt).toEqual(updated);
  });

  it('fetch ACL from serverData', () => {
    const ACL = new ParseACL({ user1: { read: true } });
    const o = new ParseObject('Item');
    o._finishFetch({
      objectId: 'O1',
      ACL: { user1: { read: true } },
    });
    expect(o.getACL()).toEqual(ACL);
  });

  it('encodes ACL from json', () => {
    const ACL = new ParseACL({ user1: { read: true } });
    const o = new ParseObject('Item');
    o.set({ ACL: ACL.toJSON() });
    expect(o.getACL()).toEqual(ACL);
  });

  it('can be rendered to JSON', () => {
    let o = new ParseObject('Item');
    o.set({
      size: 'large',
      inStock: 18,
    });
    expect(o.toJSON()).toEqual({
      size: 'large',
      inStock: 18,
    });
    o = new ParseObject('Item');
    o._finishFetch({
      objectId: 'O2',
      size: 'medium',
      inStock: 12,
    });
    expect(o.id).toBe('O2');
    expect(o.toJSON()).toEqual({
      objectId: 'O2',
      size: 'medium',
      inStock: 12,
    });
  });

  it('encodes createdAt and updatedAt fields as strings', () => {
    const o = ParseObject.fromJSON({
      id: 'hasDates',
      className: 'Item',
      createdAt: {
        __type: 'Date',
        iso: new Date(Date.UTC(2015, 0, 1)).toJSON(),
      },
      updatedAt: {
        __type: 'Date',
        iso: new Date(Date.UTC(2015, 0, 1)).toJSON(),
      },
      foo: 'bar',
    });
    expect(o.toJSON()).toEqual({
      id: 'hasDates',
      createdAt: '2015-01-01T00:00:00.000Z',
      updatedAt: '2015-01-01T00:00:00.000Z',
      foo: 'bar',
    });
  });

  it('can convert to a pointer', () => {
    const o = new ParseObject('Item');
    expect(function () {
      o.toPointer();
    }).toThrow('Cannot create a pointer to an unsaved ParseObject');
    o.id = 'anObjectId';
    expect(o.toPointer()).toEqual({
      __type: 'Pointer',
      className: 'Item',
      objectId: 'anObjectId',
    });
  });

  it('can convert to a offline pointer', () => {
    const o = new ParseObject('Item');
    o.id = 'AnObjectId';
    expect(function () {
      o.toOfflinePointer();
    }).toThrow('Cannot create a offline pointer to a saved ParseObject');
    o._localId = 'local1234';
    expect(o.toOfflinePointer()).toEqual({
      __type: 'Object',
      className: 'Item',
      _localId: 'local1234',
    });
  });

  it('can test equality against another ParseObject', () => {
    const a = new ParseObject('Item');
    expect(a.equals(a)).toBe(true);
    const b = new ParseObject('Item');
    expect(a.equals(b)).toBe(false);
    expect(b.equals(a)).toBe(false);
    a.id = 'anObjectId';
    b.id = 'anObjectId';
    expect(a.equals(b)).toBe(true);
    expect(b.equals(a)).toBe(true);
  });

  it('can set a field', () => {
    const o = new ParseObject('Person');
    expect(o.attributes).toEqual({});
    o.set('name', 'Will');
    expect(o.attributes).toEqual({ name: 'Will' });
    expect(o.op('name') instanceof SetOp).toBe(true);
    expect(o.dirtyKeys()).toEqual(['name']);
    expect(o.dirty()).toBe(true);
    expect(o.dirty('name')).toBe(true);
    expect(o._getSaveJSON()).toEqual({ name: 'Will' });

    // set multiple fields at once
    o.set({ name: 'William', behavior: 'formal' });
    expect(o.attributes).toEqual({ name: 'William', behavior: 'formal' });
  });

  it('can set id with the objectId attribute', () => {
    const o = new ParseObject('Person');
    expect(o.attributes).toEqual({});
    expect(o.id).toBe(undefined);
    o.set({ objectId: 'oid' });
    expect(o.attributes).toEqual({});
    expect(o.id).toBe('oid');
  });

  it('can get an escaped version of a field', () => {
    const o = new ParseObject('Person');
    o.set('age', 28);
    o.set('phoneProvider', 'AT&T');
    o.set('objectField', { toString: 'hacking' });
    expect(o.escape('notSet')).toBe('');
    expect(o.escape('age')).toBe('28');
    expect(o.escape('phoneProvider')).toBe('AT&amp;T');
    expect(o.escape('objectField')).toBe('');
  });

  it('can tell if it has an attribute', () => {
    const o = new ParseObject('Person');
    o.set('age', 28);
    expect(o.has('name')).toBe(false);
    expect(o.has('age')).toBe(true);
  });

  it('can tell if a field is dirty', () => {
    const o = new ParseObject('Person');
    o._finishFetch({
      objectId: 'p99',
      age: 28,
      human: true,
      objectField: { foo: 'bar' },
    });
    expect(o.dirty()).toBe(false);
    expect(o.dirty('age')).toBe(false);
    expect(o.dirty('human')).toBe(false);
    expect(o.dirty('unset')).toBe(false);
    expect(o.dirty('objectField')).toBe(false);
    o.set('human', false);
    o.set('objectField', { foo: 'baz' });
    expect(o.dirty()).toBe(true);
    expect(o.dirty('age')).toBe(false);
    expect(o.dirty('human')).toBe(true);
    expect(o.dirty('unset')).toBe(false);
    expect(o.dirty('objectField')).toBe(true);
  });

  it('can unset a field', () => {
    const o = new ParseObject('Person');
    o.id = 'anObjectId';
    o.set('name', 'Will');
    expect(o.attributes).toEqual({ name: 'Will' });
    o.unset('name');
    expect(o.attributes).toEqual({});
    // Even when you unset an unsaved set, it's still dirty
    expect(o.op('name') instanceof UnsetOp).toBe(true);
    expect(o.dirty()).toBe(true);
    expect(o.dirtyKeys()).toEqual(['name']);

    const o2 = new ParseObject('Person');
    o2._finishFetch({
      objectId: 'P1',
      name: 'Will',
    });
    expect(o2.attributes).toEqual({ name: 'Will' });
    o2.unset('name');
    expect(o2.attributes).toEqual({});
  });

  it('can clear all fields', () => {
    const o = new ParseObject('Person');
    o._finishFetch({
      objectId: 'P95',
      createdAt: { __type: 'Date', iso: new Date().toISOString() },
      updatedAt: { __type: 'Date', iso: new Date().toISOString() },
    });
    o.set({ a: 'a', b: 'b', c: 'c' });
    expect(o.dirty('a')).toBe(true);
    expect(o.dirty('b')).toBe(true);
    expect(o.dirty('c')).toBe(true);
    o.clear();
    expect(o.get('a')).toBe(undefined);
    expect(o.get('b')).toBe(undefined);
    expect(o.get('c')).toBe(undefined);
  });

  it('can increment a field', () => {
    const o = new ParseObject('Person');
    o.increment('age');
    expect(o.attributes).toEqual({ age: 1 });
    expect(o.op('age') instanceof IncrementOp).toBe(true);
    expect(o.dirtyKeys()).toEqual(['age']);
    expect(o._getSaveJSON()).toEqual({
      age: { __op: 'Increment', amount: 1 },
    });

    o.increment('age', 4);
    expect(o.attributes).toEqual({ age: 5 });
    expect(o._getSaveJSON()).toEqual({
      age: { __op: 'Increment', amount: 5 },
    });

    expect(o.increment.bind(o, 'age', 'four')).toThrow('Cannot increment by a non-numeric amount.');
    expect(o.increment.bind(o, 'age', null)).toThrow('Cannot increment by a non-numeric amount.');
    expect(o.increment.bind(o, 'age', { amount: 4 })).toThrow(
      'Cannot increment by a non-numeric amount.'
    );

    o.set('age', 30);
    o.increment('age');
    expect(o.attributes).toEqual({ age: 31 });
    expect(o._getSaveJSON()).toEqual({
      age: 31,
    });

    const o2 = new ParseObject('Person');
    o2._finishFetch({
      objectId: 'P2',
      age: 40,
    });
    expect(o2.attributes).toEqual({ age: 40 });
    o2.increment('age');
    expect(o2.attributes).toEqual({ age: 41 });
  });

  it('can decrement a field', () => {
    const o = new ParseObject('Person');
    o.decrement('age');
    expect(o.attributes).toEqual({ age: -1 });
    expect(o.op('age') instanceof IncrementOp).toBe(true);
    expect(o.dirtyKeys()).toEqual(['age']);
    expect(o._getSaveJSON()).toEqual({
      age: { __op: 'Increment', amount: -1 },
    });

    o.decrement('age', 4);
    expect(o.attributes).toEqual({ age: -5 });
    expect(o._getSaveJSON()).toEqual({
      age: { __op: 'Increment', amount: -5 },
    });

    expect(o.decrement.bind(o, 'age', 'four')).toThrow('Cannot decrement by a non-numeric amount.');
    expect(o.decrement.bind(o, 'age', null)).toThrow('Cannot decrement by a non-numeric amount.');
    expect(o.decrement.bind(o, 'age', { amount: 4 })).toThrow(
      'Cannot decrement by a non-numeric amount.'
    );

    o.set('age', 30);
    o.decrement('age');
    expect(o.attributes).toEqual({ age: 29 });
    expect(o._getSaveJSON()).toEqual({
      age: 29,
    });

    const o2 = new ParseObject('Person');
    o2._finishFetch({
      objectId: 'ABC123',
      age: 40,
    });
    expect(o2.attributes).toEqual({ age: 40 });
    o2.decrement('age');
    expect(o2.attributes).toEqual({ age: 39 });
  });

  it('can set nested field', () => {
    const o = new ParseObject('Person');
    o._finishFetch({
      objectId: 'setNested',
      objectField: {
        number: 5,
        letter: 'a',
      },
      otherField: {},
    });

    expect(o.attributes).toEqual({
      objectField: { number: 5, letter: 'a' },
      otherField: {},
    });
    o.set('otherField', { hello: 'world' });
    o.set('objectField.number', 20);

    expect(o.attributes).toEqual({
      objectField: { number: 20, letter: 'a' },
      otherField: { hello: 'world' },
    });
    expect(o.op('objectField.number') instanceof SetOp).toBe(true);
    expect(o.dirtyKeys()).toEqual(['otherField', 'objectField.number', 'objectField']);
    expect(o._getSaveJSON()).toEqual({
      'objectField.number': 20,
      otherField: { hello: 'world' },
    });
    expect(o.toJSON()).toEqual({
      objectField: {
        number: 20,
        letter: 'a',
      },
      otherField: { hello: 'world' },
      objectId: 'setNested',
    });
  });

  it('can set multiple nested fields (regression test for #1450)', () => {
    const o = new ParseObject('Person');
    o._finishFetch({
      objectId: 'setNested2_1450',
      objectField: {
        number: 5,
        letter: 'a',
        nested: {
          number: 0,
          letter: 'b',
        },
      },
    });

    expect(o.attributes).toEqual({
      objectField: { number: 5, letter: 'a', nested: { number: 0, letter: 'b' } },
    });
    o.set('objectField.number', 20);
    o.set('objectField.letter', 'b');
    o.set('objectField.nested.number', 1);
    o.set('objectField.nested.letter', 'c');

    expect(o.attributes).toEqual({
      objectField: { number: 20, letter: 'b', nested: { number: 1, letter: 'c' } },
    });
    expect(o.op('objectField.number') instanceof SetOp).toBe(true);
    expect(o.dirtyKeys()).toEqual([
      'objectField.number',
      'objectField.letter',
      'objectField.nested.number',
      'objectField.nested.letter',
      'objectField',
    ]);
    expect(o._getSaveJSON()).toEqual({
      'objectField.number': 20,
      'objectField.letter': 'b',
      'objectField.nested.number': 1,
      'objectField.nested.letter': 'c',
    });

    o.revert('objectField.nested.number');
    o.revert('objectField.nested.letter');
    expect(o._getSaveJSON()).toEqual({
      'objectField.number': 20,
      'objectField.letter': 'b',
    });
    expect(o.attributes).toEqual({
      objectField: { number: 20, letter: 'b', nested: { number: 0, letter: 'b' } },
    });

    // Also test setting new root fields using the dot notation
    o.set('objectField2.number', 0);
    expect(o._getSaveJSON()).toEqual({
      'objectField.number': 20,
      'objectField.letter': 'b',
      'objectField2.number': 0,
    });
    expect(o.attributes).toEqual({
      objectField: { number: 20, letter: 'b', nested: { number: 0, letter: 'b' } },
      objectField2: { number: 0 },
    });
  });

  it('can increment a nested field', () => {
    const o = new ParseObject('Person');
    o._finishFetch({
      objectId: 'incNested',
      objectField: {
        number: 5,
        letter: 'a',
      },
    });

    expect(o.attributes).toEqual({
      objectField: { number: 5, letter: 'a' },
    });
    o.increment('objectField.number');

    expect(o.attributes).toEqual({
      objectField: { number: 6, letter: 'a' },
    });
    expect(o.op('objectField.number') instanceof IncrementOp).toBe(true);
    expect(o.dirtyKeys()).toEqual(['objectField.number', 'objectField']);
    expect(o._getSaveJSON()).toEqual({
      'objectField.number': {
        __op: 'Increment',
        amount: 1,
      },
    });

    // Nested objects only return values changed
    o._handleSaveResponse({
      objectId: 'incNested',
      objectField: {
        number: 6,
      },
    });
    expect(o.get('objectField').number).toEqual(6);
    expect(o.get('objectField').letter).toEqual('a');
  });

  it('can add elements to an array field', () => {
    const o = new ParseObject('Schedule');
    o.add('available', 'Monday');
    o.add('available', 'Wednesday');
    expect(o.get('available')).toEqual(['Monday', 'Wednesday']);

    o.set('colors', ['red', 'green']);
    o.add('colors', 'blue');
    expect(o.get('colors')).toEqual(['red', 'green', 'blue']);

    o._handleSaveResponse({
      objectId: 'S1',
      available: ['Monday', 'Wednesday'],
      colors: ['red', 'green', 'blue'],
    });

    o.addUnique('available', 'Thursday');
    o.addUnique('available', 'Monday');
    expect(o.get('available')).toEqual(['Monday', 'Wednesday', 'Thursday']);
  });

  it('can add elements to an array field in batch mode', () => {
    const o = new ParseObject('Schedule');
    o.addAll('available', ['Monday', 'Wednesday']);
    expect(o.get('available')).toEqual(['Monday', 'Wednesday']);

    o.set('colors', ['red']);
    o.addAll('colors', ['green', 'blue']);
    expect(o.get('colors')).toEqual(['red', 'green', 'blue']);

    o._handleSaveResponse({
      objectId: 'S1',
      available: ['Monday', 'Wednesday'],
      colors: ['red', 'green', 'blue'],
    });

    o.addAllUnique('available', ['Thursday', 'Monday']);
    expect(o.get('available').length).toEqual(3);
  });

  it('can remove elements from an array field', () => {
    const o = new ParseObject('Schedule');
    o.set('available', ['Monday', 'Tuesday']);
    o.remove('available', 'Tuesday');
    o.remove('available', 'Saturday');
    expect(o.get('available')).toEqual(['Monday']);

    o._handleSaveResponse({
      objectId: 'S2',
      available: ['Monday'],
    });

    o.remove('available', 'Monday');
    o.remove('available', 'Tuesday');
    expect(o.get('available')).toEqual([]);
  });

  it('can remove elements from an array field in batch mode', () => {
    const o = new ParseObject('Schedule');
    o.set('available', ['Monday', 'Tuesday']);
    o.removeAll('available', ['Tuesday', 'Saturday']);
    expect(o.get('available')).toEqual(['Monday']);

    o._handleSaveResponse({
      objectId: 'S2',
      available: ['Monday'],
    });

    o.removeAll('available', ['Monday', 'Tuesday']);
    expect(o.get('available')).toEqual([]);
  });

  it('can chain sets', () => {
    const o = new ParseObject('Person');
    o.set('developer', true).set('platform', 'web');
    expect(o.attributes).toEqual({
      developer: true,
      platform: 'web',
    });
  });

  it('can set and retrieve ACLs', () => {
    const acl = new ParseACL();
    const o = new ParseObject('Listing');
    o.setACL(acl);
    expect(o.get('ACL')).toBe(acl);
    expect(o.getACL()).toBe(acl);
  });

  it('can manipulate relations on fields', () => {
    const o = new ParseObject('Person');
    o.id = 'AA';
    o.set('age', 38);
    expect(o.relation.bind(o, 'age')).toThrow('Called relation() on non-relation field age');
    const rel = o.relation('friends');
    expect(rel.parentClass).toBe('Person');
    expect(rel.parentId).toBe('AA');
    expect(rel.key).toBe('friends');
    const friend = new ParseObject('Person');
    friend.id = 'BB';
    rel.add(friend);
    expect(rel.targetClassName).toBe('Person');
  });

  it('can be cloned with relation (#381)', () => {
    const relationJSON = { __type: 'Relation', className: 'Bar' };
    const o = ParseObject.fromJSON({
      objectId: '7777777777',
      className: 'Foo',
      aRelation: relationJSON,
    });
    const o2 = o.clone();
    expect(o2._getSaveJSON().aRelation).toEqual(relationJSON);
  });

  it('can get relation from relation field', () => {
    const relationJSON = { __type: 'Relation', className: 'Bar' };
    const o = ParseObject.fromJSON({
      objectId: '999',
      className: 'Foo',
      aRelation: relationJSON,
    });
    const rel = o.relation('aRelation');
    expect(rel.toJSON()).toEqual(relationJSON);
  });

  it('can detect dirty object children', () => {
    const o = new ParseObject('Person');
    o._finishFetch({
      objectId: 'dirtyObj',
      obj: { a: 12 },
      location: {
        __type: 'GeoPoint',
        latitude: 20,
        longitude: 20,
      },
    });
    expect(o.dirty()).toBe(false);
    o.get('obj').b = 21;
    expect(o.get('obj')).toEqual({
      a: 12,
      b: 21,
    });
    expect(o.dirty()).toBe(true);
    expect(o.dirtyKeys()).toEqual(['obj']);
    expect(o._getSaveJSON()).toEqual({
      obj: {
        a: 12,
        b: 21,
      },
    });
    delete o.get('obj').b;
    expect(o.dirty()).toBe(false);
    expect(o.dirtyKeys()).toEqual([]);
    const loc = o.get('location');
    expect(loc instanceof ParseGeoPoint).toBe(true);
    expect(loc.latitude).toBe(20);
    expect(loc.longitude).toBe(20);
    loc.latitude = 30;
    expect(loc.latitude).toBe(30);
    expect(o.dirty()).toBe(true);
    expect(o.dirtyKeys()).toEqual(['location']);

    const p = new ParseObject('Parent');
    p.set('children', [o]);
    expect(p.dirtyKeys()).toEqual(['children']);
  });

  it('can validate attributes', () => {
    const o = new ParseObject('Listing');
    expect(
      o.validate({
        ACL: 'not an acl',
      })
    ).toEqual(new ParseError(ParseError.OTHER_CAUSE, 'ACL must be a Parse ACL.'));

    expect(
      o.validate({
        'invalid!key': 12,
      })
    ).toEqual(new ParseError(ParseError.INVALID_KEY_NAME, 'Invalid key name: invalid!key'));

    expect(
      o.validate({
        noProblem: 'here',
      })
    ).toBe(false);

    expect(
      o.validate({
        'dot.field': 'here',
      })
    ).toBe(false);
  });

  it('validates attributes on set()', () => {
    const o = new ParseObject('Listing');
    expect(() => {
      o.set('ACL', 'not an acl');
    }).toThrow(new ParseError(ParseError.OTHER_CAUSE, 'ACL must be a Parse ACL.'));
    expect(o.set('ACL', { '*': { read: true, write: false } })).toBe(o);
    expect(() => {
      o.set('$$$', 'o_O');
    }).toThrow(new ParseError(ParseError.INVALID_KEY_NAME, 'Invalid key name: $$$'));
  });

  it('ignores validation if ignoreValidation option is passed to set()', () => {
    const o = new ParseObject('Listing');
    expect(o.set('$$$', 'o_O', { ignoreValidation: true })).toBe(o);
  });

  it('can test object validity', () => {
    // Note: an object should never become invalid through normal use, but
    // it's possible that someone could manipulate it to become invalid
    const o = new ParseObject('Item');
    expect(o.isValid()).toBe(true);
    o.set('someKey', 'someValue');
    expect(o.isValid()).toBe(true);
    o.set('_internalField', 'allow_underscore');
    expect(o.isValid()).toBe(true);
    o._finishFetch({
      objectId: 'O3',
      'invalid!key': 'oops',
    });
    expect(o.isValid()).toBe(false);
  });

  it('shares data among different instances of an object', () => {
    const o = new ParseObject('Person');
    o.id = 'P2';
    const o2 = new ParseObject('Person');
    o2.id = 'P2';
    o.set('age', 22);
    expect(o.get('age')).toBe(22);
    expect(o2.get('age')).toBe(22);
  });

  it('does not stack-overflow when encoding recursive pointers', () => {
    const o = ParseObject.fromJSON({
      __type: 'Object',
      className: 'Item',
      objectId: 'recurParent',
      child: {
        __type: 'Pointer',
        className: 'Item',
        objectId: 'recurChild',
      },
    });
    expect(o.toJSON()).toEqual({
      objectId: 'recurParent',
      child: {
        __type: 'Pointer',
        className: 'Item',
        objectId: 'recurChild',
      },
    });

    ParseObject.fromJSON({
      __type: 'Object',
      className: 'Item',
      objectId: 'recurChild',
      parent: {
        __type: 'Pointer',
        className: 'Item',
        objectId: 'recurParent',
      },
    });

    expect(o.toJSON()).toEqual({
      objectId: 'recurParent',
      child: {
        __type: 'Object',
        className: 'Item',
        objectId: 'recurChild',
        parent: {
          __type: 'Pointer',
          className: 'Item',
          objectId: 'recurParent',
        },
      },
    });
  });

  it('properly encodes createdAt/updatedAt dates on nested objects', () => {
    const o = ParseObject.fromJSON({
      __type: 'Object',
      className: 'Item',
      objectId: 'recurParent',
      createdAt: '1970-01-01T00:00:00.000Z',
      updatedAt: '1970-01-01T00:00:00.000Z',
      aDate: {
        __type: 'Date',
        iso: '1970-01-01T00:00:00.000Z',
      },
      child: {
        __type: 'Pointer',
        className: 'Item',
        objectId: 'recurChild',
      },
    });
    expect(o.createdAt.getTime()).toBe(new Date(0).getTime());
    expect(o.updatedAt.getTime()).toBe(new Date(0).getTime());
    expect(o.get('aDate').getTime()).toBe(new Date(0).getTime());

    ParseObject.fromJSON({
      __type: 'Object',
      className: 'Item',
      objectId: 'recurChild',
      createdAt: '1970-01-01T00:00:00.000Z',
      updatedAt: '1970-01-01T00:00:00.000Z',
      parent: {
        __type: 'Pointer',
        className: 'Item',
        objectId: 'recurParent',
      },
    });

    expect(o.toJSON()).toEqual({
      objectId: 'recurParent',
      createdAt: '1970-01-01T00:00:00.000Z',
      updatedAt: '1970-01-01T00:00:00.000Z',
      aDate: {
        __type: 'Date',
        iso: '1970-01-01T00:00:00.000Z',
      },
      child: {
        __type: 'Object',
        className: 'Item',
        objectId: 'recurChild',
        createdAt: '1970-01-01T00:00:00.000Z',
        updatedAt: '1970-01-01T00:00:00.000Z',
        parent: {
          __type: 'Pointer',
          className: 'Item',
          objectId: 'recurParent',
        },
      },
    });
  });

  it('encodes multiple layers of nested objects', () => {
    const grandparent = ParseObject.fromJSON({
      __type: 'Object',
      className: 'Item',
      objectId: 'nestedGrand',
      child: {
        __type: 'Pointer',
        className: 'Item',
        objectId: 'nestedParent',
      },
    });

    const parent = ParseObject.fromJSON({
      __type: 'Object',
      className: 'Item',
      objectId: 'nestedParent',
      child: {
        __type: 'Pointer',
        className: 'Item',
        objectId: 'nestedChild',
      },
    });

    const child = ParseObject.fromJSON({
      __type: 'Object',
      className: 'Item',
      objectId: 'nestedChild',
      count: 12,
    });

    expect(grandparent.get('child').id).toBe(parent.id);
    expect(grandparent.get('child').get('child').id).toBe(child.id);

    expect(grandparent.toJSON()).toEqual({
      objectId: 'nestedGrand',
      child: {
        __type: 'Object',
        className: 'Item',
        objectId: 'nestedParent',
        child: {
          __type: 'Object',
          className: 'Item',
          objectId: 'nestedChild',
          count: 12,
        },
      },
    });
  });

  it('updates the existed flag when saved', () => {
    const o = new ParseObject('Item');
    expect(o.existed()).toBe(false);
    expect(o.isNew()).toBe(true);
    o._handleSaveResponse(
      {
        objectId: 'I2',
      },
      201
    );
    expect(o.existed()).toBe(false);
    o._handleSaveResponse({}, 200);
    expect(o.existed()).toBe(true);
  });

  it('check existed without object state', () => {
    const o = new ParseObject('Item');
    o.id = 'test890';
    expect(o.existed()).toBe(false);
  });

  it('commits changes to server data when saved', () => {
    const p = new ParseObject('Person');
    p.id = 'P3';
    p.set('age', 24);
    expect(p._getServerData()).toEqual({});
    expect(p.op('age') instanceof SetOp).toBe(true);
    const updated = new Date();
    p._handleSaveResponse({
      updatedAt: { __type: 'Date', iso: updated.toISOString() },
    });
    expect(p._getServerData()).toEqual({
      updatedAt: updated,
      age: 24,
    });
    expect(p.op('age')).toBe(undefined);
  });

  it('handle GeoPoint changes for server', () => {
    const p = new ParseObject('Person');
    p.id = 'PPoint';
    const created = new Date();
    const geopoint = new ParseGeoPoint(0, 0);
    p._handleSaveResponse({
      createdAt: created.toISOString(),
      point: geopoint.toJSON(),
    });
    expect(p._getServerData()).toEqual({
      updatedAt: created,
      createdAt: created,
      point: geopoint,
    });
    expect(p._getServerData().point instanceof ParseGeoPoint).toBe(true);
  });

  it('handle Polygon changes for server', () => {
    const p = new ParseObject('Person');
    p.id = 'PPolygon';
    const created = new Date();
    const polygon = new ParsePolygon([
      [0, 0],
      [0, 1],
      [1, 1],
      [1, 0],
      [0, 0],
    ]);
    p._handleSaveResponse({
      createdAt: created.toISOString(),
      shape: polygon.toJSON(),
    });
    expect(p._getServerData()).toEqual({
      updatedAt: created,
      createdAt: created,
      shape: polygon,
    });
    expect(p._getServerData().shape instanceof ParsePolygon).toBe(true);
  });

  it('handle createdAt string for server', () => {
    const p = new ParseObject('Person');
    p.id = 'P9';
    const created = new Date();
    p._handleSaveResponse({
      createdAt: created.toISOString(),
    });
    expect(p._getServerData()).toEqual({
      updatedAt: created,
      createdAt: created,
    });
  });

  it('isDataAvailable', () => {
    const p = new ParseObject('Person');
    p.id = 'isdataavailable';
    p.set('age', 24);
    expect(p.isDataAvailable()).toBe(false);
    const updated = new Date();
    p._handleSaveResponse({
      updatedAt: { __type: 'Date', iso: updated.toISOString() },
    });
    expect(p.isDataAvailable()).toBe(true);
  });

  it('handles ACL when saved', () => {
    const p = new ParseObject('Person');

    p._handleSaveResponse(
      {
        ACL: {},
      },
      201
    );

    const acl = p.getACL();
    expect(acl).not.toEqual(null);
    expect(acl instanceof ParseACL).toBe(true);
  });

  it('replaces a local id with a real one when saved', () => {
    const p = new ParseObject('Person');
    p.set('age', 34);
    expect(p._localId).toBeTruthy();
    expect(p.id).toBe(undefined);
    const oldState = SingleInstanceStateController.getState({
      className: 'Person',
      id: p._localId,
    });
    p._handleSaveResponse({
      objectId: 'P4',
    });
    expect(p._localId).toBe(undefined);
    expect(p.id).toBe('P4');
    const newState = SingleInstanceStateController.getState({
      className: 'Person',
      id: 'P4',
    });
    expect(oldState.serverData).toBe(newState.serverData);
    expect(oldState.pendingOps).toBe(newState.pendingOps);
    expect(oldState.tasks).toBe(newState.tasks);
  });

  it('marks inflated objects as existed', () => {
    const o = ParseObject.fromJSON({
      className: 'Item',
      objectId: 'iexist',
      count: 7,
    });
    expect(o.existed()).toBe(true);
  });

  it('can revert unsaved ops', () => {
    const o = ParseObject.fromJSON({
      className: 'Item',
      objectId: 'canrevert',
      count: 5,
    });
    o.set({ cool: true });
    o.increment('count');
    expect(o.get('cool')).toBe(true);
    expect(o.get('count')).toBe(6);
    o.revert();
    expect(o.get('cool')).toBe(undefined);
    expect(o.op('cool')).toBe(undefined);
    expect(o.get('count')).toBe(5);
    expect(o.op('count')).toBe(undefined);
  });

  it('can revert a specific field in unsaved ops', () => {
    const o = ParseObject.fromJSON({
      className: 'Item',
      objectId: 'canrevertspecific',
      count: 5,
    });
    o.set({ cool: true });
    o.increment('count');
    expect(o.get('cool')).toBe(true);
    expect(o.get('count')).toBe(6);
    o.revert('cool');
    expect(o.get('cool')).toBe(undefined);
    expect(o.op('cool')).toBe(undefined);
    expect(o.get('count')).toBe(6);
    expect(o.op('count')).not.toBe(undefined);
  });

  it('can revert multiple fields in unsaved ops', () => {
    const o = ParseObject.fromJSON({
      className: 'Item',
      objectId: 'canrevertmultiple',
      count: 5,
      age: 18,
      gender: 'female',
    });
    o.set({ cool: true, gender: 'male' });
    o.increment('count');
    o.increment('age');
    expect(o.get('cool')).toBe(true);
    expect(o.get('count')).toBe(6);
    expect(o.get('age')).toBe(19);
    expect(o.get('gender')).toBe('male');
    o.revert('age', 'count', 'gender');
    expect(o.get('cool')).toBe(true);
    expect(o.op('cool')).not.toBe(undefined);
    expect(o.get('count')).toBe(5);
    expect(o.op('count')).toBe(undefined);
    expect(o.get('age')).toBe(18);
    expect(o.op('age')).toBe(undefined);
    expect(o.get('gender')).toBe('female');
    expect(o.op('gender')).toBe(undefined);
  });

  it('throws if an array is provided', () => {
    const o = ParseObject.fromJSON({
      className: 'Item',
      objectId: 'throwforarray',
      count: 5,
      age: 18,
      gender: 'female',
    });
    o.set({ cool: true, gender: 'male' });

    const err = 'Parse.Object#revert expects either no, or a list of string, arguments.';

    expect(function () {
      o.revert(['age']);
    }).toThrow(err);

    expect(function () {
      o.revert([]);
    }).toThrow(err);

    expect(function () {
      o.revert('gender', ['age']);
    }).toThrow(err);
  });

  it('can fetchWithInclude', async () => {
    const objectController = CoreManager.getObjectController();
    const spy = jest
      .spyOn(objectController, 'fetch')
      .mockImplementationOnce(() => {})
      .mockImplementationOnce(() => {})
      .mockImplementationOnce(() => {});

    const parent = new ParseObject('Person');
    await parent.fetchWithInclude('child', {
      useMasterKey: true,
      sessionToken: '123',
    });
    await parent.fetchWithInclude(['child']);
    await parent.fetchWithInclude([['child']]);
    expect(objectController.fetch).toHaveBeenCalledTimes(3);

    expect(objectController.fetch.mock.calls[0]).toEqual([
      parent,
      true,
      { useMasterKey: true, sessionToken: '123', include: ['child'] },
    ]);
    expect(objectController.fetch.mock.calls[1]).toEqual([parent, true, { include: ['child'] }]);
    expect(objectController.fetch.mock.calls[2]).toEqual([parent, true, { include: ['child'] }]);

    spy.mockRestore();
  });

  it('fetchAll with empty values', async () => {
    mockFetch([{ status: 200, response: [{}] }]);
    const controller = CoreManager.getRESTController();
    jest.spyOn(controller, 'ajax');

    const results = await ParseObject.fetchAll([]);
    expect(results).toEqual([]);
    expect(controller.ajax).toHaveBeenCalledTimes(0);
  });

  it('fetchAll with null', async () => {
    mockFetch([{ status: 200, response: [{}] }]);
    const controller = CoreManager.getRESTController();
    jest.spyOn(controller, 'ajax');

    const results = await ParseObject.fetchAll(null);
    expect(results).toEqual(undefined);
    expect(controller.ajax).toHaveBeenCalledTimes(0);
  });

  it('fetchAll unique instance', async () => {
    ParseObject.disableSingleInstance();
    const obj = new ParseObject('Item');
    obj.id = 'fetch0';
    const results = await ParseObject.fetchAll([obj]);
    expect(results[0].id).toEqual(obj.id);
  });

  it('fetchAll objects does not exist on server', async () => {
    jest.spyOn(mockQuery.prototype, 'find').mockImplementationOnce(() => {
      return Promise.resolve([]);
    });
    const obj = new ParseObject('Item');
    obj.id = 'fetch-1';
    try {
      await ParseObject.fetchAll([obj]);
      expect(true).toBe(false);
    } catch (e) {
      expect(e.message).toBe('All objects must exist on the server.');
    }
  });

  it('fetchAll unsaved objects', async () => {
    const obj = new ParseObject('Item');
    try {
      await ParseObject.fetchAll([obj]);
      expect(true).toBe(false);
    } catch (e) {
      expect(e.message).toBe('All objects must have an ID');
    }
  });

  it('fetchAll objects with different classes', async () => {
    const obj = new ParseObject('Item');
    const obj2 = new ParseObject('TestObject');
    try {
      await ParseObject.fetchAll([obj, obj2]);
      expect(true).toBe(false);
    } catch (e) {
      expect(e.message).toBe('All objects must have an ID');
    }
  });

  it('fetchAll saved objects with different classes', async () => {
    const obj1 = new ParseObject('Item');
    const obj2 = new ParseObject('TestObject');
    obj1.id = 'fetch1';
    obj2.id = 'fetch2';
    try {
      await ParseObject.fetchAll([obj1, obj2]);
      expect(true).toBe(false);
    } catch (e) {
      expect(e.message).toBe('All objects should be of the same class');
    }
  });

  it('can fetchAllWithInclude', async () => {
    const objectController = CoreManager.getObjectController();
    const spy = jest
      .spyOn(objectController, 'fetch')
      .mockImplementationOnce(() => {})
      .mockImplementationOnce(() => {})
      .mockImplementationOnce(() => {});

    const parent = new ParseObject('Person');
    await ParseObject.fetchAllWithInclude([parent], 'child', {
      useMasterKey: true,
      sessionToken: '123',
    });
    await ParseObject.fetchAllWithInclude([parent], ['child']);
    await ParseObject.fetchAllWithInclude([parent], [['child']]);
    expect(objectController.fetch).toHaveBeenCalledTimes(3);

    expect(objectController.fetch.mock.calls[0]).toEqual([
      [parent],
      true,
      { useMasterKey: true, sessionToken: '123', include: ['child'] },
    ]);
    expect(objectController.fetch.mock.calls[1]).toEqual([[parent], true, { include: ['child'] }]);
    expect(objectController.fetch.mock.calls[2]).toEqual([[parent], true, { include: ['child'] }]);

    spy.mockRestore();
  });

  it('can fetchAllIfNeededWithInclude', async () => {
    const objectController = CoreManager.getObjectController();
    const spy = jest
      .spyOn(objectController, 'fetch')
      .mockImplementationOnce(() => {})
      .mockImplementationOnce(() => {})
      .mockImplementationOnce(() => {});

    const parent = new ParseObject('Person');
    await ParseObject.fetchAllIfNeededWithInclude([parent], 'child', {
      useMasterKey: true,
      sessionToken: '123',
    });
    await ParseObject.fetchAllIfNeededWithInclude([parent], ['child']);
    await ParseObject.fetchAllIfNeededWithInclude([parent], [['child']]);
    expect(objectController.fetch).toHaveBeenCalledTimes(3);

    expect(objectController.fetch.mock.calls[0]).toEqual([
      [parent],
      false,
      { useMasterKey: true, sessionToken: '123', include: ['child'] },
    ]);
    expect(objectController.fetch.mock.calls[1]).toEqual([[parent], false, { include: ['child'] }]);
    expect(objectController.fetch.mock.calls[2]).toEqual([[parent], false, { include: ['child'] }]);

    spy.mockRestore();
  });

  it('can check if object exists', async () => {
    const parent = new ParseObject('Person');
    expect(await parent.exists()).toBe(false);
    parent.id = '1234';
    expect(await parent.exists()).toBe(true);

    jest.spyOn(mockQuery.prototype, 'get').mockImplementationOnce(() => {
      return Promise.reject({
        code: 101,
      });
    });
    expect(await parent.exists()).toBe(false);

    jest.spyOn(mockQuery.prototype, 'get').mockImplementationOnce(() => {
      return Promise.reject({
        code: 1,
        message: 'Internal Server Error',
      });
    });
    try {
      await parent.exists();
      expect(true).toBe(false);
    } catch (e) {
      expect(e.code).toBe(1);
    }
  });

  it('can save the object', async () => {
    mockFetch([{ status: 200, response: { objectId: 'P5', count: 1 } }]);
    const p = new ParseObject('Person');
    p.set('age', 38);
    p.increment('count');
    const obj = await p.save();
    expect(obj).toBe(p);
    expect(obj.get('age')).toBe(38);
    expect(obj.get('count')).toBe(1);
    expect(obj.op('age')).toBe(undefined);
    expect(obj.dirty()).toBe(false);
  });

  it('can save the object eventually', async () => {
    mockFetch([{ status: 200, response: {objectId: 'PFEventually' } }]);
    const p = new ParseObject('Person');
    p.set('age', 38);
    const obj = await p.saveEventually();
    expect(obj).toBe(p);
    expect(obj.get('age')).toBe(38);
    expect(obj.op('age')).toBe(undefined);
    expect(obj.dirty()).toBe(false);
  });

  it('can save the object eventually on network failure', async () => {
    const p = new ParseObject('Person');
    jest.spyOn(EventuallyQueue, 'save').mockImplementationOnce(() => Promise.resolve());
    jest.spyOn(EventuallyQueue, 'poll').mockImplementationOnce(() => {});
    jest.spyOn(p, 'save').mockImplementationOnce(() => {
      throw new ParseError(
        ParseError.CONNECTION_FAILED,
        'XMLHttpRequest failed: ""Unable to connect to the Parse API""'
      );
    });
    await p.saveEventually();
    expect(EventuallyQueue.save).toHaveBeenCalledTimes(1);
    expect(EventuallyQueue.poll).toHaveBeenCalledTimes(1);
  });

  it('should not save the object eventually on error', async () => {
    const p = new ParseObject('Person');
    jest.spyOn(EventuallyQueue, 'save').mockImplementationOnce(() => Promise.resolve());
    jest.spyOn(EventuallyQueue, 'poll').mockImplementationOnce(() => {});
    jest.spyOn(p, 'save').mockImplementationOnce(() => {
      throw new ParseError(ParseError.OTHER_CAUSE, 'Tried to save a batch with a cycle.');
    });
    await p.saveEventually();
    expect(EventuallyQueue.save).toHaveBeenCalledTimes(0);
    expect(EventuallyQueue.poll).toHaveBeenCalledTimes(0);
  });

  it('can save the object with key / value', async () => {
    mockFetch([{ status: 200, response: { objectId: 'P8' } }]);
    const p = new ParseObject('Person');
    const obj = await p.save('foo', 'bar');
    expect(obj).toBe(p);
    expect(obj.get('foo')).toBe('bar');
  });

  it('accepts attribute changes on save', (done) => {
    mockFetch([{ status: 200, response: { objectId: 'newattributes' } }]);
    let o = new ParseObject('Item');
    o.save({ key: 'value' })
      .then(() => {
        expect(o.get('key')).toBe('value');

        o = new ParseObject('Item');
        return o.save({ ACL: 'not an acl' });
      })
      .then(null, error => {
        expect(error.code).toBe(-1);
        done();
      });
  });

  it('accepts context on save', async () => {
    mockFetch([{ status: 200, response: { objectId: 'newattributes' } }]);
    // Spy on REST controller
    const controller = CoreManager.getRESTController();
    jest.spyOn(controller, 'ajax');
    // Save object
    const context = { a: 'a' };
    const obj = new ParseObject('Item');
    await obj.save(null, { context });
    // Validate
    const jsonBody = JSON.parse(controller.ajax.mock.calls[0][2]);
    expect(jsonBody._context).toEqual(context);
  });

  it('interpolates delete operations', async () => {
    mockFetch([{ status: 200, response: { objectId: 'newattributes', deletedKey: { __op: 'Delete' } } }]);
    const o = new ParseObject('Item');
    await o.save({ key: 'value', deletedKey: 'keyToDelete' });
    expect(o.get('key')).toBe('value');
    expect(o.get('deletedKey')).toBeUndefined();
  });

  it('can make changes while in the process of a save', async () => {
    mockFetch([{ status: 200, response: { objectId: 'P12', age: 38 } }]);
    const p = new ParseObject('Person');
    p.set('age', 38);
    const result = p.save().then(() => {
      expect(p._getServerData()).toEqual({ age: 38 });
      expect(p._getPendingOps().length).toBe(1);
      expect(p.get('age')).toBe(38);
    });
    expect(p._getPendingOps().length).toBe(1);
    p.increment('age');
    expect(p.get('age')).toBe(39);
    await result;
  });

  it('will queue save operations', async () => {
    mockFetch([
      { status: 200, response: { objectId: 'P15', updates: 1 } },
      { status: 200, response: { objectId: 'P15', updates: 2 } },
    ]);
    const p = new ParseObject('Person');
    expect(p._getPendingOps().length).toBe(1);
    p.increment('updates');
    await p.save();

    expect(p._getPendingOps().length).toBe(1);
    p.increment('updates');
    await p.save();

    expect(p._getPendingOps().length).toBe(1);
    expect(p._getServerData()).toEqual({ updates: 2 });
    expect(p.get('updates')).toBe(2);
    expect(p._getPendingOps().length).toBe(1);
  });

  it('will leave the pending ops queue untouched when a lone save fails', async () => {
    mockFetch([{ status: 404, response: { code: 103, error: 'Invalid class name' } }]);
    const p = new ParseObject('Per$on');
    expect(p._getPendingOps().length).toBe(1);
    p.increment('updates');
    const result = p.save().then(null, err => {
      expect(err.code).toBe(103);
      expect(err.message).toBe('Invalid class name');
      expect(p._getPendingOps().length).toBe(1);
      expect(p.dirtyKeys()).toEqual(['updates']);
      expect(p.get('updates')).toBe(1);
    });
    await result;
  });

  it('will merge pending Ops when a save fails and others are pending', async () => {
    mockFetch([
      { status: 404, response: { code: 103, error: 'Invalid class name' } },
      { status: 404, response: { code: 103, error: 'Invalid class name' } },
    ]);
    const p = new ParseObject('Per$on');
    expect(p._getPendingOps().length).toBe(1);
    p.increment('updates');
    p.save().catch(() => {});
    jest.runAllTicks();
    await flushPromises();
    expect(p._getPendingOps().length).toBe(1);
    p.set('updates', 12);
    p.save().catch(() => {});
    jest.runAllTicks();
    await flushPromises();
    expect(p._getPendingOps().length).toBe(1);
    jest.runAllTicks();
    await flushPromises();
    expect(p._getPendingOps().length).toBe(1);
    expect(p._getPendingOps()[0]).toEqual({
      updates: new ParseOp.SetOp(12),
    });
  });

  it('will deep-save the children of an object', async () => {
    expect.assertions(4);
    mockFetch([
      { status: 200, response: [{ success: { objectId: 'child' } }] },
      { status: 200, response: { objectId: 'parent' } },
    ])
    const parent = new ParseObject('Item');
    const child = new ParseObject('Item');
    child.set('value', 5);
    parent.set('child', child);
    const result = parent.save().then(() => {
      expect(child.id).toBe('child');
      expect(child.dirty()).toBe(false);
      expect(parent.id).toBe('parent');
    });
    await result;
    expect(fetch.mock.calls[0][0]).toEqual('https://api.parse.com/1/batch');
  });

  it('will fail for a circular dependency of non-existing objects', async () => {
    const parent = new ParseObject('Item');
    const child = new ParseObject('Item');
    parent.set('child', child);
    child.set('parent', parent);
    await expect(parent.save()).rejects.toThrowError(
      'Cannot create a pointer to an unsaved Object.'
    );
  });

  it('will fail for deeper unsaved objects', async () => {
    const parent = new ParseObject('Item');
    const child = new ParseObject('Item');
    const grandchild = new ParseObject('Item');
    parent.set('child', child);
    child.set('child', grandchild);
    await expect(parent.save()).rejects.toThrowError(
      'Cannot create a pointer to an unsaved Object.'
    );
  });

  it('does not mark shallow objects as dirty', () => {
    const post = new ParseObject('Post');
    post.id = '141414';
    expect(post.dirty()).toBe(false);

    const comment = new ParseObject('Comment');
    comment.set('parent', post);
    expect(unsavedChildren(comment)).toEqual([]);
  });

  it('can fetch an object given an id', async () => {
    expect.assertions(2);
    mockFetch([{ status: 200, response: { count: 10 } }]);
    const p = new ParseObject('Person');
    p.id = 'P55';
    await p.fetch().then(res => {
      expect(p).toBe(res);
      expect(p.attributes).toEqual({ count: 10 });
    });
  });

  it('throw for fetch with empty string as ID', async () => {
    expect.assertions(1);
    mockFetch([{ status: 200, response: { count: 10 } }]);
    const p = new ParseObject('Person');
    p.id = '';
    await expect(p.fetch()).rejects.toThrowError(
      new ParseError(ParseError.MISSING_OBJECT_ID, 'Object does not have an ID')
    );
  });

  it('should fail saveAll batch cycle', async () => {
    const obj = new ParseObject('Item');
    obj.set('child', obj);

    await expect(ParseObject.saveAll([obj])).rejects.toEqual(
      expect.objectContaining({
        message: 'Tried to save a batch with a cycle.',
      })
    );
  });

  it('should fail save with transaction and batchSize option', async () => {
    const obj1 = new ParseObject('TestObject');
    const obj2 = new ParseObject('TestObject');

    await expect(
      ParseObject.saveAll([obj1, obj2], { transaction: true, batchSize: 20 })
    ).rejects.toEqual(
      expect.objectContaining({
        message: 'You cannot use both transaction and batchSize options simultaneously.',
      })
    );
  });

  it('should fail destroy with transaction and batchSize option', async () => {
    const obj1 = new ParseObject('TestObject');
    const obj2 = new ParseObject('TestObject');

    await expect(
      ParseObject.destroyAll([obj1, obj2], { transaction: true, batchSize: 20 })
    ).rejects.toEqual(
      expect.objectContaining({
        message: 'You cannot use both transaction and batchSize options simultaneously.',
      })
    );
  });

  it('should fail save batch with unserializable attribute and transaction option', async () => {
    const obj1 = new ParseObject('TestObject');
    const obj2 = new ParseObject('TestObject');
    obj1.set('relatedObject', obj2);

    await expect(ParseObject.saveAll([obj1, obj2], { transaction: true })).rejects.toEqual(
      expect.objectContaining({
        message:
          'Tried to save a transactional batch containing an object with unserializable attributes.',
      })
    );
  });

  it('should fail to save object when its children lack IDs using transaction option', async () => {
    mockFetch([{ status: 200, response: [] }]);

    const obj1 = new ParseObject('TestObject');
    const obj2 = new ParseObject('TestObject');
    obj1.set('relatedObject', obj2);

    await expect(obj1.save(null, { transaction: true })).rejects.toEqual(
      expect.objectContaining({
        message:
          'Tried to save a transactional batch containing an object with unserializable attributes.',
      })
    );
  });

  it('should save batch with serializable attribute and transaction option', async () => {
    mockFetch([{
      status: 200,
      response: [{ success: { objectId: 'parent' } }, { success: { objectId: 'id2' } }],
    }]);
    const controller = CoreManager.getRESTController();
    jest.spyOn(controller, 'request');

    const obj1 = new ParseObject('TestObject');
    const obj2 = new ParseObject('TestObject');
    obj2.id = 'id2';
    obj1.set('relatedObject', obj2);

    const [saved1, saved2] = await ParseObject.saveAll([obj1, obj2], { transaction: true });

    expect(saved1.dirty()).toBe(false);
    expect(saved2.dirty()).toBe(false);
    expect(saved1.id).toBe('parent');
    expect(saved2.id).toBe('id2');

    expect(controller.request).toHaveBeenCalledWith(
      'POST',
      'batch',
      {
        requests: [
          {
            method: 'POST',
            body: {
              relatedObject: { __type: 'Pointer', className: 'TestObject', objectId: 'id2' },
            },
            path: '/1/classes/TestObject',
          },
          { method: 'PUT', body: {}, path: '/1/classes/TestObject/id2' },
        ],
        transaction: true,
      },
      expect.anything()
    );
  });

  it('should save object along with its children using transaction option', async () => {
    mockFetch([{
      status: 200,
      response: [{ success: { objectId: 'id2' } }, { success: { objectId: 'parent' } }],
    }]);
    const controller = CoreManager.getRESTController();
    jest.spyOn(controller, 'request');

    const obj1 = new ParseObject('TestObject');
    const obj2 = new ParseObject('TestObject');
    obj2.id = 'id2';
    obj2.set('attribute', true);

    obj1.set('relatedObject', obj2);

    const saved1 = await obj1.save(null, { transaction: true });

    const saved2 = saved1.get('relatedObject');
    expect(saved1.dirty()).toBe(false);
    expect(saved2.dirty()).toBe(false);
    expect(saved1.id).toBe('parent');
    expect(saved2.id).toBe('id2');

    expect(controller.request).toHaveBeenCalledWith(
      'POST',
      'batch',
      {
        requests: [
          {
            method: 'PUT',
            body: { attribute: true },
            path: '/1/classes/TestObject/id2',
          },
          {
            method: 'POST',
            body: {
              relatedObject: { __type: 'Pointer', className: 'TestObject', objectId: 'id2' },
            },
            path: '/1/classes/TestObject',
          },
        ],
        transaction: true,
      },
      expect.anything()
    );
  });

  it('should save file & object along with its children using transaction option', async () => {
    mockFetch([
      {
        status: 200,
        response: { name: 'mock-name', url: 'mock-url' },
      },
      {
        status: 200,
        response: [{ success: { objectId: 'id2' } }, { success: { objectId: 'parent' } }],
      },
    ]);
    const controller = CoreManager.getRESTController();
    jest.spyOn(controller, 'request');

    const file1 = new ParseFile('parse-server-logo', [0, 1, 2, 3]);
    const obj1 = new ParseObject('TestObject');
    const obj2 = new ParseObject('TestObject');
    obj2.id = 'id2';
    obj2.set('file', file1);

    obj1.set('relatedObject', obj2);

    const saved1 = await obj1.save(null, { transaction: true });

    const saved2 = saved1.get('relatedObject');
    expect(saved1.dirty()).toBe(false);
    expect(saved2.dirty()).toBe(false);
    expect(saved1.id).toBe('parent');
    expect(saved2.id).toBe('id2');

    const file = saved2.get('file');
    expect(file.name()).toBe('mock-name');
    expect(file.url()).toBe('mock-url');

    expect(controller.request).toHaveBeenCalledWith(
      'POST',
      'batch',
      {
        requests: [
          {
            method: 'PUT',
            body: { file: { __type: 'File', name: 'mock-name', url: 'mock-url' } },
            path: '/1/classes/TestObject/id2',
          },
          {
            method: 'POST',
            body: {
              relatedObject: { __type: 'Pointer', className: 'TestObject', objectId: 'id2' },
            },
            path: '/1/classes/TestObject',
          },
        ],
        transaction: true,
      },
      expect.anything()
    );
  });

  it('should destroy batch with transaction option', async () => {
    mockFetch([
      {
        status: 200,
        response: [{ success: { objectId: 'parent' } }, { success: { objectId: 'id2' } }],
      },
    ]);
    const controller = CoreManager.getRESTController();
    jest.spyOn(controller, 'request');

    const obj1 = new ParseObject('TestObject');
    const obj2 = new ParseObject('TestObject');
    obj1.id = 'parent';
    obj2.id = 'id2';

    await ParseObject.destroyAll([obj1, obj2], { transaction: true });

    expect(controller.request).toHaveBeenCalledWith(
      'POST',
      'batch',
      {
        requests: [
          { method: 'DELETE', body: {}, path: '/1/classes/TestObject/parent' },
          { method: 'DELETE', body: {}, path: '/1/classes/TestObject/id2' },
        ],
        transaction: true,
      },
      expect.anything()
    );
  });

  it('should fail on invalid date', done => {
    const obj = new ParseObject('Item');
    obj.set('when', new Date(Date.parse(null)));
    ParseObject.saveAll([obj])
      .then(() => {
        done.fail('Expected invalid date to fail');
      })
      .catch(error => {
        expect(error[0].code).toEqual(ParseError.INCORRECT_TYPE);
        expect(error[0].message).toEqual('Tried to encode an invalid date.');
        done();
      });
    jest.runAllTicks();
  });

  it('can save a ring of objects, given one exists', async () => {
    mockFetch([
      { status: 200, response: [{ success: { objectId: 'parent' } }] },
      { status: 200, response: [{ success: {} }] },
    ]);
    const parent = new ParseObject('Item');
    const child = new ParseObject('Item');
    child.id = 'child';
    parent.set('child', child);
    child.set('parent', parent);

    const result = ParseObject.saveAll([parent, child]).then(() => {
      expect(child.dirty()).toBe(false);
      expect(parent.id).toBe('parent');
    });
    jest.runAllTicks();
    await flushPromises();

    expect(fetch.mock.calls[0][0]).toEqual('https://api.parse.com/1/batch');
    expect(JSON.parse(fetch.mock.calls[0][1].body).requests).toEqual([
      {
        method: 'POST',
        path: '/1/classes/Item',
        body: {
          child: {
            __type: 'Pointer',
            className: 'Item',
            objectId: 'child',
          },
        },
      },
    ]);
    jest.runAllTicks();
    await flushPromises();

    expect(parent.id).toBe('parent');
    jest.runAllTicks();

    await result;
  });

  it('accepts context on saveAll', async () => {
    mockFetch([{ status: 200, response: [{}] }]);
    // Spy on REST controller
    const controller = CoreManager.getRESTController();
    jest.spyOn(controller, 'ajax');
    // Save object
    const context = { a: 'saveAll' };
    const obj = new ParseObject('Item');
    obj.id = 'pid';
    obj.set('test', 'value');
    await ParseObject.saveAll([obj], { context, useMasterKey: true });
    // Validate
    const jsonBody = JSON.parse(controller.ajax.mock.calls[0][2]);
    expect(jsonBody._context).toEqual(context);
  });

  it('accepts context on destroyAll', async () => {
    mockFetch([{ status: 200, response: [{}] }]);
    // Spy on REST controller
    const controller = CoreManager.getRESTController();
    jest.spyOn(controller, 'ajax');
    // Save object
    const context = { a: 'b' };
    const obj = new ParseObject('Item');
    obj.id = 'pid';
    await ParseObject.destroyAll([obj], { context: context });
    // Validate
    const jsonBody = JSON.parse(controller.ajax.mock.calls[0][2]);
    expect(jsonBody._context).toEqual(context);
  });

  it('destroyAll with options', async () => {
    mockFetch([{ status: 200, response: [{}] }]);
    const controller = CoreManager.getRESTController();
    jest.spyOn(controller, 'ajax');

    const obj = new ParseObject('Item');
    obj.id = 'pid';
    await ParseObject.destroyAll([obj], {
      useMasterKey: true,
      sessionToken: 'r:1234',
      batchSize: 25,
    });

    const jsonBody = JSON.parse(controller.ajax.mock.calls[0][2]);
    expect(jsonBody._MasterKey).toBe('C');
    expect(jsonBody._SessionToken).toBe('r:1234');
  });

  it('destroyAll with empty values', async () => {
    mockFetch([{ status: 200, response: [{}] }]);
    const controller = CoreManager.getRESTController();
    jest.spyOn(controller, 'ajax');

    let results = await ParseObject.destroyAll([]);
    expect(results).toEqual([]);

    results = await ParseObject.destroyAll(null);
    expect(results).toEqual(null);
    expect(controller.ajax).toHaveBeenCalledTimes(0);
  });

  it('destroyAll unsaved objects', async () => {
    mockFetch([{ status: 200, response: [{}] }]);
    const controller = CoreManager.getRESTController();
    jest.spyOn(controller, 'ajax');

    const obj = new ParseObject('Item');
    const results = await ParseObject.destroyAll([obj]);
    expect(results).toEqual([obj]);
    expect(controller.ajax).toHaveBeenCalledTimes(0);
  });

  it('destroyAll handle error response', async () => {
    mockFetch([
      {
        status: 200,
        response: [
          {
            error: {
              code: 101,
              error: 'Object not found',
            },
          },
        ],
      },
    ]);
    const obj = new ParseObject('Item');
    obj.id = 'toDelete1';
    try {
      await ParseObject.destroyAll([obj]);
      expect(true).toBe(false);
    } catch (e) {
      expect(e.code).toBe(600);
    }
  });

  it('can save a chain of unsaved objects', async () => {
    mockFetch([
      { status: 200, response: [{ success: { objectId: 'grandchild' } }] },
      { status: 200, response: [{ success: { objectId: 'child' } }] },
      { status: 200, response: [{ success: { objectId: 'parent' } }] },
    ]);
    const parent = new ParseObject('Item');
    const child = new ParseObject('Item');
    const grandchild = new ParseObject('Item');
    parent.set('child', child);
    child.set('child', grandchild);

    const result = ParseObject.saveAll([parent]).then(() => {
      expect(child.dirty()).toBe(false);
      expect(grandchild.dirty()).toBe(false);
      expect(parent.id).toBe('parent');
      expect(child.id).toBe('child');
      expect(grandchild.id).toBe('grandchild');
    });
    jest.runAllTicks();
    await flushPromises();

    expect(fetch.mock.calls[0][0]).toEqual('https://api.parse.com/1/batch');
    expect(JSON.parse(fetch.mock.calls[0][1].body).requests).toEqual([
      {
        method: 'POST',
        path: '/1/classes/Item',
        body: {},
      },
    ]);
    expect(fetch.mock.calls[1][0]).toEqual('https://api.parse.com/1/batch');
    expect(JSON.parse(fetch.mock.calls[1][1].body).requests).toEqual([
      {
        method: 'POST',
        path: '/1/classes/Item',
        body: {
          child: {
            __type: 'Pointer',
            className: 'Item',
            objectId: 'grandchild',
          },
        },
      },
    ]);
    expect(fetch.mock.calls[2][0]).toEqual('https://api.parse.com/1/batch');
    expect(JSON.parse(fetch.mock.calls[2][1].body).requests).toEqual([
      {
        method: 'POST',
        path: '/1/classes/Item',
        body: {
          child: {
            __type: 'Pointer',
            className: 'Item',
            objectId: 'child',
          },
        },
      },
    ]);
    jest.runAllTicks();
    await result;
  });

  it('can update fields via a fetch() call', done => {
    mockFetch([
      {
        status: 200,
        response: {
          count: 11,
        },
      },
      {
        status: 200,
        response: {
          count: 20,
        },
      },
    ]);
    const p = new ParseObject('Person');
    p.id = 'P55';
    p.increment('count');
    p.save()
      .then(() => {
        expect(p.get('count')).toBe(11);
        return p.fetch();
      })
      .then(() => {
        expect(p.get('count')).toBe(20);
        expect(p.dirty()).toBe(false);
        done();
      });
  });

  it('replaces old data when fetch() is called', done => {
    mockFetch([
      {
        status: 200,
        response: {
          count: 10,
        },
      },
    ])
    const p = ParseObject.fromJSON({
      className: 'Person',
      objectId: 'P200',
      name: 'Fred',
      count: 0,
    });
    expect(p.get('name')).toBe('Fred');
    expect(p.get('count')).toBe(0);
    p.fetch().then(() => {
      expect(p.get('count')).toBe(10);
      expect(p.get('name')).toBe(undefined);
      expect(p.has('name')).toBe(false);
      done();
    });
  });

  it('can destroy an object', async () => {
    mockFetch([{ status: 200, response: { objectId: 'pid' } }]);
    const p = new ParseObject('Person');
    p.id = 'pid';
    await p.destroy({ sessionToken: 't_1234' });
    expect(fetch.mock.calls[0][0]).toEqual('https://api.parse.com/1/classes/Person/pid');
    expect(JSON.parse(fetch.mock.calls[0][1].body)._method).toBe('DELETE');
    expect(JSON.parse(fetch.mock.calls[0][1].body)._SessionToken).toBe('t_1234');
  });

  it('accepts context on destroy', async () => {
    mockFetch([{ status: 200, response: [{}] }]);
    // Spy on REST controller
    const controller = CoreManager.getRESTController();
    jest.spyOn(controller, 'ajax');
    // Save object
    const context = { a: 'a' };
    const obj = new ParseObject('Item');
    obj.id = 'pid';
    await obj.destroy({ context });
    // Validate
    const jsonBody = JSON.parse(controller.ajax.mock.calls[0][2]);
    expect(jsonBody._context).toEqual(context);
  });

  it('handle destroy on new object', async () => {
    const controller = CoreManager.getRESTController();
    jest.spyOn(controller, 'ajax');

    const obj = new ParseObject('Item');

    await obj.destroy({ useMasterKey: true });

    expect(controller.ajax).toHaveBeenCalledTimes(0);
  });

  it('can save an array of objects', async () => {
    mockFetch([{
      status: 200,
      response: [
        { success: { objectId: 'pid0' } },
        { success: { objectId: 'pid1' } },
        { success: { objectId: 'pid2' } },
        { success: { objectId: 'pid3' } },
        { success: { objectId: 'pid4' } },
      ],
    }]);
    const objects = [];
    for (let i = 0; i < 5; i++) {
      objects[i] = new ParseObject('Person');
    }
    const results = await ParseObject.saveAll(objects);
    expect(results.every(obj => obj.id !== undefined)).toBe(true);
    expect(fetch.mock.calls[0][0]).toEqual('https://api.parse.com/1/batch');
    expect(JSON.parse(fetch.mock.calls[0][1].body).requests[0]).toEqual({
      method: 'POST',
      path: '/1/classes/Person',
      body: {},
    });
  });

  it('can saveAll with batchSize', async () => {
    const objects = [];
    const response = [];
    for (let i = 0; i < 22; i++) {
      objects[i] = new ParseObject('Person');
      response[i] = { success: { objectId: `pid${i}` } };
    }
    mockFetch([
      { status: 200, response: response.slice(0, 20) },
      { status: 200, response: response.slice(20) },
    ]);
    await ParseObject.saveAll(objects, { batchSize: 20 });
    expect(fetch.mock.calls[0][0]).toEqual('https://api.parse.com/1/batch');
    expect(fetch.mock.calls[1][0]).toEqual('https://api.parse.com/1/batch');
  });

  it('can saveAll with global batchSize', async () => {
    const objects = [];
    const response = [];
    for (let i = 0; i < 22; i++) {
      objects[i] = new ParseObject('Person');
      response[i] = { success: { objectId: `pid${i}` } };
    }
    mockFetch([
      { status: 200, response: response.slice(0, 20) },
      { status: 200, response: response.slice(20) },
    ]);
    await ParseObject.saveAll(objects);
    expect(fetch.mock.calls[0][0]).toEqual('https://api.parse.com/1/batch');
    expect(fetch.mock.calls[1][0]).toEqual('https://api.parse.com/1/batch');
  });

  it('returns the first error when saving an array of objects', async () => {
    expect.assertions(4);
    const response = [
      { success: { objectId: 'pid0' } },
      { success: { objectId: 'pid1' } },
      { success: { objectId: 'pid2' } },
      { success: { objectId: 'pid3' } },
      { success: { objectId: 'pid4' } },
      { success: { objectId: 'pid5' } },
      { error: { code: -1, error: 'first error' } },
      { success: { objectId: 'pid7' } },
      { success: { objectId: 'pid8' } },
      { success: { objectId: 'pid9' } },
      { success: { objectId: 'pid10' } },
      { success: { objectId: 'pid11' } },
      { success: { objectId: 'pid12' } },
      { success: { objectId: 'pid13' } },
      { success: { objectId: 'pid14' } },
      { error: { code: -1, error: 'second error' } },
      { success: { objectId: 'pid16' } },
      { success: { objectId: 'pid17' } },
      { success: { objectId: 'pid18' } },
      { success: { objectId: 'pid19' } },
    ];
    mockFetch([{ status: 200, response }, { status: 200, response }]);
    const objects = [];
    for (let i = 0; i < 22; i++) {
      objects[i] = new ParseObject('Person');
    }
    try {
      await ParseObject.saveAll(objects);
    } catch (error) {
      // The second batch never ran
      expect(objects[19].dirty()).toBe(false);
      expect(objects[20].dirty()).toBe(true);
      expect(error.message).toBe('first error');
      expect(fetch.mock.calls.length).toBe(1);
    }
  });
});

describe('ObjectController', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('can fetch a single object', async () => {
    const objectController = CoreManager.getObjectController();
    mockFetch([{ status: 200, response: { objectId: 'pid'} }]);

    const o = new ParseObject('Person');
    o.id = 'pid';
    await objectController.fetch(o);
    expect(fetch.mock.calls[0][0]).toEqual('https://api.parse.com/1/classes/Person/pid');
    const body = JSON.parse(fetch.mock.calls[0][1].body);
    expect(body._method).toBe('GET');
  });

  it('accepts context on fetch', async () => {
    mockFetch([{ status: 200, response: {} }]);
    // Spy on REST controller
    const controller = CoreManager.getRESTController();
    jest.spyOn(controller, 'ajax');
    // Save object
    const context = { a: 'fetch' };
    const obj = new ParseObject('Item');
    obj.id = 'pid';
    await obj.fetch({ context });
    // Validate
    const jsonBody = JSON.parse(controller.ajax.mock.calls[0][2]);
    expect(jsonBody._context).toEqual(context);
  });

  it('can fetch an array of objects', done => {
    const objectController = CoreManager.getObjectController();
    const objects = [];
    for (let i = 0; i < 5; i++) {
      objects[i] = new ParseObject('Person');
      objects[i].id = 'pid' + i;
    }
    objectController.fetch(objects).then(results => {
      expect(results.length).toBe(5);
      expect(results[0] instanceof ParseObject).toBe(true);
      expect(results[0].id).toBe('pid0');
      expect(results[0].className).toBe('Person');
      done();
    });
  });

  it('can fetch a single object with include', async () => {
    expect.assertions(2);
    const objectController = CoreManager.getObjectController();
    mockFetch([{ status: 200, response: { objectId: 'pid'} }]);

    const o = new ParseObject('Person');
    o.id = 'pid';
    await objectController.fetch(o, false, { include: ['child'] });
    expect(fetch.mock.calls[0][0]).toEqual('https://api.parse.com/1/classes/Person/pid');
    const body = JSON.parse(fetch.mock.calls[0][1].body);
    expect(body._method).toBe('GET');
  });

  it('can fetch an array of objects with include', async () => {
    const objectController = CoreManager.getObjectController();
    const objects = [];
    for (let i = 0; i < 5; i++) {
      objects[i] = new ParseObject('Person');
      objects[i].id = 'pid' + i;
    }
    const results = await objectController.fetch(objects, false, {
      include: ['child'],
    });
    expect(results.length).toBe(5);
    expect(results[0] instanceof ParseObject).toBe(true);
    expect(results[0].id).toBe('pid0');
    expect(results[0].className).toBe('Person');
  });

  it('can destroy an object', async () => {
    const objectController = CoreManager.getObjectController();
    mockFetch([
      { status: 200, response: { results: [] } },
      { status: 200, response: { results: [] } },
    ]);
    const p = new ParseObject('Person');
    p.id = 'pid';
    await objectController.destroy(p, {});
    expect(fetch.mock.calls[0][0]).toEqual('https://api.parse.com/1/classes/Person/pid');
    expect(JSON.parse(fetch.mock.calls[0][1].body)._method).toBe('DELETE');
    const p2 = new ParseObject('Person');
    p2.id = 'pid2';
    await objectController.destroy(p2, {
      useMasterKey: true,
    });
    expect(fetch.mock.calls[1][0]).toEqual('https://api.parse.com/1/classes/Person/pid2');
    const body = JSON.parse(fetch.mock.calls[1][1].body);
    expect(body._method).toBe('DELETE');
    expect(body._MasterKey).toBe('C');
  });

  it('can destroy an array of objects with batchSize', async () => {
    const objectController = CoreManager.getObjectController();
    let response = [];
    let objects = [];
    for (let i = 0; i < 5; i++) {
      objects[i] = new ParseObject('Person');
      objects[i].id = 'pid' + i;
      response.push({
        success: { objectId: 'pid' + i },
      });
    }
    mockFetch([{ status: 200, response }]);

    await objectController.destroy(objects, { batchSize: 20 });
    expect(fetch.mock.calls[0][0]).toEqual('https://api.parse.com/1/batch');
    expect(JSON.parse(fetch.mock.calls[0][1].body).requests).toEqual([
      {
        method: 'DELETE',
        path: '/1/classes/Person/pid0',
        body: {},
      },
      {
        method: 'DELETE',
        path: '/1/classes/Person/pid1',
        body: {},
      },
      {
        method: 'DELETE',
        path: '/1/classes/Person/pid2',
        body: {},
      },
      {
        method: 'DELETE',
        path: '/1/classes/Person/pid3',
        body: {},
      },
      {
        method: 'DELETE',
        path: '/1/classes/Person/pid4',
        body: {},
      },
    ]);

    objects = [];
    response = [];
    for (let i = 0; i < 22; i++) {
      objects[i] = new ParseObject('Person');
      objects[i].id = 'pid' + i;
      response.push({
        success: { objectId: 'pid' + i },
      });
    }
    mockFetch([{ status: 200, response }, { status: 200, response: response.slice(20) }]);

    await objectController.destroy(objects, { batchSize: 20 });
    expect(fetch.mock.calls.length).toBe(2);
    expect(JSON.parse(fetch.mock.calls[0][1].body).requests.length).toBe(20);
    expect(JSON.parse(fetch.mock.calls[1][1].body).requests.length).toBe(2);
  });

  it('can destroy an array of objects', async () => {
    const objectController = CoreManager.getObjectController();
    let response = [];
    let objects = [];
    for (let i = 0; i < 5; i++) {
      objects[i] = new ParseObject('Person');
      objects[i].id = 'pid' + i;
      response.push({
        success: { objectId: 'pid' + i },
      });
    }
    mockFetch([{ status: 200, response }]);

    await objectController.destroy(objects, {});
    expect(fetch.mock.calls[0][0]).toEqual('https://api.parse.com/1/batch');
    expect(JSON.parse(fetch.mock.calls[0][1].body).requests).toEqual([
      {
        method: 'DELETE',
        path: '/1/classes/Person/pid0',
        body: {},
      },
      {
        method: 'DELETE',
        path: '/1/classes/Person/pid1',
        body: {},
      },
      {
        method: 'DELETE',
        path: '/1/classes/Person/pid2',
        body: {},
      },
      {
        method: 'DELETE',
        path: '/1/classes/Person/pid3',
        body: {},
      },
      {
        method: 'DELETE',
        path: '/1/classes/Person/pid4',
        body: {},
      },
    ]);

    objects = [];
    response = [];
    for (let i = 0; i < 22; i++) {
      objects[i] = new ParseObject('Person');
      objects[i].id = 'pid' + i;
      response.push({
        success: { objectId: 'pid' + i },
      });
    }
    mockFetch([{ status: 200, response }, { status: 200, response: response.slice(20) }]);

    await objectController.destroy(objects, {});
    expect(fetch.mock.calls.length).toBe(2);
    expect(JSON.parse(fetch.mock.calls[0][1].body).requests.length).toBe(20);
    expect(JSON.parse(fetch.mock.calls[1][1].body).requests.length).toBe(2);
  });

  it('can destroy the object eventually on network failure', async () => {
    const p = new ParseObject('Person');
    jest.spyOn(EventuallyQueue, 'destroy').mockImplementationOnce(() => Promise.resolve());
    jest.spyOn(EventuallyQueue, 'poll').mockImplementationOnce(() => {});
    jest.spyOn(p, 'destroy').mockImplementationOnce(() => {
      throw new ParseError(
        ParseError.CONNECTION_FAILED,
        'XMLHttpRequest failed: ""Unable to connect to the Parse API""'
      );
    });
    await p.destroyEventually();
    expect(EventuallyQueue.destroy).toHaveBeenCalledTimes(1);
    expect(EventuallyQueue.poll).toHaveBeenCalledTimes(1);
  });

  it('should not destroy object eventually on error', async () => {
    const p = new ParseObject('Person');
    jest.spyOn(EventuallyQueue, 'destroy').mockImplementationOnce(() => Promise.resolve());
    jest.spyOn(EventuallyQueue, 'poll').mockImplementationOnce(() => {});
    jest.spyOn(p, 'destroy').mockImplementationOnce(() => {
      throw new ParseError(ParseError.OTHER_CAUSE, 'Unable to delete.');
    });
    await p.destroyEventually();
    expect(EventuallyQueue.destroy).toHaveBeenCalledTimes(0);
    expect(EventuallyQueue.poll).toHaveBeenCalledTimes(0);
  });

  it('can save an object', async () => {
    const objectController = CoreManager.getObjectController();
    mockFetch([{ status: 200, response: { objectId: 'pid', key: 'value' } }]);

    const p = new ParseObject('Person');
    p.id = 'pid';
    p.set('key', 'value');
    await objectController.save(p, {});
    expect(fetch.mock.calls[0][0]).toEqual('https://api.parse.com/1/classes/Person/pid');
    const body = JSON.parse(fetch.mock.calls[0][1].body);
    expect(body.key).toBe('value');
  });

  it('returns an empty promise from an empty save', done => {
    const objectController = CoreManager.getObjectController();
    objectController.save().then(() => {
      done();
    });
    jest.runAllTicks();
  });

  it('can save an array of files', async () => {
    const objectController = CoreManager.getObjectController();
    const names = ['parse.txt', 'parse2.txt', 'parse3.txt'];
    const responses = [];
    for (let i = 0; i < 3; i++) {
      responses.push({
        status: 200,
        response:{
          name: names[i],
          url: 'http://files.parsetfss.com/a/' + names[i],
        },
      });
    }
    mockFetch(responses);
    const files = [
      new ParseFile('parse.txt', { base64: 'ParseA==' }),
      new ParseFile('parse2.txt', { base64: 'ParseA==' }),
      new ParseFile('parse3.txt', { base64: 'ParseA==' }),
    ];
    await objectController.save(files, {});
    // TODO: why they all have same url?
    // expect(files[0].url()).toBe('http://files.parsetfss.com/a/parse.txt');
    // expect(files[1].url()).toBe('http://files.parsetfss.com/a/parse2.txt');
    expect(files[2].url()).toBe('http://files.parsetfss.com/a/parse3.txt');
  });

  it('can save an array of objects', async () => {
    const objectController = CoreManager.getObjectController();
    let response = [];
    const objects = [];
    for (let i = 0; i < 5; i++) {
      objects[i] = new ParseObject('Person');
      objects[i].set('index', i);
      response.push({
        success: { objectId: 'pid' + i, index: i },
      });
    }
    mockFetch([{ status: 200, response }]);
    const results = await objectController.save(objects, {});
    expect(results.length).toBe(5);
    expect(results[0].id).toBe('pid0');
    expect(results[0].get('index')).toBe(0);
    expect(results[0].dirty()).toBe(false);

    response = [];
    for (let i = 0; i < 22; i++) {
      objects[i] = new ParseObject('Person');
      objects[i].set('index', i);
      response.push({
        success: { objectId: 'pid' + i, index: i },
      });
    }
    mockFetch([
      { status: 200, response: response.slice(0, 20) },
      { status: 200, response: response.slice(20) },
    ]);
    const saved = await objectController.save(objects, {});

    for (let i = 0; i < saved.length; i += 1) {
      expect(objects[i].dirty()).toBe(false);
      expect(objects[i].id).toBe(`pid${i}`);
      expect(objects[i].get('index')).toBe(i);
    }
    expect(saved.length).toBe(22);
    expect(fetch.mock.calls.length).toBe(2);
  });

  it('does not fail when checking if arrays of pointers are dirty', async () => {
    mockFetch([
      { status: 200, response: [{ success: { objectId: 'i333' } }] },
      { status: 200, response: {} },
    ])
    const brand = ParseObject.fromJSON({
      className: 'Brand',
      objectId: 'b123',
      items: [{ __type: 'Pointer', objectId: 'i222', className: 'Item' }],
    });
    expect(brand._getSaveJSON()).toEqual({});
    const items = brand.get('items');
    items.push(new ParseObject('Item'));
    brand.set('items', items);
    expect(function () {
      brand.save();
    }).not.toThrow();
  });

  it('can create a new instance of an object', () => {
    const o = ParseObject.fromJSON({
      className: 'Clone',
      objectId: 'C12',
    });
    const o2 = o.newInstance();
    expect(o.id).toBe(o2.id);
    expect(o.className).toBe(o2.className);
    o.set({ valid: true });
    expect(o2.get('valid')).toBe(true);

    expect(o).not.toBe(o2);
  });

  it('cannot create a new instance of an object without className', () => {
    expect(() => {
      ParseObject.fromJSON({});
    }).toThrow('Cannot create an object without a className');
  });
});

describe('ParseObject (unique instance mode)', () => {
  beforeEach(() => {
    ParseObject.disableSingleInstance();
  });

  it('can be created with initial attributes', () => {
    const o = new ParseObject({
      className: 'Item',
      value: 12,
    });
    expect(o.className).toBe('Item');
    expect(o.attributes).toEqual({ value: 12 });
  });

  it('can be inflated from server JSON', () => {
    const json = {
      className: 'Item',
      createdAt: '2013-12-14T04:51:19Z',
      objectId: 'I1',
      size: 'medium',
    };
    const o = ParseObject.fromJSON(json);
    expect(o.className).toBe('Item');
    expect(o.id).toBe('I1');
    expect(o.attributes).toEqual({
      size: 'medium',
      createdAt: new Date(Date.UTC(2013, 11, 14, 4, 51, 19)),
      updatedAt: new Date(Date.UTC(2013, 11, 14, 4, 51, 19)),
    });
    expect(o.dirty()).toBe(false);
  });

  it('can be rendered to JSON', () => {
    let o = new ParseObject('Item');
    o.set({
      size: 'large',
      inStock: 18,
    });
    expect(o.toJSON()).toEqual({
      size: 'large',
      inStock: 18,
    });
    o = new ParseObject('Item');
    o._finishFetch({
      objectId: 'O2',
      size: 'medium',
      inStock: 12,
    });
    expect(o.id).toBe('O2');
    expect(o.toJSON()).toEqual({
      objectId: 'O2',
      size: 'medium',
      inStock: 12,
    });
  });

  it('can add, update, and remove attributes', () => {
    const o = new ParseObject({
      className: 'Item',
      objectId: 'anObjectId',
      value: 12,
      valid: true,
    });
    o.set({ value: 14 });
    expect(o.get('value')).toBe(14);
    o.unset('valid');
    expect(o.get('valid')).toBe(undefined);
    expect(o.dirtyKeys()).toEqual(['value', 'valid']);
    o.increment('value');
    expect(o.get('value')).toEqual(15);

    o.clear();
    expect(o.get('value')).toBe(undefined);

    const o2 = ParseObject.fromJSON({
      className: 'Item',
      tags: ['#tbt'],
    });

    o2.add('tags', '#nofilter');
    expect(o2.get('tags')).toEqual(['#tbt', '#nofilter']);

    o2.revert();
    o2.addUnique('tags', '#tbt');
    expect(o2.get('tags')).toEqual(['#tbt']);

    o2.revert();
    o2.remove('tags', '#tbt');
    expect(o2.get('tags')).toEqual([]);
  });

  it('can save the object', done => {
    mockFetch([
      {
        status: 200,
        response: {
          objectId: 'P1',
          count: 1,
        },
      },
    ]);
    const p = new ParseObject('Person');
    p.set('age', 38);
    p.increment('count');
    p.save().then(obj => {
      expect(obj).toBe(p);
      expect(obj.get('age')).toBe(38);
      expect(obj.get('count')).toBe(1);
      expect(obj.op('age')).toBe(undefined);
      expect(obj.dirty()).toBe(false);
      done();
    });
  });

  it('can save an array of objects', async () => {
    mockFetch([{
      status: 200,
      response: [
        { success: { objectId: 'pid0' } },
        { success: { objectId: 'pid1' } },
        { success: { objectId: 'pid2' } },
        { success: { objectId: 'pid3' } },
        { success: { objectId: 'pid4' } },
      ],
    }]);
    const objects = [];
    for (let i = 0; i < 5; i++) {
      objects[i] = new ParseObject('Person');
    }
    const results = await ParseObject.saveAll(objects);
    expect(results.every(obj => obj.id !== undefined)).toBe(true);
    expect(fetch.mock.calls[0][0]).toEqual('https://api.parse.com/1/batch');
    expect(JSON.parse(fetch.mock.calls[0][1].body).requests[0]).toEqual({
      method: 'POST',
      path: '/1/classes/Person',
      body: {},
    });
  });

  it('preserves changes when changing the id', () => {
    const o = new ParseObject({
      className: 'Item',
      objectId: 'anObjectId',
      value: 12,
    });
    o.id = 'otherId';
    expect(o.get('value')).toBe(12);
  });

  it('can maintain differences between two instances of an object', () => {
    const o = new ParseObject({
      className: 'Item',
      objectId: 'anObjectId',
      value: 12,
    });
    const o2 = new ParseObject({
      className: 'Item',
      objectId: 'anObjectId',
      value: 12,
    });
    o.set({ value: 100 });
    expect(o.get('value')).toBe(100);
    expect(o2.get('value')).toBe(12);

    o2.set({ name: 'foo' });
    expect(o.has('name')).toBe(false);
    expect(o2.has('name')).toBe(true);
  });

  it('can create a new instance of an object', () => {
    const o = ParseObject.fromJSON({
      className: 'Clone',
      objectId: 'C14',
    });
    let o2 = o.newInstance();
    expect(o.id).toBe(o2.id);
    expect(o.className).toBe(o2.className);
    expect(o).not.toBe(o2);
    o.set({ valid: true });
    expect(o2.get('valid')).toBe(undefined);
    o2 = o.newInstance();
    expect(o2.get('valid')).toBe(true);
  });
});

class MyObject extends ParseObject {
  constructor() {
    super('MyObject');
  }

  doSomething() {
    return 5;
  }

  static readOnlyAttributes() {
    return ['readonly', 'static', 'frozen'];
  }
}

ParseObject.registerSubclass('MyObject', MyObject);

describe('ParseObject Subclasses', () => {
  beforeEach(() => {
    ParseObject.enableSingleInstance();
  });

  it('can be extended with ES6 classes', () => {
    const o = new MyObject();
    expect(o.className).toBe('MyObject');
    expect(MyObject.className).toBe('MyObject');
    o.id = 'anObjectId';
    expect(o.toPointer()).toEqual({
      __type: 'Pointer',
      className: 'MyObject',
      objectId: 'anObjectId',
    });

    expect(o.doSomething()).toBe(5);

    const o2 = MyObject.createWithoutData('otherId');
    expect(o2 instanceof ParseObject).toBe(true);
    expect(o2 instanceof MyObject).toBe(true);
    expect(o2.toPointer()).toEqual({
      __type: 'Pointer',
      className: 'MyObject',
      objectId: 'otherId',
    });
    expect(o2.doSomething()).toBe(5);
  });

  it('respects readonly attributes of subclasses', () => {
    const o = new MyObject();
    o.set('readwrite', true);
    expect(o.set.bind(o, 'readonly')).toThrow('Cannot modify readonly attribute: readonly');
    expect(o.set.bind(o, 'static')).toThrow('Cannot modify readonly attribute: static');
    expect(o.set.bind(o, 'frozen')).toThrow('Cannot modify readonly attribute: frozen');
  });

  it('registerSubclass errors', () => {
    expect(() => {
      ParseObject.registerSubclass(1234);
    }).toThrow('The first argument must be a valid class name.');

    expect(() => {
      ParseObject.registerSubclass('TestObject', undefined);
    }).toThrow('You must supply a subclass constructor.');

    expect(() => {
      ParseObject.registerSubclass('TestObject', {});
    }).toThrow(
      'You must register the subclass constructor. Did you attempt to register an instance of the subclass?'
    );

    expect(() => {
      ParseObject.unregisterSubclass(1234);
    }).toThrow('The first argument must be a valid class name.');
  });

  it('can use on ParseObject subclass for multiple Parse.Object class names', () => {
    class MyParseObjects extends ParseObject {}
    ParseObject.registerSubclass('TestObject', MyParseObjects);
    ParseObject.registerSubclass('TestObject1', MyParseObjects);
    ParseObject.registerSubclass('TestObject2', MyParseObjects);

    const obj = new MyParseObjects('TestObject');
    expect(obj.className).toBe('TestObject');
    const obj1 = new MyParseObjects('TestObject1');
    expect(obj1.className).toBe('TestObject1');
    const obj2 = new MyParseObjects('TestObject2');
    expect(obj2.className).toBe('TestObject2');

    let classMap = ParseObject._getClassMap();
    expect(classMap.TestObject).toEqual(MyParseObjects);
    expect(classMap.TestObject1).toEqual(MyParseObjects);
    expect(classMap.TestObject2).toEqual(MyParseObjects);

    ParseObject.unregisterSubclass('TestObject');
    ParseObject.unregisterSubclass('TestObject1');
    ParseObject.unregisterSubclass('TestObject2');

    classMap = ParseObject._getClassMap();
    expect(classMap.TestObject).toBeUndefined();
    expect(classMap.TestObject1).toBeUndefined();
    expect(classMap.TestObject2).toBeUndefined();
  });

  it('can inflate subclasses from server JSON', () => {
    const json = {
      className: 'MyObject',
      objectId: 'anotherId',
    };
    const o = ParseObject.fromJSON(json);
    expect(o instanceof ParseObject).toBe(true);
    expect(o.className).toBe('MyObject');
    expect(o.id).toBe('anotherId');
    expect(o.doSomething()).toBe(5);
  });

  it('can be cloned', () => {
    const o = new MyObject();
    o.set({
      size: 'large',
      count: 7,
    });
    const o2 = o.clone();
    expect(o2 instanceof MyObject).toBe(true);
    expect(o2.className).toBe('MyObject');
    expect(o2.attributes).toEqual({
      size: 'large',
      count: 7,
    });
    expect(o2.id).toBe(undefined);
    expect(o.equals(o2)).toBe(false);
  });

  it('can be cleared', () => {
    const o = new MyObject();
    o.set({
      size: 'large',
      count: 7,
    });
    jest.spyOn(o, 'set');
    o.clear();
    expect(o.set).toHaveBeenCalledWith(
      {
        count: true,
        size: true,
      },
      {
        unset: true,
      }
    );
  });
});

describe('ParseObject extensions', () => {
  beforeEach(() => {
    ParseObject.enableSingleInstance();
  });

  it('can extend object', () => {
    const startExtend = Date.now();
    for (let i = 0; i < 100000; i++) {
      const Parent = ParseObject.extend('Parent');

      const parent = new Parent();
    }
    expect(Date.now() - startExtend).toBeLessThan(200);

    const startNew = Date.now();
    for (let i = 0; i < 100000; i++) {
      const parent = new ParseObject('Parent');
    }
    expect(Date.now() - startNew).toBeLessThan(200);
  });

  it('can generate ParseObjects with a default className', () => {
    const YourObject = ParseObject.extend('YourObject');
    const yo = new YourObject();
    expect(yo instanceof ParseObject).toBe(true);
    expect(yo instanceof YourObject).toBe(true);
    expect(yo.className).toBe('YourObject');
    yo.set('greeting', 'yo');
    expect(yo.get('greeting')).toBe('yo');
    expect(yo.attributes).toEqual({
      greeting: 'yo',
    });

    const yo2 = YourObject.createWithoutData('otherId');
    expect(yo2 instanceof ParseObject).toBe(true);
    expect(yo2 instanceof YourObject).toBe(true);
    expect(yo2.toPointer()).toEqual({
      __type: 'Pointer',
      className: 'YourObject',
      objectId: 'otherId',
    });
  });

  it('can extend the prototype and statics of ParseObject', () => {
    const ExtendedObject = ParseObject.extend(
      'ExtendedObject',
      {
        getFoo() {
          return 12;
        },
      },
      {
        isFoo(value) {
          return value === 'foo';
        },
      }
    );
    const e = new ExtendedObject();
    expect(e instanceof ParseObject).toBe(true);
    expect(e instanceof ExtendedObject).toBe(true);
    expect(e.getFoo()).toBe(12);
    expect(ExtendedObject.isFoo(12)).toBe(false);
    expect(ExtendedObject.isFoo('foo')).toBe(true);
  });

  it('can extend a previous extension', () => {
    let FeatureObject = ParseObject.extend('FeatureObject', {
      foo() {
        return 'F';
      },
    });
    let f = new FeatureObject();
    expect(f.foo()).toBe('F');
    FeatureObject = ParseObject.extend('FeatureObject', {
      bar() {
        return 'B';
      },
    });
    f = new FeatureObject();
    expect(f.foo() + f.bar()).toBe('FB');
  });

  it('can specify a custom initializer', () => {
    const InitObject = ParseObject.extend('InitObject', {
      initialize: function () {
        this.set('field', 12);
      },
    });

    const i = new InitObject();
    expect(i.get('field')).toBe(12);
  });

  it('can handle className parameters', () => {
    expect(() => {
      ParseObject.extend();
    }).toThrow(""Parse.Object.extend's first argument should be the className."");

    let CustomObject = ParseObject.extend('Item');
    expect(CustomObject.className).toBe('Item');

    CustomObject = ParseObject.extend({ className: 'Test' });
    expect(CustomObject.className).toBe('Test');
  });

  it('can extend with user rewrite', () => {
    const CustomObject = ParseObject.extend('User');
    expect(CustomObject.className).toBe('_User');
  });

  it('can extend multiple subclasses', () => {
    const CustomObject = ParseObject.extend('Item');
    expect(() => {
      new CustomObject({ 'invalid#name': 'bar' });
    }).toThrow(""Can't create an invalid Parse Object"");

    const CustomUserObject = CustomObject.extend('User');
    const CustomRewrite = CustomUserObject.extend();
    expect(CustomRewrite.className).toBe('_User');
  });
});

describe('ParseObject pin', () => {
  beforeEach(() => {
    ParseObject.enableSingleInstance();
    jest.clearAllMocks();
    mockLocalDatastore.isEnabled = true;
  });

  it('can pin to default', async () => {
    const object = new ParseObject('Item');
    await object.pin();
    expect(mockLocalDatastore._handlePinAllWithName).toHaveBeenCalledTimes(1);
    expect(mockLocalDatastore._handlePinAllWithName).toHaveBeenCalledWith(DEFAULT_PIN, [object]);
  });

  it('can unPin to default', async () => {
    const object = new ParseObject('Item');
    await object.unPin();
    expect(mockLocalDatastore._handleUnPinAllWithName).toHaveBeenCalledTimes(1);
    expect(mockLocalDatastore._handleUnPinAllWithName).toHaveBeenCalledWith(DEFAULT_PIN, [object]);
  });

  it('can pin to specific pin', async () => {
    const object = new ParseObject('Item');
    await object.pinWithName('test_pin');
    expect(mockLocalDatastore._handlePinAllWithName).toHaveBeenCalledTimes(1);
    expect(mockLocalDatastore._handlePinAllWithName).toHaveBeenCalledWith('test_pin', [object]);
  });

  it('can unPin to specific', async () => {
    const object = new ParseObject('Item');
    await object.unPinWithName('test_pin');
    expect(mockLocalDatastore._handleUnPinAllWithName).toHaveBeenCalledTimes(1);
    expect(mockLocalDatastore._handleUnPinAllWithName).toHaveBeenCalledWith('test_pin', [object]);
  });

  it('can check if pinned', async () => {
    const object = new ParseObject('Item');
    object.id = '1234';
    mockLocalDatastore.fromPinWithName
      .mockImplementationOnce(() => {
        return [object._toFullJSON()];
      })
      .mockImplementationOnce(() => []);

    let isPinned = await object.isPinned();
    expect(isPinned).toEqual(true);
    isPinned = await object.isPinned();
    expect(isPinned).toEqual(false);
  });

  it('can fetchFromLocalDatastore', async () => {
    const object = new ParseObject('Item');
    object.id = '123';
    mockLocalDatastore.getKeyForObject.mockImplementationOnce(() => 'Item_123');

    mockLocalDatastore._serializeObject.mockImplementationOnce(() => object._toFullJSON());

    await object.fetchFromLocalDatastore();
    expect(mockLocalDatastore._serializeObject).toHaveBeenCalledTimes(1);
    expect(mockLocalDatastore._serializeObject).toHaveBeenCalledWith('Item_123');
  });

  it('cannot fetchFromLocalDatastore if unsaved', async () => {
    try {
      const object = new ParseObject('Item');
      await object.fetchFromLocalDatastore();
    } catch (e) {
      expect(e.message).toBe('Cannot fetch an unsaved ParseObject');
    }
  });

  it('can pinAll', async () => {
    const obj1 = new ParseObject('Item');
    const obj2 = new ParseObject('Item');
    await ParseObject.pinAll([obj1, obj2]);
    expect(mockLocalDatastore._handlePinAllWithName).toHaveBeenCalledTimes(1);
    expect(mockLocalDatastore._handlePinAllWithName.mock.calls[0]).toEqual([
      DEFAULT_PIN,
      [obj1, obj2],
    ]);
  });

  it('can unPinAll', async () => {
    const obj1 = new ParseObject('Item');
    const obj2 = new ParseObject('Item');
    await ParseObject.unPinAll([obj1, obj2]);
    expect(mockLocalDatastore._handleUnPinAllWithName).toHaveBeenCalledTimes(1);
    expect(mockLocalDatastore._handleUnPinAllWithName.mock.calls[0]).toEqual([
      DEFAULT_PIN,
      [obj1, obj2],
    ]);
  });

  it('can unPinAllObjects', async () => {
    await ParseObject.unPinAllObjects();
    expect(mockLocalDatastore.unPinWithName).toHaveBeenCalledTimes(1);
    expect(mockLocalDatastore.unPinWithName.mock.calls[0]).toEqual([DEFAULT_PIN]);
  });

  it('can unPinAllObjectsWithName', async () => {
    await ParseObject.unPinAllObjectsWithName('123');
    expect(mockLocalDatastore.unPinWithName).toHaveBeenCalledTimes(1);
    expect(mockLocalDatastore.unPinWithName.mock.calls[0]).toEqual([PIN_PREFIX + '123']);
  });

  it('cannot pin when localDatastore disabled', async () => {
    mockLocalDatastore.isEnabled = false;
    const name = 'test_pin';
    const obj = new ParseObject('Item');
    try {
      await obj.pin();
    } catch (error) {
      expect(error).toBe('Parse.enableLocalDatastore() must be called first');
    }
    try {
      await obj.unPin();
    } catch (error) {
      expect(error).toBe('Parse.enableLocalDatastore() must be called first');
    }
    try {
      await obj.isPinned();
    } catch (error) {
      expect(error).toBe('Parse.enableLocalDatastore() must be called first');
    }
    try {
      await obj.pinWithName();
    } catch (error) {
      expect(error).toBe('Parse.enableLocalDatastore() must be called first');
    }
    try {
      await obj.unPinWithName();
    } catch (error) {
      expect(error).toBe('Parse.enableLocalDatastore() must be called first');
    }
    try {
      await obj.fetchFromLocalDatastore();
    } catch (error) {
      expect(error.message).toBe('Parse.enableLocalDatastore() must be called first');
    }
    try {
      await ParseObject.pinAll([obj]);
    } catch (error) {
      expect(error).toBe('Parse.enableLocalDatastore() must be called first');
    }
    try {
      await ParseObject.unPinAll([obj]);
    } catch (error) {
      expect(error).toBe('Parse.enableLocalDatastore() must be called first');
    }
    try {
      await ParseObject.pinAllWithName(name, [obj]);
    } catch (error) {
      expect(error).toBe('Parse.enableLocalDatastore() must be called first');
    }
    try {
      await ParseObject.unPinAllWithName(name, [obj]);
    } catch (error) {
      expect(error).toBe('Parse.enableLocalDatastore() must be called first');
    }
    try {
      await ParseObject.unPinAllObjects();
    } catch (error) {
      expect(error).toBe('Parse.enableLocalDatastore() must be called first');
    }
    try {
      await ParseObject.unPinAllObjectsWithName(name);
    } catch (error) {
      expect(error).toBe('Parse.enableLocalDatastore() must be called first');
    }
  });
  it('gets id for new object when cascadeSave = false and singleInstance = false', done => {
    ParseObject.disableSingleInstance();
    mockFetch([
      {
        status: 200,
        response: {
          objectId: 'P5',
        },
      },
    ])
    const p = new ParseObject('Person');
    p.save(null, { cascadeSave: false }).then(obj => {
      expect(obj).toBe(p);
      expect(obj.id).toBe('P5');
      done();
    });
  });

  it('can allowCustomObjectId', async () => {
    CoreManager.set('ALLOW_CUSTOM_OBJECT_ID', true);
    const o = new ParseObject('Person');
    o.id = '';
    let params = o._getSaveParams();
    expect(params).toEqual({
      method: 'POST',
      body: { objectId: '' },
      path: 'classes/Person',
    });
    await expect(o.save()).rejects.toEqual(
      new ParseError(ParseError.MISSING_OBJECT_ID, 'objectId must not be empty or null')
    );
    await expect(ParseObject.saveAll([o])).rejects.toEqual(
      new ParseError(ParseError.MISSING_OBJECT_ID, 'objectId must not be empty or null')
    );
    o._finishFetch({
      objectId: 'CUSTOM_ID',
      createdAt: { __type: 'Date', iso: new Date().toISOString() },
      updatedAt: { __type: 'Date', iso: new Date().toISOString() },
    });
    params = o._getSaveParams();
    expect(params).toEqual({
      method: 'PUT',
      body: {},
      path: 'classes/Person/CUSTOM_ID',
    });
    CoreManager.set('ALLOW_CUSTOM_OBJECT_ID', false);
  });

  it('can log an object', () => {
    CoreManager.set('NODE_LOGGING', true);
    const o = new ParseObject('Person', { foo: 'bar' });
    const symbol = Symbol.for('nodejs.util.inspect.custom');
    expect(o[symbol]()).toBe(
      `ParseObject: className: Person, id: undefined\nAttributes: {\n  \""foo\"": \""bar\""\n}`
    );
    CoreManager.set('NODE_LOGGING', false);
  });
});",1
"jest.dontMock('../decode');
jest.dontMock('../CoreManager');
jest.dontMock('../ParseFile');
jest.dontMock('../ParseGeoPoint');
jest.dontMock('../ParseObject');
jest.dontMock('../ParsePolygon');

const decode = require('../decode').default;

const ParseFile = require('../ParseFile').default;
const ParseGeoPoint = require('../ParseGeoPoint').default;
const ParseObject = require('../ParseObject').default;
const ParsePolygon = require('../ParsePolygon').default;

describe('decode', () => {
  it('ignores primitives', () => {
    expect(decode(undefined)).toBe(undefined);
    expect(decode(null)).toBe(null);
    expect(decode(true)).toBe(true);
    expect(decode(12)).toBe(12);
    expect(decode('string')).toBe('string');
  });

  it('decodes dates', () => {
    expect(
      decode({
        __type: 'Date',
        iso: '2015-02-01T00:00:00.000Z',
      })
    ).toEqual(new Date(Date.UTC(2015, 1)));
  });

  it('decodes GeoPoints', () => {
    const point = decode({
      __type: 'GeoPoint',
      latitude: 40.5,
      longitude: 50.4,
    });
    expect(point instanceof ParseGeoPoint).toBe(true);
    expect(point.latitude).toBe(40.5);
    expect(point.longitude).toBe(50.4);
  });

  it('decodes Polygons', () => {
    const points = [
      [0, 0],
      [0, 1],
      [1, 1],
      [1, 0],
      [0, 0],
    ];
    const polygon = decode({
      __type: 'Polygon',
      coordinates: points,
    });
    expect(polygon instanceof ParsePolygon).toBe(true);
    expect(polygon.coordinates).toEqual(points);
  });

  it('decodes Files', () => {
    const file = decode({
      __type: 'File',
      name: 'parse.txt',
      url: 'https://files.parsetfss.com/a/parse.txt',
    });
    expect(file instanceof ParseFile).toBe(true);
    expect(file.name()).toBe('parse.txt');
    expect(file.url()).toBe('https://files.parsetfss.com/a/parse.txt');
  });

  it('decodes Relations', () => {
    const obj = decode({
      __type: 'Relation',
      className: 'Delivery',
    });
    expect(obj.constructor.mock.calls[0]).toEqual([null, null]);
    expect(obj.targetClassName).toBe('Delivery');
  });

  it('decodes Pointers', () => {
    const spy = jest.spyOn(ParseObject, 'fromJSON');
    const data = {
      __type: 'Pointer',
      className: 'Item',
      objectId: '1001',
    };
    decode(data);
    expect(spy.mock.calls[0][0]).toEqual(data);
  });

  it('decodes ParseObjects', () => {
    const spy = jest.spyOn(ParseObject, 'fromJSON');
    const data = {
      __type: 'Object',
      className: 'Item',
      objectId: '1001',
    };
    decode(data);
    expect(spy.mock.calls[1][0]).toEqual(data);
  });

  it('iterates over arrays', () => {
    expect(decode([{ __type: 'Date', iso: '2015-02-01T00:00:00.000Z' }, 12, 'string'])).toEqual([
      new Date(Date.UTC(2015, 1)),
      12,
      'string',
    ]);
  });

  it('iterates over objects', () => {
    expect(
      decode({
        empty: null,
        when: { __type: 'Date', iso: '2015-04-01T00:00:00.000Z' },
        count: 15,
      })
    ).toEqual({
      empty: null,
      when: new Date(Date.UTC(2015, 3)),
      count: 15,
    });
  });
});",1
"jest.dontMock('../encode');
jest.dontMock('../ParseACL');
jest.dontMock('../ParseFile');
jest.dontMock('../ParseGeoPoint');
jest.dontMock('../ParseOp');
jest.dontMock('../ParseUser');
jest.dontMock('../CoreManager');

const mockObject = function (className) {
  this.className = className;
};
mockObject.registerSubclass = function () {};
mockObject.prototype = {
  _getServerData() {
    return this._serverData;
  },
  toPointer() {
    return 'POINTER';
  },
  toOfflinePointer() {
    return 'OFFLINE_POINTER';
  },
  _getId() {
    return 'local1234';
  },
  dirty() {},
  toJSON() {
    return this.attributes;
  },
  _toFullJSON(seen, offline) {
    const json = {
      __type: 'Object',
      className: this.className,
    };
    for (const attr in this.attributes) {
      json[attr] = encode(this.attributes[attr], false, false, seen.concat(this), offline);
    }
    return json;
  },
};
jest.setMock('../ParseObject', {
  __esModule: true,
  default: mockObject,
});

const encode = require('../encode').default;
const ParseACL = require('../ParseACL').default;
const ParseFile = require('../ParseFile').default;
const ParseGeoPoint = require('../ParseGeoPoint').default;
const ParseObject = require('../ParseObject').default;
const ParseRelation = require('../ParseRelation').default;
const CoreManager = require('../CoreManager').default;
CoreManager.setParseObject(mockObject);
CoreManager.setParseOp(require('../ParseOp'));
CoreManager.setParseUser(require('../ParseUser').default);

describe('encode', () => {
  it('ignores primitives', () => {
    expect(encode(undefined)).toBe(undefined);
    expect(encode(null)).toBe(null);
    expect(encode(true)).toBe(true);
    expect(encode(12)).toBe(12);
    expect(encode('string')).toBe('string');
  });

  it('encodes dates', () => {
    expect(encode(new Date(Date.UTC(2015, 1)))).toEqual({
      __type: 'Date',
      iso: '2015-02-01T00:00:00.000Z',
    });
    expect(encode.bind(null, new Date(Date.parse(null)))).toThrow(
      'Tried to encode an invalid date.'
    );
  });

  it('encodes regular expressions', () => {
    expect(encode(new RegExp('^hello'))).toEqual('^hello');
    expect(encode(/a[^b]+c/g)).toEqual('a[^b]+c');
  });

  it('encodes GeoPoints', () => {
    const point = new ParseGeoPoint(40.5, 50.4);
    expect(encode(point)).toEqual({
      __type: 'GeoPoint',
      latitude: 40.5,
      longitude: 50.4,
    });
  });

  it('encodes Files', () => {
    const file = new ParseFile('parse.txt');
    expect(encode.bind(null, file)).toThrow('Tried to encode an unsaved file.');
    file._url = 'https://files.parsetfss.com/a/parse.txt';
    expect(encode(file)).toEqual({
      __type: 'File',
      name: 'parse.txt',
      url: 'https://files.parsetfss.com/a/parse.txt',
    });
  });

  it('encodes Relations', () => {
    const rel = new ParseRelation();
    encode(rel);
    expect(rel.toJSON.mock.calls.length).toBe(1);
  });

  it('encodes ACLs', () => {
    const acl = new ParseACL({ aUserId: { read: true, write: false } });
    expect(encode(acl)).toEqual({
      aUserId: {
        read: true,
        write: false,
      },
    });
  });

  it('encodes ParseObjects', () => {
    const obj = new ParseObject('Item');
    obj._serverData = {};
    expect(encode(obj)).toEqual('POINTER');

    obj._serverData = obj.attributes = {
      str: 'string',
      date: new Date(Date.UTC(2015, 1, 1)),
    };
    expect(encode(obj)).toEqual({
      __type: 'Object',
      className: 'Item',
      str: 'string',
      date: {
        __type: 'Date',
        iso: '2015-02-01T00:00:00.000Z',
      },
    });

    obj.attributes.self = obj;
    expect(encode(obj)).toEqual({
      __type: 'Object',
      className: 'Item',
      str: 'string',
      date: {
        __type: 'Date',
        iso: '2015-02-01T00:00:00.000Z',
      },
      self: 'POINTER',
    });
  });

  it('encodes ParseObjects offline', () => {
    const obj = new ParseObject('Item');
    obj._serverData = {};
    expect(encode(obj, false, false, undefined, true)).toEqual('OFFLINE_POINTER');
    obj._serverData = obj.attributes = {
      str: 'string',
      date: new Date(Date.UTC(2015, 1, 1)),
    };
    obj.attributes.self = obj;

    expect(encode(obj, false, false, undefined, true)).toEqual({
      __type: 'Object',
      className: 'Item',
      str: 'string',
      date: {
        __type: 'Date',
        iso: '2015-02-01T00:00:00.000Z',
      },
      self: 'OFFLINE_POINTER',
    });
  });

  it('does not encode ParseObjects when they are disallowed', () => {
    const obj = new ParseObject('Item');
    expect(encode.bind(null, obj, true)).toThrow('Parse Objects not allowed here');
  });

  it('iterates over arrays', () => {
    let arr = [12, new Date(Date.UTC(2015, 1)), 'str'];
    expect(encode(arr)).toEqual([12, { __type: 'Date', iso: '2015-02-01T00:00:00.000Z' }, 'str']);

    arr = [arr];
    expect(encode(arr)).toEqual([[12, { __type: 'Date', iso: '2015-02-01T00:00:00.000Z' }, 'str']]);
  });

  it('iterates over objects', () => {
    const obj = {
      num: 12,
      date: new Date(Date.UTC(2015, 1)),
      str: 'abc',
    };
    expect(encode(obj)).toEqual({
      num: 12,
      date: { __type: 'Date', iso: '2015-02-01T00:00:00.000Z' },
      str: 'abc',
    });
  });
});",1
"import CoreManager from './CoreManager';
import ParseFile from './ParseFile';
import ParseGeoPoint from './ParseGeoPoint';
import ParsePolygon from './ParsePolygon';
import ParseRelation from './ParseRelation';

export default function decode(value: any): any {
  if (value === null || typeof value !== 'object' || value instanceof Date) {
    return value;
  }
  if (Array.isArray(value)) {
    const dup = [];
    value.forEach((v, i) => {
      dup[i] = decode(v);
    });
    return dup;
  }
  if (typeof value.__op === 'string') {
    const { opFromJSON } = CoreManager.getParseOp();
    return opFromJSON(value);
  }
  const ParseObject = CoreManager.getParseObject();
  if (value.__type === 'Pointer' && value.className) {
    return ParseObject.fromJSON(value);
  }
  if (value.__type === 'Object' && value.className) {
    return ParseObject.fromJSON(value);
  }
  if (value.__type === 'Relation') {
    // The parent and key fields will be populated by the parent
    const relation = new ParseRelation(null, null);
    relation.targetClassName = value.className;
    return relation;
  }
  if (value.__type === 'Date') {
    return new Date(value.iso);
  }
  if (value.__type === 'File') {
    return ParseFile.fromJSON(value);
  }
  if (value.__type === 'GeoPoint') {
    return new ParseGeoPoint({
      latitude: value.latitude,
      longitude: value.longitude,
    });
  }
  if (value.__type === 'Polygon') {
    return new ParsePolygon(value.coordinates);
  }
  const copy = {};
  for (const k in value) {
    copy[k] = decode(value[k]);
  }
  return copy;
}",1
"import CoreManager from './CoreManager';
import ParseACL from './ParseACL';
import ParseFile from './ParseFile';
import ParseGeoPoint from './ParseGeoPoint';
import ParsePolygon from './ParsePolygon';
import ParseRelation from './ParseRelation';

function encode(
  value: any,
  disallowObjects: boolean,
  forcePointers: boolean,
  seen: any[],
  offline: boolean
): any {
  const ParseObject = CoreManager.getParseObject();
  if (value instanceof ParseObject) {
    if (disallowObjects) {
      throw new Error('Parse Objects not allowed here');
    }
    const seenEntry = value.id ? value.className + ':' + value.id : value;
    if (
      forcePointers ||
      !seen ||
      seen.indexOf(seenEntry) > -1 ||
      value.dirty() ||
      Object.keys(value._getServerData()).length < 1
    ) {
      if (offline && value._getId().startsWith('local')) {
        return value.toOfflinePointer();
      }
      return value.toPointer();
    }
    seen = seen.concat(seenEntry);
    return value._toFullJSON(seen, offline);
  }
  const { Op } = CoreManager.getParseOp();
  if (
    value instanceof Op ||
    value instanceof ParseACL ||
    value instanceof ParseGeoPoint ||
    value instanceof ParsePolygon ||
    value instanceof ParseRelation
  ) {
    return value.toJSON();
  }
  if (value instanceof ParseFile) {
    if (!value.url()) {
      throw new Error('Tried to encode an unsaved file.');
    }
    return value.toJSON();
  }
  if (Object.prototype.toString.call(value) === '[object Date]') {
    if (isNaN(value)) {
      throw new Error('Tried to encode an invalid date.');
    }
    return { __type: 'Date', iso: (value as Date).toJSON() };
  }
  if (
    Object.prototype.toString.call(value) === '[object RegExp]' &&
    typeof value.source === 'string'
  ) {
    return value.source;
  }

  if (Array.isArray(value)) {
    return value.map(v => {
      return encode(v, disallowObjects, forcePointers, seen, offline);
    });
  }

  if (value && typeof value === 'object') {
    const output = {};
    for (const k in value) {
      output[k] = encode(value[k], disallowObjects, forcePointers, seen, offline);
    }
    return output;
  }

  return value;
}",1
"import DOMPurify from 'dompurify';

export const downloadPdf = async (note) => {
	const [{ default: jsPDF }, { default: html2canvas }] = await Promise.all([
		import('jspdf'),
		import('html2canvas-pro')
	]);

	// Define a fixed virtual screen size
	const virtualWidth = 1024; // Fixed width (adjust as needed)
	const virtualHeight = 1400; // Fixed height (adjust as needed)

	// STEP 1. Get a DOM node to render
	const html = DOMPurify.sanitize(note.data?.content?.html ?? '');
	const isDarkMode = document.documentElement.classList.contains('dark');

	let node;
	if (html instanceof HTMLElement) {
		node = html;
	} else {",0
"<script lang=""ts"">
	import { marked } from 'marked';
	import DOMPurify from 'dompurify';

	marked.use({
		breaks: true,
		gfm: true,
		renderer: {
			list(body, ordered, start) {
				const isTaskList = body.includes('data-checked=');

				if (isTaskList) {
					return `<ul data-type=""taskList"">${body}</ul>`;
				}

				const type = ordered ? 'ol' : 'ul';
				const startatt = ordered && start !== 1 ? ` start=""${start}""` : '';
				return `<${type}${startatt}>${body}</${type}>`;
			},

			listitem(text, task, checked) {
				if (task) {
					const checkedAttr = checked ? 'true' : 'false';
					return `<li data-type=""taskItem"" data-checked=""${checkedAttr}"">${text}</li>`;
				}
				return `<li>${text}</li>`;
			}
		}
	});

	import TurndownService from 'turndown';
	import { gfm } from '@joplin/turndown-plugin-gfm';
	const turndownService = new TurndownService({
		codeBlockStyle: 'fenced',
		headingStyle: 'atx'
	});
	turndownService.escape = (string) => string;

	// Use turndown-plugin-gfm for proper GFM table support
	turndownService.use(gfm);

	// Add custom table header rule before using GFM plugin
	turndownService.addRule('tableHeaders', {
		filter: 'th',
		replacement: function (content, node) {
			return content;
		}
	});

	// Add custom table rule to handle headers properly
	turndownService.addRule('tables', {
		filter: 'table',
		replacement: function (content, node) {
			// Extract rows
			const rows = Array.from(node.querySelectorAll('tr'));
			if (rows.length === 0) return content;

			let markdown = '\n';

			rows.forEach((row, rowIndex) => {
				const cells = Array.from(row.querySelectorAll('th, td'));
				const cellContents = cells.map((cell) => {
					// Get the text content and clean it up
					let cellContent = turndownService.turndown(cell.innerHTML).trim();
					// Remove extra paragraph tags that might be added
					cellContent = cellContent.replace(/^\n+|\n+$/g, '');
					return cellContent;
				});

				// Add the row
				markdown += '| ' + cellContents.join(' | ') + ' |\n';

				// Add separator after first row (which should be headers)
				if (rowIndex === 0) {
					const separator = cells.map(() => '---').join(' | ');
					markdown += '| ' + separator + ' |\n';
				}
			});

			return markdown + '\n';
		}
	});

	turndownService.addRule('taskListItems', {
		filter: (node) =>
			node.nodeName === 'LI' &&
			(node.getAttribute('data-checked') === 'true' ||
				node.getAttribute('data-checked') === 'false'),
		replacement: function (content, node) {
			const checked = node.getAttribute('data-checked') === 'true';
			content = content.replace(/^\s+/, '');
			return `- [${checked ? 'x' : ' '}] ${content}\n`;
		}
	});

	// Convert TipTap mention spans -> <@id>
	turndownService.addRule('mentions', {
		filter: (node) => node.nodeName === 'SPAN' && node.getAttribute('data-type') === 'mention',
		replacement: (_content, node: HTMLElement) => {
			const id = node.getAttribute('data-id') || '';
			// TipTap stores the trigger char in data-mention-suggestion-char (usually ""@"")
			const ch = node.getAttribute('data-mention-suggestion-char') || '@';
			// Emit <@id> style, e.g. <@llama3.2:latest>
			return `<${ch}${id}>`;
		}
	});

	import { onMount, onDestroy, tick, getContext } from 'svelte';
	import { createEventDispatcher } from 'svelte';

	const i18n = getContext('i18n');
	const eventDispatch = createEventDispatcher();

	import { Fragment, DOMParser } from 'prosemirror-model';
	import { EditorState, Plugin, PluginKey, TextSelection, Selection } from 'prosemirror-state';
	import { Decoration, DecorationSet } from 'prosemirror-view';
	import { Editor, Extension, mergeAttributes } from '@tiptap/core';

	import { AIAutocompletion } from './RichTextInput/AutoCompletion.js';

	import StarterKit from '@tiptap/starter-kit';

	// Bubble and Floating menus are currently fixed to v2 due to styling issues in v3
	// TODO: Update to v3 when styling issues are resolved
	import BubbleMenu from '@tiptap/extension-bubble-menu';
	import FloatingMenu from '@tiptap/extension-floating-menu';

	import { TableKit } from '@tiptap/extension-table';
	import { ListKit } from '@tiptap/extension-list';
	import { Placeholder, CharacterCount } from '@tiptap/extensions';

	import Image from './RichTextInput/Image/index.js';
	// import TiptapImage from '@tiptap/extension-image';

	import FileHandler from '@tiptap/extension-file-handler';
	import Typography from '@tiptap/extension-typography';
	import Highlight from '@tiptap/extension-highlight';
	import CodeBlockLowlight from '@tiptap/extension-code-block-lowlight';

	import Mention from '@tiptap/extension-mention';
	import FormattingButtons from './RichTextInput/FormattingButtons.svelte';

	import { PASTED_TEXT_CHARACTER_LIMIT } from '$lib/constants';
	import { createLowlight } from 'lowlight';
	import hljs from 'highlight.js';

	import type { SocketIOCollaborationProvider } from './RichTextInput/Collaboration';

	export let oncompositionstart = (e) => {};
	export let oncompositionend = (e) => {};
	export let onChange = (e) => {};

	// create a lowlight instance with all languages loaded
	const lowlight = createLowlight(
		hljs.listLanguages().reduce(
			(obj, lang) => {
				obj[lang] = () => hljs.getLanguage(lang);
				return obj;
			},
			{} as Record<string, any>
		)
	);

	export let editor: Editor | null = null;

	export let socket = null;
	export let user = null;
	export let files = [];

	export let documentId = '';

	export let className = 'input-prose';
	export let placeholder = $i18n.t('Type here...');
	let _placeholder = placeholder;

	$: if (placeholder !== _placeholder) {
		setPlaceholder();
	}

	const setPlaceholder = () => {
		_placeholder = placeholder;
		if (editor) {
			editor?.view.dispatch(editor.state.tr);
		}
	};

	export let richText = true;
	export let dragHandle = false;
	export let link = false;
	export let image = false;
	export let fileHandler = false;
	export let suggestions = null;

	export let onFileDrop = (currentEditor, files, pos) => {
		files.forEach((file) => {
			const fileReader = new FileReader();

			fileReader.readAsDataURL(file);
			fileReader.onload = () => {
				currentEditor
					.chain()
					.insertContentAt(pos, {
						type: 'image',
						attrs: {
							src: fileReader.result
						}
					})
					.focus()
					.run();
			};
		});
	};

	export let onFilePaste = (currentEditor, files, htmlContent) => {
		files.forEach((file) => {
			if (htmlContent) {
				// if there is htmlContent, stop manual insertion & let other extensions handle insertion via inputRule
				// you could extract the pasted file from this url string and upload it to a server for example
				console.log(htmlContent); // eslint-disable-line no-console
				return false;
			}

			const fileReader = new FileReader();

			fileReader.readAsDataURL(file);
			fileReader.onload = () => {
				currentEditor
					.chain()
					.insertContentAt(currentEditor.state.selection.anchor, {
						type: 'image',
						attrs: {
							src: fileReader.result
						}
					})
					.focus()
					.run();
			};
		});
	};

	export let onSelectionUpdate = (e) => {};

	export let id = '';
	export let value = '';
	export let html = '';

	export let json = false;
	export let raw = false;
	export let editable = true;
	export let collaboration = false;

	export let showFormattingToolbar = true;

	export let preserveBreaks = false;
	export let generateAutoCompletion: Function = async () => null;
	export let autocomplete = false;
	export let messageInput = false;
	export let shiftEnter = false;
	export let largeTextAsFile = false;
	export let insertPromptAsRichText = false;
	export let floatingMenuPlacement = 'bottom-start';

	let content = null;
	let htmlValue = '';
	let jsonValue = '';
	let mdValue = '';

	let provider: SocketIOCollaborationProvider | null = null;

	let floatingMenuElement: Element | null = null;
	let bubbleMenuElement: Element | null = null;
	let element: Element | null = null;

	const options = {
		throwOnError: false
	};

	$: if (editor) {
		editor.setOptions({
			editable: editable
		});
	}

	$: if (value === null && html !== null && editor) {
		editor.commands.setContent(html);
	}

	export const getWordAtDocPos = () => {
		if (!editor) return '';
		const { state } = editor.view;
		const pos = state.selection.from;
		const doc = state.doc;
		const resolvedPos = doc.resolve(pos);
		const textBlock = resolvedPos.parent;
		const paraStart = resolvedPos.start();
		const text = textBlock.textContent;
		const offset = resolvedPos.parentOffset;

		let wordStart = offset,
			wordEnd = offset;
		while (wordStart > 0 && !/\s/.test(text[wordStart - 1])) wordStart--;
		while (wordEnd < text.length && !/\s/.test(text[wordEnd])) wordEnd++;

		const word = text.slice(wordStart, wordEnd);

		return word;
	};

	// Returns {start, end} of the word at pos
	function getWordBoundsAtPos(doc, pos) {
		const resolvedPos = doc.resolve(pos);
		const textBlock = resolvedPos.parent;
		const paraStart = resolvedPos.start();
		const text = textBlock.textContent;

		const offset = resolvedPos.parentOffset;
		let wordStart = offset,
			wordEnd = offset;
		while (wordStart > 0 && !/\s/.test(text[wordStart - 1])) wordStart--;
		while (wordEnd < text.length && !/\s/.test(text[wordEnd])) wordEnd++;
		return {
			start: paraStart + wordStart,
			end: paraStart + wordEnd
		};
	}

	export const replaceCommandWithText = async (text) => {
		const { state, dispatch } = editor.view;
		const { selection } = state;
		const pos = selection.from;

		// Get the plain text of this document
		// const docText = state.doc.textBetween(0, state.doc.content.size, '\n', '\n');

		// Find the word boundaries at cursor
		const { start, end } = getWordBoundsAtPos(state.doc, pos);

		let tr = state.tr;

		if (insertPromptAsRichText) {
			const htmlContent = DOMPurify.sanitize(
				marked
					.parse(text, {
						breaks: true,
						gfm: true
					})
					.trim()
			);

			// Create a temporary div to parse HTML
			const tempDiv = document.createElement('div');
			tempDiv.innerHTML = htmlContent;

			// Convert HTML to ProseMirror nodes",0
"        '[Sandbox Linux] Skipping seccomp filter - allowAllUnixSockets is enabled',
      )
    }

    // ========== NETWORK RESTRICTIONS ==========
    if (needsNetworkRestriction) {
      // Always unshare network namespace to isolate network access
      // This removes all network interfaces, effectively blocking all network
      bwrapArgs.push('--unshare-net')

      // If proxy sockets are provided, bind them into the sandbox to allow
      // filtered network access through the proxy. If not provided, network
      // is completely blocked (empty allowedDomains = block all)
      if (httpSocketPath && socksSocketPath) {
        // Verify socket files still exist before trying to bind them
        if (!fs.existsSync(httpSocketPath)) {
          throw new Error(
            `Linux HTTP bridge socket does not exist: ${httpSocketPath}. ` +
              'The bridge process may have died. Try reinitializing the sandbox.',
          )
        }
        if (!fs.existsSync(socksSocketPath)) {
          throw new Error(
            `Linux SOCKS bridge socket does not exist: ${socksSocketPath}. ` +
              'The bridge process may have died. Try reinitializing the sandbox.',
          )
        }

        // Bind both sockets into the sandbox
        bwrapArgs.push('--bind', httpSocketPath, httpSocketPath)
        bwrapArgs.push('--bind', socksSocketPath, socksSocketPath)

        // Add proxy environment variables
        // HTTP_PROXY points to the socat listener inside the sandbox (port 3128)
        // which forwards to the Unix socket that bridges to the host's proxy server
        const proxyEnv = generateProxyEnvVars(
          3128, // Internal HTTP listener port
          1080, // Internal SOCKS listener port
        )
        bwrapArgs.push(
          ...proxyEnv.flatMap((env: string) => {
            const firstEq = env.indexOf('=')
            const key = env.slice(0, firstEq)
            const value = env.slice(firstEq + 1)
            return ['--setenv', key, value]
          }),
        )

        // Add host proxy port environment variables for debugging/transparency
        // These show which host ports the Unix socket bridges connect to
        if (httpProxyPort !== undefined) {
          bwrapArgs.push(
            '--setenv',
            'CLAUDE_CODE_HOST_HTTP_PROXY_PORT',
            String(httpProxyPort),
          )
        }
        if (socksProxyPort !== undefined) {
          bwrapArgs.push(
            '--setenv',
            'CLAUDE_CODE_HOST_SOCKS_PROXY_PORT',
            String(socksProxyPort),
          )
        }
      }
      // If no sockets provided, network is completely blocked (--unshare-net without proxy)
    }

    // ========== FILESYSTEM RESTRICTIONS ==========
    const fsArgs = await generateFilesystemArgs(
      readConfig,
      writeConfig,",0
"  }
  const readConfig = {
    denyOnly:
      customConfig?.filesystem?.denyRead ?? config?.filesystem.denyRead ?? [],
  }

  // Check if network config is specified - this determines if we need network restrictions
  // Network restriction is needed when:
  // 1. customConfig has network.allowedDomains defined (even if empty array = block all)
  // 2. OR config has network.allowedDomains defined (even if empty array = block all)
  // An empty allowedDomains array means ""no domains allowed"" = block all network access
  const hasNetworkConfig =
    customConfig?.network?.allowedDomains !== undefined ||
    config?.network?.allowedDomains !== undefined

  // Get the actual allowed domains list for proxy filtering
  const allowedDomains =
    customConfig?.network?.allowedDomains ??
    config?.network.allowedDomains ??
    []

  // Network RESTRICTION is needed whenever network config is specified
  // This includes empty allowedDomains which means ""block all network""
  const needsNetworkRestriction = hasNetworkConfig

  // Network PROXY is only needed when there are domains to filter
  // If allowedDomains is empty, we block all network and don't need the proxy
  const needsNetworkProxy = allowedDomains.length > 0

  // Wait for network initialization only if proxy is actually needed
  if (needsNetworkProxy) {
    await waitForNetworkInitialization()
  }

  switch (platform) {
    case 'macos':
      return await wrapCommandWithSandboxMacOS({
        command,
        needsNetworkRestriction,
        // Only pass proxy ports if proxy is running (when there are domains to filter)
        httpProxyPort: needsNetworkProxy ? getProxyPort() : undefined,
        socksProxyPort: needsNetworkProxy ? getSocksProxyPort() : undefined,
        readConfig,
        writeConfig,
        allowUnixSockets: getAllowUnixSockets(),
        allowAllUnixSockets: getAllowAllUnixSockets(),
        allowLocalBinding: getAllowLocalBinding(),
        ignoreViolations: getIgnoreViolations(),
        binShell,
        ripgrepConfig: getRipgrepConfig(),
      })

    case 'linux':
      return wrapCommandWithSandboxLinux({
        command,
        needsNetworkRestriction,
        // Only pass socket paths if proxy is running (when there are domains to filter)
        httpSocketPath: needsNetworkProxy ? getLinuxHttpSocketPath() : undefined,
        socksSocketPath: needsNetworkProxy
          ? getLinuxSocksSocketPath()
          : undefined,
        httpProxyPort: needsNetworkProxy
          ? managerContext?.httpProxyPort
          : undefined,
        socksProxyPort: needsNetworkProxy
          ? managerContext?.socksProxyPort
          : undefined,
        readConfig,
        writeConfig,
        enableWeakerNestedSandbox: getEnableWeakerNestedSandbox(),
        allowAllUnixSockets: getAllowAllUnixSockets(),
        binShell,
        ripgrepConfig: getRipgrepConfig(),",0
"          }
        })
      })
    })
  })
})

/**
 * Integration tests for the empty allowedDomains vulnerability fix
 *
 * These tests verify the ACTUAL network behavior when allowedDomains: [] is specified.
 * With the fix:
 * - Empty allowedDomains = ALL network access blocked (as documented)
 * - Non-empty allowedDomains = Only specified domains allowed
 *
 * The bug caused empty allowedDomains to allow ALL network access instead.
 */
describe('Empty allowedDomains Network Blocking Integration', () => {
  const TEST_DIR = join(process.cwd(), '.sandbox-test-empty-domains')

  beforeAll(async () => {
    if (skipIfNotLinux()) {
      return
    }

    // Create test directory
    if (!existsSync(TEST_DIR)) {
      mkdirSync(TEST_DIR, { recursive: true })
    }
  })

  afterAll(async () => {
    if (skipIfNotLinux()) {
      return
    }

    // Clean up test directory
    if (existsSync(TEST_DIR)) {
      rmSync(TEST_DIR, { recursive: true, force: true })
    }

    await SandboxManager.reset()
  })

  describe('Network blocked with empty allowedDomains', () => {
    beforeAll(async () => {
      if (skipIfNotLinux()) {
        return
      }

      // Initialize with empty allowedDomains - should block ALL network
      await SandboxManager.reset()
      await SandboxManager.initialize({
        network: {
          allowedDomains: [], // Empty = block all network (documented behavior)
          deniedDomains: [],
        },
        filesystem: {
          denyRead: [],
          allowWrite: [TEST_DIR],
          denyWrite: [],
        },
      })
    })

    it('should block all HTTP requests when allowedDomains is empty', async () => {
      if (skipIfNotLinux()) {
        return
      }

      // Try to access example.com - should be blocked
      const command = await SandboxManager.wrapWithSandbox(
        'curl -s --max-time 2 --connect-timeout 2 http://example.com 2>&1 || echo ""network_failed""',
      )

      const result = spawnSync(command, {
        shell: true,
        encoding: 'utf8',
        timeout: 5000,
      })

      // With empty allowedDomains, network should be completely blocked
      // curl should fail with network-related error
      const output = (result.stdout + result.stderr).toLowerCase()

      // Network should fail - either connection error, timeout, or ""network_failed"" echo
      const networkBlocked =
        output.includes('network_failed') ||
        output.includes('couldn\'t connect') ||
        output.includes('connection refused') ||
        output.includes('network is unreachable') ||
        output.includes('name or service not known') ||
        output.includes('timed out') ||
        output.includes('connection timed out') ||
        result.status !== 0

      expect(networkBlocked).toBe(true)

      // Should NOT contain successful HTML response
      expect(output).not.toContain('example domain')
      expect(output).not.toContain('<!doctype')
    })

    it('should block all HTTPS requests when allowedDomains is empty', async () => {
      if (skipIfNotLinux()) {
        return
      }

      const command = await SandboxManager.wrapWithSandbox(
        'curl -s --max-time 2 --connect-timeout 2 https://example.com 2>&1 || echo ""network_failed""',
      )

      const result = spawnSync(command, {
        shell: true,
        encoding: 'utf8',
        timeout: 5000,
      })

      const output = (result.stdout + result.stderr).toLowerCase()

      // Network should fail
      const networkBlocked =
        output.includes('network_failed') ||
        output.includes('couldn\'t connect') ||
        output.includes('connection refused') ||
        output.includes('network is unreachable') ||
        output.includes('name or service not known') ||
        output.includes('timed out') ||
        result.status !== 0

      expect(networkBlocked).toBe(true)
    })

    it('should block DNS lookups when allowedDomains is empty', async () => {
      if (skipIfNotLinux()) {
        return
      }

      // Try DNS lookup - should fail with no network
      const command = await SandboxManager.wrapWithSandbox(
        'host example.com 2>&1 || nslookup example.com 2>&1 || echo ""dns_failed""',
      )

      const result = spawnSync(command, {
        shell: true,
        encoding: 'utf8',
        timeout: 5000,
      })

      const output = (result.stdout + result.stderr).toLowerCase()

      // DNS should fail when network is blocked
      const dnsBlocked =
        output.includes('dns_failed') ||
        output.includes('connection timed out') ||
        output.includes('no servers could be reached') ||
        output.includes('network is unreachable') ||
        output.includes('name or service not known') ||
        output.includes('temporary failure') ||
        result.status !== 0

      expect(dnsBlocked).toBe(true)
    })

    it('should block wget when allowedDomains is empty', async () => {
      if (skipIfNotLinux()) {
        return
      }

      const command = await SandboxManager.wrapWithSandbox(
        'wget -q --timeout=2 -O - http://example.com 2>&1 || echo ""wget_failed""',
      )

      const result = spawnSync(command, {
        shell: true,
        encoding: 'utf8',
        timeout: 5000,
      })

      const output = (result.stdout + result.stderr).toLowerCase()

      // wget should fail
      const wgetBlocked =
        output.includes('wget_failed') ||
        output.includes('failed') ||
        output.includes('network is unreachable') ||
        output.includes('unable to resolve') ||
        result.status !== 0

      expect(wgetBlocked).toBe(true)
    })

    it('should allow local filesystem operations when network is blocked', async () => {
      if (skipIfNotLinux()) {
        return
      }

      // Even with network blocked, filesystem should work
      const testFile = join(TEST_DIR, 'network-blocked-test.txt')
      const testContent = 'test content with network blocked'

      const command = await SandboxManager.wrapWithSandbox(
        `echo ""${testContent}"" > ${testFile} && cat ${testFile}`,
      )

      const result = spawnSync(command, {
        shell: true,
        encoding: 'utf8',
        cwd: TEST_DIR,
        timeout: 5000,
      })

      expect(result.status).toBe(0)
      expect(result.stdout).toContain(testContent)

      // Cleanup
      if (existsSync(testFile)) {
        unlinkSync(testFile)
      }
    })
  })

  describe('Network allowed with specific domains', () => {
    beforeAll(async () => {
      if (skipIfNotLinux()) {
        return
      }

      // Reinitialize with specific domain allowed
      await SandboxManager.reset()
      await SandboxManager.initialize({
        network: {
          allowedDomains: ['example.com'], // Only example.com allowed
          deniedDomains: [],
        },
        filesystem: {
          denyRead: [],
          allowWrite: [TEST_DIR],
          denyWrite: [],
        },
      })
    })

    it('should allow HTTP to explicitly allowed domain', async () => {
      if (skipIfNotLinux()) {
        return
      }

      const command = await SandboxManager.wrapWithSandbox(
        'curl -s --max-time 5 http://example.com 2>&1',
      )

      const result = spawnSync(command, {
        shell: true,
        encoding: 'utf8',
        timeout: 10000,
      })

      // Should succeed and return HTML
      expect(result.status).toBe(0)
      expect(result.stdout).toContain('Example Domain')
    })

    it('should block HTTP to non-allowed domain', async () => {
      if (skipIfNotLinux()) {
        return
      }

      const command = await SandboxManager.wrapWithSandbox(
        'curl -s --max-time 2 http://anthropic.com 2>&1',
      )

      const result = spawnSync(command, {
        shell: true,
        encoding: 'utf8',
        timeout: 5000,
      })

      const output = result.stdout.toLowerCase()
      // Should be blocked by proxy
      expect(output).toContain('blocked by network allowlist')
    })
  })

  describe('Contrast: empty vs undefined network config', () => {
    it('empty allowedDomains should block network', async () => {
      if (skipIfNotLinux()) {
        return
      }

      await SandboxManager.reset()
      await SandboxManager.initialize({
        network: {
          allowedDomains: [], // Explicitly empty
          deniedDomains: [],
        },
        filesystem: {
          denyRead: [],
          allowWrite: [TEST_DIR],
          denyWrite: [],
        },
      })

      const command = await SandboxManager.wrapWithSandbox(
        'curl -s --max-time 2 http://example.com 2>&1 || echo ""blocked""',
      )

      const result = spawnSync(command, {
        shell: true,
        encoding: 'utf8',
        timeout: 5000,
      })

      // Should be blocked
      const output = (result.stdout + result.stderr).toLowerCase()
      const isBlocked =
        output.includes('blocked') ||
        output.includes('couldn\'t connect') ||
        output.includes('network is unreachable') ||
        result.status !== 0

      expect(isBlocked).toBe(true)
      expect(output).not.toContain('example domain')
    })
  })
})",0
"      })

      // Should wrap for filesystem
      expect(result).not.toBe(command)
      expect(result).toContain('sandbox-exec')
    })

    // Tests for the empty allowedDomains fix (CVE fix)
    // Empty allowedDomains should block all network, not allow all
    it('needsNetworkRestriction true without proxy sockets blocks all network on Linux', async () => {
      if (getPlatform() !== 'linux') {
        return
      }

      // Network restriction enabled but no proxy sockets = block all network
      const result = await wrapCommandWithSandboxLinux({
        command,
        needsNetworkRestriction: true,
        httpSocketPath: undefined, // No proxy available
        socksSocketPath: undefined, // No proxy available
        readConfig: { denyOnly: [] },
        writeConfig: { allowOnly: ['/tmp'], denyWithinAllow: [] },
      })

      // Should wrap with --unshare-net to block all network
      expect(result).not.toBe(command)
      expect(result).toContain('bwrap')
      expect(result).toContain('--unshare-net')
      // Should NOT contain proxy-related environment variables since no proxy
      expect(result).not.toContain('HTTP_PROXY')
    })

    it('needsNetworkRestriction true without proxy ports blocks all network on macOS', async () => {
      if (getPlatform() !== 'macos') {
        return
      }

      // Network restriction enabled but no proxy ports = block all network
      const result = await wrapCommandWithSandboxMacOS({
        command,
        needsNetworkRestriction: true,
        httpProxyPort: undefined, // No proxy available
        socksProxyPort: undefined, // No proxy available
        readConfig: { denyOnly: [] },
        writeConfig: { allowOnly: ['/tmp'], denyWithinAllow: [] },
      })

      // Should wrap with sandbox-exec
      expect(result).not.toBe(command)
      expect(result).toContain('sandbox-exec')
      // The sandbox profile should NOT contain ""(allow network*)"" since restrictions are enabled
      // Note: We can't easily check the profile content, but we verify it doesn't skip sandboxing
    })

    it('needsNetworkRestriction true with proxy allows filtered network on Linux', async () => {
      if (getPlatform() !== 'linux') {
        return
      }

      // Create temporary socket files for the test
      const fs = await import('fs')
      const os = await import('os')
      const path = await import('path')
      const tmpDir = os.tmpdir()
      const httpSocket = path.join(tmpDir, `test-http-${Date.now()}.sock`)
      const socksSocket = path.join(tmpDir, `test-socks-${Date.now()}.sock`)

      // Create dummy socket files
      fs.writeFileSync(httpSocket, '')
      fs.writeFileSync(socksSocket, '')

      try {
        const result = await wrapCommandWithSandboxLinux({
          command,
          needsNetworkRestriction: true,
          httpSocketPath: httpSocket,
          socksSocketPath: socksSocket,
          httpProxyPort: 3128,
          socksProxyPort: 1080,
          readConfig: { denyOnly: [] },
          writeConfig: { allowOnly: ['/tmp'], denyWithinAllow: [] },
        })

        // Should wrap with network namespace isolation
        expect(result).not.toBe(command)
        expect(result).toContain('bwrap')
        expect(result).toContain('--unshare-net')
        // Should bind the socket files
        expect(result).toContain(httpSocket)
        expect(result).toContain(socksSocket)
      } finally {
        // Cleanup
        fs.unlinkSync(httpSocket)
        fs.unlinkSync(socksSocket)
      }
    })

    it('needsNetworkRestriction true with proxy allows filtered network on macOS', async () => {
      if (getPlatform() !== 'macos') {
        return
      }

      const result = await wrapCommandWithSandboxMacOS({
        command,
        needsNetworkRestriction: true,
        httpProxyPort: 3128,
        socksProxyPort: 1080,
        readConfig: { denyOnly: [] },
        writeConfig: { allowOnly: ['/tmp'], denyWithinAllow: [] },
      })

      // Should wrap with sandbox-exec and proxy env vars
      expect(result).not.toBe(command)
      expect(result).toContain('sandbox-exec')
      // Should set proxy environment variables
      expect(result).toContain('HTTP_PROXY')
      expect(result).toContain('HTTPS_PROXY')
    })
  })
})

/**
 * Tests for the empty allowedDomains vulnerability fix
 *
 * These tests verify that when allowedDomains is explicitly set to an empty array [],
 * network access is blocked (as documented) rather than allowed (the bug).
 *
 * Documentation states: ""Empty array = no network access""
 * Bug behavior: Empty array = full unrestricted network access
 * Fixed behavior: Empty array = network isolation enabled, all network blocked
 */
describe('empty allowedDomains network blocking (CVE fix)', () => {
  const command = 'curl https://example.com'

  describe('SandboxManager.wrapWithSandbox with empty allowedDomains', () => {
    beforeAll(async () => {
      if (skipIfUnsupportedPlatform()) {
        return
      }
      // Initialize with domains so proxy starts, then test with empty customConfig
      await SandboxManager.initialize({
        network: {
          allowedDomains: ['example.com'],
          deniedDomains: [],
        },
        filesystem: {
          denyRead: [],
          allowWrite: ['/tmp'],
          denyWrite: [],
        },
      })
    })

    afterAll(async () => {
      if (skipIfUnsupportedPlatform()) {
        return
      }
      await SandboxManager.reset()
    })

    it('empty allowedDomains in customConfig triggers network restriction on Linux', async () => {
      if (getPlatform() !== 'linux') {
        return
      }

      const result = await SandboxManager.wrapWithSandbox(command, undefined, {
        network: {
          allowedDomains: [], // Empty = block all network (documented behavior)
          deniedDomains: [],
        },
        filesystem: {
          denyRead: [],
          allowWrite: ['/tmp'],
          denyWrite: [],
        },
      })

      // With the fix, empty allowedDomains should trigger network isolation
      expect(result).not.toBe(command)
      expect(result).toContain('bwrap')
      expect(result).toContain('--unshare-net')
    })

    it('empty allowedDomains in customConfig triggers network restriction on macOS', async () => {
      if (getPlatform() !== 'macos') {
        return
      }

      const result = await SandboxManager.wrapWithSandbox(command, undefined, {
        network: {
          allowedDomains: [], // Empty = block all network (documented behavior)
          deniedDomains: [],
        },
        filesystem: {
          denyRead: [],
          allowWrite: ['/tmp'],
          denyWrite: [],
        },
      })

      // With the fix, empty allowedDomains should trigger sandbox
      expect(result).not.toBe(command)
      expect(result).toContain('sandbox-exec')
    })

    it('non-empty allowedDomains still works correctly', async () => {
      if (skipIfUnsupportedPlatform()) {
        return
      }

      const result = await SandboxManager.wrapWithSandbox(command, undefined, {
        network: {
          allowedDomains: ['example.com'], // Specific domain allowed
          deniedDomains: [],
        },
        filesystem: {
          denyRead: [],
          allowWrite: ['/tmp'],
          denyWrite: [],
        },
      })

      // Should still wrap with sandbox
      expect(result).not.toBe(command)
      // Should have proxy environment variables for filtering
      expect(result).toContain('HTTP_PROXY')
    })

    it('undefined network config in customConfig falls back to main config', async () => {
      if (skipIfUnsupportedPlatform()) {
        return
      }

      const result = await SandboxManager.wrapWithSandbox(command, undefined, {
        // No network config - should fall back to main config which has example.com
        filesystem: {
          denyRead: [],
          allowWrite: ['/tmp'],
          denyWrite: [],
        },
      })

      // Should wrap with sandbox using main config's network settings
      expect(result).not.toBe(command)
      // Main config has example.com, so proxy should be set up
      expect(result).toContain('HTTP_PROXY')
    })
  })
})",0
"                    await transport.handlePostMessage(mockReq, mockHandleRes, { jsonrpc: '2.0', method: 'test' });

                    expect(mockHandleRes.writeHead).toHaveBeenCalledWith(202);
                    expect(mockHandleRes.end).toHaveBeenCalledWith('Accepted');
                });

                it('should accept requests without origin headers', async () => {
                    const mockRes = createMockResponse();
                    const transport = new SSEServerTransport('/messages', mockRes, {
                        allowedOrigins: ['http://localhost:3000', 'https://example.com'],
                        enableDnsRebindingProtection: true
                    });
                    await transport.start();

                    const mockReq = createMockRequest({
                        headers: {
                            'content-type': 'application/json'
                        }
                    });
                    const mockHandleRes = createMockResponse();

                    await transport.handlePostMessage(mockReq, mockHandleRes, { jsonrpc: '2.0', method: 'test' });

                    expect(mockHandleRes.writeHead).toHaveBeenCalledWith(202);
                    expect(mockHandleRes.end).toHaveBeenCalledWith('Accepted');
                });

                it('should reject requests with disallowed origin headers', async () => {
                    const mockRes = createMockResponse();
                    const transport = new SSEServerTransport('/messages', mockRes, {
                        allowedOrigins: ['http://localhost:3000'],
                        enableDnsRebindingProtection: true
                    });",0
"            }
        }

        // Validate Origin header if allowedOrigins is configured
        if (this._options.allowedOrigins && this._options.allowedOrigins.length > 0) {
            const originHeader = req.headers.origin;
            if (originHeader && !this._options.allowedOrigins.includes(originHeader)) {
                return `Invalid Origin header: ${originHeader}`;
            }
        }

        return undefined;
    }",0
"                });

                expect(response.status).toBe(403);
                const body = await response.json();
                expect(body.error.message).toBe('Invalid Origin header: http://evil.com');
            });

            it('should accept requests without origin headers', async () => {
                const result = await createTestServerWithDnsProtection({
                    sessionIdGenerator: undefined,
                    allowedOrigins: ['http://localhost:3000', 'https://example.com'],
                    enableDnsRebindingProtection: true
                });
                server = result.server;
                transport = result.transport;
                baseUrl = result.baseUrl;

                const response = await fetch(baseUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        Accept: 'application/json, text/event-stream'
                    },
                    body: JSON.stringify(TEST_MESSAGES.initialize)
                });

                // Should pass even with no Origin headers because requests that do not come from browsers may not have Origin and DNS rebinding attacks can only be performed via browsers
                expect(response.status).toBe(200);
            });
        });

        describe('enableDnsRebindingProtection option', () => {
            it('should skip all validations when enableDnsRebindingProtection is false', async () => {
                const result = await createTestServerWithDnsProtection({
                    sessionIdGenerator: undefined,",0
"            }
        }

        // Validate Origin header if allowedOrigins is configured
        if (this._allowedOrigins && this._allowedOrigins.length > 0) {
            const originHeader = req.headers.origin;
            if (originHeader && !this._allowedOrigins.includes(originHeader)) {
                return `Invalid Origin header: ${originHeader}`;
            }
        }

        return undefined;
    }",0
" *   mdast node.
 * @returns {Element}
 *   hast node.
 */
export function code(state, node) {
  const value = node.value ? node.value + '\n' : ''
  /** @type {Properties} */
  const properties = {}

  if (node.lang) {
    properties.className = ['language-' + node.lang]
  }

  // Create `<code>`.
  /** @type {Element} */
  let result = {
    type: 'element',",0
"  selector: 'iframe[hostBindingIframeDir]',
  host: {
    '[innerHtml]': 'evil',
    '[attr.style]': 'evil',
    '[src]': 'evil',
    '[sandbox]': 'evil',
    '[attr.attributeName]': 'nonEvil',
  },
})
export class HostBindingIframeDir {
  evil = 'evil';
  nonEvil = 'nonEvil';
}

@Directive({
  selector: 'animateMotion[hostBindingSvgAnimateDir]',
  host: {
    '[attr.attributeName]': 'evil',
  },
})
export class HostBindingSvgAnimateDir {
  evil = 'evil';
}",0
"    $r3$.ɵɵdomProperty(""href"", ctx.evil, $r3$.ɵɵsanitizeResourceUrl);
    $r3$.ɵɵadvance();
    $r3$.ɵɵattribute(""style"", ctx.evil, $r3$.ɵɵsanitizeStyle);
    $r3$.ɵɵadvance();
    $r3$.ɵɵdomProperty(""src"", ctx.evil, $r3$.ɵɵsanitizeUrl);
    $r3$.ɵɵadvance();
    $r3$.ɵɵdomProperty(""sandbox"", ctx.evil, $r3$.ɵɵvalidateAttribute);
    $r3$.ɵɵadvance();
    $r3$.ɵɵdomProperty(""href"", $r3$.ɵɵinterpolate2("""", ctx.evil, """", ctx.evil), $r3$.ɵɵsanitizeUrl);
    $r3$.ɵɵadvance();
    $r3$.ɵɵattribute(""style"", $r3$.ɵɵinterpolate2("""", ctx.evil, """", ctx.evil), $r3$.ɵɵsanitizeStyle);
  }
}",0
"        );
        const diags = env.driveDiagnostics();
        expect(diags.length).toBe(0);
      });
    });

    describe('SVG animation processing', () => {
      it('should generate SVG animation validation instruction', () => {
        env.write(
          'test.ts',
          `
            import {Component} from '@angular/core';

            @Component({
              selector: 'test-cmp',
              template: '<svg><animate [attr.attributeName]=""attr""></animate></svg>',
              standalone: false,
            })
            export class TestCmp {
              attr = 'opacity';
            }
          `,
        );

        env.driveMain();

        const jsContents = env.getContents('test.js');
        expect(jsContents).toContain(
          'i0.ɵɵattribute(""attributeName"", ctx.attr, i0.ɵɵvalidateAttribute);',
        );
      });
    });

    describe('inline resources', () => {
      it('should process inline <style> tags', () => {
        env.write(
          'test.ts',
          `
        import {Component} from '@angular/core';

        @Component({
          selector: 'test',
          template: '<style>h1 {font-size: larger}</style>',
          styles: ['h2 {width: 10px}']
        })
        export class TestCmp {}
      `,
        );

        env.driveMain();
        const jsContents = env.getContents('test.js');
        expect(jsContents).toContain(
          'styles: [""h2[_ngcontent-%COMP%] {width: 10px}"", ""h1[_ngcontent-%COMP%] {font-size: larger}""]',
        );
      });

      it('should process inline <link> tags', () => {
        env.write('style.css', `h1 {font-size: larger}`);
        env.write(
          'test.ts',
          `
        import {Component} from '@angular/core';

        @Component({
          selector: 'test',
          template: '<link rel=""stylesheet"" href=""./style.css"">',
        })
        export class TestCmp {}
      `,
        );

        env.driveMain();
        const jsContents = env.getContents('test.js');
        expect(jsContents).toContain('styles: [""h1[_ngcontent-%COMP%] {font-size: larger}""]');
      });

      it('should share same styles declared in different components in the same file', () => {
        env.write(
          'test.ts',
          `
          import {Component} from '@angular/core';

          @Component({
            selector: 'comp-a',
            template: 'Comp A',
            styles: [
              'span { font-size: larger; }',
              'div { background: url(/some-very-very-long-path.png); }',
              'img { background: url(/a/some-very-very-long-path.png); }'
            ]
          })
          export class CompA {}

          @Component({
            selector: 'comp-b',
            template: 'Comp B',
            styles: [
              'span { font-size: larger; }',
              'div { background: url(/some-very-very-long-path.png); }',
              'img { background: url(/b/some-very-very-long-path.png); }'
            ]
          })
          export class CompB {}
        `,
        );

        env.driveMain();
        const jsContents = env.getContents('test.js');

        // Verify that long styles present in both components are extracted to a
        // separate var.
        expect(jsContents).toContain(
          '_c0 = ""div[_ngcontent-%COMP%] { background: url(/some-very-very-long-path.png); }"";',
        );

        expect(jsContents).toContain(
          'styles: [' +
            // This style is present in both components, but was not extracted into
            // a separate var since it doesn't reach length threshold (50 chars) in
            // `ConstantPool`.
            '""span[_ngcontent-%COMP%] { font-size: larger; }"", ' +
            // Style that is present in both components, but reaches length
            // threshold - extracted to a separate var.
            '_c0, ' +
            // Style that is unique to this component, but that reaches length
            // threshold - remains a string in the `styles` array.
            '""img[_ngcontent-%COMP%] { background: url(/a/some-very-very-long-path.png); }""]',
        );

        expect(jsContents).toContain(
          'styles: [' +
            // This style is present in both components, but was not extracted into
            // a separate var since it doesn't reach length threshold (50 chars) in
            // `ConstantPool`.
            '""span[_ngcontent-%COMP%] { font-size: larger; }"", ' +
            // Style that is present in both components, but reaches length
            // threshold - extracted to a separate var.
            '_c0, ' +
            // Style that is unique to this component, but that reaches length
            // threshold - remains a string in the `styles` array.
            '""img[_ngcontent-%COMP%] { background: url(/b/some-very-very-long-path.png); }""]',
        );
      });

      it('large strings are wrapped in a function for Closure', () => {
        env.tsconfig({
          annotateForClosureCompiler: true,
        });

        env.write(
          'test.ts',
          `
          import {Component} from '@angular/core';

          @Component({
            selector: 'comp-a',
            template: 'Comp A',
            styles: [
              'div { background: url(/a.png); }',
              'div { background: url(/some-very-very-long-path.png); }',
            ]
          })
          export class CompA {}

          @Component({
            selector: 'comp-b',
            template: 'Comp B',
            styles: [
              'div { background: url(/b.png); }',
              'div { background: url(/some-very-very-long-path.png); }',
            ]
          })
          export class CompB {}
        `,
        );

        env.driveMain();
        const jsContents = env.getContents('test.js');

        // Verify that long strings are extracted to a separate var. This should be
        // wrapped in a function to trick Closure not to inline the contents for very
        // large strings. See: https://github.com/angular/angular/pull/38253.
        expect(jsContents).toContain(
          '_c0 = function () {' +
            ' return ""div[_ngcontent-%COMP%] {' +
            ' background: url(/some-very-very-long-path.png);' +
            ' }"";' +
            ' };',
        );

        expect(jsContents).toContain(
          'styles: [' +
            // Check styles for component A.
            '""div[_ngcontent-%COMP%] { background: url(/a.png); }"", ' +
            // Large string should be called from function definition.
            '_c0()]',
        );

        expect(jsContents).toContain(
          'styles: [' +
            // Check styles for component B.
            '""div[_ngcontent-%COMP%] { background: url(/b.png); }"", ' +
            // Large string should be called from function definition.
            '_c0()]',
        );
      });

      it('should process `styles` as a string', () => {
        env.write(
          'test.ts',
          `
        import {Component} from '@angular/core';

        @Component({
          template: '',
          styles: 'h2 {width: 10px}'
        })
        export class TestCmp {}
      `,
        );

        env.driveMain();
        const jsContents = env.getContents('test.js');
        expect(jsContents).toContain('styles: [""h2[_ngcontent-%COMP%] {width: 10px}""]');
      });

      it('should process `styleUrl`', () => {
        env.write('dir/styles.css', 'h2 {width: 10px}');
        env.write(
          'test.ts',
          `
          import {Component} from '@angular/core';

          @Component({
            selector: 'test-cmp',
            styleUrl: 'dir/styles.css',
            template: '',
          })
          export class TestCmp {}
        `,
        );
        env.driveMain();

        const jsContents = env.getContents('test.js');
        expect(jsContents).not.toContain('styleUrl');
        expect(jsContents).toContain('styles: [""h2[_ngcontent-%COMP%] {width: 10px}""]');
      });

      it('should produce a diagnostic if both `styleUrls` and `styleUrl` are defined', () => {
        env.write('dir/styles.css', 'h2 {width: 10px}');
        env.write(
          'test.ts',
          `
          import {Component} from '@angular/core';

          @Component({
            selector: 'test-cmp',
            styleUrl: 'dir/styles.css',
            styleUrls: ['dir/styles.css'],
            template: '',
          })
          export class TestCmp {}
        `,
        );

        const diags = env.driveDiagnostics();
        expect(diags.length).toBe(1);
        expect(diags[0].messageText).toContain(
          '@Component cannot define both `styleUrl` and `styleUrls`',
        );
      });
    });

    describe('empty resources', () => {
      it('should not include empty inline styles in the compiled output', () => {
        env.write(
          'test.ts',
          `
          import {Component} from '@angular/core';

          const someStyle = ' ';

          @Component({
            selector: 'test-cmp',
            styles: ['', someStyle, '      '],
            template: '',
          })
          export class TestCmp {}
      `,
        );
        env.driveMain();

        const jsContents = env.getContents('test.js');
        expect(jsContents).not.toContain('styles');
        expect(jsContents).not.toContain('styleUrls');
      });

      it('should not include empty external styles in the compiled output', () => {
        env.write('dir/a.css', '');
        env.write('dir/b.css', '                ');
        env.write(
          'test.ts',
          `
          import {Component} from '@angular/core';

          @Component({
            selector: 'test-cmp',
            styleUrls: ['./dir/a.css', './dir/b.css'],
            template: '',
          })
          export class TestCmp {}
        `,
        );
        env.driveMain();

        const jsContents = env.getContents('test.js');
        expect(jsContents).not.toContain('styles');
        expect(jsContents).not.toContain('styleUrls');
      });

      it('should not include empty <link> tags that resolve to empty stylesheets', () => {
        env.write('dir/a.css', '');
        env.write('dir/b.css', '                ');
        env.write(
          'test.ts',
          `
        import {Component} from '@angular/core';

        @Component({
          selector: 'test',
          template: \`
            <link rel=""stylesheet"" href=""./dir/a.css"">
            <link rel=""stylesheet"" href=""./dir/b.css"">
          \`,
        })
        export class TestCmp {}
      `,
        );

        env.driveMain();
        const jsContents = env.getContents('test.js').replace(/<link [^>]*>/g, '');
        expect(jsContents).not.toContain('styles');
        expect(jsContents).not.toContain('styleUrls');
      });
    });

    describe('non-exported classes', () => {
      beforeEach(() => env.tsconfig({compileNonExportedClasses: false}));

      it('should not emit directive definitions for non-exported classes if configured', () => {
        env.write(
          'test.ts',
          `
          import {Directive} from '@angular/core';

          @Directive({
            selector: '[test]'
          })
          class TestDirective {}
        `,
        );
        env.driveMain();
        const jsContents = env.getContents('test.js');

        expect(jsContents).not.toContain('defineDirective(');
        expect(jsContents).toContain('Directive({');
      });

      it('should not emit component definitions for non-exported classes if configured', () => {
        env.write(
          'test.ts',
          `
          import {Component} from '@angular/core';

          @Component({
            selector: 'test',
            template: 'hello'
          })
          class TestComponent {}
        `,
        );
        env.driveMain();
        const jsContents = env.getContents('test.js');

        expect(jsContents).not.toContain('defineComponent(');
        expect(jsContents).toContain('Component({');
      });

      it('should not emit module definitions for non-exported classes if configured', () => {
        env.write(
          'test.ts',
          `
          import {NgModule} from '@angular/core';

          @NgModule({
            declarations: []
          })
          class TestModule {}
        `,
        );
        env.driveMain();
        const jsContents = env.getContents('test.js');

        expect(jsContents).not.toContain('defineNgModule(');
        expect(jsContents).toContain('NgModule({');
      });

      it('should still compile a class that is indirectly exported', () => {
        env.write(
          'test.ts',
          `
          import {Component} from '@angular/core';

          @Component({
            selector: 'test-cmp',
            template: 'Test Cmp',
          })
          class TestCmp {}

          export {TestCmp};
        `,
        );
        env.driveMain();
        const jsContents = env.getContents('test.js');

        expect(jsContents).toContain('defineComponent');
      });
    });

    describe('iframe processing', () => {
      it('should generate attribute and property bindings with a validator fn when on <iframe>', () => {
        env.write(
          'test.ts',
          `
                import {Component} from '@angular/core';

                @Component({
                  template: \`
                    <iframe src=""http://angular.io""
                      [sandbox]=""''"" [attr.allow]=""''""
                      [title]=""'Hi!'""
                    ></iframe>
                  \`
                })
                export class SomeComponent {}
              `,
        );

        env.driveMain();
        const jsContents = env.getContents('test.js');

        // Only `sandbox` has an extra validation fn (since it's security-sensitive),
        // the `title` property doesn't have an extra validation fn.
        expect(jsContents).toContain(
          'ɵɵdomProperty(""sandbox"", """", i0.ɵɵvalidateAttribute)(""title"", ""Hi!"")',
        );

        // The `allow` property is also security-sensitive, thus an extra validation fn.
        expect(jsContents).toContain('ɵɵattribute(""allow"", """", i0.ɵɵvalidateAttribute)');
      });

      it(
        'should generate an attribute binding instruction with a validator function ' +
          ""(making sure it's case-insensitive, since this is allowed in Angular templates)"",
        () => {
          env.write(
            'test.ts',
            `
              import {Component} from '@angular/core';

              @Component({
                template: \`
                  <IFRAME
                    src=""http://angular.io""
                    [attr.SANDBOX]=""''""
                  ></IFRAME>
                \`
              })
              export class SomeComponent {}
            `,
          );

          env.driveMain();
          const jsContents = env.getContents('test.js');

          // Make sure that the `sandbox` has an extra validation fn,
          // and the check is case-insensitive (since the `setAttribute` DOM API
          // is case-insensitive as well).
          expect(jsContents).toContain('ɵɵattribute(""SANDBOX"", """", i0.ɵɵvalidateAttribute)');
        },
      );

      it('should *not* generate a validator fn for attribute and property bindings when *not* on <iframe>', () => {
        env.write(
          'test.ts',
          `
                import {Component, Directive} from '@angular/core';

                @Directive({
                  selector: '[sandbox]',
                  inputs: ['sandbox']
                })
                class Dir {}

                @Component({
                  imports: [Dir],
                  template: \`
                    <div [sandbox]=""''"" [title]=""'Hi!'""></div>
                  \`
                })
                export class SomeComponent {}
              `,
        );

        env.driveMain();
        const jsContents = env.getContents('test.js');

        // Note: no extra validation fn, since a security-sensitive attribute is *not* on an
        // <iframe>.
        expect(jsContents).toContain('ɵɵproperty(""sandbox"", """")(""title"", ""Hi!"")');
      });

      it('should generate a validator fn for attribute and property host bindings on a directive', () => {
        env.write(
          'test.ts',
          `
              import {Directive} from '@angular/core';

              @Directive({
                selector: 'iframe[someDir]',
                host: {
                  '[sandbox]': ""''"",
                  '[attr.allow]': ""''"",
                  'src': 'http://angular.io'
                }
              })
              export class SomeDir {}
            `,
        );

        env.driveMain();
        const jsContents = env.getContents('test.js');

        // The `sandbox` is potentially a security-sensitive attribute of an <iframe>.
        // Generate an extra validation function to invoke at runtime, which would
        // check if an underlying host element is an <iframe>.
        expect(jsContents).toContain('ɵɵdomProperty(""sandbox"", """", i0.ɵɵvalidateAttribute)');

        // Similar to the above, but for an attribute binding (host attributes are
        // represented via `ɵɵattribute`).
        expect(jsContents).toContain('ɵɵattribute(""allow"", """", i0.ɵɵvalidateAttribute)');
      });

      it(
        'should generate a validator fn for attribute host bindings on a directive ' +
          '(making sure the check is case-insensitive)',
        () => {
          env.write(
            'test.ts',
            `
              import {Directive} from '@angular/core';

              @Directive({
                host: {
                  '[attr.SANDBOX]': ""''""
                }
              })
              export class SomeDir {}
            `,
          );

          env.driveMain();
          const jsContents = env.getContents('test.js');

          // Make sure that we generate a validation fn for the `sandbox` attribute,
          // even when it was declared as `SANDBOX`.
          expect(jsContents).toContain('ɵɵattribute(""SANDBOX"", """", i0.ɵɵvalidateAttribute)');
        },
      );
    });

    describe('undecorated providers', () => {
      it('should error when an undecorated class, with a non-trivial constructor, is provided directly in a module', () => {",0
"  NONE = 0,
  HTML = 1,
  STYLE = 2,
  SCRIPT = 3,
  URL = 4,
  RESOURCE_URL = 5,
  ATTRIBUTE_NO_BINDING = 6,
}

/**
 * Injection flags for DI.
 */
export const enum InjectFlags {",0
"    moduleName: CORE,
  };

  // sanitization-related functions
  static sanitizeHtml: o.ExternalReference = {name: 'ɵɵsanitizeHtml', moduleName: CORE};
  static sanitizeStyle: o.ExternalReference = {name: 'ɵɵsanitizeStyle', moduleName: CORE};
  static validateAttribute: o.ExternalReference = {
    name: 'ɵɵvalidateAttribute',
    moduleName: CORE,
  };
  static sanitizeResourceUrl: o.ExternalReference = {
    name: 'ɵɵsanitizeResourceUrl',
    moduleName: CORE,
  };
  static sanitizeScript: o.ExternalReference = {name: 'ɵɵsanitizeScript', moduleName: CORE};
  static sanitizeUrl: o.ExternalReference = {name: 'ɵɵsanitizeUrl', moduleName: CORE};
  static sanitizeUrlOrResourceUrl: o.ExternalReference = {
    name: 'ɵɵsanitizeUrlOrResourceUrl',
    moduleName: CORE,
  };
  static trustConstantHtml: o.ExternalReference = {name: 'ɵɵtrustConstantHtml', moduleName: CORE};
  static trustConstantResourceUrl: o.ExternalReference = {
    name: 'ɵɵtrustConstantResourceUrl',
    moduleName: CORE,
  };

  // Decorators
  static inputDecorator: o.ExternalReference = {name: 'Input', moduleName: CORE};
  static outputDecorator: o.ExternalReference = {name: 'Output', moduleName: CORE};
  static viewChildDecorator: o.ExternalReference = {name: 'ViewChild', moduleName: CORE};
  static viewChildrenDecorator: o.ExternalReference = {name: 'ViewChildren', moduleName: CORE};",0
"// =================================================================================================
// =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========
// =================================================================================================
// =================================================================================================
//
//        DO NOT EDIT THIS LIST OF SECURITY SENSITIVE PROPERTIES WITHOUT A SECURITY REVIEW!
//
// =================================================================================================

/** Map from tagName|propertyName to SecurityContext. Properties applying to all tags use '*'. */
let _SECURITY_SCHEMA!: {[k: string]: SecurityContext};

export function SECURITY_SCHEMA(): {[k: string]: SecurityContext} {
  if (!_SECURITY_SCHEMA) {
    _SECURITY_SCHEMA = {};
    // Case is insignificant below, all element and attribute names are lower-cased for lookup.

    registerContext(SecurityContext.HTML, ['iframe|srcdoc', '*|innerHTML', '*|outerHTML']);
    registerContext(SecurityContext.STYLE, ['*|style']);
    // NB: no SCRIPT contexts here, they are never allowed due to the parser stripping them.
    registerContext(SecurityContext.URL, [
      '*|formAction',
      'area|href',
      'area|ping',
      'audio|src',
      'a|href',
      'a|xlink:href',
      'a|ping',
      'blockquote|cite',
      'body|background',
      'del|cite',
      'form|action',
      'img|src',
      'input|src',
      'ins|cite',
      'q|cite',
      'source|src',
      'track|src',
      'video|poster',
      'video|src',

      // MathML namespace
      // https://crsrc.org/c/third_party/blink/renderer/core/sanitizer/sanitizer.cc;l=753-768;drc=b3eb16372dcd3317d65e9e0265015e322494edcd;bpv=1;bpt=1
      'annotation|href',
      'annotation|xlink:href',
      'annotation-xml|href',
      'annotation-xml|xlink:href',
      'maction|href',
      'maction|xlink:href',
      'malignmark|href',
      'malignmark|xlink:href',
      'math|href',
      'math|xlink:href',
      'mroot|href',
      'mroot|xlink:href',
      'msqrt|href',
      'msqrt|xlink:href',
      'merror|href',
      'merror|xlink:href',
      'mfrac|href',
      'mfrac|xlink:href',
      'mglyph|href',
      'mglyph|xlink:href',
      'msub|href',
      'msub|xlink:href',
      'msup|href',
      'msup|xlink:href',
      'msubsup|href',
      'msubsup|xlink:href',
      'mmultiscripts|href',
      'mmultiscripts|xlink:href',
      'mprescripts|href',
      'mprescripts|xlink:href',
      'mi|href',
      'mi|xlink:href',
      'mn|href',
      'mn|xlink:href',
      'mo|href',
      'mo|xlink:href',
      'mpadded|href',
      'mpadded|xlink:href',
      'mphantom|href',
      'mphantom|xlink:href',
      'mrow|href',
      'mrow|xlink:href',
      'ms|href',
      'ms|xlink:href',
      'mspace|href',
      'mspace|xlink:href',
      'mstyle|href',
      'mstyle|xlink:href',
      'mtable|href',
      'mtable|xlink:href',
      'mtd|href',
      'mtd|xlink:href',
      'mtr|href',
      'mtr|xlink:href',
      'mtext|href',
      'mtext|xlink:href',
      'mover|href',
      'mover|xlink:href',
      'munder|href',
      'munder|xlink:href',
      'munderover|href',
      'munderover|xlink:href',
      'semantics|href',
      'semantics|xlink:href',
      'none|href',
      'none|xlink:href',
    ]);

    registerContext(SecurityContext.RESOURCE_URL, [
      'applet|code',
      'applet|codebase',
      'base|href',
      'embed|src',
      'frame|src',
      'head|profile',
      'html|manifest',
      'iframe|src',
      'link|href',
      'media|src',
      'object|codebase',
      'object|data',
      'script|src',
    ]);

    // Keep this in sync with SECURITY_SENSITIVE_ELEMENTS in packages/core/src/sanitization/sanitization.ts
    // Unknown is the internal tag name for unknown elements example used for host-bindings.
    // These are unsafe as `attributeName` can be `href` or `xlink:href`
    // See: http://b/463880509#comment7

    registerContext(SecurityContext.ATTRIBUTE_NO_BINDING, [
      'animate|attributeName',
      'set|attributeName',
      'animateMotion|attributeName',
      'animateTransform|attributeName',

      'unknown|attributeName',

      'iframe|sandbox',
      'iframe|allow',
      'iframe|allowFullscreen',
      'iframe|referrerPolicy',
      'iframe|csp',
      'iframe|fetchPriority',

      'unknown|sandbox',
      'unknown|allow',
      'unknown|allowFullscreen',
      'unknown|referrerPolicy',
      'unknown|csp',
      'unknown|fetchPriority',
    ]);
  }

  return _SECURITY_SCHEMA;
}

function registerContext(ctx: SecurityContext, specs: string[]) {
  for (const spec of specs) _SECURITY_SCHEMA[spec.toLowerCase()] = ctx;
}",0
" * found in the LICENSE file at https://angular.dev/license
 */

import {SecurityContext} from '../../../../core';
import * as o from '../../../../output/output_ast';
import {Identifiers} from '../../../../render3/r3_identifiers';
import * as ir from '../../ir';
import {CompilationJob, CompilationJobKind} from '../compilation';

/**
 * Map of security contexts to their sanitizer function.
 */
const sanitizerFns = new Map<SecurityContext, o.ExternalReference>([
  [SecurityContext.HTML, Identifiers.sanitizeHtml],
  [SecurityContext.RESOURCE_URL, Identifiers.sanitizeResourceUrl],
  [SecurityContext.SCRIPT, Identifiers.sanitizeScript],
  [SecurityContext.STYLE, Identifiers.sanitizeStyle],
  [SecurityContext.URL, Identifiers.sanitizeUrl],
  [SecurityContext.ATTRIBUTE_NO_BINDING, Identifiers.validateAttribute],
]);

/**
 * Map of security contexts to their trusted value function.
 */
const trustedValueFns = new Map<SecurityContext, o.ExternalReference>([
  [SecurityContext.HTML, Identifiers.trustConstantHtml],
  [SecurityContext.RESOURCE_URL, Identifiers.trustConstantResourceUrl],
]);

/**
 * Resolves sanitization functions for ops that need them.
 */
export function resolveSanitizers(job: CompilationJob): void {
  for (const unit of job.units) {
    // For normal element bindings we create trusted values for security sensitive constant
    // attributes. However, for host bindings we skip this step (this matches what
    // TemplateDefinitionBuilder does).
    // TODO: Is the TDB behavior correct here?
    if (job.kind !== CompilationJobKind.Host) {
      for (const op of unit.create) {
        if (op.kind === ir.OpKind.ExtractedAttribute) {
          const trustedValueFn =
            trustedValueFns.get(getOnlySecurityContext(op.securityContext)) ?? null;
          op.trustedValueFn = trustedValueFn !== null ? o.importExpr(trustedValueFn) : null;
        }
      }
    }

    for (const op of unit.update) {
      switch (op.kind) {
        case ir.OpKind.Property:
        case ir.OpKind.Attribute:
        case ir.OpKind.DomProperty:
          let sanitizerFn: o.ExternalReference | null = null;
          if (
            Array.isArray(op.securityContext) &&
            op.securityContext.length === 2 &&
            op.securityContext.includes(SecurityContext.URL) &&
            op.securityContext.includes(SecurityContext.RESOURCE_URL)
          ) {
            // When the host element isn't known, some URL attributes (such as ""src"" and ""href"") may
            // be part of multiple different security contexts. In this case we use special
            // sanitization function and select the actual sanitizer at runtime based on a tag name
            // that is provided while invoking sanitization function.
            sanitizerFn = Identifiers.sanitizeUrlOrResourceUrl;
          } else {
            sanitizerFn = sanitizerFns.get(getOnlySecurityContext(op.securityContext)) ?? null;
          }

          op.sanitizer = sanitizerFn !== null ? o.importExpr(sanitizerFn) : null;

          break;
      }
    }
  }
}

/**
 * Asserts that there is only a single security context and returns it.
 */
function getOnlySecurityContext(
  securityContext: SecurityContext | SecurityContext[],
): SecurityContext {",0
"  ɵɵsanitizeScript,
  ɵɵsanitizeStyle,
  ɵɵsanitizeUrl,
  ɵɵsanitizeUrlOrResourceUrl,
  ɵɵtrustConstantHtml,
  ɵɵtrustConstantResourceUrl,
  ɵɵvalidateAttribute,
} from './sanitization/sanitization';
export {noSideEffects as ɵnoSideEffects} from './util/closure';
export {AfterRenderManager as ɵAfterRenderManager} from './render3/after_render/manager';
export {depsTracker as ɵdepsTracker} from './render3/deps_tracker/deps_tracker';
export {generateStandaloneInDeclarationsError as ɵgenerateStandaloneInDeclarationsError} from './render3/jit/module';
export {getAsyncClassMetadataFn as ɵgetAsyncClassMetadataFn} from './render3/metadata';
export {DeferBlockData as ɵDeferBlockData} from './render3/util/defer';",0
"  UNSAFE_VALUE_IN_RESOURCE_URL = 904,
  UNSAFE_VALUE_IN_SCRIPT = 905,
  MISSING_GENERATED_DEF = 906,
  TYPE_IS_NOT_STANDALONE = 907,
  MISSING_ZONEJS = 908,
  UNEXPECTED_ZONE_STATE = 909,
  UNSAFE_ATTRIBUTE_BINDING = -910,
  /**
   * @deprecated use `UNSAFE_ATTRIBUTE_BINDING` instead.
   */
  // tslint:disable-next-line:no-duplicate-enum-values
  UNSAFE_IFRAME_ATTRS = -910,
  VIEW_ALREADY_DESTROYED = 911,
  COMPONENT_ID_COLLISION = -912,
  IMAGE_PERFORMANCE_WARNING = -913,
  UNEXPECTED_ZONEJS_PRESENT_IN_ZONELESS_MODE = 914,
  MISSING_NG_MODULE_DEFINITION = 915,",0
"  'ɵɵinterpolateV': r3.ɵɵinterpolateV,

  'ɵɵsanitizeHtml': sanitization.ɵɵsanitizeHtml,
  'ɵɵsanitizeStyle': sanitization.ɵɵsanitizeStyle,
  'ɵɵsanitizeResourceUrl': sanitization.ɵɵsanitizeResourceUrl,
  'ɵɵsanitizeScript': sanitization.ɵɵsanitizeScript,
  'ɵɵvalidateAttribute': sanitization.ɵɵvalidateAttribute,
  'ɵɵsanitizeUrl': sanitization.ɵɵsanitizeUrl,
  'ɵɵsanitizeUrlOrResourceUrl': sanitization.ɵɵsanitizeUrlOrResourceUrl,
  'ɵɵtrustConstantHtml': sanitization.ɵɵtrustConstantHtml,
  'ɵɵtrustConstantResourceUrl': sanitization.ɵɵtrustConstantResourceUrl,

  'forwardRef': forwardRef,
  'resolveForwardRef': resolveForwardRef,

  'ɵɵtwoWayProperty': r3.ɵɵtwoWayProperty,
  'ɵɵtwoWayBindingSet': r3.ɵɵtwoWayBindingSet,",0
" * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.dev/license
 */

import {RENDERER} from '../render3/interfaces/view';
import {nativeRemoveNode} from '../render3/dom_node_manipulation';
import {getLView} from '../render3/state';
import {trustedHTMLFromString} from '../util/security/trusted_types';

/**
 * Enforces security by neutralizing an `<iframe>` if a security-sensitive attribute is set.
 *
 * This function is invoked at runtime when a security-sensitive attribute is bound to an `<iframe>`.
 * It clears the `src` and `srcdoc` attributes and removes the `<iframe>` from the DOM to prevent
 * potential security risks.
 *
 * @see [SECURITY_SCHEMA](../../../compiler/src/schema/dom_security_schema.ts) for the full list
 * of such attributes.
 *
 * @codeGenApi
 */
export function enforceIframeSecurity(iframe: HTMLIFrameElement): void {
  const lView = getLView();

  // Unset previously applied `src` and `srcdoc` if we come across a situation when
  // a security-sensitive attribute is set later via an attribute/property binding.
  iframe.src = '';
  iframe.srcdoc = trustedHTMLFromString('') as unknown as string;

  // Also remove the <iframe> from the document.
  nativeRemoveNode(lView[RENDERER], iframe);
}",0
" * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.dev/license
 */

import {XSS_SECURITY_URL} from '../error_details_base_url';
import {RuntimeError, RuntimeErrorCode} from '../errors';
import {getTemplateLocationDetails} from '../render3/instructions/element_validation';
import {getDocument} from '../render3/interfaces/document';
import {TNodeType} from '../render3/interfaces/node';
import {RElement} from '../render3/interfaces/renderer_dom';
import {ENVIRONMENT} from '../render3/interfaces/view';
import {getLView, getSelectedTNode} from '../render3/state';
import {renderStringify} from '../render3/util/stringify_utils';
import {getNativeByTNode} from '../render3/util/view_utils';
import {TrustedHTML, TrustedScript, TrustedScriptURL} from '../util/security/trusted_type_defs';
import {trustedHTMLFromString, trustedScriptURLFromString} from '../util/security/trusted_types';
import {
  trustedHTMLFromStringBypass,
  trustedScriptFromStringBypass,
  trustedScriptURLFromStringBypass,
} from '../util/security/trusted_types_bypass';

import {allowSanitizationBypassAndThrow, BypassType, unwrapSafeValue} from './bypass';
import {_sanitizeHtml as _sanitizeHtml} from './html_sanitizer';
import {enforceIframeSecurity} from './iframe_attrs_validation';
import {Sanitizer} from './sanitizer';
import {SecurityContext} from './security';
import {_sanitizeUrl as _sanitizeUrl} from './url_sanitizer';

/**
 * An `html` sanitizer which converts untrusted `html` **string** into trusted string by removing
 * dangerous content.
 *
 * This method parses the `html` and locates potentially dangerous content (such as urls and
 * javascript) and removes it.
 *
 * It is possible to mark a string as trusted by calling {@link bypassSanitizationTrustHtml}.
 *
 * @param unsafeHtml untrusted `html`, typically from the user.
 * @returns `html` string which is safe to display to user, because all of the dangerous javascript
 * and urls have been removed.
 *
 * @codeGenApi
 */
export function ɵɵsanitizeHtml(unsafeHtml: any): TrustedHTML | string {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return trustedHTMLFromStringBypass(sanitizer.sanitize(SecurityContext.HTML, unsafeHtml) || '');
  }
  if (allowSanitizationBypassAndThrow(unsafeHtml, BypassType.Html)) {
    return trustedHTMLFromStringBypass(unwrapSafeValue(unsafeHtml));
  }
  return _sanitizeHtml(getDocument(), renderStringify(unsafeHtml));
}

/**
 * A `style` sanitizer which converts untrusted `style` **string** into trusted string by removing
 * dangerous content.
 *
 * It is possible to mark a string as trusted by calling {@link bypassSanitizationTrustStyle}.
 *
 * @param unsafeStyle untrusted `style`, typically from the user.
 * @returns `style` string which is safe to bind to the `style` properties.
 *
 * @codeGenApi
 */
export function ɵɵsanitizeStyle(unsafeStyle: any): string {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return sanitizer.sanitize(SecurityContext.STYLE, unsafeStyle) || '';
  }
  if (allowSanitizationBypassAndThrow(unsafeStyle, BypassType.Style)) {
    return unwrapSafeValue(unsafeStyle);
  }
  return renderStringify(unsafeStyle);
}

/**
 * A `url` sanitizer which converts untrusted `url` **string** into trusted string by removing
 * dangerous
 * content.
 *
 * This method parses the `url` and locates potentially dangerous content (such as javascript) and
 * removes it.
 *
 * It is possible to mark a string as trusted by calling {@link bypassSanitizationTrustUrl}.
 *
 * @param unsafeUrl untrusted `url`, typically from the user.
 * @returns `url` string which is safe to bind to the `src` properties such as `<img src>`, because
 * all of the dangerous javascript has been removed.
 *
 * @codeGenApi
 */
export function ɵɵsanitizeUrl(unsafeUrl: any): string {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return sanitizer.sanitize(SecurityContext.URL, unsafeUrl) || '';
  }
  if (allowSanitizationBypassAndThrow(unsafeUrl, BypassType.Url)) {
    return unwrapSafeValue(unsafeUrl);
  }
  return _sanitizeUrl(renderStringify(unsafeUrl));
}

/**
 * A `url` sanitizer which only lets trusted `url`s through.
 *
 * This passes only `url`s marked trusted by calling {@link bypassSanitizationTrustResourceUrl}.
 *
 * @param unsafeResourceUrl untrusted `url`, typically from the user.
 * @returns `url` string which is safe to bind to the `src` properties such as `<img src>`, because
 * only trusted `url`s have been allowed to pass.
 *
 * @codeGenApi
 */
export function ɵɵsanitizeResourceUrl(unsafeResourceUrl: any): TrustedScriptURL | string {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return trustedScriptURLFromStringBypass(
      sanitizer.sanitize(SecurityContext.RESOURCE_URL, unsafeResourceUrl) || '',
    );
  }
  if (allowSanitizationBypassAndThrow(unsafeResourceUrl, BypassType.ResourceUrl)) {
    return trustedScriptURLFromStringBypass(unwrapSafeValue(unsafeResourceUrl));
  }
  throw new RuntimeError(
    RuntimeErrorCode.UNSAFE_VALUE_IN_RESOURCE_URL,
    ngDevMode && `unsafe value used in a resource URL context (see ${XSS_SECURITY_URL})`,
  );
}

/**
 * A `script` sanitizer which only lets trusted javascript through.
 *
 * This passes only `script`s marked trusted by calling {@link
 * bypassSanitizationTrustScript}.
 *
 * @param unsafeScript untrusted `script`, typically from the user.
 * @returns `url` string which is safe to bind to the `<script>` element such as `<img src>`,
 * because only trusted `scripts` have been allowed to pass.
 *
 * @codeGenApi
 */
export function ɵɵsanitizeScript(unsafeScript: any): TrustedScript | string {
  const sanitizer = getSanitizer();
  if (sanitizer) {
    return trustedScriptFromStringBypass(
      sanitizer.sanitize(SecurityContext.SCRIPT, unsafeScript) || '',
    );
  }
  if (allowSanitizationBypassAndThrow(unsafeScript, BypassType.Script)) {
    return trustedScriptFromStringBypass(unwrapSafeValue(unsafeScript));
  }
  throw new RuntimeError(
    RuntimeErrorCode.UNSAFE_VALUE_IN_SCRIPT,
    ngDevMode && 'unsafe value used in a script context',
  );
}

/**
 * A template tag function for promoting the associated constant literal to a
 * TrustedHTML. Interpolation is explicitly not allowed.
 *
 * @param html constant template literal containing trusted HTML.
 * @returns TrustedHTML wrapping `html`.
 *
 * @security This is a security-sensitive function and should only be used to
 * convert constant values of attributes and properties found in
 * application-provided Angular templates to TrustedHTML.
 *
 * @codeGenApi
 */
export function ɵɵtrustConstantHtml(html: TemplateStringsArray): TrustedHTML | string {
  // The following runtime check ensures that the function was called as a
  // template tag (e.g. ɵɵtrustConstantHtml`content`), without any interpolation
  // (e.g. not ɵɵtrustConstantHtml`content ${variable}`). A TemplateStringsArray
  // is an array with a `raw` property that is also an array. The associated
  // template literal has no interpolation if and only if the length of the
  // TemplateStringsArray is 1.
  if (ngDevMode && (!Array.isArray(html) || !Array.isArray(html.raw) || html.length !== 1)) {
    throw new Error(`Unexpected interpolation in trusted HTML constant: ${html.join('?')}`);
  }
  return trustedHTMLFromString(html[0]);
}

/**
 * A template tag function for promoting the associated constant literal to a
 * TrustedScriptURL. Interpolation is explicitly not allowed.
 *
 * @param url constant template literal containing a trusted script URL.
 * @returns TrustedScriptURL wrapping `url`.
 *
 * @security This is a security-sensitive function and should only be used to
 * convert constant values of attributes and properties found in
 * application-provided Angular templates to TrustedScriptURL.
 *
 * @codeGenApi
 */
export function ɵɵtrustConstantResourceUrl(url: TemplateStringsArray): TrustedScriptURL | string {
  // The following runtime check ensures that the function was called as a
  // template tag (e.g. ɵɵtrustConstantResourceUrl`content`), without any
  // interpolation (e.g. not ɵɵtrustConstantResourceUrl`content ${variable}`). A
  // TemplateStringsArray is an array with a `raw` property that is also an
  // array. The associated template literal has no interpolation if and only if
  // the length of the TemplateStringsArray is 1.
  if (ngDevMode && (!Array.isArray(url) || !Array.isArray(url.raw) || url.length !== 1)) {
    throw new Error(`Unexpected interpolation in trusted URL constant: ${url.join('?')}`);
  }
  return trustedScriptURLFromString(url[0]);
}

/**
 * Detects which sanitizer to use for URL property, based on tag name and prop name.
 *
 * The rules are based on the RESOURCE_URL context config from
 * `packages/compiler/src/schema/dom_security_schema.ts`.
 * If tag and prop names don't match Resource URL schema, use URL sanitizer.
 */
export function getUrlSanitizer(tag: string, prop: string) {
  if (
    (prop === 'src' &&
      (tag === 'embed' ||
        tag === 'frame' ||
        tag === 'iframe' ||
        tag === 'media' ||
        tag === 'script')) ||
    (prop === 'href' && (tag === 'base' || tag === 'link'))
  ) {
    return ɵɵsanitizeResourceUrl;
  }
  return ɵɵsanitizeUrl;
}

/**
 * Sanitizes URL, selecting sanitizer function based on tag and property names.
 *
 * This function is used in case we can't define security context at compile time, when only prop
 * name is available. This happens when we generate host bindings for Directives/Components. The
 * host element is unknown at compile time, so we defer calculation of specific sanitizer to
 * runtime.
 *
 * @param unsafeUrl untrusted `url`, typically from the user.
 * @param tag target element tag name.
 * @param prop name of the property that contains the value.
 * @returns `url` string which is safe to bind.
 *
 * @codeGenApi
 */
export function ɵɵsanitizeUrlOrResourceUrl(unsafeUrl: any, tag: string, prop: string): any {
  return getUrlSanitizer(tag, prop)(unsafeUrl);
}

export function validateAgainstEventProperties(name: string) {
  if (name.toLowerCase().startsWith('on')) {
    const errorMessage =
      `Binding to event property '${name}' is disallowed for security reasons, ` +
      `please use (${name.slice(2)})=...` +
      `\nIf '${name}' is a directive input, make sure the directive is imported by the` +
      ` current module.`;
    throw new RuntimeError(RuntimeErrorCode.INVALID_EVENT_BINDING, errorMessage);
  }
}

export function validateAgainstEventAttributes(name: string) {
  if (name.toLowerCase().startsWith('on')) {
    const errorMessage =
      `Binding to event attribute '${name}' is disallowed for security reasons, ` +
      `please use (${name.slice(2)})=...`;
    throw new RuntimeError(RuntimeErrorCode.INVALID_EVENT_BINDING, errorMessage);
  }
}

function getSanitizer(): Sanitizer | null {
  const lView = getLView();
  return lView && lView[ENVIRONMENT].sanitizer;
}

const attributeName: ReadonlySet<string> = new Set(['attributename']);

/**
 * @remarks Keep this in sync with DOM Security Schema.
 * @see [SECURITY_SCHEMA](../../../compiler/src/schema/dom_security_schema.ts)
 */
const SECURITY_SENSITIVE_ELEMENTS: Readonly<Record<string, ReadonlySet<string>>> = {
  'iframe': new Set([
    'sandbox',
    'allow',
    'allowfullscreen',
    'referrerpolicy',
    'csp',
    'fetchpriority',
  ]),
  'animate': attributeName,
  'set': attributeName,
  'animatemotion': attributeName,
  'animatetransform': attributeName,
};

/**
 * Validates that the attribute binding is safe to use.
 *
 * @param value The value of the attribute.
 * @param tagName The name of the tag.
 * @param attributeName The name of the attribute.
 */
export function ɵɵvalidateAttribute(
  value: unknown,
  tagName: string,
  attributeName: string,
): unknown {
  const lowerCaseTagName = tagName.toLowerCase();
  const lowerCaseAttrName = attributeName.toLowerCase();
  if (!SECURITY_SENSITIVE_ELEMENTS[lowerCaseTagName]?.has(lowerCaseAttrName)) {
    return value;
  }

  const tNode = getSelectedTNode()!;
  if (tNode.type !== TNodeType.Element) {
    return value;
  }

  const lView = getLView();
  if (lowerCaseTagName === 'iframe') {
    const element = getNativeByTNode(tNode, lView) as RElement;
    enforceIframeSecurity(element as HTMLIFrameElement);
  }

  const errorMessage =
    ngDevMode &&
    `Angular has detected that the \`${attributeName}\` was applied ` +
      `as a binding to the <${tagName}> element${getTemplateLocationDetails(lView)}. ` +
      `For security reasons, the \`${attributeName}\` can be set on the <${tagName}> element ` +
      `as a static attribute only. \n` +
      `To fix this, switch the \`${attributeName}\` binding to a static attribute ` +
      `in a template or in host bindings section.`;
  throw new RuntimeError(RuntimeErrorCode.UNSAFE_ATTRIBUTE_BINDING, errorMessage);
}",0
"  beforeEach(() => {
    TestBed.configureTestingModule({
      providers: [provideZoneChangeDetection()],
    });
  });
  function getErrorMessageRegexp() {
    const errorMessagePart = 'NG0' + Math.abs(RuntimeErrorCode.UNSAFE_ATTRIBUTE_BINDING).toString();
    return new RegExp(errorMessagePart);
  }

  function ensureNoIframePresent(fixture?: ComponentFixture<unknown>) {
    // Note: a `fixture` may not exist in case an error was thrown at creation time.
    const iframe = fixture?.nativeElement.querySelector('iframe');
    expect(!!iframe).toBeFalse();
  }

  function expectIframeCreationToFail<T>(component: Type<T>): ComponentFixture<T> {
    let fixture: ComponentFixture<T> | undefined;
    expect(() => {
      fixture = TestBed.createComponent(component);
      fixture.detectChanges();
    }).toThrowError(getErrorMessageRegexp());

    ensureNoIframePresent(fixture);
    return fixture!;
  }

  function expectIframeToBeCreated<T>(
    component: Type<T>,
    attrsToCheck: {[key: string]: string},
  ): ComponentFixture<T> {
    let fixture: ComponentFixture<T>;
    expect(() => {
      fixture = TestBed.createComponent(component);
      fixture.detectChanges();
    }).not.toThrow();

    const iframe = fixture!.nativeElement.querySelector('iframe');
    for (const [attrName, attrValue] of Object.entries(attrsToCheck)) {
      expect(iframe[attrName]).toEqual(attrValue);
    }

    return fixture!;
  }

  // *Must* be in sync with the `SECURITY_SENSITIVE_ATTRS` list
  // from the `packages/compiler/src/schema/dom_security_schema.ts`.
  const SECURITY_SENSITIVE_ATTRS = [
    'sandbox',
    'allow',
    'allowFullscreen',
    'referrerPolicy',
    'csp',
    'fetchPriority',
  ];

  const TEST_IFRAME_URL = 'https://angular.io/assets/images/logos/angular/angular.png';

  let oldNgDevMode!: typeof ngDevMode;

  beforeAll(() => {
    oldNgDevMode = ngDevMode;
  });

  afterAll(() => {
    global['ngDevMode'] = oldNgDevMode;
  });

  [true, false].forEach((devModeFlag) => {
    beforeAll(() => {
      global['ngDevMode'] = devModeFlag;

      // TestBed and JIT compilation have some dependencies on the ngDevMode state, so we need to
      // reset TestBed to ensure we get a 'clean' JIT compilation under the new rules.
      TestBed.resetTestingModule();
    });

    describe(`with ngDevMode = ${devModeFlag}`, () => {
      SECURITY_SENSITIVE_ATTRS.forEach((securityAttr: string) => {
        ['src', 'srcdoc'].forEach((srcAttr: string) => {
          it(
            `should work when a security-sensitive attribute is set ` +
              `as a static attribute (checking \`${securityAttr}\`)`,
            () => {
              @Component({
                selector: 'my-comp',
                template: `
                  <iframe
                    ${srcAttr}=""${TEST_IFRAME_URL}""
                    ${securityAttr}="""">
                  </iframe>`,
              })
              class IframeComp {}

              expectIframeToBeCreated(IframeComp, {[srcAttr]: TEST_IFRAME_URL});
            },
          );

          it(
            `should work when a security-sensitive attribute is set ` +
              `as a static attribute (checking \`${securityAttr}\` and ` +
              `making sure it's case-insensitive)`,
            () => {
              @Component({
                selector: 'my-comp',
                template: `
                  <iframe
                    ${srcAttr}=""${TEST_IFRAME_URL}""
                    ${securityAttr.toUpperCase()}="""">
                  </iframe>`,
              })
              class IframeComp {}

              expectIframeToBeCreated(IframeComp, {[srcAttr]: TEST_IFRAME_URL});
            },
          );

          it(
            `should error when a security-sensitive attribute is applied ` +
              `using a property binding (checking \`${securityAttr}\`)`,
            () => {
              @Component({
                selector: 'my-comp',
                template: `<iframe ${srcAttr}=""${TEST_IFRAME_URL}"" [${securityAttr}]=""''""></iframe>`,
              })
              class IframeComp {}

              expectIframeCreationToFail(IframeComp);
            },
          );

          it(
            `should error when a security-sensitive attribute is applied ` +
              `using a property interpolation (checking \`${securityAttr}\`)`,
            () => {
              @Component({
                selector: 'my-comp',
                template: `<iframe ${srcAttr}=""${TEST_IFRAME_URL}"" ${securityAttr}=""{{''}}""></iframe>`,
              })
              class IframeComp {}

              expectIframeCreationToFail(IframeComp);
            },
          );

          it(
            `should error when a security-sensitive attribute is applied ` +
              `using a property binding (checking \`${securityAttr}\`, making ` +
              `sure it's case-insensitive)`,
            () => {
              @Component({
                selector: 'my-comp',
                template: `
                    <iframe
                      ${srcAttr}=""${TEST_IFRAME_URL}""
                      [${securityAttr.toUpperCase()}]=""''""
                    ></iframe>
                  `,
              })
              class IframeComp {}

              expectIframeCreationToFail(IframeComp);
            },
          );

          it(
            `should error when a security-sensitive attribute is applied ` +
              `using a property binding (checking \`${securityAttr}\`)`,
            () => {
              @Component({
                selector: 'my-comp',
                template: `
                    <iframe
                      ${srcAttr}=""${TEST_IFRAME_URL}""
                      [attr.${securityAttr}]=""''""
                    ></iframe>
                  `,
              })
              class IframeComp {}

              expectIframeCreationToFail(IframeComp);
            },
          );

          it(
            `should error when a security-sensitive attribute is applied ` +
              `using a property binding (checking \`${securityAttr}\`, making ` +
              `sure it's case-insensitive)`,
            () => {
              @Component({
                selector: 'my-comp',
                template: `
                    <iframe
                      ${srcAttr}=""${TEST_IFRAME_URL}""
                      [attr.${securityAttr.toUpperCase()}]=""''""
                    ></iframe>
                  `,
              })
              class IframeComp {}

              expectIframeCreationToFail(IframeComp);
            },
          );

          it(`should allow changing \`${srcAttr}\` after initial render`, () => {
            @Component({
              selector: 'my-comp',
              template: `
                    <iframe
                      ${securityAttr}=""allow-forms""
                      [${srcAttr}]=""src"">
                    </iframe>
                  `,
            })
            class IframeComp {
              private sanitizer = inject(DomSanitizer);
              src = this.sanitizeFn(TEST_IFRAME_URL);

              get sanitizeFn() {
                return srcAttr === 'src'
                  ? this.sanitizer.bypassSecurityTrustResourceUrl
                  : this.sanitizer.bypassSecurityTrustHtml;
              }
            }

            const fixture = expectIframeToBeCreated(IframeComp, {[srcAttr]: TEST_IFRAME_URL});
            const component = fixture.componentInstance;

            // Changing `src` or `srcdoc` is allowed.
            const newUrl = 'https://angular.io/about?group=Angular';
            component.src = component.sanitizeFn(newUrl);
            expect(() => fixture.detectChanges()).not.toThrow();
            expect(fixture.nativeElement.querySelector('iframe')[srcAttr]).toEqual(newUrl);
          });
        });
      });

      it('should work when a directive sets a security-sensitive attribute as a static attribute', () => {
        @Directive({
          selector: '[dir]',
          host: {
            'src': TEST_IFRAME_URL,
            'sandbox': '',
          },
        })
        class IframeDir {}
        @Component({
          imports: [IframeDir],
          selector: 'my-comp',
          template: '<iframe dir></iframe>',
        })
        class IframeComp {}

        expectIframeToBeCreated(IframeComp, {src: TEST_IFRAME_URL});
      });

      it('should work when a directive sets a security-sensitive host attribute on a non-iframe element', () => {
        @Directive({
          selector: '[dir]',
          host: {
            'src': TEST_IFRAME_URL,
            'sandbox': '',
          },
        })
        class Dir {}

        @Component({
          imports: [Dir],
          selector: 'my-comp',
          template: '<img dir>',
        })
        class NonIframeComp {}

        const fixture = TestBed.createComponent(NonIframeComp);
        fixture.detectChanges();

        expect(fixture.nativeElement.firstChild.src).toEqual(TEST_IFRAME_URL);
      });

      it(
        'should work when a security-sensitive attribute on an <iframe> ' +
          'which also has a structural directive (*ngIf)',
        () => {
          @Component({
            imports: [NgIf],
            selector: 'my-comp',
            template: `<iframe *ngIf=""visible"" src=""${TEST_IFRAME_URL}"" sandbox=""""></iframe>`,
          })
          class IframeComp {
            visible = true;
          }

          expectIframeToBeCreated(IframeComp, {src: TEST_IFRAME_URL});
        },
      );

      it('should work when a security-sensitive attribute is set between `src` and `srcdoc`', () => {
        @Component({
          selector: 'my-comp',
          template: `<iframe src=""${TEST_IFRAME_URL}"" sandbox srcdoc=""Hi!""></iframe>`,
        })
        class IframeComp {}

        expectIframeToBeCreated(IframeComp, {src: TEST_IFRAME_URL});
      });

      it('should work when a directive sets a security-sensitive attribute before setting `src`', () => {
        @Directive({
          selector: '[dir]',
          host: {
            'sandbox': '',
            'src': TEST_IFRAME_URL,
          },
        })
        class IframeDir {}

        @Component({
          imports: [IframeDir],
          selector: 'my-comp',
          template: '<iframe dir></iframe>',
        })
        class IframeComp {}

        expectIframeToBeCreated(IframeComp, {src: TEST_IFRAME_URL});
      });

      it(
        'should work when a directive sets an `src` and ' +
          'there was a security-sensitive attribute set in a template' +
          '(directive attribute after `sandbox`)',
        () => {
          @Directive({
            selector: '[dir]',
            host: {
              'src': TEST_IFRAME_URL,
            },
          })
          class IframeDir {}

          @Component({
            imports: [IframeDir],
            selector: 'my-comp',
            template: '<iframe sandbox dir></iframe>',
          })
          class IframeComp {}

          expectIframeToBeCreated(IframeComp, {src: TEST_IFRAME_URL});
        },
      );

      it(
        'should error when a directive sets a security-sensitive attribute ' +
          ""as an attribute binding (checking that it's case-insensitive)"",
        () => {
          @Directive({
            selector: '[dir]',
            host: {
              '[attr.SANDBOX]': ""''"",
            },
          })
          class IframeDir {}

          @Component({
            imports: [IframeDir],
            selector: 'my-comp',
            template: `<IFRAME dir src=""${TEST_IFRAME_URL}""></IFRAME>`,
          })
          class IframeComp {}

          expectIframeCreationToFail(IframeComp);
        },
      );

      it(
        'should work when a directive sets an `src` and ' +
          'there was a security-sensitive attribute set in a template' +
          '(directive attribute before `sandbox`)',
        () => {
          @Directive({
            selector: '[dir]',
            host: {
              'src': TEST_IFRAME_URL,
            },
          })
          class IframeDir {}

          @Component({
            imports: [IframeDir],
            selector: 'my-comp',
            template: '<iframe dir sandbox></iframe>',
          })
          class IframeComp {}

          expectIframeToBeCreated(IframeComp, {src: TEST_IFRAME_URL});
        },
      );

      it(
        'should work when a directive sets a security-sensitive attribute and ' +
          'there was an `src` attribute set in a template' +
          '(directive attribute after `src`)',
        () => {
          @Directive({
            selector: '[dir]',
            host: {
              'sandbox': '',
            },
          })
          class IframeDir {}

          @Component({
            imports: [IframeDir],
            selector: 'my-comp',
            template: `<iframe src=""${TEST_IFRAME_URL}"" dir></iframe>`,
          })
          class IframeComp {}

          expectIframeToBeCreated(IframeComp, {src: TEST_IFRAME_URL});
        },
      );

      it('should work when a security-sensitive attribute is set as a static attribute', () => {
        @Component({
          selector: 'my-comp',
          template: `
            <iframe referrerPolicy=""no-referrer"" src=""${TEST_IFRAME_URL}""></iframe>
          `,
        })
        class IframeComp {}

        expectIframeToBeCreated(IframeComp, {
          src: TEST_IFRAME_URL,
          referrerPolicy: 'no-referrer',
        });
      });

      it(
        'should error when a security-sensitive attribute is set ' +
          'as a property binding and an <iframe> is wrapped into another element',
        () => {
          @Component({
            selector: 'my-comp',
            template: `
                <section>
                  <iframe
                    src=""${TEST_IFRAME_URL}""
                    [referrerPolicy]=""'no-referrer'""
                  ></iframe>
                </section>`,
          })
          class IframeComp {}

          expectIframeCreationToFail(IframeComp);
        },
      );

      it(
        'should work when a directive sets a security-sensitive attribute and ' +
          'there was an `src` attribute set in a template' +
          '(directive attribute before `src`)',
        () => {
          @Directive({
            selector: '[dir]',
            host: {
              'sandbox': '',
            },
          })
          class IframeDir {}

          @Component({
            imports: [IframeDir],
            selector: 'my-comp',
            template: `<iframe dir src=""${TEST_IFRAME_URL}""></iframe>`,
          })
          class IframeComp {}

          expectIframeToBeCreated(IframeComp, {src: TEST_IFRAME_URL});
        },
      );

      it(
        'should work when a directive that sets a security-sensitive attribute goes ' +
          'before the directive that sets an `src` attribute value',
        () => {
          @Directive({
            selector: '[set-src]',
            host: {
              'src': TEST_IFRAME_URL,
            },
          })
          class DirThatSetsSrc {}

          @Directive({
            selector: '[set-sandbox]',
            host: {
              'sandbox': '',
            },
          })
          class DirThatSetsSandbox {}

          @Component({
            imports: [DirThatSetsSandbox, DirThatSetsSrc],
            selector: 'my-comp',
            // Important note: even though the `set-sandbox` goes after the `set-src`,
            // the directive matching order (thus the order of host attributes) is
            // based on the imports order, so the `sandbox` gets set first and the `src` second.
            template: '<iframe set-src set-sandbox></iframe>',
          })
          class IframeComp {}

          expectIframeToBeCreated(IframeComp, {src: TEST_IFRAME_URL});
        },
      );

      it(
        'should work when a directive that sets a security-sensitive attribute has ' +
          'a host directive that sets an `src` attribute value',
        () => {
          @Directive({
            selector: '[set-src-dir]',
            host: {
              'src': TEST_IFRAME_URL,
            },
          })
          class DirThatSetsSrc {}

          @Directive({
            selector: '[dir]',
            hostDirectives: [DirThatSetsSrc],
            host: {
              'sandbox': '',
            },
          })
          class DirThatSetsSandbox {}

          @Component({
            imports: [DirThatSetsSandbox],
            selector: 'my-comp',
            template: '<iframe dir></iframe>',
          })
          class IframeComp {}

          expectIframeToBeCreated(IframeComp, {src: TEST_IFRAME_URL});
        },
      );

      it(
        'should work when a directive that sets an `src` has ' +
          'a host directive that sets a security-sensitive attribute value',
        () => {
          @Directive({
            selector: '[set-sandbox-dir]',
            host: {
              'sandbox': '',
            },
          })
          class DirThatSetsSandbox {}

          @Directive({
            selector: '[dir]',
            hostDirectives: [DirThatSetsSandbox],
            host: {
              'src': TEST_IFRAME_URL,
            },
          })
          class DirThatSetsSrc {}

          @Component({
            imports: [DirThatSetsSrc],
            selector: 'my-comp',
            template: '<iframe dir></iframe>',
          })
          class IframeComp {}

          expectIframeToBeCreated(IframeComp, {src: TEST_IFRAME_URL});
        },
      );

      it(
        'should error when creating a view that contains an <iframe> ' +
          'with security-sensitive attributes set via property bindings',
        () => {
          @Component({
            selector: 'my-comp',
            template: `
                <ng-container #container></ng-container>
                <ng-template #template>
                  <iframe src=""${TEST_IFRAME_URL}"" [sandbox]=""''""></iframe>
                </ng-template>
              `,
          })
          class IframeComp {
            @ViewChild('container', {read: ViewContainerRef}) container!: ViewContainerRef;
            @ViewChild('template') template!: TemplateRef<unknown>;

            createEmbeddedView() {
              this.container.createEmbeddedView(this.template);
            }
          }

          const fixture = TestBed.createComponent(IframeComp);
          fixture.detectChanges();

          expect(() => {
            fixture.componentInstance.createEmbeddedView();
            fixture.detectChanges();
          }).toThrowError(getErrorMessageRegexp());

          ensureNoIframePresent(fixture);
        },
      );

      describe('i18n', () => {
        it(
          'should error when a security-sensitive attribute is set as ' +
            'a property binding on an <iframe> inside i18n block',
          () => {
            @Component({
              selector: 'my-comp',
              template: `
                  <section i18n>
                    <iframe src=""${TEST_IFRAME_URL}"" [sandbox]=""''"">
                    </iframe>
                  </section>
                `,
            })
            class IframeComp {}

            expectIframeCreationToFail(IframeComp);
          },
        );

        it(
          'should error when a security-sensitive attribute is set as ' +
            'a property binding on an <iframe> annotated with i18n attribute',
          () => {
            @Component({
              selector: 'my-comp',
              template: `
                  <iframe i18n src=""${TEST_IFRAME_URL}"" [sandbox]=""''"">
                  </iframe>
                `,
            })
            class IframeComp {}

            expectIframeCreationToFail(IframeComp);
          },
        );

        it('should work when a security-sensitive attributes are marked for translation', () => {
          @Component({
            selector: 'my-comp',
            template: `
              <iframe src=""${TEST_IFRAME_URL}"" i18n-sandbox sandbox="""">
              </iframe>
            `,
          })
          class IframeComp {}

          expectIframeToBeCreated(IframeComp, {src: TEST_IFRAME_URL});
        });
      });
    });
  });
});

describe('SVG animation processing', () => {
  it('should error when `attributeName` is bound', () => {
    @Component({
      template: '<svg><animate [attr.attributeName]=""attr""></animate></svg>',
    })
    class TestCmp {
      attr = 'href';
    }

    expect(() => {
      const fixture = TestBed.createComponent(TestCmp);
      fixture.detectChanges();
    }).toThrowError(
      /NG0910: Angular has detected that the `attributeName` was applied as a binding to the <animate>/,
    );
  });

  it(`should error when a directive sets a 'attributeName' as an attribute binding`, () => {
    @Directive({
      selector: '[dir]',
      host: {
        '[attr.attributeName]': ""'href'"",
      },
    })
    class animateAttrDir {}

    @Component({
      imports: [animateAttrDir],
      selector: 'my-comp',
      template: '<svg><animate dir></animate></svg>',
    })
    class TestCmp {}

    expect(() => {
      const fixture = TestBed.createComponent(TestCmp);
      fixture.detectChanges();
    }).toThrowError(
      /NG0910: Angular has detected that the `attributeName` was applied as a binding to the <animate>/,
    );
  });
});",0
"  it('does not apply XSRF protection when request is a HEAD', () => {
    interceptor.intercept(new HttpRequest('HEAD', '/test'), backend).subscribe();
    const req = backend.expectOne('/test');
    expect(req.request.headers.has('X-XSRF-TOKEN')).toEqual(false);
    req.flush({});
  });

  it('does not apply XSRF protection when request is absolute', () => {
    interceptor
      .intercept(new HttpRequest('POST', 'https://example.com/test', {}), backend)
      .subscribe();
    const req = backend.expectOne('https://example.com/test');
    expect(req.request.headers.has('X-XSRF-TOKEN')).toBeFalse();
    req.flush({});
  });

  it('does not apply XSRF protection when request is protocol relative', () => {
    interceptor.intercept(new HttpRequest('POST', '//example.com/test', {}), backend).subscribe();
    const req = backend.expectOne('//example.com/test');
    expect(req.request.headers.has('X-XSRF-TOKEN')).toBeFalse();
    req.flush({});
  });

  it('does not overwrite existing header', () => {
    interceptor
      .intercept(
        new HttpRequest(
          'POST',
          '/test',",0
"    const onError = opts.onError || onErrorDefault
    const retriesCount = opts.retriesCount || 0
    const maxRetriesOn503 = opts.maxRetriesOn503 || 10
    const retryDelay = opts.retryDelay || undefined

    if (!source) {
      const requestUrl = req.url
      const queryIndex = requestUrl.indexOf('?')
      source = queryIndex >= 0 ? requestUrl.substring(0, queryIndex) : requestUrl
    }

    // we leverage caching to avoid parsing the destination URL
    const dest = getUpstream(this.request, base)
    let url
    if (cache) {",0
"  }
  return dest
}

// issue ref: https://github.com/fastify/fast-proxy/issues/42
function buildURL (source, reqBase) {
  if (decodeURIComponent(source).includes('..')) {
    const err = new Error('source/request contain invalid characters')
    err.statusCode = 400
    throw err
  }

  if (Array.isArray(reqBase)) reqBase = reqBase[0]
  let baseOrigin = reqBase ? new URL(reqBase).href : undefined

  // To make sure we don't accidentally override the base path
  if (baseOrigin && source.length > 1 && source[0] === '/' && source[1] === '/') {
    source = '.' + source",0
"      t.assert.throws(() => buildURL(source, base))
    })
  })

  await Promise.all(promises)
})

test('should throw on path traversal attempts', (t) => {
  t.assert.throws(
    () => buildURL('/foo/bar/../', 'http://localhost'),
    new Error('source/request contain invalid characters')
  )

  t.assert.throws(
    () => buildURL('/foo/bar/..', 'http://localhost'),
    new Error('source/request contain invalid characters')
  )

  t.assert.throws(
    () => buildURL('/foo/bar/%2e%2e/', 'http://localhost'),
    new Error('source/request contain invalid characters')
  )

  t.assert.throws(
    () => buildURL('/foo/bar/%2E%2E/', 'http://localhost'),
    new Error('source/request contain invalid characters')
  )

  t.assert.throws(
    () => buildURL('/foo/bar/..%2f', 'http://localhost'),
    new Error('source/request contain invalid characters')
  )

  t.assert.throws(
    () => buildURL('/foo/bar/%2e%2e%2f', 'http://localhost'),
    new Error('source/request contain invalid characters')
  )
})",0
"import * as fs from ""fs"";
import * as path from ""path"";
import { spawnSync } from ""child_process"";
import * as tmp from ""tmp"";
import { Vulnerability } from ""../types/Vulnerability"";
import { CredentialScanner } from ""./scanners/CredentialScanner"";
import { ToolPoisoningScanner } from ""./scanners/ToolPoisoningScanner"";
import { ParameterInjectionScanner } from ""./scanners/ParameterInjectionScanner"";
import { PromptInjectionScanner } from ""./scanners/PromptInjectionScanner"";
import { ToolMutationScanner } from ""./scanners/ToolMutationScanner"";
import { ConversationExfiltrationScanner } from ""./scanners/ConversationExfiltrationScanner"";
import { AnsiInjectionScanner } from ""./scanners/AnsiInjectionScanner"";
import { ProtocolViolationScanner } from ""./scanners/ProtocolViolationScanner"";
import { InputValidationScanner } from ""./scanners/InputValidationScanner"";
import { ServerSpoofingScanner } from ""./scanners/ServerSpoofingScanner"";
import { ToxicFlowScanner } from ""./scanners/ToxicFlowScanner"";
import { PermissionScanner } from ""./scanners/PermissionScanner"";

/**
 * MCPScanner - Comprehensive security scanner for Model Context Protocol (MCP) servers
 *
 * Based on vulnerability research from:
 * - VulnerableMCP Database (https://vulnerablemcp.info)
 * - HiddenLayer Research (Parameter injection attacks)
 * - Invariant Labs Research (Tool poisoning, toxic agent flows)
 * - Trail of Bits Research (Conversation exfiltration, ANSI injection)
 * - PromptHub Analysis (Command injection, SSRF, path traversal statistics)
 *
 * @example
 * ```typescript
 * const scanner = new MCPScanner();
 * const vulnerabilities = await scanner.scanRepository('https://github.com/user/mcp-server');
 * console.log(`Found ${vulnerabilities.length} vulnerabilities`);
 * ```
 */
export class MCPScanner {
  /** Array to store all discovered vulnerabilities */
  private vulnerabilities: Vulnerability[] = [];

  /**
   * Scans a GitHub repository for MCP security vulnerabilities
   *
   * @param githubUrl - The GitHub repository URL to scan
   * @returns Promise resolving to array of discovered vulnerabilities
   *
   * @example
   * ```typescript
   * const scanner = new MCPScanner();
   * const vulns = await scanner.scanRepository('https://github.com/user/mcp-server');
   * console.log(`Found ${vulns.length} vulnerabilities`);
   * ```
   */
  async scanRepository(githubUrl: string): Promise<Vulnerability[]> {
    console.log(`🔍 Scanning repository: ${githubUrl}`);
    console.log(
      ""📊 Based on vulnerablemcp.info, HiddenLayer, Invariant Labs, and Trail of Bits research\n""
    );

    const tempDir = tmp.dirSync({ unsafeCleanup: true });

    try {
      await this.cloneRepo(githubUrl, tempDir.name);

      // Initialize all scanners
      const credentialScanner = new CredentialScanner();
      const toolPoisoningScanner = new ToolPoisoningScanner();
      const parameterInjectionScanner = new ParameterInjectionScanner();
      const promptInjectionScanner = new PromptInjectionScanner();
      const toolMutationScanner = new ToolMutationScanner();
      const conversationExfiltrationScanner =
        new ConversationExfiltrationScanner();
      const ansiInjectionScanner = new AnsiInjectionScanner();
      const protocolViolationScanner = new ProtocolViolationScanner();
      const inputValidationScanner = new InputValidationScanner();
      const serverSpoofingScanner = new ServerSpoofingScanner();
      const toxicFlowScanner = new ToxicFlowScanner();
      const permissionScanner = new PermissionScanner();

      // Core vulnerability scans based on documented research
      const scanResults = await Promise.all([
        credentialScanner.scan(tempDir.name),
        toolPoisoningScanner.scan(tempDir.name),
        parameterInjectionScanner.scan(tempDir.name),
        promptInjectionScanner.scan(tempDir.name),
        toolMutationScanner.scan(tempDir.name),
        conversationExfiltrationScanner.scan(tempDir.name),
        ansiInjectionScanner.scan(tempDir.name),
        protocolViolationScanner.scan(tempDir.name),
        inputValidationScanner.scan(tempDir.name),
        serverSpoofingScanner.scan(tempDir.name),
        toxicFlowScanner.scan(tempDir.name),
        permissionScanner.scan(tempDir.name),
      ]);

      // Flatten all vulnerabilities from all scanners
      this.vulnerabilities = scanResults.flat();

      return this.vulnerabilities;
    } finally {
      tempDir.removeCallback();
    }
  }

  /**
   * Scans a local project directory for MCP security vulnerabilities
   *
   * @param projectPath - The local project directory path to scan
   * @returns Promise resolving to array of discovered vulnerabilities
   *
   * @example
   * ```typescript
   * const scanner = new MCPScanner();
   * const vulns = await scanner.scanLocalProject('./my-mcp-server');
   * console.log(`Found ${vulns.length} vulnerabilities`);
   * ```
   */
  async scanLocalProject(projectPath: string): Promise<Vulnerability[]> {
    console.log(`🔍 Scanning local project: ${projectPath}`);
    console.log(
      ""📊 Based on vulnerablemcp.info, HiddenLayer, Invariant Labs, and Trail of Bits research\n""
    );

    // Validate that the project path exists
    if (!fs.existsSync(projectPath)) {
      throw new Error(`Project path does not exist: ${projectPath}`);
    }

    const stat = fs.statSync(projectPath);
    if (!stat.isDirectory()) {
      throw new Error(`Project path is not a directory: ${projectPath}`);
    }

    // Initialize all scanners
    const credentialScanner = new CredentialScanner();
    const toolPoisoningScanner = new ToolPoisoningScanner();
    const parameterInjectionScanner = new ParameterInjectionScanner();
    const promptInjectionScanner = new PromptInjectionScanner();
    const toolMutationScanner = new ToolMutationScanner();
    const conversationExfiltrationScanner =
      new ConversationExfiltrationScanner();
    const ansiInjectionScanner = new AnsiInjectionScanner();
    const protocolViolationScanner = new ProtocolViolationScanner();
    const inputValidationScanner = new InputValidationScanner();
    const serverSpoofingScanner = new ServerSpoofingScanner();
    const toxicFlowScanner = new ToxicFlowScanner();
    const permissionScanner = new PermissionScanner();

    // Core vulnerability scans based on documented research
    const scanResults = await Promise.all([
      credentialScanner.scan(projectPath),
      toolPoisoningScanner.scan(projectPath),
      parameterInjectionScanner.scan(projectPath),
      promptInjectionScanner.scan(projectPath),
      toolMutationScanner.scan(projectPath),
      conversationExfiltrationScanner.scan(projectPath),
      ansiInjectionScanner.scan(projectPath),
      protocolViolationScanner.scan(projectPath),
      inputValidationScanner.scan(projectPath),
      serverSpoofingScanner.scan(projectPath),
      toxicFlowScanner.scan(projectPath),
      permissionScanner.scan(projectPath),
    ]);

    // Flatten all vulnerabilities from all scanners
    this.vulnerabilities = scanResults.flat();

    return this.vulnerabilities;
  }

  /**
   * Clones a Git repository to a temporary directory
   *
   * @param url - The repository URL to clone
   * @param targetDir - The target directory for cloning
   * @throws {Error} When git clone fails
   * @private
   */
  private async cloneRepo(url: string, targetDir: string) {
    try {
      console.log(""📥 Cloning repository..."");
      const result = spawnSync(""git"", [""clone"", ""--depth"", ""1"", url, targetDir], {
        stdio: ""pipe"",
        encoding: ""utf-8"",
      });

      if (result.error || result.status !== 0) {
        throw new Error(`Git clone failed: ${result.stderr || result.error?.message}`);
      }
    } catch (error) {
      throw new Error(`Failed to clone repository: ${error}`);
    }
  }

  /**",0
"/**
 * Compare two buffers in constant time.
 */
export function constantTimeEqual(
	a: ArrayBuffer | Uint8Array | string,
	b: ArrayBuffer | Uint8Array | string,
): boolean {
	if (typeof a === ""string"") {
		a = new TextEncoder().encode(a);
	}
	if (typeof b === ""string"") {
		b = new TextEncoder().encode(b);
	}
	const aBuffer = new Uint8Array(a);
	const bBuffer = new Uint8Array(b);
	let c = aBuffer.length ^ bBuffer.length;
	const length = Math.max(aBuffer.length, bBuffer.length);
	for (let i = 0; i < length; i++) {
		c |=",0
"			testUser2.email,
			otp,
			""email-verification"",
		);
	});

	it(""should reset password"", async () => {
		await client.emailOtp.sendVerificationOtp({
			email: testUser.email,
			type: ""forget-password"",
		});
		const res = await client.emailOtp.resetPassword({
			email: testUser.email,
			otp,
			password: ""changed-password"",
		});

		const { data, error } = await client.signIn.email({
			email: testUser.email,
			password: ""changed-password"",
		});
		expect(data?.user).toBeDefined();
	});
",0
"import { BASE_ERROR_CODES } from ""@better-auth/core/error"";
import { defineErrorCodes } from ""@better-auth/core/utils"";
import * as z from ""zod"";
import { APIError, getSessionFromCtx } from ""../../api"";
import { setCookieCache, setSessionCookie } from ""../../cookies"";
import {
	constantTimeEqual,
	generateRandomString,
	symmetricDecrypt,
	symmetricEncrypt,
} from ""../../crypto"";
import { getDate } from ""../../utils/date"";
import { getEndpointResponse } from ""../../utils/plugin-helper"";
import { defaultKeyHasher, splitAtLastColon } from ""./utils"";

export interface EmailOTPOptions {
	/**
	 * Function to send email verification.
	 *
	 * It is recommended to not await the email sending to avoid timing attacks.
	 * On serverless platforms, use `waitUntil` or similar to ensure the email is sent.
	 */
	sendVerificationOTP: (
		data: {
			email: string;
			otp: string;
			type: ""sign-in"" | ""email-verification"" | ""forget-password"";
		},
		ctx?: GenericEndpointContext | undefined,
	) => Promise<void>;
	/**
	 * Length of the OTP
	 *
	 * @default 6
	 */
	otpLength?: number | undefined;
	/**
	 * Expiry time of the OTP in seconds
	 *
	 * @default 300 (5 minutes)
	 */
	expiresIn?: number | undefined;
	/**
	 * Custom function to generate otp
	 */
	generateOTP?: (
		data: {
			email: string;
			type: ""sign-in"" | ""email-verification"" | ""forget-password"";
		},
		ctx?: GenericEndpointContext,
	) => string | undefined;
	/**
	 * Send email verification on sign-up
	 *
	 * @Default false
	 */
	sendVerificationOnSignUp?: boolean | undefined;
	/**
	 * A boolean value that determines whether to prevent
	 * automatic sign-up when the user is not registered.
	 *
	 * @Default false
	 */
	disableSignUp?: boolean | undefined;
	/**
	 * Allowed attempts for the OTP code
	 * @default 3
	 */
	allowedAttempts?: number | undefined;
	/**
	 * Store the OTP in your database in a secure way
	 * Note: This will not affect the OTP sent to the user, it will only affect the OTP stored in your database
	 *
	 * @default ""plain""
	 */
	storeOTP?:
		| (
				| ""hashed""
				| ""plain""
				| ""encrypted""
				| { hash: (otp: string) => Promise<string> }
				| {
						encrypt: (otp: string) => Promise<string>;
						decrypt: (otp: string) => Promise<string>;
				  }
		  )
		| undefined;
	/**
	 * Override the default email verification to use email otp instead
	 *
	 * @default false
	 */
	overrideDefaultEmailVerification?: boolean | undefined;
}

const types = [""email-verification"", ""sign-in"", ""forget-password""] as const;

const defaultOTPGenerator = (options: EmailOTPOptions) =>
	generateRandomString(options.otpLength ?? 6, ""0-9"");

const ERROR_CODES = defineErrorCodes({
	OTP_EXPIRED: ""OTP expired"",
	INVALID_OTP: ""Invalid OTP"",
	TOO_MANY_ATTEMPTS: ""Too many attempts"",
});

export const emailOTP = (options: EmailOTPOptions) => {
	const opts = {
		expiresIn: 5 * 60,
		generateOTP: () => defaultOTPGenerator(options),
		storeOTP: ""plain"",
		...options,
	} satisfies EmailOTPOptions;

	async function storeOTP(ctx: GenericEndpointContext, otp: string) {
		if (opts.storeOTP === ""encrypted"") {
			return await symmetricEncrypt({
				key: ctx.context.secret,
				data: otp,
			});
		}
		if (opts.storeOTP === ""hashed"") {
			return await defaultKeyHasher(otp);
		}
		if (typeof opts.storeOTP === ""object"" && ""hash"" in opts.storeOTP) {
			return await opts.storeOTP.hash(otp);
		}
		if (typeof opts.storeOTP === ""object"" && ""encrypt"" in opts.storeOTP) {
			return await opts.storeOTP.encrypt(otp);
		}

		return otp;
	}

	async function verifyStoredOTP(
		ctx: GenericEndpointContext,
		storedOtp: string,
		otp: string,
	): Promise<boolean> {
		if (opts.storeOTP === ""encrypted"") {
			const decryptedOtp = await symmetricDecrypt({
				key: ctx.context.secret,
				data: storedOtp,
			});
			return constantTimeEqual(decryptedOtp, otp);
		}
		if (opts.storeOTP === ""hashed"") {
			const hashedOtp = await defaultKeyHasher(otp);
			return constantTimeEqual(hashedOtp, storedOtp);
		}
		if (typeof opts.storeOTP === ""object"" && ""hash"" in opts.storeOTP) {
			const hashedOtp = await opts.storeOTP.hash(otp);
			return constantTimeEqual(hashedOtp, storedOtp);
		}
		if (typeof opts.storeOTP === ""object"" && ""decrypt"" in opts.storeOTP) {
			const decryptedOtp = await opts.storeOTP.decrypt(storedOtp);
			return constantTimeEqual(decryptedOtp, otp);
		}

		return constantTimeEqual(otp, storedOtp);
	}
	const endpoints = {
		/**
		 * ### Endpoint
		 *
		 * POST `/email-otp/send-verification-otp`
		 *
		 * ### API Methods
		 *
		 * **server:**
		 * `auth.api.sendVerificationOTP`
		 *
		 * **client:**
		 * `authClient.emailOtp.sendVerificationOtp`
		 *
		 * @see [Read our docs to learn more.](https://better-auth.com/docs/plugins/email-otp#api-method-email-otp-send-verification-otp)
		 */
		sendVerificationOTP: createAuthEndpoint(
			""/email-otp/send-verification-otp"",
			{
				method: ""POST"",
				body: z.object({
					email: z.string({}).meta({
						description: ""Email address to send the OTP"",
					}),
					type: z.enum(types).meta({
						description: ""Type of the OTP"",
					}),
				}),
				metadata: {
					openapi: {
						operationId: ""sendEmailVerificationOTP"",
						description: ""Send a verification OTP to an email"",
						responses: {
							200: {
								description: ""Success"",
								content: {
									""application/json"": {
										schema: {
											type: ""object"",
											properties: {
												success: {
													type: ""boolean"",
												},
											},
										},
									},
								},
							},
						},
					},
				},
			},
			async (ctx) => {
				if (!options?.sendVerificationOTP) {
					ctx.context.logger.error(
						""send email verification is not implemented"",
					);
					throw new APIError(""BAD_REQUEST"", {
						message: ""send email verification is not implemented"",
					});
				}
				const email = ctx.body.email.toLowerCase();
				const isValidEmail = z.email().safeParse(email);
				if (!isValidEmail.success) {
					throw ctx.error(""BAD_REQUEST"", {
						message: BASE_ERROR_CODES.INVALID_EMAIL,
					});
				}
				let otp =
					opts.generateOTP({ email, type: ctx.body.type }, ctx) ||
					defaultOTPGenerator(opts);

				let storedOTP = await storeOTP(ctx, otp);

				await ctx.context.internalAdapter
					.createVerificationValue({
						value: `${storedOTP}:0`,
						identifier: `${ctx.body.type}-otp-${email}`,
						expiresAt: getDate(opts.expiresIn, ""sec""),
					})
					.catch(async (error) => {
						// might be duplicate key error
						await ctx.context.internalAdapter.deleteVerificationByIdentifier(
							`${ctx.body.type}-otp-${email}`,
						);
						//try again
						await ctx.context.internalAdapter.createVerificationValue({
							value: `${storedOTP}:0`,
							identifier: `${ctx.body.type}-otp-${email}`,
							expiresAt: getDate(opts.expiresIn, ""sec""),
						});
					});
				const user = await ctx.context.internalAdapter.findUserByEmail(email);
				if (!user) {
					if (ctx.body.type === ""sign-in"" && !opts.disableSignUp) {
						// allow
					} else {
						await ctx.context.internalAdapter.deleteVerificationByIdentifier(
							`${ctx.body.type}-otp-${email}`,
						);
						return ctx.json({
							success: true,
						});
					}
				}

				await options.sendVerificationOTP(
					{
						email,
						otp,
						type: ctx.body.type,
					},
					ctx,
				);
				return ctx.json({
					success: true,
				});
			},
		),
	};

	return {
		id: ""email-otp"",
		init(ctx) {
			if (!opts.overrideDefaultEmailVerification) {
				return;
			}
			return {
				options: {
					emailVerification: {
						async sendVerificationEmail(data, request) {
							await endpoints.sendVerificationOTP({
								//@ts-expect-error - we need to pass the context
								context: ctx,
								request: request,
								body: {
									email: data.user.email,
									type: ""email-verification"",
								},
								ctx,
							});
						},
					},
				},
			};
		},
		endpoints: {
			...endpoints,
			createVerificationOTP: createAuthEndpoint(
				""/email-otp/create-verification-otp"",
				{
					method: ""POST"",
					body: z.object({
						email: z.string({}).meta({
							description: ""Email address to send the OTP"",
						}),
						type: z.enum(types).meta({
							required: true,
							description: ""Type of the OTP"",
						}),
					}),
					metadata: {
						SERVER_ONLY: true,
						openapi: {
							operationId: ""createEmailVerificationOTP"",
							description: ""Create a verification OTP for an email"",
							responses: {
								200: {
									description: ""Success"",
									content: {
										""application/json"": {
											schema: {
												type: ""string"",
											},
										},
									},
								},
							},
						},
					},
				},
				async (ctx) => {
					const email = ctx.body.email;
					const otp =
						opts.generateOTP({ email, type: ctx.body.type }, ctx) ||
						defaultOTPGenerator(opts);
					let storedOTP = await storeOTP(ctx, otp);
					await ctx.context.internalAdapter.createVerificationValue({
						value: `${storedOTP}:0`,
						identifier: `${ctx.body.type}-otp-${email}`,
						expiresAt: getDate(opts.expiresIn, ""sec""),
					});
					return otp;
				},
			),
			/**
			 * ### Endpoint
			 *
			 * GET `/email-otp/get-verification-otp`
			 *
			 * ### API Methods
			 *
			 * **server:**
			 * `auth.api.getVerificationOTP`
			 *
			 * @see [Read our docs to learn more.](https://better-auth.com/docs/plugins/email-otp#api-method-email-otp-get-verification-otp)
			 */
			getVerificationOTP: createAuthEndpoint(
				""/email-otp/get-verification-otp"",
				{
					method: ""GET"",
					query: z.object({
						email: z.string({}).meta({
							description: ""Email address the OTP was sent to"",
						}),
						type: z.enum(types).meta({
							required: true,
							description: ""Type of the OTP"",
						}),
					}),
					metadata: {
						SERVER_ONLY: true,
						openapi: {
							operationId: ""getEmailVerificationOTP"",
							description: ""Get a verification OTP for an email"",
							responses: {
								""200"": {
									description:
										""OTP retrieved successfully or not found/expired"",
									content: {
										""application/json"": {
											schema: {
												type: ""object"",
												properties: {
													otp: {
														type: ""string"",
														nullable: true,
														description:
															""The stored OTP, or null if not found or expired"",
													},
												},
												required: [""otp""],
											},
										},
									},
								},
							},
						},
					},
				},
				async (ctx) => {
					const email = ctx.query.email;
					const verificationValue =
						await ctx.context.internalAdapter.findVerificationValue(
							`${ctx.query.type}-otp-${email}`,
						);
					if (!verificationValue || verificationValue.expiresAt < new Date()) {
						return ctx.json({
							otp: null,
						});
					}
					if (
						opts.storeOTP === ""hashed"" ||
						(typeof opts.storeOTP === ""object"" && ""hash"" in opts.storeOTP)
					) {
						throw new APIError(""BAD_REQUEST"", {
							message: ""OTP is hashed, cannot return the plain text OTP"",
						});
					}

					let [storedOtp, _attempts] = splitAtLastColon(
						verificationValue.value,
					);
					let otp = storedOtp;
					if (opts.storeOTP === ""encrypted"") {
						otp = await symmetricDecrypt({
							key: ctx.context.secret,
							data: storedOtp,
						});
					}

					if (typeof opts.storeOTP === ""object"" && ""decrypt"" in opts.storeOTP) {
						otp = await opts.storeOTP.decrypt(storedOtp);
					}

					return ctx.json({
						otp,
					});
				},
			),
			/**
			 * ### Endpoint
			 *
			 * GET `/email-otp/check-verification-otp`
			 *
			 * ### API Methods
			 *
			 * **server:**
			 * `auth.api.checkVerificationOTP`
			 *
			 * @see [Read our docs to learn more.](https://better-auth.com/docs/plugins/email-otp#api-method-email-otp-check-verification-otp)
			 */
			checkVerificationOTP: createAuthEndpoint(
				""/email-otp/check-verification-otp"",
				{
					method: ""POST"",
					body: z.object({
						email: z.string().meta({
							description: ""Email address the OTP was sent to"",
						}),
						type: z.enum(types).meta({
							required: true,
							description: ""Type of the OTP"",
						}),
						otp: z.string().meta({
							required: true,
							description: ""OTP to verify"",
						}),
					}),
					metadata: {
						openapi: {
							operationId: ""verifyEmailWithOTP"",
							description: ""Verify an email with an OTP"",
							responses: {
								200: {
									description: ""Success"",
									content: {
										""application/json"": {
											schema: {
												type: ""object"",
												properties: {
													success: {
														type: ""boolean"",
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
				async (ctx) => {
					const email = ctx.body.email.toLowerCase();
					const isValidEmail = z.email().safeParse(email);
					if (!isValidEmail.success) {
						throw new APIError(""BAD_REQUEST"", {
							message: BASE_ERROR_CODES.INVALID_EMAIL,
						});
					}
					const user = await ctx.context.internalAdapter.findUserByEmail(email);
					if (!user) {
						throw new APIError(""BAD_REQUEST"", {
							message: BASE_ERROR_CODES.USER_NOT_FOUND,
						});
					}
					const verificationValue =
						await ctx.context.internalAdapter.findVerificationValue(
							`${ctx.body.type}-otp-${email}`,
						);
					if (!verificationValue) {
						throw new APIError(""BAD_REQUEST"", {
							message: ERROR_CODES.INVALID_OTP,
						});
					}
					if (verificationValue.expiresAt < new Date()) {
						await ctx.context.internalAdapter.deleteVerificationValue(
							verificationValue.id,
						);
						throw new APIError(""BAD_REQUEST"", {
							message: ERROR_CODES.OTP_EXPIRED,
						});
					}

					const [otpValue, attempts] = splitAtLastColon(
						verificationValue.value,
					);
					const allowedAttempts = options?.allowedAttempts || 3;
					if (attempts && parseInt(attempts) >= allowedAttempts) {
						await ctx.context.internalAdapter.deleteVerificationValue(
							verificationValue.id,
						);
						throw new APIError(""FORBIDDEN"", {
							message: ERROR_CODES.TOO_MANY_ATTEMPTS,
						});
					}
					const verified = await verifyStoredOTP(ctx, otpValue, ctx.body.otp);
					if (!verified) {
						await ctx.context.internalAdapter.updateVerificationValue(
							verificationValue.id,
							{
								value: `${otpValue}:${parseInt(attempts || ""0"") + 1}`,
							},
						);
						throw new APIError(""BAD_REQUEST"", {
							message: ERROR_CODES.INVALID_OTP,
						});
					}
					return ctx.json({
						success: true,
					});
				},
			),
			/**
			 * ### Endpoint
			 *
			 * POST `/email-otp/verify-email`
			 *
			 * ### API Methods
			 *
			 * **server:**
			 * `auth.api.verifyEmailOTP`
			 *
			 * **client:**
			 * `authClient.emailOtp.verifyEmail`
			 *
			 * @see [Read our docs to learn more.](https://better-auth.com/docs/plugins/email-otp#api-method-email-otp-verify-email)
			 */
			verifyEmailOTP: createAuthEndpoint(
				""/email-otp/verify-email"",
				{
					method: ""POST"",
					body: z.object({
						email: z.string({}).meta({
							description: ""Email address to verify"",
						}),
						otp: z.string().meta({
							required: true,
							description: ""OTP to verify"",
						}),
					}),
					metadata: {
						openapi: {
							description: ""Verify email with OTP"",
							responses: {
								200: {
									description: ""Success"",
									content: {
										""application/json"": {
											schema: {
												type: ""object"",
												properties: {
													status: {
														type: ""boolean"",
														description:
															""Indicates if the verification was successful"",
														enum: [true],
													},
													token: {
														type: ""string"",
														nullable: true,
														description:
															""Session token if autoSignInAfterVerification is enabled, otherwise null"",
													},
													user: {
														$ref: ""#/components/schemas/User"",
													},
												},
												required: [""status"", ""token"", ""user""],
											},
										},
									},
								},
							},
						},
					},
				},
				async (ctx) => {
					const email = ctx.body.email.toLowerCase();
					const isValidEmail = z.email().safeParse(email);
					if (!isValidEmail.success) {
						throw new APIError(""BAD_REQUEST"", {
							message: BASE_ERROR_CODES.INVALID_EMAIL,
						});
					}
					const verificationValue =
						await ctx.context.internalAdapter.findVerificationValue(
							`email-verification-otp-${email}`,
						);

					if (!verificationValue) {
						throw new APIError(""BAD_REQUEST"", {
							message: ERROR_CODES.INVALID_OTP,
						});
					}
					if (verificationValue.expiresAt < new Date()) {
						throw new APIError(""BAD_REQUEST"", {
							message: ERROR_CODES.OTP_EXPIRED,
						});
					}

					const [otpValue, attempts] = splitAtLastColon(
						verificationValue.value,
					);
					const allowedAttempts = options?.allowedAttempts || 3;
					if (attempts && parseInt(attempts) >= allowedAttempts) {
						await ctx.context.internalAdapter.deleteVerificationValue(
							verificationValue.id,
						);
						throw new APIError(""FORBIDDEN"", {
							message: ERROR_CODES.TOO_MANY_ATTEMPTS,
						});
					}
					const verified = await verifyStoredOTP(ctx, otpValue, ctx.body.otp);
					if (!verified) {
						await ctx.context.internalAdapter.updateVerificationValue(
							verificationValue.id,
							{
								value: `${otpValue}:${parseInt(attempts || ""0"") + 1}`,
							},
						);
						throw new APIError(""BAD_REQUEST"", {
							message: ERROR_CODES.INVALID_OTP,
						});
					}
					await ctx.context.internalAdapter.deleteVerificationValue(
						verificationValue.id,
					);
					const user = await ctx.context.internalAdapter.findUserByEmail(email);
					if (!user) {
						/**
						 * safe to leak the existence of a user, given the user has already the OTP from the
						 * email
						 */
						throw new APIError(""BAD_REQUEST"", {
							message: BASE_ERROR_CODES.USER_NOT_FOUND,
						});
					}
					const updatedUser = await ctx.context.internalAdapter.updateUser(
						user.user.id,
						{
							email,
							emailVerified: true,
						},
					);
					await ctx.context.options.emailVerification?.onEmailVerification?.(
						updatedUser,
						ctx.request,
					);

					if (
						ctx.context.options.emailVerification?.autoSignInAfterVerification
					) {
						const session = await ctx.context.internalAdapter.createSession(
							updatedUser.id,
						);
						await setSessionCookie(ctx, {
							session,
							user: updatedUser,
						});
						return ctx.json({
							status: true,
							token: session.token,
							user: {
								id: updatedUser.id,
								email: updatedUser.email,
								emailVerified: updatedUser.emailVerified,
								name: updatedUser.name,
								image: updatedUser.image,
								createdAt: updatedUser.createdAt,
								updatedAt: updatedUser.updatedAt,
							},
						});
					}
					const currentSession = await getSessionFromCtx(ctx);
					if (currentSession && updatedUser.emailVerified) {
						const dontRememberMeCookie = await ctx.getSignedCookie(
							ctx.context.authCookies.dontRememberToken.name,
							ctx.context.secret,
						);
						await setCookieCache(
							ctx,
							{
								session: currentSession.session,
								user: {
									...currentSession.user,
									emailVerified: true,
								},
							},
							!!dontRememberMeCookie,
						);
					}
					return ctx.json({
						status: true,
						token: null,
						user: {
							id: updatedUser.id,
							email: updatedUser.email,
							emailVerified: updatedUser.emailVerified,
							name: updatedUser.name,
							image: updatedUser.image,
							createdAt: updatedUser.createdAt,
							updatedAt: updatedUser.updatedAt,
						},
					});
				},
			),
			/**
			 * ### Endpoint
			 *
			 * POST `/sign-in/email-otp`
			 *
			 * ### API Methods
			 *
			 * **server:**
			 * `auth.api.signInEmailOTP`
			 *
			 * **client:**
			 * `authClient.signIn.emailOtp`
			 *
			 * @see [Read our docs to learn more.](https://better-auth.com/docs/plugins/email-otp#api-method-sign-in-email-otp)
			 */
			signInEmailOTP: createAuthEndpoint(
				""/sign-in/email-otp"",
				{
					method: ""POST"",
					body: z.object({
						email: z.string({}).meta({
							description: ""Email address to sign in"",
						}),
						otp: z.string().meta({
							required: true,
							description: ""OTP sent to the email"",
						}),
					}),
					metadata: {
						openapi: {
							operationId: ""signInWithEmailOTP"",
							description: ""Sign in with email and OTP"",
							responses: {
								200: {
									description: ""Success"",
									content: {
										""application/json"": {
											schema: {
												type: ""object"",
												properties: {
													token: {
														type: ""string"",
														description:
															""Session token for the authenticated session"",
													},
													user: {
														$ref: ""#/components/schemas/User"",
													},
												},
												required: [""token"", ""user""],
											},
										},
									},
								},
							},
						},
					},
				},
				async (ctx) => {
					const email = ctx.body.email;
					const verificationValue =
						await ctx.context.internalAdapter.findVerificationValue(
							`sign-in-otp-${email}`,
						);
					if (!verificationValue) {
						throw new APIError(""BAD_REQUEST"", {
							message: ERROR_CODES.INVALID_OTP,
						});
					}
					if (verificationValue.expiresAt < new Date()) {
						throw new APIError(""BAD_REQUEST"", {
							message: ERROR_CODES.OTP_EXPIRED,
						});
					}
					const [otpValue, attempts] = splitAtLastColon(
						verificationValue.value,
					);
					const allowedAttempts = options?.allowedAttempts || 3;
					if (attempts && parseInt(attempts) >= allowedAttempts) {
						await ctx.context.internalAdapter.deleteVerificationValue(
							verificationValue.id,
						);
						throw new APIError(""FORBIDDEN"", {
							message: ERROR_CODES.TOO_MANY_ATTEMPTS,
						});
					}
					const verified = await verifyStoredOTP(ctx, otpValue, ctx.body.otp);
					if (!verified) {
						await ctx.context.internalAdapter.updateVerificationValue(
							verificationValue.id,
							{
								value: `${otpValue}:${parseInt(attempts || ""0"") + 1}`,
							},
						);
						throw new APIError(""BAD_REQUEST"", {
							message: ERROR_CODES.INVALID_OTP,
						});
					}
					await ctx.context.internalAdapter.deleteVerificationValue(
						verificationValue.id,
					);
					const user = await ctx.context.internalAdapter.findUserByEmail(email);
					if (!user) {
						if (opts.disableSignUp) {
							throw new APIError(""BAD_REQUEST"", {
								message: BASE_ERROR_CODES.USER_NOT_FOUND,
							});
						}
						const newUser = await ctx.context.internalAdapter.createUser({
							email,
							emailVerified: true,
							name: """",
						});
						const session = await ctx.context.internalAdapter.createSession(
							newUser.id,
						);
						await setSessionCookie(ctx, {
							session,
							user: newUser,
						});
						return ctx.json({
							token: session.token,
							user: {
								id: newUser.id,
								email: newUser.email,
								emailVerified: newUser.emailVerified,
								name: newUser.name,
								image: newUser.image,
								createdAt: newUser.createdAt,
								updatedAt: newUser.updatedAt,
							},
						});
					}

					if (!user.user.emailVerified) {
						await ctx.context.internalAdapter.updateUser(user.user.id, {
							emailVerified: true,
						});
					}

					const session = await ctx.context.internalAdapter.createSession(
						user.user.id,
					);
					await setSessionCookie(ctx, {
						session,
						user: user.user,
					});
					return ctx.json({
						token: session.token,
						user: {
							id: user.user.id,
							email: user.user.email,
							emailVerified: user.user.emailVerified,
							name: user.user.name,
							image: user.user.image,
							createdAt: user.user.createdAt,
							updatedAt: user.user.updatedAt,
						},
					});
				},
			),
			/**
			 * ### Endpoint
			 *
			 * POST `/forget-password/email-otp`
			 *
			 * ### API Methods
			 *
			 * **server:**
			 * `auth.api.forgetPasswordEmailOTP`
			 *
			 * **client:**
			 * `authClient.forgetPassword.emailOtp`
			 *
			 * @see [Read our docs to learn more.](https://better-auth.com/docs/plugins/email-otp#api-method-forget-password-email-otp)
			 */
			forgetPasswordEmailOTP: createAuthEndpoint(
				""/forget-password/email-otp"",
				{
					method: ""POST"",
					body: z.object({
						email: z.string().meta({
							description: ""Email address to send the OTP"",
						}),
					}),
					metadata: {
						openapi: {
							operationId: ""forgetPasswordWithEmailOTP"",
							description: ""Forget password with email and OTP"",
							responses: {
								200: {
									description: ""Success"",
									content: {
										""application/json"": {
											schema: {
												type: ""object"",
												properties: {
													success: {
														type: ""boolean"",
														description:
															""Indicates if the OTP was sent successfully"",
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
				async (ctx) => {
					const email = ctx.body.email;
					const otp =
						opts.generateOTP({ email, type: ""forget-password"" }, ctx) ||
						defaultOTPGenerator(opts);
					let storedOTP = await storeOTP(ctx, otp);
					await ctx.context.internalAdapter.createVerificationValue({
						value: `${storedOTP}:0`,
						identifier: `forget-password-otp-${email}`,
						expiresAt: getDate(opts.expiresIn, ""sec""),
					});
					const user = await ctx.context.internalAdapter.findUserByEmail(email);
					if (!user) {
						await ctx.context.internalAdapter.deleteVerificationByIdentifier(
							`forget-password-otp-${email}`,
						);
						return ctx.json({
							success: true,
						});
					}
					await options
						.sendVerificationOTP(
							{
								email,
								otp,
								type: ""forget-password"",
							},
							ctx,
						)
						.catch((e) => {
							ctx.context.logger.error(""Failed to send OTP"", e);
						});
					return ctx.json({
						success: true,
					});
				},
			),
			/**
			 * ### Endpoint
			 *
			 * POST `/email-otp/reset-password`
			 *
			 * ### API Methods
			 *
			 * **server:**
			 * `auth.api.resetPasswordEmailOTP`
			 *
			 * **client:**
			 * `authClient.emailOtp.resetPassword`
			 *
			 * @see [Read our docs to learn more.](https://better-auth.com/docs/plugins/email-otp#api-method-email-otp-reset-password)
			 */
			resetPasswordEmailOTP: createAuthEndpoint(
				""/email-otp/reset-password"",
				{
					method: ""POST"",
					body: z.object({
						email: z.string().meta({
							description: ""Email address to reset the password"",
						}),
						otp: z.string().meta({
							description: ""OTP sent to the email"",
						}),
						password: z.string().meta({
							description: ""New password"",
						}),
					}),
					metadata: {
						openapi: {
							operationId: ""resetPasswordWithEmailOTP"",
							description: ""Reset password with email and OTP"",
							responses: {
								200: {
									description: ""Success"",
									contnt: {
										""application/json"": {
											schema: {
												type: ""object"",
												properties: {
													success: {
														type: ""boolean"",
													},
												},
											},
										},
									},
								},
							},
						},
					},
				},
				async (ctx) => {
					const email = ctx.body.email;
					const verificationValue =
						await ctx.context.internalAdapter.findVerificationValue(
							`forget-password-otp-${email}`,
						);
					if (!verificationValue) {
						throw new APIError(""BAD_REQUEST"", {
							message: ERROR_CODES.INVALID_OTP,
						});
					}
					if (verificationValue.expiresAt < new Date()) {
						await ctx.context.internalAdapter.deleteVerificationValue(
							verificationValue.id,
						);
						throw new APIError(""BAD_REQUEST"", {
							message: ERROR_CODES.OTP_EXPIRED,
						});
					}
					const [otpValue, attempts] = splitAtLastColon(
						verificationValue.value,
					);
					const allowedAttempts = options?.allowedAttempts || 3;
					if (attempts && parseInt(attempts) >= allowedAttempts) {
						await ctx.context.internalAdapter.deleteVerificationValue(
							verificationValue.id,
						);
						throw new APIError(""FORBIDDEN"", {
							message: ERROR_CODES.TOO_MANY_ATTEMPTS,
						});
					}
					const verified = await verifyStoredOTP(ctx, otpValue, ctx.body.otp);
					if (!verified) {
						await ctx.context.internalAdapter.updateVerificationValue(
							verificationValue.id,
							{
								value: `${otpValue}:${parseInt(attempts || ""0"") + 1}`,
							},
						);
						throw new APIError(""BAD_REQUEST"", {
							message: ERROR_CODES.INVALID_OTP,
						});
					}
					await ctx.context.internalAdapter.deleteVerificationValue(
						verificationValue.id,
					);
					const user = await ctx.context.internalAdapter.findUserByEmail(
						email,
						{
							includeAccounts: true,
						},
					);
					if (!user) {
						throw new APIError(""BAD_REQUEST"", {
							message: BASE_ERROR_CODES.USER_NOT_FOUND,
						});
					}
					const minPasswordLength =
						ctx.context.password.config.minPasswordLength;
					if (ctx.body.password.length < minPasswordLength) {
						throw new APIError(""BAD_REQUEST"", {
							message: BASE_ERROR_CODES.PASSWORD_TOO_SHORT,
						});
					}
					const maxPasswordLength =
						ctx.context.password.config.maxPasswordLength;
					if (ctx.body.password.length > maxPasswordLength) {
						throw new APIError(""BAD_REQUEST"", {
							message: BASE_ERROR_CODES.PASSWORD_TOO_LONG,
						});
					}
					const passwordHash = await ctx.context.password.hash(
						ctx.body.password,
					);
					let account = user.accounts?.find(
						(account) => account.providerId === ""credential"",
					);
					if (!account) {
						await ctx.context.internalAdapter.createAccount({
							userId: user.user.id,
							providerId: ""credential"",
							accountId: user.user.id,
							password: passwordHash,
						});
					} else {
						await ctx.context.internalAdapter.updatePassword(
							user.user.id,
							passwordHash,
						);
					}

					if (ctx.context.options.emailAndPassword?.onPasswordReset) {
						await ctx.context.options.emailAndPassword.onPasswordReset(
							{
								user: user.user,
							},
							ctx.request,
						);
					}

					if (!user.user.emailVerified) {
						await ctx.context.internalAdapter.updateUser(user.user.id, {
							emailVerified: true,
						});
					}

					if (
						ctx.context.options.emailAndPassword?.revokeSessionsOnPasswordReset
					) {
						await ctx.context.internalAdapter.deleteSessions(user.user.id);
					}
					return ctx.json({
						success: true,
					});
				},
			),
		},",0
"						model: ""passkey"",
						where: [
							{
								field: ""id"",
								value: ctx.body.id,
							},
							{
								field: ""userId"",
								value: ctx.context.session.user.id,
							},
						],
					});
					return ctx.json(null, {
						status: 200,
					});
				},",0
"'use strict';

/**
 * Converts tokens for a single address into an address object
 *
 * @param {Array} tokens Tokens object
 * @param {Number} depth Current recursion depth for nested group protection
 * @return {Object} Address object
 */
function _handleAddress(tokens, depth) {
    let isGroup = false;
    let state = 'text';
    let address;
    let addresses = [];
    let data = {
        address: [],
        comment: [],
        group: [],
        text: [],
        textWasQuoted: [] // Track which text tokens came from inside quotes
    };
    let i;
    let len;
    let insideQuotes = false; // Track if we're currently inside a quoted string

    // Filter out <addresses>, (comments) and regular text
    for (i = 0, len = tokens.length; i < len; i++) {
        let token = tokens[i];
        let prevToken = i ? tokens[i - 1] : null;
        if (token.type === 'operator') {
            switch (token.value) {
                case '<':
                    state = 'address';
                    insideQuotes = false;
                    break;
                case '(':
                    state = 'comment';
                    insideQuotes = false;
                    break;
                case ':':
                    state = 'group';
                    isGroup = true;
                    insideQuotes = false;
                    break;
                case '""':
                    // Track quote state for text tokens
                    insideQuotes = !insideQuotes;
                    state = 'text';
                    break;
                default:
                    state = 'text';
                    insideQuotes = false;
                    break;
            }
        } else if (token.value) {
            if (state === 'address') {
                // handle use case where unquoted name includes a ""<""
                // Apple Mail truncates everything between an unexpected < and an address
                // and so will we
                token.value = token.value.replace(/^[^<]*<\s*/, '');
            }

            if (prevToken && prevToken.noBreak && data[state].length) {
                // join values
                data[state][data[state].length - 1] += token.value;
                if (state === 'text' && insideQuotes) {
                    data.textWasQuoted[data.textWasQuoted.length - 1] = true;
                }
            } else {
                data[state].push(token.value);
                if (state === 'text') {
                    data.textWasQuoted.push(insideQuotes);
                }
            }
        }
    }

    // If there is no text but a comment, replace the two
    if (!data.text.length && data.comment.length) {
        data.text = data.comment;
        data.comment = [];
    }

    if (isGroup) {
        // http://tools.ietf.org/html/rfc2822#appendix-A.1.3
        data.text = data.text.join(' ');

        // Parse group members, but flatten any nested groups (RFC 5322 doesn't allow nesting)
        let groupMembers = [];
        if (data.group.length) {
            let parsedGroup = addressparser(data.group.join(','), { _depth: depth + 1 });
            // Flatten: if any member is itself a group, extract its members into the sequence
            parsedGroup.forEach(member => {
                if (member.group) {
                    // Nested group detected - flatten it by adding its members directly
                    groupMembers = groupMembers.concat(member.group);
                } else {
                    groupMembers.push(member);
                }
            });
        }

        addresses.push({
            name: data.text || (address && address.name),
            group: groupMembers
        });
    } else {
        // If no address was found, try to detect one from regular text
        if (!data.address.length && data.text.length) {
            for (i = data.text.length - 1; i >= 0; i--) {
                // Security fix: Do not extract email addresses from quoted strings
                // RFC 5321 allows @ inside quoted local-parts like ""user@domain""@example.com
                // Extracting emails from quoted text leads to misrouting vulnerabilities
                if (!data.textWasQuoted[i] && data.text[i].match(/^[^@\s]+@[^@\s]+$/)) {
                    data.address = data.text.splice(i, 1);
                    data.textWasQuoted.splice(i, 1);
                    break;
                }
            }

            let _regexHandler = function (address) {
                if (!data.address.length) {
                    data.address = [address.trim()];
                    return ' ';
                } else {
                    return address;
                }
            };

            // still no address
            if (!data.address.length) {
                for (i = data.text.length - 1; i >= 0; i--) {
                    // Security fix: Do not extract email addresses from quoted strings
                    if (!data.textWasQuoted[i]) {
                        // fixed the regex to parse email address correctly when email address has more than one @
                        data.text[i] = data.text[i].replace(/\s*\b[^@\s]+@[^\s]+\b\s*/, _regexHandler).trim();
                        if (data.address.length) {
                            break;
                        }
                    }
                }
            }
        }

        // If there's still is no text but a comment exixts, replace the two
        if (!data.text.length && data.comment.length) {
            data.text = data.comment;
            data.comment = [];
        }

        // Keep only the first address occurence, push others to regular text
        if (data.address.length > 1) {
            data.text = data.text.concat(data.address.splice(1));
        }

        // Join values with spaces
        data.text = data.text.join(' ');
        data.address = data.address.join(' ');

        if (!data.address && isGroup) {
            return [];
        } else {
            address = {
                address: data.address || data.text || '',
                name: data.text || data.address || ''
            };

            if (address.address === address.name) {
                if ((address.address || '').match(/@/)) {
                    address.name = '';
                } else {
                    address.address = '';
                }
            }

            addresses.push(address);
        }
    }

    return addresses;
}

/**
 * Creates a Tokenizer object for tokenizing address field strings
 *
 * @constructor
 * @param {String} str Address field string
 */
class Tokenizer {
    constructor(str) {
        this.str = (str || '').toString();
        this.operatorCurrent = '';
        this.operatorExpecting = '';
        this.node = null;
        this.escaped = false;

        this.list = [];
        /**
         * Operator tokens and which tokens are expected to end the sequence
         */
        this.operators = {
            '""': '""',
            '(': ')',
            '<': '>',
            ',': '',
            ':': ';',
            // Semicolons are not a legal delimiter per the RFC2822 grammar other
            // than for terminating a group, but they are also not valid for any
            // other use in this context.  Given that some mail clients have
            // historically allowed the semicolon as a delimiter equivalent to the
            // comma in their UI, it makes sense to treat them the same as a comma
            // when used outside of a group.
            ';': ''
        };
    }

    /**
     * Tokenizes the original input string
     *
     * @return {Array} An array of operator|text tokens
     */
    tokenize() {
        let list = [];

        for (let i = 0, len = this.str.length; i < len; i++) {
            let chr = this.str.charAt(i);
            let nextChr = i < len - 1 ? this.str.charAt(i + 1) : null;
            this.checkChar(chr, nextChr);
        }

        this.list.forEach(node => {
            node.value = (node.value || '').toString().trim();
            if (node.value) {
                list.push(node);
            }
        });

        return list;
    }

    /**
     * Checks if a character is an operator or text and acts accordingly
     *
     * @param {String} chr Character from the address field
     */
    checkChar(chr, nextChr) {
        if (this.escaped) {
            // ignore next condition blocks
        } else if (chr === this.operatorExpecting) {
            this.node = {
                type: 'operator',
                value: chr
            };

            if (nextChr && ![' ', '\t', '\r', '\n', ',', ';'].includes(nextChr)) {
                this.node.noBreak = true;
            }

            this.list.push(this.node);
            this.node = null;
            this.operatorExpecting = '';
            this.escaped = false;

            return;
        } else if (!this.operatorExpecting && chr in this.operators) {
            this.node = {
                type: 'operator',
                value: chr
            };
            this.list.push(this.node);
            this.node = null;
            this.operatorExpecting = this.operators[chr];
            this.escaped = false;
            return;
        } else if (['""', ""'""].includes(this.operatorExpecting) && chr === '\\') {
            this.escaped = true;
            return;
        }

        if (!this.node) {
            this.node = {
                type: 'text',
                value: ''
            };
            this.list.push(this.node);
        }

        if (chr === '\n') {
            // Convert newlines to spaces. Carriage return is ignored as \r and \n usually
            // go together anyway and there already is a WS for \n. Lone \r means something is fishy.
            chr = ' ';
        }

        if (chr.charCodeAt(0) >= 0x21 || [' ', '\t'].includes(chr)) {
            // skip command bytes
            this.node.value += chr;
        }

        this.escaped = false;
    }
}

/**
 * Maximum recursion depth for parsing nested groups.
 * RFC 5322 doesn't allow nested groups, so this is a safeguard against
 * malicious input that could cause stack overflow.
 */
const MAX_NESTED_GROUP_DEPTH = 50;

/**
 * Parses structured e-mail addresses from an address field
 *
 * Example:
 *
 *    'Name <address@domain>'
 *
 * will be converted to
 *
 *     [{name: 'Name', address: 'address@domain'}]
 *
 * @param {String} str Address field
 * @param {Object} options Optional options object
 * @param {Number} options._depth Internal recursion depth counter (do not set manually)
 * @return {Array} An array of address objects
 */
function addressparser(str, options) {
    options = options || {};
    let depth = options._depth || 0;

    // Prevent stack overflow from deeply nested groups (DoS protection)
    if (depth > MAX_NESTED_GROUP_DEPTH) {
        return [];
    }

    let tokenizer = new Tokenizer(str);
    let tokens = tokenizer.tokenize();

    let addresses = [];
    let address = [];
    let parsedAddresses = [];

    tokens.forEach(token => {
        if (token.type === 'operator' && (token.value === ',' || token.value === ';')) {
            if (address.length) {
                addresses.push(address);
            }
            address = [];
        } else {
            address.push(token);
        }
    });

    if (address.length) {
        addresses.push(address);
    }

    addresses.forEach(address => {
        address = _handleAddress(address, depth);
        if (address.length) {
            parsedAddresses = parsedAddresses.concat(address);
        }
    });

    if (options.flatten) {",0
"            let result = addressparser(input);
            let elapsed = Date.now() - start;
            assert.ok(elapsed < 1000, 'Should handle many delimiters quickly');
            assert.strictEqual(result.length, 2);
        });
    });

    // DoS protection tests for deeply nested groups (CVE-like vulnerability fix)
    describe('Nested group DoS protection', () => {
        /**
         * Helper to build deeply nested group structure
         * e.g., depth=3 produces: ""g0: g1: g2: user@example.com;""
         */
        function buildDeepGroup(depth) {
            let parts = [];
            for (let i = 0; i < depth; i++) {
                parts.push(`g${i}:`);
            }
            return parts.join(' ') + ' user@example.com;';
        }

        it('should handle moderately nested groups (depth 10)', () => {
            let input = buildDeepGroup(10);
            let result = addressparser(input);
            assert.strictEqual(result.length, 1);
            assert.strictEqual(result[0].name, 'g0');
            assert.ok(result[0].group);
            // Should successfully extract the email from nested structure
            assert.strictEqual(result[0].group.length, 1);
            assert.strictEqual(result[0].group[0].address, 'user@example.com');
        });

        it('should handle nested groups at depth limit (depth 50)', () => {
            let input = buildDeepGroup(50);
            let result = addressparser(input);
            assert.strictEqual(result.length, 1);
            assert.strictEqual(result[0].name, 'g0');
            assert.ok(result[0].group);
            // At the limit, should still work
            assert.strictEqual(result[0].group.length, 1);
            assert.strictEqual(result[0].group[0].address, 'user@example.com');
        });

        it('should safely truncate groups exceeding depth limit (depth 100)', () => {
            let input = buildDeepGroup(100);
            let result = addressparser(input);
            // Should not throw stack overflow
            assert.strictEqual(result.length, 1);
            assert.strictEqual(result[0].name, 'g0');
            assert.ok(result[0].group);
            // Group is truncated due to depth limit - members beyond limit are dropped
        });

        it('should not crash with malicious deeply nested input (depth 3000)', () => {
            // This would previously cause ""Maximum call stack size exceeded""
            let input = buildDeepGroup(3000);
            let start = Date.now();
            let result;

            // Must not throw
            assert.doesNotThrow(() => {
                result = addressparser(input);
            });

            let elapsed = Date.now() - start;
            // Should complete quickly (under 1 second), not hang
            assert.ok(elapsed < 1000, `Parser took too long: ${elapsed}ms`);

            // Should return a valid result structure
            assert.strictEqual(result.length, 1);
            assert.strictEqual(result[0].name, 'g0');
            assert.ok(result[0].group);
        });

        it('should not crash with extreme nesting depth (depth 10000)', () => {
            let input = buildDeepGroup(10000);
            let start = Date.now();
            let result;

            assert.doesNotThrow(() => {
                result = addressparser(input);
            });

            let elapsed = Date.now() - start;
            assert.ok(elapsed < 2000, `Parser took too long: ${elapsed}ms`);
            assert.ok(Array.isArray(result));
        });

        it('should handle multiple deeply nested groups in same input', () => {
            let input = buildDeepGroup(100) + ', ' + buildDeepGroup(100);
            let result;

            assert.doesNotThrow(() => {
                result = addressparser(input);
            });

            // Should parse both groups
            assert.strictEqual(result.length, 2);
            assert.strictEqual(result[0].name, 'g0');
            assert.strictEqual(result[1].name, 'g0');
        });

        it('should handle mixed normal and deeply nested addresses', () => {
            let input = 'normal@example.com, ' + buildDeepGroup(200) + ', another@test.com';
            let result;

            assert.doesNotThrow(() => {
                result = addressparser(input);
            });

            assert.strictEqual(result.length, 3);
            assert.strictEqual(result[0].address, 'normal@example.com');
            assert.strictEqual(result[1].name, 'g0');
            assert.strictEqual(result[2].address, 'another@test.com');
        });

        it('should preserve normal functionality while protecting against DoS', () => {
            // Normal nested groups (allowed up to depth limit) should work correctly
            let input = 'Outer: Inner: deep@example.com; ;';
            let result = addressparser(input);

            assert.strictEqual(result.length, 1);
            assert.strictEqual(result[0].name, 'Outer');
            assert.ok(result[0].group);
            // Inner group should be flattened
            assert.strictEqual(result[0].group.length, 1);
            assert.strictEqual(result[0].group[0].address, 'deep@example.com');
        });

        it('should work correctly with flatten option on deeply nested input', () => {
            let input = buildDeepGroup(100);
            let result;

            assert.doesNotThrow(() => {
                result = addressparser(input, { flatten: true });
            });

            // Should return flattened array without crashing
            assert.ok(Array.isArray(result));
        });
    });
});",0
"    let address;
    let addresses = [];
    let data = {
        address: [],
        comment: [],
        group: [],
        text: [],
        textWasQuoted: [] // Track which text tokens came from inside quotes
    };
    let i;
    let len;
    let insideQuotes = false; // Track if we're currently inside a quoted string

    // Filter out <addresses>, (comments) and regular text
    for (i = 0, len = tokens.length; i < len; i++) {
        let token = tokens[i];
        let prevToken = i ? tokens[i - 1] : null;
        if (token.type === 'operator') {
            switch (token.value) {
                case '<':
                    state = 'address';
                    insideQuotes = false;
                    break;
                case '(':
                    state = 'comment';
                    insideQuotes = false;
                    break;
                case ':':
                    state = 'group';
                    isGroup = true;
                    insideQuotes = false;
                    break;
                case '""':
                    // Track quote state for text tokens
                    insideQuotes = !insideQuotes;
                    state = 'text';
                    break;
                default:
                    state = 'text';
                    insideQuotes = false;
                    break;
            }
        } else if (token.value) {
            if (state === 'address') {
                // handle use case where unquoted name includes a ""<""
                // Apple Mail truncates everything between an unexpected < and an address
                // and so will we
                token.value = token.value.replace(/^[^<]*<\s*/, '');
            }

            if (prevToken && prevToken.noBreak && data[state].length) {
                // join values
                data[state][data[state].length - 1] += token.value;
                if (state === 'text' && insideQuotes) {
                    data.textWasQuoted[data.textWasQuoted.length - 1] = true;
                }
            } else {
                data[state].push(token.value);
                if (state === 'text') {
                    data.textWasQuoted.push(insideQuotes);
                }
            }
        }
    }

    // If there is no text but a comment, replace the two
    if (!data.text.length && data.comment.length) {
        data.text = data.comment;
        data.comment = [];
    }

    if (isGroup) {
        // http://tools.ietf.org/html/rfc2822#appendix-A.1.3
        data.text = data.text.join(' ');
        addresses.push({
            name: data.text || (address && address.name),
            group: data.group.length ? addressparser(data.group.join(',')) : []
        });
    } else {
        // If no address was found, try to detect one from regular text
        if (!data.address.length && data.text.length) {
            for (i = data.text.length - 1; i >= 0; i--) {
                // Security fix: Do not extract email addresses from quoted strings
                // RFC 5321 allows @ inside quoted local-parts like ""user@domain""@example.com
                // Extracting emails from quoted text leads to misrouting vulnerabilities
                if (!data.textWasQuoted[i] && data.text[i].match(/^[^@\s]+@[^@\s]+$/)) {
                    data.address = data.text.splice(i, 1);
                    data.textWasQuoted.splice(i, 1);
                    break;
                }
            }

            let _regexHandler = function (address) {
                if (!data.address.length) {
                    data.address = [address.trim()];
                    return ' ';
                } else {
                    return address;
                }
            };

            // still no address
            if (!data.address.length) {
                for (i = data.text.length - 1; i >= 0; i--) {
                    // Security fix: Do not extract email addresses from quoted strings
                    if (!data.textWasQuoted[i]) {
                        // fixed the regex to parse email address correctly when email address has more than one @
                        data.text[i] = data.text[i].replace(/\s*\b[^@\s]+@[^\s]+\b\s*/, _regexHandler).trim();
                        if (data.address.length) {
                            break;
                        }
                    }
                }
            }
        }

        // If there's still is no text but a comment exixts, replace the two",0
"                address: 'test@subdomain.com@example.com',
                name: ''
            }
        ];
        assert.deepStrictEqual(addressparser(input), expected);
    });

    // Security tests for RFC 5321/5322 quoted local-part handling
    it('should not extract email from quoted local-part (security)', () => {
        let input = '""xclow3n@gmail.com x""@internal.domain';
        let result = addressparser(input);
        // Should preserve full address, NOT extract xclow3n@gmail.com
        assert.strictEqual(result.length, 1);
        assert.strictEqual(result[0].address.includes('@internal.domain'), true);
        assert.strictEqual(result[0].address, 'xclow3n@gmail.com x@internal.domain');
    });

    it('should handle quoted local-part with attacker domain (security)', () => {
        let input = '""user@attacker.com""@legitimate.com';
        let result = addressparser(input);
        // Should route to legitimate.com, not attacker.com
        assert.strictEqual(result.length, 1);
        assert.strictEqual(result[0].address.includes('@legitimate.com'), true);
        assert.strictEqual(result[0].address, 'user@attacker.com@legitimate.com');
    });

    it('should handle multiple @ in quoted local-part (security)', () => {
        let input = '""a@b@c""@example.com';
        let result = addressparser(input);
        // Should not extract a@b or b@c
        assert.strictEqual(result.length, 1);
        assert.strictEqual(result[0].address, 'a@b@c@example.com');
    });

    it('should handle quoted local-part with angle brackets', () => {
        let input = 'Name <""user@domain.com""@example.com>';
        let result = addressparser(input);
        assert.strictEqual(result.length, 1);
        assert.strictEqual(result[0].name, 'Name');
        // When address is in <>, quotes are preserved as part of the address
        assert.strictEqual(result[0].address, '""user@domain.com""@example.com');
    });
});",0
" * @return {Object}
 * @private
 */

function parseExtendedQueryString(str) {
  return qs.parse(str, {
    plainObjects: true
  });
}",0
"'use strict'

var assert = require('node:assert')
var express = require('../')
  , request = require('supertest');
var qs = require('qs');

describe('req', function(){
  describe('.query', function(){
    it('should default to {}', function(done){
      var app = createApp();

      request(app)
      .get('/')
      .expect(200, '{}', done);
    });

    it('should default to parse simple keys', function (done) {
      var app = createApp();

      request(app)
      .get('/?user[name]=tj')
      .expect(200, '{""user[name]"":""tj""}', done);
    });

    describe('when ""query parser"" is extended', function () {
      it('should parse complex keys', function (done) {
        var app = createApp('extended');

        request(app)
        .get('/?foo[0][bar]=baz&foo[0][fizz]=buzz&foo[]=done!')
        .expect(200, '{""foo"":[{""bar"":""baz"",""fizz"":""buzz""},""done!""]}', done);
      });

      it('should parse parameters with dots', function (done) {
        var app = createApp('extended');

        request(app)
        .get('/?user.name=tj')
        .expect(200, '{""user.name"":""tj""}', done);
      });

      it('should not be able to access object prototype properties', function (done) {
        var app = createApp('extended', true);

        request(app)
        .get('/?foo=yee')
        .expect(200, /TypeError: req\.query\.hasOwnProperty is not a function/, done);
      });

      it('should be able to use object prototype property names as keys', function (done) {
        var app = createApp('extended', true);

        request(app)
        .get('/?hasOwnProperty=yee')
        .expect(200, '{""query"":{""hasOwnProperty"":""yee""},""error"":""TypeError: req.query.hasOwnProperty is not a function""}', done);
      });
    });

    describe('when ""query parser"" is simple', function () {
      it('should not parse complex keys', function (done) {
        var app = createApp('simple');

        request(app)
        .get('/?user%5Bname%5D=tj')
        .expect(200, '{""user[name]"":""tj""}', done);
      });

      it('should not be able to access object prototype properties', function (done) {
        var app = createApp('simple', true);

        request(app)
        .get('/?foo=yee')
        .expect(200, /TypeError: req\.query\.hasOwnProperty is not a function/, done);
      });

      it('should be able to use object prototype property names as keys', function (done) {
        var app = createApp('simple', true);

        request(app)
        .get('/?hasOwnProperty=yee')
        .expect(200, '{""query"":{""hasOwnProperty"":""yee""},""error"":""TypeError: req.query.hasOwnProperty is not a function""}', done);
      });
    });

    describe('when ""query parser"" is a function', function () {
      it('should parse using function', function (done) {
        var app = createApp(function (str) {
          return {'length': (str || '').length};
        });

        request(app)
        .get('/?user%5Bname%5D=tj')
        .expect(200, '{""length"":17}', done);
      });

      // test exists to verify behavior for folks wishing to workaround our qs defaults
      it('should drop object prototype property names and be able to access object prototype properties', function (done) {
        var app = createApp(
          function (str) {
            return qs.parse(str)
          }, true);

        request(app)
        .get('/?hasOwnProperty=biscuits')
        .expect(200, '{""query"":{},""hasOwnProperty"":false}', done);
      });
    });

    describe('when ""query parser"" disabled', function () {
      it('should not parse query', function (done) {
        var app = createApp(false);

        request(app)
        .get('/?user%5Bname%5D=tj')
        .expect(200, '{}', done);
      });

      it('should not be able to access object prototype properties', function (done) {
        var app = createApp('extended', true);

        request(app)
        .get('/?foo=yee')
        .expect(200, /TypeError: req\.query\.hasOwnProperty is not a function/, done);
      });

      it('should be able to use object prototype property names as keys', function (done) {
        var app = createApp('extended', true);

        request(app)
        .get('/?hasOwnProperty=yee')
        .expect(200, '{""query"":{""hasOwnProperty"":""yee""},""error"":""TypeError: req.query.hasOwnProperty is not a function""}', done);
      });
    });

    describe('when ""query parser"" enabled', function () {
      it('should not parse complex keys', function (done) {
        var app = createApp(true);

        request(app)
        .get('/?user%5Bname%5D=tj')
        .expect(200, '{""user[name]"":""tj""}', done);
      });

      it('should not be able to access object prototype properties', function (done) {
        var app = createApp('extended', true);

        request(app)
        .get('/?foo=yee')
        .expect(200, /TypeError: req\.query\.hasOwnProperty is not a function/, done);
      });

      it('should be able to use object prototype property names as keys', function (done) {
        var app = createApp('extended', true);

        request(app)
        .get('/?hasOwnProperty=yee')
        .expect(200, '{""query"":{""hasOwnProperty"":""yee""},""error"":""TypeError: req.query.hasOwnProperty is not a function""}', done);
      });
    });

    describe('when ""query parser"" an unknown value', function () {
      it('should throw', function () {
        assert.throws(createApp.bind(null, 'bogus'),
          /unknown value.*query parser/)
      });
    });
  })
})

function createApp(setting, isPrototypePropertyTest) {
  var app = express();

  if (setting !== undefined) {
    app.set('query parser', setting);
  }

  app.use(function (req, res) {
    if(isPrototypePropertyTest) {
      try {
        var hasOwnProperty = req.query.hasOwnProperty('✨ express ✨');
        res.send({ query: req.query, hasOwnProperty: hasOwnProperty });
      } catch (error) {
        res.send({ query: req.query, error: error.toString() });
      }
    }
    else {
      res.send(req.query);
    }
  });

  return app;
}",0
"    max = options.max;
  } else { // backwards compatibility: isLength(str, min [, max])
    min = arguments[1] || 0;
    max = arguments[2];
  }

  const presentationSequences = str.match(/[^\uFE0F\uFE0E][\uFE0F\uFE0E]/g) || [];
  const surrogatePairs = str.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g) || [];
  const len = str.length - presentationSequences.length - surrogatePairs.length;
  const isInsideRange = len >= min && (typeof max === 'undefined' || len <= max);

  if (isInsideRange && Array.isArray(options?.discreteLengths)) {
    return options.discreteLengths.some(discreteLen => discreteLen === len);",0
"      args: ['abc', 'i'],
      valid: ['abc', 'abcdef', '123abc', 'AbC'],
      invalid: ['acb'],
    });
  });


  it('should validate isLocale codes', () => {
    test({
      validator: 'isLocale',
      valid: [
        'uz_Latn_UZ',
        'en',
        'gsw',
        'en-US',
        'es_ES',
        'es-419',
        'sw_KE',
        'am_ET',
        'zh-CHS',
        'ca_ES_VALENCIA',
        'en_US_POSIX',
        'hak-CN',
        'zh-Hant',
        'zh-Hans',
        'sr-Cyrl',
        'sr-Latn',
        'zh-cmn-Hans-CN',
        'cmn-Hans-CN',
        'zh-yue-HK',
        'yue-HK',
        'zh-Hans-CN',
        'sr-Latn-RS',
        'sl-rozaj',
        'sl-rozaj-biske',
        'sl-nedis',
        'de-CH-1901',
        'sl-IT-nedis',
        'hy-Latn-IT-arevela',
        'i-enochian',
        'en-scotland-fonipa',
        'sl-IT-rozaj-biske-1994',
        'de-CH-x-phonebk',
        'az-Arab-x-AZE-derbend',
        'x-whatever',
        'qaa-Qaaa-QM-x-southern',
        'de-Qaaa',
        'sr-Latn-QM',
        'sr-Qaaa-RS',
        'en-US-u-islamcal',
        'zh-CN-a-myext-x-private',
        'en-a-myext-b-another',
      ],
      invalid: [
        'lo_POP',
        '12',
        '12_DD',
        'de-419-DE',
        'a-DE',
      ],
    });
  });

  it('should validate strings by byte length (deprecated api)', () => {
    test({
      validator: 'isByteLength',
      args: [2],
      valid: ['abc', 'de', 'abcd', 'ｇｍａｉｌ'],
      invalid: ['', 'a'],
    });
    test({
      validator: 'isByteLength',
      args: [2, 3],
      valid: ['abc', 'de', 'ｇ'],
      invalid: ['', 'a', 'abcd', 'ｇｍ'],
    });
    test({
      validator: 'isByteLength',
      args: [0, 0],
      valid: [''],
      invalid: ['ｇ', 'a'],
    });
  });


  it('should validate strings by byte length', () => {
    test({
      validator: 'isByteLength',
      args: [{ min: 2 }],
      valid: ['abc', 'de', 'abcd', 'ｇｍａｉｌ'],",0
"  IA5STRING:       22,
  UTCTIME:         23,
  GENERALIZEDTIME: 24,
  BMPSTRING:       30
};

/**
 * Sets the default maximum recursion depth when parsing ASN.1 structures.
 */
asn1.maxDepth = 256;

/**
 * Creates a new asn1 object.
 *
 * @param tagClass the tag class for the object.
 * @param type the data type (tag number) for the object.
 * @param constructed true if the asn1 object is in constructed form.
 * @param value the value for the object, if it is not constructed.
 * @param [options] the options to use:
 *          [bitStringContents] the plain BIT STRING content including padding
 *            byte.
 *
 * @return the asn1 object.
 */
asn1.create = function(tagClass, type, constructed, value, options) {
  /* An asn1 object has a tagClass, a type, a constructed flag, and a
    value. The value's type depends on the constructed flag. If
    constructed, it will contain a list of other asn1 objects. If not,
    it will contain the ASN.1 value as an array of bytes formatted
    according to the ASN.1 data type. */

  // remove undefined values
  if(forge.util.isArray(value)) {
    var tmp = [];
    for(var i = 0; i < value.length; ++i) {
      if(value[i] !== undefined) {
        tmp.push(value[i]);
      }
    }
    value = tmp;
  }

  var obj = {
    tagClass: tagClass,
    type: type,
    constructed: constructed,
    composed: constructed || forge.util.isArray(value),
    value: value
  };
  if(options && 'bitStringContents' in options) {
    // TODO: copy byte buffer if it's a buffer not a string
    obj.bitStringContents = options.bitStringContents;
    // TODO: add readonly flag to avoid this overhead
    // save copy to detect changes
    obj.original = asn1.copy(obj);
  }
  return obj;
};

/**
 * Copies an asn1 object.
 *
 * @param obj the asn1 object.
 * @param [options] copy options:
 *          [excludeBitStringContents] true to not copy bitStringContents
 *
 * @return the a copy of the asn1 object.
 */
asn1.copy = function(obj, options) {
  var copy;

  if(forge.util.isArray(obj)) {
    copy = [];
    for(var i = 0; i < obj.length; ++i) {
      copy.push(asn1.copy(obj[i], options));
    }
    return copy;
  }

  if(typeof obj === 'string') {
    // TODO: copy byte buffer if it's a buffer not a string
    return obj;
  }

  copy = {
    tagClass: obj.tagClass,
    type: obj.type,
    constructed: obj.constructed,
    composed: obj.composed,
    value: asn1.copy(obj.value, options)
  };
  if(options && !options.excludeBitStringContents) {
    // TODO: copy byte buffer if it's a buffer not a string
    copy.bitStringContents = obj.bitStringContents;
  }
  return copy;
};

/**
 * Compares asn1 objects for equality.
 *
 * Note this function does not run in constant time.
 *
 * @param obj1 the first asn1 object.
 * @param obj2 the second asn1 object.
 * @param [options] compare options:
 *          [includeBitStringContents] true to compare bitStringContents
 *
 * @return true if the asn1 objects are equal.
 */
asn1.equals = function(obj1, obj2, options) {
  if(forge.util.isArray(obj1)) {
    if(!forge.util.isArray(obj2)) {
      return false;
    }
    if(obj1.length !== obj2.length) {
      return false;
    }
    for(var i = 0; i < obj1.length; ++i) {
      if(!asn1.equals(obj1[i], obj2[i])) {
        return false;
      }
    }
    return true;
  }

  if(typeof obj1 !== typeof obj2) {
    return false;
  }

  if(typeof obj1 === 'string') {
    return obj1 === obj2;
  }

  var equal = obj1.tagClass === obj2.tagClass &&
    obj1.type === obj2.type &&
    obj1.constructed === obj2.constructed &&
    obj1.composed === obj2.composed &&
    asn1.equals(obj1.value, obj2.value);
  if(options && options.includeBitStringContents) {
    equal = equal && (obj1.bitStringContents === obj2.bitStringContents);
  }

  return equal;
};

/**
 * Gets the length of a BER-encoded ASN.1 value.
 *
 * In case the length is not specified, undefined is returned.
 *
 * @param b the BER-encoded ASN.1 byte buffer, starting with the first
 *          length byte.
 *
 * @return the length of the BER-encoded ASN.1 value or undefined.
 */
asn1.getBerValueLength = function(b) {
  // TODO: move this function and related DER/BER functions to a der.js
  // file; better abstract ASN.1 away from der/ber.
  var b2 = b.getByte();
  if(b2 === 0x80) {
    return undefined;
  }

  // see if the length is ""short form"" or ""long form"" (bit 8 set)
  var length;
  var longForm = b2 & 0x80;
  if(!longForm) {
    // length is just the first byte
    length = b2;
  } else {
    // the number of bytes the length is specified in bits 7 through 1
    // and each length byte is in big-endian base-256
    length = b.getInt((b2 & 0x7F) << 3);
  }
  return length;
};

/**
 * Check if the byte buffer has enough bytes. Throws an Error if not.
 *
 * @param bytes the byte buffer to parse from.
 * @param remaining the bytes remaining in the current parsing state.
 * @param n the number of bytes the buffer must have.
 */
function _checkBufferLength(bytes, remaining, n) {
  if(n > remaining) {
    var error = new Error('Too few bytes to parse DER.');
    error.available = bytes.length();
    error.remaining = remaining;
    error.requested = n;
    throw error;
  }
}

/**
 * Gets the length of a BER-encoded ASN.1 value.
 *
 * In case the length is not specified, undefined is returned.
 *
 * @param bytes the byte buffer to parse from.
 * @param remaining the bytes remaining in the current parsing state.
 *
 * @return the length of the BER-encoded ASN.1 value or undefined.
 */
var _getValueLength = function(bytes, remaining) {
  // TODO: move this function and related DER/BER functions to a der.js
  // file; better abstract ASN.1 away from der/ber.
  // fromDer already checked that this byte exists
  var b2 = bytes.getByte();
  remaining--;
  if(b2 === 0x80) {
    return undefined;
  }

  // see if the length is ""short form"" or ""long form"" (bit 8 set)
  var length;
  var longForm = b2 & 0x80;
  if(!longForm) {
    // length is just the first byte
    length = b2;
  } else {
    // the number of bytes the length is specified in bits 7 through 1
    // and each length byte is in big-endian base-256
    var longFormBytes = b2 & 0x7F;
    _checkBufferLength(bytes, remaining, longFormBytes);
    length = bytes.getInt(longFormBytes << 3);
  }
  // FIXME: this will only happen for 32 bit getInt with high bit set
  if(length < 0) {
    throw new Error('Negative length: ' + length);
  }
  return length;
};

/**
 * Parses an asn1 object from a byte buffer in DER format.
 *
 * @param bytes the byte buffer to parse from.
 * @param [strict] true to be strict when checking value lengths, false to
 *          allow truncated values (default: true).
 * @param [options] object with options or boolean strict flag
 *          [strict] true to be strict when checking value lengths, false to
 *            allow truncated values (default: true).
 *          [parseAllBytes] true to ensure all bytes are parsed
 *            (default: true)
 *          [decodeBitStrings] true to attempt to decode the content of
 *            BIT STRINGs (not OCTET STRINGs) using strict mode. Note that
 *            without schema support to understand the data context this can
 *            erroneously decode values that happen to be valid ASN.1. This
 *            flag will be deprecated or removed as soon as schema support is
 *            available. (default: true)
 *
 * @throws Will throw an error for various malformed input conditions.
 *
 * @return the parsed asn1 object.
 */
asn1.fromDer = function(bytes, options) {
  if(options === undefined) {
    options = {
      strict: true,
      parseAllBytes: true,
      decodeBitStrings: true
    };
  }
  if(typeof options === 'boolean') {
    options = {
      strict: options,
      parseAllBytes: true,
      decodeBitStrings: true
    };
  }
  if(!('strict' in options)) {
    options.strict = true;
  }
  if(!('parseAllBytes' in options)) {
    options.parseAllBytes = true;
  }
  if(!('decodeBitStrings' in options)) {
    options.decodeBitStrings = true;
  }
  if(!('maxDepth' in options)) {
    options.maxDepth = asn1.maxDepth;
  }

  // wrap in buffer if needed
  if(typeof bytes === 'string') {
    bytes = forge.util.createBuffer(bytes);
  }

  var byteCount = bytes.length();
  var value = _fromDer(bytes, bytes.length(), 0, options);
  if(options.parseAllBytes && bytes.length() !== 0) {
    var error = new Error('Unparsed DER bytes remain after ASN.1 parsing.');
    error.byteCount = byteCount;
    error.remaining = bytes.length();
    throw error;
  }
  return value;
};

/**
 * Internal function to parse an asn1 object from a byte buffer in DER format.
 *
 * @param bytes the byte buffer to parse from.
 * @param remaining the number of bytes remaining for this chunk.
 * @param depth the current parsing depth.
 * @param options object with same options as fromDer().
 *
 * @return the parsed asn1 object.
 */
function _fromDer(bytes, remaining, depth, options) {

  // check depth limit
  if(depth >= options.maxDepth) {
    throw new Error('ASN.1 parsing error: Max depth exceeded.');
  }

  // temporary storage for consumption calculations
  var start;

  // minimum length for ASN.1 DER structure is 2
  _checkBufferLength(bytes, remaining, 2);
",0
"  for(var i = 2; i < values.length; ++i) {
    // produce value bytes in reverse because we don't know how many
    // bytes it will take to store the value
    last = true;
    valueBytes = [];
    value = parseInt(values[i], 10);
    // TODO: Change bitwise logic to allow larger values.
    if(value > 0xffffffff) {
      throw new Error('OID value too large; max is 32-bits.');
    }
    do {
      b = value & 0x7F;
      value = value >>> 7;
      // if value is not last, then turn on 8th bit
      if(!last) {
        b |= 0x80;
      }
      valueBytes.push(b);
      last = false;
    } while(value > 0);

    // add value bytes in reverse (needs to be in big endian)
    for(var n = valueBytes.length - 1; n >= 0; --n) {
      bytes.putByte(valueBytes[n]);
    }
  }

  return bytes;
};

/**
 * Converts a DER-encoded byte buffer to an OID dot-separated string. The
 * byte buffer should contain only the DER-encoded value, not any tag or
 * length bytes.
 *
 * @param bytes the byte buffer.
 *
 * @return the OID dot-separated string.
 */
asn1.derToOid = function(bytes) {
  var oid;

  // wrap in buffer if needed
  if(typeof bytes === 'string') {
    bytes = forge.util.createBuffer(bytes);
  }

  // first byte is 40 * value1 + value2
  var b = bytes.getByte();
  oid = Math.floor(b / 40) + '.' + (b % 40);

  // other bytes are each value in base 128 with 8th bit set except for
  // the last byte for each value
  var value = 0;
  while(bytes.length() > 0) {
    // error if 7b shift would exceed Number.MAX_SAFE_INTEGER
    // (Number.MAX_SAFE_INTEGER / 128)
    if(value > 0x3fffffffffff) {
      throw new Error('OID value too large; max is 53-bits.');
    }
    b = bytes.getByte();
    value = value * 128;
    // not the last byte for the value
    if(b & 0x80) {
      value += b & 0x7F;
    } else {
      // last byte
      oid += '.' + (value + b);",0
"    // TODO: add more ASN.1 coverage

    it('should convert an OID to DER', function() {
      ASSERT.equal(ASN1.oidToDer('1.2.840.113549').toHex(), '2a864886f70d');
    });

    it('should convert a 32b OID to DER', function() {
      ASSERT.equal(ASN1.oidToDer('1.2.4294967295').toHex(), '2a8fffffff7f');
    });

    it('should not convert a >32b OID to DER', function() {
      ASSERT.throws(
        function() {
          ASN1.oidToDer('1.2.4294967296');
        },
        /OID value too large; max is 32-bits./
      );
    });

    it('should convert an OID from DER', function() {
      var der = UTIL.hexToBytes('2a864886f70d');
      ASSERT.equal(ASN1.derToOid(der), '1.2.840.113549');
    });

    it('should convert a 32b OID from DER', function() {
      var der = UTIL.hexToBytes('2a8fffffff7f');
      ASSERT.equal(ASN1.derToOid(der), '1.2.4294967295');
    });

    it('should convert a >32b OID from DER', function() {
      var der = UTIL.hexToBytes('2a9080808001');
      ASSERT.equal(ASN1.derToOid(der), '1.2.4294967297');
    });

    it('should convert a max safe int OID from DER', function() {
      var der = UTIL.hexToBytes('2a8fffffffffffff7f');
      ASSERT.equal(ASN1.derToOid(der), '1.2.9007199254740991');
    });

    it('should not convert a >max safe int OID from DER', function() {
      ASSERT.throws(
        function() {
          // '1.2.9007199254740992'
          var der = UTIL.hexToBytes('2a9080808080808000');
          console.log(ASN1.derToOid(der));
        },
        /OID value too large; max is 53-bits./
      );
    });

    it('should convert INTEGER 0 to DER', function() {
      ASSERT.equal(ASN1.integerToDer(0).toHex(), '00');
    });

    it('should convert INTEGER 1 to DER', function() {
      ASSERT.equal(ASN1.integerToDer(1).toHex(), '01');",0
"
@EnableDocumentation({
  isMasterAdminApiDocs: true,
})
@AllowAccessIfSubscriptionIsUnpaid()
@TableAccessControl({
  create: [],
  read: [Permission.CurrentUser],
  delete: [Permission.CurrentUser],
  update: [Permission.CurrentUser],
})
@CrudApiEndpoint(new Route(""/user""))
@SlugifyColumn(""name"", ""slug"")",0
"import { PromiseVoidFunction } from ""Common/Types/FunctionTypes"";
import Express, {
  ExpressApplication,
  ExpressRequest,
  ExpressResponse,
} from ""Common/Server/Utils/Express"";
import logger from ""Common/Server/Utils/Logger"";
import App from ""Common/Server/Utils/StartServer"";
import Response from ""Common/Server/Utils/Response"";
import UserMiddleware from ""Common/Server/Middleware/UserAuthorization"";
import JSONWebToken from ""Common/Server/Utils/JsonWebToken"";
import NotAuthorizedException from ""Common/Types/Exception/NotAuthorizedException"";
import { JSONObject } from ""Common/Types/JSON"";
import ""ejs"";

export const APP_NAME: string = ""admin"";

const app: ExpressApplication = Express.getExpressApp();

const ensureMasterAdminAccess = async (
  req: ExpressRequest,
  res: ExpressResponse,
): Promise<JSONObject> => {
  try {
    const accessToken: string | undefined =
      UserMiddleware.getAccessTokenFromExpressRequest(req);

    if (!accessToken) {
      Response.sendErrorResponse(
        req,
        res,
        new NotAuthorizedException(""Only master admins can access this app.""),
      );
      return {};
    }

    const authData = JSONWebToken.decode(accessToken);

    if (!authData.isMasterAdmin) {
      Response.sendErrorResponse(
        req,
        res,
        new NotAuthorizedException(""Only master admins can access this app.""),
      );
      return {};
    }

    return {};
  } catch (error) {
    logger.error(error);
    Response.sendErrorResponse(
      req,
      res,
      new NotAuthorizedException(""Only master admins can access this app.""),
    );
    return {};
  }
};

const init: PromiseVoidFunction = async (): Promise<void> => {
  try {
    // init the app
    await App.init({
      appName: APP_NAME,
      port: undefined,
      isFrontendApp: true,
      statusOptions: {
        liveCheck: async () => {},
        readyCheck: async () => {},
      },
      getVariablesToRenderIndexPage: ensureMasterAdminAccess,
    });

    // add default routes
    await App.addDefaultRoutes();
  } catch (err) {
    logger.error(""App Init Failed:"");",0
"            }
          }

          logger.debug(""Rendering index page with variables: "");
          logger.debug(variables);

          if (res.headersSent) {
            logger.debug(
              ""Response already sent while preparing index page. Skipping render."",
            );
            return;
          }

          return res.render(""/usr/src/app/views/index.ejs"", {
            enableGoogleTagManager: IsBillingEnabled || false,
            ...variables,
          });
        } catch (err) {
          return next(err);",0
"
/**
 * Count the number of parameters, stopping once limit reached
 *
 * @param {string} body
 * @param {number} limit
 * @return {number|undefined} Returns undefined if limit exceeded
 * @api private
 */
function parameterCount (body, limit) {
  let count = 0
  let index = -1
  do {
    count++
    if (count > limit) return undefined // Early exit if limit exceeded
    index = body.indexOf('&', index + 1)
  } while (index !== -1)
  return count
}",0
"  {
    name: '@sentry/node',
    path: 'packages/node/build/esm/index.js',
    import: createImport('init'),
    ignore: [...builtinModules, ...nodePrefixedBuiltinModules],
    gzip: true,
    limit: '154 KB',
  },
  {
    name: '@sentry/node - without tracing',
    path: 'packages/node/build/esm/index.js',
    import: createImport('initWithoutDefaultIntegrations', 'getDefaultIntegrationsWithoutPerformance'),
    gzip: true,",0
"            method: 'GET',
            'sentry.op': 'http.server',
            'sentry.origin': 'auto.http.astro',
            'sentry.sample_rate': 1,
            'sentry.source': 'route',
            url: expect.stringContaining('/test-ssr'),
            'http.request.header.accept': expect.any(String),
            'http.request.header.accept_encoding': 'gzip, deflate, br, zstd',
            'http.request.header.accept_language': 'en-US',
            'http.request.header.sec_fetch_mode': 'navigate',
            'http.request.header.user_agent': expect.any(String),
          },
          op: 'http.server',
          origin: 'auto.http.astro',
          status: 'ok',
          span_id: expect.stringMatching(/[a-f0-9]{16}/),
          trace_id: expect.stringMatching(/[a-f0-9]{32}/),
        },
      },
      environment: 'qa',
      event_id: expect.stringMatching(/[a-f0-9]{32}/),
      platform: 'node',
      request: {
        cookies: {},
        headers: expect.objectContaining({
          // demonstrates that request data integration can extract headers
          accept: expect.any(String),
          'accept-encoding': expect.any(String),
          'user-agent': expect.any(String),
        }),
        method: 'GET',
        url: expect.stringContaining('/test-ssr'),
      },
      sdk: {
        integrations: expect.any(Array),
        name: 'sentry.javascript.astro',
        packages: expect.any(Array),
        version: expect.any(String),
      },
      server_name: expect.any(String),
      spans: expect.any(Array),
      start_timestamp: expect.any(Number),
      timestamp: expect.any(Number),
      transaction: 'GET /test-ssr',
      transaction_info: { source: 'route' },
      type: 'transaction',
    });
  });
});

test.describe('nested SSR routes (client, server, server request)', () => {
  /** The user-page route fetches from an endpoint and creates a deeply nested span structure:
   * pageload — /user-page/myUsername123
   * ├── browser.** — multiple browser spans
   * └── browser.request — /user-page/myUsername123
   *     └── http.server — GET /user-page/[userId]                    (SSR page request)
   *         └── http.client — GET /api/user/myUsername123.json       (executing fetch call from SSR page - span)
   *             └── http.server — GET /api/user/myUsername123.json   (server request)
   */
  test('sends connected server and client pageload and request spans with the same trace id', async ({ page }) => {
    const clientPageloadTxnPromise = waitForTransaction('astro-4', txnEvent => {
      return txnEvent?.transaction?.startsWith('/user-page/') ?? false;
    });

    const serverPageRequestTxnPromise = waitForTransaction('astro-4', txnEvent => {
      return txnEvent?.transaction?.startsWith('GET /user-page/') ?? false;
    });

    const serverHTTPServerRequestTxnPromise = waitForTransaction('astro-4', txnEvent => {
      return txnEvent?.transaction?.startsWith('GET /api/user/') ?? false;
    });

    await page.goto('/user-page/myUsername123');

    const clientPageloadTxn = await clientPageloadTxnPromise;
    const serverPageRequestTxn = await serverPageRequestTxnPromise;
    const serverHTTPServerRequestTxn = await serverHTTPServerRequestTxnPromise;
    const serverRequestHTTPClientSpan = serverPageRequestTxn.spans?.find(
      span => span.op === 'http.client' && span.description?.includes('/api/user/'),
    );

    const clientPageloadTraceId = clientPageloadTxn.contexts?.trace?.trace_id;

    // Verify all spans have the same trace ID
    expect(clientPageloadTraceId).toEqual(serverPageRequestTxn.contexts?.trace?.trace_id);
    expect(clientPageloadTraceId).toEqual(serverHTTPServerRequestTxn.contexts?.trace?.trace_id);
    expect(clientPageloadTraceId).toEqual(serverRequestHTTPClientSpan?.trace_id);

    // serverPageRequest has no parent (root span)
    expect(serverPageRequestTxn.contexts?.trace?.parent_span_id).toBeUndefined();

    // clientPageload's parent and serverRequestHTTPClient's parent is serverPageRequest
    const serverPageRequestSpanId = serverPageRequestTxn.contexts?.trace?.span_id;
    expect(clientPageloadTxn.contexts?.trace?.parent_span_id).toEqual(serverPageRequestSpanId);
    expect(serverRequestHTTPClientSpan?.parent_span_id).toEqual(serverPageRequestSpanId);

    // serverHTTPServerRequest's parent is serverRequestHTTPClient
    expect(serverHTTPServerRequestTxn.contexts?.trace?.parent_span_id).toEqual(serverRequestHTTPClientSpan?.span_id);
  });

  test('sends parametrized pageload, server and API request transaction names', async ({ page }) => {
    const clientPageloadTxnPromise = waitForTransaction('astro-4', txnEvent => {
      return txnEvent?.transaction?.startsWith('/user-page/') ?? false;
    });

    const serverPageRequestTxnPromise = waitForTransaction('astro-4', txnEvent => {
      return txnEvent?.transaction?.startsWith('GET /user-page/') ?? false;
    });

    const serverHTTPServerRequestTxnPromise = waitForTransaction('astro-4', txnEvent => {
      return txnEvent?.transaction?.startsWith('GET /api/user/') ?? false;
    });

    await page.goto('/user-page/myUsername123');

    const clientPageloadTxn = await clientPageloadTxnPromise;
    const serverPageRequestTxn = await serverPageRequestTxnPromise;
    const serverHTTPServerRequestTxn = await serverHTTPServerRequestTxnPromise;

    const serverRequestHTTPClientSpan = serverPageRequestTxn.spans?.find(
      span => span.op === 'http.client' && span.description?.includes('/api/user/'),
    );

    const routeNameMetaContent = await page.locator('meta[name=""sentry-route-name""]').getAttribute('content');
    expect(routeNameMetaContent).toBe('%2Fuser-page%2F%5BuserId%5D');

    // Client pageload transaction - actual URL with pageload operation
    expect(clientPageloadTxn).toMatchObject({
      transaction: '/user-page/[userId]',
      transaction_info: { source: 'route' },
      contexts: {
        trace: {
          op: 'pageload',
          origin: 'auto.pageload.astro',
          data: {
            'sentry.op': 'pageload',
            'sentry.origin': 'auto.pageload.astro',
            'sentry.source': 'route',
          },
        },
      },
    });

    // Server page request transaction - parametrized transaction name with actual URL in data
    expect(serverPageRequestTxn).toMatchObject({
      transaction: 'GET /user-page/[userId]',
      transaction_info: { source: 'route' },
      contexts: {
        trace: {
          op: 'http.server',
          origin: 'auto.http.astro',
          data: {
            'sentry.op': 'http.server',
            'sentry.origin': 'auto.http.astro',
            'sentry.source': 'route',
            url: expect.stringContaining('/user-page/myUsername123'),
            'http.request.header.accept': expect.any(String),
            'http.request.header.accept_encoding': 'gzip, deflate, br, zstd',
            'http.request.header.accept_language': 'en-US',
            'http.request.header.sec_fetch_mode': 'navigate',
            'http.request.header.user_agent': expect.any(String),
          },
        },
      },
      request: { url: expect.stringContaining('/user-page/myUsername123') },
    });

    // HTTP client span - actual API URL with client operation
    expect(serverRequestHTTPClientSpan).toMatchObject({
      op: 'http.client',
      origin: 'auto.http.otel.node_fetch',
      description: 'GET http://localhost:3030/api/user/myUsername123.json', // http.client does not need to be parametrized
      data: {
        'sentry.op': 'http.client',
        'sentry.origin': 'auto.http.otel.node_fetch',
        'url.full': expect.stringContaining('/api/user/myUsername123.json'),
        'url.path': '/api/user/myUsername123.json',
        url: expect.stringContaining('/api/user/myUsername123.json'),
      },
    });

    // Server HTTP request transaction - should be parametrized
    expect(serverHTTPServerRequestTxn).toMatchObject({
      transaction: 'GET /api/user/myUsername123.json', // todo: parametrize
      transaction_info: { source: 'route' },
      contexts: {
        trace: {
          op: 'http.server',
          origin: 'auto.http.astro',
          data: {
            'sentry.op': 'http.server',
            'sentry.origin': 'auto.http.astro',
            'sentry.source': 'route',
            url: expect.stringContaining('/api/user/myUsername123.json'),
            'http.request.header.accept': expect.any(String),
            'http.request.header.accept_encoding': 'gzip, deflate',
            'http.request.header.accept_language': '*',
            'http.request.header.sec_fetch_mode': 'cors',
            'http.request.header.user_agent': expect.any(String),
          },
        },
      },
      request: { url: expect.stringContaining('/api/user/myUsername123.json') },
    });
  });

  test('sends parametrized pageload and server transaction names for catch-all routes', async ({ page }) => {
    const clientPageloadTxnPromise = waitForTransaction('astro-4', txnEvent => {
      return txnEvent?.transaction?.startsWith('/catchAll/') ?? false;
    });

    const serverPageRequestTxnPromise = waitForTransaction('astro-4', txnEvent => {
      return txnEvent?.transaction?.startsWith('GET /catchAll/') ?? false;
    });

    await page.goto('/catchAll/hell0/whatever-do');

    const routeNameMetaContent = await page.locator('meta[name=""sentry-route-name""]').getAttribute('content');
    expect(routeNameMetaContent).toBe('%2FcatchAll%2F%5Bpath%5D');

    const clientPageloadTxn = await clientPageloadTxnPromise;
    const serverPageRequestTxn = await serverPageRequestTxnPromise;

    expect(clientPageloadTxn).toMatchObject({
      transaction: '/catchAll/[path]',
      transaction_info: { source: 'route' },
      contexts: {
        trace: {
          op: 'pageload',
          origin: 'auto.pageload.astro',
          data: {
            'sentry.op': 'pageload',
            'sentry.origin': 'auto.pageload.astro',
            'sentry.source': 'route',
          },
        },
      },
    });

    expect(serverPageRequestTxn).toMatchObject({
      transaction: 'GET /catchAll/[path]',
      transaction_info: { source: 'route' },
      contexts: {
        trace: {
          op: 'http.server',
          origin: 'auto.http.astro',
          data: {
            'sentry.op': 'http.server',
            'sentry.origin': 'auto.http.astro',
            'sentry.source': 'route',
            url: expect.stringContaining('/catchAll/hell0/whatever-do'),
            'http.request.header.accept': expect.any(String),
            'http.request.header.accept_encoding': 'gzip, deflate, br, zstd',
            'http.request.header.accept_language': 'en-US',
            'http.request.header.sec_fetch_mode': 'navigate',
            'http.request.header.user_agent': expect.any(String),
          },
        },
      },
      request: { url: expect.stringContaining('/catchAll/hell0/whatever-do') },
    });
  });
});

// Case for `user-page/[id]` vs. `user-page/settings` static routes
test.describe('parametrized vs static paths', () => {
  test('should use static route name for static route in parametrized path', async ({ page }) => {
    const clientPageloadTxnPromise = waitForTransaction('astro-4', txnEvent => {
      return txnEvent?.transaction?.startsWith('/user-page/') ?? false;
    });

    const serverPageRequestTxnPromise = waitForTransaction('astro-4', txnEvent => {
      return txnEvent?.transaction?.startsWith('GET /user-page/') ?? false;
    });

    await page.goto('/user-page/settings');

    const clientPageloadTxn = await clientPageloadTxnPromise;
    const serverPageRequestTxn = await serverPageRequestTxnPromise;

    expect(clientPageloadTxn).toMatchObject({
      transaction: '/user-page/settings',
      transaction_info: { source: 'route' },
      contexts: {
        trace: {
          op: 'pageload',
          origin: 'auto.pageload.astro',
          data: {
            'sentry.op': 'pageload',
            'sentry.origin': 'auto.pageload.astro',
            'sentry.source': 'route',
          },
        },
      },
    });

    expect(serverPageRequestTxn).toMatchObject({
      transaction: 'GET /user-page/settings',
      transaction_info: { source: 'route' },
      contexts: {
        trace: {
          op: 'http.server',
          origin: 'auto.http.astro',
          data: {
            'sentry.op': 'http.server',
            'sentry.origin': 'auto.http.astro',
            'sentry.source': 'route',
            url: expect.stringContaining('/user-page/settings'),
            'http.request.header.accept': expect.any(String),
            'http.request.header.accept_encoding': 'gzip, deflate, br, zstd',
            'http.request.header.accept_language': 'en-US',
            'http.request.header.sec_fetch_mode': 'navigate',
            'http.request.header.user_agent': expect.any(String),
          },
        },
      },
      request: { url: expect.stringContaining('/user-page/settings') },
    });
  });",0
"            method: 'GET',
            'sentry.op': 'http.server',
            'sentry.origin': 'auto.http.astro',
            'sentry.sample_rate': 1,
            'sentry.source': 'route',
            url: expect.stringContaining('/test-ssr'),
            'http.request.header.accept': expect.any(String),
            'http.request.header.accept_encoding': 'gzip, deflate, br, zstd',
            'http.request.header.accept_language': 'en-US',
            'http.request.header.sec_fetch_mode': 'navigate',
            'http.request.header.user_agent': expect.any(String),
          },
          op: 'http.server',
          origin: 'auto.http.astro',
          status: 'ok',
          span_id: expect.stringMatching(/[a-f0-9]{16}/),
          trace_id: expect.stringMatching(/[a-f0-9]{32}/),
        },
      },
      environment: 'qa',
      event_id: expect.stringMatching(/[a-f0-9]{32}/),
      platform: 'node',
      request: {
        cookies: {},
        headers: expect.objectContaining({
          // demonstrates that request data integration can extract headers
          accept: expect.any(String),
          'accept-encoding': expect.any(String),
          'user-agent': expect.any(String),
        }),
        method: 'GET',
        url: expect.stringContaining('/test-ssr'),
      },
      sdk: {
        integrations: expect.any(Array),
        name: 'sentry.javascript.astro',
        packages: expect.any(Array),
        version: expect.any(String),
      },
      server_name: expect.any(String),
      spans: expect.any(Array),
      start_timestamp: expect.any(Number),
      timestamp: expect.any(Number),
      transaction: 'GET /test-ssr',
      transaction_info: {
        source: 'route',
      },
      type: 'transaction',
    });
  });
});

test.describe('nested SSR routes (client, server, server request)', () => {
  /** The user-page route fetches from an endpoint and creates a deeply nested span structure:
   * pageload — /user-page/myUsername123
   * ├── browser.** — multiple browser spans
   * └── browser.request — /user-page/myUsername123
   *     └── http.server — GET /user-page/[userId]                    (SSR page request)
   *         └── http.client — GET /api/user/myUsername123.json       (executing fetch call from SSR page - span)
   *             └── http.server — GET /api/user/myUsername123.json   (server request)
   */
  test('sends connected server and client pageload and request spans with the same trace id', async ({ page }) => {
    const clientPageloadTxnPromise = waitForTransaction('astro-5', txnEvent => {
      return txnEvent?.transaction?.startsWith('/user-page/') ?? false;
    });

    const serverPageRequestTxnPromise = waitForTransaction('astro-5', txnEvent => {
      return txnEvent?.transaction?.startsWith('GET /user-page/') ?? false;
    });

    const serverHTTPServerRequestTxnPromise = waitForTransaction('astro-5', txnEvent => {
      return txnEvent?.transaction?.startsWith('GET /api/user/') ?? false;
    });

    await page.goto('/user-page/myUsername123');

    const clientPageloadTxn = await clientPageloadTxnPromise;
    const serverPageRequestTxn = await serverPageRequestTxnPromise;
    const serverHTTPServerRequestTxn = await serverHTTPServerRequestTxnPromise;
    const serverRequestHTTPClientSpan = serverPageRequestTxn.spans?.find(
      span => span.op === 'http.client' && span.description?.includes('/api/user/'),
    );

    const clientPageloadTraceId = clientPageloadTxn.contexts?.trace?.trace_id;

    // Verify all spans have the same trace ID
    expect(clientPageloadTraceId).toEqual(serverPageRequestTxn.contexts?.trace?.trace_id);
    expect(clientPageloadTraceId).toEqual(serverHTTPServerRequestTxn.contexts?.trace?.trace_id);
    expect(clientPageloadTraceId).toEqual(serverRequestHTTPClientSpan?.trace_id);

    // serverPageRequest has no parent (root span)
    expect(serverPageRequestTxn.contexts?.trace?.parent_span_id).toBeUndefined();

    // clientPageload's parent and serverRequestHTTPClient's parent is serverPageRequest
    const serverPageRequestSpanId = serverPageRequestTxn.contexts?.trace?.span_id;
    expect(clientPageloadTxn.contexts?.trace?.parent_span_id).toEqual(serverPageRequestSpanId);
    expect(serverRequestHTTPClientSpan?.parent_span_id).toEqual(serverPageRequestSpanId);

    // serverHTTPServerRequest's parent is serverRequestHTTPClient
    expect(serverHTTPServerRequestTxn.contexts?.trace?.parent_span_id).toEqual(serverRequestHTTPClientSpan?.span_id);
  });

  test('sends parametrized pageload, server and API request transaction names', async ({ page }) => {
    const clientPageloadTxnPromise = waitForTransaction('astro-5', txnEvent => {
      return txnEvent?.transaction?.startsWith('/user-page/') ?? false;
    });

    const serverPageRequestTxnPromise = waitForTransaction('astro-5', txnEvent => {
      return txnEvent?.transaction?.startsWith('GET /user-page/') ?? false;
    });

    const serverHTTPServerRequestTxnPromise = waitForTransaction('astro-5', txnEvent => {
      return txnEvent?.transaction?.startsWith('GET /api/user/') ?? false;
    });

    await page.goto('/user-page/myUsername123');

    const clientPageloadTxn = await clientPageloadTxnPromise;
    const serverPageRequestTxn = await serverPageRequestTxnPromise;
    const serverHTTPServerRequestTxn = await serverHTTPServerRequestTxnPromise;

    const serverRequestHTTPClientSpan = serverPageRequestTxn.spans?.find(
      span => span.op === 'http.client' && span.description?.includes('/api/user/'),
    );

    const routeNameMetaContent = await page.locator('meta[name=""sentry-route-name""]').getAttribute('content');
    expect(routeNameMetaContent).toBe('%2Fuser-page%2F%5BuserId%5D');

    // Client pageload transaction - actual URL with pageload operation
    expect(clientPageloadTxn).toMatchObject({
      transaction: '/user-page/[userId]',
      transaction_info: { source: 'route' },
      contexts: {
        trace: {
          op: 'pageload',
          origin: 'auto.pageload.astro',
          data: {
            'sentry.op': 'pageload',
            'sentry.origin': 'auto.pageload.astro',
            'sentry.source': 'route',
          },
        },
      },
    });

    // Server page request transaction - parametrized transaction name with actual URL in data
    expect(serverPageRequestTxn).toMatchObject({
      transaction: 'GET /user-page/[userId]',
      transaction_info: { source: 'route' },
      contexts: {
        trace: {
          op: 'http.server',
          origin: 'auto.http.astro',
          data: {
            'sentry.op': 'http.server',
            'sentry.origin': 'auto.http.astro',
            'sentry.source': 'route',
            url: expect.stringContaining('/user-page/myUsername123'),
            'http.request.header.accept': expect.any(String),
            'http.request.header.accept_encoding': 'gzip, deflate, br, zstd',
            'http.request.header.accept_language': 'en-US',
            'http.request.header.sec_fetch_mode': 'navigate',
            'http.request.header.user_agent': expect.any(String),
          },
        },
      },
      request: { url: expect.stringContaining('/user-page/myUsername123') },
    });

    // HTTP client span - actual API URL with client operation
    expect(serverRequestHTTPClientSpan).toMatchObject({
      op: 'http.client',
      origin: 'auto.http.otel.node_fetch',
      description: 'GET http://localhost:3030/api/user/myUsername123.json', // http.client does not need to be parametrized
      data: {
        'sentry.op': 'http.client',
        'sentry.origin': 'auto.http.otel.node_fetch',
        'url.full': expect.stringContaining('/api/user/myUsername123.json'),
        'url.path': '/api/user/myUsername123.json',
        url: expect.stringContaining('/api/user/myUsername123.json'),
      },
    });

    // Server HTTP request transaction
    expect(serverHTTPServerRequestTxn).toMatchObject({
      transaction: 'GET /api/user/[userId].json',
      transaction_info: { source: 'route' },
      contexts: {
        trace: {
          op: 'http.server',
          origin: 'auto.http.astro',
          data: {
            'sentry.op': 'http.server',
            'sentry.origin': 'auto.http.astro',
            'sentry.source': 'route',
            url: expect.stringContaining('/api/user/myUsername123.json'),
            'http.request.header.accept': expect.any(String),
            'http.request.header.accept_encoding': 'gzip, deflate',
            'http.request.header.accept_language': '*',
            'http.request.header.sec_fetch_mode': 'cors',
            'http.request.header.user_agent': expect.any(String),
          },
        },
      },
      request: { url: expect.stringContaining('/api/user/myUsername123.json') },
    });
  });

  test('sends parametrized pageload and server transaction names for catch-all routes', async ({ page }) => {
    const clientPageloadTxnPromise = waitForTransaction('astro-5', txnEvent => {
      return txnEvent?.transaction?.startsWith('/catchAll/') ?? false;
    });

    const serverPageRequestTxnPromise = waitForTransaction('astro-5', txnEvent => {
      return txnEvent?.transaction?.startsWith('GET /catchAll/') ?? false;
    });

    await page.goto('/catchAll/hell0/whatever-do');

    const routeNameMetaContent = await page.locator('meta[name=""sentry-route-name""]').getAttribute('content');
    expect(routeNameMetaContent).toBe('%2FcatchAll%2F%5B...path%5D');

    const clientPageloadTxn = await clientPageloadTxnPromise;
    const serverPageRequestTxn = await serverPageRequestTxnPromise;

    expect(clientPageloadTxn).toMatchObject({
      transaction: '/catchAll/[...path]',
      transaction_info: { source: 'route' },
      contexts: {
        trace: {
          op: 'pageload',
          origin: 'auto.pageload.astro',
          data: {
            'sentry.op': 'pageload',
            'sentry.origin': 'auto.pageload.astro',
            'sentry.source': 'route',
          },
        },
      },
    });

    expect(serverPageRequestTxn).toMatchObject({
      transaction: 'GET /catchAll/[...path]',
      transaction_info: { source: 'route' },
      contexts: {
        trace: {
          op: 'http.server',
          origin: 'auto.http.astro',
          data: {
            'sentry.op': 'http.server',
            'sentry.origin': 'auto.http.astro',
            'sentry.source': 'route',
            url: expect.stringContaining('/catchAll/hell0/whatever-do'),
            'http.request.header.accept': expect.any(String),
            'http.request.header.accept_encoding': 'gzip, deflate, br, zstd',
            'http.request.header.accept_language': 'en-US',
            'http.request.header.sec_fetch_mode': 'navigate',
            'http.request.header.user_agent': expect.any(String),
          },
        },
      },
      request: { url: expect.stringContaining('/catchAll/hell0/whatever-do') },
    });
  });
});

// Case for `user-page/[id]` vs. `user-page/settings` static routes
test.describe('parametrized vs static paths', () => {
  test('should use static route name for static route in parametrized path', async ({ page }) => {
    const clientPageloadTxnPromise = waitForTransaction('astro-5', txnEvent => {
      return txnEvent?.transaction?.startsWith('/user-page/') ?? false;
    });

    const serverPageRequestTxnPromise = waitForTransaction('astro-5', txnEvent => {
      return txnEvent?.transaction?.startsWith('GET /user-page/') ?? false;
    });

    await page.goto('/user-page/settings');

    const clientPageloadTxn = await clientPageloadTxnPromise;
    const serverPageRequestTxn = await serverPageRequestTxnPromise;

    expect(clientPageloadTxn).toMatchObject({
      transaction: '/user-page/settings',
      transaction_info: { source: 'route' },
      contexts: {
        trace: {
          op: 'pageload',
          origin: 'auto.pageload.astro',
          data: {
            'sentry.op': 'pageload',
            'sentry.origin': 'auto.pageload.astro',
            'sentry.source': 'route',
          },
        },
      },
    });

    expect(serverPageRequestTxn).toMatchObject({
      transaction: 'GET /user-page/settings',
      transaction_info: { source: 'route' },
      contexts: {
        trace: {
          op: 'http.server',
          origin: 'auto.http.astro',
          data: {
            'sentry.op': 'http.server',
            'sentry.origin': 'auto.http.astro',
            'sentry.source': 'route',
            url: expect.stringContaining('/user-page/settings'),
            'http.request.header.accept': expect.any(String),
            'http.request.header.accept_encoding': 'gzip, deflate, br, zstd',
            'http.request.header.accept_language': 'en-US',
            'http.request.header.sec_fetch_mode': 'navigate',
            'http.request.header.user_agent': expect.any(String),
          },
        },
      },
      request: { url: expect.stringContaining('/user-page/settings') },
    });
  });",0
"      contexts: {
        trace: {
          data: expect.objectContaining({
            'sentry.op': 'http.server',
            'sentry.origin': 'auto.http.astro',
            'sentry.source': 'route',
            'http.request.header.accept': expect.any(String),
            'http.request.header.accept_encoding': 'gzip, deflate, br, zstd',
            'http.request.header.accept_language': 'en-US',
            'http.request.header.sec_fetch_mode': 'cors',
            'http.request.header.user_agent': expect.any(String),
          }),
          op: 'http.server',
          origin: 'auto.http.astro',
          span_id: expect.stringMatching(/[a-f0-9]{16}/),
          trace_id: expect.stringMatching(/[a-f0-9]{32}/),
        },",0
"      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-transaction',
      'http.request.header.accept': '*/*',
      'http.request.header.accept_encoding': 'gzip, deflate',
      'http.request.header.accept_language': '*',
      'http.request.header.connection': 'keep-alive',
      'http.request.header.host': expect.any(String),
      'http.request.header.sec_fetch_mode': 'cors',
      'http.request.header.user_agent': 'node',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: expect.stringMatching(/[a-f0-9]{32}/),
    origin: 'auto.http.otel.http',",0
"      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-transaction',
      'http.request.header.accept': '*/*',
      'http.request.header.accept_encoding': 'gzip, deflate',
      'http.request.header.accept_language': '*',
      'http.request.header.connection': 'keep-alive',
      'http.request.header.host': expect.any(String),
      'http.request.header.sec_fetch_mode': 'cors',
      'http.request.header.user_agent': 'node',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: expect.stringMatching(/[a-f0-9]{32}/),
    origin: 'auto.http.otel.http',",0
"      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-transaction',
      'http.request.header.accept': '*/*',
      'http.request.header.accept_encoding': 'gzip, deflate',
      'http.request.header.accept_language': '*',
      'http.request.header.connection': 'keep-alive',
      'http.request.header.host': expect.any(String),
      'http.request.header.sec_fetch_mode': 'cors',
      'http.request.header.user_agent': 'node',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: expect.stringMatching(/[a-f0-9]{32}/),
    origin: 'auto.http.otel.http',",0
"  const outgoingHttpSpan = outboundTransaction?.spans?.find(span => span.op === 'http.client');

  expect(outgoingHttpSpan).toBeDefined();

  const outgoingHttpSpanId = outgoingHttpSpan?.span_id;

  const outgoingHttpSpanData = outgoingHttpSpan?.data || {};
  // Outgoing span (`http.client`) does not include headers as attributes
  expect(Object.keys(outgoingHttpSpanData).some(key => key.startsWith('http.request.header.'))).toBe(false);

  expect(traceId).toEqual(expect.any(String));

  // data is passed through from the inbound request, to verify we have the correct headers set
  const inboundHeaderSentryTrace = data.headers?.['sentry-trace'];
  const inboundHeaderBaggage = data.headers?.['baggage'];

  expect(inboundHeaderSentryTrace).toEqual(`${traceId}-${outgoingHttpSpanId}-1`);
  expect(inboundHeaderBaggage).toBeDefined();

  const baggage = (inboundHeaderBaggage || '').split(',');
  expect(baggage).toEqual(
    expect.arrayContaining([
      'sentry-environment=qa',
      `sentry-trace_id=${traceId}`,
      expect.stringMatching(/sentry-public_key=/),
    ]),
  );

  expect(outboundTransaction.contexts?.trace).toEqual({
    data: {
      'sentry.source': 'route',
      'sentry.origin': 'auto.http.otel.http',
      'sentry.op': 'http.server',
      'sentry.sample_rate': 1,
      url: `http://localhost:3030/test-outgoing-http/${id}`,
      'otel.kind': 'SERVER',
      'http.response.status_code': 200,
      'http.url': `http://localhost:3030/test-outgoing-http/${id}`,
      'http.host': 'localhost:3030',
      'net.host.name': 'localhost',
      'http.method': 'GET',
      'http.scheme': 'http',
      'http.target': `/test-outgoing-http/${id}`,
      'http.user_agent': expect.any(String),
      'http.flavor': '1.1',
      'net.transport': 'ip_tcp',
      'net.host.ip': expect.any(String),
      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-outgoing-http/:id',
      'http.request.header.accept': '*/*',
      'http.request.header.accept_encoding': 'gzip, deflate',
      'http.request.header.accept_language': '*',
      'http.request.header.connection': 'keep-alive',
      'http.request.header.host': expect.any(String),
      'http.request.header.sec_fetch_mode': 'cors',
      'http.request.header.user_agent': 'node',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: traceId,
    origin: 'auto.http.otel.http',
  });

  expect(inboundTransaction.contexts?.trace).toEqual({
    data: {
      'sentry.source': 'route',
      'sentry.origin': 'auto.http.otel.http',
      'sentry.op': 'http.server',
      url: `http://localhost:3030/test-inbound-headers/${id}`,
      'otel.kind': 'SERVER',
      'http.response.status_code': 200,
      'http.url': `http://localhost:3030/test-inbound-headers/${id}`,
      'http.host': 'localhost:3030',
      'net.host.name': 'localhost',
      'http.method': 'GET',
      'http.scheme': 'http',
      'http.target': `/test-inbound-headers/${id}`,
      'http.flavor': '1.1',
      'net.transport': 'ip_tcp',
      'net.host.ip': expect.any(String),
      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-inbound-headers/:id',
      'http.request.header.baggage': expect.any(String),
      'http.request.header.connection': 'keep-alive',
      'http.request.header.host': expect.any(String),
      'http.request.header.sentry_trace': expect.stringMatching(/[a-f0-9]{32}-[a-f0-9]{16}-1/),
    },
    op: 'http.server',
    parent_span_id: outgoingHttpSpanId,
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: traceId,
    origin: 'auto.http.otel.http',
  });
});

test('Propagates trace for outgoing fetch requests', async ({ baseURL }) => {
  const id = crypto.randomUUID();

  const inboundTransactionPromise = waitForTransaction('nestjs-distributed-tracing', transactionEvent => {
    return (
      transactionEvent?.contexts?.trace?.op === 'http.server' &&
      transactionEvent.contexts?.trace?.data?.['http.target'] === `/test-inbound-headers/${id}`
    );
  });

  const outboundTransactionPromise = waitForTransaction('nestjs-distributed-tracing', transactionEvent => {
    return (
      transactionEvent?.contexts?.trace?.op === 'http.server' &&
      transactionEvent.contexts?.trace?.data?.['http.target'] === `/test-outgoing-fetch/${id}`
    );
  });

  const response = await fetch(`${baseURL}/test-outgoing-fetch/${id}`);
  const data = await response.json();

  const inboundTransaction = await inboundTransactionPromise;
  const outboundTransaction = await outboundTransactionPromise;

  const traceId = outboundTransaction?.contexts?.trace?.trace_id;
  const outgoingHttpSpan = outboundTransaction?.spans?.find(span => span.op === 'http.client');

  expect(outgoingHttpSpan).toBeDefined();

  const outgoingHttpSpanId = outgoingHttpSpan?.span_id;

  const outgoingHttpSpanData = outgoingHttpSpan?.data || {};
  // Outgoing span (`http.client`) does not include headers as attributes
  expect(Object.keys(outgoingHttpSpanData).some(key => key.startsWith('http.request.header.'))).toBe(false);

  expect(traceId).toEqual(expect.any(String));

  // data is passed through from the inbound request, to verify we have the correct headers set
  const inboundHeaderSentryTrace = data.headers?.['sentry-trace'];
  const inboundHeaderBaggage = data.headers?.['baggage'];

  expect(inboundHeaderSentryTrace).toEqual(`${traceId}-${outgoingHttpSpanId}-1`);
  expect(inboundHeaderBaggage).toBeDefined();

  const baggage = (inboundHeaderBaggage || '').split(',');
  expect(baggage).toEqual(
    expect.arrayContaining([
      'sentry-environment=qa',
      `sentry-trace_id=${traceId}`,
      expect.stringMatching(/sentry-public_key=/),
    ]),
  );

  expect(outboundTransaction.contexts?.trace).toEqual({
    data: {
      'sentry.source': 'route',
      'sentry.origin': 'auto.http.otel.http',
      'sentry.op': 'http.server',
      'sentry.sample_rate': 1,
      url: `http://localhost:3030/test-outgoing-fetch/${id}`,
      'otel.kind': 'SERVER',
      'http.response.status_code': 200,
      'http.url': `http://localhost:3030/test-outgoing-fetch/${id}`,
      'http.host': 'localhost:3030',
      'net.host.name': 'localhost',
      'http.method': 'GET',
      'http.scheme': 'http',
      'http.target': `/test-outgoing-fetch/${id}`,
      'http.user_agent': expect.any(String),
      'http.flavor': '1.1',
      'net.transport': 'ip_tcp',
      'net.host.ip': expect.any(String),
      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-outgoing-fetch/:id',
      'http.request.header.accept': '*/*',
      'http.request.header.accept_encoding': 'gzip, deflate',
      'http.request.header.accept_language': '*',
      'http.request.header.connection': 'keep-alive',
      'http.request.header.host': expect.any(String),
      'http.request.header.sec_fetch_mode': 'cors',
      'http.request.header.user_agent': 'node',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: traceId,
    origin: 'auto.http.otel.http',",0
"      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-transaction',
      'http.request.header.accept': '*/*',
      'http.request.header.accept_encoding': 'gzip, deflate',
      'http.request.header.accept_language': '*',
      'http.request.header.connection': 'keep-alive',
      'http.request.header.host': expect.any(String),
      'http.request.header.sec_fetch_mode': 'cors',
      'http.request.header.user_agent': 'node',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: expect.stringMatching(/[a-f0-9]{32}/),
    origin: 'auto.http.otel.http',",0
"      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/example-module/transaction',
      'http.request.header.accept': '*/*',
      'http.request.header.accept_encoding': 'gzip, deflate',
      'http.request.header.accept_language': '*',
      'http.request.header.connection': 'keep-alive',
      'http.request.header.host': expect.any(String),
      'http.request.header.sec_fetch_mode': 'cors',
      'http.request.header.user_agent': 'node',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: expect.stringMatching(/[a-f0-9]{32}/),
    origin: 'auto.http.otel.http',",0
"      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/example-module/transaction',
      'http.request.header.accept': '*/*',
      'http.request.header.accept_encoding': 'gzip, deflate',
      'http.request.header.accept_language': '*',
      'http.request.header.connection': 'keep-alive',
      'http.request.header.host': expect.any(String),
      'http.request.header.sec_fetch_mode': 'cors',
      'http.request.header.user_agent': 'node',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: expect.stringMatching(/[a-f0-9]{32}/),
    origin: 'auto.http.otel.http',",0
"/// <reference types=""next"" />
/// <reference types=""next/image-types/global"" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/basic-features/typescript for more information.",0
"  }

  if (testEnv === 'development') {
    return 'pnpm next dev -p 3030 2>&1 | tee .tmp_dev_server_logs';
  }

  if (testEnv === 'production' || testEnv === 'prod-turbopack') {
    return 'pnpm next start -p 3030';
  }

  throw new Error(`Unknown test env: ${testEnv}`);
};
",0
"
  const pageloadTraceId = pageloadTransaction.contexts?.trace?.trace_id;

  expect(pageloadTraceId).toBeTruthy();
  expect(serverTransaction.contexts?.trace?.trace_id).toBe(pageloadTraceId);
});

test('extracts HTTP request headers as span attributes', async ({ baseURL }) => {
  test.skip(
    process.env.TEST_ENV === 'prod-turbopack' || process.env.TEST_ENV === 'dev-turbopack',
    'Incoming fetch request headers are not added as span attributes when Turbopack is enabled (addHeadersAsAttributes)',
  );

  const serverTransactionPromise = waitForTransaction('nextjs-15', async transactionEvent => {
    return transactionEvent?.transaction === 'GET /pageload-tracing';
  });

  await fetch(`${baseURL}/pageload-tracing`, {
    headers: {
      'User-Agent': 'Custom-NextJS-Agent/15.0',
      'Content-Type': 'text/html',
      'X-NextJS-Test': 'nextjs-header-value',
      Accept: 'text/html, application/xhtml+xml',
      'X-Framework': 'Next.js',
      'X-Request-ID': 'nextjs-789',
    },
  });

  const serverTransaction = await serverTransactionPromise;

  expect(serverTransaction.contexts?.trace?.data).toEqual(
    expect.objectContaining({
      'http.request.header.user_agent': 'Custom-NextJS-Agent/15.0',
      'http.request.header.content_type': 'text/html',
      'http.request.header.x_nextjs_test': 'nextjs-header-value',
      'http.request.header.accept': 'text/html, application/xhtml+xml',
      'http.request.header.x_framework': 'Next.js',
      'http.request.header.x_request_id': 'nextjs-789',
    }),
  );
});",0
"      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-transaction',
      'http.request.header.accept': '*/*',
      'http.request.header.accept_encoding': 'gzip, deflate',
      'http.request.header.accept_language': '*',
      'http.request.header.connection': 'keep-alive',
      'http.request.header.host': expect.any(String),
      'http.request.header.sec_fetch_mode': 'cors',
      'http.request.header.user_agent': 'node',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: expect.stringMatching(/[a-f0-9]{32}/),
    origin: 'auto.http.otel.http',",0
"      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-transaction',
      'http.request.header.accept': '*/*',
      'http.request.header.accept_encoding': 'gzip, deflate',
      'http.request.header.accept_language': '*',
      'http.request.header.connection': 'keep-alive',
      'http.request.header.host': expect.any(String),
      'http.request.header.sec_fetch_mode': 'cors',
      'http.request.header.user_agent': 'node',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: expect.stringMatching(/[a-f0-9]{32}/),
    origin: 'auto.http.otel.http',",0
"      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-transaction',
      'http.request.header.accept': '*/*',
      'http.request.header.accept_encoding': 'gzip, deflate',
      'http.request.header.accept_language': '*',
      'http.request.header.connection': 'keep-alive',
      'http.request.header.host': expect.any(String),
      'http.request.header.sec_fetch_mode': 'cors',
      'http.request.header.user_agent': 'node',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: expect.stringMatching(/[a-f0-9]{32}/),
    origin: 'auto.http.otel.http',
  });

  expect(transactionEvent.contexts?.response).toEqual({
    status_code: 200,
  });

  expect(transactionEvent).toEqual(
    expect.objectContaining({
      transaction: 'GET /test-transaction',
      type: 'transaction',
      transaction_info: {
        source: 'route',
      },
    }),
  );

  const spans = transactionEvent.spans || [];

  // Manually started span
  expect(spans).toContainEqual({
    data: { 'sentry.origin': 'manual' },
    description: 'test-span',
    origin: 'manual',
    parent_span_id: expect.stringMatching(/[a-f0-9]{16}/),
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    start_timestamp: expect.any(Number),
    status: 'ok',
    timestamp: expect.any(Number),
    trace_id: expect.stringMatching(/[a-f0-9]{32}/),
  });

  // auto instrumented spans
  expect(spans).toContainEqual({
    data: {
      'sentry.origin': 'auto.http.otel.express',
      'sentry.op': 'middleware.express',
      'express.name': 'query',
      'express.type': 'middleware',
    },
    description: 'query',
    op: 'middleware.express',
    origin: 'auto.http.otel.express',
    parent_span_id: expect.stringMatching(/[a-f0-9]{16}/),
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    start_timestamp: expect.any(Number),
    status: 'ok',
    timestamp: expect.any(Number),
    trace_id: expect.stringMatching(/[a-f0-9]{32}/),
  });

  expect(spans).toContainEqual({
    data: {
      'sentry.origin': 'auto.http.otel.express',
      'sentry.op': 'middleware.express',
      'express.name': 'expressInit',
      'express.type': 'middleware',
    },
    description: 'expressInit',
    op: 'middleware.express',
    origin: 'auto.http.otel.express',
    parent_span_id: expect.stringMatching(/[a-f0-9]{16}/),
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    start_timestamp: expect.any(Number),
    status: 'ok',
    timestamp: expect.any(Number),
    trace_id: expect.stringMatching(/[a-f0-9]{32}/),
  });

  expect(spans).toContainEqual({
    data: {
      'sentry.origin': 'auto.http.otel.express',
      'sentry.op': 'request_handler.express',
      'http.route': '/test-transaction',
      'express.name': '/test-transaction',
      'express.type': 'request_handler',
    },
    description: '/test-transaction',
    op: 'request_handler.express',
    origin: 'auto.http.otel.express',
    parent_span_id: expect.stringMatching(/[a-f0-9]{16}/),
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    start_timestamp: expect.any(Number),
    status: 'ok',
    timestamp: expect.any(Number),
    trace_id: expect.stringMatching(/[a-f0-9]{32}/),
  });
});

test('Sends an API route transaction for an errored route', async ({ baseURL }) => {
  const transactionEventPromise = waitForTransaction('node-express', transactionEvent => {
    return (
      transactionEvent.contexts?.trace?.op === 'http.server' &&
      transactionEvent.transaction === 'GET /test-exception/:id' &&
      transactionEvent.request?.url === 'http://localhost:3030/test-exception/777'
    );
  });

  await fetch(`${baseURL}/test-exception/777`);

  const transactionEvent = await transactionEventPromise;

  expect(transactionEvent.contexts?.trace?.op).toEqual('http.server');
  expect(transactionEvent.transaction).toEqual('GET /test-exception/:id');
  expect(transactionEvent.contexts?.trace?.status).toEqual('internal_error');
  expect(transactionEvent.contexts?.trace?.data?.['http.status_code']).toEqual(500);

  const spans = transactionEvent.spans || [];

  expect(spans).toContainEqual({
    data: {
      'sentry.origin': 'auto.http.otel.express',
      'sentry.op': 'middleware.express',
      'express.name': 'query',
      'express.type': 'middleware',
    },
    description: 'query',
    op: 'middleware.express',
    origin: 'auto.http.otel.express',
    parent_span_id: expect.stringMatching(/[a-f0-9]{16}/),
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    start_timestamp: expect.any(Number),
    status: 'ok',
    timestamp: expect.any(Number),
    trace_id: expect.stringMatching(/[a-f0-9]{32}/),
  });

  expect(spans).toContainEqual({
    data: {
      'sentry.origin': 'auto.http.otel.express',
      'sentry.op': 'middleware.express',
      'express.name': 'expressInit',
      'express.type': 'middleware',
    },
    description: 'expressInit',
    op: 'middleware.express',
    origin: 'auto.http.otel.express',
    parent_span_id: expect.stringMatching(/[a-f0-9]{16}/),
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    start_timestamp: expect.any(Number),
    status: 'ok',
    timestamp: expect.any(Number),
    trace_id: expect.stringMatching(/[a-f0-9]{32}/),
  });

  expect(spans).toContainEqual({
    data: {
      'sentry.origin': 'auto.http.otel.express',
      'sentry.op': 'request_handler.express',
      'http.route': '/test-exception/:id',
      'express.name': '/test-exception/:id',
      'express.type': 'request_handler',
    },
    description: '/test-exception/:id',
    op: 'request_handler.express',
    origin: 'auto.http.otel.express',
    parent_span_id: expect.stringMatching(/[a-f0-9]{16}/),
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    start_timestamp: expect.any(Number),
    status: 'unknown_error',
    timestamp: expect.any(Number),
    trace_id: expect.stringMatching(/[a-f0-9]{32}/),
    measurements: {},
  });
});

test('Extracts HTTP request headers as span attributes', async ({ baseURL }) => {
  const transactionEventPromise = waitForTransaction('node-express', transactionEvent => {
    return (
      transactionEvent?.contexts?.trace?.op === 'http.server' &&
      transactionEvent?.transaction === 'GET /test-transaction'
    );
  });

  await fetch(`${baseURL}/test-transaction`, {
    headers: {
      'User-Agent': 'Custom-Agent/1.0 (Test)',
      'Content-Type': 'application/json',
      'X-Custom-Header': 'test-value',
      Accept: 'application/json, text/plain',
      'X-Request-ID': 'req-123',
    },
  });

  const transactionEvent = await transactionEventPromise;

  expect(transactionEvent.contexts?.trace?.data).toEqual(
    expect.objectContaining({
      'http.request.header.user_agent': 'Custom-Agent/1.0 (Test)',
      'http.request.header.content_type': 'application/json',
      'http.request.header.x_custom_header': 'test-value',
      'http.request.header.accept': 'application/json, text/plain',
      'http.request.header.x_request_id': 'req-123',
    }),
  );
});",0
"  const outgoingHttpSpan = outboundTransaction?.spans?.find(span => span.op === 'http.client');

  expect(outgoingHttpSpan).toBeDefined();

  const outgoingHttpSpanId = outgoingHttpSpan?.span_id;

  const outgoingHttpSpanData = outgoingHttpSpan?.data || {};
  // Outgoing span (`http.client`) does not include headers as attributes
  expect(Object.keys(outgoingHttpSpanData).some(key => key.startsWith('http.request.header.'))).toBe(false);

  expect(traceId).toEqual(expect.any(String));

  // data is passed through from the inbound request, to verify we have the correct headers set
  const inboundHeaderSentryTrace = data.headers?.['sentry-trace'];
  const inboundHeaderBaggage = data.headers?.['baggage'];

  expect(inboundHeaderSentryTrace).toEqual(`${traceId}-${outgoingHttpSpanId}-1`);
  expect(inboundHeaderBaggage).toBeDefined();

  const baggage = (inboundHeaderBaggage || '').split(',');
  expect(baggage).toEqual(
    expect.arrayContaining([
      'sentry-environment=qa',
      `sentry-trace_id=${traceId}`,
      expect.stringMatching(/sentry-public_key=/),
    ]),
  );

  expect(outboundTransaction.contexts?.trace).toEqual({
    data: {
      'sentry.source': 'route',
      'sentry.origin': 'auto.http.otel.http',
      'sentry.op': 'http.server',
      'sentry.sample_rate': 1,
      url: `http://localhost:3030/test-outgoing-http/${id}`,
      'otel.kind': 'SERVER',
      'http.response.status_code': 200,
      'http.url': `http://localhost:3030/test-outgoing-http/${id}`,
      'http.host': 'localhost:3030',
      'net.host.name': 'localhost',
      'http.method': 'GET',
      'http.scheme': 'http',
      'http.target': `/test-outgoing-http/${id}`,
      'http.user_agent': 'node',
      'http.flavor': '1.1',
      'net.transport': 'ip_tcp',
      'net.host.ip': expect.any(String),
      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-outgoing-http/:id',
      'http.request.header.accept': '*/*',
      'http.request.header.accept_encoding': 'gzip, deflate',
      'http.request.header.accept_language': '*',
      'http.request.header.connection': 'keep-alive',
      'http.request.header.host': expect.any(String),
      'http.request.header.sec_fetch_mode': 'cors',
      'http.request.header.user_agent': 'node',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: traceId,
    origin: 'auto.http.otel.http',
  });

  expect(inboundTransaction.contexts?.trace).toEqual({
    data: {
      'sentry.source': 'route',
      'sentry.origin': 'auto.http.otel.http',
      'sentry.op': 'http.server',
      url: `http://localhost:3030/test-inbound-headers/${id}`,
      'otel.kind': 'SERVER',
      'http.response.status_code': 200,
      'http.url': `http://localhost:3030/test-inbound-headers/${id}`,
      'http.host': 'localhost:3030',
      'net.host.name': 'localhost',
      'http.method': 'GET',
      'http.scheme': 'http',
      'http.target': `/test-inbound-headers/${id}`,
      'http.flavor': '1.1',
      'net.transport': 'ip_tcp',
      'net.host.ip': expect.any(String),
      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-inbound-headers/:id',
      'http.request.header.baggage': expect.any(String),
      'http.request.header.connection': 'keep-alive',
      'http.request.header.host': expect.any(String),
      'http.request.header.sentry_trace': expect.stringMatching(/[a-f0-9]{32}-[a-f0-9]{16}-1/),
    },
    op: 'http.server',
    parent_span_id: outgoingHttpSpanId,
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: traceId,
    origin: 'auto.http.otel.http',
  });
});

test('Propagates trace for outgoing fetch requests', async ({ baseURL }) => {
  const id = crypto.randomUUID();

  const inboundTransactionPromise = waitForTransaction('node-fastify-3', transactionEvent => {
    return (
      transactionEvent?.contexts?.trace?.op === 'http.server' &&
      transactionEvent.contexts?.trace?.data?.['http.target'] === `/test-inbound-headers/${id}`
    );
  });

  const outboundTransactionPromise = waitForTransaction('node-fastify-3', transactionEvent => {
    return (
      transactionEvent?.contexts?.trace?.op === 'http.server' &&
      transactionEvent.contexts?.trace?.data?.['http.target'] === `/test-outgoing-fetch/${id}`
    );
  });

  const response = await fetch(`${baseURL}/test-outgoing-fetch/${id}`);
  const data = await response.json();

  const inboundTransaction = await inboundTransactionPromise;
  const outboundTransaction = await outboundTransactionPromise;

  const traceId = outboundTransaction?.contexts?.trace?.trace_id;
  const outgoingHttpSpan = outboundTransaction?.spans?.find(span => span.op === 'http.client');

  expect(outgoingHttpSpan).toBeDefined();

  const outgoingHttpSpanId = outgoingHttpSpan?.span_id;

  const outgoingHttpSpanData = outgoingHttpSpan?.data || {};
  // Outgoing span (`http.client`) does not include headers as attributes
  expect(Object.keys(outgoingHttpSpanData).some(key => key.startsWith('http.request.header.'))).toBe(false);

  expect(traceId).toEqual(expect.any(String));

  // data is passed through from the inbound request, to verify we have the correct headers set
  const inboundHeaderSentryTrace = data.headers?.['sentry-trace'];
  const inboundHeaderBaggage = data.headers?.['baggage'];

  expect(inboundHeaderSentryTrace).toEqual(`${traceId}-${outgoingHttpSpanId}-1`);
  expect(inboundHeaderBaggage).toBeDefined();

  const baggage = (inboundHeaderBaggage || '').split(',');
  expect(baggage).toEqual(
    expect.arrayContaining([
      'sentry-environment=qa',
      `sentry-trace_id=${traceId}`,
      expect.stringMatching(/sentry-public_key=/),
    ]),
  );

  expect(outboundTransaction.contexts?.trace).toEqual({
    data: {
      'sentry.source': 'route',
      'sentry.origin': 'auto.http.otel.http',
      'sentry.op': 'http.server',
      'sentry.sample_rate': 1,
      url: `http://localhost:3030/test-outgoing-fetch/${id}`,
      'otel.kind': 'SERVER',
      'http.response.status_code': 200,
      'http.url': `http://localhost:3030/test-outgoing-fetch/${id}`,
      'http.host': 'localhost:3030',
      'net.host.name': 'localhost',
      'http.method': 'GET',
      'http.scheme': 'http',
      'http.target': `/test-outgoing-fetch/${id}`,
      'http.user_agent': 'node',
      'http.flavor': '1.1',
      'net.transport': 'ip_tcp',
      'net.host.ip': expect.any(String),
      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-outgoing-fetch/:id',
      'http.request.header.accept': '*/*',
      'http.request.header.accept_encoding': 'gzip, deflate',
      'http.request.header.accept_language': '*',
      'http.request.header.connection': 'keep-alive',
      'http.request.header.host': expect.any(String),
      'http.request.header.sec_fetch_mode': 'cors',
      'http.request.header.user_agent': 'node',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: traceId,
    origin: 'auto.http.otel.http',
  });

  expect(inboundTransaction.contexts?.trace).toEqual({
    data: {
      'sentry.source': 'route',
      'sentry.origin': 'auto.http.otel.http',
      'sentry.op': 'http.server',
      url: `http://localhost:3030/test-inbound-headers/${id}`,
      'otel.kind': 'SERVER',
      'http.response.status_code': 200,
      'http.url': `http://localhost:3030/test-inbound-headers/${id}`,
      'http.host': 'localhost:3030',
      'net.host.name': 'localhost',
      'http.method': 'GET',
      'http.scheme': 'http',
      'http.target': `/test-inbound-headers/${id}`,
      'http.flavor': '1.1',
      'net.transport': 'ip_tcp',
      'net.host.ip': expect.any(String),
      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.user_agent': 'node',
      'http.route': '/test-inbound-headers/:id',
      'http.request.header.accept': '*/*',
      'http.request.header.accept_encoding': 'gzip, deflate',
      'http.request.header.accept_language': '*',
      'http.request.header.baggage': expect.any(String),
      'http.request.header.connection': 'keep-alive',
      'http.request.header.host': expect.any(String),
      'http.request.header.sec_fetch_mode': 'cors',
      'http.request.header.sentry_trace': expect.stringMatching(/[a-f0-9]{32}-[a-f0-9]{16}-1/),
      'http.request.header.user_agent': 'node',
    },
    op: 'http.server',
    parent_span_id: outgoingHttpSpanId,
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: traceId,
    origin: 'auto.http.otel.http',",0
"      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-transaction',
      'http.request.header.accept': '*/*',
      'http.request.header.accept_encoding': 'gzip, deflate',
      'http.request.header.accept_language': '*',
      'http.request.header.connection': 'keep-alive',
      'http.request.header.host': expect.any(String),
      'http.request.header.sec_fetch_mode': 'cors',
      'http.request.header.user_agent': 'node',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: expect.stringMatching(/[a-f0-9]{32}/),
    origin: 'auto.http.otel.http',",0
"  const outgoingHttpSpan = outboundTransaction?.spans?.find(span => span.op === 'http.client');

  expect(outgoingHttpSpan).toBeDefined();

  const outgoingHttpSpanId = outgoingHttpSpan?.span_id;

  const outgoingHttpSpanData = outgoingHttpSpan?.data || {};
  // Outgoing span (`http.client`) does not include headers as attributes
  expect(Object.keys(outgoingHttpSpanData).some(key => key.startsWith('http.request.header.'))).toBe(false);

  expect(traceId).toEqual(expect.any(String));

  // data is passed through from the inbound request, to verify we have the correct headers set
  const inboundHeaderSentryTrace = data.headers?.['sentry-trace'];
  const inboundHeaderBaggage = data.headers?.['baggage'];

  expect(inboundHeaderSentryTrace).toEqual(`${traceId}-${outgoingHttpSpanId}-1`);
  expect(inboundHeaderBaggage).toBeDefined();

  const baggage = (inboundHeaderBaggage || '').split(',');
  expect(baggage).toEqual(
    expect.arrayContaining([
      'sentry-environment=qa',
      `sentry-trace_id=${traceId}`,
      expect.stringMatching(/sentry-public_key=/),
    ]),
  );

  expect(outboundTransaction.contexts?.trace).toEqual({
    data: {
      'sentry.source': 'route',
      'sentry.origin': 'auto.http.otel.http',
      'sentry.op': 'http.server',
      'sentry.sample_rate': 1,
      url: `http://localhost:3030/test-outgoing-http/${id}`,
      'otel.kind': 'SERVER',
      'http.response.status_code': 200,
      'http.url': `http://localhost:3030/test-outgoing-http/${id}`,
      'http.host': 'localhost:3030',
      'net.host.name': 'localhost',
      'http.method': 'GET',
      'http.scheme': 'http',
      'http.target': `/test-outgoing-http/${id}`,
      'http.user_agent': 'node',
      'http.flavor': '1.1',
      'net.transport': 'ip_tcp',
      'net.host.ip': expect.any(String),
      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-outgoing-http/:id',
      'http.request.header.accept': '*/*',
      'http.request.header.accept_encoding': 'gzip, deflate',
      'http.request.header.accept_language': '*',
      'http.request.header.connection': 'keep-alive',
      'http.request.header.host': expect.any(String),
      'http.request.header.sec_fetch_mode': 'cors',
      'http.request.header.user_agent': 'node',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: traceId,
    origin: 'auto.http.otel.http',
  });

  expect(inboundTransaction.contexts?.trace).toEqual({
    data: {
      'sentry.source': 'route',
      'sentry.origin': 'auto.http.otel.http',
      'sentry.op': 'http.server',
      url: `http://localhost:3030/test-inbound-headers/${id}`,
      'otel.kind': 'SERVER',
      'http.response.status_code': 200,
      'http.url': `http://localhost:3030/test-inbound-headers/${id}`,
      'http.host': 'localhost:3030',
      'net.host.name': 'localhost',
      'http.method': 'GET',
      'http.scheme': 'http',
      'http.target': `/test-inbound-headers/${id}`,
      'http.flavor': '1.1',
      'net.transport': 'ip_tcp',
      'net.host.ip': expect.any(String),
      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-inbound-headers/:id',
      'http.request.header.baggage': expect.any(String),
      'http.request.header.connection': 'keep-alive',
      'http.request.header.host': expect.any(String),
      'http.request.header.sentry_trace': expect.stringMatching(/[a-f0-9]{32}-[a-f0-9]{16}-1/),
    },
    op: 'http.server',
    parent_span_id: outgoingHttpSpanId,
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: traceId,
    origin: 'auto.http.otel.http',
  });
});

test('Propagates trace for outgoing fetch requests', async ({ baseURL }) => {
  const id = crypto.randomUUID();

  const inboundTransactionPromise = waitForTransaction('node-fastify-4', transactionEvent => {
    return (
      transactionEvent?.contexts?.trace?.op === 'http.server' &&
      transactionEvent.contexts?.trace?.data?.['http.target'] === `/test-inbound-headers/${id}`
    );
  });

  const outboundTransactionPromise = waitForTransaction('node-fastify-4', transactionEvent => {
    return (
      transactionEvent?.contexts?.trace?.op === 'http.server' &&
      transactionEvent.contexts?.trace?.data?.['http.target'] === `/test-outgoing-fetch/${id}`
    );
  });

  const response = await fetch(`${baseURL}/test-outgoing-fetch/${id}`);
  const data = await response.json();

  const inboundTransaction = await inboundTransactionPromise;
  const outboundTransaction = await outboundTransactionPromise;

  const traceId = outboundTransaction?.contexts?.trace?.trace_id;
  const outgoingHttpSpan = outboundTransaction?.spans?.find(span => span.op === 'http.client');

  expect(outgoingHttpSpan).toBeDefined();

  const outgoingHttpSpanId = outgoingHttpSpan?.span_id;

  const outgoingHttpSpanData = outgoingHttpSpan?.data || {};
  // Outgoing span (`http.client`) does not include headers as attributes
  expect(Object.keys(outgoingHttpSpanData).some(key => key.startsWith('http.request.header.'))).toBe(false);

  expect(traceId).toEqual(expect.any(String));

  // data is passed through from the inbound request, to verify we have the correct headers set
  const inboundHeaderSentryTrace = data.headers?.['sentry-trace'];
  const inboundHeaderBaggage = data.headers?.['baggage'];

  expect(inboundHeaderSentryTrace).toEqual(`${traceId}-${outgoingHttpSpanId}-1`);
  expect(inboundHeaderBaggage).toBeDefined();

  const baggage = (inboundHeaderBaggage || '').split(',');
  expect(baggage).toEqual(
    expect.arrayContaining([
      'sentry-environment=qa',
      `sentry-trace_id=${traceId}`,
      expect.stringMatching(/sentry-public_key=/),
    ]),
  );

  expect(outboundTransaction.contexts?.trace).toEqual({
    data: {
      'sentry.source': 'route',
      'sentry.origin': 'auto.http.otel.http',
      'sentry.op': 'http.server',
      'sentry.sample_rate': 1,
      url: `http://localhost:3030/test-outgoing-fetch/${id}`,
      'otel.kind': 'SERVER',
      'http.response.status_code': 200,
      'http.url': `http://localhost:3030/test-outgoing-fetch/${id}`,
      'http.host': 'localhost:3030',
      'net.host.name': 'localhost',
      'http.method': 'GET',
      'http.scheme': 'http',
      'http.target': `/test-outgoing-fetch/${id}`,
      'http.user_agent': 'node',
      'http.flavor': '1.1',
      'net.transport': 'ip_tcp',
      'net.host.ip': expect.any(String),
      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-outgoing-fetch/:id',
      'http.request.header.accept': '*/*',
      'http.request.header.accept_encoding': 'gzip, deflate',
      'http.request.header.accept_language': '*',
      'http.request.header.connection': 'keep-alive',
      'http.request.header.host': expect.any(String),
      'http.request.header.sec_fetch_mode': 'cors',
      'http.request.header.user_agent': 'node',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: traceId,
    origin: 'auto.http.otel.http',
  });

  expect(inboundTransaction.contexts?.trace).toEqual({
    data: {
      'sentry.source': 'route',
      'sentry.origin': 'auto.http.otel.http',
      'sentry.op': 'http.server',
      url: `http://localhost:3030/test-inbound-headers/${id}`,
      'otel.kind': 'SERVER',
      'http.response.status_code': 200,
      'http.url': `http://localhost:3030/test-inbound-headers/${id}`,
      'http.host': 'localhost:3030',
      'net.host.name': 'localhost',
      'http.method': 'GET',
      'http.scheme': 'http',
      'http.target': `/test-inbound-headers/${id}`,
      'http.flavor': '1.1',
      'net.transport': 'ip_tcp',
      'net.host.ip': expect.any(String),
      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-inbound-headers/:id',
      'http.user_agent': 'node',
      'http.request.header.accept': '*/*',
      'http.request.header.accept_encoding': 'gzip, deflate',
      'http.request.header.accept_language': '*',
      'http.request.header.baggage': expect.any(String),
      'http.request.header.connection': 'keep-alive',
      'http.request.header.host': expect.any(String),
      'http.request.header.sec_fetch_mode': 'cors',
      'http.request.header.sentry_trace': expect.stringMatching(/[a-f0-9]{32}-[a-f0-9]{16}-1/),
      'http.request.header.user_agent': 'node',
    },
    op: 'http.server',
    parent_span_id: outgoingHttpSpanId,
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: traceId,
    origin: 'auto.http.otel.http',",0
"      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-transaction',
      'http.request.header.accept': '*/*',
      'http.request.header.accept_encoding': 'gzip, deflate',
      'http.request.header.accept_language': '*',
      'http.request.header.connection': 'keep-alive',
      'http.request.header.host': expect.any(String),
      'http.request.header.sec_fetch_mode': 'cors',
      'http.request.header.user_agent': 'node',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: expect.stringMatching(/[a-f0-9]{32}/),
    origin: 'auto.http.otel.http',",0
"  const outgoingHttpSpan = outboundTransaction?.spans?.find(span => span.op === 'http.client');

  expect(outgoingHttpSpan).toBeDefined();

  const outgoingHttpSpanId = outgoingHttpSpan?.span_id;

  const outgoingHttpSpanData = outgoingHttpSpan?.data || {};
  // Outgoing span (`http.client`) does not include headers as attributes
  expect(Object.keys(outgoingHttpSpanData).some(key => key.startsWith('http.request.header.'))).toBe(false);

  expect(traceId).toEqual(expect.any(String));

  // data is passed through from the inbound request, to verify we have the correct headers set
  const inboundHeaderSentryTrace = data.headers?.['sentry-trace'];
  const inboundHeaderBaggage = data.headers?.['baggage'];

  expect(inboundHeaderSentryTrace).toEqual(`${traceId}-${outgoingHttpSpanId}-1`);
  expect(inboundHeaderBaggage).toBeDefined();

  const baggage = (inboundHeaderBaggage || '').split(',');
  expect(baggage).toEqual(
    expect.arrayContaining([
      'sentry-environment=qa',
      `sentry-trace_id=${traceId}`,
      expect.stringMatching(/sentry-public_key=/),
    ]),
  );

  expect(outboundTransaction.contexts?.trace).toEqual({
    data: {
      'sentry.source': 'route',
      'sentry.origin': 'auto.http.otel.http',
      'sentry.op': 'http.server',
      'sentry.sample_rate': 1,
      url: `http://localhost:3030/test-outgoing-http/${id}`,
      'otel.kind': 'SERVER',
      'http.response.status_code': 200,
      'http.url': `http://localhost:3030/test-outgoing-http/${id}`,
      'http.host': 'localhost:3030',
      'net.host.name': 'localhost',
      'http.method': 'GET',
      'http.scheme': 'http',
      'http.target': `/test-outgoing-http/${id}`,
      'http.user_agent': 'node',
      'http.flavor': '1.1',
      'net.transport': 'ip_tcp',
      'net.host.ip': expect.any(String),
      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-outgoing-http/:id',
      'http.request.header.accept': '*/*',
      'http.request.header.accept_encoding': 'gzip, deflate',
      'http.request.header.accept_language': '*',
      'http.request.header.connection': 'keep-alive',
      'http.request.header.host': 'localhost:3030',
      'http.request.header.sec_fetch_mode': 'cors',
      'http.request.header.user_agent': 'node',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: traceId,
    origin: 'auto.http.otel.http',
  });

  expect(inboundTransaction.contexts?.trace).toEqual({
    data: {
      'sentry.source': 'route',
      'sentry.origin': 'auto.http.otel.http',
      'sentry.op': 'http.server',
      url: `http://localhost:3030/test-inbound-headers/${id}`,
      'otel.kind': 'SERVER',
      'http.response.status_code': 200,
      'http.url': `http://localhost:3030/test-inbound-headers/${id}`,
      'http.host': 'localhost:3030',
      'net.host.name': 'localhost',
      'http.method': 'GET',
      'http.scheme': 'http',
      'http.target': `/test-inbound-headers/${id}`,
      'http.flavor': '1.1',
      'net.transport': 'ip_tcp',
      'net.host.ip': expect.any(String),
      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-inbound-headers/:id',
      'http.request.header.baggage': expect.any(String),
      'http.request.header.connection': 'keep-alive',
      'http.request.header.host': expect.any(String),
      'http.request.header.sentry_trace': expect.stringMatching(/[a-f0-9]{32}-[a-f0-9]{16}-1/),
    },
    op: 'http.server',
    parent_span_id: outgoingHttpSpanId,
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: traceId,
    origin: 'auto.http.otel.http',
  });
});

test('Propagates trace for outgoing fetch requests', async ({ baseURL }) => {
  const id = crypto.randomUUID();

  const inboundTransactionPromise = waitForTransaction('node-fastify-5', transactionEvent => {
    return (
      transactionEvent?.contexts?.trace?.op === 'http.server' &&
      transactionEvent.contexts?.trace?.data?.['http.target'] === `/test-inbound-headers/${id}`
    );
  });

  const outboundTransactionPromise = waitForTransaction('node-fastify-5', transactionEvent => {
    return (
      transactionEvent?.contexts?.trace?.op === 'http.server' &&
      transactionEvent.contexts?.trace?.data?.['http.target'] === `/test-outgoing-fetch/${id}`
    );
  });

  const response = await fetch(`${baseURL}/test-outgoing-fetch/${id}`);
  const data = await response.json();

  const inboundTransaction = await inboundTransactionPromise;
  const outboundTransaction = await outboundTransactionPromise;

  const traceId = outboundTransaction?.contexts?.trace?.trace_id;
  const outgoingHttpSpan = outboundTransaction?.spans?.find(span => span.op === 'http.client');

  expect(outgoingHttpSpan).toBeDefined();

  const outgoingHttpSpanId = outgoingHttpSpan?.span_id;

  const outgoingHttpSpanData = outgoingHttpSpan?.data || {};
  // Outgoing span (`http.client`) does not include headers as attributes
  expect(Object.keys(outgoingHttpSpanData).some(key => key.startsWith('http.request.header.'))).toBe(false);

  expect(traceId).toEqual(expect.any(String));

  // data is passed through from the inbound request, to verify we have the correct headers set
  const inboundHeaderSentryTrace = data.headers?.['sentry-trace'];
  const inboundHeaderBaggage = data.headers?.['baggage'];

  expect(inboundHeaderSentryTrace).toEqual(`${traceId}-${outgoingHttpSpanId}-1`);
  expect(inboundHeaderBaggage).toBeDefined();

  const baggage = (inboundHeaderBaggage || '').split(',');
  expect(baggage).toEqual(
    expect.arrayContaining([
      'sentry-environment=qa',
      `sentry-trace_id=${traceId}`,
      expect.stringMatching(/sentry-public_key=/),
    ]),
  );

  expect(outboundTransaction.contexts?.trace).toEqual({
    data: {
      'sentry.source': 'route',
      'sentry.origin': 'auto.http.otel.http',
      'sentry.op': 'http.server',
      'sentry.sample_rate': 1,
      url: `http://localhost:3030/test-outgoing-fetch/${id}`,
      'otel.kind': 'SERVER',
      'http.response.status_code': 200,
      'http.url': `http://localhost:3030/test-outgoing-fetch/${id}`,
      'http.host': 'localhost:3030',
      'net.host.name': 'localhost',
      'http.method': 'GET',
      'http.scheme': 'http',
      'http.target': `/test-outgoing-fetch/${id}`,
      'http.user_agent': 'node',
      'http.flavor': '1.1',
      'net.transport': 'ip_tcp',
      'net.host.ip': expect.any(String),
      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-outgoing-fetch/:id',
      'http.request.header.accept': '*/*',
      'http.request.header.accept_encoding': 'gzip, deflate',
      'http.request.header.accept_language': '*',
      'http.request.header.connection': 'keep-alive',
      'http.request.header.host': expect.any(String),
      'http.request.header.sec_fetch_mode': 'cors',
      'http.request.header.user_agent': 'node',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: traceId,
    origin: 'auto.http.otel.http',
  });

  expect(inboundTransaction.contexts?.trace).toEqual({
    data: {
      'sentry.source': 'route',
      'sentry.origin': 'auto.http.otel.http',
      'sentry.op': 'http.server',
      url: `http://localhost:3030/test-inbound-headers/${id}`,
      'otel.kind': 'SERVER',
      'http.response.status_code': 200,
      'http.url': `http://localhost:3030/test-inbound-headers/${id}`,
      'http.host': 'localhost:3030',
      'net.host.name': 'localhost',
      'http.method': 'GET',
      'http.scheme': 'http',
      'http.target': `/test-inbound-headers/${id}`,
      'http.flavor': '1.1',
      'net.transport': 'ip_tcp',
      'net.host.ip': expect.any(String),
      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.user_agent': 'node',
      'http.route': '/test-inbound-headers/:id',
      'http.request.header.accept': '*/*',
      'http.request.header.accept_encoding': 'gzip, deflate',
      'http.request.header.accept_language': '*',
      'http.request.header.baggage': expect.any(String),
      'http.request.header.connection': 'keep-alive',
      'http.request.header.host': expect.any(String),
      'http.request.header.sec_fetch_mode': 'cors',
      'http.request.header.sentry_trace': expect.stringMatching(/[a-f0-9]{32}-[a-f0-9]{16}-1/),
      'http.request.header.user_agent': 'node',
    },
    op: 'http.server',
    parent_span_id: outgoingHttpSpanId,
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: traceId,
    origin: 'auto.http.otel.http',",0
"      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-transaction',
      'http.request.header.accept': '*/*',
      'http.request.header.accept_encoding': 'gzip, deflate',
      'http.request.header.accept_language': '*',
      'http.request.header.connection': 'keep-alive',
      'http.request.header.host': expect.any(String),
      'http.request.header.sec_fetch_mode': 'cors',
      'http.request.header.user_agent': 'node',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: expect.stringMatching(/[a-f0-9]{32}/),
    origin: 'auto.http.otel.http',",0
"      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-success',
      'http.request.header.accept': '*/*',
      'http.request.header.accept_encoding': 'gzip, deflate',
      'http.request.header.accept_language': '*',
      'http.request.header.connection': 'keep-alive',
      'http.request.header.host': expect.any(String),
      'http.request.header.sec_fetch_mode': 'cors',
      'http.request.header.user_agent': 'node',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: expect.stringMatching(/[a-f0-9]{32}/),
    origin: 'auto.http.otel.http',
  });

  expect(transactionEvent).toEqual(
    expect.objectContaining({
      transaction: 'GET /test-success',
      type: 'transaction',
      transaction_info: {
        source: 'route',
      },
    }),
  );

  const spans = transactionEvent.spans || [];

  spans.forEach(span => {
    expect(Object.keys(span.data).some(key => key.startsWith('http.request.header.'))).toBe(false);
  });

  expect(spans).toEqual([
    {
      data: {
        'hapi.type': 'router',
        'http.method': 'GET',
        'http.route': '/test-success',",0
"  const traceId = outboundTransaction?.contexts?.trace?.trace_id;
  const outgoingHttpSpan = outboundTransaction?.spans?.find(span => span.op === 'http.client');
  expect(outgoingHttpSpan).toBeDefined();

  const outgoingHttpSpanId = outgoingHttpSpan?.span_id;

  const outgoingHttpSpanData = outgoingHttpSpan?.data || {};
  // Outgoing span (`http.client`) does not include headers as attributes
  expect(Object.keys(outgoingHttpSpanData).some(key => key.startsWith('http.request.header.'))).toBe(false);

  expect(traceId).toEqual(expect.any(String));

  // data is passed through from the inbound request, to verify we have the correct headers set
  const inboundHeaderSentryTrace = data.headers?.['sentry-trace'];
  const inboundHeaderBaggage = data.headers?.['baggage'];

  expect(inboundHeaderSentryTrace).toEqual(`${traceId}-${outgoingHttpSpanId}-1`);
  expect(inboundHeaderBaggage).toBeDefined();

  const baggage = (inboundHeaderBaggage || '').split(',');
  expect(baggage).toEqual(
    expect.arrayContaining([
      'sentry-environment=qa',
      `sentry-trace_id=${traceId}`,
      expect.stringMatching(/sentry-public_key=/),
    ]),
  );

  expect(outboundTransaction.contexts?.trace).toEqual({
    data: {
      'sentry.source': 'route',
      'sentry.origin': 'auto.http.otel.http',
      'sentry.op': 'http.server',
      'sentry.sample_rate': 1,
      url: `http://localhost:3030/test-outgoing-http/${id}`,
      'otel.kind': 'SERVER',
      'http.response.status_code': 200,
      'http.url': `http://localhost:3030/test-outgoing-http/${id}`,
      'http.host': 'localhost:3030',
      'net.host.name': 'localhost',
      'http.method': 'GET',
      'http.scheme': 'http',
      'http.target': `/test-outgoing-http/${id}`,
      'http.user_agent': 'node',
      'http.flavor': '1.1',
      'net.transport': 'ip_tcp',
      'net.host.ip': expect.any(String),
      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-outgoing-http/:id',
      'http.request.header.accept': '*/*',
      'http.request.header.accept_encoding': 'gzip, deflate',
      'http.request.header.accept_language': '*',
      'http.request.header.connection': 'keep-alive',
      'http.request.header.host': expect.any(String),
      'http.request.header.sec_fetch_mode': 'cors',
      'http.request.header.user_agent': 'node',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: traceId,
    origin: 'auto.http.otel.http',
  });

  expect(inboundTransaction.contexts?.trace).toEqual({
    data: {
      'sentry.source': 'route',
      'sentry.origin': 'auto.http.otel.http',
      'sentry.op': 'http.server',
      url: `http://localhost:3030/test-inbound-headers/${id}`,
      'otel.kind': 'SERVER',
      'http.response.status_code': 200,
      'http.url': `http://localhost:3030/test-inbound-headers/${id}`,
      'http.host': 'localhost:3030',
      'net.host.name': 'localhost',
      'http.method': 'GET',
      'http.scheme': 'http',
      'http.target': `/test-inbound-headers/${id}`,
      'http.flavor': '1.1',
      'net.transport': 'ip_tcp',
      'net.host.ip': expect.any(String),
      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-inbound-headers/:id',
      'http.request.header.baggage': expect.stringContaining(traceId!), // we already check if traceId is defined
      'http.request.header.connection': 'keep-alive',
      'http.request.header.host': expect.any(String),
      'http.request.header.sentry_trace': expect.stringMatching(/[a-f0-9]{32}-[a-f0-9]{16}-1/),
    },
    op: 'http.server',
    parent_span_id: outgoingHttpSpanId,
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: traceId,
    origin: 'auto.http.otel.http',
  });
});

test('Propagates trace for outgoing fetch requests', async ({ baseURL }) => {
  const id = crypto.randomUUID();

  const inboundTransactionPromise = waitForTransaction('node-koa', transactionEvent => {
    return (
      transactionEvent?.contexts?.trace?.op === 'http.server' &&
      transactionEvent.contexts?.trace?.data?.['http.target'] === `/test-inbound-headers/${id}`
    );
  });

  const outboundTransactionPromise = waitForTransaction('node-koa', transactionEvent => {
    return (
      transactionEvent?.contexts?.trace?.op === 'http.server' &&
      transactionEvent.contexts?.trace?.data?.['http.target'] === `/test-outgoing-fetch/${id}`
    );
  });

  const response = await fetch(`${baseURL}/test-outgoing-fetch/${id}`);
  const data = await response.json();

  const inboundTransaction = await inboundTransactionPromise;
  const outboundTransaction = await outboundTransactionPromise;

  const traceId = outboundTransaction?.contexts?.trace?.trace_id;
  const outgoingHttpSpan = outboundTransaction?.spans?.find(span => span.op === 'http.client');

  expect(outgoingHttpSpan).toBeDefined();

  const outgoingHttpSpanId = outgoingHttpSpan?.span_id;

  const outgoingHttpSpanData = outgoingHttpSpan?.data || {};
  // Outgoing span (`http.client`) does not include headers as attributes
  expect(Object.keys(outgoingHttpSpanData).some(key => key.startsWith('http.request.header.'))).toBe(false);

  expect(traceId).toEqual(expect.any(String));

  // data is passed through from the inbound request, to verify we have the correct headers set
  const inboundHeaderSentryTrace = data.headers?.['sentry-trace'];
  const inboundHeaderBaggage = data.headers?.['baggage'];

  expect(inboundHeaderSentryTrace).toEqual(`${traceId}-${outgoingHttpSpanId}-1`);
  expect(inboundHeaderBaggage).toBeDefined();

  const baggage = (inboundHeaderBaggage || '').split(',');
  expect(baggage).toEqual(
    expect.arrayContaining([
      'sentry-environment=qa',
      `sentry-trace_id=${traceId}`,
      expect.stringMatching(/sentry-public_key=/),
    ]),
  );

  expect(outboundTransaction.contexts?.trace).toEqual({
    data: {
      'sentry.source': 'route',
      'sentry.origin': 'auto.http.otel.http',
      'sentry.op': 'http.server',
      'sentry.sample_rate': 1,
      url: `http://localhost:3030/test-outgoing-fetch/${id}`,
      'otel.kind': 'SERVER',
      'http.response.status_code': 200,
      'http.url': `http://localhost:3030/test-outgoing-fetch/${id}`,
      'http.host': 'localhost:3030',
      'net.host.name': 'localhost',
      'http.method': 'GET',
      'http.scheme': 'http',
      'http.target': `/test-outgoing-fetch/${id}`,
      'http.user_agent': 'node',
      'http.flavor': '1.1',
      'net.transport': 'ip_tcp',
      'net.host.ip': expect.any(String),
      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-outgoing-fetch/:id',
      'http.request.header.accept': '*/*',
      'http.request.header.accept_encoding': 'gzip, deflate',
      'http.request.header.accept_language': '*',
      'http.request.header.connection': 'keep-alive',
      'http.request.header.host': 'localhost:3030',
      'http.request.header.sec_fetch_mode': 'cors',
      'http.request.header.user_agent': 'node',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: traceId,
    origin: 'auto.http.otel.http',
  });

  expect(inboundTransaction.contexts?.trace).toEqual({
    data: {
      'sentry.source': 'route',
      'sentry.origin': 'auto.http.otel.http',
      'sentry.op': 'http.server',
      url: `http://localhost:3030/test-inbound-headers/${id}`,
      'otel.kind': 'SERVER',
      'http.response.status_code': 200,
      'http.url': `http://localhost:3030/test-inbound-headers/${id}`,
      'http.host': 'localhost:3030',
      'net.host.name': 'localhost',
      'http.method': 'GET',
      'http.scheme': 'http',
      'http.target': `/test-inbound-headers/${id}`,
      'http.flavor': '1.1',
      'net.transport': 'ip_tcp',
      'net.host.ip': expect.any(String),
      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-inbound-headers/:id',
      'http.user_agent': 'node',
      'http.request.header.accept': '*/*',
      'http.request.header.accept_encoding': 'gzip, deflate',
      'http.request.header.accept_language': '*',
      'http.request.header.baggage': expect.stringContaining(traceId!), // we already check if traceId is defined
      'http.request.header.connection': 'keep-alive',
      'http.request.header.host': expect.any(String),
      'http.request.header.sec_fetch_mode': 'cors',
      'http.request.header.sentry_trace': expect.stringMatching(/[a-f0-9]{32}-[a-f0-9]{16}-1/),
      'http.request.header.user_agent': 'node',
    },
    op: 'http.server',
    parent_span_id: outgoingHttpSpanId,
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: traceId,
    origin: 'auto.http.otel.http',",0
"      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-transaction',
      'http.request.header.accept': '*/*',
      'http.request.header.accept_encoding': 'gzip, deflate',
      'http.request.header.accept_language': '*',
      'http.request.header.connection': 'keep-alive',
      'http.request.header.host': expect.any(String),
      'http.request.header.sec_fetch_mode': 'cors',
      'http.request.header.user_agent': 'node',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: expect.stringMatching(/[a-f0-9]{32}/),
    origin: 'auto.http.otel.http',",0
"      'net.host.port': 3030,
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/task',
      'http.request.header.accept': '*/*',
      'http.request.header.accept_encoding': 'gzip, deflate',
      'http.request.header.accept_language': '*',
      'http.request.header.connection': 'keep-alive',
      'http.request.header.host': expect.any(String),
      'http.request.header.sec_fetch_mode': 'cors',
      'http.request.header.user_agent': 'node',
    },
    origin: 'auto.http.otel.http',
    op: 'http.server',
    status: 'ok',
  });
",0
"      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-transaction',
      'http.request.header.accept': '*/*',
      'http.request.header.accept_encoding': 'gzip, deflate',
      'http.request.header.accept_language': '*',
      'http.request.header.connection': 'keep-alive',
      'http.request.header.host': expect.any(String),
      'http.request.header.sec_fetch_mode': 'cors',
      'http.request.header.user_agent': 'node',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: expect.stringMatching(/[a-f0-9]{32}/),
    origin: 'auto.http.otel.http',",0
"      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-transaction',
      'http.request.header.accept': '*/*',
      'http.request.header.accept_encoding': 'gzip, deflate',
      'http.request.header.accept_language': '*',
      'http.request.header.connection': 'keep-alive',
      'http.request.header.host': expect.any(String),
      'http.request.header.sec_fetch_mode': 'cors',
      'http.request.header.user_agent': 'node',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: expect.stringMatching(/[a-f0-9]{32}/),
    origin: 'auto.http.otel.http',",0
"  const transactionEvent = await transactionEventPromise;

  expect(buildAssetFolderOccurred).toBe(false);

  expect(transactionEvent.transaction).toBe('GET /test-param/:param()');
});

test('extracts HTTP request headers as span attributes', async ({ baseURL }) => {
  const transactionPromise = waitForTransaction('nuxt-3', transactionEvent => {
    return transactionEvent.transaction.includes('GET /api/test-param/');
  });

  await fetch(`${baseURL}/api/test-param/headers-test`, {
    headers: {
      'User-Agent': 'Custom-Nuxt-Agent/3.0',
      'Content-Type': 'application/json',
      'X-Nuxt-Test': 'nuxt-header-value',
      Accept: 'application/json, text/html',
      'X-Framework': 'Nuxt',
      'X-Request-ID': 'nuxt-456',
    },
  });

  const transaction = await transactionPromise;

  expect(transaction.contexts?.trace?.data).toEqual(
    expect.objectContaining({
      'http.request.header.user_agent': 'Custom-Nuxt-Agent/3.0',
      'http.request.header.content_type': 'application/json',
      'http.request.header.x_nuxt_test': 'nuxt-header-value',
      'http.request.header.accept': 'application/json, text/html',
      'http.request.header.x_framework': 'Nuxt',
      'http.request.header.x_request_id': 'nuxt-456',
    }),
  );
});",0
"      expect.objectContaining({ op: 'function.sveltekit.server.load', description: '/server-load-fetch' }),
      // sub request span:
      expect.objectContaining({ op: 'http.server', description: 'GET /api/users' }),
    ]),
  );
});

test('extracts HTTP request headers as span attributes', async ({ page, baseURL }) => {
  const serverTxnEventPromise = waitForTransaction('sveltekit-2', txnEvent => {
    return txnEvent?.transaction === 'GET /api/users';
  });

  await fetch(`${baseURL}/api/users`, {
    headers: {
      'User-Agent': 'Custom-SvelteKit-Agent/1.0',
      'Content-Type': 'application/json',
      'X-Test-Header': 'sveltekit-test-value',
      Accept: 'application/json',
      'X-Framework': 'SvelteKit',
      'X-Request-ID': 'sveltekit-123',
    },
  });

  const serverTxnEvent = await serverTxnEventPromise;

  expect(serverTxnEvent.contexts?.trace?.data).toEqual(
    expect.objectContaining({
      'http.request.header.user_agent': 'Custom-SvelteKit-Agent/1.0',
      'http.request.header.content_type': 'application/json',
      'http.request.header.x_test_header': 'sveltekit-test-value',
      'http.request.header.accept': 'application/json',
      'http.request.header.x_framework': 'SvelteKit',
      'http.request.header.x_request_id': 'sveltekit-123',
    }),
  );
});",0
"      'net.host.port': expect.any(Number),
      'net.peer.ip': expect.any(String),
      'net.peer.port': expect.any(Number),
      'http.status_code': 200,
      'http.status_text': 'OK',
      'http.route': '/test-transaction',
      'http.request.header.accept': '*/*',
      'http.request.header.accept_encoding': 'gzip, deflate',
      'http.request.header.accept_language': '*',
      'http.request.header.connection': 'keep-alive',
      'http.request.header.host': expect.any(String),
      'http.request.header.sec_fetch_mode': 'cors',
      'http.request.header.user_agent': 'node',
    },
    op: 'http.server',
    span_id: expect.stringMatching(/[a-f0-9]{16}/),
    status: 'ok',
    trace_id: expect.stringMatching(/[a-f0-9]{32}/),
    origin: 'auto.http.otel.http',",0
"import { afterAll, describe, expect, test } from 'vitest';
import { cleanupChildProcesses, createEsmAndCjsTests, createRunner } from '../../../utils/runner';
import { createTestServer } from '../../../utils/server';

function getCommonHttpRequestHeaders(): Record<string, unknown> {
  return {
    'http.request.header.accept': '*/*',
    'http.request.header.accept_encoding': 'gzip, deflate',
    'http.request.header.accept_language': '*',
    'http.request.header.connection': 'keep-alive',
    'http.request.header.host': expect.any(String),
    'http.request.header.sec_fetch_mode': 'cors',
    'http.request.header.user_agent': 'node',
  };
}

describe('httpIntegration', () => {
  afterAll(() => {
    cleanupChildProcesses();
  });

  describe('instrumentation options', () => {
    createEsmAndCjsTests(__dirname, 'server.mjs', 'instrument-options.mjs', (createRunner, test) => {
      test('allows to pass instrumentation options to integration', async () => {
        const runner = createRunner()
          .expect({
            transaction: {
              contexts: {
                trace: {
                  span_id: expect.stringMatching(/[a-f0-9]{16}/),
                  trace_id: expect.stringMatching(/[a-f0-9]{32}/),
                  data: {
                    url: expect.stringMatching(/\/test$/),
                    'http.response.status_code': 200,
                    attr1: 'yes',
                    attr2: 'yes',
                    attr3: 'yes',
                  },
                  op: 'http.server',
                  status: 'ok',
                },
              },
              extra: {
                requestHookCalled: {
                  url: expect.stringMatching(/\/test$/),
                  method: 'GET',
                },
                responseHookCalled: {
                  url: expect.stringMatching(/\/test$/),
                  method: 'GET',
                },
                applyCustomAttributesOnSpanCalled: {
                  reqUrl: expect.stringMatching(/\/test$/),
                  reqMethod: 'GET',
                  resUrl: expect.stringMatching(/\/test$/),
                  resMethod: 'GET',
                },
              },
            },
          })
          .start();
        runner.makeRequest('get', '/test');
        await runner.completed();
      });

      test('allows to configure incomingRequestSpanHook', async () => {
        const runner = createRunner()
          .expect({
            transaction: {
              contexts: {
                trace: {
                  span_id: expect.stringMatching(/[a-f0-9]{16}/),
                  trace_id: expect.stringMatching(/[a-f0-9]{32}/),
                  data: {
                    url: expect.stringMatching(/\/test$/),
                    'http.response.status_code': 200,
                    incomingRequestSpanHook: 'yes',
                  },
                  op: 'http.server',
                  status: 'ok',
                },
              },
              extra: expect.objectContaining({
                incomingRequestSpanHookCalled: {
                  reqUrl: expect.stringMatching(/\/test$/),
                  reqMethod: 'GET',
                  resUrl: expect.stringMatching(/\/test$/),
                  resMethod: 'GET',
                },
              }),
            },
          })
          .start();
        runner.makeRequest('get', '/test');
        await runner.completed();
      });
    });
  });

  describe('http.server spans', () => {
    createEsmAndCjsTests(__dirname, 'server.mjs', 'instrument.mjs', (createRunner, test) => {
      test('captures correct attributes for GET requests', async () => {
        const runner = createRunner()
          .expect({
            transaction: transaction => {
              const port = runner.getPort();
              expect(transaction.transaction).toBe('GET /test');
              expect(transaction.contexts?.trace?.data).toEqual({
                'http.flavor': '1.1',
                'http.host': `localhost:${port}`,
                'http.method': 'GET',
                'http.query': 'a=1&b=2',
                'http.response.status_code': 200,
                'http.route': '/test',
                'http.scheme': 'http',
                'http.status_code': 200,
                'http.status_text': 'OK',
                'http.target': '/test?a=1&b=2',
                'http.url': `http://localhost:${port}/test?a=1&b=2`,
                'http.user_agent': 'node',
                'net.host.ip': '::1',
                'net.host.name': 'localhost',
                'net.host.port': port,
                'net.peer.ip': '::1',
                'net.peer.port': expect.any(Number),
                'net.transport': 'ip_tcp',
                'otel.kind': 'SERVER',
                'sentry.op': 'http.server',
                'sentry.origin': 'auto.http.otel.http',
                'sentry.sample_rate': 1,
                'sentry.source': 'route',
                url: `http://localhost:${port}/test`,
                ...getCommonHttpRequestHeaders(),
              });
            },
          })
          .start();

        runner.makeRequest('get', '/test?a=1&b=2#hash');
        await runner.completed();
      });

      test('captures correct attributes for POST requests', async () => {
        const runner = createRunner()
          .expect({
            transaction: transaction => {
              const port = runner.getPort();
              expect(transaction.transaction).toBe('POST /test');
              expect(transaction.contexts?.trace?.data).toEqual({
                'http.flavor': '1.1',
                'http.host': `localhost:${port}`,
                'http.method': 'POST',
                'http.query': 'a=1&b=2',
                'http.request_content_length_uncompressed': 9,
                'http.response.status_code': 200,
                'http.route': '/test',
                'http.scheme': 'http',
                'http.status_code': 200,
                'http.status_text': 'OK',
                'http.target': '/test?a=1&b=2',
                'http.url': `http://localhost:${port}/test?a=1&b=2`,
                'http.user_agent': 'node',
                'net.host.ip': '::1',
                'net.host.name': 'localhost',
                'net.host.port': port,
                'net.peer.ip': '::1',
                'net.peer.port': expect.any(Number),
                'net.transport': 'ip_tcp',
                'otel.kind': 'SERVER',
                'sentry.op': 'http.server',
                'sentry.origin': 'auto.http.otel.http',
                'sentry.sample_rate': 1,
                'sentry.source': 'route',
                url: `http://localhost:${port}/test`,
                'http.request.header.content_length': '9',
                'http.request.header.content_type': 'text/plain;charset=UTF-8',
                ...getCommonHttpRequestHeaders(),
              });
            },
          })
          .start();

        runner.makeRequest('post', '/test?a=1&b=2#hash', { data: 'test body' });",0
"  getRootSpan,
  getSentryRelease,
  getSpanDescendants,
  getSpanStatusFromHttpCode,
  getTraceData,
  getTraceMetaTags,
  httpHeadersToSpanAttributes,
  winterCGHeadersToDict,
  graphqlIntegration,
  hapiIntegration,
  httpIntegration,
  // eslint-disable-next-line deprecation/deprecation
  inboundFiltersIntegration,
  eventFiltersIntegration,",0
"  captureException,
  continueTrace,
  getActiveSpan,
  getClient,
  getCurrentScope,
  getTraceMetaTags,
  httpHeadersToSpanAttributes,
  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,
  SEMANTIC_ATTRIBUTE_SENTRY_SOURCE,
  setHttpStatus,
  startSpan,
  winterCGHeadersToDict,
  withIsolationScope,
} from '@sentry/node';
import type { APIContext, MiddlewareResponseHandler, RoutePart } from 'astro';

type MiddlewareOptions = {
  /**
   * If true, the client IP will be attached to the event by calling `setUser`.
   *
   * Important: Only enable this option if your Astro app is configured for (hybrid) SSR
   * via the `output: 'server' | 'hybrid'` option in your `astro.config.mjs` file.
   * Otherwise, Astro will throw an error when starting the server.
   *
   * Only set this to `true` if you're fine with collecting potentially personally identifiable information (PII).
   *
   * @default false (recommended)
   */
  trackClientIp?: boolean;
};

function sendErrorToSentry(e: unknown): unknown {
  // In case we have a primitive, wrap it in the equivalent wrapper class (string -> String, etc.) so that we can
  // store a seen flag on it.
  const objectifiedErr = objectify(e);

  captureException(objectifiedErr, {
    mechanism: {
      type: 'astro',
      handled: false,
      data: {
        function: 'astroMiddleware',
      },
    },
  });

  return objectifiedErr;
}

type AstroLocalsWithSentry = Record<string, unknown> & {
  __sentry_wrapped__?: boolean;
};

export const handleRequest: (options?: MiddlewareOptions) => MiddlewareResponseHandler = options => {
  const handlerOptions = {
    trackClientIp: false,
    ...options,
  };

  return async (ctx, next) => {
    // If no Sentry client exists, just bail
    // Apart from the case when no Sentry.init() is called at all, this also happens
    // if a prerendered page is hit first before a ssr page is called
    // For regular prerendered pages, this is fine as we do not want to instrument them at runtime anyhow
    // BUT for server-islands requests on a static page, this can be problematic...
    // TODO: Today, this leads to inconsistent behavior: If a prerendered page is hit first (before _any_ ssr page is called),
    // Sentry.init() has not been called yet (as this is only injected in SSR pages), so server-island requests are not instrumented
    // If any SSR route is hit before, the client will already be set up and everything will work as expected :O
    // To reproduce this: Run the astro-5 ""tracing.serverIslands.test"" only
    if (!getClient()) {
      return next();
    }

    const isDynamicPageRequest = checkIsDynamicPageRequest(ctx);

    // For static (prerendered) routes, we only want to inject the parametrized route meta tags
    if (!isDynamicPageRequest) {
      return handleStaticRoute(ctx, next);
    }

    const activeSpan = getActiveSpan();
    const rootSpan = activeSpan ? getRootSpan(activeSpan) : undefined;

    // if there is an active span, we just want to enhance it with routing data etc.
    if (rootSpan && spanToJSON(rootSpan).op === 'http.server') {
      return enhanceHttpServerSpan(ctx, next, rootSpan);
    }

    return instrumentRequestStartHttpServerSpan(ctx, next, handlerOptions);
  };
};

async function handleStaticRoute(
  ctx: Parameters<MiddlewareResponseHandler>[0],
  next: Parameters<MiddlewareResponseHandler>[1],
): Promise<Response> {
  const parametrizedRoute = getParametrizedRoute(ctx);
  try {
    const originalResponse = await next();

    // We never want to continue a trace here, so we do not inject trace data
    // But we do want to inject the parametrized route, as this is used for client-side route parametrization
    const metaTagsStr = getMetaTagsStr({ injectTraceData: false, parametrizedRoute });
    return injectMetaTagsInResponse(originalResponse, metaTagsStr);
  } catch (e) {
    sendErrorToSentry(e);
    throw e;
  }
}

async function enhanceHttpServerSpan(
  ctx: Parameters<MiddlewareResponseHandler>[0],
  next: Parameters<MiddlewareResponseHandler>[1],
  rootSpan: Span,
): Promise<Response> {
  // Make sure we don't accidentally double wrap (e.g. user added middleware and integration auto added it)
  const locals = ctx.locals as AstroLocalsWithSentry | undefined;
  if (locals?.__sentry_wrapped__) {
    return next();
  }
  if (locals) {
    addNonEnumerableProperty(locals, '__sentry_wrapped__', true);
  }

  const request = ctx.request;
  const isolationScope = getIsolationScope();
  const method = request.method;

  try {
    const parametrizedRoute = getParametrizedRoute(ctx);

    rootSpan.setAttributes({
      // This is here for backwards compatibility, we used to set this here before
      method,
      [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.astro',
    });

    if (parametrizedRoute) {
      rootSpan.setAttributes({
        [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'route',
        'http.route': parametrizedRoute,
      });

      isolationScope.setTransactionName(`${method} ${parametrizedRoute}`);
    }

    try {
      const originalResponse = await next();
      const metaTagsStr = getMetaTagsStr({ injectTraceData: true, parametrizedRoute });
      return injectMetaTagsInResponse(originalResponse, metaTagsStr);
    } catch (e) {
      sendErrorToSentry(e);
      throw e;
    }
  } finally {
    await flushIfServerless();
  }
}

async function instrumentRequestStartHttpServerSpan(
  ctx: Parameters<MiddlewareResponseHandler>[0],
  next: Parameters<MiddlewareResponseHandler>[1],
  options: MiddlewareOptions,
): Promise<Response> {
  // Make sure we don't accidentally double wrap (e.g. user added middleware and integration auto added it)
  const locals = ctx.locals as AstroLocalsWithSentry | undefined;
  if (locals?.__sentry_wrapped__) {
    return next();
  }
  if (locals) {
    addNonEnumerableProperty(locals, '__sentry_wrapped__', true);
  }

  const request = ctx.request;

  // Note: We guard outside of this function call that the request is dynamic
  // accessing headers on a static route would throw
  const { method, headers } = request;

  return withIsolationScope(isolationScope => {
    return continueTrace(
      {
        sentryTrace: headers?.get('sentry-trace') || undefined,
        baggage: headers?.get('baggage'),
      },
      async () => {
        getCurrentScope().setSDKProcessingMetadata({
          // We store the request on the current scope, not isolation scope,
          // because we may have multiple requests nested inside each other
          normalizedRequest: winterCGRequestToRequestData(request),
        });

        if (options.trackClientIp) {
          isolationScope.setUser({ ip_address: ctx.clientAddress });
        }

        try {
          const parametrizedRoute = getParametrizedRoute(ctx);

          const source = parametrizedRoute ? 'route' : 'url';
          // storing res in a variable instead of directly returning is necessary to
          // invoke the catch block if next() throws

          const attributes: SpanAttributes = {
            [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.astro',
            [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: source,
            [SEMANTIC_ATTRIBUTE_HTTP_REQUEST_METHOD]: method,
            // This is here for backwards compatibility, we used to set this here before
            method,
            url: stripUrlQueryAndFragment(ctx.url.href),
            ...httpHeadersToSpanAttributes(
              winterCGHeadersToDict(request.headers),
              getClient()?.getOptions().sendDefaultPii ?? false,
            ),
          };

          if (parametrizedRoute) {
            attributes['http.route'] = parametrizedRoute;
          }
",0
"        getSpan: getSpanMock,
        setSDKProcessingMetadata: setSDKProcessingMetadataMock,
        getPropagationContext: () => ({}),
      } as any;
    });
    vi.spyOn(SentryNode, 'getActiveSpan').mockImplementation(getSpanMock);
    vi.spyOn(SentryNode, 'getClient').mockImplementation(() => ({ getOptions: () => ({}) }) as Client);
    vi.spyOn(SentryNode, 'getTraceMetaTags').mockImplementation(
      () => `
    <meta name=""sentry-trace"" content=""123"">
    <meta name=""baggage"" content=""abc"">
    `,
    );",0
"  defaultStackParser,
  lastEventId,
  flush,
  close,
  getSentryRelease,
  createGetModuleFromFilename,
  httpHeadersToSpanAttributes,
  winterCGHeadersToDict,
  // eslint-disable-next-line deprecation/deprecation
  anrIntegration,
  // eslint-disable-next-line deprecation/deprecation
  disableAnrDetectionForCallback,
  consoleIntegration,
  httpIntegration,",0
"  defaultStackParser,
  lastEventId,
  flush,
  close,
  getSentryRelease,
  createGetModuleFromFilename,
  httpHeadersToSpanAttributes,
  winterCGHeadersToDict,
  // eslint-disable-next-line deprecation/deprecation
  anrIntegration,
  // eslint-disable-next-line deprecation/deprecation
  disableAnrDetectionForCallback,
  consoleIntegration,
  httpIntegration,",0
"import type { IntegrationFn, RequestEventData, SpanAttributes } from '@sentry/core';
import {
  captureException,
  continueTrace,
  defineIntegration,
  getClient,
  httpHeadersToSpanAttributes,
  isURLObjectRelative,
  parseStringToURLObject,
  SEMANTIC_ATTRIBUTE_HTTP_REQUEST_METHOD,
  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,
  SEMANTIC_ATTRIBUTE_SENTRY_SOURCE,
  setHttpStatus,
  startSpan,
  withIsolationScope,
} from '@sentry/core';
import type { ServeOptions } from 'bun';

const INTEGRATION_NAME = 'BunServer';

const _bunServerIntegration = (() => {
  return {
    name: INTEGRATION_NAME,
    setupOnce() {
      instrumentBunServe();
    },
  };
}) satisfies IntegrationFn;

/**
 * Instruments `Bun.serve` to automatically create transactions and capture errors.
 *
 * Does not support instrumenting static routes.
 *
 * Enabled by default in the Bun SDK.
 *
 * ```js
 * Sentry.init({
 *   integrations: [
 *     Sentry.bunServerIntegration(),
 *   ],
 * })
 * ```
 */
export const bunServerIntegration = defineIntegration(_bunServerIntegration);

let hasPatchedBunServe = false;

/**
 * Instruments Bun.serve by patching it's options.
 *
 * Only exported for tests.
 */
export function instrumentBunServe(): void {
  if (hasPatchedBunServe) {
    return;
  }

  Bun.serve = new Proxy(Bun.serve, {
    apply(serveTarget, serveThisArg, serveArgs: Parameters<typeof Bun.serve>) {
      instrumentBunServeOptions(serveArgs[0]);
      const server: ReturnType<typeof Bun.serve> = serveTarget.apply(serveThisArg, serveArgs);

      // A Bun server can be reloaded, re-wrap any fetch function passed to it
      // We can't use a Proxy for this as Bun does `instanceof` checks internally that fail if we
      // wrap the Server instance.
      const originalReload: typeof server.reload = server.reload.bind(server);
      server.reload = (serveOptions: ServeOptions) => {
        instrumentBunServeOptions(serveOptions);
        return originalReload(serveOptions);
      };

      return server;
    },
  });

  hasPatchedBunServe = true;
}

/**
 * Instruments Bun.serve options.
 *
 * @param serveOptions - The options for the Bun.serve function.
 */
function instrumentBunServeOptions(serveOptions: Parameters<typeof Bun.serve>[0]): void {
  // First handle fetch
  instrumentBunServeOptionFetch(serveOptions);
  // then handle routes
  instrumentBunServeOptionRoutes(serveOptions);
}

/**
 * Instruments the `fetch` option of Bun.serve.
 *
 * @param serveOptions - The options for the Bun.serve function.
 */
function instrumentBunServeOptionFetch(serveOptions: Parameters<typeof Bun.serve>[0]): void {
  if (typeof serveOptions.fetch !== 'function') {
    return;
  }

  serveOptions.fetch = new Proxy(serveOptions.fetch, {
    apply(fetchTarget, fetchThisArg, fetchArgs: Parameters<typeof serveOptions.fetch>) {
      return wrapRequestHandler(fetchTarget, fetchThisArg, fetchArgs);
    },
  });
}

/**
 * Instruments the `routes` option of Bun.serve.
 *
 * @param serveOptions - The options for the Bun.serve function.
 */
function instrumentBunServeOptionRoutes(serveOptions: Parameters<typeof Bun.serve>[0]): void {
  if (!serveOptions.routes) {
    return;
  }

  if (typeof serveOptions.routes !== 'object') {
    return;
  }

  Object.keys(serveOptions.routes).forEach(route => {
    const routeHandler = serveOptions.routes[route];

    // Handle route handlers that are an object
    if (typeof routeHandler === 'function') {
      serveOptions.routes[route] = new Proxy(routeHandler, {
        apply: (routeHandlerTarget, routeHandlerThisArg, routeHandlerArgs: Parameters<typeof routeHandler>) => {
          return wrapRequestHandler(routeHandlerTarget, routeHandlerThisArg, routeHandlerArgs, route);
        },
      });
    }

    // Static routes are not instrumented
    if (routeHandler instanceof Response) {
      return;
    }

    // Handle the route handlers that are an object. This means they define a route handler for each method.
    if (typeof routeHandler === 'object') {
      Object.entries(routeHandler).forEach(([routeHandlerObjectHandlerKey, routeHandlerObjectHandler]) => {
        if (typeof routeHandlerObjectHandler === 'function') {
          (serveOptions.routes[route] as Record<string, RouteHandler>)[routeHandlerObjectHandlerKey] = new Proxy(
            routeHandlerObjectHandler,
            {
              apply: (
                routeHandlerObjectHandlerTarget,
                routeHandlerObjectHandlerThisArg,
                routeHandlerObjectHandlerArgs: Parameters<typeof routeHandlerObjectHandler>,
              ) => {
                return wrapRequestHandler(
                  routeHandlerObjectHandlerTarget,
                  routeHandlerObjectHandlerThisArg,
                  routeHandlerObjectHandlerArgs,
                  route,
                );
              },
            },
          );
        }
      });
    }
  });
}

type RouteHandler = Extract<
  NonNullable<Parameters<typeof Bun.serve>[0]['routes']>[string],
  // eslint-disable-next-line @typescript-eslint/ban-types
  Function
>;

function wrapRequestHandler<T extends RouteHandler = RouteHandler>(
  target: T,
  thisArg: unknown,
  args: Parameters<T>,
  route?: string,
): ReturnType<T> {
  return withIsolationScope(isolationScope => {
    const request = args[0];
    const upperCaseMethod = request.method.toUpperCase();
    if (upperCaseMethod === 'OPTIONS' || upperCaseMethod === 'HEAD') {
      return target.apply(thisArg, args);
    }

    const parsedUrl = parseStringToURLObject(request.url);
    const attributes = getSpanAttributesFromParsedUrl(parsedUrl, request);

    let routeName = parsedUrl?.pathname || '/';
    if (request.params) {
      Object.keys(request.params).forEach(key => {
        attributes[`url.path.parameter.${key}`] = (request.params as Record<string, string>)[key];
      });

      // If a route has parameters, it's a parameterized route
      if (route) {
        attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] = 'route';
        attributes['url.template'] = route;
        routeName = route;
      }
    }

    // Handle wildcard routes
    if (route?.endsWith('/*')) {
      attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] = 'route';
      attributes['url.template'] = route;
      routeName = route;
    }

    const client = getClient();
    const sendDefaultPii = client?.getOptions().sendDefaultPii ?? false;
    Object.assign(attributes, httpHeadersToSpanAttributes(request.headers.toJSON(), sendDefaultPii));

    isolationScope.setSDKProcessingMetadata({
      normalizedRequest: {
        url: request.url,
        method: request.method,
        headers: request.headers.toJSON(),
        query_string: parsedUrl?.search,",0
"          'url.query': '?id=123',
          'url.path': '/users',
          'url.full': `http://localhost:${port}/users?id=123`,
          'url.port': port.toString(),
          'url.scheme': 'http:',
          'url.domain': 'localhost',
          'http.request.header.accept': '*/*',
          'http.request.header.accept_encoding': 'gzip, deflate, br, zstd',
          'http.request.header.connection': 'keep-alive',
          'http.request.header.host': expect.any(String),
          'http.request.header.user_agent': expect.stringContaining('Bun'),
        },
        op: 'http.server',
        name: 'GET /users',
      },
      expect.any(Function),
    );
  });

  test('generates a post transaction', async () => {
    const server = Bun.serve({
      async fetch(_req) {
        return new Response('Bun!');
      },
      port,
    });

    await fetch(`http://localhost:${port}/`, {
      method: 'POST',
    });

    await server.stop();

    expect(startSpanSpy).toHaveBeenCalledTimes(1);
    expect(startSpanSpy).toHaveBeenLastCalledWith(
      {
        attributes: {
          'sentry.origin': 'auto.http.bun.serve',
          'http.request.method': 'POST',
          'sentry.source': 'url',
          'url.path': '/',
          'url.full': `http://localhost:${port}/`,
          'url.port': port.toString(),
          'url.scheme': 'http:',
          'url.domain': 'localhost',
          'http.request.header.accept': '*/*',
          'http.request.header.accept_encoding': 'gzip, deflate, br, zstd',
          'http.request.header.connection': 'keep-alive',
          'http.request.header.content_length': '0',
          'http.request.header.host': expect.any(String),
          'http.request.header.user_agent': expect.stringContaining('Bun'),
        },
        op: 'http.server',
        name: 'POST /',
      },
      expect.any(Function),
    );
  });

  test('continues a trace', async () => {
    const TRACE_ID = '12312012123120121231201212312012';
    const PARENT_SPAN_ID = '1121201211212012';
    const PARENT_SAMPLED = '1';

    const SENTRY_TRACE_HEADER = `${TRACE_ID}-${PARENT_SPAN_ID}-${PARENT_SAMPLED}`;
    const SENTRY_BAGGAGE_HEADER = 'sentry-sample_rand=0.42,sentry-environment=production';

    const server = Bun.serve({
      async fetch(_req) {
        return new Response('Bun!');
      },
      port,
    });

    // Make request with trace headers
    await fetch(`http://localhost:${port}/`, {
      headers: {
        'sentry-trace': SENTRY_TRACE_HEADER,
        baggage: SENTRY_BAGGAGE_HEADER,
      },
    });

    await server.stop();

    // Verify continueTrace was called with the correct headers
    expect(continueTraceSpy).toHaveBeenCalledTimes(1);
    expect(continueTraceSpy).toHaveBeenCalledWith(
      {
        sentryTrace: SENTRY_TRACE_HEADER,
        baggage: SENTRY_BAGGAGE_HEADER,
      },
      expect.any(Function),
    );

    // Verify a span was created
    expect(startSpanSpy).toHaveBeenCalledTimes(1);
  });

  test('includes HTTP request headers as span attributes', async () => {
    const server = Bun.serve({
      async fetch(_req) {
        return new Response('Headers test!');
      },
      port,
    });

    // Make request with custom headers
    await fetch(`http://localhost:${port}/api/test`, {
      method: 'POST',
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
        'Content-Type': 'application/json',
        'X-Custom-Header': 'custom-value',
        Accept: 'application/json, text/plain',
        Authorization: 'Bearer token123',
      },
      body: JSON.stringify({ test: 'data' }),
    });

    await server.stop();

    // Verify span was created with header attributes
    expect(startSpanSpy).toHaveBeenCalledTimes(1);
    expect(startSpanSpy).toHaveBeenLastCalledWith(
      expect.objectContaining({
        attributes: expect.objectContaining({
          'sentry.origin': 'auto.http.bun.serve',
          'http.request.method': 'POST',
          'sentry.source': 'url',
          'url.path': '/api/test',
          'url.full': `http://localhost:${port}/api/test`,
          'url.port': port.toString(),
          'url.scheme': 'http:',
          'url.domain': 'localhost',
          // HTTP headers as span attributes following OpenTelemetry semantic conventions
          'http.request.header.user_agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
          'http.request.header.content_type': 'application/json',
          'http.request.header.x_custom_header': 'custom-value',
          'http.request.header.accept': 'application/json, text/plain',
          'http.request.header.accept_encoding': 'gzip, deflate, br, zstd',
          'http.request.header.connection': 'keep-alive',
          'http.request.header.content_length': '15',
          'http.request.header.host': expect.any(String),
        }),
        op: 'http.server',
        name: 'POST /api/test',
      }),
      expect.any(Function),
    );
  });

  test('skips span creation for OPTIONS and HEAD requests', async () => {
    const server = Bun.serve({
      async fetch(_req) {
        return new Response('Bun!');
      },
      port,",0
"import type { ExecutionContext, IncomingRequestCfProperties } from '@cloudflare/workers-types';
import {
  captureException,
  continueTrace,
  flush,
  getHttpSpanDetailsFromUrlObject,
  httpHeadersToSpanAttributes,
  parseStringToURLObject,
  SEMANTIC_ATTRIBUTE_SENTRY_OP,
  setHttpStatus,
  startSpan,
  winterCGHeadersToDict,
  withIsolationScope,
} from '@sentry/core';
import type { CloudflareOptions } from './client';
import { addCloudResourceContext, addCultureContext, addRequest } from './scope-utils';
import { init } from './sdk';

interface RequestHandlerWrapperOptions {
  options: CloudflareOptions;
  request: Request<unknown, IncomingRequestCfProperties<unknown>>;
  context: ExecutionContext;
  /**
   * If true, errors will be captured, rethrown and sent to Sentry.
   * Otherwise, errors are rethrown but not captured.
   *
   * You most likely don't want to set this to `false`, if you use `wrapRequestHandler` directly.
   * This is primarily meant as an escape hatch for higher-level SDKs relying on additional error
   * capturing mechanisms where this wrapper captures errors too early or too generally.
   *
   * @default true
   */
  captureErrors?: boolean;
}

/**
 * Wraps a cloudflare request handler in Sentry instrumentation
 */
export function wrapRequestHandler(
  wrapperOptions: RequestHandlerWrapperOptions,
  handler: (...args: unknown[]) => Response | Promise<Response>,
): Promise<Response> {
  return withIsolationScope(async isolationScope => {
    const { options, request, captureErrors = true } = wrapperOptions;

    // In certain situations, the passed context can become undefined.
    // For example, for Astro while prerendering pages at build time.
    // see: https://github.com/getsentry/sentry-javascript/issues/13217
    const context = wrapperOptions.context as ExecutionContext | undefined;

    const waitUntil = context?.waitUntil?.bind?.(context);

    const client = init({ ...options, ctx: context });
    isolationScope.setClient(client);

    const urlObject = parseStringToURLObject(request.url);
    const [name, attributes] = getHttpSpanDetailsFromUrlObject(urlObject, 'server', 'auto.http.cloudflare', request);

    const contentLength = request.headers.get('content-length');
    if (contentLength) {
      attributes['http.request.body.size'] = parseInt(contentLength, 10);
    }

    const userAgentHeader = request.headers.get('user-agent');
    if (userAgentHeader) {
      attributes['user_agent.original'] = userAgentHeader;
    }

    const sendDefaultPii = options.sendDefaultPii ?? false;
    Object.assign(attributes, httpHeadersToSpanAttributes(winterCGHeadersToDict(request.headers), sendDefaultPii));

    attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP] = 'http.server';

    addCloudResourceContext(isolationScope);
    addRequest(isolationScope, request);
    if (request.cf) {
      addCultureContext(isolationScope, request.cf);",0
"          'network.protocol.name': 'HTTP/1.1',
          'url.scheme': 'https:',
          'url.path': '/',
          'sentry.sample_rate': 1,
          'http.response.status_code': 200,
          'http.request.body.size': 10,
          'http.request.header.content_length': '10',
        },
        op: 'http.server',
        origin: 'auto.http.cloudflare',
        span_id: expect.stringMatching(/[a-f0-9]{16}/),
        status: 'ok',
        trace_id: expect.stringMatching(/[a-f0-9]{32}/),",0
"export {
  winterCGHeadersToDict,
  winterCGRequestToRequestData,
  httpRequestToRequestData,
  extractQueryParamsFromUrl,
  headersToDict,
  httpHeadersToSpanAttributes,
} from './utils/request';
export { DEFAULT_ENVIRONMENT } from './constants';
export { addBreadcrumb } from './breadcrumbs';
export { functionToStringIntegration } from './integrations/functiontostring';
// eslint-disable-next-line deprecation/deprecation
export { inboundFiltersIntegration } from './integrations/eventFilters';",0
"    return `${protocol}://${host}${url}`;
  }

  return undefined;
}

// ""-user"" because otherwise it would match ""user-agent""
const SENSITIVE_HEADER_SNIPPETS = ['auth', 'token', 'secret', 'cookie', '-user', 'password', 'key'];

/**
 * Converts incoming HTTP request headers to OpenTelemetry span attributes following semantic conventions.
 * Header names are converted to the format: http.request.header.<key>
 * where <key> is the header name in lowercase with dashes converted to underscores.
 *
 * @see https://opentelemetry.io/docs/specs/semconv/registry/attributes/http/#http-request-header
 */
export function httpHeadersToSpanAttributes(
  headers: Record<string, string | string[] | undefined>,
  sendDefaultPii: boolean = false,
): Record<string, string> {
  const spanAttributes: Record<string, string> = {};

  try {
    Object.entries(headers).forEach(([key, value]) => {
      if (value !== undefined) {
        const lowerCasedKey = key.toLowerCase();

        if (!sendDefaultPii && SENSITIVE_HEADER_SNIPPETS.some(snippet => lowerCasedKey.includes(snippet))) {
          return;
        }

        const normalizedKey = `http.request.header.${lowerCasedKey.replace(/-/g, '_')}`;

        if (Array.isArray(value)) {
          spanAttributes[normalizedKey] = value.map(v => (v !== null && v !== undefined ? String(v) : v)).join(';');
        } else if (typeof value === 'string') {
          spanAttributes[normalizedKey] = value;
        }
      }
    });
  } catch {
    // Return empty object if there's an error
  }

  return spanAttributes;
}

/** Extract the query params from an URL. */
export function extractQueryParamsFromUrl(url: string): string | undefined {
  // url is path and query string
  if (!url) {
    return;
  }",0
"import { describe, expect, it } from 'vitest';
import {
  extractQueryParamsFromUrl,
  headersToDict,
  httpHeadersToSpanAttributes,
  httpRequestToRequestData,
  winterCGHeadersToDict,
  winterCGRequestToRequestData,
} from '../../../src/utils/request';

describe('request utils', () => {
  describe('winterCGHeadersToDict', () => {
    it('works with invalid headers object', () => {
      expect(winterCGHeadersToDict({} as any)).toEqual({});
    });

    it('works with header object', () => {
      expect(
        winterCGHeadersToDict({
          forEach: (callbackfn: (value: unknown, key: string) => void): void => {
            callbackfn('value1', 'key1');
            callbackfn(['value2'], 'key2');
            callbackfn('value3', 'key3');
          },
        } as any),
      ).toEqual({
        key1: 'value1',
        key3: 'value3',
      });
    });
  });

  describe('headersToDict', () => {
    it('works with empty object', () => {
      expect(headersToDict({})).toEqual({});
    });

    it('works with plain object', () => {
      expect(
        headersToDict({
          key1: 'value1',
          key2: ['value2'],
          key3: 'value3',
        }),
      ).toEqual({
        key1: 'value1',
        key3: 'value3',
      });
    });
  });

  describe('winterCGRequestToRequestData', () => {
    it('works', () => {
      const actual = winterCGRequestToRequestData({
        method: 'GET',
        url: 'http://example.com?foo=bar&baz=qux',
        headers: {
          forEach: (callbackfn: (value: unknown, key: string) => void): void => {
            callbackfn('value1', 'key1');
            callbackfn(['value2'], 'key2');
            callbackfn('value3', 'key3');
          },
        } as any,
        clone: () => ({}) as any,
      });

      expect(actual).toEqual({
        headers: {
          key1: 'value1',
          key3: 'value3',
        },
        method: 'GET',
        query_string: 'foo=bar&baz=qux',
        url: 'http://example.com?foo=bar&baz=qux',
      });
    });
  });

  describe('httpRequestToRequestData', () => {
    it('works with minimal request', () => {
      const actual = httpRequestToRequestData({});
      expect(actual).toEqual({
        headers: {},
      });
    });

    it('works with absolute URL request', () => {
      const actual = httpRequestToRequestData({
        method: 'GET',
        url: 'http://example.com/blabla?xx=a&yy=z',
        headers: {
          key1: 'value1',
          key2: ['value2'],
          key3: 'value3',
        },
      });

      expect(actual).toEqual({
        method: 'GET',
        url: 'http://example.com/blabla?xx=a&yy=z',
        headers: {
          key1: 'value1',
          key3: 'value3',
        },
        query_string: 'xx=a&yy=z',
      });
    });

    it('works with relative URL request without host', () => {
      const actual = httpRequestToRequestData({
        method: 'GET',
        url: '/blabla',
        headers: {
          key1: 'value1',
          key2: ['value2'],
          key3: 'value3',
        },
      });

      expect(actual).toEqual({
        method: 'GET',
        headers: {
          key1: 'value1',
          key3: 'value3',
        },
      });
    });

    it('works with relative URL request with host', () => {
      const actual = httpRequestToRequestData({
        url: '/blabla',
        headers: {
          host: 'example.com',
        },
      });

      expect(actual).toEqual({
        url: 'http://example.com/blabla',
        headers: {
          host: 'example.com',
        },
      });
    });

    it('works with relative URL request with host & protocol', () => {
      const actual = httpRequestToRequestData({
        url: '/blabla',
        headers: {
          host: 'example.com',
        },
        protocol: 'https',
      });

      expect(actual).toEqual({
        url: 'https://example.com/blabla',
        headers: {
          host: 'example.com',
        },
      });
    });

    it('works with relative URL request with host & socket', () => {
      const actual = httpRequestToRequestData({
        url: '/blabla',
        headers: {
          host: 'example.com',
        },
        socket: {
          encrypted: true,
        },
      });

      expect(actual).toEqual({
        url: 'https://example.com/blabla',
        headers: {
          host: 'example.com',
        },
      });
    });

    it('extracts non-standard cookies', () => {
      const actual = httpRequestToRequestData({
        cookies: { xx: 'a', yy: 'z' },
      } as any);

      expect(actual).toEqual({
        headers: {},
        cookies: { xx: 'a', yy: 'z' },
      });
    });

    it('extracts non-standard body', () => {
      const actual = httpRequestToRequestData({
        body: { xx: 'a', yy: 'z' },
      } as any);

      expect(actual).toEqual({
        headers: {},
        data: { xx: 'a', yy: 'z' },
      });
    });

    describe('x-forwarded headers support', () => {
      it('should prioritize x-forwarded-proto header over explicit protocol parameter', () => {
        const actual = httpRequestToRequestData({
          url: '/test',
          headers: {
            host: 'example.com',
            'x-forwarded-proto': 'https',
          },
          protocol: 'http',
        });

        expect(actual).toEqual({
          url: 'https://example.com/test',
          headers: {
            host: 'example.com',
            'x-forwarded-proto': 'https',
          },
        });
      });

      it('should prioritize x-forwarded-proto header even when downgrading from https to http', () => {
        const actual = httpRequestToRequestData({
          url: '/test',
          headers: {
            host: 'example.com',
            'x-forwarded-proto': 'http',
          },
          protocol: 'https',
        });

        expect(actual).toEqual({
          url: 'http://example.com/test',
          headers: {
            host: 'example.com',
            'x-forwarded-proto': 'http',
          },
        });
      });

      it('should prioritize x-forwarded-proto header over socket encryption detection', () => {
        const actual = httpRequestToRequestData({
          url: '/test',
          headers: {
            host: 'example.com',
            'x-forwarded-proto': 'https',
          },
          socket: {
            encrypted: false,
          },
        });

        expect(actual).toEqual({
          url: 'https://example.com/test',
          headers: {
            host: 'example.com',
            'x-forwarded-proto': 'https',
          },
        });
      });

      it('should prioritize x-forwarded-host header over standard host header', () => {
        const actual = httpRequestToRequestData({
          url: '/test',
          headers: {
            host: 'localhost:3000',
            'x-forwarded-host': 'example.com',
            'x-forwarded-proto': 'https',
          },
        });

        expect(actual).toEqual({
          url: 'https://example.com/test',
          headers: {
            host: 'localhost:3000',
            'x-forwarded-host': 'example.com',
            'x-forwarded-proto': 'https',
          },
        });
      });

      it('should construct URL correctly when both x-forwarded-proto and x-forwarded-host are present', () => {
        const actual = httpRequestToRequestData({
          method: 'POST',
          url: '/api/test?param=value',
          headers: {
            host: 'localhost:3000',
            'x-forwarded-host': 'api.example.com',
            'x-forwarded-proto': 'https',
            'content-type': 'application/json',
          },
          protocol: 'http',
        });

        expect(actual).toEqual({
          method: 'POST',
          url: 'https://api.example.com/api/test?param=value',
          query_string: 'param=value',
          headers: {
            host: 'localhost:3000',
            'x-forwarded-host': 'api.example.com',
            'x-forwarded-proto': 'https',
            'content-type': 'application/json',
          },
        });
      });

      it('should fall back to standard headers when x-forwarded headers are not present', () => {
        const actual = httpRequestToRequestData({
          url: '/test',
          headers: {
            host: 'example.com',
          },
          protocol: 'https',
        });

        expect(actual).toEqual({
          url: 'https://example.com/test',
          headers: {
            host: 'example.com',
          },
        });
      });

      it('should ignore x-forwarded headers when they contain non-string values', () => {
        const actual = httpRequestToRequestData({
          url: '/test',
          headers: {
            host: 'example.com',
            'x-forwarded-host': ['forwarded.example.com'] as any,
            'x-forwarded-proto': ['https'] as any,
          },
          protocol: 'http',
        });

        expect(actual).toEqual({
          url: 'http://example.com/test',
          headers: {
            host: 'example.com',
          },
        });
      });

      it('should correctly transform localhost request to public URL using x-forwarded headers', () => {
        const actual = httpRequestToRequestData({
          method: 'GET',
          url: '/',
          headers: {
            host: 'localhost:3000',
            'x-forwarded-proto': 'https',
            'x-forwarded-host': 'example.com',
          },
        });

        expect(actual).toEqual({
          method: 'GET',
          url: 'https://example.com/',
          headers: {
            host: 'localhost:3000',
            'x-forwarded-proto': 'https',
            'x-forwarded-host': 'example.com',
          },
        });
      });

      it('should respect x-forwarded-proto even when it downgrades from encrypted socket', () => {
        const actual = httpRequestToRequestData({
          url: '/test',
          headers: {
            host: 'example.com',
            'x-forwarded-proto': 'http',
          },
          socket: {
            encrypted: true,
          },
        });

        expect(actual).toEqual({
          url: 'http://example.com/test',
          headers: {
            host: 'example.com',
            'x-forwarded-proto': 'http',
          },
        });
      });

      it('should preserve query parameters when constructing URL with x-forwarded headers', () => {
        const actual = httpRequestToRequestData({
          method: 'GET',
          url: '/search?q=test&category=api',
          headers: {
            host: 'localhost:8080',
            'x-forwarded-host': 'search.example.com',
            'x-forwarded-proto': 'https',
          },
        });

        expect(actual).toEqual({
          method: 'GET',
          url: 'https://search.example.com/search?q=test&category=api',
          query_string: 'q=test&category=api',
          headers: {
            host: 'localhost:8080',
            'x-forwarded-host': 'search.example.com',
            'x-forwarded-proto': 'https',
          },
        });
      });
    });
  });

  describe('extractQueryParamsFromUrl', () => {
    it.each([
      ['/', undefined],
      ['http://example.com', undefined],
      ['/sub-path', undefined],
      ['/sub-path?xx=a&yy=z', 'xx=a&yy=z'],
      ['http://example.com/sub-path?xx=a&yy=z', 'xx=a&yy=z'],
    ])('works with %s', (url, expected) => {
      expect(extractQueryParamsFromUrl(url)).toEqual(expected);
    });
  });

  describe('httpHeadersToSpanAttributes', () => {
    it('works with empty headers object', () => {
      expect(httpHeadersToSpanAttributes({})).toEqual({});
    });

    it('converts single string header values to strings', () => {
      const headers = {
        'Content-Type': 'application/json',
        'user-agent': 'test-agent',
      };

      const result = httpHeadersToSpanAttributes(headers);

      expect(result).toEqual({
        'http.request.header.content_type': 'application/json',
        'http.request.header.user_agent': 'test-agent',
      });
    });

    it('handles array header values by joining with semicolons', () => {
      const headers = {
        'custom-header': ['value1', 'value2'],
        accept: ['application/json', 'text/html'],
      };

      const result = httpHeadersToSpanAttributes(headers);

      expect(result).toEqual({
        'http.request.header.custom_header': 'value1;value2',
        'http.request.header.accept': 'application/json;text/html',
      });
    });

    it('filters undefined values in arrays when joining', () => {
      const headers = {
        'undefined-values': [undefined, undefined],
        'valid-header': 'valid-value',
      } as any;

      const result = httpHeadersToSpanAttributes(headers);

      expect(result).toEqual({
        'http.request.header.valid_header': 'valid-value',
        'http.request.header.undefined_values': ';',
      });
    });

    it('ignores undefined header values', () => {
      const headers = {
        'valid-header': 'valid-value',
        'undefined-header': undefined,
      };

      const result = httpHeadersToSpanAttributes(headers);

      expect(result).toEqual({
        'http.request.header.valid_header': 'valid-value',
      });
    });

    it('adds empty array headers as empty string', () => {
      const headers = {
        'empty-header': [],
        'valid-header': 'valid-value',
      } as any;

      const result = httpHeadersToSpanAttributes(headers);

      expect(result).toEqual({
        'http.request.header.empty_header': '',
        'http.request.header.valid_header': 'valid-value',
      });
    });

    it('converts header names to lowercase and replaces dashes with underscores', () => {
      const headers = {
        'Content-Type': 'application/json',
        'X-CUSTOM-HEADER': 'custom-value',
        'user-Agent': 'test-agent',
        ACCEPT: 'text/html',
      };

      const result = httpHeadersToSpanAttributes(headers);

      expect(result).toEqual({
        'http.request.header.content_type': 'application/json',
        'http.request.header.x_custom_header': 'custom-value',
        'http.request.header.user_agent': 'test-agent',
        'http.request.header.accept': 'text/html',
      });
    });

    it('handles real-world headers', () => {
      const headers = {
        Host: 'example.com',
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
        Accept: 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
        'Accept-Language': 'en-US,en;q=0.5',
        'Accept-Encoding': 'gzip, deflate',
        Connection: 'keep-alive',
        'Upgrade-Insecure-Requests': '1',
        'Cache-Control': 'no-cache',
        'X-Forwarded-For': '192.168.1.1',
      };

      const result = httpHeadersToSpanAttributes(headers);

      expect(result).toEqual({
        'http.request.header.host': 'example.com',
        'http.request.header.user_agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
        'http.request.header.accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
        'http.request.header.accept_language': 'en-US,en;q=0.5',
        'http.request.header.accept_encoding': 'gzip, deflate',
        'http.request.header.connection': 'keep-alive',
        'http.request.header.upgrade_insecure_requests': '1',
        'http.request.header.cache_control': 'no-cache',
        'http.request.header.x_forwarded_for': '192.168.1.1',
      });
    });

    it('handles multiple values for the same header by joining with semicolons', () => {
      const headers = {
        'x-random-header': ['test=abc123', 'preferences=dark-mode', 'number=three'],
        Accept: ['application/json', 'text/html'],
      };

      const result = httpHeadersToSpanAttributes(headers);

      expect(result).toEqual({
        'http.request.header.x_random_header': 'test=abc123;preferences=dark-mode;number=three',
        'http.request.header.accept': 'application/json;text/html',
      });
    });

    it('handles headers with empty string values', () => {
      const headers = {
        'empty-header': '',
        'valid-header': 'valid-value',
      };

      const result = httpHeadersToSpanAttributes(headers);

      expect(result).toEqual({
        'http.request.header.empty_header': '',
        'http.request.header.valid_header': 'valid-value',
      });
    });

    it('returns empty object when processing invalid headers throws error', () => {
      // Create a headers object that will throw an error when iterated
      const headers = {};
      Object.defineProperty(headers, Symbol.iterator, {
        get() {
          throw new Error('Test error');
        },
      });

      const result = httpHeadersToSpanAttributes(headers);

      expect(result).toEqual({});
    });

    it('stringifies non-string values (except null) in arrays and joins them', () => {
      const headers = {
        'mixed-types': ['string-value', 123, true, null],
      } as any;

      const result = httpHeadersToSpanAttributes(headers);

      expect(result).toEqual({
        'http.request.header.mixed_types': 'string-value;123;true;',
      });
    });

    it('ignores non-string and non-array header values', () => {
      const headers = {
        'string-header': 'valid-value',
        'number-header': 123,
        'boolean-header': true,
        'null-header': null,
        'object-header': { key: 'value' },
      } as any;

      const result = httpHeadersToSpanAttributes(headers);

      expect(result).toEqual({
        'http.request.header.string_header': 'valid-value',
      });
    });

    describe('PII filtering', () => {
      it('filters out sensitive headers when sendDefaultPii is false (default)', () => {
        const headers = {
          'Content-Type': 'application/json',
          'User-Agent': 'test-agent',
          Authorization: 'Bearer secret-token',
          Cookie: 'session=abc123',
          'X-API-Key': 'api-key-123',
          'X-Auth-Token': 'auth-token-456',
        };

        const result = httpHeadersToSpanAttributes(headers, false);

        expect(result).toEqual({
          'http.request.header.content_type': 'application/json',
          'http.request.header.user_agent': 'test-agent',
          // Sensitive headers should be filtered out
        });
      });

      it('includes sensitive headers when sendDefaultPii is true', () => {
        const headers = {
          'Content-Type': 'application/json',
          'User-Agent': 'test-agent',
          Authorization: 'Bearer secret-token',
          Cookie: 'session=abc123',
          'X-API-Key': 'api-key-123',
        };

        const result = httpHeadersToSpanAttributes(headers, true);

        expect(result).toEqual({
          'http.request.header.content_type': 'application/json',
          'http.request.header.user_agent': 'test-agent',
          'http.request.header.authorization': 'Bearer secret-token',
          'http.request.header.cookie': 'session=abc123',
          'http.request.header.x_api_key': 'api-key-123',
        });
      });

      it('filters sensitive headers case-insensitively', () => {
        const headers = {
          AUTHORIZATION: 'Bearer secret-token',
          Cookie: 'session=abc123',
          'x-api-key': 'key-123',
          'Content-Type': 'application/json',
        };

        const result = httpHeadersToSpanAttributes(headers, false);

        expect(result).toEqual({
          'http.request.header.content_type': 'application/json',
        });
      });

      it('filters comprehensive list of sensitive headers', () => {
        const headers = {
          'Content-Type': 'application/json',
          'User-Agent': 'test-agent',
          Accept: 'application/json',
          Host: 'example.com',

          // Should be filtered
          Authorization: 'Bearer token',
          Cookie: 'session=123',
          'Set-Cookie': 'session=456',
          'X-API-Key': 'key',
          'X-Auth-Token': 'token',
          'X-Secret': 'secret',
          'x-secret-key': 'another-secret',
          'WWW-Authenticate': 'Basic',
          'Proxy-Authorization': 'Basic auth',
          'X-Access-Token': 'access',
          'X-CSRF-Token': 'csrf',
          'X-XSRF-Token': 'xsrf',
          'X-Session-Token': 'session',
          'X-Password': 'password',
          'X-Private-Key': 'private',
          'X-Forwarded-user': 'user',
          'X-Forwarded-authorization': 'auth',
        };

        const result = httpHeadersToSpanAttributes(headers, false);

        expect(result).toEqual({
          'http.request.header.content_type': 'application/json',
          'http.request.header.user_agent': 'test-agent',
          'http.request.header.accept': 'application/json',
          'http.request.header.host': 'example.com',
        });
      });
    });
  });
});",0
"  defaultStackParser,
  lastEventId,
  flush,
  close,
  getSentryRelease,
  createGetModuleFromFilename,
  httpHeadersToSpanAttributes,
  winterCGHeadersToDict,
  // eslint-disable-next-line deprecation/deprecation
  anrIntegration,
  // eslint-disable-next-line deprecation/deprecation
  disableAnrDetectionForCallback,
  consoleIntegration,
  httpIntegration,",0
"  startSpanManual,
  vercelWaitUntil,
  withIsolationScope,
} from '@sentry/core';
import type { NextApiRequest } from 'next';
import type { AugmentedNextApiResponse, NextApiHandler } from '../types';
import { addHeadersAsAttributes } from '../utils/addHeadersAsAttributes';
import { flushSafelyWithTimeout } from '../utils/responseEnd';
import { dropNextjsRootContext, escapeNextjsTracing } from '../utils/tracingUtils';

export type AugmentedNextApiRequest = NextApiRequest & {
  __withSentry_applied__?: boolean;
};

/**
 * Wrap the given API route handler with error nad performance monitoring.
 *
 * @param apiHandler The handler exported from the user's API page route file, which may or may not already be
 * wrapped with `withSentry`
 * @param parameterizedRoute The page's parameterized route.
 * @returns The wrapped handler which will always return a Promise.
 */
export function wrapApiHandlerWithSentry(apiHandler: NextApiHandler, parameterizedRoute: string): NextApiHandler {
  return new Proxy(apiHandler, {
    apply: (
      wrappingTarget,
      thisArg,
      args: [AugmentedNextApiRequest | undefined, AugmentedNextApiResponse | undefined],
    ) => {
      dropNextjsRootContext();
      return escapeNextjsTracing(() => {
        const [req, res] = args;

        if (!req) {
          debug.log(
            `Wrapped API handler on route ""${parameterizedRoute}"" was not passed a request object. Will not instrument.`,
          );
          return wrappingTarget.apply(thisArg, args);
        } else if (!res) {
          debug.log(
            `Wrapped API handler on route ""${parameterizedRoute}"" was not passed a response object. Will not instrument.`,
          );
          return wrappingTarget.apply(thisArg, args);
        }

        // Prevent double wrapping of the same request.
        if (req.__withSentry_applied__) {
          return wrappingTarget.apply(thisArg, args);
        }
        req.__withSentry_applied__ = true;

        return withIsolationScope(isolationScope => {
          // Normally, there is an active span here (from Next.js OTEL) and we just use that as parent
          // Else, we manually continueTrace from the incoming headers
          const continueTraceIfNoActiveSpan = getActiveSpan()
            ? <T>(_opts: unknown, callback: () => T) => callback()
            : continueTrace;

          return continueTraceIfNoActiveSpan(
            {
              sentryTrace:
                req.headers && isString(req.headers['sentry-trace']) ? req.headers['sentry-trace'] : undefined,
              baggage: req.headers?.baggage,
            },
            () => {
              const reqMethod = `${(req.method || 'GET').toUpperCase()} `;
              const normalizedRequest = httpRequestToRequestData(req);

              isolationScope.setSDKProcessingMetadata({ normalizedRequest });
              isolationScope.setTransactionName(`${reqMethod}${parameterizedRoute}`);

              return startSpanManual(
                {
                  name: `${reqMethod}${parameterizedRoute}`,
                  op: 'http.server',
                  forceTransaction: true,
                  attributes: {
                    [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'route',
                    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.nextjs',
                    ...addHeadersAsAttributes(normalizedRequest.headers || {}),
                  },
                },
                async span => {
                  // eslint-disable-next-line @typescript-eslint/unbound-method
                  res.end = new Proxy(res.end, {
                    apply(target, thisArg, argArray) {",0
"  withIsolationScope,
  withScope,
} from '@sentry/core';
import type { GenerationFunctionContext } from '../common/types';
import { isNotFoundNavigationError, isRedirectNavigationError } from './nextNavigationErrorUtils';
import { TRANSACTION_ATTR_SENTRY_TRACE_BACKFILL } from './span-attributes-with-logic-attached';
import { addHeadersAsAttributes } from './utils/addHeadersAsAttributes';
import { commonObjectToIsolationScope, commonObjectToPropagationContext } from './utils/tracingUtils';
import { getSanitizedRequestUrl } from './utils/urls';
import { maybeExtractSynchronousParamsAndSearchParams } from './utils/wrapperUtils';
/**
 * Wraps a generation function (e.g. generateMetadata) with Sentry error and performance instrumentation.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function wrapGenerationFunctionWithSentry<F extends (...args: any[]) => any>(
  generationFunction: F,
  context: GenerationFunctionContext,
): F {
  const { requestAsyncStorage, componentRoute, componentType, generationFunctionIdentifier } = context;
  return new Proxy(generationFunction, {
    apply: (originalFunction, thisArg, args) => {
      const requestTraceId = getActiveSpan()?.spanContext().traceId;
      let headers: WebFetchHeaders | undefined = undefined;
      // We try-catch here just in case anything goes wrong with the async storage here goes wrong since it is Next.js internal API
      try {
        headers = requestAsyncStorage?.getStore()?.headers;
      } catch {
        /** empty */
      }

      const isolationScope = commonObjectToIsolationScope(headers);
      let pathname = undefined as string | undefined;

      const activeSpan = getActiveSpan();
      if (activeSpan) {
        const rootSpan = getRootSpan(activeSpan);
        const { scope } = getCapturedScopesOnSpan(rootSpan);
        setCapturedScopesOnSpan(rootSpan, scope ?? new Scope(), isolationScope);

        const spanData = spanToJSON(rootSpan);

        if (spanData.data && 'http.target' in spanData.data) {
          pathname = spanData.data['http.target'] as string;
        }
      }

      const headersDict = headers ? winterCGHeadersToDict(headers) : undefined;

      if (activeSpan) {
        const rootSpan = getRootSpan(activeSpan);
        addHeadersAsAttributes(headers, rootSpan);
      }

      let data: Record<string, unknown> | undefined = undefined;
      if (getClient()?.getOptions().sendDefaultPii) {
        const props: unknown = args[0];
        const { params, searchParams } = maybeExtractSynchronousParamsAndSearchParams(props);
        data = { params, searchParams };
      }",0
"  setCapturedScopesOnSpan,
  startSpan,
  vercelWaitUntil,
  winterCGRequestToRequestData,
  withIsolationScope,
} from '@sentry/core';
import { addHeadersAsAttributes } from '../common/utils/addHeadersAsAttributes';
import { flushSafelyWithTimeout } from '../common/utils/responseEnd';
import type { EdgeRouteHandler } from '../edge/types';

/**
 * Wraps Next.js middleware with Sentry error and performance instrumentation.
 *
 * @param middleware The middleware handler.
 * @returns a wrapped middleware handler.
 */
export function wrapMiddlewareWithSentry<H extends EdgeRouteHandler>(
  middleware: H,
): (...params: Parameters<H>) => Promise<ReturnType<H>> {
  return new Proxy(middleware, {
    apply: async (wrappingTarget, thisArg, args: Parameters<H>) => {
      const tunnelRoute =
        '_sentryRewritesTunnelPath' in globalThis
          ? (globalThis as Record<string, unknown>)._sentryRewritesTunnelPath
          : undefined;

      if (tunnelRoute && typeof tunnelRoute === 'string') {
        const req: unknown = args[0];
        // Check if the current request matches the tunnel route
        if (req instanceof Request) {
          const url = new URL(req.url);
          const isTunnelRequest = url.pathname.startsWith(tunnelRoute);

          if (isTunnelRequest) {
            // Create a simple response that mimics NextResponse.next() so we don't need to import internals here
            // which breaks next 13 apps
            // https://github.com/vercel/next.js/blob/c12c9c1f78ad384270902f0890dc4cd341408105/packages/next/src/server/web/spec-extension/response.ts#L146
            return new Response(null, {
              status: 200,
              headers: {
                'x-middleware-next': '1',
              },
            }) as ReturnType<H>;
          }
        }
      }
      // TODO: We still should add central isolation scope creation for when our build-time instrumentation does not work anymore with turbopack.
      return withIsolationScope(isolationScope => {
        const req: unknown = args[0];
        const currentScope = getCurrentScope();

        let spanName: string;
        let spanSource: TransactionSource;
        let headerAttributes: Record<string, string> = {};

        if (req instanceof Request) {
          isolationScope.setSDKProcessingMetadata({
            normalizedRequest: winterCGRequestToRequestData(req),
          });
          spanName = `middleware ${req.method} ${new URL(req.url).pathname}`;
          spanSource = 'url';

          headerAttributes = addHeadersAsAttributes(req.headers);
        } else {
          spanName = 'middleware';
          spanSource = 'component';
        }

        currentScope.setTransactionName(spanName);

        const activeSpan = getActiveSpan();

        if (activeSpan) {
          // If there is an active span, it likely means that the automatic Next.js OTEL instrumentation worked and we can
          // rely on that for parameterization.
          spanName = 'middleware';
          spanSource = 'component';

          const rootSpan = getRootSpan(activeSpan);
          if (rootSpan) {
            setCapturedScopesOnSpan(rootSpan, currentScope, isolationScope);
            rootSpan.setAttributes(headerAttributes);
          }
        }

        return startSpan(
          {
            name: spanName,
            op: 'http.server.middleware',
            attributes: {
              [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: spanSource,
              [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.nextjs.wrapMiddlewareWithSentry',
              ...headerAttributes,
            },
          },
          () => {
            return handleCallbackErrors(
              () => wrappingTarget.apply(thisArg, args),
              error => {",0
"  winterCGHeadersToDict,
  withIsolationScope,
  withScope,
} from '@sentry/core';
import { isNotFoundNavigationError, isRedirectNavigationError } from './nextNavigationErrorUtils';
import type { RouteHandlerContext } from './types';
import { addHeadersAsAttributes } from './utils/addHeadersAsAttributes';
import { flushSafelyWithTimeout } from './utils/responseEnd';
import { commonObjectToIsolationScope } from './utils/tracingUtils';

/**
 * Wraps a Next.js App Router Route handler with Sentry error and performance instrumentation.
 *
 * NOTICE: This wrapper is for App Router API routes. If you are looking to wrap Pages Router API routes use `wrapApiHandlerWithSentry` instead.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function wrapRouteHandlerWithSentry<F extends (...args: any[]) => any>(
  routeHandler: F,
  context: RouteHandlerContext,
): (...args: Parameters<F>) => ReturnType<F> extends Promise<unknown> ? ReturnType<F> : Promise<ReturnType<F>> {
  const { method, parameterizedRoute, headers } = context;

  return new Proxy(routeHandler, {
    apply: async (originalFunction, thisArg, args) => {
      const activeSpan = getActiveSpan();
      const rootSpan = activeSpan ? getRootSpan(activeSpan) : undefined;

      if (rootSpan && process.env.NEXT_RUNTIME !== 'edge') {
        addHeadersAsAttributes(headers, rootSpan);
      }

      let edgeRuntimeIsolationScopeOverride: Scope | undefined;
      if (rootSpan && process.env.NEXT_RUNTIME === 'edge') {
        const isolationScope = commonObjectToIsolationScope(headers);
        const { scope } = getCapturedScopesOnSpan(rootSpan);
        setCapturedScopesOnSpan(rootSpan, scope ?? new Scope(), isolationScope);

        edgeRuntimeIsolationScopeOverride = isolationScope;

        rootSpan.updateName(`${method} ${parameterizedRoute}`);
        rootSpan.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, 'route');
        rootSpan.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_OP, 'http.server');
        addHeadersAsAttributes(headers, rootSpan);
      }

      return withIsolationScope(
        process.env.NEXT_RUNTIME === 'edge' ? edgeRuntimeIsolationScopeOverride : getIsolationScope(),
        () => {
          return withScope(async scope => {",0
"  withScope,
} from '@sentry/core';
import { isNotFoundNavigationError, isRedirectNavigationError } from '../common/nextNavigationErrorUtils';
import type { ServerComponentContext } from '../common/types';
import { flushSafelyWithTimeout } from '../common/utils/responseEnd';
import { TRANSACTION_ATTR_SENTRY_TRACE_BACKFILL } from './span-attributes-with-logic-attached';
import { addHeadersAsAttributes } from './utils/addHeadersAsAttributes';
import { commonObjectToIsolationScope, commonObjectToPropagationContext } from './utils/tracingUtils';
import { getSanitizedRequestUrl } from './utils/urls';
import { maybeExtractSynchronousParamsAndSearchParams } from './utils/wrapperUtils';

/**
 * Wraps an `app` directory server component with Sentry error instrumentation.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function wrapServerComponentWithSentry<F extends (...args: any[]) => any>(
  appDirComponent: F,
  context: ServerComponentContext,
): F {
  const { componentRoute, componentType } = context;
  // Even though users may define server components as async functions, for the client bundles
  // Next.js will turn them into synchronous functions and it will transform any `await`s into instances of the `use`
  // hook. 🤯
  return new Proxy(appDirComponent, {
    apply: (originalFunction, thisArg, args) => {
      const requestTraceId = getActiveSpan()?.spanContext().traceId;
      const isolationScope = commonObjectToIsolationScope(context.headers);

      let pathname = undefined as string | undefined;
      const activeSpan = getActiveSpan();
      if (activeSpan) {
        const rootSpan = getRootSpan(activeSpan);
        const { scope } = getCapturedScopesOnSpan(rootSpan);
        setCapturedScopesOnSpan(rootSpan, scope ?? new Scope(), isolationScope);

        const spanData = spanToJSON(rootSpan);

        if (spanData.data && 'http.target' in spanData.data) {
          pathname = spanData.data['http.target']?.toString();
        }
      }

      const headersDict = context.headers ? winterCGHeadersToDict(context.headers) : undefined;

      if (activeSpan) {
        const rootSpan = getRootSpan(activeSpan);
        addHeadersAsAttributes(context.headers, rootSpan);
      }

      let params: Record<string, string> | undefined = undefined;

      if (getClient()?.getOptions().sendDefaultPii) {
        const props: unknown = args[0];
        const { params: paramsFromProps } = maybeExtractSynchronousParamsAndSearchParams(props);
        params = paramsFromProps;",0
"  setCapturedScopesOnSpan,
  startSpan,
  vercelWaitUntil,
  winterCGRequestToRequestData,
  withIsolationScope,
} from '@sentry/core';
import { addHeadersAsAttributes } from '../common/utils/addHeadersAsAttributes';
import { flushSafelyWithTimeout } from '../common/utils/responseEnd';
import type { EdgeRouteHandler } from './types';

/**
 * Wraps a Next.js edge route handler with Sentry error and performance instrumentation.
 */
export function wrapApiHandlerWithSentry<H extends EdgeRouteHandler>(
  handler: H,
  parameterizedRoute: string,
): (...params: Parameters<H>) => Promise<ReturnType<H>> {
  return new Proxy(handler, {
    apply: async (wrappingTarget, thisArg, args: Parameters<H>) => {
      // TODO: We still should add central isolation scope creation for when our build-time instrumentation does not work anymore with turbopack.

      return withIsolationScope(isolationScope => {
        const req: unknown = args[0];
        const currentScope = getCurrentScope();

        let headerAttributes: Record<string, string> = {};

        if (req instanceof Request) {
          isolationScope.setSDKProcessingMetadata({
            normalizedRequest: winterCGRequestToRequestData(req),
          });
          currentScope.setTransactionName(`${req.method} ${parameterizedRoute}`);

          headerAttributes = addHeadersAsAttributes(req.headers);
        } else {
          currentScope.setTransactionName(`handler (${parameterizedRoute})`);
        }

        let spanName: string;
        let op: string | undefined = 'http.server';

        // If there is an active span, it likely means that the automatic Next.js OTEL instrumentation worked and we can
        // rely on that for parameterization.
        const activeSpan = getActiveSpan();
        if (activeSpan) {
          spanName = `handler (${parameterizedRoute})`;
          op = undefined;

          const rootSpan = getRootSpan(activeSpan);
          if (rootSpan) {
            rootSpan.updateName(
              req instanceof Request ? `${req.method} ${parameterizedRoute}` : `handler ${parameterizedRoute}`,
            );
            rootSpan.setAttributes({
              [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'http.server',
              [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'route',
              ...headerAttributes,
            });
            setCapturedScopesOnSpan(rootSpan, currentScope, isolationScope);
          }
        } else if (req instanceof Request) {
          spanName = `${req.method} ${parameterizedRoute}`;
        } else {
          spanName = `handler ${parameterizedRoute}`;
        }

        return startSpan(
          {
            name: spanName,
            op: op,
            attributes: {
              [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'route',
              [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.nextjs.wrapApiHandlerWithSentry',
              ...headerAttributes,
            },
          },
          () => {
            return handleCallbackErrors(
              () => wrappingTarget.apply(thisArg, args),
              error => {",0
"
    expect(startSpanManualSpy).not.toHaveBeenCalled();
  });

  test('wrapped function sets route backfill attribute when called within an active span', async () => {
    const mockSetAttribute = vi.fn();
    const mockSetAttributes = vi.fn();
    const mockGetActiveSpan = vi.spyOn(SentryCore, 'getActiveSpan').mockReturnValue({
      setAttribute: mockSetAttribute,
      setAttributes: mockSetAttributes,
    } as any);
    const mockGetRootSpan = vi.spyOn(SentryCore, 'getRootSpan').mockReturnValue({
      setAttribute: mockSetAttribute,
      setAttributes: mockSetAttributes,
    } as any);

    const origFunction = vi.fn(async () => ({ props: {} }));
    const wrappedOriginal = wrapGetServerSidePropsWithSentry(origFunction, route);

    await wrappedOriginal({ req, res } as any);

    expect(mockGetActiveSpan).toHaveBeenCalled();
    expect(mockGetRootSpan).toHaveBeenCalled();
    expect(mockSetAttribute).toHaveBeenCalledWith('sentry.route_backfill', '/tricks/[trickName]');
  });

  test('wrapped function does not set route backfill attribute for /_error route', async () => {
    const mockSetAttribute = vi.fn();
    const mockSetAttributes = vi.fn();
    const mockGetActiveSpan = vi.spyOn(SentryCore, 'getActiveSpan').mockReturnValue({
      setAttribute: mockSetAttribute,
      setAttributes: mockSetAttributes,
    } as any);
    const mockGetRootSpan = vi.spyOn(SentryCore, 'getRootSpan').mockReturnValue({
      setAttribute: mockSetAttribute,
      setAttributes: mockSetAttributes,
    } as any);

    const origFunction = vi.fn(async () => ({ props: {} }));
    const wrappedOriginal = wrapGetServerSidePropsWithSentry(origFunction, '/_error');

    await wrappedOriginal({ req, res } as any);",0
"  debug,
  generateSpanId,
  getClient,
  getCurrentScope,
  getIsolationScope,
  getSpanStatusFromHttpCode,
  httpHeadersToSpanAttributes,
  httpRequestToRequestData,
  parseStringToURLObject,
  SEMANTIC_ATTRIBUTE_SENTRY_OP,
  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,
  SPAN_STATUS_ERROR,
  stripUrlQueryAndFragment,
  withIsolationScope,
} from '@sentry/core';
import type EventEmitter from 'events';
import { errorMonitor } from 'events';
import type { ClientRequest, IncomingHttpHeaders, IncomingMessage, Server, ServerResponse } from 'http';
import type { Socket } from 'net';
import { DEBUG_BUILD } from '../../debug-build';
import type { NodeClient } from '../../sdk/client';
import { INSTRUMENTATION_NAME, MAX_BODY_BYTE_LENGTH } from './constants';

// Tree-shakable guard to remove all code related to tracing
declare const __SENTRY_TRACING__: boolean;

type ServerEmit = typeof Server.prototype.emit;

const HTTP_SERVER_INSTRUMENTED_KEY = createContextKey('sentry_http_server_instrumented');

const clientToRequestSessionAggregatesMap = new Map<
  Client,
  { [timestampRoundedToSeconds: string]: { exited: number; crashed: number; errored: number } }
>();

// We keep track of emit functions we wrapped, to avoid double wrapping
// We do this instead of putting a non-enumerable property on the function, because
// sometimes the property seems to be migrated to forks of the emit function, which we do not want to happen
// This was the case in the nestjs-distributed-tracing E2E test
const wrappedEmitFns = new WeakSet<ServerEmit>();

/**
 * Instrument a server to capture incoming requests.
 *
 */
export function instrumentServer(
  server: Server,
  {
    ignoreIncomingRequestBody,
    ignoreSpansForIncomingRequests,
    maxIncomingRequestBodySize = 'medium',
    trackIncomingRequestsAsSessions = true,
    spans,
    ignoreStaticAssets = true,
    sessionFlushingDelayMS,
    // eslint-disable-next-line deprecation/deprecation
    instrumentation,
    incomingRequestSpanHook,
  }: {
    ignoreIncomingRequestBody?: (url: string, request: IncomingMessage) => boolean;
    ignoreSpansForIncomingRequests?: (urlPath: string, request: IncomingMessage) => boolean;
    maxIncomingRequestBodySize?: 'small' | 'medium' | 'always' | 'none';
    trackIncomingRequestsAsSessions?: boolean;
    sessionFlushingDelayMS: number;
    spans: boolean;
    ignoreStaticAssets?: boolean;
    incomingRequestSpanHook?: (span: Span, request: IncomingMessage, response: ServerResponse) => void;
    /** @deprecated Use `incomingRequestSpanHook` instead. */
    instrumentation?: {
      requestHook?: (span: Span, req: IncomingMessage | ClientRequest) => void;
      responseHook?: (span: Span, response: ServerResponse | IncomingMessage) => void;
      applyCustomAttributesOnSpan?: (
        span: Span,
        request: IncomingMessage | ClientRequest,
        response: ServerResponse | IncomingMessage,
      ) => void;
    };
  },
): void {
  // eslint-disable-next-line @typescript-eslint/unbound-method
  const originalEmit: ServerEmit = server.emit;

  if (wrappedEmitFns.has(originalEmit)) {
    DEBUG_BUILD &&
      debug.log(INSTRUMENTATION_NAME, 'Incoming requests already instrumented, not instrumenting again...');
    return;
  }

  const { requestHook, responseHook, applyCustomAttributesOnSpan } = instrumentation ?? {};

  const newEmit = new Proxy(originalEmit, {
    apply(target, thisArg, args: [event: string, ...args: unknown[]]) {
      // Only traces request events
      if (args[0] !== 'request') {
        return target.apply(thisArg, args);
      }

      // Make sure we do not double execute our wrapper code, for edge cases...
      // Without this check, if we double-wrap emit, for whatever reason, you'd get two http.server spans (one the children of the other)
      if (context.active().getValue(HTTP_SERVER_INSTRUMENTED_KEY)) {
        return target.apply(thisArg, args);
      }

      DEBUG_BUILD && debug.log(INSTRUMENTATION_NAME, 'Handling incoming request');

      const client = getClient<NodeClient>();
      const isolationScope = getIsolationScope().clone();
      const request = args[1] as IncomingMessage;
      const response = args[2] as ServerResponse & { socket: Socket };

      const normalizedRequest = httpRequestToRequestData(request);

      // request.ip is non-standard but some frameworks set this
      const ipAddress = (request as { ip?: string }).ip || request.socket?.remoteAddress;

      const url = request.url || '/';
      if (maxIncomingRequestBodySize !== 'none' && !ignoreIncomingRequestBody?.(url, request)) {
        patchRequestToCaptureBody(request, isolationScope, maxIncomingRequestBodySize);
      }

      // Update the isolation scope, isolate this request
      isolationScope.setSDKProcessingMetadata({ normalizedRequest, ipAddress });

      // attempt to update the scope's `transactionName` based on the request URL
      // Ideally, framework instrumentations coming after the HttpInstrumentation
      // update the transactionName once we get a parameterized route.
      const httpMethod = (request.method || 'GET').toUpperCase();
      const httpTargetWithoutQueryFragment = stripUrlQueryAndFragment(url);

      const bestEffortTransactionName = `${httpMethod} ${httpTargetWithoutQueryFragment}`;

      isolationScope.setTransactionName(bestEffortTransactionName);

      if (trackIncomingRequestsAsSessions !== false) {
        recordRequestSession({
          requestIsolationScope: isolationScope,
          response,
          sessionFlushingDelayMS: sessionFlushingDelayMS ?? 60_000,
        });
      }

      return withIsolationScope(isolationScope, () => {
        // Set a new propagationSpanId for this request
        // We rely on the fact that `withIsolationScope()` will implicitly also fork the current scope
        // This way we can save an ""unnecessary"" `withScope()` invocation
        getCurrentScope().getPropagationContext().propagationSpanId = generateSpanId();

        const ctx = propagation
          .extract(context.active(), normalizedRequest.headers)
          .setValue(HTTP_SERVER_INSTRUMENTED_KEY, true);

        return context.with(ctx, () => {
          // if opting out of span creation, we can end here
          if (
            (typeof __SENTRY_TRACING__ !== 'undefined' && !__SENTRY_TRACING__) ||
            !spans ||
            !client ||
            shouldIgnoreSpansForIncomingRequest(request, {
              ignoreStaticAssets,
              ignoreSpansForIncomingRequests,
            })
          ) {
            DEBUG_BUILD && debug.log(INSTRUMENTATION_NAME, 'Skipping span creation for incoming request');
            return target.apply(thisArg, args);
          }

          const fullUrl = normalizedRequest.url || url;
          const urlObj = parseStringToURLObject(fullUrl);

          const headers = request.headers;
          const userAgent = headers['user-agent'];
          const ips = headers['x-forwarded-for'];
          const httpVersion = request.httpVersion;
          const host = headers.host;
          const hostname = host?.replace(/^(.*)(:[0-9]{1,5})/, '$1') || 'localhost';

          const tracer = client.tracer;
          const scheme = fullUrl.startsWith('https') ? 'https' : 'http';

          const shouldSendDefaultPii = client?.getOptions().sendDefaultPii ?? false;

          // We use the plain tracer.startSpan here so we can pass the span kind
          const span = tracer.startSpan(bestEffortTransactionName, {
            kind: SpanKind.SERVER,
            attributes: {
              // Sentry specific attributes
              [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'http.server',
              [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.otel.http',
              'sentry.http.prefetch': isKnownPrefetchRequest(request) || undefined,
              // Old Semantic Conventions attributes - added for compatibility with what `@opentelemetry/instrumentation-http` output before
              'http.url': fullUrl,
              'http.method': httpMethod,
              'http.target': urlObj ? `${urlObj.pathname}${urlObj.search}` : httpTargetWithoutQueryFragment,
              'http.host': host,
              'net.host.name': hostname,
              'http.client_ip': typeof ips === 'string' ? ips.split(',')[0] : undefined,
              'http.user_agent': userAgent,
              'http.scheme': scheme,
              'http.flavor': httpVersion,
              'net.transport': httpVersion?.toUpperCase() === 'QUIC' ? 'ip_udp' : 'ip_tcp',
              ...getRequestContentLengthAttribute(request),
              ...httpHeadersToSpanAttributes(normalizedRequest.headers || {}, shouldSendDefaultPii),
            },
          });

          // TODO v11: Remove the following three hooks, only incomingRequestSpanHook should remain
          requestHook?.(span, request);
          responseHook?.(span, response);",0
"  parameterize,
  getClient,
  getCurrentScope,
  getIsolationScope,
  getTraceData,
  getTraceMetaTags,
  httpHeadersToSpanAttributes,
  winterCGHeadersToDict,
  continueTrace,
  withScope,
  withIsolationScope,
  captureException,
  captureEvent,
  captureMessage,",0
"  fill,
  getActiveSpan,
  getClient,
  getRootSpan,
  getTraceData,
  hasSpansEnabled,
  httpHeadersToSpanAttributes,
  isNodeEnv,
  loadModule,
  SEMANTIC_ATTRIBUTE_SENTRY_OP,
  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,
  SEMANTIC_ATTRIBUTE_SENTRY_SOURCE,
  setHttpStatus,
  spanToJSON,
  startSpan,
  winterCGHeadersToDict,
  winterCGRequestToRequestData,
  withIsolationScope,
} from '@sentry/core';
import { DEBUG_BUILD } from '../utils/debug-build';
import { createRoutes, getTransactionName } from '../utils/utils';
import { extractData, isResponse, json } from '../utils/vendor/response';
import { captureRemixServerException, errorHandleDataFunction, errorHandleDocumentRequestFunction } from './errors';

type AppData = unknown;
type RemixRequest = Parameters<RequestHandler>[0];
type ServerRouteManifest = ServerBuild['routes'];
type DataFunction = LoaderFunction | ActionFunction;
type DataFunctionArgs = LoaderFunctionArgs | ActionFunctionArgs;

const redirectStatusCodes = new Set([301, 302, 303, 307, 308]);
function isRedirectResponse(response: Response): boolean {
  return redirectStatusCodes.has(response.status);
}

function isCatchResponse(response: Response): boolean {
  return response.headers.get('X-Remix-Catch') != null;
}

/**
 * Sentry utility to be used in place of `handleError` function of Remix v2
 * Remix Docs: https://remix.run/docs/en/main/file-conventions/entry.server#handleerror
 *
 * Should be used in `entry.server` like:
 *
 * export const handleError = Sentry.sentryHandleError
 */
export function sentryHandleError(err: unknown, { request }: DataFunctionArgs): void {
  // We are skipping thrown responses here as they are handled by
  // `captureRemixServerException` at loader / action level
  // We don't want to capture them twice.
  // This function is only for capturing unhandled server-side exceptions.
  // https://remix.run/docs/en/main/file-conventions/entry.server#thrown-responses
  if (isResponse(err) || isRouteErrorResponse(err)) {
    return;
  }

  captureRemixServerException(err, 'remix.server.handleError', request).then(null, e => {
    DEBUG_BUILD && debug.warn('Failed to capture Remix Server exception.', e);
  });
}

/**
 * Sentry wrapper for Remix's `handleError` function.
 * Remix Docs: https://remix.run/docs/en/main/file-conventions/entry.server#handleerror
 */
export function wrapHandleErrorWithSentry(
  origHandleError: (err: unknown, args: { request: unknown }) => void,
): (err: unknown, args: { request: unknown }) => void {
  return function (this: unknown, err: unknown, args: { request: unknown }): void {
    // This is expected to be void but just in case it changes in the future.
    const res = origHandleError.call(this, err, args);

    sentryHandleError(err, args as DataFunctionArgs);

    return res;
  };
}

function isCloudflareEnv(): boolean {
  // eslint-disable-next-line no-restricted-globals
  return navigator?.userAgent?.includes('Cloudflare');
}

function getTraceAndBaggage(): {
  sentryTrace?: string;
  sentryBaggage?: string;
} {
  if (isNodeEnv() || isCloudflareEnv()) {
    const traceData = getTraceData();

    return {
      sentryTrace: traceData['sentry-trace'],
      sentryBaggage: traceData.baggage,
    };
  }

  return {};
}

function makeWrappedDocumentRequestFunction(instrumentTracing?: boolean) {
  return function (origDocumentRequestFunction: HandleDocumentRequestFunction): HandleDocumentRequestFunction {
    return async function (
      this: unknown,
      request: Request,
      responseStatusCode: number,
      responseHeaders: Headers,
      context: EntryContext,
      loadContext?: Record<string, unknown>,
    ): Promise<Response> {
      const documentRequestContext = {
        request,
        responseStatusCode,
        responseHeaders,
        context,
        loadContext,
      };

      if (instrumentTracing) {
        const activeSpan = getActiveSpan();
        const rootSpan = activeSpan && getRootSpan(activeSpan);

        const name = rootSpan ? spanToJSON(rootSpan).description : undefined;

        return startSpan(
          {
            // If we don't have a root span, `onlyIfParent` will lead to the span not being created anyhow
            // So we don't need to care too much about the fallback name, it's just for typing purposes....
            name: name || '<unknown>',
            onlyIfParent: true,
            attributes: {
              method: request.method,
              url: request.url,
              [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.remix',
              [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'function.remix.document_request',
            },
          },
          () => {
            return errorHandleDocumentRequestFunction.call(this, origDocumentRequestFunction, documentRequestContext);
          },
        );
      } else {
        return errorHandleDocumentRequestFunction.call(this, origDocumentRequestFunction, documentRequestContext);
      }
    };
  };
}

function makeWrappedDataFunction(
  origFn: DataFunction,
  id: string,
  name: 'action' | 'loader',
  instrumentTracing?: boolean,
): DataFunction {
  return async function (this: unknown, args: DataFunctionArgs): Promise<Response | AppData> {
    if (instrumentTracing) {
      return startSpan(
        {
          op: `function.remix.${name}`,
          name: id,
          attributes: {
            [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.ui.remix',
            name,
          },
        },
        (span: Span) => {
          return errorHandleDataFunction.call(this, origFn, name, args, span);
        },
      );
    } else {
      return errorHandleDataFunction.call(this, origFn, name, args);
    }
  };
}

const makeWrappedAction =
  (id: string, instrumentTracing?: boolean) =>
  (origAction: DataFunction): DataFunction => {
    return makeWrappedDataFunction(origAction, id, 'action', instrumentTracing);
  };

const makeWrappedLoader =
  (id: string, instrumentTracing?: boolean) =>
  (origLoader: DataFunction): DataFunction => {
    return makeWrappedDataFunction(origLoader, id, 'loader', instrumentTracing);
  };

function makeWrappedRootLoader() {
  return function (origLoader: DataFunction): DataFunction {
    return async function (this: unknown, args: DataFunctionArgs): Promise<Response | AppData> {
      const res = await origLoader.call(this, args);
      const traceAndBaggage = getTraceAndBaggage();

      if (isDeferredData(res)) {
        res.data['sentryTrace'] = traceAndBaggage.sentryTrace;
        res.data['sentryBaggage'] = traceAndBaggage.sentryBaggage;

        return res;
      }

      if (isResponse(res)) {
        // Note: `redirect` and `catch` responses do not have bodies to extract.
        // We skip injection of trace and baggage in those cases.
        // For `redirect`, a valid internal redirection target will have the trace and baggage injected.
        if (isRedirectResponse(res) || isCatchResponse(res)) {
          DEBUG_BUILD && debug.warn('Skipping injection of trace and baggage as the response does not have a body');
          return res;
        } else {
          const data = await extractData(res);

          if (typeof data === 'object') {
            return json(
              { ...data, ...traceAndBaggage },
              {
                headers: res.headers,
                statusText: res.statusText,
                status: res.status,
              },
            );
          } else {
            DEBUG_BUILD && debug.warn('Skipping injection of trace and baggage as the response body is not an object');
            return res;
          }
        }
      }

      return { ...res, ...traceAndBaggage };
    };
  };
}

function wrapRequestHandler<T extends ServerBuild | (() => ServerBuild | Promise<ServerBuild>)>(
  origRequestHandler: RequestHandler,
  build: T,
  options?: {
    instrumentTracing?: boolean;
  },
): RequestHandler {
  let resolvedBuild: ServerBuild | { build: ServerBuild };
  let name: string;
  let source: TransactionSource;

  return async function (this: unknown, request: RemixRequest, loadContext?: AppLoadContext): Promise<Response> {
    const upperCaseMethod = request.method.toUpperCase();
    // We don't want to wrap OPTIONS and HEAD requests
    if (upperCaseMethod === 'OPTIONS' || upperCaseMethod === 'HEAD') {
      return origRequestHandler.call(this, request, loadContext);
    }

    let resolvedRoutes: AgnosticRouteObject[] | undefined;

    if (options?.instrumentTracing) {
      if (typeof build === 'function') {
        resolvedBuild = await build();
      } else {
        resolvedBuild = build;
      }

      // check if the build is nested under `build` key
      if ('build' in resolvedBuild) {
        resolvedRoutes = createRoutes((resolvedBuild.build as ServerBuild).routes);
      } else {
        resolvedRoutes = createRoutes(resolvedBuild.routes);
      }
    }

    return withIsolationScope(async isolationScope => {
      const clientOptions = getClient()?.getOptions();

      let normalizedRequest: RequestEventData = {};

      try {
        normalizedRequest = winterCGRequestToRequestData(request);
      } catch {
        DEBUG_BUILD && debug.warn('Failed to normalize Remix request');
      }

      if (options?.instrumentTracing && resolvedRoutes) {
        const url = new URL(request.url);
        [name, source] = getTransactionName(resolvedRoutes, url);

        isolationScope.setTransactionName(name);
      }

      isolationScope.setSDKProcessingMetadata({ normalizedRequest });

      if (!clientOptions || !hasSpansEnabled(clientOptions)) {
        return origRequestHandler.call(this, request, loadContext);
      }

      return continueTrace(
        {
          sentryTrace: request.headers.get('sentry-trace') || '',
          baggage: request.headers.get('baggage') || '',
        },
        async () => {
          if (options?.instrumentTracing) {
            const parentSpan = getActiveSpan();
            const rootSpan = parentSpan && getRootSpan(parentSpan);
            rootSpan?.updateName(name);

            return startSpan(
              {
                name,
                attributes: {
                  [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.remix',
                  [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: source,
                  [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'http.server',
                  method: request.method,
                  ...httpHeadersToSpanAttributes(
                    winterCGHeadersToDict(request.headers),
                    clientOptions.sendDefaultPii ?? false,
                  ),
                },
              },
              async span => {
                const res = (await origRequestHandler.call(this, request, loadContext)) as Response;

                if (isResponse(res)) {",0
"import type { Span } from '@sentry/core';
import {
  continueTrace,
  debug,
  flushIfServerless,
  getClient,
  getCurrentScope,
  getDefaultIsolationScope,
  getIsolationScope,
  getTraceMetaTags,
  httpHeadersToSpanAttributes,
  SEMANTIC_ATTRIBUTE_SENTRY_OP,
  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,
  SEMANTIC_ATTRIBUTE_SENTRY_SOURCE,
  setHttpStatus,
  spanToJSON,
  startSpan,
  updateSpanName,
  winterCGHeadersToDict,
  winterCGRequestToRequestData,
  withIsolationScope,
} from '@sentry/core';
import type { Handle, ResolveOptions } from '@sveltejs/kit';
import { DEBUG_BUILD } from '../common/debug-build';
import { getTracePropagationData, sendErrorToSentry } from './utils';

export type SentryHandleOptions = {
  /**
   * Controls whether the SDK should capture errors and traces in requests that don't belong to a
   * route defined in your SvelteKit application.
   *
   * By default, this option is set to `false` to reduce noise (e.g. bots sending random requests to your server).
   *
   * Set this option to `true` if you want to monitor requests events without a route. This might be useful in certain
   * scenarios, for instance if you registered other handlers that handle these requests.
   * If you set this option, you might want adjust the the transaction name in the `beforeSendTransaction`
   * callback of your server-side `Sentry.init` options. You can also use `beforeSendTransaction` to filter out
   * transactions that you still don't want to be sent to Sentry.
   *
   * @default false
   */
  handleUnknownRoutes?: boolean;

  /**
   * Controls if `sentryHandle` should inject a script tag into the page that enables instrumentation
   * of `fetch` calls in `load` functions.
   *
   * @default true
   */
  injectFetchProxyScript?: boolean;
};

export const FETCH_PROXY_SCRIPT = `
    const f = window.fetch;
    if(f){
      window._sentryFetchProxy = function(...a){return f(...a)}
      window.fetch = function(...a){return window._sentryFetchProxy(...a)}
    }
`;
/**
 * Adds Sentry tracing <meta> tags to the returned html page.
 * Adds Sentry fetch proxy script to the returned html page if enabled in options.
 *
 * Exported only for testing
 */
export function addSentryCodeToPage(options: {
  injectFetchProxyScript: boolean;
}): NonNullable<ResolveOptions['transformPageChunk']> {
  return ({ html }) => {
    const metaTags = getTraceMetaTags();
    const headWithMetaTags = metaTags ? `<head>\n${metaTags}` : '<head>';

    const headWithFetchScript = options.injectFetchProxyScript ? `\n<script>${FETCH_PROXY_SCRIPT}</script>` : '';

    const modifiedHead = `${headWithMetaTags}${headWithFetchScript}`;

    return html.replace('<head>', modifiedHead);
  };
}

/**
 * We only need to inject the fetch proxy script for SvelteKit versions < 2.16.0.
 * Exported only for testing.
 */
export function isFetchProxyRequired(version: string): boolean {
  try {
    const [major, minor] = version.trim().replace(/-.*/, '').split('.').map(Number);
    if (major != null && minor != null && (major > 2 || (major === 2 && minor >= 16))) {
      return false;
    }
  } catch {
    // ignore
  }
  return true;
}

interface BackwardsForwardsCompatibleEvent {
  /**
   * For now taken from: https://github.com/sveltejs/kit/pull/13899
   * Access to spans for tracing. If tracing is not enabled or the function is being run in the browser, these spans will do nothing.
   * @since 2.31.0
   */
  tracing?: {
    /** Whether tracing is enabled. */
    enabled: boolean;
    current: Span;
    root: Span;
  };
}

async function instrumentHandle(
  {
    event,
    resolve,
  }: {
    event: Parameters<Handle>[0]['event'] & BackwardsForwardsCompatibleEvent;
    resolve: Parameters<Handle>[0]['resolve'];
  },
  options: SentryHandleOptions,
): Promise<Response> {
  const routeId = event.route?.id;

  if (!routeId && !options.handleUnknownRoutes) {
    return resolve(event);
  }

  // caching the result of the version check in `options.injectFetchProxyScript`
  // to avoid doing the dynamic import on every request
  if (options.injectFetchProxyScript == null) {
    try {
      // @ts-expect-error - the dynamic import is fine here
      const { VERSION } = await import('@sveltejs/kit');
      options.injectFetchProxyScript = isFetchProxyRequired(VERSION);
    } catch {
      options.injectFetchProxyScript = true;
    }
  }

  const routeName = `${event.request.method} ${routeId || event.url.pathname}`;

  if (getIsolationScope() !== getDefaultIsolationScope()) {
    getIsolationScope().setTransactionName(routeName);
  } else {
    DEBUG_BUILD && debug.warn('Isolation scope is default isolation scope - skipping setting transactionName');
  }

  // We only start a span if SvelteKit's native tracing is not enabled. Two reasons:
  // - Used Kit version doesn't yet support tracing
  // - Users didn't enable tracing
  const kitTracingEnabled = event.tracing?.enabled;

  try {
    const resolveWithSentry: (sentrySpan?: Span) => Promise<Response> = async (sentrySpan?: Span) => {
      getCurrentScope().setSDKProcessingMetadata({
        // We specifically avoid cloning the request here to avoid double read errors.
        // We only read request headers so we're not consuming the body anyway.
        // Note to future readers: This sounds counter-intuitive but please read
        // https://github.com/getsentry/sentry-javascript/issues/14583
        normalizedRequest: winterCGRequestToRequestData(event.request),
      });
      const kitRootSpan = event.tracing?.enabled ? event.tracing?.root : undefined;

      if (kitRootSpan) {
        // Update the root span emitted from SvelteKit to resemble a `http.server` span
        // We're doing this here instead of an event processor to ensure we update the
        // span name as early as possible (for dynamic sampling, et al.)
        // Other spans are enhanced in the `processKitSpans` integration.
        const spanJson = spanToJSON(kitRootSpan);
        const kitRootSpanAttributes = spanJson.data;
        const originalName = spanJson.description;

        const routeName = kitRootSpanAttributes['http.route'];
        if (routeName && typeof routeName === 'string') {
          updateSpanName(kitRootSpan, `${event.request.method ?? 'GET'} ${routeName}`);
        }

        kitRootSpan.setAttributes({
          [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'http.server',
          [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.sveltekit',
          [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: routeName ? 'route' : 'url',
          'sveltekit.tracing.original_name': originalName,
          ...httpHeadersToSpanAttributes(
            winterCGHeadersToDict(event.request.headers),
            getClient()?.getOptions().sendDefaultPii ?? false,
          ),
        });
      }

      const res = await resolve(event, {
        transformPageChunk: addSentryCodeToPage({
          injectFetchProxyScript: options.injectFetchProxyScript ?? true,
        }),
      });

      if (sentrySpan) {
        setHttpStatus(sentrySpan, res.status);
      }

      return res;
    };

    const resolveResult = kitTracingEnabled
      ? await resolveWithSentry()
      : await startSpan(
          {
            op: 'http.server',
            attributes: {
              [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.sveltekit',
              [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: routeId ? 'route' : 'url',
              'http.method': event.request.method,
              ...httpHeadersToSpanAttributes(
                winterCGHeadersToDict(event.request.headers),
                getClient()?.getOptions().sendDefaultPii ?? false,
              ),
            },
            name: routeName,
          },
          resolveWithSentry,
        );
",0
"import { NextRequest } from 'next/server';
import { WORKOS_CLIENT_ID } from './env-variables.js';
import { HandleAuthOptions } from './interfaces.js';
import { saveSession } from './session.js';
import { errorResponseWithFallback, redirectWithFallback, setCachePreventionHeaders } from './utils.js';
import { getWorkOS } from './workos.js';

function preventCaching(headers: Headers): void {
  headers.set('Vary', 'Cookie');
  setCachePreventionHeaders(headers);
}

function handleState(state: string | null) {
  let returnPathname: string | undefined = undefined;
  let userState: string | undefined;
  if (state?.includes('.')) {
    const [internal, ...rest] = state.split('.');
    userState = rest.join('.');
    try {
      // Reverse URL-safe base64 encoding
      const decoded = internal.replace(/-/g, '+').replace(/_/g, '/');
      returnPathname = JSON.parse(atob(decoded)).returnPathname;
    } catch {
      // Malformed internal part, ignore it
    }
  } else if (state) {
    try {
      const decoded = JSON.parse(atob(state));
      if (decoded.returnPathname) {
        returnPathname = decoded.returnPathname;
      } else {
        userState = state;
      }
    } catch {
      userState = state;
    }
  }
  return {
    returnPathname,
    state: userState,
  };
}

export function handleAuth(options: HandleAuthOptions = {}) {
  const { returnPathname: returnPathnameOption = '/', baseURL, onSuccess, onError } = options;

  // Throw early if baseURL is provided but invalid
  if (baseURL) {
    try {
      new URL(baseURL);
    } catch (error) {
      throw new Error(`Invalid baseURL: ${baseURL}`, { cause: error });
    }
  }

  return async function GET(request: NextRequest) {
    const code = request.nextUrl.searchParams.get('code');
    const state = request.nextUrl.searchParams.get('state');

    const { state: customState, returnPathname: returnPathnameState } = handleState(state);

    if (code) {
      try {
        // Use the code returned to us by AuthKit and authenticate the user with WorkOS
        const { accessToken, refreshToken, user, impersonator, oauthTokens, authenticationMethod, organizationId } =
          await getWorkOS().userManagement.authenticateWithCode({
            clientId: WORKOS_CLIENT_ID,
            code,
          });

        // If baseURL is provided, use it instead of request.nextUrl
        // This is useful if the app is being run in a container like docker where
        // the hostname can be different from the one in the request
        const url = baseURL ? new URL(baseURL) : request.nextUrl.clone();

        // Cleanup params
        url.searchParams.delete('code');
        url.searchParams.delete('state');

        // Redirect to the requested path and store the session
        const returnPathname = returnPathnameState ?? returnPathnameOption;

        // Extract the search params if they are present
        if (returnPathname.includes('?')) {
          const newUrl = new URL(returnPathname, 'https://example.com');
          url.pathname = newUrl.pathname;

          for (const [key, value] of newUrl.searchParams) {
            url.searchParams.append(key, value);
          }
        } else {
          url.pathname = returnPathname;
        }

        // Fall back to standard Response if NextResponse is not available.
        // This is to support Next.js 13.
        const response = redirectWithFallback(url.toString());
        preventCaching(response.headers);

        if (!accessToken || !refreshToken) throw new Error('response is missing tokens');

        await saveSession({ accessToken, refreshToken, user, impersonator }, request);

        if (onSuccess) {
          await onSuccess({
            accessToken,
            refreshToken,
            user,
            impersonator,
            oauthTokens,
            authenticationMethod,
            organizationId,
            state: customState,
          });
        }

        return response;
      } catch (error) {
        const errorRes = {
          error: error instanceof Error ? error.message : String(error),
        };

        console.error(errorRes);

        return await errorResponse(request, error);
      }
    }

    return await errorResponse(request);
  };

  async function errorResponse(request: NextRequest, error?: unknown) {
    if (onError) {
      const response = await onError({ error, request });
      preventCaching(response.headers);
      return response;
    }

    const response = errorResponseWithFallback({
      error: {
        message: 'Something went wrong',
        description: ""Couldn't sign in. If you are not sure what happened, please contact your organization admin."",
      },
    });

    preventCaching(response.headers);
    return response;
  }
}",0
"      nextHeaders.delete('x-workos-middleware');
      nextHeaders.set('x-url', 'https://example.com/');

      await expect(async () => {
        await withAuth();
      }).rejects.toThrow(
        /You are calling 'withAuth' on https:\/\/example\.com\/ that isn't covered by the AuthKit middleware/,
      );
    });

    it('should throw an error if the route is not covered by the middleware and there is no URL in the headers', async () => {
      const nextHeaders = await headers();
      nextHeaders.delete('x-workos-middleware');

      await expect(async () => {
        await withAuth({ ensureSignedIn: true });
      }).rejects.toThrow(/You are calling 'withAuth' on a route that isn't covered by the AuthKit middleware/);
    });

    it('should throw an error if the URL is not found in the headers', async () => {
      const nextHeaders = await headers();
      nextHeaders.delete('x-url');
",0
"  UserInfo,
} from './interfaces.js';
import { getWorkOS } from './workos.js';

import type { AuthenticationResponse } from '@workos-inc/node';
import { parse, tokensToRegexp } from 'path-to-regexp';
import { lazy, redirectWithFallback, setCachePreventionHeaders } from './utils.js';

const sessionHeaderName = 'x-workos-session';
const middlewareHeaderName = 'x-workos-middleware';
const signUpPathsHeaderName = 'x-sign-up-paths';
const jwtCookieName = 'workos-access-token';

const JWKS = lazy(() => createRemoteJWKSet(new URL(getWorkOS().userManagement.getJwksUrl(WORKOS_CLIENT_ID))));

/**
 * Applies cache security headers with Vary header deduplication.
 * Only applies headers if the request is authenticated (has session, cookie, or Authorization header).
 * Used in middleware where existing Vary headers may already be present.
 * @param headers - The Headers object to set the cache security headers on.
 * @param request - The NextRequest object to check for authentication.
 * @param sessionData - Optional session data to check for authentication.
 */
function applyCacheSecurityHeaders(
  headers: Headers,
  request: NextRequest,
  sessionData?: { accessToken?: string } | Session,
): void {
  const cookieName = WORKOS_COOKIE_NAME || 'wos-session';

  // Only apply cache headers for authenticated requests
  if (!sessionData?.accessToken && !request.cookies.has(cookieName) && !request.headers.has('authorization')) {
    return;
  }

  const varyValues = new Set<string>(['cookie']);
  if (request.headers.has('authorization')) {
    varyValues.add('authorization');
  }

  const currentVary = headers.get('Vary');
  if (currentVary) {
    currentVary.split(',').forEach((v) => {
      const trimmed = v.trim().toLowerCase();
      if (trimmed) varyValues.add(trimmed);
    });
  }

  headers.set(
    'Vary',
    Array.from(varyValues)
      .map((v) => v.charAt(0).toUpperCase() + v.slice(1))
      .join(', '),
  );

  setCachePreventionHeaders(headers);
}

/**
 * Determines if a request is for an initial document load (not API/RSC/prefetch)
 */
function isInitialDocumentRequest(request: NextRequest): boolean {
  const accept = request.headers.get('accept') || '';
  const isDocumentRequest = accept.includes('text/html');
  const isRSCRequest = request.headers.has('RSC') || request.headers.has('Next-Router-State-Tree');
  const isPrefetch =
    request.headers.get('Purpose') === 'prefetch' ||
    request.headers.get('Sec-Purpose') === 'prefetch' ||
    request.headers.has('Next-Router-Prefetch');

  return isDocumentRequest && !isRSCRequest && !isPrefetch;
}

async function encryptSession(session: Session) {
  return sealData(session, {
    password: WORKOS_COOKIE_PASSWORD,
    ttl: 0,
  });
}

async function updateSessionMiddleware(
  request: NextRequest,
  debug: boolean,
  middlewareAuth: AuthkitMiddlewareAuth,
  redirectUri: string,
  signUpPaths: string[],
  eagerAuth = false,
) {
  if (!redirectUri && !WORKOS_REDIRECT_URI) {
    throw new Error('You must provide a redirect URI in the AuthKit middleware or in the environment variables.');
  }

  if (!WORKOS_COOKIE_PASSWORD || WORKOS_COOKIE_PASSWORD.length < 32) {
    throw new Error(
      'You must provide a valid cookie password that is at least 32 characters in the environment variables.',
    );
  }

  let url;

  if (redirectUri) {
    url = new URL(redirectUri);
  } else {
    url = new URL(WORKOS_REDIRECT_URI);
  }

  if (
    middlewareAuth.enabled &&
    url.pathname === request.nextUrl.pathname &&
    !middlewareAuth.unauthenticatedPaths.includes(url.pathname)
  ) {
    // In the case where:
    // - We're using middleware auth mode
    // - The redirect URI is in the middleware matcher
    // - The redirect URI isn't in the unauthenticatedPaths array
    //
    // then we would get stuck in a login loop due to the redirect happening before the session is set.
    // It's likely that the user accidentally forgot to add the path to unauthenticatedPaths, so we add it here.
    middlewareAuth.unauthenticatedPaths.push(url.pathname);
  }

  const matchedPaths: string[] = middlewareAuth.unauthenticatedPaths.filter((pathGlob) => {
    const pathRegex = getMiddlewareAuthPathRegex(pathGlob);

    return pathRegex.exec(request.nextUrl.pathname);
  });

  const { session, headers, authorizationUrl } = await updateSession(request, {
    debug,
    redirectUri,
    screenHint: getScreenHint(signUpPaths, request.nextUrl.pathname),
    eagerAuth,
  });

  // If the user is logged out and this path isn't on the allowlist for logged out paths, redirect to AuthKit.
  if (middlewareAuth.enabled && matchedPaths.length === 0 && !session.user) {
    if (debug) {
      console.log(`Unauthenticated user on protected route ${request.url}, redirecting to AuthKit`);
    }

    return redirectWithFallback(authorizationUrl as string, headers);
  }

  // Record the sign up paths so we can use them later
  if (signUpPaths.length > 0) {
    headers.set(signUpPathsHeaderName, signUpPaths.join(','));
  }

  applyCacheSecurityHeaders(headers, request, session);

  // Create a new request with modified headers (for page handlers)
  const requestHeaders = new Headers(request.headers);
  requestHeaders.set(middlewareHeaderName, headers.get(middlewareHeaderName)!);
  requestHeaders.set('x-url', headers.get('x-url')!);
  if (headers.has('x-redirect-uri')) {
    requestHeaders.set('x-redirect-uri', headers.get('x-redirect-uri')!);
  }
  if (headers.has(signUpPathsHeaderName)) {
    requestHeaders.set(signUpPathsHeaderName, headers.get(signUpPathsHeaderName)!);
  }

  // Pass session to page handlers via request header
  // This ensures handlers see refreshed sessions immediately (before Set-Cookie reaches browser)
  const sessionHeader = headers.get(sessionHeaderName);
  if (sessionHeader) {
    requestHeaders.set(sessionHeaderName, sessionHeader);
  }

  // Remove session header from response headers to prevent leakage
  headers.delete(sessionHeaderName);

  return NextResponse.next({
    request: {
      headers: requestHeaders,
    },
    headers,
  });
}

async function updateSession(
  request: NextRequest,
  options: AuthkitOptions = { debug: false },
): Promise<AuthkitResponse> {
  const session = await getSessionFromCookie(request);

  // Since we're setting the headers in the response, we need to create a new Headers object without copying
  // the request headers.
  // See https://github.com/vercel/next.js/issues/50659#issuecomment-2333990159
  const newRequestHeaders = new Headers();

  // Record that the request was routed through the middleware so we can check later for DX purposes
  newRequestHeaders.set(middlewareHeaderName, 'true');

  // We store the current request url in a custom header, so we can always have access to it
  // This is because on hard navigations we don't have access to `next-url` but need to get the current
  // `pathname` to be able to return the users where they came from before sign-in
  newRequestHeaders.set('x-url', request.url);

  if (options.redirectUri) {
    // Store the redirect URI in a custom header, so we always have access to it and so that subsequent
    // calls to `getAuthorizationUrl` will use the same redirect URI
    newRequestHeaders.set('x-redirect-uri', options.redirectUri);
  }

  newRequestHeaders.delete(sessionHeaderName);

  if (!session) {
    if (options.debug) {
      console.log('No session found from cookie');
    }

    return {
      session: { user: null },
      headers: newRequestHeaders,
      authorizationUrl: await getAuthorizationUrl({
        returnPathname: getReturnPathname(request.url),
        redirectUri: options.redirectUri || WORKOS_REDIRECT_URI,
        screenHint: options.screenHint,
      }),
    };
  }

  const hasValidSession = await verifyAccessToken(session.accessToken);

  const cookieName = WORKOS_COOKIE_NAME || 'wos-session';

  applyCacheSecurityHeaders(newRequestHeaders, request, session);

  if (hasValidSession) {
    newRequestHeaders.set(sessionHeaderName, request.cookies.get(cookieName)!.value);

    const {
      sid: sessionId,
      org_id: organizationId,
      role,
      roles,
      permissions,
      entitlements,
      feature_flags: featureFlags,
    } = decodeJwt<AccessToken>(session.accessToken);

    // Set JWT cookie if eagerAuth is enabled
    // Only set on document requests (initial page loads), not on API/RSC requests
    if (options.eagerAuth && isInitialDocumentRequest(request)) {
      const existingJwtCookie = request.cookies.get(jwtCookieName);
      // Only set if cookie doesn't exist or has different value
      if (!existingJwtCookie || existingJwtCookie.value !== session.accessToken) {
        newRequestHeaders.append('Set-Cookie', getJwtCookie(session.accessToken, request.url));
      }
    }

    return {
      session: {
        sessionId,
        user: session.user,
        organizationId,
        role,
        roles,
        permissions,
        entitlements,
        featureFlags,
        impersonator: session.impersonator,
        accessToken: session.accessToken,
      },
      headers: newRequestHeaders,
    };
  }

  try {
    if (options.debug) {
      // istanbul ignore next
      console.log(
        `Session invalid. ${session.accessToken ? `Refreshing access token that ends in ${session.accessToken.slice(-10)}` : 'Access token missing.'}`,
      );
    }

    const { org_id: organizationIdFromAccessToken } = decodeJwt<AccessToken>(session.accessToken);

    const { accessToken, refreshToken, user, impersonator } =
      await getWorkOS().userManagement.authenticateWithRefreshToken({
        clientId: WORKOS_CLIENT_ID,
        refreshToken: session.refreshToken,
        organizationId: organizationIdFromAccessToken,
      });

    if (options.debug) {
      console.log('Session successfully refreshed');
    }
    // Encrypt session with new access and refresh tokens
    const encryptedSession = await encryptSession({
      accessToken,
      refreshToken,
      user,
      impersonator,
    });

    newRequestHeaders.append('Set-Cookie', `${cookieName}=${encryptedSession}; ${getCookieOptions(request.url, true)}`);
    newRequestHeaders.set(sessionHeaderName, encryptedSession);

    // Set JWT cookie if eagerAuth is enabled
    // Only set on document requests (initial page loads), not on API/RSC requests
    if (options.eagerAuth && isInitialDocumentRequest(request)) {
      newRequestHeaders.append('Set-Cookie', getJwtCookie(accessToken, request.url));
    }

    const {
      sid: sessionId,
      org_id: organizationId,
      role,
      roles,
      permissions,
      entitlements,
      feature_flags: featureFlags,
    } = decodeJwt<AccessToken>(accessToken);

    options.onSessionRefreshSuccess?.({ accessToken, user, impersonator, organizationId });

    return {
      session: {
        sessionId,
        user,
        organizationId,
        role,
        roles,
        permissions,
        entitlements,
        featureFlags,
        impersonator,
        accessToken,
      },
      headers: newRequestHeaders,
    };
  } catch (e) {
    if (options.debug) {
      console.log('Failed to refresh. Deleting cookie.', e);
    }

    // When we need to delete a cookie, return it as a header as you can't delete cookies from edge middleware
    const deleteCookie = `${cookieName}=; Expires=${new Date(0).toUTCString()}; ${getCookieOptions(request.url, true, true)}`;
    newRequestHeaders.append('Set-Cookie', deleteCookie);

    // Delete JWT cookie if eagerAuth is enabled
    if (options.eagerAuth) {
      const deleteJwtCookie = getJwtCookie(null, request.url, true);
      newRequestHeaders.append('Set-Cookie', deleteJwtCookie);
    }

    options.onSessionRefreshError?.({ error: e, request });

    return {
      session: { user: null },
      headers: newRequestHeaders,
      authorizationUrl: await getAuthorizationUrl({
        returnPathname: getReturnPathname(request.url),
        redirectUri: options.redirectUri || WORKOS_REDIRECT_URI,
      }),
    };
  }
}

async function refreshSession(options: { organizationId?: string; ensureSignedIn: true }): Promise<UserInfo>;
async function refreshSession(options?: {
  organizationId?: string;
  ensureSignedIn?: boolean;
}): Promise<UserInfo | NoUserInfo>;
async function refreshSession({
  organizationId: nextOrganizationId,
  ensureSignedIn = false,
}: {
  organizationId?: string;
  ensureSignedIn?: boolean;
} = {}): Promise<UserInfo | NoUserInfo> {
  const session = await getSessionFromCookie();
  if (!session) {
    if (ensureSignedIn) {
      await redirectToSignIn();
    }
    return { user: null };
  }

  const { org_id: organizationIdFromAccessToken } = decodeJwt<AccessToken>(session.accessToken);

  let refreshResult;

  try {
    refreshResult = await getWorkOS().userManagement.authenticateWithRefreshToken({
      clientId: WORKOS_CLIENT_ID,
      refreshToken: session.refreshToken,
      organizationId: nextOrganizationId ?? organizationIdFromAccessToken,
    });
  } catch (error) {
    throw new Error(`Failed to refresh session: ${error instanceof Error ? error.message : String(error)}`, {
      cause: error,
    });
  }

  const headersList = await headers();
  const url = headersList.get('x-url');

  await saveSession(refreshResult, url || WORKOS_REDIRECT_URI);

  const { accessToken, user, impersonator } = refreshResult;

  const {
    sid: sessionId,
    org_id: organizationId,
    role,
    roles,
    permissions,
    entitlements,
    feature_flags: featureFlags,
  } = decodeJwt<AccessToken>(accessToken);

  return {
    sessionId,
    user,
    organizationId,
    role,
    roles,
    permissions,
    entitlements,
    featureFlags,
    impersonator,
    accessToken,
  };
}

function getMiddlewareAuthPathRegex(pathGlob: string) {
  try {
    const url = new URL(pathGlob, 'https://example.com');
    const path = `${url.pathname!}${url.hash || ''}`;

    const tokens = parse(path);
    const regex = tokensToRegexp(tokens).source;

    return new RegExp(regex);
  } catch (err) {
    console.log('err', err);
    const message = err instanceof Error ? err.message : String(err);

    throw new Error(`Error parsing routes for middleware auth. Reason: ${message}`);
  }
}

async function redirectToSignIn() {
  const headersList = await headers();
  const url = headersList.get('x-url');

  if (!url) {
    throw new Error('No URL found in the headers');
  }

  // Determine if the current route is in the sign up paths
  const signUpPaths = headersList.get(signUpPathsHeaderName)?.split(',');

  const pathname = new URL(url).pathname;
  const screenHint = getScreenHint(signUpPaths, pathname);

  const returnPathname = getReturnPathname(url);

  redirect(await getAuthorizationUrl({ returnPathname, screenHint }));
}

export async function getTokenClaims<T = Record<string, unknown>>(
  accessToken?: string,
): Promise<Partial<JWTPayload & T>> {
  const token = accessToken ?? (await withAuth()).accessToken;
  if (!token) {
    return {};
  }

  return decodeJwt<T>(token);
}

async function withAuth(options: { ensureSignedIn: true }): Promise<UserInfo>;
async function withAuth(options?: { ensureSignedIn?: true | false }): Promise<UserInfo | NoUserInfo>;
async function withAuth(options?: { ensureSignedIn?: boolean }): Promise<UserInfo | NoUserInfo> {
  const session = await getSessionFromHeader();

  if (!session) {
    if (options?.ensureSignedIn) {
      await redirectToSignIn();
    }
    return { user: null };
  }

  const {
    sid: sessionId,
    org_id: organizationId,
    role,
    roles,
    permissions,
    entitlements,
    feature_flags: featureFlags,
  } = decodeJwt<AccessToken>(session.accessToken);

  return {
    sessionId,
    user: session.user,
    organizationId,
    role,
    roles,
    permissions,
    entitlements,
    featureFlags,
    impersonator: session.impersonator,
    accessToken: session.accessToken,
  };
}

async function verifyAccessToken(accessToken: string) {
  try {
    await jwtVerify(accessToken, JWKS());
    return true;
  } catch {
    return false;
  }
}

export async function getSessionFromCookie(request?: NextRequest) {
  const cookieName = WORKOS_COOKIE_NAME || 'wos-session';
  let cookie;

  if (request) {
    cookie = request.cookies.get(cookieName);
  } else {
    const nextCookies = await cookies();
    cookie = nextCookies.get(cookieName);
  }

  if (cookie) {
    return unsealData<Session>(cookie.value, {
      password: WORKOS_COOKIE_PASSWORD,
    });
  }
}

async function getSessionFromHeader(): Promise<Session | undefined> {
  const headersList = await headers();
  const hasMiddleware = Boolean(headersList.get(middlewareHeaderName));

  if (!hasMiddleware) {
    const url = headersList.get('x-url');
    throw new Error(
      `You are calling 'withAuth' on ${url ?? 'a route'} that isn't covered by the AuthKit middleware. Make sure it is running on all paths you are calling 'withAuth' from by updating your middleware config in 'middleware.(js|ts)'.`,
    );
  }

  const authHeader = headersList.get(sessionHeaderName);
  if (!authHeader) return;
",0
"import { NextResponse } from 'next/server';

/**
 * Sets cache prevention headers to prevent CDN/proxy caching.
 * @param headers - The Headers object to set the cache prevention headers on.
 */
export function setCachePreventionHeaders(headers: Headers): void {
  headers.set('Cache-Control', 'private, no-cache, no-store, must-revalidate, max-age=0');
  headers.set('Pragma', 'no-cache');
  headers.set('Expires', '0');
  headers.set('x-middleware-cache', 'no-cache');
}

export function redirectWithFallback(redirectUri: string, headers?: Headers) {
  const newHeaders = headers ? new Headers(headers) : new Headers();
  newHeaders.set('Location', redirectUri);

  // Fall back to standard Response if NextResponse is not available.
  // This is to support Next.js 13.",0
"    }
    argv.ext = normalizeExt(argv.ext);
    const { script, scriptPath, tempPath } = yield readScript();
    yield runScript(script, scriptPath, tempPath);
  });
}
var rmrf = (p) => {
  if (!p) return;
  try {
    import_index.fs.lstatSync(p).isSymbolicLink() ? import_index.fs.unlinkSync(p) : import_index.fs.rmSync(p, { force: true, recursive: true });
  } catch (e) {
  }
};
function runScript(script, scriptPath, tempPath) {
  return __async(this, null, function* () {
    let nmLink = """";
    const rmTemp = () => {
      rmrf(tempPath);
      rmrf(nmLink);
    };
    try {
      if (tempPath) {
        scriptPath = tempPath;
        yield import_index.fs.writeFile(tempPath, script);
      }
      const cwd = import_index.path.dirname(scriptPath);
      if (typeof argv.preferLocal === ""string"") {
        linkNodeModules(cwd, argv.preferLocal);
        try {
          const aliasPath = import_index.path.resolve(cwd, ""node_modules"");
          if (import_index.fs.existsSync(aliasPath) && import_index.fs.lstatSync(aliasPath).isSymbolicLink()) {
            nmLink = aliasPath;
          } else {
            nmLink = """";
          }
        } catch (e) {
        }
      }
      if (argv.install) {
        yield (0, import_deps.installDeps)((0, import_deps.parseDeps)(script), cwd, argv.registry);
      }
      injectGlobalRequire(scriptPath);
      import_node_process2.default.once(""exit"", rmTemp);",0
"  argv.ext = normalizeExt(argv.ext)

  const { script, scriptPath, tempPath } = await readScript()
  await runScript(script, scriptPath, tempPath)
}

// Short & safe remove: unlink symlinks; recurse only for real dirs/files
const rmrf = (p: string) => {
  if (!p) return
  try {
    fs.lstatSync(p).isSymbolicLink()
      ? fs.unlinkSync(p)
      : fs.rmSync(p, { force: true, recursive: true })
  } catch {}
}

async function runScript(
  script: string,
  scriptPath: string,
  tempPath: string
): Promise<void> {
  let nmLink = '' // will hold the alias path (./node_modules) ONLY if it's a symlink
  const rmTemp = () => {
    rmrf(tempPath)
    rmrf(nmLink)
  }
  try {
    if (tempPath) {
      scriptPath = tempPath
      await fs.writeFile(tempPath, script)
    }
    const cwd = path.dirname(scriptPath)

    if (typeof argv.preferLocal === 'string') {
      // Keep original behaviour: linkNodeModules returns TARGET (unchanged API)
      linkNodeModules(cwd, argv.preferLocal)

      // For cleanup, compute ALIAS and only unlink if it's a symlink
      try {
        const aliasPath = path.resolve(cwd, 'node_modules')
        if (
          fs.existsSync(aliasPath) &&
          fs.lstatSync(aliasPath).isSymbolicLink()
        ) {
          nmLink = aliasPath
        } else {
          nmLink = ''
        }
      } catch {}
    }

    if (argv.install) {
      await installDeps(parseDeps(script), cwd, argv.registry)
    }

    injectGlobalRequire(scriptPath)
    process.once('exit', rmTemp)

    // TODO: fix unanalyzable-dynamic-import to work correctly with jsr.io
    await import(url.pathToFileURL(scriptPath).toString())
  } finally {
    rmTemp()
  }
}

function linkNodeModules(cwd: string, external: string): string {
  const nm = 'node_modules'
  const alias = path.resolve(cwd, nm)
  const target =
    path.basename(external) === nm
      ? path.resolve(external)
      : path.resolve(external, nm)

  if (fs.existsSync(alias) || !fs.existsSync(target)) return ''

  fs.symlinkSync(target, alias, 'junction')
  // Keep behaviour stable: return TARGET (not alias)
  return target
}

async function readScript() {
  const [firstArg] = argv._
  let script = ''",0
"			left: '20mm',
		},
	},
	launch_options: {},
	gray_matter_options: {
		engines: {
			javascript: () =>
				new Error(
					'The JS engine for front-matter is disabled by default for security reasons. You can enable it by configuring gray_matter_options.',
				),
		},
	},
	md_file_encoding: 'utf-8',",0
"	const textContent = await getPdfTextContent(pdf.content);

	t.true(textContent.startsWith('Formulas with MathJax'));
	t.regex(textContent, /a\s≠\s0/);
});

test('the JS engine with `js` tag is disabled by default', async (t) => {
	const css = '`body::before { display: block; content: ""${""i am injected""}""}`'; // eslint-disable-line no-template-curly-in-string

	const pdf = await mdToPdf({ content: `---js\n{ css: ${css} }\n---` });

	const textContent = await getPdfTextContent(pdf.content);

	t.is(textContent, '');
});

test('the JS engine with `javascript` tag is disabled by default', async (t) => {
	const css = '`body::before { display: block; content: ""${""i am injected""}""}`'; // eslint-disable-line no-template-curly-in-string

	const pdf = await mdToPdf({ content: `---javascript\n{ css: ${css} }\n---` });

	const textContent = await getPdfTextContent(pdf.content);

	t.is(textContent, '');
});

test('the JS engine for front-matter can be enabled', async (t) => {
	const css = '`body::before { display: block; content: ""${""i am injected""}""}`'; // eslint-disable-line no-template-curly-in-string

	const pdf = await mdToPdf({ content: `---js\n{ css: ${css} }\n---` }, { gray_matter_options: undefined });

	const textContent = await getPdfTextContent(pdf.content);",0
"		before(async () => {
			fixture = await loadFixture({
				root: './fixtures/core-image/',
				image: {
					service: testImageService({ foo: 'bar' }),
					domains: ['avatars.githubusercontent.com'],
					remotePatterns: [
						{
							protocol: 'data',
						},
					],
				},
			});

			devServer = await fixture.startDevServer({
				logger: new Logger({
					level: 'error',",0
"import * as assert from 'node:assert/strict';
import { describe, it } from 'node:test';
import {
	isRemoteAllowed,
	matchHostname,
	matchPathname,
	matchPattern,
	matchPort,
	matchProtocol,
} from '@astrojs/internal-helpers/remote';

describe('remote-pattern', () => {
	const url1 = new URL('https://docs.astro.build/en/getting-started');
	const url2 = new URL('http://preview.docs.astro.build:8080/');
	const url3 = new URL('https://astro.build/');
	const url4 = new URL('https://example.co/');
	const url5 = new URL('data:text/plain;base64,SGVsbG8sIFdvcmxkIQ==');

	describe('remote pattern matchers', () => {
		it('matches protocol', async () => {
			// undefined
			assert.equal(matchProtocol(url1), true);

			// defined, true/false
			assert.equal(matchProtocol(url1, 'http'), false);
			assert.equal(matchProtocol(url1, 'https'), true);
			assert.equal(matchProtocol(url5, 'data'), true);
		});

		it('matches port', async () => {
			// undefined
			assert.equal(matchPort(url1), true);

			// defined, but port is empty (default port used in URL)
			assert.equal(matchPort(url1, ''), true);

			// defined and port is custom
			assert.equal(matchPort(url2, '8080'), true);
		});

		it('matches hostname (no wildcards)', async () => {
			// undefined
			assert.equal(matchHostname(url1), true);

			// defined, true/false
			assert.equal(matchHostname(url1, 'astro.build'), false);
			assert.equal(matchHostname(url1, 'docs.astro.build'), true);
		});

		it('matches hostname (with wildcards)', async () => {
			// defined, true/false
			assert.equal(matchHostname(url1, 'docs.astro.build', true), true);
			assert.equal(matchHostname(url1, '**.astro.build', true), true);
			assert.equal(matchHostname(url1, '*.astro.build', true), true);

			assert.equal(matchHostname(url2, '*.astro.build', true), false);
			assert.equal(matchHostname(url2, '**.astro.build', true), true);

			assert.equal(matchHostname(url3, 'astro.build', true), true);
			assert.equal(matchHostname(url3, '*.astro.build', true), false);
			assert.equal(matchHostname(url3, '**.astro.build', true), false);
		});

		it('rejects hostname without dots when using single wildcard (*.domain.com)', async () => {
			// hostnames without dots (like localhost) should not match *.astro.build
			const localhostUrl = new URL('http://localhost/');
			assert.equal(matchHostname(localhostUrl, '*.astro.build', true), false);

			const bareHostnameUrl = new URL('http://example/');
			assert.equal(matchHostname(bareHostnameUrl, '*.victim.com', true), false);

			const internalUrl = new URL('http://internal/');
			assert.equal(matchHostname(internalUrl, '*.astro.build', true), false);
		});

		it('matches pathname (no wildcards)', async () => {
			// undefined
			assert.equal(matchPathname(url1), true);

			// defined, true/false
			assert.equal(matchPathname(url1, '/'), false);
			assert.equal(matchPathname(url1, '/en/getting-started'), true);
		});

		it('matches pathname (with wildcards)', async () => {
			// defined, true/false
			assert.equal(matchPathname(url1, '/en/**', true), true);
			assert.equal(matchPathname(url1, '/en/*', true), true);
			assert.equal(matchPathname(url1, '/**', true), true);

			assert.equal(matchPathname(url2, '/**', true), false);
			assert.equal(matchPathname(url2, '/*', true), false);
		});

		it('matches patterns', async () => {
			assert.equal(matchPattern(url1, {}), true);

			assert.equal(
				matchPattern(url1, {
					protocol: 'https',
				}),
				true,
			);

			assert.equal(
				matchPattern(url1, {
					protocol: 'https',
					hostname: '**.astro.build',
				}),
				true,
			);

			assert.equal(
				matchPattern(url1, {
					protocol: 'https',
					hostname: '**.astro.build',
					pathname: '/en/**',
				}),
				true,
			);

			assert.equal(
				matchPattern(url4, {
					protocol: 'https',
					hostname: 'example.com',
				}),
				false,
			);

			assert.equal(
				matchPattern(url5, {
					protocol: 'data',
				}),
				true,
			);
		});
	});

	describe('remote is allowed', () => {
		it('allows remote URLs based on patterns', async () => {
			const patterns = {domains: [], remotePatterns: [
				{
					protocol: 'https',
					hostname: '**.astro.build',
					pathname: '/en/**',
				},
				{
					protocol: 'http',
					hostname: 'preview.docs.astro.build',
					port: '8080',
				},
			]};

			assert.equal(isRemoteAllowed(url1, patterns), true);
			assert.equal(isRemoteAllowed(url2, patterns), true);
			assert.equal(isRemoteAllowed(url3, patterns), false);
			assert.equal(isRemoteAllowed(url4, patterns), false);
			assert.equal(isRemoteAllowed(url5, patterns), false);
		});
	});
});",0
"	if (!URL.canParse(src)) {
		return false;
	}

	const url = new URL(src);

	// Non-http(s) protocols are never allowed
	if (!['http:', 'https:', 'data:'].includes(url.protocol)) {
		return false;
	}

	return (
		domains.some((domain) => matchHostname(url, domain)) ||
		remotePatterns.some((remotePattern) => matchPattern(url, remotePattern))",0
"		public request: Request,
		public routeData: RouteData,
		public status: number,
		public clientAddress: string | undefined,
		protected cookies = new AstroCookies(request),
		public params = getParams(routeData, pathname),
		protected url = RenderContext.#createNormalizedUrl(request.url),
		public props: Props = {},
		public partial: undefined | boolean = undefined,
		public shouldInjectCspMetaTags = !!pipeline.manifest.csp,
		public session: AstroSession | undefined = pipeline.manifest.sessionConfig
			? new AstroSession(cookies, pipeline.manifest.sessionConfig, pipeline.runtimeMode)
			: undefined,
	) {}

	static #createNormalizedUrl(requestUrl: string): URL {
		const url = new URL(requestUrl);
		try {
			url.pathname = decodeURI(url.pathname);
		} finally {
			return url;
		}
	}

	/**
	 * A flag that tells the render content if the rewriting was triggered
	 */
	isRewriting = false;
	/**
	 * A safety net in case of loops
	 */
	counter = 0;

	result: SSRResult | undefined = undefined;

	static async create({
		locals = {},
		middleware,
		pathname,
		pipeline,
		request,
		routeData,
		clientAddress,
		status = 200,
		props,
		partial = undefined,
		actions,
		shouldInjectCspMetaTags,
	}: Pick<RenderContext, 'pathname' | 'pipeline' | 'request' | 'routeData' | 'clientAddress'> &
		Partial<
			Pick<
				RenderContext,
				| 'locals'
				| 'middleware'
				| 'status'
				| 'props'
				| 'partial'
				| 'actions'
				| 'shouldInjectCspMetaTags'
			>
		>): Promise<RenderContext> {
		const pipelineMiddleware = await pipeline.getMiddleware();
		const pipelineActions = actions ?? (await pipeline.getActions());
		setOriginPathname(
			request,
			pathname,
			pipeline.manifest.trailingSlash,
			pipeline.manifest.buildFormat,
		);
		return new RenderContext(
			pipeline,
			locals,
			sequence(...pipeline.internalMiddleware, middleware ?? pipelineMiddleware),
			pipelineActions,
			pathname,
			request,
			routeData,
			status,
			clientAddress,
			undefined,
			undefined,
			undefined,
			props,
			partial,
			shouldInjectCspMetaTags ?? !!pipeline.manifest.csp,
		);
	}
	/**
	 * The main function of the RenderContext.
	 *
	 * Use this function to render any route known to Astro.
	 * It attempts to render a route. A route can be a:
	 *
	 * - page
	 * - redirect
	 * - endpoint
	 * - fallback
	 */
	async render(
		componentInstance: ComponentInstance | undefined,
		slots: Record<string, any> = {},
	): Promise<Response> {
		const { middleware, pipeline } = this;
		const { logger, serverLike, streaming, manifest } = pipeline;

		const props =
			Object.keys(this.props).length > 0
				? this.props
				: await getProps({
						mod: componentInstance,
						routeData: this.routeData,
						routeCache: this.pipeline.routeCache,
						pathname: this.pathname,
						logger,
						serverLike,
						base: manifest.base,
					});
		const actionApiContext = this.createActionAPIContext();
		const apiContext = this.createAPIContext(props, actionApiContext);

		this.counter++;
		if (this.counter === 4) {
			return new Response('Loop Detected', {
				// https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/508
				status: 508,
				statusText:
					'Astro detected a loop where you tried to call the rewriting logic more than four times.',
			});
		}
		const lastNext = async (ctx: APIContext, payload?: RewritePayload) => {
			if (payload) {
				const oldPathname = this.pathname;
				pipeline.logger.debug('router', 'Called rewriting to:', payload);
				// we intentionally let the error bubble up
				const {
					routeData,
					componentInstance: newComponent,
					pathname,
					newUrl,
				} = await pipeline.tryRewrite(payload, this.request);

				// This is a case where the user tries to rewrite from a SSR route to a prerendered route (SSG).
				// This case isn't valid because when building for SSR, the prerendered route disappears from the server output because it becomes an HTML file,
				// so Astro can't retrieve it from the emitted manifest.
				if (
					this.pipeline.serverLike === true &&
					this.routeData.prerender === false &&
					routeData.prerender === true
				) {
					throw new AstroError({
						...ForbiddenRewrite,
						message: ForbiddenRewrite.message(this.pathname, pathname, routeData.component),
						hint: ForbiddenRewrite.hint(routeData.component),
					});
				}

				this.routeData = routeData;
				componentInstance = newComponent;
				if (payload instanceof Request) {
					this.request = payload;
				} else {
					this.request = copyRequest(
						newUrl,
						this.request,
						// need to send the flag of the previous routeData
						routeData.prerender,
						this.pipeline.logger,
						this.routeData.route,
					);
				}
				this.isRewriting = true;
				this.url = RenderContext.#createNormalizedUrl(this.request.url);
				this.params = getParams(routeData, pathname);
				this.pathname = pathname;
				this.status = 200;
				setOriginPathname(
					this.request,
					oldPathname,
					this.pipeline.manifest.trailingSlash,
					this.pipeline.manifest.buildFormat,
				);
			}
			let response: Response;

			if (!ctx.isPrerendered) {
				const { action, setActionResult, serializeActionResult } = getActionContext(ctx);

				if (action?.calledFrom === 'form') {
					const actionResult = await action.handler();
					setActionResult(action.name, serializeActionResult(actionResult));
				}
			}

			switch (this.routeData.type) {
				case 'endpoint': {
					response = await renderEndpoint(
						componentInstance as any,
						ctx,
						this.routeData.prerender,
						logger,
					);
					break;
				}
				case 'redirect':
					return renderRedirect(this);
				case 'page': {
					this.result = await this.createResult(componentInstance!, actionApiContext);
					try {
						response = await renderPage(
							this.result,
							componentInstance?.default as any,
							props,
							slots,
							streaming,
							this.routeData,
						);
					} catch (e) {
						// If there is an error in the page's frontmatter or instantiation of the RenderTemplate fails midway,
						// we signal to the rest of the internals that we can ignore the results of existing renders and avoid kicking off more of them.
						this.result.cancelled = true;
						throw e;
					}

					// Signal to the i18n middleware to maybe act on this response
					response.headers.set(ROUTE_TYPE_HEADER, 'page');
					// Signal to the error-page-rerouting infra to let this response pass through to avoid loops
					if (this.routeData.route === '/404' || this.routeData.route === '/500') {
						response.headers.set(REROUTE_DIRECTIVE_HEADER, 'no');
					}
					if (this.isRewriting) {
						response.headers.set(REWRITE_DIRECTIVE_HEADER_KEY, REWRITE_DIRECTIVE_HEADER_VALUE);
					}
					break;
				}
				case 'fallback': {
					return new Response(null, { status: 500, headers: { [ROUTE_TYPE_HEADER]: 'fallback' } });
				}
			}
			// We need to merge the cookies from the response back into this.cookies
			// because they may need to be passed along from a rewrite.
			const responseCookies = getCookiesFromResponse(response);
			if (responseCookies) {
				this.cookies.merge(responseCookies);
			}
			return response;
		};

		// If we are rendering an extrnal redirect, we don't need go through the middleware,
		// otherwise Astro will attempt to render the external website
		if (isRouteExternalRedirect(this.routeData)) {
			return renderRedirect(this);
		}

		const response = await callMiddleware(middleware, apiContext, lastNext);
		if (response.headers.get(ROUTE_TYPE_HEADER)) {
			response.headers.delete(ROUTE_TYPE_HEADER);
		}
		// LEGACY: we put cookies on the response object,
		// where the adapter might be expecting to read it.
		// New code should be using `app.render({ addCookieHeader: true })` instead.
		attachCookiesToResponse(response, this.cookies);
		return response;
	}

	createAPIContext(props: APIContext['props'], context: ActionAPIContext): APIContext {
		const redirect = (path: string, status = 302) =>
			new Response(null, { status, headers: { Location: path } });

		Reflect.set(context, apiContextRoutesSymbol, this.pipeline);

		return Object.assign(context, {
			props,
			redirect,
			getActionResult: createGetActionResult(context.locals),
			callAction: createCallAction(context),
		});
	}

	async #executeRewrite(reroutePayload: RewritePayload) {
		this.pipeline.logger.debug('router', 'Calling rewrite: ', reroutePayload);
		const oldPathname = this.pathname;
		const { routeData, componentInstance, newUrl, pathname } = await this.pipeline.tryRewrite(
			reroutePayload,
			this.request,
		);
		// This is a case where the user tries to rewrite from a SSR route to a prerendered route (SSG).
		// This case isn't valid because when building for SSR, the prerendered route disappears from the server output because it becomes an HTML file,
		// so Astro can't retrieve it from the emitted manifest.
		// Allow i18n fallback rewrites - if the target route has fallback routes, this is likely an i18n scenario
		const isI18nFallback = routeData.fallbackRoutes && routeData.fallbackRoutes.length > 0;
		if (
			this.pipeline.serverLike &&
			!this.routeData.prerender &&
			routeData.prerender &&
			!isI18nFallback
		) {
			throw new AstroError({
				...ForbiddenRewrite,
				message: ForbiddenRewrite.message(this.pathname, pathname, routeData.component),
				hint: ForbiddenRewrite.hint(routeData.component),
			});
		}

		this.routeData = routeData;
		if (reroutePayload instanceof Request) {
			this.request = reroutePayload;
		} else {
			this.request = copyRequest(
				newUrl,
				this.request,
				// need to send the flag of the previous routeData
				routeData.prerender,
				this.pipeline.logger,
				this.routeData.route,
			);
		}
		this.url = RenderContext.#createNormalizedUrl(this.request.url);
		const newCookies = new AstroCookies(this.request);
		if (this.cookies) {
			newCookies.merge(this.cookies);
		}
		this.cookies = newCookies;
		this.params = getParams(routeData, pathname);",0
"		// We already have a middleware that checks if there's an incoming URL that has invalid URI, so it's safe
		// to not handle the error: packages/astro/src/vite-plugin-astro-server/base.ts
		pathname = decodeURI(url.pathname);
	}

	// Add config.base back to url before passing it to SSR
	url.pathname = removeTrailingForwardSlash(config.base) + decodeURI(url.pathname);

	// Apply trailing slash configuration consistently
	if (config.trailingSlash === 'never') {
		url.pathname = removeTrailingForwardSlash(url.pathname);
	} else if (config.trailingSlash === 'always' && !hasFileExtension(url.pathname)) {
		url.pathname = appendForwardSlash(url.pathname);",0
"			const data = devalue.parse(await res.text());
			assert.equal(data.success, true);
			assert.equal(data.isFormData, true, 'Should receive plain FormData');
		});

		it('Handles special characters in action names', async () => {
			for (const name of ['with%2Fslash', 'with%20space']) {
				const res = await fixture.fetch(`/_actions/${name}`, {
					method: 'POST',
					body: JSON.stringify({ name: 'ben' }),
					headers: {
						'Content-Type': 'application/json',
					},
				});
				assert.equal(res.ok, true);
				const text = await res.text();
				assert.equal(res.headers.get('Content-Type'), 'application/json+devalue');
				const data = devalue.parse(text);
				assert.equal(data, 'Hello, ben!');
			}
		});

		it('Returns 404 for non-existent action', async () => {
			const res = await fixture.fetch('/_actions/nonExistent', {
				method: 'POST',
				body: JSON.stringify({}),
				headers: {
					'Content-Type': 'application/json',
				},
			});
			assert.equal(res.status, 404);
			const data = await res.json();
			assert.equal(data.code, 'NOT_FOUND');
		});

		it('Should fail when calling an action without using Astro.callAction', async () => {
			const res = await fixture.fetch('/invalid/');
			const text = await res.text();
			assert.match(text, /ActionCalledFromServerError/);
		});
	});

	describe('build', () => {
		let app;

		before(async () => {
			await fixture.build();
			app = await fixture.loadTestAdapterApp();
		});

		it('Exposes subscribe action', async () => {
			const req = new Request('http://example.com/_actions/subscribe', {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json',
				},
				body: JSON.stringify({ channel: 'bholmesdev' }),
			});
			const res = await app.render(req);

			assert.equal(res.ok, true);
			assert.equal(res.headers.get('Content-Type'), 'application/json+devalue');

			const data = devalue.parse(await res.text());
			assert.equal(data.channel, 'bholmesdev');
			assert.equal(data.subscribeButtonState, 'smashed');
		});

		it('Exposes comment action', async () => {
			const formData = new FormData();
			formData.append('channel', 'bholmesdev');
			formData.append('comment', 'Hello, World!');
			const req = new Request('http://example.com/_actions/comment', {
				method: 'POST',
				body: formData,
			});
			const res = await app.render(req);

			assert.equal(res.ok, true);
			assert.equal(res.headers.get('Content-Type'), 'application/json+devalue');

			const data = devalue.parse(await res.text());
			assert.equal(data.channel, 'bholmesdev');
			assert.equal(data.comment, 'Hello, World!');
		});

		it('Raises validation error on bad form data', async () => {
			const formData = new FormData();
			formData.append('channel', 'bholmesdev');
			const req = new Request('http://example.com/_actions/comment', {
				method: 'POST',
				body: formData,
			});
			const res = await app.render(req);

			assert.equal(res.ok, false);
			assert.equal(res.status, 400);
			assert.equal(res.headers.get('Content-Type'), 'application/json');

			const data = await res.json();
			assert.equal(data.type, 'AstroActionInputError');
		});

		it('Exposes plain formData action', async () => {
			const formData = new FormData();
			formData.append('channel', 'bholmesdev');
			formData.append('comment', 'Hello, World!');
			const req = new Request('http://example.com/_actions/commentPlainFormData', {
				method: 'POST',
				body: formData,
			});
			const res = await app.render(req);

			assert.equal(res.ok, true);
			assert.equal(res.headers.get('Content-Type'), 'application/json+devalue');

			const data = devalue.parse(await res.text());
			assert.equal(data.success, true);
			assert.equal(data.isFormData, true, 'Should receive plain FormData');
		});

		it('Response middleware fallback - POST', async () => {
			const req = new Request('http://example.com/user?_action=getUser', {
				method: 'POST',
				body: new FormData(),
				headers: {
					Referer: 'http://example.com/user',
				},
			});
			const res = await app.render(req);
			assert.equal(res.ok, true);

			const html = await res.text();
			let $ = cheerio.load(html);
			assert.equal($('#user').text(), 'Houston');
		});

		it('Response middleware fallback - cookie forwarding', async () => {
			const req = new Request(
				'http://example.com/user?_action=getUser&actionCookieForwarding=true',
				{
					method: 'POST',
					body: new FormData(),
					headers: {
						Referer: 'http://example.com/user',
					},
				},
			);
			const res = await followExpectedRedirect(req, app);
			assert.equal(res.ok, true);

			const html = await res.text();
			let $ = cheerio.load(html);
			assert.equal($('#user').text(), 'Houston');
		});

		it('Respects custom errors - POST', async () => {
			const req = new Request('http://example.com/user-or-throw?_action=getUserOrThrow', {
				method: 'POST',
				body: new FormData(),
				headers: {
					Referer: 'http://example.com/user-or-throw',
				},
			});
			const res = await app.render(req);
			assert.equal(res.status, 401);

			const html = await res.text();
			let $ = cheerio.load(html);
			assert.equal($('#error-message').text(), 'Not logged in');
			assert.equal($('#error-code').text(), 'UNAUTHORIZED');
		});

		it('Respects custom errors - cookie forwarding', async () => {
			const req = new Request(
				'http://example.com/user-or-throw?_action=getUserOrThrow&actionCookieForwarding=true',
				{
					method: 'POST',
					body: new FormData(),
					headers: {
						Referer: 'http://example.com/user-or-throw',
					},
				},
			);
			const res = await followExpectedRedirect(req, app);
			assert.equal(res.status, 401);

			const html = await res.text();
			let $ = cheerio.load(html);
			assert.equal($('#error-message').text(), 'Not logged in');
			assert.equal($('#error-code').text(), 'UNAUTHORIZED');
		});

		it('Respects RPC middleware handling - locked', async () => {
			const req = new Request('http://example.com/_actions/locked', {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json',
				},
				body: '{}',
			});
			const res = await app.render(req);
			assert.equal(res.status, 401);
		});

		it('Respects RPC middleware handling - cookie present', async () => {
			const req = new Request('http://example.com/_actions/locked', {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json',
					Cookie: 'actionCookie=1234',
				},
				body: '{}',
			});
			const res = await app.render(req);
			assert.equal(res.ok, true);
			assert.equal(res.headers.get('Content-Type'), 'application/json+devalue');

			const data = devalue.parse(await res.text());
			assert.equal('safe' in data, true);
		});

		it('Ignores action name for GET requests', async () => {
			const req = new Request('http://example.com/user-or-throw?_action=getUserOrThrow', {
				method: 'GET',
			});
			const res = await app.render(req);
			assert.equal(res.ok, true);

			const html = await res.text();
			let $ = cheerio.load(html);
			assert.ok($('#user'));
		});

		it('Supports effects on form input validators', async () => {
			const formData = new FormData();
			formData.set('password', 'benisawesome');
			formData.set('confirmPassword', 'benisveryawesome');

			const req = new Request('http://example.com/_actions/validatePassword', {
				method: 'POST',
				body: formData,
			});

			const res = await app.render(req);

			assert.equal(res.ok, false);
			assert.equal(res.status, 400);
			assert.equal(res.headers.get('Content-Type'), 'application/json');

			const data = await res.json();
			assert.equal(data.type, 'AstroActionInputError');
			assert.equal(data.issues?.[0]?.message, 'Passwords do not match');
		});

		it('Supports complex chained effects on form input validators', async () => {
			const formData = new FormData();
			formData.set('currentPassword', 'benisboring');
			formData.set('newPassword', 'benisawesome');
			formData.set('confirmNewPassword', 'benisawesome');

			const req = new Request('http://example.com/_actions/validatePasswordComplex', {
				method: 'POST',
				body: formData,
			});

			const res = await app.render(req);

			assert.equal(res.ok, true);
			assert.equal(res.headers.get('Content-Type'), 'application/json+devalue');

			const data = devalue.parse(await res.text());
			assert.equal(Object.keys(data).length, 2, 'More keys than expected');
			assert.deepEqual(data, {
				currentPassword: 'benisboring',
				newPassword: 'benisawesome',
			});
		});

		it('Supports input form data transforms', async () => {
			const formData = new FormData();
			formData.set('name', 'ben');
			formData.set('age', '42');

			const req = new Request('http://example.com/_actions/transformFormInput', {
				method: 'POST',
				body: formData,
			});

			const res = await app.render(req);

			assert.equal(res.ok, true);
			assert.equal(res.headers.get('Content-Type'), 'application/json+devalue');

			const data = devalue.parse(await res.text());
			assert.equal(data?.name, 'ben');
			assert.equal(data?.age, '42');
		});

		it('Sets status to 204 when content-length is 0', async () => {
			const req = new Request('http://example.com/_actions/fireAndForget', {
				method: 'POST',
				headers: {
					'Content-Length': '0',
				},
			});
			const res = await app.render(req);
			assert.equal(res.status, 204);
		});

		it('Sets status to 204 when content-type is omitted', async () => {
			const req = new Request('http://example.com/_actions/fireAndForget', {
				method: 'POST',
			});
			const res = await app.render(req);
			assert.equal(res.status, 204);
		});

		it('Sets status to 415 when content-type is unexpected', async () => {
			const req = new Request('http://example.com/_actions/fireAndForget', {
				method: 'POST',
				body: 'hey',
				headers: {
					'Content-Type': 'text/plain',
				},
			});
			const res = await app.render(req);
			assert.equal(res.status, 415);
		});

		it('Is callable from the server with rewrite', async () => {
			const req = new Request('http://example.com/rewrite');
			const res = await app.render(req);
			assert.equal(res.ok, true);

			const html = await res.text();
			let $ = cheerio.load(html);
			assert.equal($('[data-url]').text(), '/subscribe');
			assert.equal($('[data-channel]').text(), 'bholmesdev');
		});

		it('Returns content when the value is 0', async () => {
			const req = new Request('http://example.com/_actions/zero', {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json',
					'Content-Length': '0',
				},
			});
			const res = await app.render(req);
			assert.equal(res.status, 200);
			const value = devalue.parse(await res.text());
			assert.equal(value, 0);
		});

		it('Returns content when the value is false', async () => {
			const req = new Request('http://example.com/_actions/false', {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json',
					'Content-Length': '0',
				},
			});
			const res = await app.render(req);
			assert.equal(res.status, 200);

			const value = devalue.parse(await res.text());
			assert.equal(value, false);
		});

		it('Supports complex values: Date, Set, URL', async () => {
			const req = new Request('http://example.com/_actions/complexValues', {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json',
					'Content-Length': '0',
				},
			});
			const res = await app.render(req);
			assert.equal(res.status, 200);
			assert.equal(res.headers.get('Content-Type'), 'application/json+devalue');

			const value = devalue.parse(await res.text(), {
				URL: (href) => new URL(href),
			});
			assert.ok(value.date instanceof Date);
			assert.ok(value.set instanceof Set);
		});

		it('Supports discriminated union for different form fields', async () => {
			const formData = new FormData();
			formData.set('type', 'first-chunk');
			formData.set('alt', 'Cool image');
			formData.set('image', new File([''], 'chunk-1.png'));
			const reqFirst = new Request('http://example.com/_actions/imageUploadInChunks', {
				method: 'POST',
				body: formData,
			});

			const resFirst = await app.render(reqFirst);
			assert.equal(resFirst.status, 200);
			assert.equal(resFirst.headers.get('Content-Type'), 'application/json+devalue');
			const data = devalue.parse(await resFirst.text());
			const uploadId = data?.uploadId;
			assert.ok(uploadId);

			const formDataRest = new FormData();
			formDataRest.set('type', 'rest-chunk');
			formDataRest.set('uploadId', 'fake');
			formDataRest.set('image', new File([''], 'chunk-2.png'));
			const reqRest = new Request('http://example.com/_actions/imageUploadInChunks', {
				method: 'POST',
				body: formDataRest,
			});

			const resRest = await app.render(reqRest);
			assert.equal(resRest.status, 200);
			assert.equal(resRest.headers.get('Content-Type'), 'application/json+devalue');
			const dataRest = devalue.parse(await resRest.text());
			assert.equal('fake', dataRest?.uploadId);
		});

		it('Handles special characters in action names', async () => {
			for (const name of ['with%2Fslash', 'with%20space']) {
				const req = new Request(`http://example.com/_actions/${name}`, {
					method: 'POST',
					body: JSON.stringify({ name: 'ben' }),
					headers: {
						'Content-Type': 'application/json',
					},",0
"import { defineMiddleware, sequence } from 'astro:middleware';

const first = defineMiddleware(async (context, next) => {
	// Auth check: protect /admin route
	if (context.url.pathname === '/admin') {
		const authToken = context.request.headers.get('Authorization');
		if (!authToken) {
			return context.redirect('/');
		}
		// Auth token present, allow access
		return await next();
	}

	if (context.request.url.includes('/lorem')) {
		context.locals.name = 'ipsum';
	} else if (context.request.url.includes('/rewrite')) {
		return new Response('<span>New content!!</span>', {
			status: 200,
		});",0
"	it('should forward cookies set in a component when the middleware returns a new response', async () => {
		const res = await fixture.fetch('/return-response-cookies');
		const headers = res.headers;
		assert.notEqual(headers.get('set-cookie'), null);
	});

	describe('Path encoding in middleware', () => {
		it('should protect /admin route with auth check', async () => {
			const res = await fixture.fetch('/admin', { redirect: 'manual' });
			assert.equal(res.status, 302);
			assert.equal(res.headers.get('location'), '/');
		});

		it('should NOT allow accessing /admin with url encoding', async () => {
			const res = await fixture.fetch('/%61dmin', { redirect: 'manual' });
			assert.equal(res.status, 302);
			assert.equal(res.headers.get('location'), '/');
		});

		it('should NOT allow accessing /admin with fully encoded path', async () => {
			const res = await fixture.fetch('/%61%64%6d%69%6e', { redirect: 'manual' });
			assert.equal(res.status, 302);
			assert.equal(res.headers.get('location'), '/');
		});
	});

	describe('Integration hooks', () => {
		it('Integration middleware marked as ""pre"" runs', async () => {
			const res = await fixture.fetch('/integration-pre');
			const json = await res.json();
			assert.equal(json.pre, 'works');
		});

		it('Integration middleware marked as ""post"" runs', async () => {
			const res = await fixture.fetch('/integration-post');
			const json = await res.json();
			assert.equal(json.post, 'works');
		});
	});
});

describe('Integration hooks with no user middleware', () => {
	/** @type {import('./test-utils').Fixture} */
	let fixture;
	let devServer;
	before(async () => {
		fixture = await loadFixture({
			root: './fixtures/middleware-no-user-middleware/',
		});
		devServer = await fixture.startDevServer();
	});

	after(async () => {
		await devServer.stop();
	});

	it('Integration middleware marked as ""pre"" runs', async () => {
		const res = await fixture.fetch('/pre');
		const json = await res.json();
		assert.equal(json.pre, 'works');
	});

	it('Integration middleware marked as ""post"" runs', async () => {
		const res = await fixture.fetch('/post');
		const json = await res.json();
		assert.equal(json.post, 'works');
	});

	it('Integration middleware marked as ""url"" runs', async () => {
		const res = await fixture.fetch('/url');
		const json = await res.json();
		assert.equal(json.post, 'works');
	});
});

describe('Middleware in PROD mode, SSG', () => {
	/** @type {import('./test-utils').Fixture} */
	let fixture;

	before(async () => {
		fixture = await loadFixture({
			root: './fixtures/middleware-ssg/',
		});
		await fixture.build();
	});

	it('should render locals data', async () => {
		const html = await fixture.readFile('/index.html');
		const $ = cheerio.load(html);
		assert.equal($('p').html(), 'bar');
	});

	it('should change locals data based on URL', async () => {
		let html = await fixture.readFile('/index.html');
		let $ = cheerio.load(html);
		assert.equal($('p').html(), 'bar');

		html = await fixture.readFile('/second/index.html');
		$ = cheerio.load(html);
		assert.equal($('p').html(), 'second');
	});
});

describe('Middleware should not be executed or imported during', () => {
	/** @type {import('./test-utils').Fixture} */
	let fixture;

	it('should build the project without errors', async () => {
		fixture = await loadFixture({
			root: './fixtures/middleware-full-ssr/',
			output: 'server',
			adapter: testAdapter({}),
		});
		await fixture.build();
		assert.ok('Should build');
	});
});

describe('Middleware API in PROD mode, SSR', () => {
	/** @type {import('./test-utils').Fixture} */
	let fixture;
	let middlewarePath;
	/** @type {import('../src/core/app/index').App} */
	let app;

	before(async () => {
		fixture = await loadFixture({
			root: './fixtures/middleware space/',
			output: 'server',
			adapter: testAdapter({}),
		});
		await fixture.build();
		app = await fixture.loadTestAdapterApp();
	});

	it('should render locals data', async () => {
		const request = new Request('http://example.com/');
		const response = await app.render(request);
		const html = await response.text();
		const $ = cheerio.load(html);
		assert.equal($('p').html(), 'bar');
	});

	it('should change locals data based on URL', async () => {
		let response = await app.render(new Request('http://example.com/'));
		let html = await response.text();
		let $ = cheerio.load(html);
		assert.equal($('p').html(), 'bar');

		response = await app.render(new Request('http://example.com/lorem'));
		html = await response.text();
		$ = cheerio.load(html);
		assert.equal($('p').html(), 'ipsum');
	});

	it('should successfully redirect to another page', async () => {
		const request = new Request('http://example.com/redirect');
		const response = await app.render(request);
		assert.equal(response.status, 302);
	});

	it('should call a second middleware', async () => {
		const response = await app.render(new Request('http://example.com/second'));
		const html = await response.text();
		const $ = cheerio.load(html);
		assert.equal($('p').html(), 'second');
	});

	it('should successfully create a new response', async () => {
		const request = new Request('http://example.com/rewrite');
		const response = await app.render(request);
		const html = await response.text();
		const $ = cheerio.load(html);
		assert.equal($('p').html(), null);
		assert.equal($('span').html(), 'New content!!');
	});

	it('should return a new response that is a 500', async () => {
		const request = new Request('http://example.com/broken-500');
		const response = await app.render(request);
		assert.equal(response.status, 500);
	});

	it('should successfully render a page if the middleware calls only next() and returns nothing', async () => {
		const request = new Request('http://example.com/not-interested');
		const response = await app.render(request);
		const html = await response.text();
		const $ = cheerio.load(html);
		assert.equal($('p').html(), 'Not interested');
	});

	it(""should throw an error when the middleware doesn't call next or doesn't return a response"", async () => {
		const request = new Request('http://example.com/does-nothing');
		const response = await app.render(request);
		const html = await response.text();
		const $ = cheerio.load(html);
		assert.notEqual($('title').html(), 'MiddlewareNoDataReturned');
	});

	it('should return 200 if the middleware returns a 200 Response', async () => {
		const request = new Request('http://example.com/no-route-but-200');
		const response = await app.render(request);
		assert.equal(response.status, 200);
		const html = await response.text();
		assert.match(html, /It's OK!/);
	});

	it('should correctly work for API endpoints that return a Response object', async () => {
		const request = new Request('http://example.com/api/endpoint');
		const response = await app.render(request);
		assert.equal(response.status, 200);
		assert.equal(response.headers.get('Content-Type'), 'application/json');
	});

	it('should correctly manipulate the response coming from API endpoints (not simple)', async () => {
		const request = new Request('http://example.com/api/endpoint');
		const response = await app.render(request);
		const text = await response.text();
		assert.equal(text.includes('REDACTED'), true);
	});

	it('should correctly call the middleware function for 404', async () => {
		const request = new Request('http://example.com/funky-url');
		const routeData = app.match(request);
		const response = await app.render(request, { routeData });
		const text = await response.text();
		assert.equal(text.includes('Error'), true);
		assert.equal(text.includes('bar'), true);
	});

	it('should render 500.astro when the middleware throws an error', async () => {
		const request = new Request('http://example.com/throw');
		const routeData = app.match(request);

		const response = await app.render(request, { routeData });
		assert.equal(response.status, 500);

		const text = await response.text();
		assert.equal(text.includes('<h1>There was an error rendering the page.</h1>'), true);
	});

	it('should correctly render the page even when custom headers are set in a middleware', async () => {
		const request = new Request('http://example.com/content-policy');
		const routeData = app.match(request);

		const response = await app.render(request, { routeData });
		assert.equal(response.status, 404);
		assert.equal(response.headers.get('content-type'), 'text/html');
	});

	it('can render a page that does not exist', async () => {
		const request = new Request('http://example.com/does-not-exist');
		const routeData = app.match(request);

		const response = await app.render(request, { routeData });
		assert.equal(response.status, 200);
		const html = await response.text();
		const $ = cheerio.load(html);
		assert.equal($('p').html(), null);
		assert.equal($('span').html(), 'New content!!');
	});

	it('can set locals for prerendered pages to use', async () => {
		const text = await fixture.readFile('/client/prerendered/index.html');
		assert.equal(text.includes('<p>yes they can!</p>'), true);
	});

	describe('Path encoding in middleware', () => {
		it('should allow accessing /admin with valid auth header', async () => {
			const request = new Request('http://example.com/admin', {
				headers: { Authorization: 'Bearer token123' },
			});
			const response = await app.render(request);
			assert.equal(response.status, 200);
			const html = await response.text();
			assert.equal(html.includes('Admin Panel'), true);
		});

		it('should NOT allow accessing /admin without auth header', async () => {
			const request = new Request('http://example.com/admin');
			const response = await app.render(request);
			assert.equal(response.status, 302);
		});

		it('should NOT allow accessing /admin with url encoding', async () => {
			const request = new Request('http://example.com/%61dmin');
			const response = await app.render(request);
			assert.equal(response.status, 302);
		});

		it('should NOT allow accessing /admin with fully encoded path', async () => {
			const request = new Request('http://example.com/%61%64%6d%69%6e');
			const response = await app.render(request);
			assert.equal(response.status, 302);
		});
	});

	// keep this last
	it('the integration should receive the path to the middleware', async () => {
		fixture = await loadFixture({
			root: './fixtures/middleware space/',
			output: 'server',
			build: {",0
"}

export function trailingSlashMismatchTemplate(
	pathname: string,
	trailingSlash: 'always' | 'never' | 'ignore',
) {
	const corrected = escape(
		trailingSlash === 'always'
			? appendForwardSlash(pathname)
			: removeTrailingForwardSlash(pathname),
	);
	return template({
		pathname,
		statusCode: 404,
		title: 'Not found',
		tabTitle: '404: Not Found',
		body: `<p>Your site is configured with <code>trailingSlash</code> set to <code>${trailingSlash}</code>. Do you want to go to <a href=""${corrected}"">${corrected}</a> instead?</p>",0
"	mode: 'dev' | 'build',
	cwd?: string,
): RouteData {
	const endpointEntrypoint =
		settings.config.image.endpoint.entrypoint === undefined // If not set, use default endpoint
			? mode === 'dev'
				? 'astro/assets/endpoint/dev'
				: 'astro/assets/endpoint/generic'
			: settings.config.image.endpoint.entrypoint;

	const segments = [
		[
			{",0
"
		if (isRemoteImage && isRemoteAllowed(transform.src, imageConfig) === false) {
			return new Response('Forbidden', { status: 403 });
		}

		const sourceUrl = new URL(transform.src, url.origin);

		// Have we been tricked into thinking this is local?
		if (!isRemoteImage && sourceUrl.origin !== url.origin) {
			return new Response('Forbidden', { status: 403 });
		}

		inputBuffer = await loadRemoteImage(sourceUrl, isRemoteImage ? new Headers() : request.headers);

		if (!inputBuffer) {
			return new Response('Not Found', { status: 404 });
		}
",0
"// @ts-expect-error
import { outDir } from 'astro:assets';
import { readFile } from 'node:fs/promises';
import { fileURLToPath } from 'node:url';
import { isParentDirectory } from '@astrojs/internal-helpers/path';
import type { APIRoute } from '../../types/public/common.js';
import { handleImageRequest } from './shared.js';

async function loadLocalImage(src: string, url: URL) {
	// If the _image segment isn't at the start of the path, we have a base
	const idx = url.pathname.indexOf('/_image');
	if (idx > 0) {
		// Remove the base path
		src = src.slice(idx);
	}
	if (!URL.canParse('.' + src, outDir)) {
		return undefined;
	}
	const fileUrl = new URL('.' + src, outDir);
	if (fileUrl.protocol !== 'file:') {
		return undefined;
	}
	if (!isParentDirectory(fileURLToPath(outDir), fileURLToPath(fileUrl))) {
		return undefined;
	}

	try {
		return await readFile(fileUrl);
	} catch {
		return undefined;
	}
}



/**
 * Endpoint used in dev and SSR to serve optimized images by the base image services
 */
export const GET: APIRoute = async ({ request }) => {
	try {
		return await handleImageRequest({ request, loadLocalImage });
	} catch (err: unknown) {
		console.error('Could not process image request:', err);
		return new Response('Internal Server Error', {
			status: 500,
		});
	}
};",0
"		return quality;
	}

	return result;
}

export type ImageConfig<T> = Omit<AstroConfig['image'], 'service'> & {
	service: { entrypoint: string; config: T };
};

interface SharedServiceProps<T extends Record<string, any> = Record<string, any>> {
	/**
	 * Return the URL to the endpoint or URL your images are generated from.
	 *
	 * For a local service, your service should expose an endpoint handling the image requests, or use Astro's which by default, is located at `/_image`.
	 *
	 * For external services, this should point to the URL your images are coming from, for instance, `/_vercel/image`
	 *
	 */
	getURL: (options: ImageTransform, imageConfig: ImageConfig<T>) => string | Promise<string>;
	/**
	 * Generate additional `srcset` values for the image.
	 *
	 * While in most cases this is exclusively used for `srcset`, it can also be used in a more generic way to generate
	 * multiple variants of the same image. For instance, you can use this to generate multiple aspect ratios or multiple formats.
	 */
	getSrcSet?: (
		options: ImageTransform,
		imageConfig: ImageConfig<T>,
	) => UnresolvedSrcSetValue[] | Promise<UnresolvedSrcSetValue[]>;
	/**
	 * Return any additional HTML attributes separate from `src` that your service requires to show the image properly.
	 *
	 * For example, you might want to return the `width` and `height` to avoid CLS, or a particular `class` or `style`.
	 * In most cases, you'll want to return directly what your user supplied you, minus the attributes that were used to generate the image.
	 */
	getHTMLAttributes?: (
		options: ImageTransform,
		imageConfig: ImageConfig<T>,
	) => Record<string, any> | Promise<Record<string, any>>;
	/**
	 * Validate and return the options passed by the user.
	 *
	 * This method is useful to present errors to users who have entered invalid options.
	 * For instance, if they are missing a required property or have entered an invalid image format.
	 *
	 * This method should returns options, and can be used to set defaults (ex: a default output format to be used if the user didn't specify one.)
	 */
	validateOptions?: (
		options: ImageTransform,
		imageConfig: ImageConfig<T>,
	) => ImageTransform | Promise<ImageTransform>;
}

export type ExternalImageService<T extends Record<string, any> = Record<string, any>> =
	SharedServiceProps<T>;

export type LocalImageTransform = {
	src: string;
	[key: string]: any;
};

export interface LocalImageService<T extends Record<string, any> = Record<string, any>>
	extends SharedServiceProps<T> {",0
"					let $img = $('#remote img');
					assert.equal($img.attr('alt'), 'fred');
				});

				it('includes loading and decoding attributes', () => {
					let $img = $('#remote img');
					assert.ok($img.attr('loading'));
					assert.ok($img.attr('decoding'));
				});

				it('includes width and height attributes', () => {
					let $img = $('#remote img');
					assert.ok($img.attr('width'));
					assert.ok($img.attr('height'));
				});

				it('support data: URI', () => {
					let $img = $('#data-uri img');
					assert.ok($img.attr('src').startsWith('/_image?href=data'));
					assert.ok($img.attr('width'));
					assert.ok($img.attr('height'));
				});

				it('support images from public', () => {
					let $img = $('#public img');
					assert.equal($img.attr('src'), '/penguin3.jpg');
					assert.ok($img.attr('width'));
					assert.ok($img.attr('height'));
				});
			});

			it('error if no width and height', async () => {
				logs.length = 0;
				let res = await fixture.fetch('/remote-error-no-dimensions');
				await res.text();

				assert.equal(logs.length, 1);
				assert.equal(logs[0].message.includes('Missing width and height attributes'), true);
			});

			it('error if no height', async () => {
				logs.length = 0;
				let res = await fixture.fetch('/remote-error-no-height');
				await res.text();

				assert.equal(logs.length, 1);
				assert.equal(logs[0].message.includes('Missing height attribute'), true);
			});

			it('supports aliases', async () => {
				let res = await fixture.fetch('/alias');
				let html = await res.text();
				let $ = cheerio.load(html);

				let $img = $('img');
				assert.equal($img.length, 1);
				assert.equal($img.attr('src').includes('penguin1.jpg'), true);
			});
		});

		describe('markdown', () => {
			let $;
			before(async () => {
				let res = await fixture.fetch('/post');
				let html = await res.text();
				$ = cheerio.load(html);
			});

			it('Adds the <img> tag', () => {
				let $img = $('img');
				assert.equal($img.length, 2);

				// Verbose test for the full URL to make sure the image went through the full pipeline
				assert.equal(
					$img.attr('src').startsWith('/_image') && $img.attr('src').endsWith('f=webp'),
					true,
				);
			});

			it('has width and height attributes', () => {
				let $img = $('img');
				assert.equal(!!$img.attr('width'), true);
				assert.equal(!!$img.attr('height'), true);
			});

			it('Supports aliased paths', async () => {
				let res = await fixture.fetch('/aliasMarkdown');
				let html = await res.text();
				$ = cheerio.load(html);

				let $img = $('img');
				assert.equal($img.attr('src').startsWith('/_image'), true);
			});

			it('Supports special characters in file name', async () => {
				let res = await fixture.fetch('/specialChars');
				let html = await res.text();
				$ = cheerio.load(html);

				let $img = $('img');
				assert.equal($img.length, 4);
				$img.each((_, el) => {
					assert.equal(el.attribs.src?.startsWith('/_image'), true);
				});
			});

			it('properly handles remote images', async () => {
				let res = await fixture.fetch('/httpImage');
				let html = await res.text();
				$ = cheerio.load(html);

				let $img = $('img');
				assert.equal($img.length, 2);
				const remoteUrls = ['https://example.com/image.png', '/image.png'];
				$img.each((index, element) => {
					assert.equal(element.attribs['src'], remoteUrls[index]);
				});
			});
		});

		describe('getImage', () => {
			let $;
			before(async () => {
				let res = await fixture.fetch('/get-image');
				let html = await res.text();
				$ = cheerio.load(html);
			});

			it('Adds the <img> tag', () => {
				let $img = $('img');
				assert.equal($img.length, 1);
				assert.equal($img.attr('src').startsWith('/_image'), true);
			});

			it('includes the provided alt', () => {
				let $img = $('img');
				assert.equal($img.attr('alt'), 'a penguin');
			});
		});

		describe('content collections', () => {
			let $;
			before(async () => {
				let res = await fixture.fetch('/blog/one');
				let html = await res.text();
				$ = cheerio.load(html);
			});

			it('Adds the <img> tags', () => {
				let $img = $('img');
				assert.equal($img.length, 8);
			});

			it('image in cc folder is processed', () => {
				let $imgs = $('img');
				let $blogfolderimg = $($imgs[7]);
				assert.equal($blogfolderimg.attr('src').includes('blogfolder.jpg'), true);
				assert.equal($blogfolderimg.attr('src').endsWith('f=webp'), true);
			});

			it('has proper source for directly used image', () => {
				let $img = $('#direct-image img');
				assert.equal($img.attr('src').startsWith('/'), true);
			});

			it('has proper source for refined image', () => {
				let $img = $('#refined-image img');
				assert.equal($img.attr('src').startsWith('/'), true);
			});

			it('has proper sources for array of images', () => {
				let $img = $('#array-of-images img');
				const imgsSrcs = [];
				$img.each((_i, img) => imgsSrcs.push(img.attribs['src']));
				assert.equal($img.length, 2);
				assert.equal(
					imgsSrcs.every((img) => img.startsWith('/')),
					true,
				);
			});

			it('has proper attributes for optimized image through getImage', () => {
				let $img = $('#optimized-image-get-image img');
				assert.equal($img.attr('src').startsWith('/_image'), true);
				assert.equal($img.attr('width'), '207');
				assert.equal($img.attr('height'), '243');
			});

			it('has proper attributes for optimized image through Image component', () => {
				let $img = $('#optimized-image-component img');
				assert.equal($img.attr('src').startsWith('/_image'), true);
				assert.equal($img.attr('width'), '207');
				assert.equal($img.attr('height'), '243');
				assert.equal($img.attr('alt'), 'A penguin!');
			});

			it('properly handles nested images', () => {
				let $img = $('#nested-image img');
				assert.equal($img.attr('src').startsWith('/'), true);
			});
		});

		describe('regular img tag', () => {
			/** @type {ReturnType<import('cheerio')['load']>} */
			let $;
			before(async () => {
				let res = await fixture.fetch('/regular-img');
				let html = await res.text();
				$ = cheerio.load(html);
			});

			it('does not have a file url', async () => {
				assert.equal($('img').attr('src').startsWith('file://'), false);
			});

			it('includes /src in the path', async () => {
				assert.equal($('img').attr('src').includes('/src'), true);
			});
		});

		describe('custom service', () => {
			it('custom service implements getHTMLAttributes', async () => {
				const response = await fixture.fetch('/');
				const html = await response.text();

				const $ = cheerio.load(html);
				assert.equal($('#local img').attr('data-service'), 'my-custom-service');
			});

			it('custom service works in Markdown', async () => {
				const response = await fixture.fetch('/post');
				const html = await response.text();

				const $ = cheerio.load(html);
				assert.equal($('img').attr('data-service'), 'my-custom-service');
			});

			it('gets service config', async () => {
				const response = await fixture.fetch('/');
				const html = await response.text();

				const $ = cheerio.load(html);
				assert.equal($('#local img').attr('data-service-config'), 'bar');
			});
		});

		describe('custom endpoint', async () => {
			/** @type {import('./test-utils').DevServer} */
			let customEndpointDevServer;

			/** @type {import('./test-utils.js').Fixture} */
			let customEndpointFixture;

			before(async () => {
				customEndpointFixture = await loadFixture({
					root: './fixtures/core-image/',
					image: {
						endpoint: { entrypoint: './src/custom-endpoint.ts' },
						service: testImageService({ foo: 'bar' }),
						domains: ['avatars.githubusercontent.com'],
					},
				});

				customEndpointDevServer = await customEndpointFixture.startDevServer({
					server: { port: 4324 },
				});
			});

			it('custom endpoint works', async () => {
				const response = await customEndpointFixture.fetch('/');
				const html = await response.text();

				const $ = cheerio.load(html);
				const src = $('#local img').attr('src');

				let res = await customEndpointFixture.fetch(src);
				assert.equal(res.status, 200);
				assert.equal(
					await res.text(),
					""You fool! I'm not a image endpoint at all, I just return this!"",
				);
			});

			after(async () => {
				await customEndpointDevServer.stop();
			});
		});
	});

	describe('proper errors', () => {
		/** @type {import('./test-utils').DevServer} */
		let devServer;
		/** @type {Array<{ type: any, level: 'error', message: string; }>} */
		let logs = [];

		before(async () => {
			fixture = await loadFixture({
				root: './fixtures/core-image-errors/',
				image: {
					service: testImageService(),
				},
			});

			devServer = await fixture.startDevServer({
				logger: new Logger({
					level: 'error',
					dest: new Writable({
						objectMode: true,
						write(event, _, callback) {
							logs.push(event);
							callback();
						},
					}),
				}),
			});
		});

		after(async () => {
			await devServer.stop();
		});

		it(""properly error when getImage's first parameter isn't filled"", async () => {
			logs.length = 0;
			let res = await fixture.fetch('/get-image-empty');
			await res.text();

			assert.equal(logs.length >= 1, true);
			assert.equal(logs[0].message.includes('Expected getImage() parameter'), true);
		});

		it('properly error when src is undefined', async () => {
			logs.length = 0;
			let res = await fixture.fetch('/get-image-undefined');
			await res.text();

			assert.equal(logs.length >= 1, true);
			assert.equal(logs[0].message.includes('Expected `src` property'), true);
		});

		it('errors when an ESM imported image is passed directly to getImage', async () => {
			logs.length = 0;
			let res = await fixture.fetch('/get-image-import-passed');
			await res.text();
			assert.equal(logs.length >= 1, true);
			assert.equal(
				logs[0].message.includes('An ESM-imported image cannot be passed directly'),
				true,
			);
		});

		it('properly error image in Markdown frontmatter is not found', async () => {
			logs.length = 0;
			let res = await fixture.fetch('/blog/one');
			await res.text();

			assert.equal(logs.length, 1);
			assert.equal(logs[0].message.includes('does not exist. Is the path correct?'), true);
		});

		it('properly error image in Markdown content is not found', async () => {
			logs.length = 0;
			let res = await fixture.fetch('/post');
			await res.text();
			assert.equal(logs.length, 1);
			assert.equal(logs[0].message.includes('Could not find requested image'), true);
		});
	});

	describe('support base option correctly', () => {
		before(async () => {
			fixture = await loadFixture({
				root: './fixtures/core-image-base/',
				image: {
					service: testImageService(),
				},
				base: '/blog',
			});
			await fixture.build();
		});

		it('has base path prefix when using the Image component', async () => {
			const html = await fixture.readFile('/index.html');
			const $ = cheerio.load(html);
			const src = $('#local img').attr('src');
			assert.equal(src.length > 0, true);
			assert.equal(src.startsWith('/blog'), true);
		});

		it('has base path prefix when using getImage', async () => {
			const html = await fixture.readFile('/get-image/index.html');
			const $ = cheerio.load(html);
			const src = $('img').attr('src');
			assert.equal(src.length > 0, true);
			assert.equal(src.startsWith('/blog'), true);
		});

		it('has base path prefix when using image directly', async () => {
			const html = await fixture.readFile('/direct/index.html');
			const $ = cheerio.load(html);
			const src = $('img').attr('src');
			assert.equal(src.length > 0, true);
			assert.equal(src.startsWith('/blog'), true);
		});

		it('has base path prefix in Markdown', async () => {
			const html = await fixture.readFile('/post/index.html');
			const $ = cheerio.load(html);
			const src = $('img').attr('src');
			assert.equal(src.length > 0, true);
			assert.equal(src.startsWith('/blog'), true);
		});

		it('has base path prefix in Content Collection frontmatter', async () => {
			const html = await fixture.readFile('/blog/one/index.html');
			const $ = cheerio.load(html);
			const src = $('img').attr('src');
			assert.equal(src.length > 0, true);
			assert.equal(src.startsWith('/blog'), true);
		});

		it('has base path prefix in SSR', async () => {
			const fixtureWithBase = await loadFixture({
				root: './fixtures/core-image-ssr/',
				output: 'server',
				outDir: './dist/server-base-path',
				adapter: testAdapter(),
				image: {
					endpoint: {
						entrypoint: 'astro/assets/endpoint/node',
					},
					service: testImageService(),
				},
				base: '/blog',
			});
			await fixtureWithBase.build();
			const app = await fixtureWithBase.loadTestAdapterApp();
			const request = new Request('http://example.com/blog/');
			const response = await app.render(request);
			assert.equal(response.status, 200);
			const html = await response.text();
			const $ = cheerio.load(html);
			const src = $('#local img').attr('src');
			assert.equal(src.startsWith('/blog'), true);
			const img = await app.render(new Request(`https://example.com${src}`));
			assert.equal(img.status, 200);
		});

		it('returns 403 when loading a relative pattern iamge', async () => {
			const fixtureWithBase = await loadFixture({
				root: './fixtures/core-image-ssr/',
				output: 'server',
				outDir: './dist/server-base-path',
				adapter: testAdapter(),
			});
			await fixtureWithBase.build();
			const app = await fixtureWithBase.loadTestAdapterApp();
			let request = new Request('http://example.com/');
			let response = await app.render(request);
			// making sure that the app works
			assert.equal(response.status, 200);
			request = new Request(
				'http://example.com/_image/?href=//secure0x.netlify.app/secure0x.svg&f=svg',
			);
			response = await app.render(request);
			assert.equal(response.status, 403);
		});
	});

	describe('build ssg', () => {
		before(async () => {
			fixture = await loadFixture({
				root: './fixtures/core-image-ssg/',
				image: {
					service: testImageService(),
					domains: [
						'astro.build',
						'avatars.githubusercontent.com',
						'kaleidoscopic-biscotti-6fe98c.netlify.app',
					],
				},
			});
			// Remove cache directory
			removeDir(new URL('./fixtures/core-image-ssg/node_modules/.astro', import.meta.url));

			await fixture.build();
		});

		it('writes out images to dist folder', async () => {
			const html = await fixture.readFile('/index.html');
			const $ = cheerio.load(html);
			const src = $('#local img').attr('src');
			assert.equal(src.length > 0, true);
			const data = await fixture.readFile(src, null);
			assert.equal(data instanceof Buffer, true);
		});

		it('writes out allowed remote images', async () => {
			const html = await fixture.readFile('/remote/index.html');
			const $ = cheerio.load(html);
			const src = $('#remote img').attr('src');
			assert.equal(src.length > 0, true);
			const data = await fixture.readFile(src, null);
			assert.equal(data instanceof Buffer, true);
		});

		it('writes out images to dist folder with proper extension if no format was passed', async () => {
			const html = await fixture.readFile('/index.html');
			const $ = cheerio.load(html);
			const src = $('#local img').attr('src');
			assert.equal(src.endsWith('.webp'), true);
		});

		it('getImage() usage also written', async () => {
			const html = await fixture.readFile('/get-image/index.html');
			const $ = cheerio.load(html);
			let $img = $('img');

			// <img> tag
			assert.equal($img.length, 1);
			assert.equal($img.attr('alt'), 'a penguin');

			// image itself
			const src = $img.attr('src');
			const data = await fixture.readFile(src, null);
			assert.equal(data instanceof Buffer, true);
		});

		it('handles remote images with special characters', async () => {
			const html = await fixture.readFile('/special-chars/index.html');
			const $ = cheerio.load(html);
			const $img = $('img');
			assert.equal($img.length, 1);
			const src = $img.attr('src');
			// The filename should be encoded and sanitized
			assert.ok(src.startsWith('/_astro/c_23'));
			const data = await fixture.readFile(src, null);
			assert.ok(data instanceof Buffer);
		});

		it('Picture component images are written', async () => {
			const html = await fixture.readFile('/picturecomponent/index.html');
			const $ = cheerio.load(html);
			let $img = $('img');
			let $source = $('source');

			assert.equal($img.length, 1);
			assert.equal($source.length, 2);

			const srcset = parseSrcset($source.attr('srcset'));
			let hasExistingSrc = await Promise.all(
				srcset.map(async (src) => {
					const data = await fixture.readFile(src.url, null);
					return data instanceof Buffer;
				}),
			);

			assert.deepEqual(
				hasExistingSrc.every((src) => src === true),
				true,
			);
		});

		it('markdown images are written', async () => {
			const html = await fixture.readFile('/post/index.html');
			const $ = cheerio.load(html);
			let $img = $('img');

			// <img> tag
			assert.equal($img.length, 1);
			assert.equal($img.attr('alt'), 'My article cover');

			// image itself
			const src = $img.attr('src');
			const data = await fixture.readFile(src, null);
			assert.equal(data instanceof Buffer, true);
		});

		it('aliased images are written', async () => {
			const html = await fixture.readFile('/alias/index.html');

			const $ = cheerio.load(html);
			let $img = $('img');

			// <img> tag
			assert.equal($img.length, 1);
			assert.equal($img.attr('alt'), 'A penguin!');

			// image itself
			const src = $img.attr('src');
			const data = await fixture.readFile(src, null);
			assert.equal(data instanceof Buffer, true);
		});

		it('aliased images in Markdown are written', async () => {
			const html = await fixture.readFile('/aliasMarkdown/index.html');

			const $ = cheerio.load(html);
			let $img = $('img');

			// <img> tag
			assert.equal($img.length, 1);
			assert.equal($img.attr('alt'), 'A penguin');

			// image itself
			const src = $img.attr('src');
			const data = await fixture.readFile(src, null);
			assert.equal(data instanceof Buffer, true);
		});

		it('output files for content collections images', async () => {
			const html = await fixture.readFile('/blog/one/index.html');

			const $ = cheerio.load(html);
			let $img = $('img');
			assert.equal($img.length, 2);

			const srcdirect = $('#direct-image img').attr('src');
			const datadirect = await fixture.readFile(srcdirect, null);
			assert.equal(datadirect instanceof Buffer, true);

			const srcnested = $('#nested-image img').attr('src');
			const datanested = await fixture.readFile(srcnested, null);
			assert.equal(datanested instanceof Buffer, true);
		});

		it('quality attribute produces a different file', async () => {
			const html = await fixture.readFile('/quality/index.html');
			const $ = cheerio.load(html);
			assert.notEqual($('#no-quality img').attr('src'), $('#quality-low img').attr('src'));
		});

		it('quality can be a number between 0-100', async () => {
			const html = await fixture.readFile('/quality/index.html');
			const $ = cheerio.load(html);
			assert.notEqual($('#no-quality img').attr('src'), $('#quality-num img').attr('src'));
		});

		it('format attribute produces a different file', async () => {
			const html = await fixture.readFile('/format/index.html');
			const $ = cheerio.load(html);
			assert.notEqual($('#no-format img').attr('src'), $('#format-avif img').attr('src'));
		});

		it('has cache entries', async () => {
			const generatedImages = (await fixture.glob('_astro/**/*.webp'))
				.map((path) => basename(path))
				.sort();
			const cachedImages = [...(await fixture.glob('../node_modules/.astro/assets/**/*.webp'))]
				.map((path) => basename(path))
				.sort();

			assert.deepEqual(generatedImages, cachedImages);
		});

		it('uses cache entries', async () => {
			const logs = [];
			const logging = {
				dest: {
					write(chunk) {
						logs.push(chunk);
					},
				},
			};

			await fixture.build({ logging });
			const generatingImageIndex = logs.findIndex((logLine) =>
				logLine.message.includes('generating optimized images'),
			);
			const relevantLogs = logs.slice(generatingImageIndex + 1, -1);
			const isReusingCache = relevantLogs.every((logLine) =>
				logLine.message.includes('(reused cache entry)'),
			);

			assert.equal(isReusingCache, true);
		});

		it('writes remote image cache metadata', async () => {
			const html = await fixture.readFile('/remote/index.html');
			const $ = cheerio.load(html);
			const metaSrc =
				'../node_modules/.astro/assets/' + basename($('#remote img').attr('src')) + '.json';
			const data = await fixture.readFile(metaSrc, null);
			assert.equal(data instanceof Buffer, true);
			const metadata = JSON.parse(data.toString());
			assert.equal(typeof metadata.expires, 'number');
		});

		it('client images are written to build', async () => {
			const html = await fixture.readFile('/client/index.html');
			const $ = cheerio.load(html);
			let $script = $('script');

			// Find image
			const regex = /src:""([^""]*)/;
			const imageSrc = regex.exec($script.html())[1];
			const data = await fixture.readFile(imageSrc, null);
			assert.equal(data instanceof Buffer, true);
		});

		it('client images srcset parsed correctly', async () => {
			const html = await fixture.readFile('/srcset/index.html');
			const $ = cheerio.load(html);
			const srcset = $('#local-2-widths-with-spaces img').attr('srcset');

			// Find image
			const regex = /^(.+?) \d+[wx]$/m;
			const imageSrcset = regex.exec(srcset)[1];
			assert.notEqual(imageSrcset.includes(' '), true);
		});

		it('supports images with encoded characters in url', async () => {
			const html = await fixture.readFile('/index.html');
			const $ = cheerio.load(html);
			const img = $('#encoded-chars img');
			const src = img.attr('src');
			const data = await fixture.readFile(src);
			assert.notEqual(data, undefined);
		});

		describe('custom service in build', () => {
			it('uses configured hashes properties', async () => {
				await fixture.build();
				const html = await fixture.readFile('/imageDeduplication/index.html');

				const $ = cheerio.load(html);

				const allTheSamePath = $('#all-the-same img')
					.map((_, el) => $(el).attr('src'))
					.get();

				assert.equal(
					allTheSamePath.every((path) => path === allTheSamePath[0]),
					true,
				);

				const useCustomHashProperty = $('#use-data img')
					.map((_, el) => $(el).attr('src'))
					.get();
				assert.equal(
					useCustomHashProperty.every((path) => path === useCustomHashProperty[0]),
					false,
				);

				assert.notEqual(useCustomHashProperty[1], useCustomHashProperty[0]);
			});
		});
	});

	describe('dev ssr', () => {
		/** @type {import('./test-utils').DevServer} */
		let devServer;
		before(async () => {
			fixture = await loadFixture({
				root: './fixtures/core-image-ssr/',
				output: 'server',
				outDir: './dist/server-dev',
				adapter: testAdapter(),
				base: 'some-base',
				image: {
					service: testImageService(),
				},
			});
			devServer = await fixture.startDevServer();
		});

		after(async () => {
			await devServer.stop();
		});

		it('serves the image at /_image', async () => {
			const params = new URLSearchParams();
			params.set('href', '/src/assets/penguin1.jpg?origWidth=207&origHeight=243&origFormat=jpg');
			params.set('f', 'webp');
			const response = await fixture.fetch('/some-base/_image?' + String(params));
			assert.equal(response.status, 200);
			assert.equal(response.headers.get('content-type'), 'image/webp');
		});

		it('returns HEAD method ok for /_image', async () => {
			const params = new URLSearchParams();
			params.set('href', '/src/assets/penguin1.jpg?origWidth=207&origHeight=243&origFormat=jpg');
			params.set('f', 'webp');
			const response = await fixture.fetch('/some-base/_image?' + String(params), {
				method: 'HEAD',
			});
			assert.equal(response.status, 200);
			assert.equal(response.body, null);
			assert.equal(response.headers.get('content-type'), 'image/webp');
		});

		it('does not interfere with query params', async () => {
			let res = await fixture.fetch('/api?src=image.png');
			const html = await res.text();
			assert.equal(html, 'An image: ""image.png""');
		});
	});

	describe('prod ssr', () => {
		before(async () => {
			fixture = await loadFixture({
				root: './fixtures/core-image-ssr/',
				output: 'server',
				outDir: './dist/server-prod',
				adapter: testAdapter(),
				image: {
					endpoint: { entrypoint: 'astro/assets/endpoint/node' },
					service: testImageService(),
				},
			});
			await fixture.build();
		});

		it('dynamic route images are built at response time', async () => {
			const app = await fixture.loadTestAdapterApp();
			let request = new Request('http://example.com/');
			let response = await app.render(request);
			assert.equal(response.status, 200);
			const html = await response.text();
			const $ = cheerio.load(html);
			const src = $('#local img').attr('src');
			request = new Request('http://example.com' + src);
			response = await app.render(request);
			assert.equal(response.status, 200);
		});

		it('endpoint handle malformed requests', async () => {
			const badPaths = [
				'../../../../../../../../../../../../etc/hosts%00',
				'../../../../../../../../../../../../etc/hosts',
				'../../boot.ini',
				'/../../../../../../../../%2A',
				'../../../../../../../../../../../../etc/passwd%00',
				'../../../../../../../../../../../../etc/passwd',
				'../../../../../../../../../../../../etc/shadow%00',
				'../../../../../../../../../../../../etc/shadow',
				'/../../../../../../../../../../etc/passwd^^',
				'/../../../../../../../../../../etc/shadow^^',
				'/../../../../../../../../../../etc/passwd',
				'/../../../../../../../../../../etc/shadow',
				'/./././././././././././etc/passwd',
				'/./././././././././././etc/shadow',
				'....................etcpasswd',
				'....................etcshadow',
				'....................etcpasswd',
				'....................etcshadow',
				'/..../..../..../..../..../..../etc/passwd',
				'/..../..../..../..../..../..../etc/shadow',
				'.\\./.\\./.\\./.\\./.\\./.\\./etc/passwd',
				'.\\./.\\./.\\./.\\./.\\./.\\./etc/shadow',
				'....................etcpasswd%00',
				'....................etcshadow%00',
				'....................etcpasswd%00',
				'....................etcshadow%00',
				'%0a/bin/cat%20/etc/passwd',
				'%0a/bin/cat%20/etc/shadow',
				'%00/etc/passwd%00',
				'%00/etc/shadow%00',
				'%00../../../../../../etc/passwd',
				'%00../../../../../../etc/shadow',
				'/../../../../../../../../../../../etc/passwd%00.jpg',
				'/../../../../../../../../../../../etc/passwd%00.html',
				'/..%c0%af../..%c0%af../..%c0%af../..%c0%af../..%c0%af../..%c0%af../etc/passwd',
				'/..%c0%af../..%c0%af../..%c0%af../..%c0%af../..%c0%af../..%c0%af../etc/shadow',
				'/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd,',
				'/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/shadow,',
				'%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%,25%5c..%25%5c..%25%5c..%25%5c..%00',
				'/%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..,%25%5c..%25%5c..%25%5c..%25%5c..%00',
				'%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%,25%5c..%25%5c..%	25%5c..%25%5c..%00',
				'%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%,25%5c..%25%5c..%		25%5c..%25%5c..%255cboot.ini',
				'/%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..%25%5c..,%25%5c..%25%5c..%25%5c..%25%5c..winnt/desktop.ini',
				'\\&apos;/bin/cat%20/etc/passwd\\&apos;',
				'\\&apos;/bin/cat%20/etc/shadow\\&apos;',
				'../../../../../../../../conf/server.xml',
				'/../../../../../../../../bin/id|',
				'C:/inetpub/wwwroot/global.asa',
				'C:inetpubwwwrootglobal.asa',
				'C:/boot.ini',
				'C:\boot.ini',
				'../../../../../../../../../../../../localstart.asp%00',
				'../../../../../../../../../../../../localstart.asp',
				'../../../../../../../../../../../../boot.ini%00',
				'../../../../../../../../../../../../boot.ini',
				'/./././././././././././boot.ini',
				'/../../../../../../../../../../../boot.ini%00',
				'/../../../../../../../../../../../boot.ini',
				'/..../..../..../..../..../..../boot.ini',
				'/.\\./.\\./.\\./.\\./.\\./.\\./boot.ini',
				'....................\boot.ini',
				'....................\boot.ini%00',
				'....................\boot.ini',
				'/../../../../../../../../../../../boot.ini%00.html',
				'/../../../../../../../../../../../boot.ini%00.jpg',
				'/.../.../.../.../.../	',
				'..%c0%af../..%c0%af../..%c0%af../..%c0%af../..%c0%af../..%c0%af../boot.ini',
				'/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/boot.ini',
				'../prerender/index.html',
			];

			const app = await fixture.loadTestAdapterApp();

			for (const path of badPaths) {
				let request = new Request('http://example.com/_image?href=' + path);
				let response = await app.render(request);
				const body = await response.text();

				// Most paths are malformed local paths (500), but some backslash patterns
				// are now correctly detected as remote and get 403
				const { isRemotePath } = await import('@astrojs/internal-helpers/path');
				const isDetectedAsRemote = isRemotePath(path);
				const expectedStatus = isDetectedAsRemote ? 403 : 500;
				const expectedBodyText = isDetectedAsRemote ? 'Forbidden' : 'Internal Server Error';

				assert.equal(
					response.status,
					expectedStatus,
					`Path ""${path}"" should return ${expectedStatus}`,
				);
				assert.equal(
					body.includes(expectedBodyText),
					true,
					`Path ""${path}"" body should include ""${expectedBodyText}""`,
				);
			}

			// Server should still be running
			let request = new Request('http://example.com/');
			let response = await app.render(request);
			assert.equal(response.status, 200);
		});

		it('prerendered routes images are built', async () => {
			const html = await fixture.readFile('/client/prerender/index.html');
			const $ = cheerio.load(html);
			const src = $('img').attr('src');
			const imgData = await fixture.readFile('/client' + src, null);
			assert.equal(imgData instanceof Buffer, true);
		});

		it('can load images from public dir', async () => {
			const app = await fixture.loadTestAdapterApp();
			let request = new Request('http://example.com/_image?href=/penguin3.jpg&f=webp');
			let response = await app.render(request);
			assert.equal(response.status, 200);
			assert.equal(response.headers.get('content-type'), 'image/webp');
		});
	});

	describe('trailing slash on the endpoint', () => {
		/** @type {import('./test-utils').DevServer} */
		let devServer;
",0
"								pattern: '/foo',
								params: [],
								origin: 'external',
							},
							{
								isPrerendered: false,
								entrypoint: '../../../../dist/assets/endpoint/dev.js',
								pattern: '/_image',
								params: [],
								origin: 'internal',
							},
							{
								isPrerendered: false,
								entrypoint: 'astro-default-404.astro',
								pattern: '/404',
								params: [],
								origin: 'internal',
							},
						].sort((a, b) => a.pattern.localeCompare(b.pattern)),
					);

					await fixture.writeFile('/src/pages/bar.astro', '');
					container.viteServer.watcher.emit(
						'add',
						fixture.getPath('/src/pages/bar.astro').replace(/\\/g, '/'),
					);
					await new Promise((r) => setTimeout(r, 100));

					assert.deepEqual(
						routes,
						[
							{
								isPrerendered: false,
								entrypoint: '_server-islands.astro',
								pattern: '/_server-islands/[name]',
								params: ['name'],
								origin: 'internal',
							},
							{
								isPrerendered: false,
								entrypoint: '../../../../dist/actions/runtime/route.js',
								pattern: '/_actions/[...path]',
								params: ['...path'],
								origin: 'internal',
							},
							{
								isPrerendered: true,
								entrypoint: 'src/pages/about.astro',
								pattern: '/about',
								params: [],
								origin: 'project',
							},
							{
								isPrerendered: true,
								entrypoint: 'src/pages/bar.astro',
								pattern: '/bar',
								params: [],
								origin: 'project',
							},
							{
								isPrerendered: true,
								entrypoint: 'src/foo.astro',
								pattern: '/foo',
								params: [],
								origin: 'external',
							},
							{
								isPrerendered: false,
								entrypoint: '../../../../dist/assets/endpoint/dev.js',
								pattern: '/_image',
								params: [],
								origin: 'internal',
							},
							{
								isPrerendered: false,
								entrypoint: 'astro-default-404.astro',
								pattern: '/404',
								params: [],
								origin: 'internal',
							},
						].sort((a, b) => a.pattern.localeCompare(b.pattern)),
					);

					await fixture.writeFile('/src/pages/about.astro', '---\nexport const prerender=false\n');
					container.viteServer.watcher.emit(
						'change',
						fixture.getPath('/src/pages/about.astro').replace(/\\/g, '/'),
					);
					await new Promise((r) => setTimeout(r, 100));

					assert.deepEqual(
						routes,
						[
							{
								isPrerendered: false,
								entrypoint: '_server-islands.astro',
								pattern: '/_server-islands/[name]',
								params: ['name'],
								origin: 'internal',
							},
							{
								isPrerendered: false,
								entrypoint: '../../../../dist/actions/runtime/route.js',
								pattern: '/_actions/[...path]',
								params: ['...path'],
								origin: 'internal',
							},
							{
								isPrerendered: false,
								entrypoint: 'src/pages/about.astro',
								pattern: '/about',
								params: [],
								origin: 'project',
							},
							{
								isPrerendered: true,
								entrypoint: 'src/pages/bar.astro',
								pattern: '/bar',
								params: [],
								origin: 'project',
							},
							{
								isPrerendered: true,
								entrypoint: 'src/foo.astro',
								pattern: '/foo',
								params: [],
								origin: 'external',
							},
							{
								isPrerendered: false,
								entrypoint: '../../../../dist/assets/endpoint/dev.js',
								pattern: '/_image',
								params: [],
								origin: 'internal',
							},
							{
								isPrerendered: false,",0
"		} else {
			// Redirect here because it is safer than a proxy, remote image will be served by remote domain and not own domain
			return Response.redirect(href, 302);
		}
	}

	const proxied = new URL(href, ctx.url.origin);
	// Have we been tricked into thinking this is local?
	if (proxied.origin !== ctx.url.origin) {
		return new Response('Forbidden', { status: 403 });
	}

	return fetch(proxied);
};",0
"	let _options: Options;
	let _config: AstroConfig | undefined = undefined;
	let _routeToHeaders: RouteToHeaders | undefined = undefined;
	return {
		name: '@astrojs/node',
		hooks: {
			'astro:config:setup': async ({ updateConfig, config, logger, command }) => {
				let session = config.session;
				_config = config;
				if (!session?.driver) {
					logger.info('Enabling sessions with filesystem storage');
					session = {
						...session,
						driver: 'fs-lite',
						options: {
							base: fileURLToPath(new URL('sessions', config.cacheDir)),
						},
					};
				}

				updateConfig({
					image: {
						endpoint: {
							route: config.image.endpoint.route ?? '_image',
							entrypoint:
								config.image.endpoint.entrypoint ??
								(command === 'dev' ? 'astro/assets/endpoint/dev' : 'astro/assets/endpoint/node'),
						},
					},
					session,
					vite: {
						ssr: {
							noExternal: ['@astrojs/node'],",0
"	});

	after(async () => {
		await devPreview.stop();
	});

	it('it returns local images', async () => {
		const res = await fixture.fetch('/');
		assert.equal(res.status, 200);
		const html = await res.text();
		const $ = cheerio.load(html);

		const img = $('img[alt=Penguins]').attr('src');
		const size = await inferRemoteSize(`http://localhost:4321${img}`);
		assert.equal(size.format, 'webp');
		assert.equal(size.width, 50);
		assert.equal(size.height, 33);
	});

	it('it returns remote images', async () => {
		const res = await fixture.fetch('/');
		assert.equal(res.status, 200);
		const html = await res.text();
		const $ = cheerio.load(html);
		const img = $('img[alt=Cornwall]').attr('src');
		const size = await inferRemoteSize(`http://localhost:4321${img}`);
		assert.equal(size.format, 'webp');
		assert.equal(size.width, 400);
		assert.equal(size.height, 300);
	});



	it('refuses images from unknown domains', async () => {
		const res = await fixture.fetch('/_image?href=https://example.com/image.jpg&w=100&h=100&f=webp&q=75');
		assert.equal(res.status, 403);
	});

	it(""refuses common URL bypasses"", async () => {

		for (const href of [
			""HTTP://raw.githubusercontent.com/projectdiscovery/nuclei-templates/refs/heads/main/helpers/payloads/retool-xss.svg"",
			""HttpS://raw.githubusercontent.com/projectdiscovery/nuclei-templates/refs/heads/main/helpers/payloads/retool-xss.svg"",
			""//raw.githubusercontent.com/projectdiscovery/nuclei-templates/refs/heads/main/helpers/payloads/retool-xss.svg"",
			""//raw.githubusercontent.com/projectdiscovery/nuclei-templates/refs/heads/main/helpers/payloads/retool-xss.svg?param=https://example.com"",
			""/%2fraw.githubusercontent.com/projectdiscovery/nuclei-templates/refs/heads/main/helpers/payloads/retool-xss.svg"",
			""/%5craw.githubusercontent.com/projectdiscovery/nuclei-templates/refs/heads/main/helpers/payloads/retool-xss.svg"",
			""/\\raw.githubusercontent.com/projectdiscovery/nuclei-templates/refs/heads/main/helpers/payloads/retool-xss.svg"",
			""///raw.githubusercontent.com/projectdiscovery/nuclei-templates/refs/heads/main/helpers/payloads/retool-xss.svg"",
			""http:\\\\raw.githubusercontent.com/projectdiscovery/nuclei-templates/refs/heads/main/helpers/payloads/retool-xss.svg"",
			""\\\\raw.githubusercontent.com/projectdiscovery/nuclei-templates/refs/heads/main/helpers/payloads/retool-xss.svg"",
			""\\raw.githubusercontent.com/projectdiscovery/nuclei-templates/refs/heads/main/helpers/payloads/retool-xss.svg"",
			""    https://raw.githubusercontent.com/projectdiscovery/nuclei-templates/refs/heads/main/helpers/payloads/retool-xss.svg"",
			""\thttps://raw.githubusercontent.com/projectdiscovery/nuclei-templates/refs/heads/main/helpers/payloads/retool-xss.svg"",
			""\nhttps://raw.githubusercontent.com/projectdiscovery/nuclei-templates/refs/heads/main/helpers/payloads/retool-xss.svg"",
			""\rhttps://raw.githubusercontent.com/projectdiscovery/nuclei-templates/refs/heads/main/helpers/payloads/retool-xss.svg"",
		]) {
			const res = await fixture.fetch(
				`/_image?href=${encodeURIComponent(href)}&f=svg`
			);
			assert.equal(res.status, 403, `Failed on href: ${href}`);
		}

	});

});",0
"}

export function isRelativePath(path: string) {
	return startsWithDotDotSlash(path) || startsWithDotSlash(path);
}

export function isAbsolutePath(path: string) {
	// Unix absolute paths start with /
	// Windows absolute paths start with drive letter (C:, D:, etc)
	return startsWithForwardSlash(path) || /^[a-zA-Z]:/.test(path);
}

function isString(path: unknown): path is string {
	return typeof path === 'string' || path instanceof String;
}

const INTERNAL_PREFIXES = new Set(['/_', '/@', '/.', '//']);
const JUST_SLASHES = /^\/{2,}$/;

export function isInternalPath(path: string) {
	return INTERNAL_PREFIXES.has(path.slice(0, 2)) && !JUST_SLASHES.test(path);
}

export function joinPaths(...paths: (string | undefined)[]) {
	return paths
		.filter(isString)
		.map((path, i) => {
			if (i === 0) {
				return removeTrailingForwardSlash(path);
			} else if (i === paths.length - 1) {
				return removeLeadingForwardSlash(path);
			} else {
				return trimSlashes(path);
			}
		})
		.join('/');
}

export function removeFileExtension(path: string) {
	let idx = path.lastIndexOf('.');
	return idx === -1 ? path : path.slice(0, idx);
}

export function removeQueryString(path: string) {
	const index = path.lastIndexOf('?');
	return index > 0 ? path.substring(0, index) : path;
}

/**
 * Checks whether the path is considered a remote path.
 * Remote means untrusted in this context, so anything that isn't a straightforward
 * local path is considered remote.
 * 
 * @param src
 */
export function isRemotePath(src: string) {
	if (!src) return false;

	// Trim leading/trailing whitespace
	const trimmed = src.trim();
	if (!trimmed) return false;

	// Recursively decode URL-encoded characters to catch multi-level obfuscation
	let decoded = trimmed;
	let previousDecoded = '';
	let maxIterations = 10; // Prevent infinite loops on malformed input

	while (decoded !== previousDecoded && maxIterations > 0) {
		previousDecoded = decoded;
		try {
			decoded = decodeURIComponent(decoded);
		} catch {
			// If decoding fails (e.g., invalid %), stop and use what we have
			break;
		}
		maxIterations--;
	}

	// Check for Windows paths first (C:\, D:\, C:file, etc.)
	// This needs to be before the backslash check
	if (/^[a-zA-Z]:/.test(decoded)) {
		// Windows path with drive letter - always local
		return false;
	}

	// Check for Unix absolute path (starts with / but not // or /\)
	// This needs to be before the backslash check
	if (decoded[0] === '/' && decoded[1] !== '/' && decoded[1] !== '\\') {
		return false;
	}

	// Any backslash at the start is probably trouble. Treat as remote.
	if (decoded[0] === '\\') {
		return true;
	}

	// Protocol-relative URLs are remote
	if (decoded.startsWith('//')) {
		return true;
	}

	// Try to parse as URL to check for protocols and credentials
	try {
		// Try with a mock base URL for relative URLs that might have protocols
		const url = new URL(decoded, 'http://n');
		// Check for credentials first - ANY URL with credentials is suspicious
		if (url.username || url.password) {
			return true;
		}

		if(decoded.includes('@') && (!url.pathname.includes('@') && !url.search.includes('@'))) {
			// If the original string had an @ but it wasn't in the pathname or search,
			// it must have been in the authority section (credentials or domain).
			// Since we already checked for credentials, this is something dodgy.
			return true;
		}
		// If the input had its own protocol, it would override the base
		if (url.origin !== 'http://n') {
			// It had its own protocol - check what it is
			const protocol = url.protocol.toLowerCase();

			// Only file: protocol without credentials is considered local
			if (protocol === 'file:') {
				return false;
			}
			// All other protocols are remote (http:, https:, ftp:, ws:, data:, etc.)
			return true;
		}
		// If we can parse it both with and without a base URL, it's probably remote
		if(URL.canParse(decoded)) {
			return true;
		}
		return false;

	} catch(e) {
		return true
	}
}

/**
 * Checks if parentPath is a parent directory of childPath.
 */
export function isParentDirectory(parentPath: string, childPath: string): boolean {
	if (!parentPath || !childPath) {
		return false;
	}

	// Reject any URLs
	if (parentPath.includes('://') || childPath.includes('://')) {
		return false;
	}

	// Reject remote or suspicious paths
	if (isRemotePath(parentPath) || isRemotePath(childPath)) {
		return false;
	}

	// Don't allow any .. in paths - too risky for traversal attacks
	if (parentPath.includes('..') || childPath.includes('..')) {
		return false;
	}

	// Reject null bytes - security risk
	if (parentPath.includes('\0') || childPath.includes('\0')) {
		return false;
	}

	const normalizedParent = appendForwardSlash(slash(parentPath).toLowerCase());
	const normalizedChild = slash(childPath).toLowerCase();

	// Don't allow same path (parent can't be parent of itself)
	if (normalizedParent === normalizedChild || normalizedParent === normalizedChild + '/') {
		return false;
	}

	return normalizedChild.startsWith(normalizedParent);
}

export function slash(path: string) {
	return path.replace(/\\/g, '/');
}
",0
"): boolean {
	if (!URL.canParse(src)) {
		return false;
	}

	const url = new URL(src);

	// Data URLs are always allowed
	if (url.protocol === 'data:') {
		return true;
	}

	// Non-http(s) protocols are never allowed
	if (!['http:', 'https:'].includes(url.protocol)) {
		return false;
	}

	return (
		domains.some((domain) => matchHostname(url, domain)) ||
		remotePatterns.some((remotePattern) => matchPattern(url, remotePattern))
	);
}",0
"import assert from 'node:assert/strict';
import { describe, it } from 'node:test';
import { isParentDirectory, isRemotePath } from '../dist/path.js';

describe('isRemotePath', () => {
	const remotePaths = [
		// Standard remote protocols
		'https://example.com/foo/bar.js',
		'http://example.com/foo/bar.js',
		'//example.com/foo/bar.js',
		'ws://example.com/foo/bar.js',
		'wss://example.com/foo/bar.js',
		'ftp://example.com/foo/bar.js',
		'sftp://example.com/foo/bar.js',
		'mailto:example@example.com',
		'data:someCode',
		'data:image/png;base64,iVBORw0KGgo',
		'data:text/html,<script>alert(1)</script>',

		// Backslash bypass attempts
		'\\\\example.com/foo/bar.js',
		'\\example.com/foo/bar.js',
		'\\\\\\example.com/foo/bar.js',
		'\\\\\\\\example.com/foo/bar.js',
		'\\raw.githubusercontent.com/test.svg',
		'\\\\raw.githubusercontent.com/test.svg',

		// URL-encoded backslash attempts
		'%5C%5Cexample.com/foo/bar.js',
		'%5Cexample.com/foo/bar.js',
		'%5c%5cexample.com/foo/bar.js',
		'%5cexample.com/foo/bar.js',
		'%5C%5C%5Cexample.com/foo/bar.js',
		'%5C%5C%5C%5Cexample.com/foo/bar.js',

		// Mixed encoding
		'%5C\\example.com/foo/bar.js',
		'\\%5Cexample.com/foo/bar.js',
		'%5c\\example.com/test',

		// Mixed forward and backslashes
		'\\//example.com/foo/bar.js',
		'\\//\\example.com/foo/bar.js',
		'/\\example.com/foo/bar.js', // Forward then backslash - suspicious
		'/\\\\example.com/foo/bar.js', // Forward then double backslash - suspicious

		// Protocol with backslashes
		'http:\\\\example.com/foo/bar.js',
		'https:\\\\example.com/foo/bar.js',
		'http:\\example.com/foo/bar.js',
		'https:\\example.com/foo/bar.js',
		'ftp:\\\\example.com/foo/bar.js',
		'ws:\\\\example.com/foo/bar.js',
		'wss:\\\\example.com/test', // WSS with backslashes
		'sftp:\\\\example.com/test', // SFTP with backslashes
		'HTTP:\\\\example.com/test',
		'HtTp:\\\\example.com/test',

		// Unicode escapes
		'\u005C\u005Cexample.com/test',
		'\u005Cexample.com/test',
		'\\u005C\\u005Cexample.com/test',

		// Null byte injection
		'\\example.com%00.jpg',
		'%5Cexample.com%00.jpg',
		'\\example.com\x00.jpg',

		// Whitespace injection
		'\\\texample.com/test',
		'\\ example.com/test',
		'\\%09example.com/test',
		'\\%20example.com/test',

		// Newline/carriage return injection
		'\\\nexample.com/test',
		'\\\rexample.com/test',
		'\\%0Aexample.com/test',
		'\\%0Dexample.com/test',

		// IP addresses
		'http://192.168.1.1/test',
		'//192.168.1.1/test',
		'\\\\192.168.1.1/test',
		'http://[::1]/test',
		'http://[2001:db8::1]/test',
		'//[::1]/test',
		'\\\\[::1]/test',

		// Localhost
		'http://localhost/test',
		'//localhost/test',
		'\\\\localhost/test',
		'http://127.0.0.1/test',
		'\\\\127.0.0.1/test',

		// With ports
		'http://example.com:8080/test',
		'//example.com:8080/test',
		'\\\\example.com:8080/test',
		'http:\\\\example.com:8080/test',

		// With auth - basic credential attacks
		'http://user:pass@example.com/test',
		'//user:pass@example.com/test',
		'\\\\user:pass@example.com/test',

		// Credential injection attempts to look like local paths
		'//admin:admin@/var/www/html', // Protocol-relative with path-like ending
		'\\\\admin:password@C:\\Windows\\System32', // UNC-style with Windows path
		'user:pass@/home/user/file.js', // No protocol but has creds and Unix path
		'admin:admin@C:\\Users\\Public', // No protocol but has creds and Windows path
		'//user@/local/path', // Single user@ with local-looking path
		'\\\\user@C:\\Program Files', // Backslash variant

		// Encoded credentials to bypass detection
		'http://%75ser:%70ass@example.com', // URL-encoded ""user:pass""
		'http://user%3Apass@example.com', // Encoded colon in creds
		'http://user:pass%40example.com', // Encoded @ in password
		'//%75%73%65%72:%70%61%73%73@example.com', // Fully encoded creds
		'\\\\%75ser:%70ass@example.com', // Backslash with encoded creds

		// Double/triple encoding credentials
		'http://%2575ser:%2570ass@example.com', // Double encoded
		'http://%252575ser:%252570ass@example.com', // Triple encoded

		// Credentials with special characters trying to break parsing
		'http://user:p@ss@example.com', // @ in password
		'http://user:pass:extra@example.com', // Multiple colons
		'http://user::@example.com', // Empty password with double colon
		'http://:password@example.com', // Empty username
		'http://@example.com', // Just @ symbol
		'//user:@example.com', // Empty password
		'//:pass@example.com', // Empty username protocol-relative

		// Credentials with path traversal
		'http://user:../../../etc/passwd@example.com', // Path traversal in password
		'http://../../admin:pass@example.com', // Path traversal in username
		'//user:pass@example.com/../../etc/passwd', // Creds with traversal after

		// Credentials with null bytes and special chars
		'http://user%00:pass@example.com', // Null byte in username
		'http://user:pass%00@example.com', // Null byte in password
		'http://user\x00:pass@example.com', // Hex null byte
		'http://user:pass\0@example.com', // Escaped null

		// OAuth/API key patterns that might be confused
		'http://oauth2:CLIENT_SECRET_HERE@example.com',
		'http://api_key:SECRET_KEY_123@example.com',
		'//token:eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9@example.com', // JWT-like

		// Credentials with port confusion
		'http://user:pass@example.com:8080', // Standard with port
		'http://user:8080@example.com', // Port-like password
		'http://admin:3306@localhost', // MySQL port as password
		'//root:22@server.com', // SSH port as password

		// Unicode in credentials
		'http://üser:pāss@example.com', // Unicode username/password
		'http://用户:密码@example.com', // Chinese characters
		'http://админ:пароль@example.com', // Cyrillic
		'http://\u0075ser:\u0070ass@example.com', // Unicode escapes

		// Homograph attacks in credentials
		'http://аdmin:pаssword@example.com', // Cyrillic 'а' looks like Latin 'a'
		'http://adⅿin:password@example.com', // Unicode small m lookalike

		// Large credentials trying to overflow
		'http://' + 'a'.repeat(1000) + ':' + 'b'.repeat(1000) + '@example.com',
		'//' + 'x'.repeat(10000) + '@example.com', // Massive username

		// Mixed slashes with credentials
		'http:\\//user:pass@example.com', // Mixed slashes in protocol
		'http://user:pass@example.com\\path', // Mixed slashes in path
		'\\//user:pass@example.com', // Backslash then protocol-relative

		// Credentials to bypass startsWith checks
		// These try to trick checks like if(path.startsWith('/home')) or if(path.startsWith('src/'))
		'//user:pass@/home/user/file.js', // Looks like /home but has protocol-relative with creds
		'//token@/usr/local/bin', // Looks like /usr but is protocol-relative
		'//api:key@/etc/passwd', // Looks like /etc but has creds
		'//admin@/var/www/html/index.html', // Looks like /var but has creds
		'//root@src/index.js', // Looks like src/ but protocol-relative with creds
		'//user@public/assets/logo.png', // Looks like public/ but has creds
		'//deploy@dist/bundle.js', // Looks like dist/ but has creds
		'//ci:token@node_modules/package', // Looks like node_modules/ but has creds

		// Using credentials patterns that parse as valid URLs
		'user:pass@localhost/admin', // Credentials with localhost
		'admin:admin@127.0.0.1:8080', // Credentials with IP and port
		'root:toor@evil.com/payload', // Clear credential pattern

		// Credentials with localhost/127.0.0.1 to look local
		'//admin:admin@localhost/admin', // Localhost but still remote protocol
		'//root:toor@127.0.0.1/phpmyadmin', // Loopback but still remote
		'//user@localhost:3000/api', // Localhost with port
		'//dev:dev@[::1]/graphql', // IPv6 localhost
		'//test@0.0.0.0/test', // 0.0.0.0 binding address

		// File URLs with @ trying to look like local paths
		'file://user@/etc/hosts', // file:// but with user@
		'file://admin:pass@localhost/C:/Windows/System32', // file:// localhost Windows
		'file://root@127.0.0.1/home/user', // file:// with IP

		// Encoded credentials in paths that might decode to look local
		'//%2F%2Fhome/user', // Encoded // at start: //home/user
		'//%2Fetc%2Fpasswd@evil.com', // Encoded /etc/passwd@evil.com
		'%2F%2Fadmin:admin@/var/log', // Encoded //admin:admin@/var/log
		'//%252Fhome%252Fuser@evil.com', // Double encoded /home/user

		// Vite-like paths with credentials (trying to bypass Vite path detection)
		'//user@/@fs/home/user/project', // Vite /@fs/ with creds before
		'//admin@/@id/virtual:module', // Vite /@id/ with creds
		'//dev@/@vite/client', // Vite client with creds
		'//@react-refresh', // Vite React refresh with just @

		// Query strings and fragments
		'http://example.com/test?param=value',
		'\\\\example.com/test?param=value',
		'http://example.com/test#fragment',
		'\\\\example.com/test#fragment',

		// Edge cases with dots
		'http://example..com/test',
		'\\\\example..com/test',
		'http://.example.com/test',
		'\\\\.example.com/test',

		// Long domains
		'\\\\' + 'a'.repeat(1000) + '.com/test',
		'http://' + 'a'.repeat(1000) + '.com/test',

		// Minimal cases
		'\\', // Single backslash
		'\\\\', // Double backslash
		'//', // Protocol-relative
		'http://',
		'https://',
		'data:',

		// Path traversal
		'http://example.com/./../../test',
		'\\\\example.com/./../../test',
		'http://example.com/%2e%2e/test',
		'\\\\example.com/%2e%2e/test',

		// Windows special paths
		'\\\\?\\C:\\test',
		'\\\\.\\pipe\\test',
		'\\\\LOCALHOST\\share',
		'\\\\127.0.0.1\\share',

		// Punycode and Unicode domains
		'http://xn--e1afmkfd.xn--p1ai/test',
		'\\\\xn--e1afmkfd.xn--p1ai/test',
		'http://例え.jp/test',
		'\\\\例え.jp/test',

		// Case variations
		'HtTp://example.com/test',
		'HTTP://example.com/test',
		'DATA:text/plain,hello', // Uppercase data URL
		'Data:text/plain,test', // Mixed case data URL
		'dAtA:text/plain,test', // Weird case data URL

		// Mixed slashes in protocols
		'http:\\//example.com/test',
		'https:/\\example.com/test',
		'ftp://\\example.com/test',
		'ws:\\//example.com/test',

		// Brackets
		'http://[example.com]/test',
		'\\\\[example.com]/test',
		'http://(example.com)/test',
		'\\\\(example.com)/test',

		// Malformed but has protocol prefix (conservative: treated as remote)
		'http:%2F%2Fexample.com/test', // Encoded slashes after colon

		// JavaScript and other dangerous protocols
		'javascript:alert(1)',
		'JavaScript:alert(1)', // Case variant
		'vbscript:msgbox',
		'data:application/javascript,alert(1)',
		'jar:http://example.com/evil.jar!/',
		'view-source:http://example.com',
		'about:blank',
		'blob:http://example.com/uuid',
		'filesystem:http://example.com/temp/',

		// Browser/app specific protocols
		'chrome://settings',
		'chrome-extension://abc/page.html',
		'moz-extension://abc/page.html',
		'safari-extension://abc/page.html',
		'opera://settings',
		'edge://settings',
		'resource://gre/modules/',

		// Other network protocols
		'git://github.com/user/repo.git',
		'ssh://user@host.com',
		'telnet://host.com',
		'gopher://example.com',
		'redis://localhost:6379',
		'mongodb://localhost:27017',
		'postgresql://localhost:5432',
		'mysql://localhost:3306',
		'ldap://example.com',
		'nntp://news.example.com',

		// Mobile/communication protocols
		'tel:+1234567890',
		'sms:+1234567890',
		'mailto:test@test.com', // Already in list but keeping for completeness

		// Authority confusion with @
		'http://google.com@evil.com',
		'http://user:pass@good.com@evil.com',
		'//google.com@evil.com',
		'\\\\google.com@evil.com',

		// Windows UNC paths that could be URL bypass attempts
		'\\\\example.com\\share\\file.js', // Could be //example.com
		'\\\\evil.com\\payload', // Could be //evil.com
		'\\\\localhost\\share\\file.js', // Even localhost could be suspicious
		'\\\\127.0.0.1\\c$\\windows', // IP-based UNC
		'\\\\LOCALHOST\\pipe\\test', // Uppercase variant
		'\\Program Files\\app', // Single backslash - ambiguous
		'\\Users\\Public\\Documents', // Single backslash - ambiguous
		'\\\\?\\C:\\very\\long\\path', // Windows long path (treating as remote for safety)
		'\\\\.\\COM1', // Device path (treating as remote for safety)
		'\\\\.\\pipe\\pipename', // Named pipe (treating as remote for safety)

		// Encoded @ attempts
		'http://example.com%40evil.com/path',
		'http://example.com%2540evil.com/path', // Double encoded @

		// IP address encoding tricks
		'http://2130706433/', // 127.0.0.1 as decimal
		'http://0x7f.0x0.0x0.0x1/', // 127.0.0.1 as hex
		'http://0177.0.0.1/', // 127.0.0.1 partial octal
		'http://127.1/', // Short form IP
		'http://127.0.1/', // Another short form
		'http://[::ffff:127.0.0.1]/', // IPv4-mapped IPv6

		'http://\0example.com', // Null before domain

		// Multiple slashes and dots
		'http:///example.com', // Triple slash
		'http:////example.com', // Quad slash
		'http://example.com..', // Double dots at end
		'http://example.com./', // Dot slash at end
		'http://example.com./.', // Multiple dots
		'http://.example.com', // Leading dot (handled earlier but different context)


		// Relative URLs that look suspicious
		'http:example.com', // Missing slashes (relative URL in HTTP context)
		'https:example.com', // Missing slashes
		'//http://example.com', // Protocol-relative with protocol
		'////example.com', // Multiple slashes

		// Case sensitivity edge cases for data URLs
		'DATA:,test',
		'dAtA:,test',
		'DaTa:,test',

		'http:/\\example.com', // Mixed slash backslash (this is actually http:/\example.com)

	];

	const localPaths = [
		// Standard Unix/Linux absolute paths
		'/local/path/file.js',
		'/usr/local/bin/node',
		'/home/user/projects/app.js',
		'/var/www/html/index.html',
		'/opt/application/config.json',
		'/tmp/build-output.js',
		'/dev/null',
		'/proc/self/exe',
		'/etc/hosts',

		// macOS specific paths
		'/System/Library/Frameworks',
		'/Applications/App.app/Contents',
		'/Users/username/Documents',
		'/Volumes/External Drive/file.js',
		'/private/tmp/file.js',
		'/Library/Application Support/app',

		// Standard relative paths
		'relative/path/file.js',
		'./relative/path/file.js',
		'../relative/path/file.js',
		'../../parent/parent/file.js',
		'./file.js',
		'../file.js',
		'file.js',
		'index.html',
		'src/components/Button.tsx',
		'node_modules/package/dist/index.js',
		'dist/assets/index-abc123.js',

		// Single dot paths
		'.',
		'./',
		'./.',

		// Double dot paths
		'..',
		'../',
		'../.',

		// Windows absolute paths (various formats)
		'C:\\windows\\path\\file.js',
		'C:/windows/path/file.js', // Forward slashes on Windows
		'D:\\Program Files\\app\\main.exe',
		'E:/Projects/web/index.html',
		'Z:\\network\\share\\file.doc',

		// Windows drive-relative paths (uncommon but valid)
		'C:file.txt', // Relative to current directory on C:
		'D:folder\\file.js',

		// file:// protocol is local (all variations)
		'file://example.com/foo/bar.js',
		'file:', // Just file protocol
		'file://', // File with slashes
		'file:///', // File with triple slash (absolute path)
		'file:////', // File with quad slash
		'file://///server/share', // UNC path via file protocol
		'File://example.com', // Uppercase file
		'FILE://example.com', // All caps file
		'fILe://example.com', // Mixed case file

		// file:// with backslashes is still local
		'file:\\\\example.com/test',

		// file:// URLs with legitimate @ symbols (NOT credentials)
		'file:///home/user/package@1.0.0.tgz', // NPM package file
		'file:///Users/dev/icon@2x.png', // Retina image file
		'file:///C:/Projects/@company/app/index.js', // Scoped package path
		'file:///var/cache/@cache_key.dat', // Cache file with @
		'file://localhost/home/backup@2024.sql', // Backup file
		'file:///opt/app/sprite@mobile.css', // Responsive asset
		'file:///D:/Work/email@example.com.txt', // Email as filename
		'file:///home/user/@types/node/index.d.ts', // TypeScript defs
		'file:///app/test@integration.spec.js', // Test file
		'file:///Users/john/logo@dark@2x.png', // Multiple @ in name

		// Vite-specific paths (all should be local)
		'/@fs/local/path/file.js',
		'/@fs/C:/Users/project/src/main.js',
		'/@fs/Users/mac/project/src/app.vue',
		'/@id/local/path/file.js',
		'/@id/__x00__virtual:file',
		'/@vite/client',
		'/@vite/env',
		'/@react-refresh',
		'/node_modules/.vite/deps/vue.js',
		'/node_modules/.vite/deps/_metadata.json',
		'/__vite_ping',
		'/src/main.ts?t=1234567890',
		'/src/assets/logo.png?import',
		'/src/styles.css?direct',
		'/@modules/my-package',
		'/~partytown/debug/partytown.js',

		// Fragment and query strings without protocols (local)
		'#http://evil.com',
		'#//evil.com',
		'?http://evil.com',
		'?//evil.com',

		// Paths with spaces (valid local paths)
		'/path with spaces/file.js',
		'C:\\Program Files (x86)\\app\\file.exe',
		'./folder with spaces/index.html',
		'/Users/John Doe/Documents/file.txt',
		'My Documents\\Projects\\app.js',

		// Paths with special characters
		'/path/to/file-name_2023.test.js',
		'/path/to/file@2x.png',
		'/path/to/file#1.js',
		// Legitimate @ in filenames (NOT credentials)
		'package@1.0.0.tgz', // NPM package versioning
		'user@2x.png', // Retina image naming
		'icon@3x.png', // iOS asset naming
		'logo@2x@dark.png', // Multiple @ in filename
		'@babel/core/lib/index.js', // Scoped package path
		'/@babel/preset-env', // Scoped package in node_modules
		'node_modules/@types/node/index.d.ts', // TypeScript definitions
		'./@company/shared-ui/Button.tsx', // Monorepo package
		'packages/@my-org/utils/index.js', // Lerna/workspace package
		'email@example.com.txt', // Email as filename
		'backup@2023-12-01.sql', // Backup file naming
		'snapshot@latest.json', // Version/tag in filename
		'test@integration.spec.js', // Test file naming
		'sprite@mobile.css', // Responsive asset naming
		'/var/cache/nginx/@cache_key', // Cache files with @
		'/path/to/[bracketed]/file.js',
		'/path/to/(parentheses)/file.js',
		'/path/to/file$.js',
		'/path/to/file+plus.js',
		'/path/to/file=equals.js',
		'/path/to/file&ampersand.js',
		'/path/to/file,comma.js',
		'/path/to/file;semicolon.js',
		""/path/to/file'quote.js"",
		'/path/to/file`backtick.js',
		'C:\\Users\\user!\\file%.txt',

		// Paths with Unicode characters
		'/用户/文档/文件.js',
		'/путь/к/файлу.js',
		'/مسار/إلى/ملف.js',
		'/パス/ファイル.js',
		'/경로/파일.js',
		'C:\\文档\\项目\\app.js',

		// Query parameters on local paths (common in dev servers)
		'/src/main.js?v=12345',
		'/assets/style.css?inline',
		'/image.png?w=500&h=300',
		'./component.vue?type=template',
		'../styles/theme.scss?module',

		// Hash fragments on local paths
		'/docs/guide.html#introduction',
		'/app.js#section',
		'./page.html#top',
		'index.html#/route/path',

		// Edge case: paths that look like URLs but aren't
		'http', // Just the word http as a filename
		'https', // Just the word https as a filename
		'ftp', // Just the word ftp as a filename
		'ws', // Just the word ws as a filename
		'C:http', // Windows drive with filename http
		'./http', // Relative path to file named http
		'../https', // Parent directory file named https

		// Paths starting with URL-like strings but no protocol separator
		'httpserver/file.js',
		'https_server/file.js',
		'ftpd/config.json',
		'wss_module/index.js',
		'data-processor/file.js',
		'javascript-files/app.js',

		// Build tool specific paths
		'/.next/static/chunks/main.js',
		'/_next/data/buildid/page.json',
		'/.nuxt/dist/client/app.js',
		'/public/build/bundle.js',
		'/static/js/main.chunk.js',
		'/dist/assets/index.js',
		'/_app/immutable/chunks/index.js', // SvelteKit
		'/.svelte-kit/generated/client/app.js',

		// Package manager paths
		'node_modules/react/index.js',
		'.pnpm/react@18.0.0/node_modules/react/index.js',
		'.yarn/cache/package.zip',
		'bower_components/jquery/dist/jquery.js',

		// Paths with multiple dots
		'../../../file.js',
		'./././file.js',
		'.../weird/path.js', // Triple dots (valid but unusual)
		'file...js', // Multiple dots in filename
		'file.test.spec.js', // Multiple extensions

		// Invalid/malformed encodings (should handle gracefully)
		'%%36%38ttp://example.com', // Invalid double %
		'%GGexample.com', // Invalid hex characters
		'%1', // Incomplete encoding
		'%', // Just a percent sign
		'%%%', // Multiple percent signs

		// Empty string
		'',
	];

	it('should correctly identify remote paths', () => {
		remotePaths.forEach((path) => {
			assert.equal(isRemotePath(path), true, `Expected ""${path}"" to be remote`);
		});
	});

	it('should correctly identify local paths', () => {
		localPaths.forEach((path) => {
			assert.equal(isRemotePath(path), false, `Expected ""${path}"" to be local`);
		});
	});
});

describe('isParentDirectory', () => {
	it('should correctly identify parent-child relationships', () => {
		const validCases = [
			// Unix absolute paths
			['/home', '/home/user'],
			['/home', '/home/user/documents'],
			['/home/user', '/home/user/documents/file.txt'],
			['/var', '/var/www/html/index.html'],
			['/usr/local', '/usr/local/bin/node'],
			['/', '/home'],
			['/', '/usr/local/bin'],

			// Unix relative paths
			['src', 'src/components'],
			['src', 'src/components/Button.tsx'],
			['.', './file.js'],
			['.', './src/index.js'],

			// Windows absolute paths
			['C:\\Users', 'C:\\Users\\Admin'],
			['C:\\Users', 'C:\\Users\\Admin\\Documents'],
			['C:\\', 'C:\\Windows\\System32'],
			['D:\\Projects', 'D:\\Projects\\app\\src\\main.js'],
			['C:/', 'C:/Windows/System32'], // Forward slashes on Windows

			// Windows relative paths
			['src', 'src\\components'],
			['.', '.\\file.js'],

			// Mixed slashes (normalized internally)
			['C:/Users', 'C:\\Users\\Admin\\Documents'],
			['/home/user', '/home/user\\documents'],

			// Paths with single dots that resolve correctly
			['/home', '/home/./user'],
			['src', 'src/./components'],

			// Case insensitive for Windows
			['c:\\users', 'C:\\Users\\Admin'],
			['C:\\USERS', 'c:\\users\\admin'],

			// Very long paths (valid parent-child)
			['/' + 'a'.repeat(1000), '/' + 'a'.repeat(1000) + '/b'],
		];

		validCases.forEach(([parent, child]) => {
			assert.equal(
				isParentDirectory(parent, child),
				true,
				`Expected ""${parent}"" to be parent of ""${child}""`,
			);
		});
	});

	it('should correctly reject non-parent relationships', () => {
		const invalidCases = [
			// Different directories
			['/home', '/usr'],
			['/home/user', '/home/otheruser'],
			['src/components', 'src/utils'],
			['C:\\Users', 'C:\\Windows'],

			// Child is not descendant
			['/home/user/documents', '/home/user'], // Parent longer than child
			['src/components/Button', 'src/components'], // Parent longer
			['/home/user', '/home'], // Reversed relationship

			// Different drives on Windows
			['C:\\Users', 'D:\\Users'],
			['C:\\', 'D:\\'],

			// Absolute vs relative
			['/home', 'home'],
			['C:\\Users', 'Users'],
			['home', '/home'],

			// Path traversal attempts
			['/home', '/etc/../home/user'], // Resolves to /home/user but starts elsewhere
			['/restricted', '/restricted/../../../etc/passwd'], // Traversal outside

			// Empty or null paths
			['', '/home'],
			['/home', ''],
			['', ''],
			[null, '/home'],
			['/home', null],
			[undefined, '/home'],

			// Same path (not parent-child)
			['/home/user', '/home/user'],
			['src', 'src'],
			['C:\\Users', 'C:\\Users'],

			// Partial name match but not parent
			['/home', '/homepage'],
			['/home', '/home2'],
			['src', 'src2'],
			['test', 'test-utils'],

			// Special characters and null bytes
			['/home\0', '/home/user'],
			['/home', '/home\0/user'],
			['/home', '/home/\0user'],
		];

		invalidCases.forEach(([parent, child]) => {
			assert.equal(
				isParentDirectory(parent, child),
				false,
				`Expected ""${parent}"" NOT to be parent of ""${child}""`,
			);
		});
	});

	it('should handle adversarial inputs safely', () => {
		const adversarialCases = [
			// Path traversal attacks
			['/safe', '/safe/../../../etc/passwd'],
			['/app', '/app/../../../../root/.ssh'],
			['C:\\Safe', 'C:\\Safe\\..\\..\\..\\Windows\\System32'],

			// URL-like paths
			['http://evil.com', 'http://evil.com/payload'],
			['//evil.com', '//evil.com/hack'],
			['file://host', 'file://host/etc/passwd'],

			// Encoded paths
			['/home', '/%2e%2e/home/user'], // Encoded ..
			['/home', '/home%2Fuser'], // Encoded /

			// Very long paths that don't match
			['/short', '/' + 'a'.repeat(10000)],

			// Symlink-like patterns
			['/real', '/real/../../symlink/target'],
			['/app', '/app/node_modules/.bin/../../../outside'],

			// Credentials in paths
			['/home/safe', 'file:///home/safe/user:@/etc/passwd'],
			['C:\\Safe', 'file:///C:\\Safe\\user:@\\Windows\\System32'],
		];

		adversarialCases.forEach(([parent, child]) => {
			// Should safely return false for all adversarial inputs
			assert.equal(
				isParentDirectory(parent, child),
				false,
				`Expected adversarial input ""${parent}"" vs ""${child}"" to return false safely`,
			);
		});
	});

	it('should handle edge cases correctly', () => {
		// Root paths
		assert.equal(isParentDirectory('/', '/home'), true);
		assert.equal(isParentDirectory('/', '/'), false); // Same path
		assert.equal(isParentDirectory('C:\\', 'C:\\Windows'), true);
		assert.equal(isParentDirectory('C:\\', 'C:\\'), false);

		// Current directory
		assert.equal(isParentDirectory('.', './src'), true);
		assert.equal(isParentDirectory('.', '.'), false);

		// Parent directory references not allowed (.. paths rejected)
		assert.equal(isParentDirectory('..', '../src'), false);
		assert.equal(isParentDirectory('../..', '../../src/main.js'), false);

		// Trailing slashes
		assert.equal(isParentDirectory('/home/', '/home/user'), true);
		assert.equal(isParentDirectory('/home', '/home/user/'), true);
		assert.equal(isParentDirectory('/home/', '/home/user/'), true);

		// Multiple slashes
		assert.equal(isParentDirectory('/home', '/home//user'), true);
		assert.equal(isParentDirectory('/home', '/home///user///docs'), true);
	});
});",0
"		} catch {
			// Invalid URL
			return false;
		}
	}

	/**
	 * Validate a hostname by rejecting any with path separators.
	 * Prevents path injection attacks. Invalid hostnames return undefined.
	 */
	static sanitizeHost(hostname: string | undefined): string | undefined {
		if (!hostname) return undefined;
		// Reject any hostname containing path separators - they're invalid
		if (/[/\\]/.test(hostname)) return undefined;
		return hostname;
	}

	/**
	 * Validate forwarded headers (proto, host, port) against allowedDomains.
	 * Returns validated values or undefined for rejected headers.
	 * Uses strict defaults: http/https only for proto, rejects port if not in allowedDomains.
	 */
	static validateForwardedHeaders(
		forwardedProtocol?: string,
		forwardedHost?: string,
		forwardedPort?: string,
		allowedDomains?: Partial<RemotePattern>[],
	): { protocol?: string; host?: string; port?: string } {
		const result: { protocol?: string; host?: string; port?: string } = {};

		// Validate protocol
		if (forwardedProtocol) {
			if (allowedDomains && allowedDomains.length > 0) {
				const hasProtocolPatterns = allowedDomains.some(
					(pattern) => pattern.protocol !== undefined,
				);
				if (hasProtocolPatterns) {
					// Validate against allowedDomains patterns
					try {
						const testUrl = new URL(`${forwardedProtocol}://example.com`);
						const isAllowed = allowedDomains.some((pattern) => matchPattern(testUrl, pattern));
						if (isAllowed) {
							result.protocol = forwardedProtocol;
						}
					} catch {
						// Invalid protocol, omit from result
					}
				} else if (/^https?$/.test(forwardedProtocol)) {
					// allowedDomains exist but no protocol patterns, allow http/https
					result.protocol = forwardedProtocol;
				}
			} else if (/^https?$/.test(forwardedProtocol)) {
				// No allowedDomains, only allow http/https
				result.protocol = forwardedProtocol;
			}
		}

		// Validate port first
		if (forwardedPort && allowedDomains && allowedDomains.length > 0) {
			const hasPortPatterns = allowedDomains.some((pattern) => pattern.port !== undefined);
			if (hasPortPatterns) {
				// Validate against allowedDomains patterns
				const isAllowed = allowedDomains.some((pattern) => pattern.port === forwardedPort);
				if (isAllowed) {
					result.port = forwardedPort;
				}
			}
			// If no port patterns, reject the header (strict security default)
		}

		// Validate host (extract port from hostname for validation)
		// Reject empty strings and sanitize to prevent path injection
		if (forwardedHost && forwardedHost.length > 0 && allowedDomains && allowedDomains.length > 0) {
			const protoForValidation = result.protocol || 'https';
			const sanitized = App.sanitizeHost(forwardedHost);
			if (sanitized) {
				try {
					// Extract hostname without port for validation
					const hostnameOnly = sanitized.split(':')[0];
					// Use full hostname:port for validation so patterns with ports match correctly
					// Include validated port if available, otherwise use port from forwardedHost if present
					const portFromHost = sanitized.includes(':') ? sanitized.split(':')[1] : undefined;
					const portForValidation = result.port || portFromHost;
					const hostWithPort = portForValidation ? `${hostnameOnly}:${portForValidation}` : hostnameOnly;
					const testUrl = new URL(`${protoForValidation}://${hostWithPort}`);
					const isAllowed = allowedDomains.some((pattern) => matchPattern(testUrl, pattern));
					if (isAllowed) {
						result.host = sanitized;
					}
				} catch {
					// Invalid host, omit from result
				}
			}
		}

		return result;
	}

	/**
	 * Creates a pipeline by reading the stored manifest
	 *
	 * @param streaming
	 * @private
	 */
	#createPipeline(streaming = false) {
		return AppPipeline.create({
			logger: this.#logger,
			manifest: this.#manifest,
			runtimeMode: 'production',
			renderers: this.#manifest.renderers,
			defaultRoutes: createDefaultRoutes(this.#manifest),
			resolve: async (specifier: string) => {
				if (!(specifier in this.#manifest.entryModules)) {
					throw new Error(`Unable to resolve [${specifier}]`);
				}
				const bundlePath = this.#manifest.entryModules[specifier];
				if (bundlePath.startsWith('data:') || bundlePath.length === 0) {
					return bundlePath;
				} else {
					return createAssetLink(bundlePath, this.#manifest.base, this.#manifest.assetsPrefix);
				}
			},
			serverLike: true,
			streaming,
		});
	}

	set setManifestData(newManifestData: RoutesList) {
		this.#manifestData = newManifestData;
	}

	removeBase(pathname: string) {
		if (pathname.startsWith(this.#manifest.base)) {
			return pathname.slice(this.#baseWithoutTrailingSlash.length + 1);
		}
		return pathname;
	}

	/**
	 * It removes the base from the request URL, prepends it with a forward slash and attempts to decoded it.
	 *
	 * If the decoding fails, it logs the error and return the pathname as is.
	 * @param request
	 * @private
	 */
	#getPathnameFromRequest(request: Request): string {
		const url = new URL(request.url);
		const pathname = prependForwardSlash(this.removeBase(url.pathname));
		try {
			return decodeURI(pathname);
		} catch (e: any) {
			this.getAdapterLogger().error(e.toString());
			return pathname;
		}
	}

	/**
	 * Given a `Request`, it returns the `RouteData` that matches its `pathname`. By default, prerendered
	 * routes aren't returned, even if they are matched.
	 *
	 * When `allowPrerenderedRoutes` is `true`, the function returns matched prerendered routes too.
	 * @param request
	 * @param allowPrerenderedRoutes
	 */
	match(request: Request, allowPrerenderedRoutes = false): RouteData | undefined {
		const url = new URL(request.url);
		// ignore requests matching public assets
		if (this.#manifest.assets.has(url.pathname)) return undefined;
		let pathname = this.#computePathnameFromDomain(request);
		if (!pathname) {
			pathname = prependForwardSlash(this.removeBase(url.pathname));
		}
		let routeData = matchRoute(decodeURI(pathname), this.#manifestData);

		if (!routeData) return undefined;
		if (allowPrerenderedRoutes) {
			return routeData;
		}
		// missing routes fall-through, pre rendered are handled by static layer
		else if (routeData.prerender) {
			return undefined;
		}
		return routeData;
	}

	#computePathnameFromDomain(request: Request): string | undefined {
		let pathname: string | undefined = undefined;
		const url = new URL(request.url);

		if (
			this.#manifest.i18n &&
			(this.#manifest.i18n.strategy === 'domains-prefix-always' ||
				this.#manifest.i18n.strategy === 'domains-prefix-other-locales' ||
				this.#manifest.i18n.strategy === 'domains-prefix-always-no-redirect')
		) {
			// Validate forwarded headers
			const validated = App.validateForwardedHeaders(
				request.headers.get('X-Forwarded-Proto') ?? undefined,
				request.headers.get('X-Forwarded-Host') ?? undefined,
				request.headers.get('X-Forwarded-Port') ?? undefined,
				this.#manifest.allowedDomains,
			);

			// Build protocol with fallback
			let protocol = validated.protocol ? validated.protocol + ':' : url.protocol;

			// Build host with fallback
			let host = validated.host ?? request.headers.get('Host');
			// If we don't have a host and a protocol, it's impossible to proceed
			if (host && protocol) {
				// The header might have a port in their name, so we remove it
				host = host.split(':')[0];
				try {
					let locale;",0
"import fs from 'node:fs';
import type { IncomingMessage, ServerResponse } from 'node:http';
import { Http2ServerResponse } from 'node:http2';
import type { Socket } from 'node:net';
import type { RemotePattern } from '../../types/public/config.js';
import type { RouteData } from '../../types/public/internal.js';
import { clientAddressSymbol, nodeRequestAbortControllerCleanupSymbol } from '../constants.js';
import { deserializeManifest } from './common.js';
import { createOutgoingHttpHeaders } from './createOutgoingHttpHeaders.js';
import type { RenderOptions } from './index.js';
import { App } from './index.js';
import type { NodeAppHeadersJson, SerializedSSRManifest, SSRManifest } from './types.js';

export { apply as applyPolyfills } from '../polyfill.js';

/**
 * Allow the request body to be explicitly overridden. For example, this
 * is used by the Express JSON middleware.
 */
interface NodeRequest extends IncomingMessage {
	body?: unknown;
}

export class NodeApp extends App {
	headersMap: NodeAppHeadersJson | undefined = undefined;

	public setHeadersMap(headers: NodeAppHeadersJson) {
		this.headersMap = headers;
	}

	match(req: NodeRequest | Request, allowPrerenderedRoutes = false) {
		if (!(req instanceof Request)) {
			req = NodeApp.createRequest(req, {
				skipBody: true,
				allowedDomains: this.manifest.allowedDomains,
			});
		}
		return super.match(req, allowPrerenderedRoutes);
	}
	render(request: NodeRequest | Request, options?: RenderOptions): Promise<Response>;
	/**
	 * @deprecated Instead of passing `RouteData` and locals individually, pass an object with `routeData` and `locals` properties.
	 * See https://github.com/withastro/astro/pull/9199 for more information.
	 */
	render(request: NodeRequest | Request, routeData?: RouteData, locals?: object): Promise<Response>;
	render(
		req: NodeRequest | Request,
		routeDataOrOptions?: RouteData | RenderOptions,
		maybeLocals?: object,
	) {
		if (!(req instanceof Request)) {
			req = NodeApp.createRequest(req, {
				allowedDomains: this.manifest.allowedDomains,
			});
		}
		// @ts-expect-error The call would have succeeded against the implementation, but implementation signatures of overloads are not externally visible.
		return super.render(req, routeDataOrOptions, maybeLocals);
	}

	/**
	 * Converts a NodeJS IncomingMessage into a web standard Request.
	 * ```js
	 * import { NodeApp } from 'astro/app/node';
	 * import { createServer } from 'node:http';
	 *
	 * const server = createServer(async (req, res) => {
	 *     const request = NodeApp.createRequest(req);
	 *     const response = await app.render(request);
	 *     await NodeApp.writeResponse(response, res);
	 * })
	 * ```
	 */
	static createRequest(
		req: NodeRequest,
		{
			skipBody = false,
			allowedDomains = [],
		}: { skipBody?: boolean; allowedDomains?: Partial<RemotePattern>[] } = {},
	): Request {
		const controller = new AbortController();

		const isEncrypted = 'encrypted' in req.socket && req.socket.encrypted;

		// Parses multiple header and returns first value if available.
		const getFirstForwardedValue = (multiValueHeader?: string | string[]) => {
			return multiValueHeader
				?.toString()
				?.split(',')
				.map((e) => e.trim())?.[0];
		};

		const providedProtocol = isEncrypted ? 'https' : 'http';
		const providedHostname = req.headers.host ?? req.headers[':authority'];

		// Validate forwarded headers
		// NOTE: Header values may have commas/spaces from proxy chains, extract first value
		const validated = App.validateForwardedHeaders(
			getFirstForwardedValue(req.headers['x-forwarded-proto']),
			getFirstForwardedValue(req.headers['x-forwarded-host']),
			getFirstForwardedValue(req.headers['x-forwarded-port']),
			allowedDomains,
		);

		const protocol = validated.protocol ?? providedProtocol;
		// validated.host is already sanitized, only sanitize providedHostname
		const sanitizedProvidedHostname = App.sanitizeHost(
			typeof providedHostname === 'string' ? providedHostname : undefined,
		);
		const hostname = validated.host ?? sanitizedProvidedHostname;
		const port = validated.port;

		let url: URL;
		try {
			const hostnamePort = getHostnamePort(hostname, port);
			url = new URL(`${protocol}://${hostnamePort}${req.url}`);
		} catch {",0
"						host: 'example.com',
						'x-forwarded-host': ':123',
					},
				});
				assert.equal(result.url, 'https://example.com/');
			});

			it('rejects empty x-forwarded-host and falls back to host header', () => {
				const result = NodeApp.createRequest(
					{
						...mockNodeRequest,
						headers: {
							host: 'legitimate.example.com',
							'x-forwarded-host': '',
						},
					},
					{ allowedDomains: [{ hostname: 'example.com' }] },
				);
				assert.equal(result.url, 'https://legitimate.example.com/');
			});

			it('rejects x-forwarded-host with path separator (path injection attempt)', () => {
				const result = NodeApp.createRequest(
					{
						...mockNodeRequest,
						headers: {
							host: 'example.com',
							'x-forwarded-host': 'example.com/admin',
						},
					},
					{ allowedDomains: [{ hostname: 'example.com', protocol: 'https' }] },
				);
				// Path separator in host is rejected, falls back to Host header
				assert.equal(result.url, 'https://example.com/');
			});

			it('rejects x-forwarded-host with multiple path segments', () => {
				const result = NodeApp.createRequest(
					{
						...mockNodeRequest,
						headers: {
							host: 'example.com',
							'x-forwarded-host': 'example.com/admin/users',
						},
					},
					{ allowedDomains: [{ hostname: 'example.com', protocol: 'https' }] },
				);
				// Path separators in host are rejected, falls back to Host header
				assert.equal(result.url, 'https://example.com/');
			});

			it('rejects x-forwarded-host with backslash path separator (path injection attempt)', () => {
				const result = NodeApp.createRequest(
					{
						...mockNodeRequest,
						headers: {
							host: 'example.com',
							'x-forwarded-host': 'example.com\\admin',
						},
					},
					{ allowedDomains: [{ hostname: 'example.com', protocol: 'https' }] },
				);
				// Backslash separator in host is rejected, falls back to Host header
				assert.equal(result.url, 'https://example.com/');
			});

			it('parses x-forwarded-host with embedded port when allowedDomains has port pattern', () => {
				const result = NodeApp.createRequest(
					{
						...mockNodeRequest,
						headers: {
							host: 'example.com',
							'x-forwarded-host': 'example.com:3000',
						},
					},
					{ allowedDomains: [{ hostname: 'example.com', port: '3000' }] },
				);
				// X-Forwarded-Host with port should match pattern that includes port
				assert.equal(result.url, 'https://example.com:3000/');
			});
		});

		it('rejects Host header with path separator (path injection attempt)', () => {
			const result = NodeApp.createRequest({
				...mockNodeRequest,
				headers: {
					host: 'example.com/admin',
				},
			});
			// Host header with path is rejected, resulting in undefined hostname
			assert.equal(result.url, 'https://undefined/');
		});

		it('rejects Host header with backslash path separator (path injection attempt)', () => {
			const result = NodeApp.createRequest({
				...mockNodeRequest,
				headers: {
					host: 'example.com\\admin',
				},
			});
			// Host header with backslash is rejected, resulting in undefined hostname
			assert.equal(result.url, 'https://undefined/');
		});

		describe('x-forwarded-proto', () => {
			it('parses protocol from single-value x-forwarded-proto header', () => {
				const result = NodeApp.createRequest({
					...mockNodeRequest,
					headers: {
						host: 'example.com',
						'x-forwarded-proto': 'http',
						'x-forwarded-port': '80',
					},
				});
				assert.equal(result.url, 'http://example.com/');
			});

			it('parses protocol from multi-value x-forwarded-proto header', () => {
				const result = NodeApp.createRequest({
					...mockNodeRequest,
					headers: {
						host: 'example.com',
						'x-forwarded-proto': 'http,https',
						'x-forwarded-port': '80,443',
					},
				});
				assert.equal(result.url, 'http://example.com/');
			});

			it('fallbacks to encrypted property when no x-forwarded-proto header is present', () => {
				const result = NodeApp.createRequest({
					...mockNodeRequest,
					headers: {
						host: 'example.com',
					},
				});
				assert.equal(result.url, 'https://example.com/');
			});

			it('rejects malicious x-forwarded-proto with URL injection (https://www.malicious-url.com/?tank=)', () => {
				const result = NodeApp.createRequest({
					...mockNodeRequest,
					headers: {
						host: 'example.com',
						'x-forwarded-proto': 'https://www.malicious-url.com/?tank=',
					},
				});
				assert.equal(result.url, 'https://example.com/');
			});

			it('rejects malicious x-forwarded-proto with middleware bypass attempt (x:admin?)', () => {
				const result = NodeApp.createRequest({
					...mockNodeRequest,
					headers: {
						host: 'example.com',
						'x-forwarded-proto': 'x:admin?',
					},
				});
				assert.equal(result.url, 'https://example.com/');
			});

			it('rejects malicious x-forwarded-proto with cache poison attempt (https://localhost/vulnerable?)', () => {
				const result = NodeApp.createRequest({
					...mockNodeRequest,
					headers: {
						host: 'example.com',
						'x-forwarded-proto': 'https://localhost/vulnerable?',
					},
				});
				assert.equal(result.url, 'https://example.com/');
			});

			it('rejects malicious x-forwarded-proto with XSS attempt (javascript:alert(document.cookie)//)', () => {
				const result = NodeApp.createRequest({
					...mockNodeRequest,
					headers: {
						host: 'example.com',
						'x-forwarded-proto': 'javascript:alert(document.cookie)//',
					},
				});
				assert.equal(result.url, 'https://example.com/');
			});

			it('rejects empty x-forwarded-proto and falls back to encrypted property', () => {
				const result = NodeApp.createRequest({
					...mockNodeRequest,
					headers: {
						host: 'example.com',
						'x-forwarded-proto': '',
					},
				});
				assert.equal(result.url, 'https://example.com/');
			});
		});

		describe('x-forwarded-port', () => {
			it('parses port from single-value x-forwarded-port header (with allowedDomains)', () => {
				const result = NodeApp.createRequest(
					{
						...mockNodeRequest,
						headers: {
							host: 'example.com',
							'x-forwarded-port': '8443',
						},
					},
					{ allowedDomains: [{ port: '8443' }] },
				);
				assert.equal(result.url, 'https://example.com:8443/');
			});

			it('parses port from multi-value x-forwarded-port header (with allowedDomains)', () => {
				const result = NodeApp.createRequest(
					{
						...mockNodeRequest,
						headers: {
							host: 'example.com',
							'x-forwarded-port': '8443,3000',
						},
					},
					{ allowedDomains: [{ port: '8443' }] },
				);
				assert.equal(result.url, 'https://example.com:8443/');
			});

			it('rejects x-forwarded-port without allowedDomains patterns (strict security default)', () => {
				const result = NodeApp.createRequest({
					...mockNodeRequest,
					headers: {
						host: 'example.com',
						'x-forwarded-port': '8443',
					},
				});
				assert.equal(result.url, 'https://example.com/');
			});

			it('prefers port from host', () => {
				const result = NodeApp.createRequest({
					...mockNodeRequest,
					headers: {
						host: 'example.com:3000',
						'x-forwarded-port': '443',
					},
				});
				assert.equal(result.url, 'https://example.com:3000/');
			});

			it('uses port embedded in x-forwarded-host', () => {
				const result = NodeApp.createRequest(
					{
						...mockNodeRequest,
						headers: {
							host: 'example.com',
							'x-forwarded-host': 'example.com:3000',
						},
					},
					{ allowedDomains: [{ hostname: 'example.com' }] },
				);
				assert.equal(result.url, 'https://example.com:3000/');
			});",0
"export default defineConfig({
	output: 'server',
	adapter: nodejs({ mode: 'standalone' }),
	security: {
		allowedDomains: [
			{
				hostname: 'abc.xyz',
				port: '444'
			}
		]
	}
});",0
"		const $ = cheerio.load(html);

		// Should use the Host header, not X-Forwarded-Host when allowedDomains is not configured
		assert.equal($('body').text(), 'https://legitimate.example.com/');
	});

	it('rejects port in forwarded host when port not in allowedDomains', async () => {
		const { handler } = await import('./fixtures/url/dist/server/entry.mjs');
		const { req, res, text } = createRequestAndResponse({
			headers: {
				'X-Forwarded-Proto': 'https',
				'X-Forwarded-Host': 'abc.xyz:8080',
				Host: 'localhost:3000',
			},
			url: '/',
		});

		handler(req, res);
		req.send();

		const html = await text();
		const $ = cheerio.load(html);

		// Port 8080 not in allowedDomains (only 444), so should fall back to Host header
		assert.equal($('body').text(), 'https://localhost:3000/');
	});

	it('rejects empty X-Forwarded-Host with allowedDomains configured', async () => {
		const { handler } = await import('./fixtures/url/dist/server/entry.mjs');
		const { req, res, text } = createRequestAndResponse({
			headers: {
				'X-Forwarded-Proto': 'https',
				'X-Forwarded-Host': '',
				Host: 'legitimate.example.com',
			},
			url: '/',
		});

		handler(req, res);
		req.send();

		const html = await text();
		const $ = cheerio.load(html);

		// Empty X-Forwarded-Host should be rejected and fall back to Host header
		assert.equal($('body').text(), 'https://legitimate.example.com/');
	});

	it('rejects X-Forwarded-Host with path injection attempt', async () => {
		const { handler } = await import('./fixtures/url/dist/server/entry.mjs');
		const { req, res, text } = createRequestAndResponse({
			headers: {
				'X-Forwarded-Proto': 'https',
				'X-Forwarded-Host': 'example.com/admin',
				Host: 'localhost:3000',
			},
			url: '/',
		});

		handler(req, res);
		req.send();

		const html = await text();
		const $ = cheerio.load(html);

		// Path injection attempt should be rejected and fall back to Host header
		assert.equal($('body').text(), 'https://localhost:3000/');
	});
});",0
"}

export function trailingSlashMismatchTemplate(
	pathname: string,
	trailingSlash: 'always' | 'never' | 'ignore',
) {
	const corrected = escape(
		trailingSlash === 'always'
			? appendForwardSlash(pathname)
			: removeTrailingForwardSlash(pathname),
	);
	return template({
		pathname,
		statusCode: 404,
		title: 'Not found',
		tabTitle: '404: Not Found',
		body: `<p>Your site is configured with <code>trailingSlash</code> set to <code>${trailingSlash}</code>. Do you want to go to <a href=""${corrected}"">${corrected}</a> instead?</p>",0
"
			for (const path of badPaths) {
				let request = new Request('http://example.com/_image?href=' + path);
				let response = await app.render(request);
				const body = await response.text();

				// Most paths are malformed local paths (500), but some backslash patterns
				// are now correctly detected as remote and get 403
				const { isRemotePath } = await import('@astrojs/internal-helpers/path');
				const isDetectedAsRemote = isRemotePath(path);
				const expectedStatus = isDetectedAsRemote ? 403 : 500;
				const expectedBodyText = isDetectedAsRemote ? 'Forbidden' : 'Internal Server Error';
				
				assert.equal(response.status, expectedStatus, `Path ""${path}"" should return ${expectedStatus}`);
				assert.equal(body.includes(expectedBodyText), true, `Path ""${path}"" body should include ""${expectedBodyText}""`);
			}

			// Server should still be running
			let request = new Request('http://example.com/');
			let response = await app.render(request);
			assert.equal(response.status, 200);",0
" * - `http://`
 * - `https://`
 * - `ftp://`
 * - `ws://`
 * - `//` (protocol-relative URLs)
 * - `data:` (base64 images)
 * - Backslash variants (e.g., `\\example.com`) that could normalize to remote URLs
 * - URL-encoded backslash variants (e.g., `%5C%5Cexample.com`)
 * @param src
 */
export function isRemotePath(src: string) {
	// First decode any URL-encoded backslashes
	const decoded = src.replace(/%5C/gi, '\\');
	
	// Check for any backslash at the start (single or multiple)
	// These can be normalized to protocol-relative URLs
	if (decoded[0] === '\\') {
		return true;
	}
	
	// Check for protocols with backslashes (e.g., http:\\ or https:\\)
	if (/^(?:http|https|ftp|ws):\\/.test(decoded)) {
		return true;
	}
	
	// Check standard URL patterns
	return URL_PROTOCOL_REGEX.test(decoded) || decoded.startsWith('data:');
}

export function slash(path: string) {
	return path.replace(/\\/g, '/');
}
",0
"		assert.equal(
			isRemotePath('wss://example.com/foo/bar.js'),
			false,
			'should not be a remote path',
		);
		assert.equal(isRemotePath('mailto:example@example.com'), false, 'should not be a remote path');
		
		// Backslash bypass attempts - these SHOULD be treated as remote paths
		// to prevent SSRF via URL normalization in downstream code
		assert.equal(isRemotePath('\\\\example.com/foo/bar.js'), true, 'double backslash should be detected as remote');
		assert.equal(isRemotePath('\\example.com/foo/bar.js'), true, 'single backslash should be detected as remote');
		assert.equal(isRemotePath('\\\\\\example.com/foo/bar.js'), true, 'triple backslash should be detected as remote');
		
		// Encoded backslash attempts - these should also be caught
		assert.equal(isRemotePath('%5C%5Cexample.com/foo/bar.js'), true, 'encoded double backslash should be detected as remote');
		assert.equal(isRemotePath('%5Cexample.com/foo/bar.js'), true, 'encoded single backslash should be detected as remote');
		
		// Mixed forward and backslashes
		assert.equal(isRemotePath('\\//example.com/foo/bar.js'), true, 'mixed backslash-forward should be detected as remote');
		assert.equal(isRemotePath('/\\example.com/foo/bar.js'), false, 'forward-backslash in path should not be remote');
		
		// Backslashes with protocols (malformed but could be normalized)
		assert.equal(isRemotePath('http:\\\\example.com/foo/bar.js'), true, 'http with backslashes should be detected as remote');
		assert.equal(isRemotePath('https:\\\\example.com/foo/bar.js'), true, 'https with backslashes should be detected as remote');
		assert.equal(isRemotePath('http:\\example.com/foo/bar.js'), true, 'http with single backslash should be detected as remote');
		
		// Other backslash edge cases
		assert.equal(isRemotePath('\\raw.githubusercontent.com/test.svg'), true, 'backslash with real domain should be detected as remote');
		assert.equal(isRemotePath('\\\\raw.githubusercontent.com/test.svg'), true, 'double backslash with real domain should be detected as remote');
	});
});",0
"                             matches as arguments.
    
      -p<pattern> --default=<pattern>
                             If no positional arguments are provided, glob will use
                             this pattern
    
      --shell                Interpret the command as a shell command by passing it
                             to the shell, with all matched filesystem paths
                             appended,
                             **even if this cannot be done safely**.
    
                             This is **not** unsafe (and usually unnecessary) when
                             using the known Unix shells sh, bash, zsh, and fish, as
                             these can all be executed in such a way as to pass
                             positional arguments safely.
    
                             **Note**: THIS IS UNSAFE IF THE FILE PATHS ARE
                             UNTRUSTED, because a path like \`'some/path/\\\\$\\\\(cmd)'\`
                             will be executed by the shell.
    
                             If you do have positional arguments that you wish to
                             pass to the command ahead of the glob pattern matches,
                             use the \`--cmd-arg\`/\`-g\` option instead.
    
                             The next major release of glob will fully remove the
                             ability to use this option unsafely.
    
      -g<arg> --cmd-arg=<arg>
                             Pass the provided values to the supplied command, ahead
                             of the glob matches.
    
                             For example, the command:
    
                             glob -c echo -g""hello"" -g""world"" *.txt
    
                             might output:
    
                             hello world a.txt b.txt
    
                             This is a safer (and future-proof) alternative than
                             putting positional arguments in the \`-c\`/\`--cmd\`
                             option.
    
                             Can be set multiple times
    
      -A --all               By default, the glob cli command will not expand any
                             arguments that are an exact match to a file on disk.
    
                             This prevents double-expanding, in case the shell
                             expands an argument whose filename is a glob
                             expression.",0
"import { spawn, type SpawnOptions } from 'child_process'
import { readFileSync } from 'fs'
import { sep } from 'path'
import t from 'tap'
import { fileURLToPath } from 'url'
const { version } = JSON.parse(
  readFileSync(
    fileURLToPath(new URL('../package.json', import.meta.url)),
    'utf8',
  ),
)
const bin = fileURLToPath(new URL('../dist/esm/bin.mjs', import.meta.url))

const foregroundChildCalls: [
  string,
  string[],
  undefined | SpawnOptions,
][] = []
let mockForegroundChildAwaiting: undefined | Promise<void> = undefined
let resolveMockForegroundChildAwaiting: undefined | (() => void) =
  undefined
const expectForegroundChild = () =>
  new Promise<void>(res => (resolveMockForegroundChildAwaiting = res))
const mockForegroundChild = {
  foregroundChild: async (
    cmd: string,
    args: string[],
    options?: SpawnOptions,
  ) => {
    resolveMockForegroundChildAwaiting?.()
    resolveMockForegroundChildAwaiting = undefined
    mockForegroundChildAwaiting = undefined
    foregroundChildCalls.push([cmd, args, options])
  },
}
t.beforeEach(() => (foregroundChildCalls.length = 0))

t.cleanSnapshot = s => s.split(version).join('{VERSION}')

interface Result {
  args: string[]
  options: SpawnOptions
  stdout: string
  stderr: string
  code: number | null
  signal: NodeJS.Signals | null
}
const run = async (args: string[], options = {}) => {
  const proc = spawn(
    process.execPath,
    ['--enable-source-maps', bin, ...args],
    options,
  )
  const out: Buffer[] = []
  const err: Buffer[] = []
  proc.stdout.on('data', c => out.push(c))
  proc.stderr.on('data', c => err.push(c))
  return new Promise<Result>(res => {
    proc.on('close', (code, signal) => {
      res({
        args,
        options,
        stdout: Buffer.concat(out).toString(),
        stderr: Buffer.concat(err).toString(),
        code,
        signal,
      })
    })
  })
}

t.test('usage', async t => {
  t.matchSnapshot(await run(['-h']), '-h shows usage')
  const res = await run([])
  t.equal(res.code, 1, 'exit with code 1 when no args')
  t.match(res.stderr, 'No patterns provided')
  t.match(res.stderr, /-h --help +Show this usage information$/m)
  const badp = await run(['--platform=glorb'])
  t.equal(badp.code, 1, 'exit with code 1 on bad platform arg')
  t.match(badp.stderr, 'Invalid value provided for --platform: ""glorb""\n')
})

t.test('version', async t => {
  t.matchSnapshot(await run(['-V']), '-V shows version')
  t.matchSnapshot(await run(['--version']), '--version shows version')
})

// Note: this test works without --shell because we only run it on bash.
// exercises the ""safely add cmd args to shell cmd"" path.
t.test('finds matches for a pattern', async t => {
  const cwd = t.testdir({
    a: {
      'x.y': '',
      'x.a': '',
      b: {
        'z.y': '',
        'z.a': '',
      },
    },
  })
  const res = await run(['**/*.y'], { cwd })
  t.match(res.stdout, `a${sep}x.y\n`)
  t.match(res.stdout, `a${sep}b${sep}z.y\n`)

  const c = `node -p ""process.argv.map(s=>s.toUpperCase())""`
  const cmd = await run(['**/*.y', '-c', c], { cwd })
  t.match(cmd.stdout, `'a${sep.replace(/\\/g, '\\\\')}x.y'`.toUpperCase())
  t.match(
    cmd.stdout,
    `'a${sep.replace(/\\/g, '\\\\')}b${sep.replace(
      /\\/g,
      '\\\\',
    )}z.y'`.toUpperCase(),
  )
})

t.test('append positional args safely to shell in fish', async t => {
  const cwd = t.testdir({
    a: {
      'x.y': '',
      'x.a': '',
      b: {
        'z.y': '',
        'z.a': '',
      },
    },
  })
  const { SHELL } = process.env
  t.teardown(() => (process.env.SHELL = SHELL))
  process.env.SHELL = '/usr/local/bin/fish'
  const p = expectForegroundChild()
  t.chdir(cwd)
  const c = `node -p ""process.argv.map(s=>s.toUpperCase())""`
  t.intercept(process, 'argv', {
    value: [process.argv[0], 'glob', '**/*.y', '-c', c],
  })

  await t.mockImport('../dist/esm/bin.mjs', {
    'foreground-child': mockForegroundChild,
  })
  await p
  t.strictSame(foregroundChildCalls, [
    [
      '/usr/local/bin/fish',
      [
        '-c',
        'node -p ""process.argv.map(s=>s.toUpperCase())"" ""$argv""',
        'a/x.y',
        'a/b/z.y',
      ],
      undefined,
    ],
  ])
})

t.test('UNSAFE positional args with --shell', async t => {
  const cwd = t.testdir({
    a: {
      'x.y': '',
      'x.a': '',
      b: {
        'z.y': '',
        'z.a': '',
      },
    },
  })
  const { SHELL } = process.env
  t.teardown(() => (process.env.SHELL = SHELL))
  process.env.SHELL = '/some/unknown/thing'

  const p = expectForegroundChild()
  t.chdir(cwd)
  const c = `node -p ""process.argv.map(s=>s.toUpperCase())""`
  t.intercept(process, 'argv', {
    value: [process.argv[0], 'glob', '--shell', '**/*.y', '-c', c],
  })
  const warnings: [string, string, string][] = []
  t.intercept(process, 'emitWarning', {
    value: (a: string, b: string, c: string) => warnings.push([a, b, c]),
  })

  await t.mockImport('../dist/esm/bin.mjs', {
    'foreground-child': mockForegroundChild,
  })
  await p
  t.strictSame(foregroundChildCalls, [
    [c, ['a/x.y', 'a/b/z.y'], { shell: true }],
  ])
  t.strictSame(warnings, [
    [
      'The --shell option is unsafe, and will be removed. To pass positional arguments to the subprocess, use -g/--cmd-arg instead.',
      'DeprecationWarning',
      'GLOB_SHELL',
    ],
  ])
})

t.test('safe positional args with --cmd-arg/-g', async t => {
  const cwd = t.testdir({
    a: {
      'x.y': '',
      'x.a': '',
      b: {
        'z.y': '',
        'z.a': '',
      },
    },
  })
  const { SHELL } = process.env
  t.teardown(() => (process.env.SHELL = SHELL))
  process.env.SHELL = '/some/unknown/thing'

  const p = expectForegroundChild()
  t.chdir(cwd)
  const c = 'node'
  t.intercept(process, 'argv', {
    value: [
      process.argv[0],
      'glob',
      '**/*.y',
      '-c',
      c,
      '-g-p',
      '--cmd-arg',
      'process.argv.map(s=>s.toUpperCase())',
    ],
  })
  const warnings: [string, string, string][] = []
  t.intercept(process, 'emitWarning', {
    value: (a: string, b: string, c: string) => warnings.push([a, b, c]),
  })

  await t.mockImport('../dist/esm/bin.mjs', {
    'foreground-child': mockForegroundChild,
  })
  await p
  t.strictSame(foregroundChildCalls, [
    [
      c,
      ['-p', 'process.argv.map(s=>s.toUpperCase())', 'a/x.y', 'a/b/z.y'],
      { shell: false },
    ],
  ])
  t.strictSame(warnings, [])
})

t.test('prioritizes exact match if exists, unless --all', async t => {
  const cwd = t.testdir({
    routes: {
      '[id].tsx': '',
      'i.tsx': '',
      'd.tsx': '',",0
"import gql from 'graphql-tag';
import {
  assertCompositionSuccess,
  composeAsFed2Subgraphs,
} from ""./testHelper"";
import {InterfaceType, ObjectType} from ""@apollo/federation-internals"";

describe('authorization tests', () => {
  describe(""@requires"", () => {
    it('works with explicit auth', () => {
      const subgraph1 = {
        name: 'Subgraph1',
        url: 'https://Subgraph1',
        typeDefs: gql`
          type Query {
            t: T
          }

          type T @key(fields: ""id"") {
            id: ID
            extra: String @external
            requiresExtra: String @requires(fields: ""extra"") @authenticated
          }
        `
      }

      const subgraph2 = {
        name: 'Subgraph2',
        url: 'https://Subgraph2',
        typeDefs: gql`
          type T @key(fields: ""id"") {
            id: ID
            extra: String @authenticated
          }
        `
      }

      const result = composeAsFed2Subgraphs([subgraph1, subgraph2]);
      assertCompositionSuccess(result);
    })

    it('works with auth on the type', () => {
      const subgraph1 = {
        name: 'Subgraph1',
        url: 'https://Subgraph1',
        typeDefs: gql`
          type Query {
            t: T
          }

          type T @key(fields: ""id"") @policy(policies: [[""P1""]]) {
            id: ID
            extra: String @external
            requiresExtra: String @requires(fields: ""extra"")
          }
        `
      }

      const subgraph2 = {
        name: 'Subgraph2',
        url: 'https://Subgraph2',
        typeDefs: gql`
          type T @key(fields: ""id"") {
            id: ID
            extra: String @policy(policies: [[""P1""]])
          }
        `
      }

      const result = composeAsFed2Subgraphs([subgraph1, subgraph2]);
      assertCompositionSuccess(result);
    })

    it('works with valid subset of auth', () => {
      const subgraph1 = {
        name: 'Subgraph1',
        url: 'https://Subgraph1',
        typeDefs: gql`
          type Query {
            t: T
          }

          type T @key(fields: ""id"") {
            id: ID
            extra: String @external
            requiresExtra: String @requires(fields: ""extra"") @requiresScopes(scopes: [[""S2"", ""S1""]])
          }
        `
      }

      const subgraph2 = {
        name: 'Subgraph2',
        url: 'https://Subgraph2',
        typeDefs: gql`
          type T @key(fields: ""id"") {
            id: ID
            extra: String @requiresScopes(scopes: [[""S1"", ""S2""], [""S3""]])
          }
        `
      }

      const result = composeAsFed2Subgraphs([subgraph1, subgraph2]);
      assertCompositionSuccess(result);
    })

    it('works with auth on nested selection', () => {
      const subgraph1 = {
        name: 'Subgraph1',
        url: 'https://Subgraph1',
        typeDefs: gql`
          type Query {
            t: T
          }

          type T @key(fields: ""id"") @authenticated {
            id: ID
            extra: I @external
            requiresExtra: String @requires(fields: ""extra { i ... on I1 { i1 } ... on I2 { i2 } }"")
              @requiresScopes(scopes: [[""S1""][""S2""]]) @policy(policies: [[""P1""]])
          }

          interface I {
            i: String
          }

          type I1 implements I @external {
            i: String
            i1: String
          }

          type I2 implements I @external {
            i: String
            i2: Int
          }
        `
      }

      const subgraph2 = {
        name: 'Subgraph2',
        url: 'https://Subgraph2',
        typeDefs: gql`
          type T @key(fields: ""id"") {
            id: ID
            extra: I @authenticated
          }

          interface I {
            i: String
          }

          type I1 implements I {
            i: String @requiresScopes(scopes: [[""S1""]])
            i1: String @requiresScopes(scopes: [[""S2""]])
          }

          type I2 implements I {
            i: String
            i2: Int @policy(policies: [[""P1""]])
          }
        `
      }

      const result = composeAsFed2Subgraphs([subgraph1, subgraph2]);
      assertCompositionSuccess(result);
    })

    it('does not work when missing auth', () => {
      const subgraph1 = {
        name: 'Subgraph1',
        url: 'https://Subgraph1',
        typeDefs: gql`
          type Query {
            t: T
          }

          type T @key(fields: ""id"") {
            id: ID
            extra: String @external
            requiresExtra: String @requires(fields: ""extra"")
          }
        `
      }

      const subgraph2 = {
        name: 'Subgraph2',
        url: 'https://Subgraph2',
        typeDefs: gql`
          type T @key(fields: ""id"") {
            id: ID
            extra: String @authenticated
          }
        `
      }

      const result = composeAsFed2Subgraphs([subgraph1, subgraph2]);
      expect(result.schema).toBeUndefined();
      expect(result.errors?.length).toBe(1);
      expect(result.errors?.[0].message).toBe(
          '[Subgraph1] Field ""T.requiresExtra"" does not specify necessary @authenticated, @requiresScopes and/or ' +
          '@policy auth requirements to access the transitive field ""T.extra"" data from @requires selection set.'
      );
    })

    it('does not work with invalid subset of auth', () => {
      const subgraph1 = {
        name: 'Subgraph1',
        url: 'https://Subgraph1',
        typeDefs: gql`
          type Query {
            t: T
          }

          type T @key(fields: ""id"") {
            id: ID
            extra: String @external
            requiresExtra: String @requires(fields: ""extra"") @requiresScopes(scopes: [[""S1""]])
          }
        `
      }

      const subgraph2 = {
        name: 'Subgraph2',
        url: 'https://Subgraph2',
        typeDefs: gql`
          type T @key(fields: ""id"") {
            id: ID
            extra: String @requiresScopes(scopes: [[""S1"", ""S2""]])
          }
        `
      }

      const result = composeAsFed2Subgraphs([subgraph1, subgraph2]);
      expect(result.schema).toBeUndefined();
      expect(result.errors?.length).toBe(1);
      expect(result.errors?.[0].message).toBe(
          '[Subgraph1] Field ""T.requiresExtra"" does not specify necessary @authenticated, @requiresScopes and/or @policy ' +
          'auth requirements to access the transitive field ""T.extra"" data from @requires selection set.'
      );
    })

    it('does not work when missing auth on a nested selection', () => {
      const subgraph1 = {
        name: 'Subgraph1',
        url: 'https://Subgraph1',
        typeDefs: gql`
          type Query {
            t: T
          }

          type T @key(fields: ""id"") {
            id: ID
            extra: I @external
            requiresExtra: String @requires(fields: ""extra { i ... on I1 { i1 } ... on I2 { i2 } }"")
          }

          interface I {
            i: String
          }

          type I1 implements I @external {
            i: String
            i1: String
          }

          type I2 implements I @external {
            i: String
            i2: Int
          }
        `
      }

      const subgraph2 = {
        name: 'Subgraph2',
        url: 'https://Subgraph2',
        typeDefs: gql`
          type T @key(fields: ""id"") {
            id: ID
            extra: I
          }

          interface I {
            i: String
          }

          type I1 implements I {
            i: String
            i1: String
          }

          type I2 implements I {
            i: String
            i2: Int @policy(policies: [[""P1""]])
          }
        `
      }

      const result = composeAsFed2Subgraphs([subgraph1, subgraph2]);
      expect(result.schema).toBeUndefined();
      expect(result.errors?.length).toBe(1);
      expect(result.errors?.[0].message).toBe(
          '[Subgraph1] Field ""T.requiresExtra"" does not specify necessary @authenticated, @requiresScopes and/or @policy ' +
          'auth requirements to access the transitive field ""I2.i2"" data from @requires selection set.'
      );
    })

    it('does not work when missing explicit auth on an interface field selection', () => {
      const subgraph1 = {
        name: 'Subgraph1',
        url: 'https://Subgraph1',
        typeDefs: gql`
          type Query {
            t: T
          }

          type T @key(fields: ""id"") {
            id: ID
            extra: I @external
            requiresExtra: String @requires(fields: ""extra { i }"")
          }

          interface I {
            i: String
          }

          type I1 implements I @external {
            i: String
          }
        `
      }

      const subgraph2 = {
        name: 'Subgraph2',
        url: 'https://Subgraph2',
        typeDefs: gql`
          type T @key(fields: ""id"") {
            id: ID
            extra: I
          }

          interface I {
            i: String
          }

          type I1 implements I {
            i: String @requiresScopes(scopes: [[""S1""]])
          }
        `
      }

      const result = composeAsFed2Subgraphs([subgraph1, subgraph2]);
      expect(result.schema).toBeUndefined();
      expect(result.errors?.length).toBe(1);
      expect(result.errors?.[0].message).toBe(
          '[Subgraph1] Field ""T.requiresExtra"" does not specify necessary @authenticated, @requiresScopes and/or @policy ' +
          'auth requirements to access the transitive field ""I1.i"" data from @requires selection set.'
      );
    })

    it('does not work when missing inherited auth on a interface field selection', () => {
      const subgraph1 = {
        name: 'Subgraph1',
        url: 'https://Subgraph1',
        typeDefs: gql`
          type Query {
            t: T
          }

          type T @key(fields: ""id"") {
            id: ID
            extra: I @external
            requiresExtra: String @requires(fields: ""extra { i }"")
          }

          interface I {
            i: String
          }

          type I1 implements I @external {
            i: String
          }
        `
      }

      const subgraph2 = {
        name: 'Subgraph2',
        url: 'https://Subgraph2',
        typeDefs: gql`
          type T @key(fields: ""id"") {
            id: ID
            extra: I
          }

          interface I {
            i: String
          }

          type I1 implements I @authenticated {
            i: String
          }
        `
      }

      const result = composeAsFed2Subgraphs([subgraph1, subgraph2]);
      expect(result.schema).toBeUndefined();
      expect(result.errors?.length).toBe(1);
      expect(result.errors?.[0].message).toBe(
          '[Subgraph1] Field ""T.requiresExtra"" does not specify necessary @authenticated, @requiresScopes and/or @policy ' +
          'auth requirements to access the transitive field ""T.extra"" data from @requires selection set.'
      );
    })

    it('does not work when missing auth on type condition in a field selection', () => {
      const subgraph1 = {
        name: 'Subgraph1',
        url: 'https://Subgraph1',
        typeDefs: gql`
          type Query {
            t: T
          }

          type T @key(fields: ""id"") {
            id: ID
            extra: I @external
            requiresExtra: String @requires(fields: ""extra { ... on I1 { i1 } ... on I2 { i2 }}"")
          }

          interface I {
            i: String
          }

          type I1 implements I @external {
            i: String
            i1: Int
          }
          
          type I2 implements I @external {
            i: String
            i2: String
          }
        `
      }

      const subgraph2 = {
        name: 'Subgraph2',
        url: 'https://Subgraph2',
        typeDefs: gql`
          type T @key(fields: ""id"") {
            id: ID
            extra: I
          }

          interface I {
            i: String
          }

          type I1 implements I @requiresScopes(scopes: [[""S1""]]) {
            i: String 
            i1: Int
          }

          type I2 implements I {
            i: String
            i2: String
          }
        `
      }

      const result = composeAsFed2Subgraphs([subgraph1, subgraph2]);
      expect(result.schema).toBeUndefined();
      expect(result.errors?.length).toBe(1);
      expect(result.errors?.[0].message).toBe(
          '[Subgraph1] Field ""T.requiresExtra"" does not specify necessary @authenticated, @requiresScopes and/or @policy' +
          ' auth requirements to access the transitive field ""T.extra"" data from @requires selection set.'
      );
    })

    it('verifies access control on chain of requires', () => {
      const subgraph1 = {
        name: 'Subgraph1',
        url: 'https://Subgraph1',
        typeDefs: gql`
          type Query {
            t: T
          }

          type T @key(fields: ""id"") {
            id: ID
            extra: String @external
            requiresExtra: String @requires(fields: ""extra"")
          }
        `
      }

      const subgraph2 = {
        name: 'Subgraph2',
        url: 'https://Subgraph2',
        typeDefs: gql`
          type T @key(fields: ""id"") {
            id: ID
            secret: String @external
            extra: String @requires(fields: ""secret"")
          }
        `
      }

      const subgraph3 = {
        name: 'Subgraph3',
        url: 'https://Subgraph3',
        typeDefs: gql`
          type T @key(fields: ""id"") {
            id: ID
            secret: String @authenticated @inaccessible
          }
        `
      }

      const result = composeAsFed2Subgraphs([subgraph1, subgraph2, subgraph3]);
      expect(result.schema).toBeUndefined();
      expect(result.errors?.length).toBe(1);
      expect(result.errors?.[0].message).toBe(
          '[Subgraph2] Field ""T.extra"" does not specify necessary @authenticated, @requiresScopes and/or ' +
          '@policy auth requirements to access the transitive field ""T.secret"" data from @requires selection set.'
      );
    })

    it('works with chain of requires', () => {
      const subgraph1 = {
        name: 'Subgraph1',
        url: 'https://Subgraph1',
        typeDefs: gql`
          type Query {
            t: T
          }

          type T @key(fields: ""id"") {
            id: ID
            extra: String @external
            requiresExtra: String @requires(fields: ""extra"") @authenticated
          }
        `
      }

      const subgraph2 = {
        name: 'Subgraph2',
        url: 'https://Subgraph2',
        typeDefs: gql`
          type T @key(fields: ""id"") {
            id: ID
            secret: String @external
            extra: String @requires(fields: ""secret"") @authenticated
          }
        `
      }

      const subgraph3 = {
        name: 'Subgraph3',
        url: 'https://Subgraph3',
        typeDefs: gql`
          type T @key(fields: ""id"") {
            id: ID
            secret: String @authenticated @inaccessible
          }
        `
      }

      const result = composeAsFed2Subgraphs([subgraph1, subgraph2, subgraph3]);
      assertCompositionSuccess(result);
    })

    it('works with interface objects', () => {
      const subgraph1 = {
        name: 'Subgraph1',
        url: 'https://Subgraph1',
        typeDefs: gql`
          type Query {
            i: I
          }

          type I @interfaceObject @key(fields: ""id"") {
            id: ID!
            extra: String @external
            requiresExtra: String @requires(fields: ""extra"") @authenticated
          }
        `
      }

      const subgraph2 = {
        name: 'Subgraph2',
        url: 'https://Subgraph2',
        typeDefs: gql`
          interface I @key(fields: ""id"") {
            id: ID!
            extra: String
          }

          type T @key(fields: ""id"") {
            id: ID
            extra: String @authenticated
          }
        `
      }

      const result = composeAsFed2Subgraphs([subgraph1, subgraph2]);
      assertCompositionSuccess(result);
      const interfaceI = result.schema.type(""I"") as InterfaceType;
      expect(interfaceI).toBeDefined();
      const requiresExtraField = interfaceI.field('requiresExtra');
      expect(requiresExtraField).toBeDefined();
      expect(requiresExtraField?.appliedDirectivesOf(""authenticated"")).toBeDefined();
    })

    it('works with interface object chains', () => {
      const subgraph1 = {
        name: 'Subgraph1',
        url: 'https://Subgraph1',
        typeDefs: gql`
          type Query {
            i: I
          }

          type I @interfaceObject @key(fields: ""id"") {
            id: ID!
            extra: String @external
            requiresExtra: String @requires(fields: ""extra"") @authenticated
          }
        `
      }

      const subgraph2 = {
        name: 'Subgraph2',
        url: 'https://Subgraph2',
        typeDefs: gql`
          type I @interfaceObject @key(fields: ""id"") {
            id: ID!
            secret: String @external
            extra: String @requires(fields: ""secret"") @authenticated
          }
        `
      }

      const subgraph3 = {
        name: 'Subgraph3',
        url: 'https://Subgraph3',
        typeDefs: gql`
          interface I @key(fields: ""id"") {
            id: ID!
            secret: String
          }

          type T implements I @key(fields: ""id"") {
            id: ID!
            secret: String @authenticated
          }
        `
      }

      const result = composeAsFed2Subgraphs([subgraph1, subgraph2, subgraph3]);
      assertCompositionSuccess(result);
    })

    it('verifies requires on interface objects without auth', () => {
      const subgraph1 = {
        name: 'Subgraph1',
        url: 'https://Subgraph1',
        typeDefs: gql`
          type Query {
            i: I
          }

          type I @interfaceObject @key(fields: ""id"") {
            id: ID!
            extra: String @external
            requiresExtra: String @requires(fields: ""extra"")
          }
        `
      }

      const subgraph2 = {
        name: 'Subgraph2',
        url: 'https://Subgraph2',
        typeDefs: gql`
          interface I @key(fields: ""id"") {
            id: ID!
            extra: String
          }
          
          type T implements I @key(fields: ""id"") {
            id: ID!
            extra: String @authenticated
          }
        `
      }

      const result = composeAsFed2Subgraphs([subgraph1, subgraph2]);
      console.log(result.supergraphSdl);
      expect(result.schema).toBeUndefined();
      expect(result.errors?.length).toBe(1);
      expect(result.errors?.[0].message).toBe(
          '[Subgraph1] Field ""I.requiresExtra"" does not specify necessary @authenticated, @requiresScopes and/or @policy' +
          ' auth requirements to access the transitive field ""T.extra"" data from @requires selection set.'
      );
    })
  });

  describe(""@context"", () => {
    it('works with explicit auth', () => {
      const subgraph1 = {
        name: 'Subgraph1',
        url: 'https://Subgraph1',
        typeDefs: gql`
          type Query {
            t: T!
          }

          type T @key(fields: ""id"") @context(name: ""context"") {
            id: ID!
            u: U!
            prop: String! @authenticated
          }

          type U @key(fields: ""id"") {
            id: ID!
            field(a: String @fromContext(field: ""$context { prop }"")): Int! @authenticated
          }
        `
      }

      const subgraph2 = {
        name: 'Subgraph2',
        url: 'https://Subgraph2',
        typeDefs: gql`
          type Query {
            a: Int!
          }

          type U @key(fields: ""id"") {
            id: ID!
          }
        `
      }

      const result = composeAsFed2Subgraphs([subgraph1, subgraph2]);
      assertCompositionSuccess(result);
    })

    it('works with explicit auth and multiple contexts', () => {
      const subgraph1 = {
        name: ""Subgraph1"",
        utl: ""https://Subgraph1"",
        typeDefs: gql`
          type Query {
            foo: Foo!
            bar: Bar!
          }

          type Foo @key(fields: ""id"") @context(name: ""context"") {
            id: ID!
            u: U!
            prop: String! @requiresScopes(scopes: [[""S1""]])
          }

          type Bar @key(fields: ""id"") @context(name: ""context"") {
            id: ID!
            u: U!
            prop: String! @requiresScopes(scopes: [[""S2""]])
          }

          type U @key(fields: ""id"") {
            id: ID!
            field(a: String @fromContext(field: ""$context { prop }"")): Int! @requiresScopes(scopes: [[""S1""], [""S2""]])
          }
        `,
      };

      const subgraph2 = {
        name: ""Subgraph2"",
        utl: ""https://Subgraph2"",
        typeDefs: gql`
          type Query {
            a: Int!
          }

          type U @key(fields: ""id"") {
            id: ID!
          }
        `,
      };

      const result = composeAsFed2Subgraphs([subgraph1, subgraph2]);
      assertCompositionSuccess(result);
    })

    it('works with explicit auth and multiple contexts using type conditions', () => {
      const subgraph1 = {
        name: ""Subgraph1"",
        utl: ""https://Subgraph1"",
        typeDefs: gql`
          type Query {
            foo: Foo!
            bar: Bar!
          }

          type Foo @key(fields: ""id"") @context(name: ""context"") {
            id: ID!
            u: U!
            prop: String! @requiresScopes(scopes: [[""S1""]])
          }

          type Bar @key(fields: ""id"") @context(name: ""context"") {
            id: ID!
            u: U!
            prop2: String! @policy(policies: [[""P1""]])
          }

          type U @key(fields: ""id"") {
            id: ID!
            field(
              a: String
              @fromContext(
                field: ""$context ... on Foo { prop } ... on Bar { prop2 }""
              )
            ): Int! @requiresScopes(scopes: [[""S1""]]) @policy(policies: [[""P1""]])
          }
        `,
      };

      const subgraph2 = {
        name: ""Subgraph2"",
        utl: ""https://Subgraph2"",
        typeDefs: gql`
          type Query {
            a: Int!
          }

          type U @key(fields: ""id"") {
            id: ID!
          }
        `,
      };

      const result = composeAsFed2Subgraphs([subgraph1, subgraph2]);
      assertCompositionSuccess(result);
    })

    it('does not work with missing auth', () => {
      const subgraph1 = {
        name: 'Subgraph1',
        url: 'https://Subgraph1',
        typeDefs: gql`
          type Query {
            t: T!
          }

          type T @key(fields: ""id"") @context(name: ""context"") {
            id: ID!
            u: U!
            prop: String! @authenticated
          }

          type U @key(fields: ""id"") {
            id: ID!
            field(a: String @fromContext(field: ""$context { prop }"")): Int!
          }
        `
      }

      const subgraph2 = {
        name: 'Subgraph2',
        url: 'https://Subgraph2',
        typeDefs: gql`
          type Query {
            a: Int!
          }

          type U @key(fields: ""id"") {
            id: ID!
          }
        `
      }

      const result = composeAsFed2Subgraphs([subgraph1, subgraph2]);
      expect(result.schema).toBeUndefined();
      expect(result.errors?.length).toBe(1);
      expect(result.errors?.[0].message).toBe(
          '[Subgraph1] Field ""U.field"" does not specify necessary @authenticated, @requiresScopes and/or @policy ' +
          'auth requirements to access the transitive field ""T.prop"" data from @fromContext selection set.'
      );
    })

    it('does not work with missing auth on one of the contexts', () => {
      const subgraph1 = {
        name: ""Subgraph1"",
        utl: ""https://Subgraph1"",
        typeDefs: gql`
          type Query {
            foo: Foo!
            bar: Bar!
          }

          type Foo @key(fields: ""id"") @context(name: ""context"") @authenticated {
            id: ID!
            u: U!
            prop: String!
          }

          type Bar @key(fields: ""id"") @context(name: ""context"") {
            id: ID!
            u: U!
            prop: String!
          }

          type U @key(fields: ""id"") {
            id: ID!
            field(a: String @fromContext(field: ""$context { prop }"")): Int!
          }
        `,
      };

      const subgraph2 = {
        name: ""Subgraph2"",
        utl: ""https://Subgraph2"",
        typeDefs: gql`
          type Query {
            a: Int!
          }

          type U @key(fields: ""id"") {
            id: ID!
          }
        `,
      };

      const result = composeAsFed2Subgraphs([subgraph1, subgraph2]);
      expect(result.schema).toBeUndefined();
      expect(result.errors?.length).toBe(1);
      expect(result.errors?.[0].message).toBe(
          '[Subgraph1] Field ""U.field"" does not specify necessary @authenticated, @requiresScopes and/or @policy auth ' +
          'requirements to access the transitive data in context Subgraph1__context from @fromContext selection set.'
      );
    })
  });

  describe(""interfaces"", () => {
    it('propagates @authenticated from type', () => {
      const subgraph1 = {
        name: 'Subgraph1',
        url: 'https://Subgraph1',
        typeDefs: gql`
          type Query {
            i: I!
          }

          interface I {
            id: ID
          }

          type T implements I @key(fields: ""id"") @authenticated {
            id: ID
            value1: String
          }

          type U implements I @key(fields: ""id"") {
            id: ID
            value2: String
          }
        `
      }

      const subgraph2 = {
        name: 'Subgraph2',
        url: 'https://Subgraph2',
        typeDefs: gql`
          type Query {
            t: T
          }

          type T @key(fields: ""id"") {
            id: ID!
            other: Int
          }
        `
      }

      const result = composeAsFed2Subgraphs([subgraph1, subgraph2]);
      assertCompositionSuccess(result);
      expect(
          result.schema.type('I')?.appliedDirectivesOf(""authenticated"")?.[0]
      ).toBeDefined();
    })

    it('propagates @requiresScopes from type', () => {
      const subgraph1 = {
        name: 'Subgraph1',
        url: 'https://Subgraph1',
        typeDefs: gql`
          type Query {
            i: I!
          }

          interface I {
            id: ID
          }

          type T implements I @key(fields: ""id"") @requiresScopes(scopes: [[""S1""], [""S2""]]) {
            id: ID
            vT: String
          }

          type U implements I @key(fields: ""id"") @requiresScopes(scopes: [[""S1""], [""S2"", ""S3""]]) {
            id: ID
            vU: String
          }

          type V implements I @key(fields: ""id"") {
            id: ID
            vV: String
          }
        `
      }

      const subgraph2 = {
        name: 'Subgraph2',
        url: 'https://Subgraph2',
        typeDefs: gql`
          type Query {
            t: T
          }

          type T @key(fields: ""id"") {
            id: ID!
            other: Int
          }
        `
      }

      const result = composeAsFed2Subgraphs([subgraph1, subgraph2]);
      assertCompositionSuccess(result);
      expect(
          result.schema.type('I')
              ?.appliedDirectivesOf(""requiresScopes"")
              ?.[0]?.arguments()?.[""scopes""]).toStrictEqual(
          [
            ['S1'],
            ['S2', 'S3'],
          ]
      );
    })

    it('propagates @policy from type', () => {
      const subgraph1 = {
        name: 'Subgraph1',
        url: 'https://Subgraph1',
        typeDefs: gql`
          type Query {
            i: I!
          }

          interface I {
            id: ID
          }

          type T implements I @key(fields: ""id"") @policy(policies: [[""P1""]]) {
            id: ID
            vT: String
          }

          type U implements I @key(fields: ""id"") @policy(policies: [[""P2""]]) {
            id: ID
            vU: String
          }

          type V implements I @key(fields: ""id"") {
            id: ID
            vV: String
          }
        `
      }

      const subgraph2 = {
        name: 'Subgraph2',
        url: 'https://Subgraph2',
        typeDefs: gql`
          type Query {
            t: T
          }

          type T @key(fields: ""id"") {
            id: ID!
            other: Int
          }
        `
      }

      const result = composeAsFed2Subgraphs([subgraph1, subgraph2]);
      assertCompositionSuccess(result);
      expect(
          result.schema.type('I')
              ?.appliedDirectivesOf(""policy"")
              ?.[0]?.arguments()?.[""policies""]).toStrictEqual(
          [
            ['P1', 'P2'],
          ]
      );
    })

    it('propagates @authenticated from fields', () => {
      const subgraph1 = {
        name: 'Subgraph1',
        url: 'https://Subgraph1',
        typeDefs: gql`
          type Query {
            i: I!
          }

          interface I {
            id: ID
            i1: Int
            i2: String
            i3: String
          }

          type T1 implements I @key(fields: ""id"") {
            id: ID
            i1: Int
            i2: String @shareable
            i3: String
            value1: String
          }

          type T2 implements I @key(fields: ""id"") {
            id: ID
            i1: Int @authenticated
            i2: String
            i3: String
            value2: String
          }
        `
      }

      const subgraph2 = {
        name: 'Subgraph2',
        url: 'https://Subgraph2',
        typeDefs: gql`
          type Query {
            t: T1
          }

          type T1 @key(fields: ""id"") {
            id: ID!
            i2: String @shareable @authenticated
            other: Int
          }
        `
      }

      const result = composeAsFed2Subgraphs([subgraph1, subgraph2]);
      assertCompositionSuccess(result);
      const i = result.schema.type('I');
      expect(i).toBeDefined();
      expect(i).toBeInstanceOf(InterfaceType);
      const field1 = (i as InterfaceType).field(""i1"");
      const field2 = (i as InterfaceType).field(""i2"");
      expect(field1?.appliedDirectivesOf(""authenticated"")?.[0]).toBeDefined();
      expect(field2?.appliedDirectivesOf(""authenticated"")?.[0]).toBeDefined();
    })

    it('propagates @requiresScopes from field', () => {
      const subgraph1 = {
        name: 'Subgraph1',
        url: 'https://Subgraph1',
        typeDefs: gql`
          type Query {
            i: I!
          }

          interface I {
            id: ID
            i1: Int
            i2: String
            i3: String
          }

          type T1 implements I @key(fields: ""id"") {
            id: ID
            i1: Int @requiresScopes(scopes: [[""S1""]])
            i2: String @shareable
            i3: String
            value1: String
          }

          type T2 implements I @key(fields: ""id"") {
            id: ID
            i1: Int @requiresScopes(scopes: [[""S1"", ""S2""]])
            i2: String
            i3: String
            value2: String
          }

          type T3 implements I @key(fields: ""id"") {
            id: ID
            i1: Int
            i2: String
            i3: String
            value2: String
          }
        `
      }

      const subgraph2 = {
        name: 'Subgraph2',
        url: 'https://Subgraph2',
        typeDefs: gql`
          type Query {
            t: T1
          }

          type T1 @key(fields: ""id"") {
            id: ID!
            i2: String @shareable @requiresScopes(scopes: [[""S3""]])
            other: Int
          }
        `
      }

      const result = composeAsFed2Subgraphs([subgraph1, subgraph2]);
      assertCompositionSuccess(result);
      const i = result.schema.type('I');
      expect(i).toBeDefined();
      expect(i).toBeInstanceOf(InterfaceType);
      const field1 = (i as InterfaceType).field(""i1"");
      expect(field1?.appliedDirectivesOf(""requiresScopes"")
          ?.[0]?.arguments()?.[""scopes""]).toStrictEqual(
          [
            ['S1', 'S2'],
          ]
      );
      const field2 = (i as InterfaceType).field(""i2"");
      expect(field2?.appliedDirectivesOf(""requiresScopes"")
          ?.[0]?.arguments()?.[""scopes""]).toStrictEqual(
          [
            ['S3'],
          ]
      );
    })

    it('propagates @policy on field', () => {
      const subgraph1 = {
        name: 'Subgraph1',
        url: 'https://Subgraph1',
        typeDefs: gql`
          type Query {
            i: I!
          }

          interface I {
            id: ID
            i1: Int
            i2: String
            i3: String
          }

          type T1 implements I @key(fields: ""id"") {
            id: ID
            i1: Int @policy(policies: [[""P1""], [""P2""]])
            i2: String @shareable
            i3: String
            value1: String
          }

          type T2 implements I @key(fields: ""id"") {
            id: ID
            i1: Int @policy(policies: [[""P1""], [""P2"", ""P3""]])
            i2: String
            i3: String
            value2: String
          }

          type T3 implements I @key(fields: ""id"") {
            id: ID
            i1: Int
            i2: String
            i3: String
            value2: String
          }
        `
      }

      const subgraph2 = {
        name: 'Subgraph2',
        url: 'https://Subgraph2',
        typeDefs: gql`
          type Query {
            t: T1
          }

          type T1 @key(fields: ""id"") {
            id: ID!
            i2: String @shareable @policy(policies: [[""P4""]])
            other: Int
          }
        `
      }

      const result = composeAsFed2Subgraphs([subgraph1, subgraph2]);
      assertCompositionSuccess(result);
      const i = result.schema.type('I');
      expect(i).toBeDefined();
      expect(i).toBeInstanceOf(InterfaceType);
      const field1 = (i as InterfaceType).field(""i1"");
      expect(field1?.appliedDirectivesOf(""policy"")
          ?.[0]?.arguments()?.[""policies""]).toStrictEqual(
          [
            ['P1'],
            ['P2', 'P3'],
          ]
      );
      const field2 = (i as InterfaceType).field(""i2"");
      expect(field2?.appliedDirectivesOf(""policy"")
          ?.[0]?.arguments()?.[""policies""]).toStrictEqual(
          [
            ['P4'],
          ]
      );
    })

    it('works with interface objects', () => {
      const subgraph1 = {
        name: 'Subgraph1',
        url: 'https://Subgraph1',
        typeDefs: gql`
          type Query {
            i: I
          }

          type I @interfaceObject @key(fields: ""id"") {
            id: ID!
            secret: String @requiresScopes(scopes: [[""S1""]])
          }
        `
      }

      const subgraph2 = {
        name: 'Subgraph2',
        url: 'https://Subgraph2',
        typeDefs: gql`
          interface I @key(fields: ""id"") {
            id: ID!
            extra: String
          }

          type T implements I @key(fields: ""id"") {
            id: ID!
            extra: String @authenticated
          }
          
          type U implements I @key(fields: ""id"") {
            id: ID!
            extra: String
          }
        `
      }

      const result = composeAsFed2Subgraphs([subgraph1, subgraph2]);
      assertCompositionSuccess(result);
    })

    it('works with shareable interface object fields', () => {
      const subgraph1 = {
        name: 'Subgraph1',
        url: 'https://Subgraph1',
        typeDefs: gql`
          type Query {
            i: I
          }

          type I @interfaceObject @key(fields: ""id"") {
            id: ID!
            secret: String @requiresScopes(scopes: [[""S1""]]) @shareable
          }
        `
      }

      const subgraph2 = {
        name: 'Subgraph2',
        url: 'https://Subgraph2',
        typeDefs: gql`
          interface I @key(fields: ""id"") {
            id: ID!
            extra: String
          }

          type T implements I @key(fields: ""id"") {
            id: ID!
            extra: String @authenticated
          }

          type U implements I @key(fields: ""id"") {
            id: ID!
            extra: String
          }
        `
      }

      const subgraph3 = {
        name: 'Subgraph3',
        url: 'https://Subgraph3',
        typeDefs: gql`
          type T @key(fields: ""id"") {
            id: ID!
            secret: String @requiresScopes(scopes: [[""S2""]]) @shareable
          }
        `
      }

      const result = composeAsFed2Subgraphs([subgraph1, subgraph2, subgraph3]);
      assertCompositionSuccess(result);
      // interface I {
      //   id: ID!
      //   secret: String @requiresScopes(scopes: [[""S1"", ""S2""]])
      //   extra: String @authenticated
      // }
      const i = result.schema.type(""I"");
      expect(i).toBeDefined();
      expect(i).toBeInstanceOf(InterfaceType);
      const secretI = (i as InterfaceType).field(""secret"");
      expect(secretI?.appliedDirectivesOf(""requiresScopes"")
          ?.[0]?.arguments()?.[""scopes""]).toStrictEqual(
          [
            ['S1', 'S2'],
          ]
      );
      const extraI = (i as InterfaceType).field(""extra"");
      expect(extraI?.appliedDirectivesOf(""authenticated"")
          ?.[0]
      ).toBeDefined();

      // type T implements I {
      //   id: ID!
      //   extra: String @authenticated
      //   secret: String @requiresScopes(scopes: [[""S1"", ""S2""]])
      // }
      const t = result.schema.type(""T"");
      expect(t).toBeDefined();
      expect(t).toBeInstanceOf(ObjectType);
      const secretT = (t as ObjectType).field(""secret"");
      expect(secretT?.appliedDirectivesOf(""requiresScopes"")
          ?.[0]?.arguments()?.[""scopes""]).toStrictEqual(
          [
            ['S1', 'S2'],
          ]
      );
      const extraT = (t as ObjectType).field(""extra"");
      expect(extraT?.appliedDirectivesOf(""authenticated"")
          ?.[0]
      ).toBeDefined();

      // type U implements I {
      //   id: ID!
      //   extra: String
      //   secret: String @requiresScopes(scopes: [[""S1"", ""S2""]])
      // }
      const u = result.schema.type(""U"");
      expect(u).toBeDefined();
      expect(u).toBeInstanceOf(ObjectType);
      const secretU = (u as ObjectType).field(""secret"");
      expect(secretU?.appliedDirectivesOf(""requiresScopes"")
          ?.[0]?.arguments()?.[""scopes""]).toStrictEqual(
          [
            ['S1', 'S2'],
          ]
      );
      const extraU = (u as ObjectType).field(""extra"");
      expect(extraU?.appliedDirectivesOf(""authenticated"")
          ?.[0]
      ).toBeUndefined();
    })
  });
});",0
"      }
    `;

      expect(buildForErrors(doc, { includeAllImports: true })).toStrictEqual([
        [
          'AUTHENTICATION_APPLIED_ON_INTERFACE',
          `[S] Invalid use of ${directiveName} on field ""I.x"": ${directiveName} cannot be applied on interfaces, interface fields and interface objects`,
        ],
        [
          'AUTHENTICATION_APPLIED_ON_INTERFACE',
          `[S] Invalid use of ${directiveName} on interface ""I"": ${directiveName} cannot be applied on interfaces, interface fields and interface objects`,
        ],
        [
          'AUTHENTICATION_APPLIED_ON_INTERFACE',
          `[S] Invalid use of ${directiveName} on interface object ""O"": ${directiveName} cannot be applied on interfaces, interface fields and interface objects`,
        ],
      ]);
    },
  );
});",0
"  'The maximum number of validation subgraph paths has been exceeded.',
  { addedIn: '2.8.0' },
);

const AUTHENTICATION_APPLIED_ON_INTERFACE = makeCodeDefinition(
    'AUTHENTICATION_APPLIED_ON_INTERFACE',
    'The @authenticated, @requiresScopes and @policy directive cannot be applied on interface, interface fields and interface object',
    { addedIn: '2.9.4' },
);

const MISSING_TRANSITIVE_AUTH_REQUIREMENTS = makeCodeDefinition(
    'MISSING_TRANSITIVE_AUTH_REQUIREMENTS',
    'Field missing transitive @authenticated, @requiresScopes and/or @policy auth requirements needed to access dependent data.',",0
"      validateListSizeAppliedToList(application, parent, errorCollector);
      validateAssumedSizeNotNegative(application, parent, errorCollector);
      validateSlicingArgumentsAreValidIntegers(application, parent, errorCollector);
      validateSizedFieldsAreValidLists(application, parent, errorCollector);
    }

    // Validate @authenticated, @requireScopes and @policy usage on interfaces and interface objects
    validateNoAuthenticationOnInterfaces(metadata, errorCollector);

    return errorCollector;
  }

  validationRules(): readonly SDLValidationRule[] {
    return FEDERATION_VALIDATION_RULES;
  }

  onUnknownDirectiveValidationError(schema: Schema, unknownDirectiveName: string, error: GraphQLError): GraphQLError {
    const metadata = federationMetadata(schema);
    assert(metadata, `This method should only have been called on a subgraph schema`)
    if (ALL_DEFAULT_FEDERATION_DIRECTIVE_NAMES.includes(unknownDirectiveName)) {
      // The directive name is ""unknown"" but it is a default federation directive name. So it means one of a few things
      // happened:
      //  1. it's a fed1 schema but the directive is a fed2 only one (only possible case for fed1 schema).
      //  2. the directive has not been imported at all (so needs to be prefixed for it to work).
      //  3. the directive has an `import`, but it's been aliased to another name.
      if (metadata.isFed2Schema()) {
        const federationFeature = metadata.federationFeature();
        assert(federationFeature, 'Fed2 subgraph _must_ link to the federation feature')
        const directiveNameInSchema = federationFeature.directiveNameInSchema(unknownDirectiveName);
        if (directiveNameInSchema.startsWith(federationFeature.nameInSchema + '__')) {
          // There is no import for that directive
          return withModifiedErrorMessage(
            error,
            `${error.message} If you meant the ""@${unknownDirectiveName}"" federation directive, you should use fully-qualified name ""@${directiveNameInSchema}"" or add ""@${unknownDirectiveName}"" to the \`import\` argument of the @link to the federation specification.`
          );
        } else {
          // There's an import, but it's renamed
          return withModifiedErrorMessage(
            error,
            `${error.message} If you meant the ""@${unknownDirectiveName}"" federation directive, you should use ""@${directiveNameInSchema}"" as it is imported under that name in the @link to the federation specification of this schema.`
          );
        }
      } else {
        return withModifiedErrorMessage(
          error,
          `${error.message} If you meant the ""@${unknownDirectiveName}"" federation 2 directive, note that this schema is a federation 1 schema. To be a federation 2 schema, it needs to @link to the federation specifcation v2.`
        );
      }
    } else if (!metadata.isFed2Schema()) {
      // We could get here in the case where a fed1 schema has tried to use a fed2 directive but mispelled it.
      const suggestions = suggestionList(unknownDirectiveName, ALL_DEFAULT_FEDERATION_DIRECTIVE_NAMES);
      if (suggestions.length > 0) {
        return withModifiedErrorMessage(
          error,
          `${error.message}${didYouMean(suggestions.map((s) => '@' + s))} If so, note that ${suggestions.length === 1 ? 'it is a federation 2 directive' : 'they are federation 2 directives'} but this schema is a federation 1 one. To be a federation 2 schema, it needs to @link to the federation specifcation v2.`
        );
      }
    }
    return error;
  }

  applyDirectivesAfterParsing() {
    return true;
  }
}

function findUnusedNamedForLinkDirective(schema: Schema): string | undefined {
  if (!schema.directive(linkSpec.url.name)) {
    return undefined;
  }

  // The schema already defines a directive named `@link` so we need to use an alias.
  // To keep it simple, we add a number in the end (so we try `@link1`, and if that's taken `@link2`, ...)
  const baseName = linkSpec.url.name;
  const n = 1;
  for (;;) {
    const candidate = baseName + n;
    if (!schema.directive(candidate)) {
      return candidate;
    }
  }
}

export function setSchemaAsFed2Subgraph(schema: Schema, useLatest: boolean = false) {
  let core = schema.coreFeatures;
  let spec: CoreSpecDefinition;
  if (core) {
    spec = core.coreDefinition;
    // We don't accept pre-1.0 @core: this avoid having to care about what the name
    // of the argument below is, and why would be bother?
    assert(spec.url.version.satisfies(linkSpec.version), `Fed2 schema must use @link with version >= 1.0, but schema uses ${spec.url}`);
  } else {
    const alias = findUnusedNamedForLinkDirective(schema);
    const errors = linkSpec.addToSchema(schema, alias);
    if (errors.length > 0) {
      throw ErrGraphQLValidationFailed(errors);
    }
    spec = linkSpec;
    core = schema.coreFeatures;
    assert(core, 'Schema should now be a core schema');
  }

  const fedSpec = useLatest ? latestFederationSpec : autoExpandedFederationSpec;

  assert(!core.getByIdentity(fedSpec.identity), 'Schema already set as a federation subgraph');
  schema.schemaDefinition.applyDirective(
    core.coreItself.nameInSchema,
    {
      // note that there is a mismatch between url and directives that are imported. This is because
      // we want to maintain backward compatibility for those who have already upgraded and we had been upgrading the url to
      // latest, but we never automatically import directives that exist past 2.4
      url: fedSpec.url.toString(),
      import: autoExpandedFederationSpec.directiveSpecs().map((spec) => `@${spec.name}`),
    }
  );
  const errors = completeSubgraphSchema(schema);
  if (errors.length > 0) {
    throw ErrGraphQLValidationFailed(errors);
  }
}

// This is the full @link declaration as added by `asFed2SubgraphDocument`. It's here primarily for uses by tests that print and match
// subgraph schema to avoid having to update 20+ tests every time we use a new directive or the order of import changes ...
export const FEDERATION2_LINK_WITH_FULL_IMPORTS = '@link(url: ""https://specs.apollo.dev/federation/v2.12"", import: [""@key"", ""@requires"", ""@provides"", ""@external"", ""@tag"", ""@extends"", ""@shareable"", ""@inaccessible"", ""@override"", ""@composeDirective"", ""@interfaceObject"", ""@authenticated"", ""@requiresScopes"", ""@policy"", ""@context"", ""@fromContext"", ""@cost"", ""@listSize"", ""@cacheTag""])';
// This is the full @link declaration that is added when upgrading fed v1 subgraphs to v2 version. It should only be used by tests.
export const FEDERATION2_LINK_WITH_AUTO_EXPANDED_IMPORTS = '@link(url: ""https://specs.apollo.dev/federation/v2.12"", import: [""@key"", ""@requires"", ""@provides"", ""@external"", ""@tag"", ""@extends"", ""@shareable"", ""@inaccessible"", ""@override"", ""@composeDirective"", ""@interfaceObject""])';

// This is the federation @link for tests that go through the SchemaUpgrader.
export const FEDERATION2_LINK_WITH_AUTO_EXPANDED_IMPORTS_UPGRADED = '@link(url: ""https://specs.apollo.dev/federation/v2.4"", import: [""@key"", ""@requires"", ""@provides"", ""@external"", ""@tag"", ""@extends"", ""@shareable"", ""@inaccessible"", ""@override"", ""@composeDirective"", ""@interfaceObject""])';

/**
 * Given a document that is assumed to _not_ be a fed2 schema (it does not have a `@link` to the federation spec),
 * returns an equivalent document that `@link` to the last known federation spec.
 *
 * @param document - the document to ""augment"".
 * @param options.addAsSchemaExtension - defines whether the added `@link` is added as a schema extension (`extend schema`) or
 *   added to the schema definition. Defaults to `true` (added as an extension), as this mimics what we tends to write manually.
 * @param options.includeAllImports - defines whether we should auto import ALL latest federation v2 directive definitions or include
 *   only limited set of directives (i.e. federation v2.4 definitions)
 */
export function asFed2SubgraphDocument(document: DocumentNode, options?: { addAsSchemaExtension?: boolean, includeAllImports?: boolean }): DocumentNode {
  const importedDirectives = options?.includeAllImports ? latestFederationSpec.directiveSpecs() : autoExpandedFederationSpec.directiveSpecs();
  const directiveToAdd: ConstDirectiveNode = ({
    kind: Kind.DIRECTIVE,
    name: { kind: Kind.NAME, value: linkDirectiveDefaultName },
    arguments: [
      {
        kind: Kind.ARGUMENT,
        name: { kind: Kind.NAME, value: 'url' },
        value: { kind: Kind.STRING, value: latestFederationSpec.url.toString() }
      },
      {
        kind: Kind.ARGUMENT,
        name: { kind: Kind.NAME, value: 'import' },
        value: { kind: Kind.LIST, values: importedDirectives.map((spec) => ({ kind: Kind.STRING, value: `@${spec.name}` })) }
      }
    ]
  });
  if (options?.addAsSchemaExtension ?? true) {
    return {
      kind: Kind.DOCUMENT,
      loc: document.loc,
      definitions: document.definitions.concat({
        kind: Kind.SCHEMA_EXTENSION,
        directives: [directiveToAdd]
      }),
    }
  }

  // We can't add a new schema definition if it already exists. If it doesn't we need to know if there is a mutation type or
  // not.
  const existingSchemaDefinition = document.definitions.find((d): d is SchemaDefinitionNode => d.kind == Kind.SCHEMA_DEFINITION);
  if (existingSchemaDefinition) {
    return {
      kind: Kind.DOCUMENT,
      loc: document.loc,
      definitions: document.definitions.filter((d) => d !== existingSchemaDefinition).concat([{
        ...existingSchemaDefinition,
        directives: [directiveToAdd].concat(existingSchemaDefinition.directives ?? []),
      }]),
    }
  } else {
    const hasMutation = document.definitions.some((d) => d.kind === Kind.OBJECT_TYPE_DEFINITION && d.name.value === 'Mutation');
    const makeOpType = (opType: OperationTypeNode, name: string): OperationTypeDefinitionNode => ({
      kind: Kind.OPERATION_TYPE_DEFINITION,
      operation: opType,
      type: {
        kind: Kind.NAMED_TYPE,
        name: {
          kind: Kind.NAME,
          value: name,
        }
      },
    });
    return {
      kind: Kind.DOCUMENT,
      loc: document.loc,
      definitions: document.definitions.concat({
        kind: Kind.SCHEMA_DEFINITION,
        directives: [directiveToAdd],
        operationTypes: [ makeOpType(OperationTypeNode.QUERY, 'Query') ].concat(hasMutation ? makeOpType(OperationTypeNode.MUTATION, 'Mutation') : []),
      }),
    }
  }
}

export function printSubgraphNames(names: string[]): string {
  return printHumanReadableList(
    names.map(n => `""${n}""`),
    {
      prefix: 'subgraph',
      prefixPlural: 'subgraphs',
    }
  );
}

export function federationMetadata(schema: Schema): FederationMetadata | undefined {
  return (schema as any)['_federationMetadata'];
}

export function isFederationSubgraphSchema(schema: Schema): boolean {
  return !!federationMetadata(schema);
}

export function isFederationField(field: FieldDefinition<CompositeType>): boolean {
  if (field.parent === field.schema().schemaDefinition.root(""query"")?.type) {
    return FEDERATION_OPERATION_FIELDS.includes(field.name);
  }
  return false;
}

export function isEntityType(type: NamedType): boolean {
  if (!isObjectType(type) && !isInterfaceType(type)) {
    return false;
  }
  const metadata = federationMetadata(type.schema());
  return !!metadata && type.hasAppliedDirective(metadata.keyDirective());
}

export function isInterfaceObjectType(type: NamedType): boolean {
  if (!isObjectType(type)) {
    return false;
  }
  const metadata = federationMetadata(type.schema());
  return !!metadata && metadata.isInterfaceObjectType(type);
}

export function buildSubgraph(
  name: string,
  url: string,
  source: DocumentNode | string,
  withRootTypeRenaming: boolean = true,
): Subgraph {
  const buildOptions = {
    blueprint: new FederationBlueprint(withRootTypeRenaming),
    validate: false,
  };
  let subgraph: Subgraph;
  try {
    const schema = typeof source === 'string'
      ? buildSchema(new Source(source, name), buildOptions)
      : buildSchemaFromAST(source, buildOptions)
    subgraph = new Subgraph(name, url, schema);
  } catch (e) {
    if (e instanceof GraphQLError && name !== FEDERATION_UNNAMED_SUBGRAPH_NAME) {
      throw addSubgraphToError(e, name, ERRORS.INVALID_GRAPHQL);
    } else {
      throw e;
    }
  }
  return subgraph.validate();
}

export function newEmptyFederation2Schema(config?: SchemaConfig): Schema {
  const schema = new Schema(new FederationBlueprint(true), config);
  setSchemaAsFed2Subgraph(schema, true);
  return schema;
}

function completeSubgraphSchema(schema: Schema): GraphQLError[] {
  const coreFeatures = schema.coreFeatures;
  if (coreFeatures) {
    const fedFeature = coreFeatures.getByIdentity(federationIdentity);
    if (fedFeature) {
      return completeFed2SubgraphSchema(schema);
    } else {
      return completeFed1SubgraphSchema(schema);
    }
  } else {
    const fedLink = schema.schemaDefinition.appliedDirectivesOf(linkDirectiveDefaultName).find(isFedSpecLinkDirective);
    if (fedLink) {
      const errors = linkSpec.addToSchema(schema);
      if (errors.length > 0) {
        return errors;
      }
      return completeFed2SubgraphSchema(schema);
    } else {
      return completeFed1SubgraphSchema(schema);
    }
  }
}

function isFedSpecLinkDirective(directive: Directive<SchemaDefinition>): directive is Directive<SchemaDefinition, LinkDirectiveArgs> {
  const args = directive.arguments();
  return directive.name === linkDirectiveDefaultName && args['url'] && (args['url'] as string).startsWith(federationIdentity);
}

function completeFed1SubgraphSchema(schema: Schema): GraphQLError[] {
  // We special case @key, @requires and @provides because we've seen existing user schema where those
  // have been defined in an invalid way, but in a way that fed1 wasn't rejecting. So for convenience,
  // if we detect one of those case, we just remove the definition and let the code afteward add the
  // proper definition back.
  // Note that, in a perfect world, we'd do this within the `SchemaUpgrader`. But the way the code
  // is organised, this method is called before we reach the `SchemaUpgrader`, and it doesn't seem
  // worth refactoring things drastically for that minor convenience.
  for (const name of [FederationDirectiveName.KEY, FederationDirectiveName.PROVIDES, FederationDirectiveName.REQUIRES]) {
    const directive = schema.directive(name);
    if (!directive) {
      continue;
    }

    // We shouldn't have applications at the time of this writing because `completeSubgraphSchema`, which calls this,
    // is only called:
    // 1. during schema parsing, by `FederationBluePrint.onDirectiveDefinitionAndSchemaParsed`, and that is called
    //   before we process any directive applications.
    // 2. by `setSchemaAsFed2Subgraph`, but as the name imply, this trickles to `completeFed2SubgraphSchema`, not
    //   this one method.
    // In other words, there is currently no way to create a full fed1 schema first, and get that method called
    // second. If that changes (no real reason but...), we'd have to modify this because when we remove the
    // definition to re-add the ""correct"" version, we'd have to re-attach existing applications (doable but not
    // done). This assert is so we notice it quickly if that ever happens (again, unlikely, because fed1 schema
    // is a backward compatibility thing and there is no reason to expand that too much in the future).
    assert(directive.applications().size === 0, `${directive} shouldn't have had validation at that places`);

    // The patterns we recognize and ""correct"" (by essentially ignoring the definition)
    // are:
    //  1. if the definition has no arguments at all.
    //  2. if the `fields` argument is declared as nullable.
    //  3. if the `fields` argument type is named ""FieldSet"" instead of ""_FieldSet"".
    //
    // Note that they all correspong to things we've seen in use schema.
    const fieldType = directive.argument('fields')?.type?.toString();
    // Note that to be on the safe side, we check that `fields` is the only argument. That's
    // because while fed2 accepts the optional `resolvable` arg for @key, fed1 only ever
    // accepted that one argument for all those directives. But if the use had definited
    // more arguments _and_ provided value for such extra argument in some applications,
    // us removing the definition would create validation errors that would be hard to
    // understand for the user.
    const fieldTypeIsWrongInKnownWays = !!fieldType
      && directive.arguments().length === 1
      && (fieldType === 'String' || fieldType === '_FieldSet' || fieldType === 'FieldSet');

    if (directive.arguments().length === 0 || fieldTypeIsWrongInKnownWays) {
      directive.remove();
    }
  }

  const errors = FEDERATION1_TYPES.map((spec) => spec.checkOrAdd(schema, FAKE_FED1_CORE_FEATURE_TO_RENAME_TYPES))
    .concat(FEDERATION1_DIRECTIVES.map((spec) => spec.checkOrAdd(schema)))
    .flat();

  return errors.length === 0 ? expandKnownFeatures(schema) : errors;
}

function completeFed2SubgraphSchema(schema: Schema): GraphQLError[] {
  const coreFeatures = schema.coreFeatures;
  assert(coreFeatures, 'This method should not have been called on a non-core schema');

  const fedFeature = coreFeatures.getByIdentity(federationIdentity);
  assert(fedFeature, 'This method should not have been called on a schema with no @link for federation');

  const spec = FEDERATION_VERSIONS.find(fedFeature.url.version);
  if (!spec) {
    return [ERRORS.UNKNOWN_FEDERATION_LINK_VERSION.err(
      `Invalid version ${fedFeature.url.version} for the federation feature in @link directive on schema`,
      { nodes: fedFeature.directive.sourceAST },
    )];
  }

  const errors = spec.addElementsToSchema(schema);
  return errors.length === 0 ? expandKnownFeatures(schema) : errors;
}

function expandKnownFeatures(schema: Schema): GraphQLError[] {
  const coreFeatures = schema.coreFeatures;
  if (!coreFeatures) {
    return [];
  }

  let errors: GraphQLError[] = [];
  for (const feature of coreFeatures.allFeatures()) {
    // We should already have dealt with the core/link spec and federation at this point. Also, we shouldn't have the `join` spec in subgraphs,
    // but some tests play with the idea and currently the join spec is implemented in a way that is not idempotent (it doesn't use
    // `DirectiveSpecification.checkAndAdd`; we should clean it up at some point, but not exactly urgent).
    if (feature === coreFeatures.coreItself || feature.url.identity === federationIdentity  || feature.url.identity === joinIdentity) {
      continue;
    }

    const spec = coreFeatureDefinitionIfKnown(feature.url);
    if (!spec) {
      continue;
    }

    errors = errors.concat(spec.addElementsToSchema(schema));
  }
  return errors;
}

export function parseFieldSetArgument({
  parentType,
  directive,
  fieldAccessor,
  validate,
  decorateValidationErrors = true,
  normalize = false,
}: {
  parentType: CompositeType,
  directive: Directive<SchemaElement<any, any>, {fields: any}>,
  fieldAccessor?: (type: CompositeType, fieldName: string) => FieldDefinition<any> | undefined,
  validate?: boolean,
  decorateValidationErrors?: boolean,
  normalize?: boolean,
}): SelectionSet {
  try {
    const selectionSet = parseSelectionSet({
      parentType,
      source: validateFieldSetValue(directive),
      fieldAccessor,
      validate,
    });
    if (validate ?? true) {
      selectionSet.forEachElement((elt) => {
        if (elt.kind === 'Field' && elt.alias) {
          // Note that this will be caught by the surrounding catch and ""decorated"".
          throw new GraphQLError(`Cannot use alias ""${elt.alias}"" in ""${elt}"": aliases are not currently supported in @${directive.name}`);
        }
      });
    }
    return normalize
      ? selectionSet.normalize({ parentType, recursive: true })
      : selectionSet;
  } catch (e) {
    if (!(e instanceof GraphQLError) || !decorateValidationErrors) {
      throw e;
    }

    throw handleFieldSetValidationError(
      directive,
      e,
      (msg: string) => {
        if (msg.startsWith('Cannot query field')) {
          if (msg.endsWith('.')) {
            msg = msg.slice(0, msg.length - 1);
          }
          if (directive.name === FederationDirectiveName.KEY) {
            msg = msg + ' (the field should either be added to this subgraph or, if it should not be resolved by this subgraph, you need to add it to this subgraph with @external).';
          } else {
            msg = msg + ' (if the field is defined in another subgraph, you need to add it to this subgraph with @external).';
          }
        }
        return msg;
      },
    );
  }
}

export function collectTargetFields({
  parentType,
  directive,
  includeInterfaceFieldsImplementations,
  validate = true,
}: {
  parentType: CompositeType,
  directive: Directive<NamedType | FieldDefinition<CompositeType>, {fields: any}>,
  includeInterfaceFieldsImplementations: boolean,
  validate?: boolean,
}): FieldDefinition<CompositeType>[] {
  const fields: FieldDefinition<CompositeType>[] = [];
  try {
    parseFieldSetArgument({
      parentType,
      directive,
      fieldAccessor: (t, f) => {
        const field = t.field(f);
        if (field) {
          fields.push(field);
          if (includeInterfaceFieldsImplementations && isInterfaceType(t)) {
            for (const implType of t.possibleRuntimeTypes()) {
              const implField = implType.field(f);
              if (implField) {
                fields.push(implField);
              }
            }
          }
        }
        return field;
      },
      validate,
    });
  } catch (e) {
    // If we explicitly requested no validation, then we shouldn't throw a (graphQL) error, but if we do, we swallow it
    // (returning a partial result, but we assume it is fine).
    const isGraphQLError = errorCauses(e) !== undefined
    if (!isGraphQLError || validate) {
      throw e;
    }
  }
  return fields;
}

function validateFieldSetValue(directive: Directive<SchemaElement<any, any>, {fields: any}>): string {
  const fields = directive.arguments().fields;
  const nodes = directive.sourceAST;
  if (typeof fields !== 'string') {
    throw ERROR_CATEGORIES.DIRECTIVE_INVALID_FIELDS_TYPE.get(directive.name).err(
      `Invalid value for argument ""${directive.definition!.argument('fields')!.name}"": must be a string.`,
      { nodes },
    );
  }
  // While validating if the field is a string will work in most cases, this will not catch the case where the field argument was
  // unquoted but parsed as an enum value (see federation/issues/850 in particular). So if we have the AST (which we will usually
  // have in practice), use that to check that the argument was truly a string.
  if (nodes && nodes.kind === 'Directive') {
    for (const argNode of nodes.arguments ?? []) {
      if (argNode.name.value === 'fields') {
        if (argNode.value.kind !== 'StringValue') {
          throw ERROR_CATEGORIES.DIRECTIVE_INVALID_FIELDS_TYPE.get(directive.name).err(
            `Invalid value for argument ""${directive.definition!.argument('fields')!.name}"": must be a string.`,
            { nodes },
          );
        }
        break;
      }
    }
  }

  return fields;
}

export interface ServiceDefinition {
  typeDefs: DocumentNode;
  name: string;
  url?: string;
}
export function subgraphsFromServiceList(serviceList: ServiceDefinition[]): Subgraphs | GraphQLError[] {
  let errors: GraphQLError[] = [];
  const subgraphs = new Subgraphs();
  for (const service of serviceList) {
    try {
      subgraphs.add(buildSubgraph(service.name, service.url ?? '', service.typeDefs));
    } catch (e) {
      const causes = errorCauses(e);
      if (causes) {
        errors = errors.concat(causes);
      } else {
        throw e;
      }
    }
  }
  return errors.length === 0 ? subgraphs : errors;
}

// Simple wrapper around a Subgraph[] that ensures that 1) we never mistakenly get 2 subgraph with the same name,
// 2) keep the subgraphs sorted by name (makes iteration more predictable). It also allow convenient access to
// a subgraph by name so behave like a map<string, Subgraph> in most ways (but with the previously mentioned benefits).
export class Subgraphs {
  private readonly subgraphs = new OrderedMap<string, Subgraph>();

  add(subgraph: Subgraph): Subgraph {
    if (this.subgraphs.has(subgraph.name)) {
      throw new Error(`A subgraph named ${subgraph.name} already exists` + (subgraph.url ? ` (with url '${subgraph.url}')` : ''));
    }

    this.subgraphs.add(subgraph.name, subgraph);
    return subgraph;
  }

  get(name: string): Subgraph | undefined {
    return this.subgraphs.get(name);
  }

  size(): number {
    return this.subgraphs.size;
  }

  names(): readonly string[] {
    return this.subgraphs.keys();
  }

  values(): readonly Subgraph[] {
    return this.subgraphs.values();
  }

  *[Symbol.iterator]() {
    for (const subgraph of this.subgraphs) {
      yield subgraph;
    }
  }

  validate(): GraphQLError[] | undefined {
    let errors: GraphQLError[] = [];
    for (const subgraph of this.values()) {
      try {
        subgraph.validate();
      } catch (e) {
        const causes = errorCauses(e);
        if (!causes) {
          throw e;
        }
        errors = errors.concat(causes);
      }
    }
    return errors.length === 0 ? undefined : errors;
  }

  toString(): string {
    return '[' + this.subgraphs.keys().join(', ') + ']'
  }
}

export const anyTypeSpec = createScalarTypeSpecification({ name: '_Any' });

export const serviceTypeSpec = createObjectTypeSpecification({
  name: '_Service',
  fieldsFct: (schema) => [{ name: 'sdl', type: schema.stringType() }],
});

export const entityTypeSpec = createUnionTypeSpecification({
  name: '_Entity',
  membersFct: (schema) => {
    // Please note that `_Entity` cannot use ""interface entities"" since interface types cannot be in unions.
    // It is ok in practice because _Entity is only use as return type for `_entities`, and even when interfaces
    // are involve, the result of an `_entities` call will always be an object type anyway, and since we force
    // all implementations of an interface entity to be entity themselves in a subgraph, we're fine.
    return schema.objectTypes().filter(isEntityType).map((t) => t.name);
  },
});

export const FEDERATION_OPERATION_TYPES = [ anyTypeSpec, serviceTypeSpec, entityTypeSpec ];

export const serviceFieldName = '_service';
export const entitiesFieldName = '_entities';

export const FEDERATION_OPERATION_FIELDS: readonly string[] = [ serviceFieldName, entitiesFieldName ];

export class Subgraph {
  constructor(
    readonly name: string,
    readonly url: string,
    readonly schema: Schema,
  ) {
    if (name === FEDERATION_RESERVED_SUBGRAPH_NAME) {
      throw ERRORS.INVALID_SUBGRAPH_NAME.err(`Invalid name ${FEDERATION_RESERVED_SUBGRAPH_NAME} for a subgraph: this name is reserved`);
    }
  }

  metadata(): FederationMetadata {
    const metadata = federationMetadata(this.schema);
    assert(metadata, 'The subgraph schema should have built with the federation built-ins.');
    return metadata;
  }

  isFed2Subgraph(): boolean {
    return this.metadata().isFed2Schema();
  }

  // Adds the _entities and _service fields to the root query type.
  private addFederationOperations() {
    const metadata = this.metadata();

    for (const type of FEDERATION_OPERATION_TYPES) {
      type.checkOrAdd(this.schema);
    }

    const queryRoot = this.schema.schemaDefinition.root(""query"");
    const queryType = queryRoot ? queryRoot.type : this.schema.addType(new ObjectType(""Query""));

    const entityField = queryType.field(entitiesFieldName);
    const entityType = metadata.entityType();
    if (entityType) {
      const entityFieldType = new NonNullType(new ListType(entityType));
      if (!entityField) {
        queryType.addField(entitiesFieldName, entityFieldType)
          .addArgument('representations', new NonNullType(new ListType(new NonNullType(metadata.anyType()))));
      } else if (!entityField.type) {
        // This can happen when the schema had an empty redefinition of _Entity as we've removed it in
        // that clear and that would have clear the type of the correspond field. Let's re-populate it
        // in that case.
        entityField.type = entityType;
      }
    } else if (entityField) {
      entityField.remove();
    }

    if (!queryType.field(serviceFieldName)) {
      queryType.addField(serviceFieldName, new NonNullType(metadata.serviceType()));
    }
  }

  /**
   * Same as `Schema.assumeValid`. Use carefully.
   */
  assumeValid(): Subgraph {
    this.addFederationOperations();
    this.schema.assumeValid();
    return this;
  }

  validate(): Subgraph {
    try {
      this.addFederationOperations();
      this.schema.validate();
      return this;
    } catch (e) {
      if (e instanceof GraphQLError) {
        // Note that `addSubgraphToError` only adds the provided code if the original error
        // didn't have one, and the only one that will not have a code are GraphQL errors
        // (since we assign specific codes to the federation errors).
        throw addSubgraphToError(e, this.name, ERRORS.INVALID_GRAPHQL);
      } else {
        throw e;
      }
    }
  }

  private isPrintedDirective(d: DirectiveDefinition): boolean {
    if (this.metadata().allFederationDirectives().includes(d)) {
      return false;
    }

    const core = this.schema.coreFeatures;
    return !core || core.sourceFeature(d)?.feature.url.identity !== linkIdentity;
  }

  private isPrintedType(t: NamedType): boolean {
    if (this.metadata().allFederationTypes().includes(t)) {
      return false;
    }

    // If the query type only have our federation specific fields, then that (almost surely) means the original subgraph
    // had no Query type and so we save printing it.
    if (isObjectType(t) && t.isQueryRootType() && t.fields().filter((f) => !isFederationField(f)).length === 0) {
      return false;
    }

    const core = this.schema.coreFeatures;
    return !core || core.sourceFeature(t)?.feature.url.identity !== linkIdentity;
  }

  private isPrintedDirectiveApplication(d: Directive): boolean {
    // We print almost all directive application, but the one we skip is the `@link` to the link spec itself.
    // The reason is that it is one of the things that usually not provided by users but is instead auto-added
    // and so this keep the output a tad ""cleaner"".
    // Do note that it is only auto-added if it uses the `@link` name. If it is renamed, we need to include
    // the application (and more generally, if there is more argument set than just the url, we print
    // the directive to make sure we're not hidding something relevant).
    if (!this.schema.coreFeatures || d.name !== linkSpec.url.name) {
      return true;
    }
    const args = d.arguments();
    let urlArg: FeatureUrl | undefined = undefined;
    if ('url' in args) {
      try {
        urlArg = FeatureUrl.parse(args['url']);
      } catch (e) {
        // ignored on purpose: if the 'url' arg don't parse properly as a Feature url, then `urlArg` will
        // be `undefined` which we want.
      }
    }
    const isDefaultLinkToLink = urlArg?.identity === linkIdentity && Object.keys(args).length === 1;
    return !isDefaultLinkToLink;
  }

  /**
   * Returns a representation of the subgraph without any auto-imported directive definitions or ""federation private""
   * types and fiels (`_service` et al.).
   *
   * In other words, this will correspond to what a user would usually write.
   *
   * Note that if one just want a representation of the full schema, then it can simply call `printSchema(this.schema)`.
   */
  toString(basePrintOptions: PrintOptions = defaultPrintOptions) {
    return printSchema(
      this.schema,
      {
        ...basePrintOptions,
        directiveDefinitionFilter: (d) => this.isPrintedDirective(d),
        typeFilter: (t) => this.isPrintedType(t),
        fieldFilter: (f) => !isFederationField(f),
        directiveApplicationFilter: (d) => this.isPrintedDirectiveApplication(d),
      }
    );
  }
}

export type SubgraphASTNode = ASTNode & { subgraph: string };

export function addSubgraphToASTNode(node: ASTNode, subgraph: string): SubgraphASTNode {
  // We won't override a existing subgraph info: it's not like the subgraph an ASTNode can come
  // from can ever change and this allow the provided to act as a ""default"" rather than a
  // hard setter, which is convenient in `addSubgraphToError` below if some of the AST of
  // the provided error already have a subgraph ""origin"".
  if ('subgraph' in (node as any)) {
    return node as SubgraphASTNode;
  }
  return {
    ...node,
    subgraph
  };
}

export function addSubgraphToError(e: GraphQLError, subgraphName: string, errorCode?: ErrorCodeDefinition): GraphQLError {
  const updatedCauses = errorCauses(e)!.map(cause => {
    const message = `[${subgraphName}] ${cause.message}`;
    const nodes = cause.nodes
      ? cause.nodes.map(node => addSubgraphToASTNode(node, subgraphName))
      : undefined;

    const code = errorCodeDef(cause) ?? errorCode;
    const options: GraphQLErrorOptions = {
      ...extractGraphQLErrorOptions(cause),
      nodes,
      originalError: cause,
    };

    return code
      ? code.err(message, options)
      : new GraphQLError(message, options);
  });

  return updatedCauses.length === 1 ? updatedCauses[0] : ErrGraphQLValidationFailed(updatedCauses);
}

class ExternalTester {
  private readonly fakeExternalFields = new Set<string>();
  private readonly providedFields = new Set<string>();
  private readonly externalDirective: DirectiveDefinition<{}>;
  private readonly externalFieldsOnType = new Set<string>();

  constructor(readonly schema: Schema, private readonly isFed2Schema: boolean) {
    this.externalDirective = this.metadata().externalDirective();
    this.collectFakeExternals();
    this.collectProvidedFields();
    this.collectExternalsOnType();
  }

  private metadata(): FederationMetadata {
    const metadata = federationMetadata(this.schema);
    assert(metadata, 'Schema should be a subgraphs schema');
    return metadata;
  }

  private collectFakeExternals() {
    const metadata = this.metadata();
    const extendsDirective =  metadata.extendsDirective();
    for (const key of metadata.keyDirective().applications()) {
      const parentType = key.parent as CompositeType;
      if (!(key.ofExtension() || parentType.hasAppliedDirective(extendsDirective))) {
        continue;
      }
      collectTargetFields({
        parentType,
        directive: key as Directive<any, {fields: any}>,
        includeInterfaceFieldsImplementations: false,
        validate: false,
      }).filter((field) => field.hasAppliedDirective(this.externalDirective))
        .forEach((field) => this.fakeExternalFields.add(field.coordinate));
    }
  }

  private collectProvidedFields() {
    for (const provides of this.metadata().providesDirective().applications()) {
      const parent = provides.parent as FieldDefinition<CompositeType>;
      const parentType = baseType(parent.type!);
      // If `parentType` is not a composite, that means an invalid @provides, but we ignore such errors
      // for now (also why we pass 'validate: false'). Proper errors will be thrown later during validation.
      if (isCompositeType(parentType)) {
        collectTargetFields({
          parentType,
          directive: provides as Directive<any, {fields: any}>,
          includeInterfaceFieldsImplementations: true,
          validate: false,
        }).forEach((f) => this.providedFields.add(f.coordinate));
      }
    }
  }

  private collectExternalsOnType() {
    // We do not collect @external on types for fed1 schema since those will be discarded by the schema upgrader.
    // The schema upgrader, through calls to `isExternal`, relies on the populated `externalFieldsOnType` object to
    // inform when @shareable should be automatically added. In the fed1 case, if the map is populated then @shareable won't
    // be added in places where it should have.
    if (!this.isFed2Schema) {
      return;
    }

    for (const type of this.schema.objectTypes()) {
      if (type.hasAppliedDirective(this.externalDirective)) {
        for (const field of type.fields()) {
          this.externalFieldsOnType.add(field.coordinate);
        }
      }
    }
  }

  isExternal(field: FieldDefinition<any> | InputFieldDefinition) {
    return (field.hasAppliedDirective(this.externalDirective) || this.externalFieldsOnType.has(field.coordinate)) && !this.isFakeExternal(field);
  }

  isFakeExternal(field: FieldDefinition<any> | InputFieldDefinition) {
    return this.fakeExternalFields.has(field.coordinate);
  }

  selectsAnyExternalField(selectionSet: SelectionSet): boolean {
    for (const selection of selectionSet.selections()) {
      if (selection.kind === 'FieldSelection' && this.isExternal(selection.element.definition)) {
        return true;
      }
      if (selection.selectionSet) {
        if (this.selectsAnyExternalField(selection.selectionSet)) {
          return true;
        }
      }
    }
    return false;
  }

  isPartiallyExternal(field: FieldDefinition<any> | InputFieldDefinition) {
    return this.isExternal(field) && this.providedFields.has(field.coordinate);
  }

  isFullyExternal(field: FieldDefinition<any> | InputFieldDefinition) {
    return this.isExternal(field) && !this.providedFields.has(field.coordinate);
  }
}

export type ProvidesOrRequiresApplication = Directive<FieldDefinition<ObjectType | InterfaceType>, {fields: any}>

/*
 * It makes no sense to have a @provides/@requires on a non-external leaf field, and we usually reject it during schema
 * validation but this method allows to remove those for:
 *  1. when we extract subgraphs from a fed 1 supergraph, where such validation hadn't been run.
 *  2. for the fed 1 -> fed 2 upgader code.
 *
 * The reason we do this (and generally reject it) is that such provides/requires have a negative impact on later query
 * planning, because it sometimes make us to try type-exploding some interfaces unecessarily. Besides, if a use add
 * something useless, there is a change it hasn't fully understood something, and warning it about that fact through
 * an error is more helpful.
 */
export function removeInactiveProvidesAndRequires(
  schema: Schema,
  onModified: (field: FieldDefinition<any>, original: ProvidesOrRequiresApplication, updated?: ProvidesOrRequiresApplication) => void = () => {},
) {
  const metadata = federationMetadata(schema);
  if (!metadata) {
    return;
  }
  const providesDirective = metadata.providesDirective();
  const requiresDirective = metadata.requiresDirective();

  for (const type of schema.types()) {
    if (!isObjectType(type) && !isInterfaceType(type)) {
      continue;
    }

    for (const field of type.fields()) {
      const fieldBaseType = baseType(field.type!) as CompositeType;
      removeInactiveApplications(providesDirective, field, fieldBaseType, onModified);
      removeInactiveApplications(requiresDirective, field, type, onModified);
    }
  }
}

function removeInactiveApplications(
  directiveDefinition: DirectiveDefinition<{fields: any}>,
  field: FieldDefinition<any>,
  parentType: CompositeType,
  onModified: (field: FieldDefinition<any>, original: ProvidesOrRequiresApplication, updated?: ProvidesOrRequiresApplication) => void
) {
  for (const application of field.appliedDirectivesOf(directiveDefinition)) {
    let selection;
    try {
      selection = parseFieldSetArgument({parentType, directive: application});
    } catch (e) {
      // This method is sometimes called on federation directives that haven't been validated, and so parsing the
      // `fields` argument may throw. In that case, we just silently ignore that particular directive application:
      // it's not the job of this method to do validation, but we will always validate things in other places
      // when needed so whatever error that directive has will be caught in a more appropriate place.
      continue;
    }
    if (selectsNonExternalLeafField(selection)) {
      application.remove();
      const updated = withoutNonExternalLeafFields(selection);
      if (!updated.isEmpty()) {
        const updatedDirective = field.applyDirective(directiveDefinition, { fields: updated.toString(true, false) });
        onModified(field, application, updatedDirective);
      } else {
        onModified(field, application);
      }
    }
  }
}

function isExternalOrHasExternalImplementations(field: FieldDefinition<CompositeType>): boolean {
  const metadata = federationMetadata(field.schema());
  if (!metadata) {
    return false;
  }
  if (field.hasAppliedDirective(metadata.externalDirective())) {
    return true;
  }
  const parentType = field.parent;
  if (isInterfaceType(parentType)) {
    for (const implem of parentType.possibleRuntimeTypes()) {
      const fieldInImplem = implem.field(field.name);
      if (fieldInImplem && fieldInImplem.hasAppliedDirective(metadata.externalDirective())) {
        return true;
      }
    }
  }
  return false;
}

function selectsNonExternalLeafField(selection: SelectionSet): boolean {
  return selection.selections().some(s => {
    if (s.kind === 'FieldSelection') {
      // If it's external, we're good and don't need to recurse.
      if (isExternalOrHasExternalImplementations(s.element.definition)) {
        return false;
      }
      // Otherwise, we select a non-external if it's a leaf, or the sub-selection does.
      return !s.selectionSet || selectsNonExternalLeafField(s.selectionSet);
    } else {
      return selectsNonExternalLeafField(s.selectionSet);
    }
  });
}

function withoutNonExternalLeafFields(selectionSet: SelectionSet): SelectionSet {
  return selectionSet.lazyMap((selection) => {
    if (selection.kind === 'FieldSelection') {
      if (isExternalOrHasExternalImplementations(selection.element.definition)) {
        // That field is external, so we can add the selection back entirely.
        return selection;
      }
    }
    if (selection.selectionSet) {
      // Note that for fragments this will always be true (and we just recurse), while
      // for fields, we'll only get here if the field is not external, and so
      // we want to add the selection only if it's not a leaf and even then, only
      // the part where we've recursed.
      const updated = withoutNonExternalLeafFields(selection.selectionSet);
      if (!updated.isEmpty()) {
        return selection.withUpdatedSelectionSet(updated);
      }
    }
    // We skip that selection.
    return undefined;
  });
}

function validateNoAuthenticationOnInterfaces(metadata: FederationMetadata, errorCollector: GraphQLError[]) {
  const authenticatedDirective = metadata.authenticatedDirective();
  const requiresScopesDirective = metadata.requiresScopesDirective();
  const policyDirective = metadata.policyDirective();
  [authenticatedDirective, requiresScopesDirective, policyDirective].forEach((directive) => {
    for (const application of directive.applications()) {
      const element = application.parent;
      function isAppliedOnInterface(type: Type) {
        return isInterfaceType(type) || isInterfaceObjectType(baseType(type));
      }
      function isAppliedOnInterfaceField(elem: SchemaElement<any, any>) {
        return isFieldDefinition(elem) && isInterfaceType(elem.parent);
      }

      if (isAppliedOnInterface(element) || isAppliedOnInterfaceField(element)) {
        let kind = '';
        switch (element.kind) {
          case 'FieldDefinition':
            kind = 'field';
            break;
          case 'InterfaceType':
            kind = 'interface';
            break;
          case 'ObjectType':
            kind = 'interface object';
            break;
        }
        errorCollector.push(ERRORS.AUTHENTICATION_APPLIED_ON_INTERFACE.err(
            `Invalid use of @${directive.name} on ${kind} ""${element.coordinate}"": @${directive.name} cannot be applied on interfaces, interface fields and interface objects`,
            {nodes: sourceASTs(application, element.parent)},
        ));
      }
    }
  });
}",0
"<script setup lang=""ts"">
import api from '@/api';
import { useCollectionsStore } from '@/stores/collections';
import { unexpectedError } from '@/utils/unexpected-error';
import EditorJS from '@editorjs/editorjs';
import { isEqual } from 'lodash';
import { onMounted, onUnmounted, ref, watch } from 'vue';
import { useI18n } from 'vue-i18n';
import { useRouter } from 'vue-router';
import { useBus } from './bus';
import { sanitizeValue } from './sanitize';
import getTools from './tools';
import { useFileHandler } from './use-file-handler';

import './editorjs-overrides.css';

// https://github.com/codex-team/editor.js/blob/057bf17a6fc2d5e05c662107918d7c3e943d077c/src/components/events/RedactorDomChanged.ts#L4
const RedactorDomChanged = 'redactor dom changed';

const props = withDefaults(
	defineProps<{
		disabled?: boolean;
		autofocus?: boolean;
		value?: Record<string, any> | null;
		bordered?: boolean;
		placeholder?: string;
		tools?: string[];
		folder?: string;
		font?: 'sans-serif' | 'monospace' | 'serif';
	}>(),
	{
		value: null,
		bordered: true,
		tools: () => ['header', 'nestedlist', 'code', 'image', 'paragraph', 'checklist', 'quote', 'underline'],
		font: 'sans-serif',
	},
);

const bus = useBus();

const emit = defineEmits<{ input: [value: EditorJS.OutputData | null] }>();

const { t } = useI18n();

const collectionStore = useCollectionsStore();

const { currentPreview, setCurrentPreview, fileHandler, setFileHandler, unsetFileHandler, handleFile } =
	useFileHandler();

const editorjsRef = ref<EditorJS>();
const editorjsIsReady = ref(false);
const uploaderComponentElement = ref<HTMLElement>();
const editorElement = ref<HTMLElement>();
const haveFilesAccess = Boolean(collectionStore.getCollection('directus_files'));
const haveValuesChanged = ref(false);
const router = useRouter();

const tools = getTools(
	{
		baseURL: api.defaults.baseURL,
		setFileHandler,
		setCurrentPreview,
		getUploadFieldElement: () => uploaderComponentElement,
	},
	props.tools,
	haveFilesAccess,
);

bus.on(async (event) => {
	if (event.type === 'open-url') {
		router.push(event.payload);
	}
});

onMounted(async () => {
	editorjsRef.value = new EditorJS({
		logLevel: 'ERROR' as EditorJS.LogLevels,
		holder: editorElement.value,
		readOnly: false,
		placeholder: props.placeholder,
		minHeight: 72,
		onChange: (api) => emitValue(api),
		tools: tools,
	});

	await editorjsRef.value.isReady;

	const sanitizedValue = sanitizeValue(props.value);

	if (sanitizedValue) {
		await editorjsRef.value.render(sanitizedValue);
	}

	if (props.autofocus) {
		editorjsRef.value.focus();
	}

	editorjsRef.value.on(RedactorDomChanged, () => {
		emitValue(editorjsRef.value!);
	});

	editorjsIsReady.value = true;
});

onUnmounted(() => {
	editorjsRef.value?.destroy();
	bus.reset();
});

watch(
	() => props.value,
	async (newVal, oldVal) => {
		// First value will be set in 'onMounted'
		if (!editorjsRef.value || !editorjsIsReady.value) return;

		if (haveValuesChanged.value) {
			haveValuesChanged.value = false;
			return;
		}

		if (isEqual(newVal?.blocks, oldVal?.blocks)) return;

		try {
			const sanitizedValue = sanitizeValue(newVal);

			if (sanitizedValue) {
				await editorjsRef.value.render(sanitizedValue);
			} else {
				editorjsRef.value.clear();
			}
		} catch (error) {
			unexpectedError(error);
		}
	},
);

async function emitValue(context: EditorJS.API | EditorJS) {
	if (props.disabled || !context || !context.saver) return;

	try {
		const result = await context.saver.save();

		haveValuesChanged.value = true;

		if (!result || result.blocks.length < 1) {
			emit('input', null);
			return;
		}

		if (isEqual(result.blocks, props.value?.blocks)) return;

		emit('input', result);
	} catch (error) {
		unexpectedError(error);
	}
}
</script>

<template>
	<div class=""input-block-editor"">
		<div ref=""editorElement"" :class=""{ [font]: true, disabled, bordered }""></div>
",0
"							collection: { _eq: collection },
							field: { _eq: field },
						},
					},
					{ emitEvents: false },
				);

				// cleanup permissions for deleted field
				const permissionRows: { id: number; collection: string; fields: string }[] = await trx
					.select('id', 'collection', 'fields')
					.from('directus_permissions')
					.whereRaw('?? = ? AND ?? LIKE ?', ['collection', collection, 'fields', '%' + field + '%']);

				if (permissionRows.length > 0) {
					for (const permissionRow of permissionRows) {
						const newFields = permissionRow['fields']
							.split(',')
							.filter((v) => v !== field)
							.join(',');

						await trx('directus_permissions')
							.update('fields', newFields.length > 0 ? newFields : null)
							.where('id', '=', permissionRow['id']);
					}
				}
			});

			const actionEvent = {
				event: 'fields.delete',
				meta: {
					payload: [field],",0
"/**
 * Check if requested collection exists, and save it to req.collection
 */

import type { RequestHandler } from 'express';
import { systemCollectionRows } from '@directus/system-data';
import asyncHandler from '../utils/async-handler.js';
import { createCollectionForbiddenError } from '../permissions/modules/process-ast/utils/validate-path/create-error.js';

const collectionExists: RequestHandler = asyncHandler(async (req, _res, next) => {
	if (!req.params['collection']) return next();

	if (req.params['collection'] in req.schema.collections === false) {
		throw createCollectionForbiddenError('', req.params['collection']);
	}

	req.collection = req.params['collection'];

	const systemCollectionRow = systemCollectionRows.find((collection) => {
		return collection?.collection === req.collection;",0
"import type { Accountability, Filter, Item, PermissionsAction } from '@directus/types';
import { parseFilter, validatePayload } from '@directus/utils';
import { FailedValidationError, joiValidationErrorItemToErrorExtensions } from '@directus/validation';
import { assign, difference, uniq } from 'lodash-es';
import { fetchPermissions } from '../../lib/fetch-permissions.js';
import { fetchPolicies } from '../../lib/fetch-policies.js';
import type { Context } from '../../types.js';
import { extractRequiredDynamicVariableContext } from '../../utils/extract-required-dynamic-variable-context.js';
import { fetchDynamicVariableData } from '../../utils/fetch-dynamic-variable-data.js';
import { contextHasDynamicVariables } from '../process-ast/utils/context-has-dynamic-variables.js';
import { isFieldNullable } from './lib/is-field-nullable.js';
import {
	createCollectionForbiddenError,
	createFieldsForbiddenError,
} from '../process-ast/utils/validate-path/create-error.js';

export interface ProcessPayloadOptions {
	accountability: Accountability;
	action: PermissionsAction;
	collection: string;
	payload: Item;
	nested: string[];
}

/**
 * @note this only validates the top-level fields. The expectation is that this function is called
 * for each level of nested insert separately
 */
export async function processPayload(options: ProcessPayloadOptions, context: Context) {
	let permissions;
	let permissionValidationRules: (Filter | null)[] = [];

	let policies: string[] = [];

	if (!options.accountability.admin) {
		policies = await fetchPolicies(options.accountability, context);

		permissions = await fetchPermissions(
			{ action: options.action, policies, collections: [options.collection], accountability: options.accountability },
			context,
		);

		if (permissions.length === 0) {
			throw createCollectionForbiddenError('', options.collection);
		}

		const fieldsAllowed = uniq(permissions.map(({ fields }) => fields ?? []).flat());

		if (fieldsAllowed.includes('*') === false) {
			const fieldsUsed = Object.keys(options.payload);
			const notAllowed = difference(fieldsUsed, fieldsAllowed);

			if (notAllowed.length > 0) {
				throw createFieldsForbiddenError('', options.collection, notAllowed);
			}
		}

		permissionValidationRules = permissions.map(({ validation }) => validation);
	}
",0
"import { ForbiddenError } from '@directus/errors';
import type { Accountability, PermissionsAction, PrimaryKey } from '@directus/types';
import type { Context } from '../../types.js';
import { validateCollectionAccess } from './lib/validate-collection-access.js';
import { validateItemAccess } from './lib/validate-item-access.js';
import { createCollectionForbiddenError } from '../process-ast/utils/validate-path/create-error.js';

export interface ValidateAccessOptions {
	accountability: Accountability;
	action: PermissionsAction;
	collection: string;
	primaryKeys?: PrimaryKey[];
	fields?: string[];
	skipCollectionExistsCheck?: boolean;
}

/**
 * Validate if the current user has access to perform action against the given collection and
 * optional primary keys. This is done by reading the item from the database using the access
 * control rules and checking if we got the expected result back
 */
export async function validateAccess(options: ValidateAccessOptions, context: Context) {
	// Skip further validation if the collection does not exist
	if (!options.skipCollectionExistsCheck && options.collection in context.schema.collections === false) {
		throw createCollectionForbiddenError('', options.collection);
	}

	if (options.accountability.admin === true) {
		return;
	}
",0
"	.collection('test', (c) => {
		c.field('id').uuid().primary();
		c.field('text').text();
		c.field('string').string();
		c.field('float').float();
		c.field('integer').integer();

		c.field('secret')
			.string()
			.options({
				special: ['conceal'],
			});
	})
	.build();

const permissions = [
	{
		collection: 'test',
		action: 'read',
		fields: ['text', 'float', 'integer', 'id'],
		permissions: {
			text: {},
		},
	},
] as unknown as Permission[];

for (const number of ['0x56071c902718e681e274DB0AaC9B4Ed2d027924d', '0b11111', '0.42e3', 'Infinity', '42.000']) {
	test(`Prevent ${number} from being cast to number`, async () => {
		const db = vi.mocked(knex.default({ client: Client_SQLite3 }));
		const queryBuilder = db.queryBuilder();

		applySearch(db as any, schema, queryBuilder, number, 'test', {}, permissions);

		const rawQuery = queryBuilder.toSQL();

		expect(rawQuery.sql).toEqual(`select * where ((LOWER(""test"".""text"") LIKE ?))`);
		expect(rawQuery.bindings).toEqual([`%${number.toLowerCase()}%`]);
	});
}

for (const number of ['1234', '-128', '12.34']) {
	test(`Casting number ${number}`, async () => {
		const db = vi.mocked(knex.default({ client: Client_SQLite3 }));
		const queryBuilder = db.queryBuilder();

		applySearch(db as any, schema, queryBuilder, number, 'test', {}, permissions);

		const rawQuery = queryBuilder.toSQL();

		expect(rawQuery.sql).toEqual(
			`select * where ((LOWER(""test"".""text"") LIKE ?) or (""test"".""float"" = ?) or (""test"".""integer"" = ?))`,
		);

		expect(rawQuery.bindings).toEqual([`%${number.toLowerCase()}%`, Number(number), Number(number)]);
	});
}

test(`Query is falsy if no other clause is added`, async () => {
	const db = vi.mocked(knex.default({ client: Client_SQLite3 }));
	const queryBuilder = db.queryBuilder();

	const schema = new SchemaBuilder()
		.collection('test', (c) => {
			c.field('id').uuid().primary();
			c.field('string').string();
			c.field('float').float();
			c.field('integer').integer();
		})
		.build();

	applySearch(db as any, schema, queryBuilder, 'searchstring', 'test', {}, permissions);

	const rawQuery = queryBuilder.toSQL();

	expect(rawQuery.sql).toEqual(`select * where (1 = 0)`);
	expect(rawQuery.bindings).toEqual([]);
});

test(`Exclude non uuid searchable field(s) when searchQuery has valid uuid value`, async () => {
	const db = vi.mocked(knex.default({ client: Client_SQLite3 }));
	const queryBuilder = db.queryBuilder();

	applySearch(db as any, schema, queryBuilder, '4b9adc65-4ad8-4242-9144-fbfc58400d74', 'test', {}, [
		{
			collection: 'test',
			action: 'read',
			fields: ['id', 'text'],
			permissions: null,
		} as unknown as Permission,
	]);

	const rawQuery = queryBuilder.toSQL();

	expect(rawQuery.sql).toEqual(`select * where ((""test"".""id"" = ?) or (LOWER(""test"".""text"") LIKE ?))`);
	expect(rawQuery.bindings).toEqual(['4b9adc65-4ad8-4242-9144-fbfc58400d74', '%4b9adc65-4ad8-4242-9144-fbfc58400d74%']);
});

test(`Remove forbidden field(s) from search`, async () => {
	const db = vi.mocked(knex.default({ client: Client_SQLite3 }));
	const queryBuilder = db.queryBuilder();

	applySearch(db as any, schema, queryBuilder, 'directus', 'test', {}, [
		{
			collection: 'test',
			action: 'read',
			fields: ['string'],
			permissions: {
				text: {},
			},
		} as unknown as Permission,
	]);

	const rawQuery = queryBuilder.toSQL();

	expect(rawQuery.sql).toEqual(`select * where ((LOWER(""test"".""string"") LIKE ?))`);
	expect(rawQuery.bindings).toEqual(['%directus%']);
});

test(`Remove ""conceal"" field(s) from search irrespective of permissions`, async () => {
	const db = vi.mocked(knex.default({ client: Client_SQLite3 }));
	const queryBuilder = db.queryBuilder();

	applySearch(db as any, schema, queryBuilder, 'directus', 'test', {}, [
		{
			collection: 'test',
			action: 'read',
			fields: ['text', 'string', 'secret'],
			permissions: {
				text: {},
			},
		} as unknown as Permission,
	]);

	const rawQuery = queryBuilder.toSQL();

	expect(rawQuery.sql).toEqual(`select * where ((LOWER(""test"".""text"") LIKE ?) or (LOWER(""test"".""string"") LIKE ?))`);
	expect(rawQuery.bindings).toEqual(['%directus%', '%directus%']);
});

test(`Add all fields for * field rule`, async () => {
	const db = vi.mocked(knex.default({ client: Client_SQLite3 }));
	const queryBuilder = db.queryBuilder();

	applySearch(db as any, schema, queryBuilder, '1', 'test', {}, [
		{",0
"
	const allowedFields = new Set(permissions.filter((p) => p.collection === collection).flatMap((p) => p.fields ?? []));

	let fields = Object.entries(schema.collections[collection]!.fields);

	// filter out fields that are not searchable
	fields = fields.filter(([_name, field]) => field.searchable !== false && field.special.includes('conceal') !== true);

	const { cases, caseMap } = getCases(collection, permissions, []);

	// Add field restrictions if non-admin and ""everything"" is not allowed
	if (cases.length !== 0 && !allowedFields.has('*')) {
		fields = fields.filter((field) => allowedFields.has(field[0]));",0
"        nstack.push(evaluate(n1 ? n2 : n3, expr, values));
      } else {
        f = expr.ternaryOps[item.value];
        nstack.push(f(resolveExpression(n1, values), resolveExpression(n2, values), resolveExpression(n3, values)));
      }
    } else if (type === IVAR) {
      if (/^__proto__|prototype|constructor$/.test(item.value)) {
        throw new Error('prototype access detected');
      }
      if (item.value in expr.functions) {
        nstack.push(expr.functions[item.value]);
      } else if (item.value in expr.unaryOps && expr.parser.isOperatorEnabled(item.value)) {
        nstack.push(expr.unaryOps[item.value]);
      } else {
        var v = values[item.value];",0
"  return String.fromCharCode(
    ((c - 0x010000) >> 10) + 0xD800,
    ((c - 0x010000) & 0x03FF) + 0xDC00
  );
}

// set a property of a literal object, while protecting against prototype pollution,
// see https://github.com/nodeca/js-yaml/issues/164 for more details
function setProperty(object, key, value) {
  // used for this specific key only because Object.defineProperty is slow
  if (key === '__proto__') {
    Object.defineProperty(object, key, {
      configurable: true,
      enumerable: true,
      writable: true,
      value,
    });
  } else {
    object[key] = value;
  }
}

var simpleEscapeCheck = new Array(256); // integer, for fast access
var simpleEscapeMap = new Array(256);
for (var i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}


function State(input, options) {
  this.input = input;

  this.filename  = options['filename']  || null;
  this.schema    = options['schema']    || DEFAULT_SCHEMA;
  this.onWarning = options['onWarning'] || null;
  // (Hidden) Remove? makes the loader to expect YAML 1.1 documents
  // if such documents have no explicit %YAML directive
  this.legacy    = options['legacy']    || false;

  this.json      = options['json']      || false;
  this.listener  = options['listener']  || null;

  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap       = this.schema.compiledTypeMap;

  this.length     = input.length;
  this.position   = 0;
  this.line       = 0;
  this.lineStart  = 0;
  this.lineIndent = 0;

  // position of first leading tab in the current line,
  // used to make sure there are no tabs in the indentation
  this.firstTabInLine = -1;

  this.documents = [];

  /*
  this.version;
  this.checkLineBreaks;
  this.tagMap;
  this.anchorMap;
  this.tag;
  this.anchor;
  this.kind;
  this.result;*/

}


function generateError(state, message) {
  var mark = {
    name:     state.filename,
    buffer:   state.input.slice(0, -1), // omit trailing \0
    position: state.position,
    line:     state.line,
    column:   state.position - state.lineStart
  };

  mark.snippet = makeSnippet(mark);

  return new YAMLException(message, mark);
}

function throwError(state, message) {
  throw generateError(state, message);
}

function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}


var directiveHandlers = {

  YAML: function handleYamlDirective(state, name, args) {

    var match, major, minor;

    if (state.version !== null) {
      throwError(state, 'duplication of %YAML directive');
    }

    if (args.length !== 1) {
      throwError(state, 'YAML directive accepts exactly one argument');
    }

    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

    if (match === null) {
      throwError(state, 'ill-formed argument of the YAML directive');
    }

    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);

    if (major !== 1) {
      throwError(state, 'unacceptable YAML version of the document');
    }

    state.version = args[0];
    state.checkLineBreaks = (minor < 2);

    if (minor !== 1 && minor !== 2) {
      throwWarning(state, 'unsupported YAML version of the document');
    }
  },

  TAG: function handleTagDirective(state, name, args) {

    var handle, prefix;

    if (args.length !== 2) {
      throwError(state, 'TAG directive accepts exactly two arguments');
    }

    handle = args[0];
    prefix = args[1];

    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
    }

    if (_hasOwnProperty.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for ""' + handle + '"" tag handle');
    }

    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
    }

    try {
      prefix = decodeURIComponent(prefix);
    } catch (err) {
      throwError(state, 'tag prefix is malformed: ' + prefix);
    }

    state.tagMap[handle] = prefix;
  }
};


function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;

  if (start < end) {
    _result = state.input.slice(start, end);

    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 0x09 ||
              (0x20 <= _character && _character <= 0x10FFFF))) {
          throwError(state, 'expected valid JSON character');
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, 'the stream contains non-printable characters');
    }

    state.result += _result;
  }
}

function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;

  if (!common.isObject(source)) {
    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
  }

  sourceKeys = Object.keys(source);

  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];

    if (!_hasOwnProperty.call(destination, key)) {
      setProperty(destination, key, source[key]);
      overridableKeys[key] = true;
    }
  }
}

function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode,
  startLine, startLineStart, startPos) {

  var index, quantity;

  // The output is a plain object here, so keys can only be strings.
  // We need to convert keyNode to a string, but doing so can hang the process
  // (deeply nested arrays that explode exponentially using aliases).
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);

    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state, 'nested arrays are not supported inside keys');
      }

      if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {
        keyNode[index] = '[object Object]';
      }
    }
  }

  // Avoid code execution in load() via toString property
  // (still use its own toString for arrays, timestamps,
  // and whatever user schema extensions happen to have @@toStringTag)
  if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {
    keyNode = '[object Object]';
  }


  keyNode = String(keyNode);

  if (_result === null) {
    _result = {};
  }

  if (keyTag === 'tag:yaml.org,2002:merge') {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json &&
        !_hasOwnProperty.call(overridableKeys, keyNode) &&
        _hasOwnProperty.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.lineStart = startLineStart || state.lineStart;
      state.position = startPos || state.position;
      throwError(state, 'duplicated mapping key');
    }

    setProperty(_result, keyNode, valueNode);
    delete overridableKeys[keyNode];
  }

  return _result;
}
",0
"
const assert = require('assert');
const yaml = require('../../');


it('should define __proto__ as a value (not invoke setter)', function () {
  let object = yaml.load('{ __proto__: {polluted: bar} }');

  assert.strictEqual(({}).hasOwnProperty.call(yaml.load('{}'), '__proto__'), false);
  assert.strictEqual(({}).hasOwnProperty.call(object, '__proto__'), true);
  assert(!object.polluted);
});


it('should merge __proto__ as a value with << operator', function () {
  let object = yaml.load(`
payload: &ref
  polluted: bar

foo:
  <<:
    __proto__: *ref
  `);

  assert.strictEqual(({}).hasOwnProperty.call(yaml.load('{}'), '__proto__'), false);
  assert.strictEqual(({}).hasOwnProperty.call(object.foo, '__proto__'), true);
  assert(!object.foo.polluted);
});",0
"'use strict';

const Parse = require('parse/node');
const request = require('../lib/request');
const ParseServerRESTController = require('../lib/ParseServerRESTController').ParseServerRESTController;
const ParseServer = require('../lib/ParseServer').default;
const Deprecator = require('../lib/Deprecator/Deprecator').default;

const masterKeyHeaders = {
  'X-Parse-Application-Id': 'test',
  'X-Parse-Rest-API-Key': 'test',
  'X-Parse-Master-Key': 'test',
  'Content-Type': 'application/json',
};

const masterKeyOptions = {
  headers: masterKeyHeaders,
};

const BoxedNumber = Parse.Object.extend({
  className: 'BoxedNumber',
});

describe('Parse.Query testing', () => {
  it('basic query', function (done) {
    const baz = new TestObject({ foo: 'baz' });
    const qux = new TestObject({ foo: 'qux' });
    Parse.Object.saveAll([baz, qux]).then(function () {
      const query = new Parse.Query(TestObject);
      query.equalTo('foo', 'baz');
      query.find().then(function (results) {
        equal(results.length, 1);
        equal(results[0].get('foo'), 'baz');
        done();
      });
    });
  });

  it_only_db('mongo')('gracefully handles invalid explain values', async () => {
    // Note that anything that is not truthy (like 0) does not cause an exception, as they get swallowed up by ClassesRouter::optionsFromBody
    const values = [1, 'yolo', { a: 1 }, [1, 2, 3]];
    for (const value of values) {
      try {
        await request({
          method: 'GET',
          url: `http://localhost:8378/1/classes/_User?explain=${value}`,
          json: true,
          headers: masterKeyHeaders,
        });
        fail('request did not throw');
      } catch (e) {
        // Expect that Parse Server did not crash
        expect(e.code).not.toEqual('ECONNRESET');
        // Expect that Parse Server validates the explain value and does not crash;
        // see https://jira.mongodb.org/browse/NODE-3463
        equal(e.data.code, Parse.Error.INVALID_QUERY);
        equal(e.data.error, 'Invalid value for explain');
      }
      // get queries (of the form '/classes/:className/:objectId' cannot have the explain key, see ClassesRouter.js)
      // so it is enough that we test find queries
    }
  });

  it_only_db('mongo')('supports valid explain values', async () => {
    const values = [
      false,
      true,
      'queryPlanner',
      'executionStats',
      'allPlansExecution',
      // 'queryPlannerExtended' is excluded as it only applies to MongoDB Data Lake which is currently not available in our CI environment
    ];
    for (const value of values) {
      const response = await request({
        method: 'GET',
        url: `http://localhost:8378/1/classes/_User?explain=${value}`,
        json: true,
        headers: masterKeyHeaders,
      });
      expect(response.status).toBe(200);
      if (value) {
        expect(response.data.results.ok).toBe(1);
      }
    }
  });

  it('searching for null', function (done) {
    const baz = new TestObject({ foo: null });
    const qux = new TestObject({ foo: 'qux' });
    const qux2 = new TestObject({});
    Parse.Object.saveAll([baz, qux, qux2]).then(function () {
      const query = new Parse.Query(TestObject);
      query.equalTo('foo', null);
      query.find().then(function (results) {
        equal(results.length, 2);
        qux.set('foo', null);
        qux.save().then(function () {
          query.find().then(function (results) {
            equal(results.length, 3);
            done();
          });
        });
      });
    });
  });

  it('searching for not null', function (done) {
    const baz = new TestObject({ foo: null });
    const qux = new TestObject({ foo: 'qux' });
    const qux2 = new TestObject({});
    Parse.Object.saveAll([baz, qux, qux2]).then(function () {
      const query = new Parse.Query(TestObject);
      query.notEqualTo('foo', null);
      query.find().then(function (results) {
        equal(results.length, 1);
        qux.set('foo', null);
        qux.save().then(function () {
          query.find().then(function (results) {
            equal(results.length, 0);
            done();
          });
        });
      });
    });
  });

  it('notEqualTo with Relation is working', function (done) {
    const user = new Parse.User();
    user.setPassword('asdf');
    user.setUsername('zxcv');

    const user1 = new Parse.User();
    user1.setPassword('asdf');
    user1.setUsername('qwerty');

    const user2 = new Parse.User();
    user2.setPassword('asdf');
    user2.setUsername('asdf');

    const Cake = Parse.Object.extend('Cake');
    const cake1 = new Cake();
    const cake2 = new Cake();
    const cake3 = new Cake();

    user
      .signUp()
      .then(function () {
        return user1.signUp();
      })
      .then(function () {
        return user2.signUp();
      })
      .then(function () {
        const relLike1 = cake1.relation('liker');
        relLike1.add([user, user1]);

        const relDislike1 = cake1.relation('hater');
        relDislike1.add(user2);

        return cake1.save();
      })
      .then(function () {
        const rellike2 = cake2.relation('liker');
        rellike2.add([user, user1]);

        const relDislike2 = cake2.relation('hater');
        relDislike2.add(user2);

        const relSomething = cake2.relation('something');
        relSomething.add(user);

        return cake2.save();
      })
      .then(function () {
        const rellike3 = cake3.relation('liker');
        rellike3.add(user);

        const relDislike3 = cake3.relation('hater');
        relDislike3.add([user1, user2]);
        return cake3.save();
      })
      .then(function () {
        const query = new Parse.Query(Cake);
        // User2 likes nothing so we should receive 0
        query.equalTo('liker', user2);
        return query.find().then(function (results) {
          equal(results.length, 0);
        });
      })
      .then(function () {
        const query = new Parse.Query(Cake);
        // User1 likes two of three cakes
        query.equalTo('liker', user1);
        return query.find().then(function (results) {
          // It should return 2 -> cake 1 and cake 2
          equal(results.length, 2);
        });
      })
      .then(function () {
        const query = new Parse.Query(Cake);
        // We want to know which cake the user1 is not appreciating -> cake3
        query.notEqualTo('liker', user1);
        return query.find().then(function (results) {
          // Should return 1 -> the cake 3
          equal(results.length, 1);
        });
      })
      .then(function () {
        const query = new Parse.Query(Cake);
        // User2 is a hater of everything so we should receive 0
        query.notEqualTo('hater', user2);
        return query.find().then(function (results) {
          equal(results.length, 0);
        });
      })
      .then(function () {
        const query = new Parse.Query(Cake);
        // Only cake3 is liked by user
        query.notContainedIn('liker', [user1]);
        return query.find().then(function (results) {
          equal(results.length, 1);
        });
      })
      .then(function () {
        const query = new Parse.Query(Cake);
        // All the users
        query.containedIn('liker', [user, user1, user2]);
        // Exclude user 1
        query.notEqualTo('liker', user1);
        // Only cake3 is liked only by user1
        return query.find().then(function (results) {
          equal(results.length, 1);
          const cake = results[0];
          expect(cake.id).toBe(cake3.id);
        });
      })
      .then(function () {
        const query = new Parse.Query(Cake);
        // Exclude user1
        query.notEqualTo('liker', user1);
        // Only cake1
        query.equalTo('objectId', cake1.id);
        // user1 likes cake1 so this should return no results
        return query.find().then(function (results) {
          equal(results.length, 0);
        });
      })
      .then(function () {
        const query = new Parse.Query(Cake);
        query.notEqualTo('hater', user2);
        query.notEqualTo('liker', user2);
        // user2 doesn't like any cake so this should be 0
        return query.find().then(function (results) {
          equal(results.length, 0);
        });
      })
      .then(function () {
        const query = new Parse.Query(Cake);
        query.equalTo('hater', user);
        query.equalTo('liker', user);
        // user doesn't hate any cake so this should be 0
        return query.find().then(function (results) {
          equal(results.length, 0);
        });
      })
      .then(function () {
        const query = new Parse.Query(Cake);
        query.equalTo('hater', null);
        query.equalTo('liker', null);
        // user doesn't hate any cake so this should be 0
        return query.find().then(function (results) {
          equal(results.length, 0);
        });
      })
      .then(function () {
        const query = new Parse.Query(Cake);
        query.equalTo('something', null);
        // user doesn't hate any cake so this should be 0
        return query.find().then(function (results) {
          equal(results.length, 0);
        });
      })
      .then(function () {
        done();
      })
      .catch(err => {
        jfail(err);
        done();
      });
  });

  it('query notContainedIn on empty array', async () => {
    const object = new TestObject();
    object.set('value', 100);
    await object.save();

    const query = new Parse.Query(TestObject);
    query.notContainedIn('value', []);

    const results = await query.find();
    equal(results.length, 1);
  });

  it('query containedIn on empty array', async () => {
    const object = new TestObject();
    object.set('value', 100);
    await object.save();

    const query = new Parse.Query(TestObject);
    query.containedIn('value', []);

    const results = await query.find();
    equal(results.length, 0);
  });

  it('query without limit respects default limit', async () => {
    await reconfigureServer({ defaultLimit: 1 });
    const obj1 = new TestObject({ foo: 'baz' });
    const obj2 = new TestObject({ foo: 'qux' });
    await Parse.Object.saveAll([obj1, obj2]);
    const query = new Parse.Query(TestObject);
    const result = await query.find();
    expect(result.length).toBe(1);
  });

  it('query with limit', async () => {
    const obj1 = new TestObject({ foo: 'baz' });
    const obj2 = new TestObject({ foo: 'qux' });
    await Parse.Object.saveAll([obj1, obj2]);
    const query = new Parse.Query(TestObject);
    query.limit(1);
    const result = await query.find();
    expect(result.length).toBe(1);
  });

  it('query with limit overrides default limit', async () => {
    await reconfigureServer({ defaultLimit: 2 });
    const obj1 = new TestObject({ foo: 'baz' });
    const obj2 = new TestObject({ foo: 'qux' });
    await Parse.Object.saveAll([obj1, obj2]);
    const query = new Parse.Query(TestObject);
    query.limit(1);
    const result = await query.find();
    expect(result.length).toBe(1);
  });

  it('query with limit equal to maxlimit', async () => {
    await reconfigureServer({ maxLimit: 1 });
    const obj1 = new TestObject({ foo: 'baz' });
    const obj2 = new TestObject({ foo: 'qux' });
    await Parse.Object.saveAll([obj1, obj2]);
    const query = new Parse.Query(TestObject);
    query.limit(1);
    const result = await query.find();
    expect(result.length).toBe(1);
  });

  it('query with limit exceeding maxlimit', async () => {
    await reconfigureServer({ maxLimit: 1 });
    const obj1 = new TestObject({ foo: 'baz' });
    const obj2 = new TestObject({ foo: 'qux' });
    await Parse.Object.saveAll([obj1, obj2]);
    const query = new Parse.Query(TestObject);
    query.limit(2);
    const result = await query.find();
    expect(result.length).toBe(1);
  });

  it('containedIn object array queries', function (done) {
    const messageList = [];
    for (let i = 0; i < 4; ++i) {
      const message = new TestObject({});
      if (i > 0) {
        message.set('prior', messageList[i - 1]);
      }
      messageList.push(message);
    }

    Parse.Object.saveAll(messageList).then(
      function () {
        equal(messageList.length, 4);

        const inList = [];
        inList.push(messageList[0]);
        inList.push(messageList[2]);

        const query = new Parse.Query(TestObject);
        query.containedIn('prior', inList);
        query.find().then(
          function (results) {
            equal(results.length, 2);
            done();
          },
          function (e) {
            jfail(e);
            done();
          }
        );
      },
      e => {
        jfail(e);
        done();
      }
    );
  });

  it('containedIn null array', done => {
    const emails = ['contact@xyz.com', 'contact@zyx.com', null];
    const user = new Parse.User();
    user.setUsername(emails[0]);
    user.setPassword('asdf');
    user
      .signUp()
      .then(() => {
        const query = new Parse.Query(Parse.User);
        query.containedIn('username', emails);
        return query.find({ useMasterKey: true });
      })
      .then(results => {
        equal(results.length, 1);
        done();
      }, done.fail);
  });

  it('nested equalTo string with single quote', async () => {
    const obj = new TestObject({ nested: { foo: ""single'quote"" } });
    await obj.save();
    const query = new Parse.Query(TestObject);
    query.equalTo('nested.foo', ""single'quote"");
    const result = await query.get(obj.id);
    equal(result.get('nested').foo, ""single'quote"");
  });

  it('nested containedIn string with single quote', async () => {
    const obj = new TestObject({ nested: { foo: [""single'quote""] } });
    await obj.save();
    const query = new Parse.Query(TestObject);
    query.containedIn('nested.foo', [""single'quote""]);
    const result = await query.get(obj.id);
    equal(result.get('nested').foo[0], ""single'quote"");
  });

  it('nested containedIn string', done => {
    const sender1 = { group: ['A', 'B'] };
    const sender2 = { group: ['A', 'C'] };
    const sender3 = { group: ['B', 'C'] };
    const obj1 = new TestObject({ sender: sender1 });
    const obj2 = new TestObject({ sender: sender2 });
    const obj3 = new TestObject({ sender: sender3 });
    Parse.Object.saveAll([obj1, obj2, obj3])
      .then(() => {
        const query = new Parse.Query(TestObject);
        query.containedIn('sender.group', ['A']);
        return query.find();
      })
      .then(results => {
        equal(results.length, 2);
        done();
      }, done.fail);
  });

  it('nested containedIn number', done => {
    const sender1 = { group: [1, 2] };
    const sender2 = { group: [1, 3] };
    const sender3 = { group: [2, 3] };
    const obj1 = new TestObject({ sender: sender1 });
    const obj2 = new TestObject({ sender: sender2 });
    const obj3 = new TestObject({ sender: sender3 });
    Parse.Object.saveAll([obj1, obj2, obj3])
      .then(() => {
        const query = new Parse.Query(TestObject);
        query.containedIn('sender.group', [1]);
        return query.find();
      })
      .then(results => {
        equal(results.length, 2);
        done();
      }, done.fail);
  });

  it('containsAll number array queries', function (done) {
    const NumberSet = Parse.Object.extend({ className: 'NumberSet' });

    const objectsList = [];
    objectsList.push(new NumberSet({ numbers: [1, 2, 3, 4, 5] }));
    objectsList.push(new NumberSet({ numbers: [1, 3, 4, 5] }));

    Parse.Object.saveAll(objectsList)
      .then(function () {
        const query = new Parse.Query(NumberSet);
        query.containsAll('numbers', [1, 2, 3]);
        query.find().then(
          function (results) {
            equal(results.length, 1);
            done();
          },
          function (err) {
            jfail(err);
            done();
          }
        );
      })
      .catch(err => {
        jfail(err);
        done();
      });
  });

  it('containsAll string array queries', function (done) {
    const StringSet = Parse.Object.extend({ className: 'StringSet' });

    const objectsList = [];
    objectsList.push(new StringSet({ strings: ['a', 'b', 'c', 'd', 'e'] }));
    objectsList.push(new StringSet({ strings: ['a', 'c', 'd', 'e'] }));

    Parse.Object.saveAll(objectsList)
      .then(function () {
        const query = new Parse.Query(StringSet);
        query.containsAll('strings', ['a', 'b', 'c']);
        query.find().then(function (results) {
          equal(results.length, 1);
          done();
        });
      })
      .catch(err => {
        jfail(err);
        done();
      });
  });

  it('containsAll date array queries', function (done) {
    const DateSet = Parse.Object.extend({ className: 'DateSet' });

    function parseDate(iso8601) {
      const regexp = new RegExp(
        '^([0-9]{1,4})-([0-9]{1,2})-([0-9]{1,2})' +
          'T' +
          '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2})' +
          '(.([0-9]+))?' +
          'Z$'
      );
      const match = regexp.exec(iso8601);
      if (!match) {
        return null;
      }

      const year = match[1] || 0;
      const month = (match[2] || 1) - 1;
      const day = match[3] || 0;
      const hour = match[4] || 0;
      const minute = match[5] || 0;
      const second = match[6] || 0;
      const milli = match[8] || 0;

      return new Date(Date.UTC(year, month, day, hour, minute, second, milli));
    }

    const makeDates = function (stringArray) {
      return stringArray.map(function (dateStr) {
        return parseDate(dateStr + 'T00:00:00Z');
      });
    };

    const objectsList = [];
    objectsList.push(
      new DateSet({
        dates: makeDates(['2013-02-01', '2013-02-02', '2013-02-03', '2013-02-04']),
      })
    );
    objectsList.push(
      new DateSet({
        dates: makeDates(['2013-02-01', '2013-02-03', '2013-02-04']),
      })
    );

    Parse.Object.saveAll(objectsList).then(function () {
      const query = new Parse.Query(DateSet);
      query.containsAll('dates', makeDates(['2013-02-01', '2013-02-02', '2013-02-03']));
      query.find().then(
        function (results) {
          equal(results.length, 1);
          done();
        },
        function (e) {
          jfail(e);
          done();
        }
      );
    });
  });

  it_id('25bb35a6-e953-4d6d-a31c-66324d5ae076')(it)('containsAll object array queries', function (done) {
    const MessageSet = Parse.Object.extend({ className: 'MessageSet' });

    const messageList = [];
    for (let i = 0; i < 4; ++i) {
      messageList.push(new TestObject({ i: i }));
    }

    Parse.Object.saveAll(messageList).then(function () {
      equal(messageList.length, 4);

      const messageSetList = [];
      messageSetList.push(new MessageSet({ messages: messageList }));

      const someList = [];
      someList.push(messageList[0]);
      someList.push(messageList[1]);
      someList.push(messageList[3]);
      messageSetList.push(new MessageSet({ messages: someList }));

      Parse.Object.saveAll(messageSetList).then(function () {
        const inList = [];
        inList.push(messageList[0]);
        inList.push(messageList[2]);

        const query = new Parse.Query(MessageSet);
        query.containsAll('messages', inList);
        query.find().then(function (results) {
          equal(results.length, 1);
          done();
        });
      });
    });
  });

  it('containsAllStartingWith should match all strings that starts with string', done => {
    const object = new Parse.Object('Object');
    object.set('strings', ['the', 'brown', 'lazy', 'fox', 'jumps']);
    const object2 = new Parse.Object('Object');
    object2.set('strings', ['the', 'brown', 'fox', 'jumps']);
    const object3 = new Parse.Object('Object');
    object3.set('strings', ['over', 'the', 'lazy', 'dog']);

    const objectList = [object, object2, object3];

    Parse.Object.saveAll(objectList).then(results => {
      equal(objectList.length, results.length);

      return request({
        url: Parse.serverURL + '/classes/Object',
        qs: {
          where: JSON.stringify({
            strings: {
              $all: [{ $regex: '^\\Qthe\\E' }, { $regex: '^\\Qfox\\E' }, { $regex: '^\\Qlazy\\E' }],
            },
          }),
        },
        headers: {
          'X-Parse-Application-Id': Parse.applicationId,
          'X-Parse-Javascript-Key': Parse.javaScriptKey,
          'Content-Type': 'application/json',
        },
      })
        .then(function (response) {
          const results = response.data;
          equal(results.results.length, 1);
          arrayContains(results.results, object);

          return request({
            url: Parse.serverURL + '/classes/Object',
            qs: {
              where: JSON.stringify({
                strings: {
                  $all: [{ $regex: '^\\Qthe\\E' }, { $regex: '^\\Qlazy\\E' }],
                },
              }),
            },
            headers: {
              'X-Parse-Application-Id': Parse.applicationId,
              'X-Parse-Javascript-Key': Parse.javaScriptKey,
              'Content-Type': 'application/json',
            },
          });
        })
        .then(function (response) {
          const results = response.data;
          equal(results.results.length, 2);
          arrayContains(results.results, object);
          arrayContains(results.results, object3);

          return request({
            url: Parse.serverURL + '/classes/Object',
            qs: {
              where: JSON.stringify({
                strings: {
                  $all: [{ $regex: '^\\Qhe\\E' }, { $regex: '^\\Qlazy\\E' }],
                },
              }),
            },
            headers: {
              'X-Parse-Application-Id': Parse.applicationId,
              'X-Parse-Javascript-Key': Parse.javaScriptKey,
              'Content-Type': 'application/json',
            },
          });
        })
        .then(function (response) {
          const results = response.data;
          equal(results.results.length, 0);

          done();
        });
    });
  });

  it_id('3ea6ae04-bcc2-453d-8817-4c64d059c2f6')(it)('containsAllStartingWith values must be all of type starting with regex', done => {
    const object = new Parse.Object('Object');
    object.set('strings', ['the', 'brown', 'lazy', 'fox', 'jumps']);

    object
      .save()
      .then(() => {
        equal(object.isNew(), false);

        return request({
          url: Parse.serverURL + '/classes/Object',
          qs: {
            where: JSON.stringify({
              strings: {
                $all: [
                  { $regex: '^\\Qthe\\E' },
                  { $regex: '^\\Qlazy\\E' },
                  { $regex: '^\\Qfox\\E' },
                  { $unknown: /unknown/ },
                ],
              },
            }),
          },
          headers: {
            'X-Parse-Application-Id': Parse.applicationId,
            'X-Parse-Javascript-Key': Parse.javaScriptKey,
            'Content-Type': 'application/json',
          },
        });
      })
      .then(done.fail, function () {
        done();
      });
  });

  it('containsAllStartingWith empty array values should return empty results', done => {
    const object = new Parse.Object('Object');
    object.set('strings', ['the', 'brown', 'lazy', 'fox', 'jumps']);

    object
      .save()
      .then(() => {
        equal(object.isNew(), false);

        return request({
          url: Parse.serverURL + '/classes/Object',
          qs: {
            where: JSON.stringify({
              strings: {
                $all: [],
              },
            }),
          },
          headers: {
            'X-Parse-Application-Id': Parse.applicationId,
            'X-Parse-Javascript-Key': Parse.javaScriptKey,
            'Content-Type': 'application/json',
          },
        });
      })
      .then(
        function (response) {
          const results = response.data;
          equal(results.results.length, 0);
          done();
        },
        function () {}
      );
  });

  it('containsAllStartingWith single empty value returns empty results', done => {
    const object = new Parse.Object('Object');
    object.set('strings', ['the', 'brown', 'lazy', 'fox', 'jumps']);

    object
      .save()
      .then(() => {
        equal(object.isNew(), false);

        return request({
          url: Parse.serverURL + '/classes/Object',
          qs: {
            where: JSON.stringify({
              strings: {
                $all: [{}],
              },
            }),
          },
          headers: {
            'X-Parse-Application-Id': Parse.applicationId,
            'X-Parse-Javascript-Key': Parse.javaScriptKey,
            'Content-Type': 'application/json',
          },
        });
      })
      .then(
        function (response) {
          const results = response.data;
          equal(results.results.length, 0);
          done();
        },
        function () {}
      );
  });

  it('containsAllStartingWith single regex value should return corresponding matching results', done => {
    const object = new Parse.Object('Object');
    object.set('strings', ['the', 'brown', 'lazy', 'fox', 'jumps']);
    const object2 = new Parse.Object('Object');
    object2.set('strings', ['the', 'brown', 'fox', 'jumps']);
    const object3 = new Parse.Object('Object');
    object3.set('strings', ['over', 'the', 'lazy', 'dog']);

    const objectList = [object, object2, object3];

    Parse.Object.saveAll(objectList)
      .then(results => {
        equal(objectList.length, results.length);

        return request({
          url: Parse.serverURL + '/classes/Object',
          qs: {
            where: JSON.stringify({
              strings: {
                $all: [{ $regex: '^\\Qlazy\\E' }],
              },
            }),
          },
          headers: {
            'X-Parse-Application-Id': Parse.applicationId,
            'X-Parse-Javascript-Key': Parse.javaScriptKey,
            'Content-Type': 'application/json',
          },
        });
      })
      .then(
        function (response) {
          const results = response.data;
          equal(results.results.length, 2);
          done();
        },
        function () {}
      );
  });

  it('containsAllStartingWith single invalid regex returns empty results', done => {
    const object = new Parse.Object('Object');
    object.set('strings', ['the', 'brown', 'lazy', 'fox', 'jumps']);

    object
      .save()
      .then(() => {
        equal(object.isNew(), false);

        return request({
          url: Parse.serverURL + '/classes/Object',
          qs: {
            where: JSON.stringify({
              strings: {
                $all: [{ $unknown: '^\\Qlazy\\E' }],
              },
            }),
          },
          headers: {
            'X-Parse-Application-Id': Parse.applicationId,
            'X-Parse-Javascript-Key': Parse.javaScriptKey,
          },
        });
      })
      .then(
        function (response) {
          const results = response.data;
          equal(results.results.length, 0);
          done();
        },
        function () {}
      );
  });

  it_id('01a15195-dde2-4368-b996-d746a4ede3a1')(it)('containedBy pointer array', done => {
    const objects = Array.from(Array(10).keys()).map(idx => {
      const obj = new Parse.Object('Object');
      obj.set('key', idx);
      return obj;
    });

    const parent = new Parse.Object('Parent');
    const parent2 = new Parse.Object('Parent');
    const parent3 = new Parse.Object('Parent');

    Parse.Object.saveAll(objects)
      .then(() => {
        // [0, 1, 2]
        parent.set('objects', objects.slice(0, 3));

        const shift = objects.shift();
        // [2, 0]
        parent2.set('objects', [objects[1], shift]);

        // [1, 2, 3, 4]
        parent3.set('objects', objects.slice(1, 4));

        return Parse.Object.saveAll([parent, parent2, parent3]);
      })
      .then(() => {
        // [1, 2, 3, 4, 5, 6, 7, 8, 9]
        const pointers = objects.map(object => object.toPointer());

        // Return all Parent where all parent.objects are contained in objects
        return request({
          url: Parse.serverURL + '/classes/Parent',
          qs: {
            where: JSON.stringify({
              objects: {
                $containedBy: pointers,
              },
            }),
          },
          headers: {
            'X-Parse-Application-Id': Parse.applicationId,
            'X-Parse-Javascript-Key': Parse.javaScriptKey,
            'Content-Type': 'application/json',
          },
        });
      })
      .then(response => {
        const results = response.data;
        expect(results.results[0].objectId).not.toBeUndefined();
        expect(results.results[0].objectId).toBe(parent3.id);
        expect(results.results.length).toBe(1);
        done();
      });
  });

  it('containedBy number array', done => {
    const options = Object.assign({}, masterKeyOptions, {
      qs: {
        where: JSON.stringify({
          numbers: { $containedBy: [1, 2, 3, 4, 5, 6, 7, 8, 9] },
        }),
      },
    });
    const obj1 = new TestObject({ numbers: [0, 1, 2] });
    const obj2 = new TestObject({ numbers: [2, 0] });
    const obj3 = new TestObject({ numbers: [1, 2, 3, 4] });
    Parse.Object.saveAll([obj1, obj2, obj3])
      .then(() => {
        return request(Object.assign({ url: Parse.serverURL + '/classes/TestObject' }, options));
      })
      .then(response => {
        const results = response.data;
        expect(results.results[0].objectId).not.toBeUndefined();
        expect(results.results[0].objectId).toBe(obj3.id);
        expect(results.results.length).toBe(1);
        done();
      });
  });

  it('containedBy empty array', done => {
    const options = Object.assign({}, masterKeyOptions, {
      qs: {
        where: JSON.stringify({ numbers: { $containedBy: [] } }),
      },
    });
    const obj1 = new TestObject({ numbers: [0, 1, 2] });
    const obj2 = new TestObject({ numbers: [2, 0] });
    const obj3 = new TestObject({ numbers: [1, 2, 3, 4] });
    Parse.Object.saveAll([obj1, obj2, obj3])
      .then(() => {
        return request(Object.assign({ url: Parse.serverURL + '/classes/TestObject' }, options));
      })
      .then(response => {
        const results = response.data;
        expect(results.results.length).toBe(0);
        done();
      });
  });

  it('containedBy invalid query', done => {
    const options = Object.assign({}, masterKeyOptions, {
      qs: {
        where: JSON.stringify({ objects: { $containedBy: 1234 } }),
      },
    });
    const obj = new TestObject();
    obj
      .save()
      .then(() => {
        return request(Object.assign({ url: Parse.serverURL + '/classes/TestObject' }, options));
      })
      .then(done.fail)
      .catch(response => {
        equal(response.data.code, Parse.Error.INVALID_JSON);
        equal(response.data.error, 'bad $containedBy: should be an array');
        done();
      });
  });

  it('equalTo queries', function (done) {
    const makeBoxedNumber = function (i) {
      return new BoxedNumber({ number: i });
    };
    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {
      const query = new Parse.Query(BoxedNumber);
      query.equalTo('number', 3);
      query.find().then(function (results) {
        equal(results.length, 1);
        done();
      });
    });
  });

  it('equalTo undefined', function (done) {
    const makeBoxedNumber = function (i) {
      return new BoxedNumber({ number: i });
    };
    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {
      const query = new Parse.Query(BoxedNumber);
      query.equalTo('number', undefined);
      query.find().then(function (results) {
        equal(results.length, 0);
        done();
      });
    });
  });

  it('lessThan queries', function (done) {
    const makeBoxedNumber = function (i) {
      return new BoxedNumber({ number: i });
    };
    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {
      const query = new Parse.Query(BoxedNumber);
      query.lessThan('number', 7);
      query.find().then(function (results) {
        equal(results.length, 7);
        done();
      });
    });
  });

  it('lessThanOrEqualTo queries', function (done) {
    const makeBoxedNumber = function (i) {
      return new BoxedNumber({ number: i });
    };
    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {
      const query = new Parse.Query(BoxedNumber);
      query.lessThanOrEqualTo('number', 7);
      query.find().then(function (results) {
        equal(results.length, 8);
        done();
      });
    });
  });

  it('lessThan zero queries', done => {
    const makeBoxedNumber = i => {
      return new BoxedNumber({ number: i });
    };
    const numbers = [-3, -2, -1, 0, 1];
    const boxedNumbers = numbers.map(makeBoxedNumber);
    Parse.Object.saveAll(boxedNumbers)
      .then(() => {
        const query = new Parse.Query(BoxedNumber);
        query.lessThan('number', 0);
        return query.find();
      })
      .then(results => {
        equal(results.length, 3);
        done();
      });
  });

  it('lessThanOrEqualTo zero queries', done => {
    const makeBoxedNumber = i => {
      return new BoxedNumber({ number: i });
    };
    const numbers = [-3, -2, -1, 0, 1];
    const boxedNumbers = numbers.map(makeBoxedNumber);
    Parse.Object.saveAll(boxedNumbers)
      .then(() => {
        const query = new Parse.Query(BoxedNumber);
        query.lessThanOrEqualTo('number', 0);
        return query.find();
      })
      .then(results => {
        equal(results.length, 4);
        done();
      });
  });

  it('greaterThan queries', function (done) {
    const makeBoxedNumber = function (i) {
      return new BoxedNumber({ number: i });
    };
    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {
      const query = new Parse.Query(BoxedNumber);
      query.greaterThan('number', 7);
      query.find().then(function (results) {
        equal(results.length, 2);
        done();
      });
    });
  });

  it('greaterThanOrEqualTo queries', function (done) {
    const makeBoxedNumber = function (i) {
      return new BoxedNumber({ number: i });
    };
    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {
      const query = new Parse.Query(BoxedNumber);
      query.greaterThanOrEqualTo('number', 7);
      query.find().then(function (results) {
        equal(results.length, 3);
        done();
      });
    });
  });

  it('greaterThan zero queries', done => {
    const makeBoxedNumber = i => {
      return new BoxedNumber({ number: i });
    };
    const numbers = [-3, -2, -1, 0, 1];
    const boxedNumbers = numbers.map(makeBoxedNumber);
    Parse.Object.saveAll(boxedNumbers)
      .then(() => {
        const query = new Parse.Query(BoxedNumber);
        query.greaterThan('number', 0);
        return query.find();
      })
      .then(results => {
        equal(results.length, 1);
        done();
      });
  });

  it('greaterThanOrEqualTo zero queries', done => {
    const makeBoxedNumber = i => {
      return new BoxedNumber({ number: i });
    };
    const numbers = [-3, -2, -1, 0, 1];
    const boxedNumbers = numbers.map(makeBoxedNumber);
    Parse.Object.saveAll(boxedNumbers)
      .then(() => {
        const query = new Parse.Query(BoxedNumber);
        query.greaterThanOrEqualTo('number', 0);
        return query.find();
      })
      .then(results => {
        equal(results.length, 2);
        done();
      });
  });

  it('lessThanOrEqualTo greaterThanOrEqualTo queries', function (done) {
    const makeBoxedNumber = function (i) {
      return new BoxedNumber({ number: i });
    };
    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {
      const query = new Parse.Query(BoxedNumber);
      query.lessThanOrEqualTo('number', 7);
      query.greaterThanOrEqualTo('number', 7);
      query.find().then(function (results) {
        equal(results.length, 1);
        done();
      });
    });
  });

  it('lessThan greaterThan queries', function (done) {
    const makeBoxedNumber = function (i) {
      return new BoxedNumber({ number: i });
    };
    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {
      const query = new Parse.Query(BoxedNumber);
      query.lessThan('number', 9);
      query.greaterThan('number', 3);
      query.find().then(function (results) {
        equal(results.length, 5);
        done();
      });
    });
  });

  it('notEqualTo queries', function (done) {
    const makeBoxedNumber = function (i) {
      return new BoxedNumber({ number: i });
    };
    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {
      const query = new Parse.Query(BoxedNumber);
      query.notEqualTo('number', 5);
      query.find().then(function (results) {
        equal(results.length, 9);
        done();
      });
    });
  });

  it('notEqualTo zero queries', done => {
    const makeBoxedNumber = i => {
      return new BoxedNumber({ number: i });
    };
    const numbers = [-3, -2, -1, 0, 1];
    const boxedNumbers = numbers.map(makeBoxedNumber);
    Parse.Object.saveAll(boxedNumbers)
      .then(() => {
        const query = new Parse.Query(BoxedNumber);
        query.notEqualTo('number', 0);
        return query.find();
      })
      .then(results => {
        equal(results.length, 4);
        done();
      });
  });

  it('equalTo zero queries', done => {
    const makeBoxedNumber = i => {
      return new BoxedNumber({ number: i });
    };
    const numbers = [-3, -2, -1, 0, 1];
    const boxedNumbers = numbers.map(makeBoxedNumber);
    Parse.Object.saveAll(boxedNumbers)
      .then(() => {
        const query = new Parse.Query(BoxedNumber);
        query.equalTo('number', 0);
        return query.find();
      })
      .then(results => {
        equal(results.length, 1);
        done();
      });
  });

  it('number equalTo boolean queries', done => {
    const makeBoxedNumber = i => {
      return new BoxedNumber({ number: i });
    };
    const numbers = [-3, -2, -1, 0, 1];
    const boxedNumbers = numbers.map(makeBoxedNumber);
    Parse.Object.saveAll(boxedNumbers)
      .then(() => {
        const query = new Parse.Query(BoxedNumber);
        query.equalTo('number', false);
        return query.find();
      })
      .then(results => {
        equal(results.length, 0);
        done();
      });
  });

  it('equalTo false queries', done => {
    const obj1 = new TestObject({ field: false });
    const obj2 = new TestObject({ field: true });
    Parse.Object.saveAll([obj1, obj2])
      .then(() => {
        const query = new Parse.Query(TestObject);
        query.equalTo('field', false);
        return query.find();
      })
      .then(results => {
        equal(results.length, 1);
        done();
      });
  });

  it('where $eq false queries (rest)', done => {
    const options = Object.assign({}, masterKeyOptions, {
      qs: {
        where: JSON.stringify({ field: { $eq: false } }),
      },
    });
    const obj1 = new TestObject({ field: false });
    const obj2 = new TestObject({ field: true });
    Parse.Object.saveAll([obj1, obj2]).then(() => {
      request(Object.assign({ url: Parse.serverURL + '/classes/TestObject' }, options)).then(
        resp => {
          equal(resp.data.results.length, 1);
          done();
        }
      );
    });
  });

  it('where $eq null queries (rest)', done => {
    const options = Object.assign({}, masterKeyOptions, {
      qs: {
        where: JSON.stringify({ field: { $eq: null } }),
      },
    });
    const obj1 = new TestObject({ field: false });
    const obj2 = new TestObject({ field: null });
    Parse.Object.saveAll([obj1, obj2]).then(() => {
      return request(Object.assign({ url: Parse.serverURL + '/classes/TestObject' }, options)).then(
        resp => {
          equal(resp.data.results.length, 1);
          done();
        }
      );
    });
  });

  it('containedIn queries', function (done) {
    const makeBoxedNumber = function (i) {
      return new BoxedNumber({ number: i });
    };
    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {
      const query = new Parse.Query(BoxedNumber);
      query.containedIn('number', [3, 5, 7, 9, 11]);
      query.find().then(function (results) {
        equal(results.length, 4);
        done();
      });
    });
  });

  it('containedIn false queries', done => {
    const makeBoxedNumber = i => {
      return new BoxedNumber({ number: i });
    };
    const numbers = [-3, -2, -1, 0, 1];
    const boxedNumbers = numbers.map(makeBoxedNumber);
    Parse.Object.saveAll(boxedNumbers)
      .then(() => {
        const query = new Parse.Query(BoxedNumber);
        query.containedIn('number', false);
        return query.find();
      })
      .then(done.fail)
      .catch(error => {
        equal(error.code, Parse.Error.INVALID_JSON);
        equal(error.message, 'bad $in value');
        done();
      });
  });

  it('notContainedIn false queries', done => {
    const makeBoxedNumber = i => {
      return new BoxedNumber({ number: i });
    };
    const numbers = [-3, -2, -1, 0, 1];
    const boxedNumbers = numbers.map(makeBoxedNumber);
    Parse.Object.saveAll(boxedNumbers)
      .then(() => {
        const query = new Parse.Query(BoxedNumber);
        query.notContainedIn('number', false);
        return query.find();
      })
      .then(done.fail)
      .catch(error => {
        equal(error.code, Parse.Error.INVALID_JSON);
        equal(error.message, 'bad $nin value');
        done();
      });
  });

  it('notContainedIn queries', function (done) {
    const makeBoxedNumber = function (i) {
      return new BoxedNumber({ number: i });
    };
    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {
      const query = new Parse.Query(BoxedNumber);
      query.notContainedIn('number', [3, 5, 7, 9, 11]);
      query.find().then(function (results) {
        equal(results.length, 6);
        done();
      });
    });
  });

  it('objectId containedIn queries', function (done) {
    const makeBoxedNumber = function (i) {
      return new BoxedNumber({ number: i });
    };
    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function (list) {
      const query = new Parse.Query(BoxedNumber);
      query.containedIn('objectId', [list[2].id, list[3].id, list[0].id, 'NONSENSE']);
      query.ascending('number');
      query.find().then(function (results) {
        if (results.length != 3) {
          fail('expected 3 results');
        } else {
          equal(results[0].get('number'), 0);
          equal(results[1].get('number'), 2);
          equal(results[2].get('number'), 3);
        }
        done();
      });
    });
  });

  it('objectId equalTo queries', function (done) {
    const makeBoxedNumber = function (i) {
      return new BoxedNumber({ number: i });
    };
    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function (list) {
      const query = new Parse.Query(BoxedNumber);
      query.equalTo('objectId', list[4].id);
      query.find().then(function (results) {
        if (results.length != 1) {
          fail('expected 1 result');
          done();
        } else {
          equal(results[0].get('number'), 4);
        }
        done();
      });
    });
  });

  it('find no elements', function (done) {
    const makeBoxedNumber = function (i) {
      return new BoxedNumber({ number: i });
    };
    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {
      const query = new Parse.Query(BoxedNumber);
      query.equalTo('number', 17);
      query.find().then(function (results) {
        equal(results.length, 0);
        done();
      });
    });
  });

  it('find with error', function (done) {
    const query = new Parse.Query(BoxedNumber);
    query.equalTo('$foo', 'bar');
    query
      .find()
      .then(done.fail)
      .catch(error => expect(error.code).toBe(Parse.Error.INVALID_KEY_NAME))
      .then(done);
  });

  it('get', function (done) {
    Parse.Object.saveAll([new TestObject({ foo: 'bar' })]).then(function (items) {
      ok(items[0]);
      const objectId = items[0].id;
      const query = new Parse.Query(TestObject);
      query.get(objectId).then(function (result) {
        ok(result);
        equal(result.id, objectId);
        equal(result.get('foo'), 'bar');
        ok(result.createdAt instanceof Date);
        ok(result.updatedAt instanceof Date);
        done();
      });
    });
  });

  it('get undefined', function (done) {
    Parse.Object.saveAll([new TestObject({ foo: 'bar' })]).then(function (items) {
      ok(items[0]);
      const query = new Parse.Query(TestObject);
      query.get(undefined).then(fail, () => done());
    });
  });

  it('get error', function (done) {
    Parse.Object.saveAll([new TestObject({ foo: 'bar' })]).then(function (items) {
      ok(items[0]);
      const query = new Parse.Query(TestObject);
      query.get('InvalidObjectID').then(
        function () {
          ok(false, 'The get should have failed.');
          done();
        },
        function (error) {
          equal(error.code, Parse.Error.OBJECT_NOT_FOUND);
          done();
        }
      );
    });
  });

  it('first', function (done) {
    Parse.Object.saveAll([new TestObject({ foo: 'bar' })]).then(function () {
      const query = new Parse.Query(TestObject);
      query.equalTo('foo', 'bar');
      query.first().then(function (result) {
        equal(result.get('foo'), 'bar');
        done();
      });
    });
  });

  it('first no result', function (done) {
    Parse.Object.saveAll([new TestObject({ foo: 'bar' })]).then(function () {
      const query = new Parse.Query(TestObject);
      query.equalTo('foo', 'baz');
      query.first().then(function (result) {
        equal(result, undefined);
        done();
      });
    });
  });

  it('first with two results', function (done) {
    Parse.Object.saveAll([new TestObject({ foo: 'bar' }), new TestObject({ foo: 'bar' })]).then(
      function () {
        const query = new Parse.Query(TestObject);
        query.equalTo('foo', 'bar');
        query.first().then(function (result) {
          equal(result.get('foo'), 'bar');
          done();
        });
      }
    );
  });

  it('first with error', function (done) {
    const query = new Parse.Query(BoxedNumber);
    query.equalTo('$foo', 'bar');
    query
      .first()
      .then(done.fail)
      .catch(e => expect(e.code).toBe(Parse.Error.INVALID_KEY_NAME))
      .then(done);
  });

  const Container = Parse.Object.extend({
    className: 'Container',
  });

  it('notEqualTo object', function (done) {
    const item1 = new TestObject();
    const item2 = new TestObject();
    const container1 = new Container({ item: item1 });
    const container2 = new Container({ item: item2 });
    Parse.Object.saveAll([item1, item2, container1, container2]).then(function () {
      const query = new Parse.Query(Container);
      query.notEqualTo('item', item1);
      query.find().then(function (results) {
        equal(results.length, 1);
        done();
      });
    });
  });

  it('skip', function (done) {
    Parse.Object.saveAll([new TestObject(), new TestObject()]).then(function () {
      const query = new Parse.Query(TestObject);
      query.skip(1);
      query.find().then(function (results) {
        equal(results.length, 1);
        query.skip(3);
        query.find().then(function (results) {
          equal(results.length, 0);
          done();
        });
      });
    });
  });

  it(""skip doesn't affect count"", function (done) {
    Parse.Object.saveAll([new TestObject(), new TestObject()]).then(function () {
      const query = new Parse.Query(TestObject);
      query.count().then(function (count) {
        equal(count, 2);
        query.skip(1);
        query.count().then(function (count) {
          equal(count, 2);
          query.skip(3);
          query.count().then(function (count) {
            equal(count, 2);
            done();
          });
        });
      });
    });
  });

  it('count', function (done) {
    const makeBoxedNumber = function (i) {
      return new BoxedNumber({ number: i });
    };
    Parse.Object.saveAll([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(makeBoxedNumber)).then(function () {
      const query = new Parse.Query(BoxedNumber);
      query.greaterThan('number', 1);
      query.count().then(function (count) {
        equal(count, 8);
        done();
      });
    });
  });

  it('order by ascending number', function (done) {
    const makeBoxedNumber = function (i) {
      return new BoxedNumber({ number: i });
    };
    Parse.Object.saveAll([3, 1, 2].map(makeBoxedNumber)).then(function () {
      const query = new Parse.Query(BoxedNumber);
      query.ascending('number');
      query.find().then(function (results) {
        equal(results.length, 3);
        equal(results[0].get('number'), 1);
        equal(results[1].get('number'), 2);
        equal(results[2].get('number'), 3);
        done();
      });
    });
  });

  it('order by descending number', function (done) {
    const makeBoxedNumber = function (i) {
      return new BoxedNumber({ number: i });
    };
    Parse.Object.saveAll([3, 1, 2].map(makeBoxedNumber)).then(function () {
      const query = new Parse.Query(BoxedNumber);
      query.descending('number');
      query.find().then(function (results) {
        equal(results.length, 3);
        equal(results[0].get('number'), 3);
        equal(results[1].get('number'), 2);
        equal(results[2].get('number'), 1);
        done();
      });
    });
  });

  it('can order on an object string field', function (done) {
    const testSet = [
      { sortField: { value: 'Z' } },
      { sortField: { value: 'A' } },
      { sortField: { value: 'M' } },
    ];

    const objects = testSet.map(e => new Parse.Object('Test', e));
    Parse.Object.saveAll(objects)
      .then(() => new Parse.Query('Test').addDescending('sortField.value').first())
      .then(result => {
        expect(result.get('sortField').value).toBe('Z');
        return new Parse.Query('Test').addAscending('sortField.value').first();
      })
      .then(result => {
        expect(result.get('sortField').value).toBe('A');
        done();
      })
      .catch(done.fail);
  });

  it('can order on an object string field (level 2)', function (done) {
    const testSet = [
      { sortField: { value: { field: 'Z' } } },
      { sortField: { value: { field: 'A' } } },
      { sortField: { value: { field: 'M' } } },
    ];

    const objects = testSet.map(e => new Parse.Object('Test', e));
    Parse.Object.saveAll(objects)
      .then(() => new Parse.Query('Test').addDescending('sortField.value.field').first())
      .then(result => {
        expect(result.get('sortField').value.field).toBe('Z');
        return new Parse.Query('Test').addAscending('sortField.value.field').first();
      })
      .then(result => {
        expect(result.get('sortField').value.field).toBe('A');
        done();
      })
      .catch(done.fail);
  });

  it_id('65c8238d-cf02-49d0-a919-8a17f5a58280')(it)('can order on an object number field', function (done) {
    const testSet = [
      { sortField: { value: 10 } },
      { sortField: { value: 1 } },
      { sortField: { value: 5 } },
    ];

    const objects = testSet.map(e => new Parse.Object('Test', e));
    Parse.Object.saveAll(objects)
      .then(() => new Parse.Query('Test').addDescending('sortField.value').first())
      .then(result => {
        expect(result.get('sortField').value).toBe(10);
        return new Parse.Query('Test').addAscending('sortField.value').first();
      })
      .then(result => {
        expect(result.get('sortField').value).toBe(1);
        done();
      })
      .catch(done.fail);
  });

  it_id('d8f0bead-b931-4d66-8b0c-28c5705e463c')(it)('can order on an object number field (level 2)', function (done) {
    const testSet = [
      { sortField: { value: { field: 10 } } },
      { sortField: { value: { field: 1 } } },
      { sortField: { value: { field: 5 } } },
    ];

    const objects = testSet.map(e => new Parse.Object('Test', e));
    Parse.Object.saveAll(objects)
      .then(() => new Parse.Query('Test').addDescending('sortField.value.field').first())
      .then(result => {
        expect(result.get('sortField').value.field).toBe(10);
        return new Parse.Query('Test').addAscending('sortField.value.field').first();
      })
      .then(result => {
        expect(result.get('sortField').value.field).toBe(1);
        done();
      })
      .catch(done.fail);
  });

  it('order by ascending number then descending string', function (done) {
    const strings = ['a', 'b', 'c', 'd'];
    const makeBoxedNumber = function (num, i) {
      return new BoxedNumber({ number: num, string: strings[i] });
    };
    Parse.Object.saveAll([3, 1, 3, 2].map(makeBoxedNumber)).then(function () {
      const query = new Parse.Query(BoxedNumber);
      query.ascending('number').addDescending('string');
      query.find().then(function (results) {
        equal(results.length, 4);
        equal(results[0].get('number'), 1);
        equal(results[0].get('string'), 'b');
        equal(results[1].get('number'), 2);
        equal(results[1].get('string'), 'd');
        equal(results[2].get('number'), 3);
        equal(results[2].get('string'), 'c');
        equal(results[3].get('number'), 3);
        equal(results[3].get('string'), 'a');
        done();
      });
    });
  });

  it('order by non-existing string', async () => {
    const strings = ['a', 'b', 'c', 'd'];
    const makeBoxedNumber = function (num, i) {
      return new BoxedNumber({ number: num, string: strings[i] });
    };
    await Parse.Object.saveAll([3, 1, 3, 2].map(makeBoxedNumber));
    const results = await new Parse.Query(BoxedNumber).ascending('foo').find();
    expect(results.length).toBe(4);
  });

  it('order by descending number then ascending string', function (done) {
    const strings = ['a', 'b', 'c', 'd'];
    const makeBoxedNumber = function (num, i) {
      return new BoxedNumber({ number: num, string: strings[i] });
    };

    const objects = [3, 1, 3, 2].map(makeBoxedNumber);
    Parse.Object.saveAll(objects)
      .then(() => {
        const query = new Parse.Query(BoxedNumber);
        query.descending('number').addAscending('string');
        return query.find();
      })
      .then(
        results => {
          equal(results.length, 4);
          equal(results[0].get('number'), 3);
          equal(results[0].get('string'), 'a');
          equal(results[1].get('number'), 3);
          equal(results[1].get('string'), 'c');
          equal(results[2].get('number'), 2);
          equal(results[2].get('string'), 'd');
          equal(results[3].get('number'), 1);
          equal(results[3].get('string'), 'b');
          done();
        },
        err => {
          jfail(err);
          done();
        }
      );
  });

  it('order by descending number and string', function (done) {
    const strings = ['a', 'b', 'c', 'd'];
    const makeBoxedNumber = function (num, i) {
      return new BoxedNumber({ number: num, string: strings[i] });
    };
    Parse.Object.saveAll([3, 1, 3, 2].map(makeBoxedNumber)).then(function () {
      const query = new Parse.Query(BoxedNumber);
      query.descending('number,string');
      query.find().then(function (results) {
        equal(results.length, 4);
        equal(results[0].get('number'), 3);
        equal(results[0].get('string'), 'c');
        equal(results[1].get('number'), 3);
        equal(results[1].get('string'), 'a');
        equal(results[2].get('number'), 2);
        equal(results[2].get('string'), 'd');
        equal(results[3].get('number'), 1);
        equal(results[3].get('string'), 'b');
        done();
      });
    });
  });

  it('order by descending number and string, with space', function (done) {
    const strings = ['a', 'b', 'c', 'd'];
    const makeBoxedNumber = function (num, i) {
      return new BoxedNumber({ number: num, string: strings[i] });
    };
    Parse.Object.saveAll([3, 1, 3, 2].map(makeBoxedNumber)).then(
      function () {
        const query = new Parse.Query(BoxedNumber);
        query.descending('number, string');
        query.find().then(function (results) {
          equal(results.length, 4);
          equal(results[0].get('number'), 3);
          equal(results[0].get('string'), 'c');
          equal(results[1].get('number'), 3);
          equal(results[1].get('string'), 'a');
          equal(results[2].get('number'), 2);
          equal(results[2].get('string'), 'd');
          equal(results[3].get('number'), 1);
          equal(results[3].get('string'), 'b');
          done();
        });
      },
      err => {
        jfail(err);
        done();
      }
    );
  });

  it('order by descending number and string, with array arg', function (done) {
    const strings = ['a', 'b', 'c', 'd'];
    const makeBoxedNumber = function (num, i) {
      return new BoxedNumber({ number: num, string: strings[i] });
    };
    Parse.Object.saveAll([3, 1, 3, 2].map(makeBoxedNumber)).then(function () {
      const query = new Parse.Query(BoxedNumber);
      query.descending(['number', 'string']);
      query.find().then(function (results) {
        equal(results.length, 4);
        equal(results[0].get('number'), 3);
        equal(results[0].get('string'), 'c');
        equal(results[1].get('number'), 3);
        equal(results[1].get('string'), 'a');
        equal(results[2].get('number'), 2);
        equal(results[2].get('string'), 'd');
        equal(results[3].get('number'), 1);
        equal(results[3].get('string'), 'b');
        done();
      });
    });
  });

  it('order by descending number and string, with multiple args', function (done) {
    const strings = ['a', 'b', 'c', 'd'];
    const makeBoxedNumber = function (num, i) {
      return new BoxedNumber({ number: num, string: strings[i] });
    };
    Parse.Object.saveAll([3, 1, 3, 2].map(makeBoxedNumber)).then(function () {
      const query = new Parse.Query(BoxedNumber);
      query.descending('number', 'string');
      query.find().then(function (results) {
        equal(results.length, 4);
        equal(results[0].get('number'), 3);
        equal(results[0].get('string'), 'c');
        equal(results[1].get('number'), 3);
        equal(results[1].get('string'), 'a');
        equal(results[2].get('number'), 2);
        equal(results[2].get('string'), 'd');
        equal(results[3].get('number'), 1);
        equal(results[3].get('string'), 'b');
        done();
      });
    });
  });

  it(""can't order by password"", function (done) {
    const makeBoxedNumber = function (i) {
      return new BoxedNumber({ number: i });
    };
    Parse.Object.saveAll([3, 1, 2].map(makeBoxedNumber)).then(function () {
      const query = new Parse.Query(BoxedNumber);
      query.ascending('_password');
      query
        .find()
        .then(done.fail)
        .catch(e => expect(e.code).toBe(Parse.Error.INVALID_KEY_NAME))
        .then(done);
    });
  });

  it('order by _created_at', function (done) {
    const makeBoxedNumber = function (i) {
      return new BoxedNumber({ number: i });
    };
    const numbers = [3, 1, 2].map(makeBoxedNumber);
    numbers[0]
      .save()
      .then(() => {
        return numbers[1].save();
      })
      .then(() => {
        return numbers[2].save();
      })
      .then(function () {
        const query = new Parse.Query(BoxedNumber);
        query.ascending('_created_at');
        query.find().then(function (results) {
          equal(results.length, 3);
          equal(results[0].get('number'), 3);
          equal(results[1].get('number'), 1);
          equal(results[2].get('number'), 2);
          done();
        }, done.fail);
      });
  });

  it('order by createdAt', function (done) {
    const makeBoxedNumber = function (i) {
      return new BoxedNumber({ number: i });
    };
    const numbers = [3, 1, 2].map(makeBoxedNumber);
    numbers[0]
      .save()
      .then(() => {
        return numbers[1].save();
      })
      .then(() => {
        return numbers[2].save();
      })
      .then(function () {
        const query = new Parse.Query(BoxedNumber);
        query.descending('createdAt');
        query.find().then(function (results) {
          equal(results.length, 3);
          equal(results[0].get('number'), 2);
          equal(results[1].get('number'), 1);
          equal(results[2].get('number'), 3);
          done();
        });
      });
  });

  it('order by _updated_at', function (done) {
    const makeBoxedNumber = function (i) {
      return new BoxedNumber({ number: i });
    };
    const numbers = [3, 1, 2].map(makeBoxedNumber);
    numbers[0]
      .save()
      .then(() => {
        return numbers[1].save();
      })
      .then(() => {
        return numbers[2].save();
      })
      .then(function () {
        numbers[1].set('number', 4);
        numbers[1].save().then(function () {
          const query = new Parse.Query(BoxedNumber);
          query.ascending('_updated_at');
          query.find().then(function (results) {
            equal(results.length, 3);
            equal(results[0].get('number'), 3);
            equal(results[1].get('number'), 2);
            equal(results[2].get('number'), 4);
            done();
          });
        });
      });
  });

  it('order by updatedAt', function (done) {
    const makeBoxedNumber = function (i) {
      return new BoxedNumber({ number: i });
    };
    const numbers = [3, 1, 2].map(makeBoxedNumber);
    numbers[0]
      .save()
      .then(() => {
        return numbers[1].save();
      })
      .then(() => {
        return numbers[2].save();
      })
      .then(function () {
        numbers[1].set('number', 4);
        numbers[1].save().then(function () {
          const query = new Parse.Query(BoxedNumber);
          query.descending('_updated_at');
          query.find().then(function (results) {
            equal(results.length, 3);
            equal(results[0].get('number'), 4);
            equal(results[1].get('number'), 2);
            equal(results[2].get('number'), 3);
            done();
          });
        });
      });
  });

  // Returns a promise
  function makeTimeObject(start, i) {
    const time = new Date();
    time.setSeconds(start.getSeconds() + i);
    const item = new TestObject({ name: 'item' + i, time: time });
    return item.save();
  }

  // Returns a promise for all the time objects
  function makeThreeTimeObjects() {
    const start = new Date();
    let one, two, three;
    return makeTimeObject(start, 1)
      .then(o1 => {
        one = o1;
        return makeTimeObject(start, 2);
      })
      .then(o2 => {
        two = o2;
        return makeTimeObject(start, 3);
      })
      .then(o3 => {
        three = o3;
        return [one, two, three];
      });
  }

  it('time equality', function (done) {
    makeThreeTimeObjects().then(function (list) {
      const query = new Parse.Query(TestObject);
      query.equalTo('time', list[1].get('time'));
      query.find().then(function (results) {
        equal(results.length, 1);
        equal(results[0].get('name'), 'item2');
        done();
      });
    });
  });

  it('time lessThan', function (done) {
    makeThreeTimeObjects().then(function (list) {
      const query = new Parse.Query(TestObject);
      query.lessThan('time', list[2].get('time'));
      query.find().then(function (results) {
        equal(results.length, 2);
        done();
      });
    });
  });

  // This test requires Date objects to be consistently stored as a Date.
  it('time createdAt', function (done) {
    makeThreeTimeObjects().then(function (list) {
      const query = new Parse.Query(TestObject);
      query.greaterThanOrEqualTo('createdAt', list[0].createdAt);
      query.find().then(function (results) {
        equal(results.length, 3);
        done();
      });
    });
  });

  it('matches string', function (done) {
    const thing1 = new TestObject();
    thing1.set('myString', 'football');
    const thing2 = new TestObject();
    thing2.set('myString', 'soccer');
    Parse.Object.saveAll([thing1, thing2]).then(function () {
      const query = new Parse.Query(TestObject);
      query.matches('myString', '^fo*\\wb[^o]l+$');
      query.find().then(function (results) {
        equal(results.length, 1);
        done();
      });
    });
  });

  it('matches regex', function (done) {
    const thing1 = new TestObject();
    thing1.set('myString', 'football');
    const thing2 = new TestObject();
    thing2.set('myString', 'soccer');
    Parse.Object.saveAll([thing1, thing2]).then(function () {
      const query = new Parse.Query(TestObject);
      query.matches('myString', /^fo*\wb[^o]l+$/);
      query.find().then(function (results) {
        equal(results.length, 1);
        done();
      });
    });
  });

  it('case insensitive regex success', function (done) {
    const thing = new TestObject();
    thing.set('myString', 'football');
    Parse.Object.saveAll([thing]).then(function () {
      const query = new Parse.Query(TestObject);
      query.matches('myString', 'FootBall', 'i');
      query.find().then(done);
    });
  });

  it('regexes with invalid options fail', function (done) {
    const query = new Parse.Query(TestObject);
    query.matches('myString', 'FootBall', 'some invalid option');
    query
      .find()
      .then(done.fail)
      .catch(e => expect(e.code).toBe(Parse.Error.INVALID_QUERY))
      .then(done);
  });

  it_id('351f57a8-e00a-4da2-887d-6e25c9e359fc')(it)('regex with unicode option', async function () {
    const thing = new TestObject();
    thing.set('myString', 'hello 世界');
    await Parse.Object.saveAll([thing]);
    const query = new Parse.Query(TestObject);
    query.matches('myString', '世界', 'u');
    const results = await query.find();
    equal(results.length, 1);
  });

  it_id('823852f6-1de5-45ba-a2b9-ed952fcc6012')(it)('Use a regex that requires all modifiers', function (done) {
    const thing = new TestObject();
    thing.set('myString', 'PArSe\nCom');
    Parse.Object.saveAll([thing]).then(function () {
      const query = new Parse.Query(TestObject);
      query.matches(
        'myString',
        ""parse # First fragment. We'll write this in one case but match insensitively\n"" +
          '.com  # Second fragment. This can be separated by any character, including newline;' +
          'however, this comment must end with a newline to recognize it as a comment\n',
        'mixs'
      );
      query.find().then(
        function (results) {
          equal(results.length, 1);
          done();
        },
        function (err) {
          jfail(err);
          done();
        }
      );
    });
  });

  it('Regular expression constructor includes modifiers inline', function (done) {
    const thing = new TestObject();
    thing.set('myString', '\n\nbuffer\n\nparse.COM');
    Parse.Object.saveAll([thing]).then(function () {
      const query = new Parse.Query(TestObject);
      query.matches('myString', /parse\.com/im);
      query.find().then(function (results) {
        equal(results.length, 1);
        done();
      });
    });
  });

  const someAscii =
    ""\\E' !\""#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTU"" +
    ""VWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~'"";

  it('contains', function (done) {
    Parse.Object.saveAll([
      new TestObject({ myString: 'zax' + someAscii + 'qub' }),
      new TestObject({ myString: 'start' + someAscii }),
      new TestObject({ myString: someAscii + 'end' }),
      new TestObject({ myString: someAscii }),
    ]).then(function () {
      const query = new Parse.Query(TestObject);
      query.contains('myString', someAscii);
      query.find().then(function (results) {
        equal(results.length, 4);
        done();
      });
    });
  });

  it('nested contains', done => {
    const sender1 = { group: ['A', 'B'] };
    const sender2 = { group: ['A', 'C'] };
    const sender3 = { group: ['B', 'C'] };
    const obj1 = new TestObject({ sender: sender1 });
    const obj2 = new TestObject({ sender: sender2 });
    const obj3 = new TestObject({ sender: sender3 });
    Parse.Object.saveAll([obj1, obj2, obj3])
      .then(() => {
        const query = new Parse.Query(TestObject);
        query.contains('sender.group', 'A');
        return query.find();
      })
      .then(results => {
        equal(results.length, 2);
        done();
      }, done.fail);
  });

  it('startsWith', function (done) {
    Parse.Object.saveAll([
      new TestObject({ myString: 'zax' + someAscii + 'qub' }),
      new TestObject({ myString: 'start' + someAscii }),
      new TestObject({ myString: someAscii + 'end' }),
      new TestObject({ myString: someAscii }),
    ]).then(function () {
      const query = new Parse.Query(TestObject);
      query.startsWith('myString', someAscii);
      query.find().then(function (results) {
        equal(results.length, 2);
        done();
      });
    });
  });

  it('endsWith', function (done) {
    Parse.Object.saveAll([
      new TestObject({ myString: 'zax' + someAscii + 'qub' }),
      new TestObject({ myString: 'start' + someAscii }),
      new TestObject({ myString: someAscii + 'end' }),
      new TestObject({ myString: someAscii }),
    ]).then(function () {
      const query = new Parse.Query(TestObject);
      query.endsWith('myString', someAscii);
      query.find().then(function (results) {
        equal(results.length, 2);
        done();
      });
    });
  });

  it('exists', function (done) {
    const objects = [];
    for (const i of [0, 1, 2, 3, 4, 5, 6, 7, 8]) {
      const item = new TestObject();
      if (i % 2 === 0) {
        item.set('x', i + 1);
      } else {
        item.set('y', i + 1);
      }
      objects.push(item);
    }
    Parse.Object.saveAll(objects).then(function () {
      const query = new Parse.Query(TestObject);
      query.exists('x');
      query.find().then(function (results) {
        equal(results.length, 5);
        for (const result of results) {
          ok(result.get('x'));
        }
        done();
      });
    });
  });

  it('doesNotExist', function (done) {
    const objects = [];
    for (const i of [0, 1, 2, 3, 4, 5, 6, 7, 8]) {
      const item = new TestObject();
      if (i % 2 === 0) {
        item.set('x', i + 1);
      } else {
        item.set('y', i + 1);
      }
      objects.push(item);
    }
    Parse.Object.saveAll(objects).then(function () {
      const query = new Parse.Query(TestObject);
      query.doesNotExist('x');
      query.find().then(function (results) {
        equal(results.length, 4);
        for (const result of results) {
          ok(result.get('y'));
        }
        done();
      });
    });
  });

  it('exists relation', function (done) {
    const objects = [];
    for (const i of [0, 1, 2, 3, 4, 5, 6, 7, 8]) {
      const container = new Container();
      if (i % 2 === 0) {
        const item = new TestObject();
        item.set('x', i);
        container.set('x', item);
        objects.push(item);
      } else {
        container.set('y', i);
      }
      objects.push(container);
    }
    Parse.Object.saveAll(objects).then(function () {
      const query = new Parse.Query(Container);
      query.exists('x');
      query.find().then(function (results) {
        equal(results.length, 5);
        for (const result of results) {
          ok(result.get('x'));
        }
        done();
      });
    });
  });

  it('doesNotExist relation', function (done) {
    const objects = [];
    for (const i of [0, 1, 2, 3, 4, 5, 6, 7]) {
      const container = new Container();
      if (i % 2 === 0) {
        const item = new TestObject();
        item.set('x', i);
        container.set('x', item);
        objects.push(item);
      } else {
        container.set('y', i);
      }
      objects.push(container);
    }
    Parse.Object.saveAll(objects).then(function () {
      const query = new Parse.Query(Container);
      query.doesNotExist('x');
      query.find().then(function (results) {
        equal(results.length, 4);
        for (const result of results) {
          ok(result.get('y'));
        }
        done();
      });
    });
  });

  it(""don't include by default"", function (done) {
    const child = new TestObject();
    const parent = new Container();
    child.set('foo', 'bar');
    parent.set('child', child);
    Parse.Object.saveAll([child, parent]).then(function () {
      child._clearServerData();
      const query = new Parse.Query(Container);
      query.find().then(function (results) {
        equal(results.length, 1);
        const parentAgain = results[0];
        const goodURL = Parse.serverURL;
        Parse.serverURL = 'YAAAAAAAAARRRRRGGGGGGGGG';
        const childAgain = parentAgain.get('child');
        ok(childAgain);
        equal(childAgain.get('foo'), undefined);
        Parse.serverURL = goodURL;
        done();
      });
    });
  });

  it('include relation', function (done) {
    const child = new TestObject();
    const parent = new Container();
    child.set('foo', 'bar');
    parent.set('child', child);
    Parse.Object.saveAll([child, parent]).then(function () {
      const query = new Parse.Query(Container);
      query.include('child');
      query.find().then(function (results) {
        equal(results.length, 1);
        const parentAgain = results[0];
        const goodURL = Parse.serverURL;
        Parse.serverURL = 'YAAAAAAAAARRRRRGGGGGGGGG';
        const childAgain = parentAgain.get('child');
        ok(childAgain);
        equal(childAgain.get('foo'), 'bar');
        Parse.serverURL = goodURL;
        done();
      });
    });
  });

  it('include relation array', function (done) {
    const child = new TestObject();
    const parent = new Container();
    child.set('foo', 'bar');
    parent.set('child', child);
    Parse.Object.saveAll([child, parent]).then(function () {
      const query = new Parse.Query(Container);
      query.include(['child']);
      query.find().then(function (results) {
        equal(results.length, 1);
        const parentAgain = results[0];
        const goodURL = Parse.serverURL;
        Parse.serverURL = 'YAAAAAAAAARRRRRGGGGGGGGG';
        const childAgain = parentAgain.get('child');
        ok(childAgain);
        equal(childAgain.get('foo'), 'bar');
        Parse.serverURL = goodURL;
        done();
      });
    });
  });

  it('nested include', function (done) {
    const Child = Parse.Object.extend('Child');
    const Parent = Parse.Object.extend('Parent');
    const Grandparent = Parse.Object.extend('Grandparent');
    const objects = [];
    for (let i = 0; i < 5; ++i) {
      const grandparent = new Grandparent({
        z: i,
        parent: new Parent({
          y: i,
          child: new Child({
            x: i,
          }),
        }),
      });
      objects.push(grandparent);
    }

    Parse.Object.saveAll(objects).then(function () {
      const query = new Parse.Query(Grandparent);
      query.include(['parent.child']);
      query.find().then(function (results) {
        equal(results.length, 5);
        for (const object of results) {
          equal(object.get('z'), object.get('parent').get('y'));
          equal(object.get('z'), object.get('parent').get('child').get('x'));
        }
        done();
      });
    });
  });

  it(""include doesn't make dirty wrong"", function (done) {
    const Parent = Parse.Object.extend('ParentObject');
    const Child = Parse.Object.extend('ChildObject');
    const parent = new Parent();
    const child = new Child();
    child.set('foo', 'bar');
    parent.set('child', child);

    Parse.Object.saveAll([child, parent]).then(function () {
      const query = new Parse.Query(Parent);
      query.include('child');
      query.find().then(function (results) {
        equal(results.length, 1);
        const parentAgain = results[0];
        const childAgain = parentAgain.get('child');
        equal(childAgain.id, child.id);
        equal(parentAgain.id, parent.id);
        equal(childAgain.get('foo'), 'bar');
        equal(false, parentAgain.dirty());
        equal(false, childAgain.dirty());
        done();
      });
    });
  });

  it('properly includes array', done => {
    const objects = [];
    let total = 0;
    while (objects.length != 5) {
      const object = new Parse.Object('AnObject');
      object.set('key', objects.length);
      total += objects.length;
      objects.push(object);
    }
    Parse.Object.saveAll(objects)
      .then(() => {
        const object = new Parse.Object('AContainer');
        object.set('objects', objects);
        return object.save();
      })
      .then(() => {
        const query = new Parse.Query('AContainer');
        query.include('objects');
        return query.find();
      })
      .then(
        results => {
          expect(results.length).toBe(1);
          const res = results[0];
          const objects = res.get('objects');
          expect(objects.length).toBe(5);
          objects.forEach(object => {
            total -= object.get('key');
          });
          expect(total).toBe(0);
          done();
        },
        () => {
          fail('should not fail');
          done();
        }
      );
  });

  it('properly includes array of mixed objects', done => {
    const objects = [];
    let total = 0;
    while (objects.length != 5) {
      const object = new Parse.Object('AnObject');
      object.set('key', objects.length);
      total += objects.length;
      objects.push(object);
    }
    while (objects.length != 10) {
      const object = new Parse.Object('AnotherObject');
      object.set('key', objects.length);
      total += objects.length;
      objects.push(object);
    }
    Parse.Object.saveAll(objects)
      .then(() => {
        const object = new Parse.Object('AContainer');
        object.set('objects', objects);
        return object.save();
      })
      .then(() => {
        const query = new Parse.Query('AContainer');
        query.include('objects');
        return query.find();
      })
      .then(
        results => {
          expect(results.length).toBe(1);
          const res = results[0];
          const objects = res.get('objects');
          expect(objects.length).toBe(10);
          objects.forEach(object => {
            total -= object.get('key');
          });
          expect(total).toBe(0);
          done();
        },
        e => {
          fail('should not fail');
          fail(JSON.stringify(e));
          done();
        }
      );
  });

  it('properly nested array of mixed objects with bad ids', done => {
    const objects = [];
    let total = 0;
    while (objects.length != 5) {
      const object = new Parse.Object('AnObject');
      object.set('key', objects.length);
      objects.push(object);
    }
    while (objects.length != 10) {
      const object = new Parse.Object('AnotherObject');
      object.set('key', objects.length);
      objects.push(object);
    }
    Parse.Object.saveAll(objects)
      .then(() => {
        const object = new Parse.Object('AContainer');
        for (let i = 0; i < objects.length; i++) {
          if (i % 2 == 0) {
            objects[i].id = 'randomThing';
          } else {
            total += objects[i].get('key');
          }
        }
        object.set('objects', objects);
        return object.save();
      })
      .then(() => {
        const query = new Parse.Query('AContainer');
        query.include('objects');
        return query.find();
      })
      .then(
        results => {
          expect(results.length).toBe(1);
          const res = results[0];
          const objects = res.get('objects');
          expect(objects.length).toBe(5);
          objects.forEach(object => {
            total -= object.get('key');
          });
          expect(total).toBe(0);
          done();
        },
        err => {
          jfail(err);
          fail('should not fail');
          done();
        }
      );
  });

  it('properly fetches nested pointers', done => {
    const color = new Parse.Object('Color');
    color.set('hex', '#133733');
    const circle = new Parse.Object('Circle');
    circle.set('radius', 1337);

    Parse.Object.saveAll([color, circle])
      .then(() => {
        circle.set('color', color);
        const badCircle = new Parse.Object('Circle');
        badCircle.id = 'badId';
        const complexFigure = new Parse.Object('ComplexFigure');
        complexFigure.set('consistsOf', [circle, badCircle]);
        return complexFigure.save();
      })
      .then(() => {
        const q = new Parse.Query('ComplexFigure');
        q.include('consistsOf.color');
        return q.find();
      })
      .then(
        results => {
          expect(results.length).toBe(1);
          const figure = results[0];
          expect(figure.get('consistsOf').length).toBe(1);
          expect(figure.get('consistsOf')[0].get('color').get('hex')).toBe('#133733');
          done();
        },
        () => {
          fail('should not fail');
          done();
        }
      );
  });

  it('result object creation uses current extension', function (done) {
    const ParentObject = Parse.Object.extend({ className: 'ParentObject' });
    // Add a foo() method to ChildObject.
    let ChildObject = Parse.Object.extend('ChildObject', {
      foo: function () {
        return 'foo';
      },
    });

    const parent = new ParentObject();
    const child = new ChildObject();
    parent.set('child', child);
    Parse.Object.saveAll([child, parent]).then(function () {
      // Add a bar() method to ChildObject.
      ChildObject = Parse.Object.extend('ChildObject', {
        bar: function () {
          return 'bar';
        },
      });

      const query = new Parse.Query(ParentObject);
      query.include('child');
      query.find().then(function (results) {
        equal(results.length, 1);
        const parentAgain = results[0];
        const childAgain = parentAgain.get('child');
        equal(childAgain.foo(), 'foo');
        equal(childAgain.bar(), 'bar');
        done();
      });
    });
  });

  it('matches query', function (done) {
    const ParentObject = Parse.Object.extend('ParentObject');
    const ChildObject = Parse.Object.extend('ChildObject');
    const objects = [];
    for (let i = 0; i < 10; ++i) {
      objects.push(
        new ParentObject({
          child: new ChildObject({ x: i }),
          x: 10 + i,
        })
      );
    }
    Parse.Object.saveAll(objects).then(function () {
      const subQuery = new Parse.Query(ChildObject);
      subQuery.greaterThan('x', 5);
      const query = new Parse.Query(ParentObject);
      query.matchesQuery('child', subQuery);
      query.find().then(function (results) {
        equal(results.length, 4);
        for (const object of results) {
          ok(object.get('x') > 15);
        }
        const query = new Parse.Query(ParentObject);
        query.doesNotMatchQuery('child', subQuery);
        query.find().then(function (results) {
          equal(results.length, 6);
          for (const object of results) {
            ok(object.get('x') >= 10);
            ok(object.get('x') <= 15);
            done();
          }
        });
      });
    });
  });

  it('select query', function (done) {
    const RestaurantObject = Parse.Object.extend('Restaurant');
    const PersonObject = Parse.Object.extend('Person');
    const objects = [
      new RestaurantObject({ ratings: 5, location: 'Djibouti' }),
      new RestaurantObject({ ratings: 3, location: 'Ouagadougou' }),
      new PersonObject({ name: 'Bob', hometown: 'Djibouti' }),
      new PersonObject({ name: 'Tom', hometown: 'Ouagadougou' }),
      new PersonObject({ name: 'Billy', hometown: 'Detroit' }),
    ];

    Parse.Object.saveAll(objects).then(function () {
      const query = new Parse.Query(RestaurantObject);
      query.greaterThan('ratings', 4);
      const mainQuery = new Parse.Query(PersonObject);
      mainQuery.matchesKeyInQuery('hometown', 'location', query);
      mainQuery.find().then(function (results) {
        equal(results.length, 1);
        equal(results[0].get('name'), 'Bob');
        done();
      });
    });
  });

  it('$select inside $or', done => {
    const Restaurant = Parse.Object.extend('Restaurant');
    const Person = Parse.Object.extend('Person');
    const objects = [
      new Restaurant({ ratings: 5, location: 'Djibouti' }),
      new Restaurant({ ratings: 3, location: 'Ouagadougou' }),
      new Person({ name: 'Bob', hometown: 'Djibouti' }),
      new Person({ name: 'Tom', hometown: 'Ouagadougou' }),
      new Person({ name: 'Billy', hometown: 'Detroit' }),
    ];

    Parse.Object.saveAll(objects)
      .then(() => {
        const subquery = new Parse.Query(Restaurant);
        subquery.greaterThan('ratings', 4);
        const query1 = new Parse.Query(Person);
        query1.matchesKeyInQuery('hometown', 'location', subquery);
        const query2 = new Parse.Query(Person);
        query2.equalTo('name', 'Tom');
        const query = Parse.Query.or(query1, query2);
        return query.find();
      })
      .then(
        results => {
          expect(results.length).toEqual(2);
          done();
        },
        error => {
          jfail(error);
          done();
        }
      );
  });

  it('$nor valid query', done => {
    const objects = Array.from(Array(10).keys()).map(rating => {
      return new TestObject({ rating: rating });
    });

    const highValue = 5;
    const lowValue = 3;
    const options = Object.assign({}, masterKeyOptions, {
      qs: {
        where: JSON.stringify({
          $nor: [{ rating: { $gt: highValue } }, { rating: { $lte: lowValue } }],
        }),
      },
    });

    Parse.Object.saveAll(objects)
      .then(() => {
        return request(Object.assign({ url: Parse.serverURL + '/classes/TestObject' }, options));
      })
      .then(response => {
        const results = response.data;
        expect(results.results.length).toBe(highValue - lowValue);
        expect(results.results.every(res => res.rating > lowValue && res.rating <= highValue)).toBe(
          true
        );
        done();
      });
  });

  it('$nor invalid query - empty array', done => {
    const options = Object.assign({}, masterKeyOptions, {
      qs: {
        where: JSON.stringify({ $nor: [] }),
      },
    });
    const obj = new TestObject();
    obj
      .save()
      .then(() => {
        return request(Object.assign({ url: Parse.serverURL + '/classes/TestObject' }, options));
      })
      .then(done.fail)
      .catch(response => {
        equal(response.data.code, Parse.Error.INVALID_QUERY);
        done();
      });
  });

  it('$nor invalid query - wrong type', done => {
    const options = Object.assign({}, masterKeyOptions, {
      qs: {
        where: JSON.stringify({ $nor: 1337 }),
      },
    });
    const obj = new TestObject();
    obj
      .save()
      .then(() => {
        return request(Object.assign({ url: Parse.serverURL + '/classes/TestObject' }, options));
      })
      .then(done.fail)
      .catch(response => {
        equal(response.data.code, Parse.Error.INVALID_QUERY);
        done();
      });
  });

  it('dontSelect query', function (done) {
    const RestaurantObject = Parse.Object.extend('Restaurant');
    const PersonObject = Parse.Object.extend('Person');
    const objects = [
      new RestaurantObject({ ratings: 5, location: 'Djibouti' }),
      new RestaurantObject({ ratings: 3, location: 'Ouagadougou' }),
      new PersonObject({ name: 'Bob', hometown: 'Djibouti' }),
      new PersonObject({ name: 'Tom', hometown: 'Ouagadougou' }),
      new PersonObject({ name: 'Billy', hometown: 'Djibouti' }),
    ];

    Parse.Object.saveAll(objects).then(function () {
      const query = new Parse.Query(RestaurantObject);
      query.greaterThan('ratings', 4);
      const mainQuery = new Parse.Query(PersonObject);
      mainQuery.doesNotMatchKeyInQuery('hometown', 'location', query);
      mainQuery.find().then(function (results) {
        equal(results.length, 1);
        equal(results[0].get('name'), 'Tom');
        done();
      });
    });
  });

  it('dontSelect query without conditions', function (done) {
    const RestaurantObject = Parse.Object.extend('Restaurant');
    const PersonObject = Parse.Object.extend('Person');
    const objects = [
      new RestaurantObject({ location: 'Djibouti' }),
      new RestaurantObject({ location: 'Ouagadougou' }),
      new PersonObject({ name: 'Bob', hometown: 'Djibouti' }),
      new PersonObject({ name: 'Tom', hometown: 'Yoloblahblahblah' }),
      new PersonObject({ name: 'Billy', hometown: 'Ouagadougou' }),
    ];

    Parse.Object.saveAll(objects).then(function () {
      const query = new Parse.Query(RestaurantObject);
      const mainQuery = new Parse.Query(PersonObject);
      mainQuery.doesNotMatchKeyInQuery('hometown', 'location', query);
      mainQuery.find().then(results => {
        equal(results.length, 1);
        equal(results[0].get('name'), 'Tom');
        done();
      });
    });
  });

  it('equalTo on same column as $dontSelect should not break $dontSelect functionality (#3678)', function (done) {
    const AuthorObject = Parse.Object.extend('Author');
    const BlockedObject = Parse.Object.extend('Blocked');
    const PostObject = Parse.Object.extend('Post');

    let postAuthor = null;
    let requestUser = null;

    return new AuthorObject({ name: 'Julius' })
      .save()
      .then(user => {
        postAuthor = user;
        return new AuthorObject({ name: 'Bob' }).save();
      })
      .then(user => {
        requestUser = user;
        const objects = [
          new PostObject({ author: postAuthor, title: 'Lorem ipsum' }),
          new PostObject({ author: requestUser, title: 'Kafka' }),
          new PostObject({ author: requestUser, title: 'Brown fox' }),
          new BlockedObject({
            blockedBy: postAuthor,
            blockedUser: requestUser,
          }),
        ];
        return Parse.Object.saveAll(objects);
      })
      .then(() => {
        const banListQuery = new Parse.Query(BlockedObject);
        banListQuery.equalTo('blockedUser', requestUser);

        return new Parse.Query(PostObject)
          .equalTo('author', postAuthor)
          .doesNotMatchKeyInQuery('author', 'blockedBy', banListQuery)
          .find()
          .then(r => {
            expect(r.length).toEqual(0);
            done();
          }, done.fail);
      });
  });

  it('multiple dontSelect query', function (done) {
    const RestaurantObject = Parse.Object.extend('Restaurant');
    const PersonObject = Parse.Object.extend('Person');
    const objects = [
      new RestaurantObject({ ratings: 7, location: 'Djibouti2' }),
      new RestaurantObject({ ratings: 5, location: 'Djibouti' }),
      new RestaurantObject({ ratings: 3, location: 'Ouagadougou' }),
      new PersonObject({ name: 'Bob2', hometown: 'Djibouti2' }),
      new PersonObject({ name: 'Bob', hometown: 'Djibouti' }),
      new PersonObject({ name: 'Tom', hometown: 'Ouagadougou' }),
    ];

    Parse.Object.saveAll(objects).then(function () {
      const query = new Parse.Query(RestaurantObject);
      query.greaterThan('ratings', 6);
      const query2 = new Parse.Query(RestaurantObject);
      query2.lessThan('ratings', 4);
      const subQuery = new Parse.Query(PersonObject);
      subQuery.matchesKeyInQuery('hometown', 'location', query);
      const subQuery2 = new Parse.Query(PersonObject);
      subQuery2.matchesKeyInQuery('hometown', 'location', query2);
      const mainQuery = new Parse.Query(PersonObject);
      mainQuery.doesNotMatchKeyInQuery('objectId', 'objectId', Parse.Query.or(subQuery, subQuery2));
      mainQuery.find().then(function (results) {
        equal(results.length, 1);
        equal(results[0].get('name'), 'Bob');
        done();
      });
    });
  });

  it('include user', function (done) {
    Parse.User.signUp('bob', 'password', { age: 21 }).then(function (user) {
      const TestObject = Parse.Object.extend('TestObject');
      const obj = new TestObject();
      obj
        .save({
          owner: user,
        })
        .then(function (obj) {
          const query = new Parse.Query(TestObject);
          query.include('owner');
          query.get(obj.id).then(function (objAgain) {
            equal(objAgain.id, obj.id);
            ok(objAgain.get('owner') instanceof Parse.User);
            equal(objAgain.get('owner').get('age'), 21);
            done();
          }, done.fail);
        }, done.fail);
    }, done.fail);
  });

  it('or queries', function (done) {
    const objects = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(function (x) {
      const object = new Parse.Object('BoxedNumber');
      object.set('x', x);
      return object;
    });
    Parse.Object.saveAll(objects).then(function () {
      const query1 = new Parse.Query('BoxedNumber');
      query1.lessThan('x', 2);
      const query2 = new Parse.Query('BoxedNumber');
      query2.greaterThan('x', 5);
      const orQuery = Parse.Query.or(query1, query2);
      orQuery.find().then(function (results) {
        equal(results.length, 6);
        for (const number of results) {
          ok(number.get('x') < 2 || number.get('x') > 5);
        }
        done();
      });
    });
  });

  // This relies on matchesQuery aka the $inQuery operator
  it('or complex queries', function (done) {
    const objects = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(function (x) {
      const child = new Parse.Object('Child');
      child.set('x', x);
      const parent = new Parse.Object('Parent');
      parent.set('child', child);
      parent.set('y', x);
      return parent;
    });

    Parse.Object.saveAll(objects).then(function () {
      const subQuery = new Parse.Query('Child');
      subQuery.equalTo('x', 4);
      const query1 = new Parse.Query('Parent');
      query1.matchesQuery('child', subQuery);
      const query2 = new Parse.Query('Parent');
      query2.lessThan('y', 2);
      const orQuery = Parse.Query.or(query1, query2);
      orQuery.find().then(function (results) {
        equal(results.length, 3);
        done();
      });
    });
  });

  it('async methods', function (done) {
    const saves = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(function (x) {
      const obj = new Parse.Object('TestObject');
      obj.set('x', x + 1);
      return obj;
    });

    Parse.Object.saveAll(saves)
      .then(function () {
        const query = new Parse.Query('TestObject');
        query.ascending('x');
        return query.first();
      })
      .then(function (obj) {
        equal(obj.get('x'), 1);
        const query = new Parse.Query('TestObject');
        query.descending('x');
        return query.find();
      })
      .then(function (results) {
        equal(results.length, 10);
        const query = new Parse.Query('TestObject');
        return query.get(results[0].id);
      })
      .then(function (obj1) {
        equal(obj1.get('x'), 10);
        const query = new Parse.Query('TestObject');
        return query.count();
      })
      .then(function (count) {
        equal(count, 10);
      })
      .then(function () {
        done();
      });
  });

  it('query.each', function (done) {
    const TOTAL = 50;
    const COUNT = 25;

    const items = range(TOTAL).map(function (x) {
      const obj = new TestObject();
      obj.set('x', x);
      return obj;
    });

    Parse.Object.saveAll(items).then(function () {
      const query = new Parse.Query(TestObject);
      query.lessThan('x', COUNT);

      const seen = [];
      query
        .each(
          function (obj) {
            seen[obj.get('x')] = (seen[obj.get('x')] || 0) + 1;
          },
          {
            batchSize: 10,
          }
        )
        .then(function () {
          equal(seen.length, COUNT);
          for (let i = 0; i < COUNT; i++) {
            equal(seen[i], 1, 'Should have seen object number ' + i);
          }
          done();
        }, done.fail);
    });
  });

  it('query.each async', function (done) {
    const TOTAL = 50;
    const COUNT = 25;

    expect(COUNT + 1);

    const items = range(TOTAL).map(function (x) {
      const obj = new TestObject();
      obj.set('x', x);
      return obj;
    });

    const seen = [];

    Parse.Object.saveAll(items)
      .then(function () {
        const query = new Parse.Query(TestObject);
        query.lessThan('x', COUNT);
        return query.each(
          function (obj) {
            return new Promise(resolve => {
              process.nextTick(function () {
                seen[obj.get('x')] = (seen[obj.get('x')] || 0) + 1;
                resolve();
              });
            });
          },
          {
            batchSize: 10,
          }
        );
      })
      .then(function () {
        equal(seen.length, COUNT);
        for (let i = 0; i < COUNT; i++) {
          equal(seen[i], 1, 'Should have seen object number ' + i);
        }
        done();
      });
  });

  it('query.each fails with order', function (done) {
    const TOTAL = 50;
    const COUNT = 25;

    const items = range(TOTAL).map(function (x) {
      const obj = new TestObject();
      obj.set('x', x);
      return obj;
    });

    const seen = [];

    Parse.Object.saveAll(items)
      .then(function () {
        const query = new Parse.Query(TestObject);
        query.lessThan('x', COUNT);
        query.ascending('x');
        return query.each(function (obj) {
          seen[obj.get('x')] = (seen[obj.get('x')] || 0) + 1;
        });
      })
      .then(
        function () {
          ok(false, 'This should have failed.');
          done();
        },
        function () {
          done();
        }
      );
  });

  it('query.each fails with skip', function (done) {
    const TOTAL = 50;
    const COUNT = 25;

    const items = range(TOTAL).map(function (x) {
      const obj = new TestObject();
      obj.set('x', x);
      return obj;
    });

    const seen = [];

    Parse.Object.saveAll(items)
      .then(function () {
        const query = new Parse.Query(TestObject);
        query.lessThan('x', COUNT);
        query.skip(5);
        return query.each(function (obj) {
          seen[obj.get('x')] = (seen[obj.get('x')] || 0) + 1;
        });
      })
      .then(
        function () {
          ok(false, 'This should have failed.');
          done();
        },
        function () {
          done();
        }
      );
  });

  it('query.each fails with limit', function (done) {
    const TOTAL = 50;
    const COUNT = 25;

    expect(0);

    const items = range(TOTAL).map(function (x) {
      const obj = new TestObject();
      obj.set('x', x);
      return obj;
    });

    const seen = [];

    Parse.Object.saveAll(items)
      .then(function () {
        const query = new Parse.Query(TestObject);
        query.lessThan('x', COUNT);
        query.limit(5);
        return query.each(function (obj) {
          seen[obj.get('x')] = (seen[obj.get('x')] || 0) + 1;
        });
      })
      .then(
        function () {
          ok(false, 'This should have failed.');
          done();
        },
        function () {
          done();
        }
      );
  });

  it('select keys query JS SDK', async () => {
    const obj = new TestObject({ foo: 'baz', bar: 1, qux: 2 });
    await obj.save();
    obj._clearServerData();
    const query1 = new Parse.Query(TestObject);
    query1.select('foo');
    const result1 = await query1.first();
    ok(result1.id, 'expected object id to be set');
    ok(result1.createdAt, 'expected object createdAt to be set');
    ok(result1.updatedAt, 'expected object updatedAt to be set');
    ok(!result1.dirty(), 'expected result not to be dirty');
    strictEqual(result1.get('foo'), 'baz');
    strictEqual(result1.get('bar'), undefined, ""expected 'bar' field to be unset"");
    strictEqual(result1.get('qux'), undefined, ""expected 'qux' field to be unset"");

    const result2 = await result1.fetch();
    strictEqual(result2.get('foo'), 'baz');
    strictEqual(result2.get('bar'), 1);
    strictEqual(result2.get('qux'), 2);

    obj._clearServerData();
    const query2 = new Parse.Query(TestObject);
    query2.select();
    const result3 = await query2.first();
    ok(result3.id, 'expected object id to be set');
    ok(result3.createdAt, 'expected object createdAt to be set');
    ok(result3.updatedAt, 'expected object updatedAt to be set');
    ok(!result3.dirty(), 'expected result not to be dirty');
    strictEqual(result3.get('foo'), undefined, ""expected 'foo' field to be unset"");
    strictEqual(result3.get('bar'), undefined, ""expected 'bar' field to be unset"");
    strictEqual(result3.get('qux'), undefined, ""expected 'qux' field to be unset"");

    obj._clearServerData();
    const query3 = new Parse.Query(TestObject);
    query3.select([]);
    const result4 = await query3.first();
    ok(result4.id, 'expected object id to be set');
    ok(result4.createdAt, 'expected object createdAt to be set');
    ok(result4.updatedAt, 'expected object updatedAt to be set');
    ok(!result4.dirty(), 'expected result not to be dirty');
    strictEqual(result4.get('foo'), undefined, ""expected 'foo' field to be unset"");
    strictEqual(result4.get('bar'), undefined, ""expected 'bar' field to be unset"");
    strictEqual(result4.get('qux'), undefined, ""expected 'qux' field to be unset"");

    obj._clearServerData();
    const query4 = new Parse.Query(TestObject);
    query4.select(['foo']);
    const result5 = await query4.first();
    ok(result5.id, 'expected object id to be set');
    ok(result5.createdAt, 'expected object createdAt to be set');
    ok(result5.updatedAt, 'expected object updatedAt to be set');
    ok(!result5.dirty(), 'expected result not to be dirty');
    strictEqual(result5.get('foo'), 'baz');
    strictEqual(result5.get('bar'), undefined, ""expected 'bar' field to be unset"");
    strictEqual(result5.get('qux'), undefined, ""expected 'qux' field to be unset"");

    obj._clearServerData();
    const query5 = new Parse.Query(TestObject);
    query5.select(['foo', 'bar']);
    const result6 = await query5.first();
    ok(result6.id, 'expected object id to be set');
    ok(!result6.dirty(), 'expected result not to be dirty');
    strictEqual(result6.get('foo'), 'baz');
    strictEqual(result6.get('bar'), 1);
    strictEqual(result6.get('qux'), undefined, ""expected 'qux' field to be unset"");

    obj._clearServerData();
    const query6 = new Parse.Query(TestObject);
    query6.select(['foo', 'bar', 'qux']);
    const result7 = await query6.first();
    ok(result7.id, 'expected object id to be set');
    ok(!result7.dirty(), 'expected result not to be dirty');
    strictEqual(result7.get('foo'), 'baz');
    strictEqual(result7.get('bar'), 1);
    strictEqual(result7.get('qux'), 2);

    obj._clearServerData();
    const query7 = new Parse.Query(TestObject);
    query7.select('foo', 'bar');
    const result8 = await query7.first();
    ok(result8.id, 'expected object id to be set');
    ok(!result8.dirty(), 'expected result not to be dirty');
    strictEqual(result8.get('foo'), 'baz');
    strictEqual(result8.get('bar'), 1);
    strictEqual(result8.get('qux'), undefined, ""expected 'qux' field to be unset"");

    obj._clearServerData();
    const query8 = new Parse.Query(TestObject);
    query8.select('foo', 'bar', 'qux');
    const result9 = await query8.first();
    ok(result9.id, 'expected object id to be set');
    ok(!result9.dirty(), 'expected result not to be dirty');
    strictEqual(result9.get('foo'), 'baz');
    strictEqual(result9.get('bar'), 1);
    strictEqual(result9.get('qux'), 2);
  });

  it('select keys (arrays)', async () => {
    const obj = new TestObject({ foo: 'baz', bar: 1, hello: 'world' });
    await obj.save();

    const response = await request({
      url: Parse.serverURL + '/classes/TestObject',
      qs: {
        keys: 'hello',
        where: JSON.stringify({ objectId: obj.id }),
      },
      headers: masterKeyHeaders,
    });
    expect(response.data.results[0].foo).toBeUndefined();
    expect(response.data.results[0].bar).toBeUndefined();
    expect(response.data.results[0].hello).toBe('world');

    const response2 = await request({
      url: Parse.serverURL + '/classes/TestObject',
      qs: {
        keys: ['foo', 'hello'],
        where: JSON.stringify({ objectId: obj.id }),
      },
      headers: masterKeyHeaders,
    });
    expect(response2.data.results[0].foo).toBe('baz');
    expect(response2.data.results[0].bar).toBeUndefined();
    expect(response2.data.results[0].hello).toBe('world');

    const response3 = await request({
      url: Parse.serverURL + '/classes/TestObject',
      qs: {
        keys: ['foo', 'bar', 'hello'],
        where: JSON.stringify({ objectId: obj.id }),
      },
      headers: masterKeyHeaders,
    });
    expect(response3.data.results[0].foo).toBe('baz');
    expect(response3.data.results[0].bar).toBe(1);
    expect(response3.data.results[0].hello).toBe('world');

    const response4 = await request({
      url: Parse.serverURL + '/classes/TestObject',
      qs: {
        keys: [''],
        where: JSON.stringify({ objectId: obj.id }),
      },
      headers: masterKeyHeaders,
    });
    ok(response4.data.results[0].objectId, 'expected objectId to be set');
    ok(response4.data.results[0].createdAt, 'expected object createdAt to be set');
    ok(response4.data.results[0].updatedAt, 'expected object updatedAt to be set');
    expect(response4.data.results[0].foo).toBeUndefined();
    expect(response4.data.results[0].bar).toBeUndefined();
    expect(response4.data.results[0].hello).toBeUndefined();

    const response5 = await request({
      url: Parse.serverURL + '/classes/TestObject',
      qs: {
        keys: [],
        where: JSON.stringify({ objectId: obj.id }),
      },
      headers: masterKeyHeaders,
    });
    ok(response5.data.results[0].objectId, 'expected objectId to be set');
    ok(response5.data.results[0].createdAt, 'expected object createdAt to be set');
    ok(response5.data.results[0].updatedAt, 'expected object updatedAt to be set');
    expect(response5.data.results[0].foo).toBe('baz');
    expect(response5.data.results[0].bar).toBe(1);
    expect(response5.data.results[0].hello).toBe('world');
  });

  it('select keys (strings)', async () => {
    const obj = new TestObject({ foo: 'baz', bar: 1, hello: 'world' });
    await obj.save();

    const response = await request({
      url: Parse.serverURL + '/classes/TestObject',
      qs: {
        keys: '',
        where: JSON.stringify({ objectId: obj.id }),
      },
      headers: masterKeyHeaders,
    });
    ok(response.data.results[0].objectId, 'expected objectId to be set');
    ok(response.data.results[0].createdAt, 'expected object createdAt to be set');
    ok(response.data.results[0].updatedAt, 'expected object updatedAt to be set');
    expect(response.data.results[0].foo).toBeUndefined();
    expect(response.data.results[0].bar).toBeUndefined();
    expect(response.data.results[0].hello).toBeUndefined();

    const response2 = await request({
      url: Parse.serverURL + '/classes/TestObject',
      qs: {
        keys: '[""foo"", ""hello""]',
        where: JSON.stringify({ objectId: obj.id }),
      },
      headers: masterKeyHeaders,
    });
    ok(response2.data.results[0].objectId, 'expected objectId to be set');
    ok(response2.data.results[0].createdAt, 'expected object createdAt to be set');
    ok(response2.data.results[0].updatedAt, 'expected object updatedAt to be set');
    expect(response2.data.results[0].foo).toBe('baz');
    expect(response2.data.results[0].bar).toBeUndefined();
    expect(response2.data.results[0].hello).toBe('world');

    const response3 = await request({
      url: Parse.serverURL + '/classes/TestObject',
      qs: {
        keys: '[""foo"", ""bar"", ""hello""]',
        where: JSON.stringify({ objectId: obj.id }),
      },
      headers: masterKeyHeaders,
    });
    ok(response3.data.results[0].objectId, 'expected objectId to be set');
    ok(response3.data.results[0].createdAt, 'expected object createdAt to be set');
    ok(response3.data.results[0].updatedAt, 'expected object updatedAt to be set');
    expect(response3.data.results[0].foo).toBe('baz');
    expect(response3.data.results[0].bar).toBe(1);
    expect(response3.data.results[0].hello).toBe('world');
  });

  it('exclude keys query JS SDK', async () => {
    const obj = new TestObject({ foo: 'baz', bar: 1, qux: 2 });

    await obj.save();
    obj._clearServerData();
    const query1 = new Parse.Query(TestObject);
    query1.exclude('foo');
    const result1 = await query1.first();
    ok(result1.id, 'expected object id to be set');
    ok(result1.createdAt, 'expected object createdAt to be set');
    ok(result1.updatedAt, 'expected object updatedAt to be set');
    ok(!result1.dirty(), 'expected result not to be dirty');
    strictEqual(result1.get('foo'), undefined, ""expected 'bar' field to be unset"");
    strictEqual(result1.get('bar'), 1);
    strictEqual(result1.get('qux'), 2);

    const result2 = await result1.fetch();
    strictEqual(result2.get('foo'), 'baz');
    strictEqual(result2.get('bar'), 1);
    strictEqual(result2.get('qux'), 2);

    obj._clearServerData();
    const query2 = new Parse.Query(TestObject);
    query2.exclude();
    const result3 = await query2.first();
    ok(result3.id, 'expected object id to be set');
    ok(result3.createdAt, 'expected object createdAt to be set');
    ok(result3.updatedAt, 'expected object updatedAt to be set');
    ok(!result3.dirty(), 'expected result not to be dirty');
    strictEqual(result3.get('foo'), 'baz');
    strictEqual(result3.get('bar'), 1);
    strictEqual(result3.get('qux'), 2);

    obj._clearServerData();
    const query3 = new Parse.Query(TestObject);
    query3.exclude([]);
    const result4 = await query3.first();
    ok(result4.id, 'expected object id to be set');
    ok(result4.createdAt, 'expected object createdAt to be set');
    ok(result4.updatedAt, 'expected object updatedAt to be set');
    ok(!result4.dirty(), 'expected result not to be dirty');
    strictEqual(result4.get('foo'), 'baz');
    strictEqual(result4.get('bar'), 1);
    strictEqual(result4.get('qux'), 2);

    obj._clearServerData();
    const query4 = new Parse.Query(TestObject);
    query4.exclude(['foo']);
    const result5 = await query4.first();
    ok(result5.id, 'expected object id to be set');
    ok(result5.createdAt, 'expected object createdAt to be set');
    ok(result5.updatedAt, 'expected object updatedAt to be set');
    ok(!result5.dirty(), 'expected result not to be dirty');
    strictEqual(result5.get('foo'), undefined, ""expected 'bar' field to be unset"");
    strictEqual(result5.get('bar'), 1);
    strictEqual(result5.get('qux'), 2);

    obj._clearServerData();
    const query5 = new Parse.Query(TestObject);
    query5.exclude(['foo', 'bar']);
    const result6 = await query5.first();
    ok(result6.id, 'expected object id to be set');
    ok(!result6.dirty(), 'expected result not to be dirty');
    strictEqual(result6.get('foo'), undefined, ""expected 'bar' field to be unset"");
    strictEqual(result6.get('bar'), undefined, ""expected 'bar' field to be unset"");
    strictEqual(result6.get('qux'), 2);

    obj._clearServerData();
    const query6 = new Parse.Query(TestObject);
    query6.exclude(['foo', 'bar', 'qux']);
    const result7 = await query6.first();
    ok(result7.id, 'expected object id to be set');
    ok(!result7.dirty(), 'expected result not to be dirty');
    strictEqual(result7.get('foo'), undefined, ""expected 'bar' field to be unset"");
    strictEqual(result7.get('bar'), undefined, ""expected 'bar' field to be unset"");
    strictEqual(result7.get('qux'), undefined, ""expected 'bar' field to be unset"");

    obj._clearServerData();
    const query7 = new Parse.Query(TestObject);
    query7.exclude('foo');
    const result8 = await query7.first();
    ok(result8.id, 'expected object id to be set');
    ok(!result8.dirty(), 'expected result not to be dirty');
    strictEqual(result8.get('foo'), undefined, ""expected 'bar' field to be unset"");
    strictEqual(result8.get('bar'), 1);
    strictEqual(result8.get('qux'), 2);

    obj._clearServerData();
    const query8 = new Parse.Query(TestObject);
    query8.exclude('foo', 'bar');
    const result9 = await query8.first();
    ok(result9.id, 'expected object id to be set');
    ok(!result9.dirty(), 'expected result not to be dirty');
    strictEqual(result9.get('foo'), undefined, ""expected 'bar' field to be unset"");
    strictEqual(result9.get('bar'), undefined, ""expected 'bar' field to be unset"");
    strictEqual(result9.get('qux'), 2);

    obj._clearServerData();
    const query9 = new Parse.Query(TestObject);
    query9.exclude('foo', 'bar', 'qux');
    const result10 = await query9.first();
    ok(result10.id, 'expected object id to be set');
    ok(!result10.dirty(), 'expected result not to be dirty');
    strictEqual(result10.get('foo'), undefined, ""expected 'bar' field to be unset"");
    strictEqual(result10.get('bar'), undefined, ""expected 'bar' field to be unset"");
    strictEqual(result10.get('qux'), undefined, ""expected 'bar' field to be unset"");
  });

  it('exclude keys (arrays)', async () => {
    const obj = new TestObject({ foo: 'baz', hello: 'world' });
    await obj.save();

    const response = await request({
      url: Parse.serverURL + '/classes/TestObject',
      qs: {
        excludeKeys: ['foo'],
        where: JSON.stringify({ objectId: obj.id }),
      },
      headers: masterKeyHeaders,
    });
    ok(response.data.results[0].objectId, 'expected objectId to be set');
    ok(response.data.results[0].createdAt, 'expected object createdAt to be set');
    ok(response.data.results[0].updatedAt, 'expected object updatedAt to be set');
    expect(response.data.results[0].foo).toBeUndefined();
    expect(response.data.results[0].hello).toBe('world');

    const response2 = await request({
      url: Parse.serverURL + '/classes/TestObject',
      qs: {
        excludeKeys: ['foo', 'hello'],
        where: JSON.stringify({ objectId: obj.id }),
      },
      headers: masterKeyHeaders,
    });
    ok(response2.data.results[0].objectId, 'expected objectId to be set');
    ok(response2.data.results[0].createdAt, 'expected object createdAt to be set');
    ok(response2.data.results[0].updatedAt, 'expected object updatedAt to be set');
    expect(response2.data.results[0].foo).toBeUndefined();
    expect(response2.data.results[0].hello).toBeUndefined();

    const response3 = await request({
      url: Parse.serverURL + '/classes/TestObject',
      qs: {
        excludeKeys: [],
        where: JSON.stringify({ objectId: obj.id }),
      },
      headers: masterKeyHeaders,
    });
    ok(response3.data.results[0].objectId, 'expected objectId to be set');
    ok(response3.data.results[0].createdAt, 'expected object createdAt to be set');
    ok(response3.data.results[0].updatedAt, 'expected object updatedAt to be set');
    expect(response3.data.results[0].foo).toBe('baz');
    expect(response3.data.results[0].hello).toBe('world');

    const response4 = await request({
      url: Parse.serverURL + '/classes/TestObject',
      qs: {
        excludeKeys: [''],
        where: JSON.stringify({ objectId: obj.id }),
      },
      headers: masterKeyHeaders,
    });
    ok(response4.data.results[0].objectId, 'expected objectId to be set');
    ok(response4.data.results[0].createdAt, 'expected object createdAt to be set');
    ok(response4.data.results[0].updatedAt, 'expected object updatedAt to be set');
    expect(response4.data.results[0].foo).toBe('baz');
    expect(response4.data.results[0].hello).toBe('world');
  });

  it('exclude keys (strings)', async () => {
    const obj = new TestObject({ foo: 'baz', hello: 'world' });
    await obj.save();

    const response = await request({
      url: Parse.serverURL + '/classes/TestObject',
      qs: {
        excludeKeys: 'foo',
        where: JSON.stringify({ objectId: obj.id }),
      },
      headers: masterKeyHeaders,
    });
    ok(response.data.results[0].objectId, 'expected objectId to be set');
    ok(response.data.results[0].createdAt, 'expected object createdAt to be set');
    ok(response.data.results[0].updatedAt, 'expected object updatedAt to be set');
    expect(response.data.results[0].foo).toBeUndefined();
    expect(response.data.results[0].hello).toBe('world');

    const response2 = await request({
      url: Parse.serverURL + '/classes/TestObject',
      qs: {
        excludeKeys: '',
        where: JSON.stringify({ objectId: obj.id }),
      },
      headers: masterKeyHeaders,
    });
    ok(response2.data.results[0].objectId, 'expected objectId to be set');
    ok(response2.data.results[0].createdAt, 'expected object createdAt to be set');
    ok(response2.data.results[0].updatedAt, 'expected object updatedAt to be set');
    expect(response2.data.results[0].foo).toBe('baz');
    expect(response2.data.results[0].hello).toBe('world');

    const response3 = await request({
      url: Parse.serverURL + '/classes/TestObject',
      qs: {
        excludeKeys: '[""hello""]',
        where: JSON.stringify({ objectId: obj.id }),
      },
      headers: masterKeyHeaders,
    });
    ok(response3.data.results[0].objectId, 'expected objectId to be set');
    ok(response3.data.results[0].createdAt, 'expected object createdAt to be set');
    ok(response3.data.results[0].updatedAt, 'expected object updatedAt to be set');
    expect(response3.data.results[0].foo).toBe('baz');
    expect(response3.data.results[0].hello).toBeUndefined();

    const response4 = await request({
      url: Parse.serverURL + '/classes/TestObject',
      qs: {
        excludeKeys: '[""foo"", ""hello""]',
        where: JSON.stringify({ objectId: obj.id }),
      },
      headers: masterKeyHeaders,
    });
    ok(response4.data.results[0].objectId, 'expected objectId to be set');
    ok(response4.data.results[0].createdAt, 'expected object createdAt to be set');
    ok(response4.data.results[0].updatedAt, 'expected object updatedAt to be set');
    expect(response4.data.results[0].foo).toBeUndefined();
    expect(response4.data.results[0].hello).toBeUndefined();
  });

  it('exclude keys with select same key', async () => {
    const obj = new TestObject({ foo: 'baz', hello: 'world' });
    await obj.save();

    const response = await request({
      url: Parse.serverURL + '/classes/TestObject',
      qs: {
        keys: 'foo',
        excludeKeys: 'foo',
        where: JSON.stringify({ objectId: obj.id }),
      },
      headers: masterKeyHeaders,
    });
    expect(response.data.results[0].foo).toBeUndefined();
    expect(response.data.results[0].hello).toBeUndefined();
  });

  it('exclude keys with select different key', async () => {
    const obj = new TestObject({ foo: 'baz', hello: 'world' });
    await obj.save();

    const response = await request({
      url: Parse.serverURL + '/classes/TestObject',
      qs: {
        keys: 'foo,hello',
        excludeKeys: 'foo',
        where: JSON.stringify({ objectId: obj.id }),
      },
      headers: masterKeyHeaders,
    });
    expect(response.data.results[0].foo).toBeUndefined();
    expect(response.data.results[0].hello).toBe('world');
  });

  it('exclude keys with include same key', async () => {
    const pointer = new TestObject();
    await pointer.save();
    const obj = new TestObject({ child: pointer, hello: 'world' });
    await obj.save();

    const response = await request({
      url: Parse.serverURL + '/classes/TestObject',
      qs: {
        include: 'child',
        excludeKeys: 'child',
        where: JSON.stringify({ objectId: obj.id }),
      },
      headers: masterKeyHeaders,
    });
    expect(response.data.results[0].child).toBeUndefined();
    expect(response.data.results[0].hello).toBe('world');
  });

  it('exclude keys with include different key', async () => {
    const pointer = new TestObject();
    await pointer.save();
    const obj = new TestObject({
      child1: pointer,
      child2: pointer,
      hello: 'world',
    });
    await obj.save();

    const response = await request({
      url: Parse.serverURL + '/classes/TestObject',
      qs: {
        include: 'child1,child2',
        excludeKeys: 'child1',
        where: JSON.stringify({ objectId: obj.id }),
      },
      headers: masterKeyHeaders,
    });
    expect(response.data.results[0].child1).toBeUndefined();
    expect(response.data.results[0].child2.objectId).toEqual(pointer.id);
    expect(response.data.results[0].hello).toBe('world');
  });

  it('exclude keys with includeAll', async () => {
    const pointer = new TestObject();
    await pointer.save();
    const obj = new TestObject({
      child1: pointer,
      child2: pointer,
      hello: 'world',
    });
    await obj.save();

    const response = await request({
      url: Parse.serverURL + '/classes/TestObject',
      qs: {
        includeAll: true,
        excludeKeys: 'child1',
        where: JSON.stringify({ objectId: obj.id }),
      },
      headers: masterKeyHeaders,
    });
    expect(response.data.results[0].child).toBeUndefined();
    expect(response.data.results[0].child2.objectId).toEqual(pointer.id);
    expect(response.data.results[0].hello).toBe('world');
  });

  it('select keys with each query', function (done) {
    const obj = new TestObject({ foo: 'baz', bar: 1 });

    obj.save().then(function () {
      obj._clearServerData();
      const query = new Parse.Query(TestObject);
      query.select('foo');
      query
        .each(function (result) {
          ok(result.id, 'expected object id to be set');
          ok(result.createdAt, 'expected object createdAt to be set');
          ok(result.updatedAt, 'expected object updatedAt to be set');
          ok(!result.dirty(), 'expected result not to be dirty');
          strictEqual(result.get('foo'), 'baz');
          strictEqual(result.get('bar'), undefined, 'expected ""bar"" field to be unset');
        })
        .then(
          function () {
            done();
          },
          function (err) {
            jfail(err);
            done();
          }
        );
    });
  });

  it_id('56b09b92-c756-4bae-8c32-1c32b5b4c397')(it)('notEqual with array of pointers', done => {
    const children = [];
    const parents = [];
    const promises = [];
    for (let i = 0; i < 2; i++) {
      const proc = iter => {
        const child = new Parse.Object('Child');
        children.push(child);
        const parent = new Parse.Object('Parent');
        parents.push(parent);
        promises.push(
          child.save().then(() => {
            parents[iter].set('child', [children[iter]]);
            return parents[iter].save();
          })
        );
      };
      proc(i);
    }
    Promise.all(promises)
      .then(() => {
        const query = new Parse.Query('Parent');
        query.notEqualTo('child', children[0]);
        return query.find();
      })
      .then(results => {
        expect(results.length).toEqual(1);
        expect(results[0].id).toEqual(parents[1].id);
        done();
      })
      .catch(error => {
        console.log(error);
      });
  });

  // PG don't support creating a null column
  it_exclude_dbs(['postgres'])('querying for null value', done => {
    const obj = new Parse.Object('TestObject');
    obj.set('aNull', null);
    obj
      .save()
      .then(() => {
        const query = new Parse.Query('TestObject');
        query.equalTo('aNull', null);
        return query.find();
      })
      .then(results => {
        expect(results.length).toEqual(1);
        expect(results[0].get('aNull')).toEqual(null);
        done();
      });
  });

  it('query within dictionary', done => {
    const promises = [];
    for (let i = 0; i < 2; i++) {
      const proc = iter => {
        const obj = new Parse.Object('TestObject');
        obj.set('aDict', { x: iter + 1, y: iter + 2 });
        promises.push(obj.save());
      };
      proc(i);
    }
    Promise.all(promises)
      .then(() => {
        const query = new Parse.Query('TestObject');
        query.equalTo('aDict.x', 1);
        return query.find();
      })
      .then(
        results => {
          expect(results.length).toEqual(1);
          done();
        },
        error => {
          console.log(error);
        }
      );
  });

  it('supports include on the wrong key type (#2262)', function (done) {
    const childObject = new Parse.Object('TestChildObject');
    childObject.set('hello', 'world');
    childObject
      .save()
      .then(() => {
        const obj = new Parse.Object('TestObject');
        obj.set('foo', 'bar');
        obj.set('child', childObject);
        return obj.save();
      })
      .then(() => {
        const q = new Parse.Query('TestObject');
        q.include('child');
        q.include('child.parent');
        q.include('createdAt');
        q.include('createdAt.createdAt');
        return q.find();
      })
      .then(
        objs => {
          expect(objs.length).toBe(1);
          expect(objs[0].get('child').get('hello')).toEqual('world');
          expect(objs[0].createdAt instanceof Date).toBe(true);
          done();
        },
        () => {
          fail('should not fail');
          done();
        }
      );
  });

  it('query match on array with single object', done => {
    const target = {
      __type: 'Pointer',
      className: 'TestObject',
      objectId: 'abc123',
    };
    const obj = new Parse.Object('TestObject');
    obj.set('someObjs', [target]);
    obj
      .save()
      .then(() => {
        const query = new Parse.Query('TestObject');
        query.equalTo('someObjs', target);
        return query.find();
      })
      .then(
        results => {
          expect(results.length).toEqual(1);
          done();
        },
        error => {
          console.log(error);
        }
      );
  });

  it('query match on array with multiple objects', done => {
    const target1 = {
      __type: 'Pointer',
      className: 'TestObject',
      objectId: 'abc',
    };
    const target2 = {
      __type: 'Pointer',
      className: 'TestObject',
      objectId: '123',
    };
    const obj = new Parse.Object('TestObject');
    obj.set('someObjs', [target1, target2]);
    obj
      .save()
      .then(() => {
        const query = new Parse.Query('TestObject');
        query.equalTo('someObjs', target1);
        return query.find();
      })
      .then(
        results => {
          expect(results.length).toEqual(1);
          done();
        },
        error => {
          console.log(error);
        }
      );
  });

  it('query should not match on array when searching for null', done => {
    const target = {
      __type: 'Pointer',
      className: 'TestObject',
      objectId: '123',
    };
    const obj = new Parse.Object('TestObject');
    obj.set('someKey', 'someValue');
    obj.set('someObjs', [target]);
    obj
      .save()
      .then(() => {
        const query = new Parse.Query('TestObject');
        query.equalTo('someKey', 'someValue');
        query.equalTo('someObjs', null);
        return query.find();
      })
      .then(
        results => {
          expect(results.length).toEqual(0);
          done();
        },
        error => {
          console.log(error);
        }
      );
  });

  // #371
  it('should properly interpret a query v1', done => {
    const query = new Parse.Query('C1');
    const auxQuery = new Parse.Query('C1');
    query.matchesKeyInQuery('A1', 'A2', auxQuery);
    query.include('A3');
    query.include('A2');
    query.find().then(
      () => {
        done();
      },
      err => {
        jfail(err);
        fail('should not failt');
        done();
      }
    );
  });

  it_id('7079f0ef-47b3-4a1e-aac0-32654dadaa27')(it)('should properly interpret a query v2', done => {
    const user = new Parse.User();
    user.set('username', 'foo');
    user.set('password', 'bar');
    return user
      .save()
      .then(user => {
        const objIdQuery = new Parse.Query('_User').equalTo('objectId', user.id);
        const blockedUserQuery = user.relation('blockedUsers').query();

        const aResponseQuery = new Parse.Query('MatchRelationshipActivityResponse');
        aResponseQuery.equalTo('userA', user);
        aResponseQuery.equalTo('userAResponse', 1);

        const bResponseQuery = new Parse.Query('MatchRelationshipActivityResponse');
        bResponseQuery.equalTo('userB', user);
        bResponseQuery.equalTo('userBResponse', 1);

        const matchOr = Parse.Query.or(aResponseQuery, bResponseQuery);
        const matchRelationshipA = new Parse.Query('_User');
        matchRelationshipA.matchesKeyInQuery('objectId', 'userAObjectId', matchOr);
        const matchRelationshipB = new Parse.Query('_User');
        matchRelationshipB.matchesKeyInQuery('objectId', 'userBObjectId', matchOr);

        const orQuery = Parse.Query.or(
          objIdQuery,
          blockedUserQuery,
          matchRelationshipA,
          matchRelationshipB
        );
        const query = new Parse.Query('_User');
        query.doesNotMatchQuery('objectId', orQuery);
        return query.find();
      })
      .then(
        () => {
          done();
        },
        err => {
          jfail(err);
          fail('should not fail');
          done();
        }
      );
  });

  it('should match a key in an array (#3195)', function (done) {
    const AuthorObject = Parse.Object.extend('Author');
    const GroupObject = Parse.Object.extend('Group');
    const PostObject = Parse.Object.extend('Post');

    return new AuthorObject()
      .save()
      .then(user => {
        const post = new PostObject({
          author: user,
        });

        const group = new GroupObject({
          members: [user],
        });

        return Promise.all([post.save(), group.save()]);
      })
      .then(results => {
        const p = results[0];
        return new Parse.Query(PostObject)
          .matchesKeyInQuery('author', 'members', new Parse.Query(GroupObject))
          .find()
          .then(r => {
            expect(r.length).toEqual(1);
            if (r.length > 0) {
              expect(r[0].id).toEqual(p.id);
            }
            done();
          }, done.fail);
      });
  });

  it_id('d95818c0-9e3c-41e6-be20-e7bafb59eefb')(it)('should find objects with array of pointers', done => {
    const objects = [];
    while (objects.length != 5) {
      const object = new Parse.Object('ContainedObject');
      object.set('index', objects.length);
      objects.push(object);
    }

    Parse.Object.saveAll(objects)
      .then(objects => {
        const container = new Parse.Object('Container');
        const pointers = objects.map(obj => {
          return {
            __type: 'Pointer',
            className: 'ContainedObject',
            objectId: obj.id,
          };
        });
        container.set('objects', pointers);
        const container2 = new Parse.Object('Container');
        container2.set('objects', pointers.slice(2, 3));
        return Parse.Object.saveAll([container, container2]);
      })
      .then(() => {
        const inQuery = new Parse.Query('ContainedObject');
        inQuery.greaterThanOrEqualTo('index', 1);
        const query = new Parse.Query('Container');
        query.matchesQuery('objects', inQuery);
        return query.find();
      })
      .then(results => {
        if (results) {
          expect(results.length).toBe(2);
        }
        done();
      })
      .catch(err => {
        jfail(err);
        fail('should not fail');
        done();
      });
  });

  it('query with two OR subqueries (regression test #1259)', done => {
    const relatedObject = new Parse.Object('Class2');
    relatedObject
      .save()
      .then(relatedObject => {
        const anObject = new Parse.Object('Class1');
        const relation = anObject.relation('relation');
        relation.add(relatedObject);
        return anObject.save();
      })
      .then(anObject => {
        const q1 = anObject.relation('relation').query();
        q1.doesNotExist('nonExistantKey1');
        const q2 = anObject.relation('relation').query();
        q2.doesNotExist('nonExistantKey2');
        Parse.Query.or(q1, q2)
          .find()
          .then(results => {
            expect(results.length).toEqual(1);
            if (results.length == 1) {
              expect(results[0].objectId).toEqual(q1.objectId);
            }
            done();
          });
      });
  });

  it('objectId containedIn with multiple large array', done => {
    const obj = new Parse.Object('MyClass');
    obj
      .save()
      .then(obj => {
        const longListOfStrings = [];
        for (let i = 0; i < 130; i++) {
          longListOfStrings.push(i.toString());
        }
        longListOfStrings.push(obj.id);
        const q = new Parse.Query('MyClass');
        q.containedIn('objectId', longListOfStrings);
        q.containedIn('objectId', longListOfStrings);
        return q.find();
      })
      .then(results => {
        expect(results.length).toEqual(1);
        done();
      });
  });

  it('containedIn with pointers should work with string array', done => {
    const obj = new Parse.Object('MyClass');
    const child = new Parse.Object('Child');
    child
      .save()
      .then(() => {
        obj.set('child', child);
        return obj.save();
      })
      .then(() => {
        const objs = [];
        for (let i = 0; i < 10; i++) {
          objs.push(new Parse.Object('MyClass'));
        }
        return Parse.Object.saveAll(objs);
      })
      .then(() => {
        const query = new Parse.Query('MyClass');
        query.containedIn('child', [child.id]);
        return query.find();
      })
      .then(results => {
        expect(results.length).toBe(1);
      })
      .then(done)
      .catch(done.fail);
  });

  it('containedIn with pointers should work with string array, with many objects', done => {
    const objs = [];
    const children = [];
    for (let i = 0; i < 10; i++) {
      const obj = new Parse.Object('MyClass');
      const child = new Parse.Object('Child');
      objs.push(obj);
      children.push(child);
    }
    Parse.Object.saveAll(children)
      .then(() => {
        return Parse.Object.saveAll(
          objs.map((obj, i) => {
            obj.set('child', children[i]);
            return obj;
          })
        );
      })
      .then(() => {
        const query = new Parse.Query('MyClass');
        const subset = children.slice(0, 5).map(child => {
          return child.id;
        });
        query.containedIn('child', subset);
        return query.find();
      })
      .then(results => {
        expect(results.length).toBe(5);
      })
      .then(done)
      .catch(done.fail);
  });

  it('include for specific object', function (done) {
    const child = new Parse.Object('Child');
    const parent = new Parse.Object('Parent');
    child.set('foo', 'bar');
    parent.set('child', child);
    Parse.Object.saveAll([child, parent]).then(function (response) {
      const savedParent = response[1];
      const parentQuery = new Parse.Query('Parent');
      parentQuery.include('child');
      parentQuery.get(savedParent.id).then(function (parentObj) {
        const childPointer = parentObj.get('child');
        ok(childPointer);
        equal(childPointer.get('foo'), 'bar');
        done();
      });
    });
  });

  it('select keys for specific object', function (done) {
    const Foobar = new Parse.Object('Foobar');
    Foobar.set('foo', 'bar');
    Foobar.set('fizz', 'buzz');
    Foobar.save().then(function (savedFoobar) {
      const foobarQuery = new Parse.Query('Foobar');
      foobarQuery.select('fizz');
      foobarQuery.get(savedFoobar.id).then(function (foobarObj) {
        equal(foobarObj.get('fizz'), 'buzz');
        equal(foobarObj.get('foo'), undefined);
        done();
      });
    });
  });

  it('select nested keys (issue #1567)', function (done) {
    const Foobar = new Parse.Object('Foobar');
    const BarBaz = new Parse.Object('Barbaz');
    BarBaz.set('key', 'value');
    BarBaz.set('otherKey', 'value');
    BarBaz.save()
      .then(() => {
        Foobar.set('foo', 'bar');
        Foobar.set('fizz', 'buzz');
        Foobar.set('barBaz', BarBaz);
        return Foobar.save();
      })
      .then(function (savedFoobar) {
        const foobarQuery = new Parse.Query('Foobar');
        foobarQuery.select(['fizz', 'barBaz.key']);
        foobarQuery.get(savedFoobar.id).then(function (foobarObj) {
          equal(foobarObj.get('fizz'), 'buzz');
          equal(foobarObj.get('foo'), undefined);
          if (foobarObj.has('barBaz')) {
            equal(foobarObj.get('barBaz').get('key'), 'value');
            equal(foobarObj.get('barBaz').get('otherKey'), undefined);
          } else {
            fail('barBaz should be set');
          }
          done();
        });
      });
  });

  it('select nested keys 2 level (issue #1567)', function (done) {
    const Foobar = new Parse.Object('Foobar');
    const BarBaz = new Parse.Object('Barbaz');
    const Bazoo = new Parse.Object('Bazoo');

    Bazoo.set('some', 'thing');
    Bazoo.set('otherSome', 'value');
    Bazoo.save()
      .then(() => {
        BarBaz.set('key', 'value');
        BarBaz.set('otherKey', 'value');
        BarBaz.set('bazoo', Bazoo);
        return BarBaz.save();
      })
      .then(() => {
        Foobar.set('foo', 'bar');
        Foobar.set('fizz', 'buzz');
        Foobar.set('barBaz', BarBaz);
        return Foobar.save();
      })
      .then(function (savedFoobar) {
        const foobarQuery = new Parse.Query('Foobar');
        foobarQuery.select(['fizz', 'barBaz.key', 'barBaz.bazoo.some']);
        foobarQuery.get(savedFoobar.id).then(function (foobarObj) {
          equal(foobarObj.get('fizz'), 'buzz');
          equal(foobarObj.get('foo'), undefined);
          if (foobarObj.has('barBaz')) {
            equal(foobarObj.get('barBaz').get('key'), 'value');
            equal(foobarObj.get('barBaz').get('otherKey'), undefined);
            equal(foobarObj.get('barBaz').get('bazoo').get('some'), 'thing');
            equal(foobarObj.get('barBaz').get('bazoo').get('otherSome'), undefined);
          } else {
            fail('barBaz should be set');
          }
          done();
        });
      });
  });

  it('exclude nested keys', async () => {
    const Foobar = new Parse.Object('Foobar');
    const BarBaz = new Parse.Object('Barbaz');
    BarBaz.set('key', 'value');
    BarBaz.set('otherKey', 'value');
    await BarBaz.save();

    Foobar.set('foo', 'bar');
    Foobar.set('fizz', 'buzz');
    Foobar.set('barBaz', BarBaz);
    const savedFoobar = await Foobar.save();

    const foobarQuery = new Parse.Query('Foobar');
    foobarQuery.exclude(['foo', 'barBaz.otherKey']);
    const foobarObj = await foobarQuery.get(savedFoobar.id);
    equal(foobarObj.get('fizz'), 'buzz');
    equal(foobarObj.get('foo'), undefined);
    if (foobarObj.has('barBaz')) {
      equal(foobarObj.get('barBaz').get('key'), 'value');
      equal(foobarObj.get('barBaz').get('otherKey'), undefined);
    } else {
      fail('barBaz should be set');
    }
  });

  it('exclude nested keys 2 level', async () => {
    const Foobar = new Parse.Object('Foobar');
    const BarBaz = new Parse.Object('Barbaz');
    const Bazoo = new Parse.Object('Bazoo');

    Bazoo.set('some', 'thing');
    Bazoo.set('otherSome', 'value');
    await Bazoo.save();

    BarBaz.set('key', 'value');
    BarBaz.set('otherKey', 'value');
    BarBaz.set('bazoo', Bazoo);
    await BarBaz.save();

    Foobar.set('foo', 'bar');
    Foobar.set('fizz', 'buzz');
    Foobar.set('barBaz', BarBaz);
    const savedFoobar = await Foobar.save();

    const foobarQuery = new Parse.Query('Foobar');
    foobarQuery.exclude(['foo', 'barBaz.otherKey', 'barBaz.bazoo.otherSome']);
    const foobarObj = await foobarQuery.get(savedFoobar.id);
    equal(foobarObj.get('fizz'), 'buzz');
    equal(foobarObj.get('foo'), undefined);
    if (foobarObj.has('barBaz')) {
      equal(foobarObj.get('barBaz').get('key'), 'value');
      equal(foobarObj.get('barBaz').get('otherKey'), undefined);
      equal(foobarObj.get('barBaz').get('bazoo').get('some'), 'thing');
      equal(foobarObj.get('barBaz').get('bazoo').get('otherSome'), undefined);
    } else {
      fail('barBaz should be set');
    }
  });

  it('include with *', async () => {
    const child1 = new TestObject({ foo: 'bar', name: 'ac' });
    const child2 = new TestObject({ foo: 'baz', name: 'flo' });
    const child3 = new TestObject({ foo: 'bad', name: 'mo' });
    const parent = new Container({ child1, child2, child3 });
    await Parse.Object.saveAll([parent, child1, child2, child3]);
    const options = Object.assign({}, masterKeyOptions, {
      qs: {
        where: JSON.stringify({ objectId: parent.id }),
        include: '*',
      },
    });
    const resp = await request(
      Object.assign({ url: Parse.serverURL + '/classes/Container' }, options)
    );
    const result = resp.data.results[0];
    equal(result.child1.foo, 'bar');
    equal(result.child2.foo, 'baz');
    equal(result.child3.foo, 'bad');
    equal(result.child1.name, 'ac');
    equal(result.child2.name, 'flo');
    equal(result.child3.name, 'mo');
  });

  it('include with [""*""]', async () => {
    const child1 = new TestObject({ foo: 'bar', name: 'ac' });
    const child2 = new TestObject({ foo: 'baz', name: 'flo' });
    const child3 = new TestObject({ foo: 'bad', name: 'mo' });
    const parent = new Container({ child1, child2, child3 });
    await Parse.Object.saveAll([parent, child1, child2, child3]);
    const options = Object.assign({}, masterKeyOptions, {
      qs: {
        where: JSON.stringify({ objectId: parent.id }),
        include: '[""*""]',
      },
    });
    const resp = await request(
      Object.assign({ url: Parse.serverURL + '/classes/Container' }, options)
    );
    const result = resp.data.results[0];
    equal(result.child1.foo, 'bar');
    equal(result.child2.foo, 'baz');
    equal(result.child3.foo, 'bad');
    equal(result.child1.name, 'ac');
    equal(result.child2.name, 'flo');
    equal(result.child3.name, 'mo');
  });

  it('include with * overrides', async () => {
    const child1 = new TestObject({ foo: 'bar', name: 'ac' });
    const child2 = new TestObject({ foo: 'baz', name: 'flo' });
    const child3 = new TestObject({ foo: 'bad', name: 'mo' });
    const parent = new Container({ child1, child2, child3 });
    await Parse.Object.saveAll([parent, child1, child2, child3]);
    const options = Object.assign({}, masterKeyOptions, {
      qs: {
        where: JSON.stringify({ objectId: parent.id }),
        include: 'child2,*',
      },
    });
    const resp = await request(
      Object.assign({ url: Parse.serverURL + '/classes/Container' }, options)
    );
    const result = resp.data.results[0];
    equal(result.child1.foo, 'bar');
    equal(result.child2.foo, 'baz');
    equal(result.child3.foo, 'bad');
    equal(result.child1.name, 'ac');
    equal(result.child2.name, 'flo');
    equal(result.child3.name, 'mo');
  });

  it('include with [""*""] overrides', async () => {
    const child1 = new TestObject({ foo: 'bar', name: 'ac' });
    const child2 = new TestObject({ foo: 'baz', name: 'flo' });
    const child3 = new TestObject({ foo: 'bad', name: 'mo' });
    const parent = new Container({ child1, child2, child3 });
    await Parse.Object.saveAll([parent, child1, child2, child3]);
    const options = Object.assign({}, masterKeyOptions, {
      qs: {
        where: JSON.stringify({ objectId: parent.id }),
        include: '[""child2"",""*""]',
      },
    });
    const resp = await request(
      Object.assign({ url: Parse.serverURL + '/classes/Container' }, options)
    );
    const result = resp.data.results[0];
    equal(result.child1.foo, 'bar');
    equal(result.child2.foo, 'baz');
    equal(result.child3.foo, 'bad');
    equal(result.child1.name, 'ac');
    equal(result.child2.name, 'flo');
    equal(result.child3.name, 'mo');
  });

  it('includeAll', done => {
    const child1 = new TestObject({ foo: 'bar', name: 'ac' });
    const child2 = new TestObject({ foo: 'baz', name: 'flo' });
    const child3 = new TestObject({ foo: 'bad', name: 'mo' });
    const parent = new Container({ child1, child2, child3 });
    Parse.Object.saveAll([parent, child1, child2, child3])
      .then(() => {
        const options = Object.assign({}, masterKeyOptions, {
          qs: {
            where: JSON.stringify({ objectId: parent.id }),
            includeAll: true,
          },
        });
        return request(Object.assign({ url: Parse.serverURL + '/classes/Container' }, options));
      })
      .then(resp => {
        const result = resp.data.results[0];
        equal(result.child1.foo, 'bar');
        equal(result.child2.foo, 'baz');
        equal(result.child3.foo, 'bad');
        equal(result.child1.name, 'ac');
        equal(result.child2.name, 'flo');
        equal(result.child3.name, 'mo');
        done();
      });
  });

  it('include pointer and pointer array', function (done) {
    const child = new TestObject();
    const child2 = new TestObject();
    child.set('foo', 'bar');
    child2.set('hello', 'world');
    Parse.Object.saveAll([child, child2]).then(function () {
      const parent = new Container();
      parent.set('child', child.toPointer());
      parent.set('child2', [child2.toPointer()]);
      parent.save().then(function () {
        const query = new Parse.Query(Container);
        query.include(['child', 'child2']);
        query.find().then(function (results) {
          equal(results.length, 1);
          const parentAgain = results[0];
          const childAgain = parentAgain.get('child');
          ok(childAgain);
          equal(childAgain.get('foo'), 'bar');
          const child2Again = parentAgain.get('child2');
          equal(child2Again.length, 1);
          ok(child2Again);
          equal(child2Again[0].get('hello'), 'world');
          done();
        });
      });
    });
  });

  it('include pointer and pointer array (keys switched)', function (done) {
    const child = new TestObject();
    const child2 = new TestObject();
    child.set('foo', 'bar');
    child2.set('hello', 'world');
    Parse.Object.saveAll([child, child2]).then(function () {
      const parent = new Container();
      parent.set('child', child.toPointer());
      parent.set('child2', [child2.toPointer()]);
      parent.save().then(function () {
        const query = new Parse.Query(Container);
        query.include(['child2', 'child']);
        query.find().then(function (results) {
          equal(results.length, 1);
          const parentAgain = results[0];
          const childAgain = parentAgain.get('child');
          ok(childAgain);
          equal(childAgain.get('foo'), 'bar');
          const child2Again = parentAgain.get('child2');
          equal(child2Again.length, 1);
          ok(child2Again);
          equal(child2Again[0].get('hello'), 'world');
          done();
        });
      });
    });
  });

  it('includeAll pointer and pointer array', function (done) {
    const child = new TestObject();
    const child2 = new TestObject();
    child.set('foo', 'bar');
    child2.set('hello', 'world');
    Parse.Object.saveAll([child, child2]).then(function () {
      const parent = new Container();
      parent.set('child', child.toPointer());
      parent.set('child2', [child2.toPointer()]);
      parent.save().then(function () {
        const query = new Parse.Query(Container);
        query.includeAll();
        query.find().then(function (results) {
          equal(results.length, 1);
          const parentAgain = results[0];
          const childAgain = parentAgain.get('child');
          ok(childAgain);
          equal(childAgain.get('foo'), 'bar');
          const child2Again = parentAgain.get('child2');
          equal(child2Again.length, 1);
          ok(child2Again);
          equal(child2Again[0].get('hello'), 'world');
          done();
        });
      });
    });
  });

  it('select nested keys 2 level includeAll', done => {
    const Foobar = new Parse.Object('Foobar');
    const BarBaz = new Parse.Object('Barbaz');
    const Bazoo = new Parse.Object('Bazoo');
    const Tang = new Parse.Object('Tang');

    Bazoo.set('some', 'thing');
    Bazoo.set('otherSome', 'value');
    Bazoo.save()
      .then(() => {
        BarBaz.set('key', 'value');
        BarBaz.set('otherKey', 'value');
        BarBaz.set('bazoo', Bazoo);
        return BarBaz.save();
      })
      .then(() => {
        Tang.set('clan', 'wu');
        return Tang.save();
      })
      .then(() => {
        Foobar.set('foo', 'bar');
        Foobar.set('fizz', 'buzz');
        Foobar.set('barBaz', BarBaz);
        Foobar.set('group', Tang);
        return Foobar.save();
      })
      .then(savedFoobar => {
        const options = Object.assign(
          {
            url: Parse.serverURL + '/classes/Foobar',
          },
          masterKeyOptions,
          {
            qs: {
              where: JSON.stringify({ objectId: savedFoobar.id }),
              includeAll: true,
              keys: 'fizz,barBaz.key,barBaz.bazoo.some',
            },
          }
        );
        return request(options);
      })
      .then(resp => {
        const result = resp.data.results[0];
        equal(result.group.clan, 'wu');
        equal(result.foo, undefined);
        equal(result.fizz, 'buzz');
        equal(result.barBaz.key, 'value');
        equal(result.barBaz.otherKey, undefined);
        equal(result.barBaz.bazoo.some, 'thing');
        equal(result.barBaz.bazoo.otherSome, undefined);
        done();
      })
      .catch(done.fail);
  });

  it('select nested keys 2 level without include (issue #3185)', function (done) {
    const Foobar = new Parse.Object('Foobar');
    const BarBaz = new Parse.Object('Barbaz');
    const Bazoo = new Parse.Object('Bazoo');

    Bazoo.set('some', 'thing');
    Bazoo.set('otherSome', 'value');
    Bazoo.save()
      .then(() => {
        BarBaz.set('key', 'value');
        BarBaz.set('otherKey', 'value');
        BarBaz.set('bazoo', Bazoo);
        return BarBaz.save();
      })
      .then(() => {
        Foobar.set('foo', 'bar');
        Foobar.set('fizz', 'buzz');
        Foobar.set('barBaz', BarBaz);
        return Foobar.save();
      })
      .then(function (savedFoobar) {
        const foobarQuery = new Parse.Query('Foobar');
        foobarQuery.select(['fizz', 'barBaz.key', 'barBaz.bazoo.some']);
        return foobarQuery.get(savedFoobar.id);
      })
      .then(foobarObj => {
        equal(foobarObj.get('fizz'), 'buzz');
        equal(foobarObj.get('foo'), undefined);
        if (foobarObj.has('barBaz')) {
          equal(foobarObj.get('barBaz').get('key'), 'value');
          equal(foobarObj.get('barBaz').get('otherKey'), undefined);
          if (foobarObj.get('barBaz').has('bazoo')) {
            equal(foobarObj.get('barBaz').get('bazoo').get('some'), 'thing');
            equal(foobarObj.get('barBaz').get('bazoo').get('otherSome'), undefined);
          } else {
            fail('bazoo should be set');
          }
        } else {
          fail('barBaz should be set');
        }
        done();
      });
  });

  it('properly handles nested ors', function (done) {
    const objects = [];
    while (objects.length != 4) {
      const obj = new Parse.Object('Object');
      obj.set('x', objects.length);
      objects.push(obj);
    }
    Parse.Object.saveAll(objects)
      .then(() => {
        const q0 = new Parse.Query('Object');
        q0.equalTo('x', 0);
        const q1 = new Parse.Query('Object');
        q1.equalTo('x', 1);
        const q2 = new Parse.Query('Object');
        q2.equalTo('x', 2);
        const or01 = Parse.Query.or(q0, q1);
        return Parse.Query.or(or01, q2).find();
      })
      .then(results => {
        expect(results.length).toBe(3);
        done();
      })
      .catch(error => {
        fail('should not fail');
        jfail(error);
        done();
      });
  });

  it('should not depend on parameter order #3169', function (done) {
    const score1 = new Parse.Object('Score', { scoreId: '1' });
    const score2 = new Parse.Object('Score', { scoreId: '2' });
    const game1 = new Parse.Object('Game', { gameId: '1' });
    const game2 = new Parse.Object('Game', { gameId: '2' });
    Parse.Object.saveAll([score1, score2, game1, game2])
      .then(() => {
        game1.set('score', [score1]);
        game2.set('score', [score2]);
        return Parse.Object.saveAll([game1, game2]);
      })
      .then(() => {
        const where = {
          score: {
            objectId: score1.id,
            className: 'Score',
            __type: 'Pointer',
          },
        };
        return request({
          method: 'POST',
          url: Parse.serverURL + '/classes/Game',
          body: { where, _method: 'GET' },
          headers: {
            'X-Parse-Application-Id': Parse.applicationId,
            'X-Parse-Javascript-Key': Parse.javaScriptKey,
            'Content-Type': 'application/json',
          },
        });
      })
      .then(
        response => {
          const results = response.data;
          expect(results.results.length).toBe(1);
          done();
        },
        res => done.fail(res.data)
      );
  });

  it('should not interfere with has when using select on field with undefined value #3999', done => {
    const obj1 = new Parse.Object('TestObject');
    const obj2 = new Parse.Object('OtherObject');
    obj2.set('otherField', 1);
    obj1.set('testPointerField', obj2);
    obj1.set('shouldBe', true);
    const obj3 = new Parse.Object('TestObject');
    obj3.set('shouldBe', false);
    Parse.Object.saveAll([obj1, obj3])
      .then(() => {
        const query = new Parse.Query('TestObject');
        query.include('testPointerField');
        query.select(['testPointerField', 'testPointerField.otherField', 'shouldBe']);
        return query.find();
      })
      .then(results => {
        results.forEach(result => {
          equal(result.has('testPointerField'), result.get('shouldBe'));
        });
        done();
      })
      .catch(done.fail);
  });

  it('should handle relative times correctly', async () => {
    const now = Date.now();
    const obj1 = new Parse.Object('MyCustomObject', {
      name: 'obj1',
      ttl: new Date(now + 2 * 24 * 60 * 60 * 1000), // 2 days from now
    });
    const obj2 = new Parse.Object('MyCustomObject', {
      name: 'obj2',
      ttl: new Date(now - 2 * 24 * 60 * 60 * 1000), // 2 days ago
    });

    await Parse.Object.saveAll([obj1, obj2]);
    const q1 = new Parse.Query('MyCustomObject');
    q1.greaterThan('ttl', { $relativeTime: 'in 1 day' });
    const results1 = await q1.find({ useMasterKey: true });
    expect(results1.length).toBe(1);

    const q2 = new Parse.Query('MyCustomObject');
    q2.greaterThan('ttl', { $relativeTime: '1 day ago' });
    const results2 = await q2.find({ useMasterKey: true });
    expect(results2.length).toBe(1);

    const q3 = new Parse.Query('MyCustomObject');
    q3.lessThan('ttl', { $relativeTime: '5 days ago' });
    const results3 = await q3.find({ useMasterKey: true });
    expect(results3.length).toBe(0);

    const q4 = new Parse.Query('MyCustomObject');
    q4.greaterThan('ttl', { $relativeTime: '3 days ago' });
    const results4 = await q4.find({ useMasterKey: true });
    expect(results4.length).toBe(2);

    const q5 = new Parse.Query('MyCustomObject');
    q5.greaterThan('ttl', { $relativeTime: 'now' });
    const results5 = await q5.find({ useMasterKey: true });
    expect(results5.length).toBe(1);

    const q6 = new Parse.Query('MyCustomObject');
    q6.greaterThan('ttl', { $relativeTime: 'now' });
    q6.lessThan('ttl', { $relativeTime: 'in 1 day' });
    const results6 = await q6.find({ useMasterKey: true });
    expect(results6.length).toBe(0);

    const q7 = new Parse.Query('MyCustomObject');
    q7.greaterThan('ttl', { $relativeTime: '1 year 3 weeks ago' });
    const results7 = await q7.find({ useMasterKey: true });
    expect(results7.length).toBe(2);
  });

  it('should error on invalid relative time', async () => {
    const obj1 = new Parse.Object('MyCustomObject', {
      name: 'obj1',
      ttl: new Date(Date.now() + 2 * 24 * 60 * 60 * 1000), // 2 days from now
    });
    await obj1.save({ useMasterKey: true });
    const q = new Parse.Query('MyCustomObject');
    q.greaterThan('ttl', { $relativeTime: '-12 bananas ago' });
    try {
      await q.find({ useMasterKey: true });
      fail('Should have thrown error');
    } catch (error) {
      expect(error.code).toBe(Parse.Error.INVALID_JSON);
    }
  });

  it('should error when using $relativeTime on non-Date field', async () => {
    const obj1 = new Parse.Object('MyCustomObject', {
      name: 'obj1',
      nonDateField: 'abcd',
      ttl: new Date(Date.now() + 2 * 24 * 60 * 60 * 1000), // 2 days from now
    });
    await obj1.save({ useMasterKey: true });
    const q = new Parse.Query('MyCustomObject');
    q.greaterThan('nonDateField', { $relativeTime: '1 day ago' });
    try {
      await q.find({ useMasterKey: true });
      fail('Should have thrown error');
    } catch (error) {
      expect(error.code).toBe(Parse.Error.INVALID_JSON);
    }
  });

  it('should match complex structure with dot notation when using matchesKeyInQuery', function (done) {
    const group1 = new Parse.Object('Group', {
      name: 'Group #1',
    });

    const group2 = new Parse.Object('Group', {
      name: 'Group #2',
    });

    Parse.Object.saveAll([group1, group2])
      .then(() => {
        const role1 = new Parse.Object('Role', {
          name: 'Role #1',
          type: 'x',
          belongsTo: group1,
        });

        const role2 = new Parse.Object('Role', {
          name: 'Role #2',
          type: 'y',
          belongsTo: group1,
        });

        return Parse.Object.saveAll([role1, role2]);
      })
      .then(() => {
        const rolesOfTypeX = new Parse.Query('Role');
        rolesOfTypeX.equalTo('type', 'x');

        const groupsWithRoleX = new Parse.Query('Group');
        groupsWithRoleX.matchesKeyInQuery('objectId', 'belongsTo.objectId', rolesOfTypeX);

        groupsWithRoleX.find().then(function (results) {
          equal(results.length, 1);
          equal(results[0].get('name'), group1.get('name'));
          done();
        });
      });
  });

  it('should match complex structure with dot notation when using doesNotMatchKeyInQuery', function (done) {
    const group1 = new Parse.Object('Group', {
      name: 'Group #1',
    });

    const group2 = new Parse.Object('Group', {
      name: 'Group #2',
    });

    Parse.Object.saveAll([group1, group2])
      .then(() => {
        const role1 = new Parse.Object('Role', {
          name: 'Role #1',
          type: 'x',
          belongsTo: group1,
        });

        const role2 = new Parse.Object('Role', {
          name: 'Role #2',
          type: 'y',
          belongsTo: group1,
        });

        return Parse.Object.saveAll([role1, role2]);
      })
      .then(() => {
        const rolesOfTypeX = new Parse.Query('Role');
        rolesOfTypeX.equalTo('type', 'x');

        const groupsWithRoleX = new Parse.Query('Group');
        groupsWithRoleX.doesNotMatchKeyInQuery('objectId', 'belongsTo.objectId', rolesOfTypeX);

        groupsWithRoleX.find().then(function (results) {
          equal(results.length, 1);
          equal(results[0].get('name'), group2.get('name'));
          done();
        });
      });
  });

  it('should not throw error with undefined dot notation when using matchesKeyInQuery', async () => {
    const group = new Parse.Object('Group', { name: 'Group #1' });
    await group.save();

    const role1 = new Parse.Object('Role', {
      name: 'Role #1',
      type: 'x',
      belongsTo: group,
    });

    const role2 = new Parse.Object('Role', {
      name: 'Role #2',
      type: 'y',
      belongsTo: undefined,
    });
    await Parse.Object.saveAll([role1, role2]);

    const rolesOfTypeX = new Parse.Query('Role');
    rolesOfTypeX.equalTo('type', 'x');

    const groupsWithRoleX = new Parse.Query('Group');
    groupsWithRoleX.matchesKeyInQuery('objectId', 'belongsTo.objectId', rolesOfTypeX);

    const results = await groupsWithRoleX.find();
    equal(results.length, 1);
    equal(results[0].get('name'), group.get('name'));
  });

  it('should not throw error with undefined dot notation when using doesNotMatchKeyInQuery', async () => {
    const group1 = new Parse.Object('Group', { name: 'Group #1' });
    const group2 = new Parse.Object('Group', { name: 'Group #2' });
    await Parse.Object.saveAll([group1, group2]);

    const role1 = new Parse.Object('Role', {
      name: 'Role #1',
      type: 'x',
      belongsTo: group1,
    });

    const role2 = new Parse.Object('Role', {
      name: 'Role #2',
      type: 'y',
      belongsTo: undefined,
    });
    await Parse.Object.saveAll([role1, role2]);

    const rolesOfTypeX = new Parse.Query('Role');
    rolesOfTypeX.equalTo('type', 'x');

    const groupsWithRoleX = new Parse.Query('Group');
    groupsWithRoleX.doesNotMatchKeyInQuery('objectId', 'belongsTo.objectId', rolesOfTypeX);

    const results = await groupsWithRoleX.find();
    equal(results.length, 1);
    equal(results[0].get('name'), group2.get('name'));
  });

  it_id('8886b994-fbb8-487d-a863-43bbd2b24b73')(it)('withJSON supports geoWithin.centerSphere', done => {
    const inbound = new Parse.GeoPoint(1.5, 1.5);
    const onbound = new Parse.GeoPoint(10, 10);
    const outbound = new Parse.GeoPoint(20, 20);
    const obj1 = new Parse.Object('TestObject', { location: inbound });
    const obj2 = new Parse.Object('TestObject', { location: onbound });
    const obj3 = new Parse.Object('TestObject', { location: outbound });
    const center = new Parse.GeoPoint(0, 0);
    const distanceInKilometers = 1569 + 1; // 1569km is the approximate distance between {0, 0} and {10, 10}.
    Parse.Object.saveAll([obj1, obj2, obj3])
      .then(() => {
        const q = new Parse.Query(TestObject);
        const jsonQ = q.toJSON();
        jsonQ.where.location = {
          $geoWithin: {
            $centerSphere: [center, distanceInKilometers / 6371.0],
          },
        };
        q.withJSON(jsonQ);
        return q.find();
      })
      .then(results => {
        equal(results.length, 2);
        const q = new Parse.Query(TestObject);
        const jsonQ = q.toJSON();
        jsonQ.where.location = {
          $geoWithin: {
            $centerSphere: [[0, 0], distanceInKilometers / 6371.0],
          },
        };
        q.withJSON(jsonQ);
        return q.find();
      })
      .then(results => {
        equal(results.length, 2);
        done();
      })
      .catch(error => {
        fail(error);
        done();
      });
  });

  it('withJSON with geoWithin.centerSphere fails without parameters', done => {
    const q = new Parse.Query(TestObject);
    const jsonQ = q.toJSON();
    jsonQ.where.location = {
      $geoWithin: {
        $centerSphere: [],
      },
    };
    q.withJSON(jsonQ);
    q.find()
      .then(done.fail)
      .catch(e => expect(e.code).toBe(Parse.Error.INVALID_JSON))
      .then(done);
  });

  it('withJSON with geoWithin.centerSphere fails with invalid distance', done => {
    const q = new Parse.Query(TestObject);
    const jsonQ = q.toJSON();
    jsonQ.where.location = {
      $geoWithin: {
        $centerSphere: [[0, 0], 'invalid_distance'],
      },
    };
    q.withJSON(jsonQ);
    q.find()
      .then(done.fail)
      .catch(e => expect(e.code).toBe(Parse.Error.INVALID_JSON))
      .then(done);
  });

  it('withJSON with geoWithin.centerSphere fails with invalid coordinate', done => {
    const q = new Parse.Query(TestObject);
    const jsonQ = q.toJSON();
    jsonQ.where.location = {
      $geoWithin: {
        $centerSphere: [[-190, -190], 1],
      },
    };
    q.withJSON(jsonQ);
    q.find()
      .then(done.fail)
      .catch(() => done());
  });

  it('withJSON with geoWithin.centerSphere fails with invalid geo point', done => {
    const q = new Parse.Query(TestObject);
    const jsonQ = q.toJSON();
    jsonQ.where.location = {
      $geoWithin: {
        $centerSphere: [{ longitude: 0, dummytude: 0 }, 1],
      },
    };
    q.withJSON(jsonQ);
    q.find()
      .then(done.fail)
      .catch(() => done());
  });

  it_id('02d4e7e6-859a-4ab6-878d-135ccc77040e')(it)('can add new config to existing config', async () => {
    await request({
      method: 'PUT',
      url: 'http://localhost:8378/1/config',
      json: true,
      body: {
        params: {
          files: [{ __type: 'File', name: 'name', url: 'http://url' }],
        },
      },
      headers: masterKeyHeaders,
    });

    await request({
      method: 'PUT',
      url: 'http://localhost:8378/1/config',
      json: true,
      body: {
        params: { newConfig: 'good' },
      },
      headers: masterKeyHeaders,
    });

    const result = await Parse.Config.get();
    equal(result.get('files')[0].toJSON(), {
      __type: 'File',
      name: 'name',
      url: 'http://url',
    });
    equal(result.get('newConfig'), 'good');
  });

  it('can set object type key', async () => {
    const data = { bar: true, baz: 100 };
    const object = new TestObject();
    object.set('objectField', data);
    await object.save();

    const query = new Parse.Query(TestObject);
    let result = await query.get(object.id);
    equal(result.get('objectField'), data);

    object.set('objectField.baz', 50, { ignoreValidation: true });
    await object.save();

    result = await query.get(object.id);
    equal(result.get('objectField'), { bar: true, baz: 50 });
  });

  it('can update numeric array', async () => {
    const data1 = [0, 1.1, 1, -2, 3];
    const data2 = [0, 1.1, 1, -2, 3, 4];
    const obj1 = new TestObject();
    obj1.set('array', data1);
    await obj1.save();
    equal(obj1.get('array'), data1);

    const query = new Parse.Query(TestObject);
    query.equalTo('objectId', obj1.id);

    const result = await query.first();
    equal(result.get('array'), data1);

    result.set('array', data2);
    equal(result.get('array'), data2);
    await result.save();
    equal(result.get('array'), data2);

    const results = await query.find();
    equal(results[0].get('array'), data2);
  });

  it('can update mixed array', async () => {
    const data1 = [0, 1.1, 'hello world', { foo: 'bar' }];
    const data2 = [0, 1, { foo: 'bar' }, [], [1, 2, 'bar']];
    const obj1 = new TestObject();
    obj1.set('array', data1);
    await obj1.save();
    equal(obj1.get('array'), data1);

    const query = new Parse.Query(TestObject);
    query.equalTo('objectId', obj1.id);

    const result = await query.first();
    equal(result.get('array'), data1);

    result.set('array', data2);
    equal(result.get('array'), data2);

    await result.save();
    equal(result.get('array'), data2);

    const results = await query.find();
    equal(results[0].get('array'), data2);
  });

  it('can query regex with unicode', async () => {
    const object = new TestObject();
    object.set('field', 'autoöo');
    await object.save();

    const query = new Parse.Query(TestObject);
    query.contains('field', 'autoöo');
    const results = await query.find();

    expect(results.length).toBe(1);
    expect(results[0].get('field')).toBe('autoöo');
  });

  it('can update mixed array more than 100 elements', async () => {
    const array = [0, 1.1, 'hello world', { foo: 'bar' }, null];
    const obj = new TestObject({ array });
    await obj.save();

    const query = new Parse.Query(TestObject);
    const result = await query.get(obj.id);
    equal(result.get('array').length, 5);

    for (let i = 0; i < 100; i += 1) {
      array.push(i);
    }
    obj.set('array', array);
    await obj.save();

    const results = await query.find();
    equal(results[0].get('array').length, 105);
  });

  xit('todo: exclude keys with select key (sdk query get)', async done => {
    // there is some problem with js sdk caching

    const obj = new TestObject({ foo: 'baz', hello: 'world' });
    await obj.save();

    const query = new Parse.Query('TestObject');

    query.withJSON({
      keys: 'hello',
      excludeKeys: 'hello',
    });

    const object = await query.get(obj.id);
    expect(object.get('foo')).toBeUndefined();
    expect(object.get('hello')).toBeUndefined();
    done();
  });

  it_only_db('mongo')('can use explain on User class', async () => {
    // Create user
    const user = new Parse.User();
    user.set('username', 'foo');
    user.set('password', 'bar');
    await user.save();
    // Query for user with explain
    const query = new Parse.Query('_User');
    query.equalTo('objectId', user.id);
    query.explain();
    const result = await query.find();
    // Validate
    expect(result.executionStats).not.toBeUndefined();
  });

  it('should query with distinct within eachBatch and direct access enabled', async () => {
    await reconfigureServer({
      directAccess: true,
    });

    Parse.CoreManager.setRESTController(
      ParseServerRESTController(Parse.applicationId, ParseServer.promiseRouter({ appId: Parse.applicationId }))
    );

    const user = new Parse.User();
    user.set('username', 'foo');
    user.set('password', 'bar');
    await user.save();

    const score = new Parse.Object('Score');
    score.set('player', user);
    score.set('score', 1);
    await score.save();

    await new Parse.Query('_User')
      .equalTo('objectId', user.id)
      .eachBatch(async ([user]) => {
        const score = await new Parse.Query('Score')
          .equalTo('player', user)
          .distinct('score', { useMasterKey: true });
        expect(score).toEqual([1]);
      }, { useMasterKey: true });
  });

  describe_only_db('mongo')('query nested keys', () => {
    it('queries nested key using equalTo', async () => {
      const child = new Parse.Object('Child');
      child.set('key', 'value');
      await child.save();

      const parent = new Parse.Object('Parent');
      parent.set('some', {
        nested: {
          key: {
            child,
          },
        },
      });
      await parent.save();

      const query1 = await new Parse.Query('Parent')
        .equalTo('some.nested.key.child', child)
        .find();

      expect(query1.length).toEqual(1);
    });

    it('queries nested key using containedIn', async () => {
      const child = new Parse.Object('Child');
      child.set('key', 'value');
      await child.save();

      const parent = new Parse.Object('Parent');
      parent.set('some', {
        nested: {
          key: {
            child,
          },
        },
      });
      await parent.save();

      const query1 = await new Parse.Query('Parent')
        .containedIn('some.nested.key.child', [child])
        .find();

      expect(query1.length).toEqual(1);
    });

    it('queries nested key using matchesQuery', async () => {
      const child = new Parse.Object('Child');
      child.set('key', 'value');
      await child.save();

      const parent = new Parse.Object('Parent');
      parent.set('some', {
        nested: {
          key: {
            child,
          },
        },
      });
      await parent.save();

      const query1 = await new Parse.Query('Parent')
        .matchesQuery('some.nested.key.child', new Parse.Query('Child').equalTo('key', 'value'))
        .find();

      expect(query1.length).toEqual(1);
    });
  });

  describe('allowPublicExplain', () => {
    it_id('a1b2c3d4-e5f6-4a7b-8c9d-0e1f2a3b4c5d')(it_only_db('mongo'))(
      'explain works with and without master key when allowPublicExplain is true',
      async () => {
        await reconfigureServer({
          databaseAdapter: undefined,
          databaseURI: 'mongodb://localhost:27017/parse',
          databaseOptions: {
            allowPublicExplain: true,
          },
        });

        const obj = new TestObject({ foo: 'bar' });
        await obj.save();

        // Without master key
        const query = new Parse.Query(TestObject);
        query.explain();
        const resultWithoutMasterKey = await query.find();
        expect(resultWithoutMasterKey).toBeDefined();

        // With master key
        const queryWithMasterKey = new Parse.Query(TestObject);
        queryWithMasterKey.explain();
        const resultWithMasterKey = await queryWithMasterKey.find({ useMasterKey: true });
        expect(resultWithMasterKey).toBeDefined();
      }
    );

    it_id('b2c3d4e5-f6a7-4b8c-9d0e-1f2a3b4c5d6e')(it_only_db('mongo'))(
      'explain requires master key when allowPublicExplain is false',
      async () => {
        await reconfigureServer({
          databaseAdapter: undefined,
          databaseURI: 'mongodb://localhost:27017/parse',
          databaseOptions: {
            allowPublicExplain: false,
          },
        });

        const obj = new TestObject({ foo: 'bar' });
        await obj.save();

        // Without master key
        const query = new Parse.Query(TestObject);
        query.explain();
        await expectAsync(query.find()).toBeRejectedWith(
          new Parse.Error(
            Parse.Error.INVALID_QUERY,
            'Using the explain query parameter requires the master key'
          )
        );

        // With master key
        const queryWithMasterKey = new Parse.Query(TestObject);
        queryWithMasterKey.explain();
        const result = await queryWithMasterKey.find({ useMasterKey: true });
        expect(result).toBeDefined();
      }
    );

    it_id('c3d4e5f6-a7b8-4c9d-0e1f-2a3b4c5d6e7f')(it_only_db('mongo'))(
      'explain works with and without master key by default',
      async () => {
        const logger = require('../lib/logger').logger;
        const logSpy = spyOn(logger, 'warn').and.callFake(() => {});

        await reconfigureServer({
          databaseAdapter: undefined,
          databaseURI: 'mongodb://localhost:27017/parse',
          databaseOptions: {
            allowPublicExplain: undefined,
          },
        });

        // Verify deprecation warning is logged when allowPublicExplain is not explicitly set
        expect(logSpy).toHaveBeenCalledWith(
          jasmine.stringMatching(/DeprecationWarning.*databaseOptions\.allowPublicExplain.*false/)
        );

        const obj = new TestObject({ foo: 'bar' });
        await obj.save();

        // Without master key
        const query = new Parse.Query(TestObject);
        query.explain();
        const resultWithoutMasterKey = await query.find();
        expect(resultWithoutMasterKey).toBeDefined();

        // With master key
        const queryWithMasterKey = new Parse.Query(TestObject);
        queryWithMasterKey.explain();
        const resultWithMasterKey = await queryWithMasterKey.find({ useMasterKey: true });
        expect(resultWithMasterKey).toBeDefined();
      }
    );
  });
});",0
"      expect(group.checks()[0].checkState()).toBe(CheckState.fail);
      expect(group.checks()[1].checkState()).toBe(CheckState.fail);
      expect(group.checks()[2].checkState()).toBe(CheckState.fail);
      expect(group.checks()[4].checkState()).toBe(CheckState.fail);
      expect(group.checks()[5].checkState()).toBe(CheckState.fail);
    });

    it_only_db('mongo')('checks succeed correctly (MongoDB specific)', async () => {
      config.databaseAdapter = undefined;
      config.databaseOptions = { allowPublicExplain: false };
      await reconfigureServer(config);

      const group = new CheckGroupServerConfig();
      await group.run();
      expect(group.checks()[6].checkState()).toBe(CheckState.success);
    });

    it_only_db('mongo')('checks fail correctly (MongoDB specific)', async () => {
      config.databaseAdapter = undefined;
      config.databaseOptions = { allowPublicExplain: true };
      await reconfigureServer(config);

      const group = new CheckGroupServerConfig();
      await group.run();
      expect(group.checks()[6].checkState()).toBe(CheckState.fail);
    });
  });

  describe('CheckGroupDatabase', () => {
    it('is subclassed correctly', async () => {
      const group = new CheckGroupDatabase();
      expect(group.name()).toBeDefined();",0
"    }
    if (databaseOptions.schemaCacheTtl === undefined) {
      databaseOptions.schemaCacheTtl = DatabaseOptions.schemaCacheTtl.default;
    } else if (typeof databaseOptions.schemaCacheTtl !== 'number') {
      throw `databaseOptions.schemaCacheTtl must be a number`;
    }
    if (databaseOptions.allowPublicExplain === undefined) {
      databaseOptions.allowPublicExplain = DatabaseOptions.allowPublicExplain.default;
    } else if (typeof databaseOptions.allowPublicExplain !== 'boolean') {
      throw `Parse Server option 'databaseOptions.allowPublicExplain' must be a boolean.`;
    }
  }

  static validateRateLimit(rateLimit) {
    if (!rateLimit) {
      return;
    }",0
" *
 * If there are no deprecations, this must return an empty array.
 */
module.exports = [
  { optionKey: 'encodeParseObjectInCloudFunction', changeNewDefault: 'true' },
  { optionKey: 'enableInsecureAuthAdapters', changeNewDefault: 'false' },
  { optionKey: 'databaseOptions.allowPublicExplain', changeNewDefault: 'false' },
];",0
"    help:
      'The MongoDB driver event name to listen for. See the [MongoDB driver events documentation](https://www.mongodb.com/docs/drivers/node/current/fundamentals/monitoring/) for available events.',
    required: true,
  },
};
module.exports.DatabaseOptions = {
  allowPublicExplain: {
    env: 'PARSE_SERVER_DATABASE_ALLOW_PUBLIC_EXPLAIN',
    help:
      'Set to `true` to allow `Parse.Query.explain` without master key.<br><br>\u26A0\uFE0F Enabling this option may expose sensitive query performance data to unauthorized users and could potentially be exploited for malicious purposes.',
    action: parsers.booleanParser,
    default: true,
  },
  appName: {
    env: 'PARSE_SERVER_DATABASE_APP_NAME',
    help:
      'The MongoDB driver option to specify the name of the application that created this MongoClient instance.',
  },
  authMechanism: {",0
" * @property {String} logLevel The log level to use for this event. See [LogLevel](LogLevel.html) for available values. Defaults to `'info'`.
 * @property {String} name The MongoDB driver event name to listen for. See the [MongoDB driver events documentation](https://www.mongodb.com/docs/drivers/node/current/fundamentals/monitoring/) for available events.
 */

/**
 * @interface DatabaseOptions
 * @property {Boolean} allowPublicExplain Set to `true` to allow `Parse.Query.explain` without master key.<br><br>⚠️ Enabling this option may expose sensitive query performance data to unauthorized users and could potentially be exploited for malicious purposes.
 * @property {String} appName The MongoDB driver option to specify the name of the application that created this MongoClient instance.
 * @property {String} authMechanism The MongoDB driver option to specify the authentication mechanism that MongoDB will use to authenticate the connection.
 * @property {Any} authMechanismProperties The MongoDB driver option to specify properties for the specified authMechanism as a comma-separated list of colon-separated key-value pairs.
 * @property {String} authSource The MongoDB driver option to specify the database name associated with the user's credentials.
 * @property {Boolean} autoSelectFamily The MongoDB driver option to set whether the socket attempts to connect to IPv6 and IPv4 addresses until a connection is established. If available, the driver will select the first IPv6 address.
 * @property {Number} autoSelectFamilyAttemptTimeout The MongoDB driver option to specify the amount of time in milliseconds to wait for a connection attempt to finish before trying the next address when using the autoSelectFamily option. If set to a positive integer less than 10, the value 10 is used instead.",0
"        check: () => {
          if (config.graphQLPublicIntrospection !== false) {
            throw 1;
          }
        },
      }),
      new Check({
        title: 'Public database explain disabled',
        warning:
          'Database explain queries are publicly accessible, which may expose sensitive database performance information and schema details.',
        solution:
          ""Change Parse Server configuration to 'databaseOptions.allowPublicExplain: false'. You will need to use master key to run explain queries."",
        check: () => {
          if (
            config.databaseOptions?.allowPublicExplain === true ||
            config.databaseOptions?.allowPublicExplain == null
          ) {
            throw 1;
          }
        },
      }),
    ];
  }
}

module.exports = CheckGroupServerConfig;",0
"  clientSDK,
  context,
  options = {}
) {
  const { isGet } = options;

  if (restOptions && restOptions.explain && !auth.isMaster) {
    const allowPublicExplain = config.databaseOptions?.allowPublicExplain ?? true;

    if (!allowPublicExplain) {
      throw new Parse.Error(
        Parse.Error.INVALID_QUERY,
        'Using the explain query parameter requires the master key'
      );
    }
  }

  // Run beforeFind trigger - may modify query or return objects directly
  const result = await triggers.maybeRunQueryTrigger(
    triggers.Types.beforeFind,
    className,
    restWhere,
    restOptions,",0
"    appName?: string;
    authMechanism?: string;
    authMechanismProperties?: any;
    authSource?: string;
    autoSelectFamily?: boolean;
    autoSelectFamilyAttemptTimeout?: number;
    allowPublicExplain?: boolean;
    compressors?: string[] | string;
    connectTimeoutMS?: number;
    directConnection?: boolean;
    forceServerObjectId?: boolean;
    heartbeatFrequencyMS?: number;
    loadBalanced?: boolean;",0
"        expect(response.status).toBe(400);
        const body = response.text;
        expect(body).toEqual('{""code"":122,""error"":""Filename not provided.""}');
        done();
      });
    });

    describe('URI-backed file upload is disabled to prevent SSRF attack', () => {
      const express = require('express');
      let testServer;
      let testServerPort;
      let requestsMade;

      beforeEach(async () => {
        requestsMade = [];
        const app = express();
        app.use((req, res) => {
          requestsMade.push({ url: req.url, method: req.method });
          res.status(200).send('test file content');
        });
        testServer = app.listen(0);
        testServerPort = testServer.address().port;
      });

      afterEach(async () => {
        if (testServer) {
          await new Promise(resolve => testServer.close(resolve));
        }
        Parse.Cloud._removeAllHooks();
      });

      it('does not access URI when file upload attempted over REST', async () => {
        const response = await request({
          method: 'POST',
          url: 'http://localhost:8378/1/classes/TestClass',
          headers: {
            'Content-Type': 'application/json',
            'X-Parse-Application-Id': 'test',
            'X-Parse-REST-API-Key': 'rest',
          },
          body: {
            file: {
              __type: 'File',
              name: 'test.txt',
              _source: {
                format: 'uri',
                uri: `http://127.0.0.1:${testServerPort}/secret-file.txt`,
              },
            },
          },
        });
        expect(response.status).toBe(201);
        // Verify no HTTP request was made to the URI
        expect(requestsMade.length).toBe(0);
      });

      it('does not access URI when file created in beforeSave trigger', async () => {
        Parse.Cloud.beforeSave(Parse.File, () => {
          return new Parse.File('trigger-file.txt', {
            uri: `http://127.0.0.1:${testServerPort}/secret-file.txt`,
          });
        });
        await expectAsync(
          request({
            method: 'POST',
            headers: {
              'Content-Type': 'application/octet-stream',
              'X-Parse-Application-Id': 'test',
              'X-Parse-REST-API-Key': 'rest',
            },
            url: 'http://localhost:8378/1/files/test.txt',
            body: 'test content',
          })
        ).toBeRejectedWith(jasmine.objectContaining({
          status: 400
        }));
        // Verify no HTTP request was made to the URI
        expect(requestsMade.length).toBe(0);
      });
    });
  });

  describe('deleting files', () => {
    it('fails to delete an unkown file', done => {
      const headers = {
        'Content-Type': 'application/octet-stream',",0
"import BodyParser from 'body-parser';
import * as Middlewares from '../middlewares';
import Parse from 'parse/node';
import Config from '../Config';
import logger from '../logger';
const triggers = require('../triggers');
const Utils = require('../Utils');

export class FilesRouter {
  expressRouter({ maxUploadSize = '20Mb' } = {}) {
    var router = express.Router();
    router.get('/files/:appId/:filename', this.getHandler);
    router.get('/files/:appId/metadata/:filename', this.metadataHandler);

    router.post('/files', function (req, res, next) {
      next(new Parse.Error(Parse.Error.INVALID_FILE_NAME, 'Filename not provided.'));
    });

    router.post(
      '/files/:filename',
      BodyParser.raw({
        type: () => {
          return true;
        },
        limit: maxUploadSize,
      }), // Allow uploads without Content-Type, or with any Content-Type.
      Middlewares.handleParseHeaders,
      Middlewares.handleParseSession,
      this.createHandler
    );

    router.delete(
      '/files/:filename',
      Middlewares.handleParseHeaders,
      Middlewares.handleParseSession,
      Middlewares.enforceMasterKeyAccess,
      this.deleteHandler
    );
    return router;
  }

  async getHandler(req, res) {
    const config = Config.get(req.params.appId);
    if (!config) {
      res.status(403);
      const err = new Parse.Error(Parse.Error.OPERATION_FORBIDDEN, 'Invalid application ID.');
      res.json({ code: err.code, error: err.message });
      return;
    }
    const filesController = config.filesController;
    const filename = req.params.filename;
    const mime = (await import('mime')).default;
    const contentType = mime.getType(filename);
    if (isFileStreamable(req, filesController)) {
      filesController.handleFileStream(config, filename, req, res, contentType).catch(() => {
        res.status(404);
        res.set('Content-Type', 'text/plain');
        res.end('File not found.');
      });
    } else {
      filesController
        .getFileData(config, filename)
        .then(data => {
          res.status(200);
          res.set('Content-Type', contentType);
          res.set('Content-Length', data.length);
          res.end(data);
        })
        .catch(() => {
          res.status(404);
          res.set('Content-Type', 'text/plain');
          res.end('File not found.');
        });
    }
  }

  async createHandler(req, res, next) {
    const config = req.config;
    const user = req.auth.user;
    const isMaster = req.auth.isMaster;
    const isLinked = user && Parse.AnonymousUtils.isLinked(user);
    if (!isMaster && !config.fileUpload.enableForAnonymousUser && isLinked) {
      next(
        new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by anonymous user is disabled.')
      );
      return;
    }
    if (!isMaster && !config.fileUpload.enableForAuthenticatedUser && !isLinked && user) {
      next(
        new Parse.Error(
          Parse.Error.FILE_SAVE_ERROR,
          'File upload by authenticated user is disabled.'
        )
      );
      return;
    }
    if (!isMaster && !config.fileUpload.enableForPublic && !user) {
      next(new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'File upload by public is disabled.'));
      return;
    }
    const filesController = config.filesController;
    const { filename } = req.params;
    const contentType = req.get('Content-type');

    if (!req.body || !req.body.length) {
      next(new Parse.Error(Parse.Error.FILE_SAVE_ERROR, 'Invalid file upload.'));
      return;
    }

    const error = filesController.validateFilename(filename);
    if (error) {
      next(error);
      return;
    }

    const fileExtensions = config.fileUpload?.fileExtensions;
    if (!isMaster && fileExtensions) {
      const isValidExtension = extension => {
        return fileExtensions.some(ext => {
          if (ext === '*') {
            return true;
          }
          const regex = new RegExp(ext);
          if (regex.test(extension)) {
            return true;
          }
        });
      };
      let extension = contentType;
      if (filename && filename.includes('.')) {
        extension = filename.substring(filename.lastIndexOf('.') + 1);
      } else if (contentType && contentType.includes('/')) {
        extension = contentType.split('/')[1];
      }
      extension = extension?.split(' ')?.join('');

      if (extension && !isValidExtension(extension)) {
        next(
          new Parse.Error(
            Parse.Error.FILE_SAVE_ERROR,
            `File upload of extension ${extension} is disabled.`
          )
        );
        return;
      }
    }

    const base64 = req.body.toString('base64');
    const file = new Parse.File(filename, { base64 }, contentType);
    const { metadata = {}, tags = {} } = req.fileData || {};
    try {
      // Scan request data for denied keywords
      Utils.checkProhibitedKeywords(config, metadata);
      Utils.checkProhibitedKeywords(config, tags);
    } catch (error) {
      next(new Parse.Error(Parse.Error.INVALID_KEY_NAME, error));
      return;
    }
    file.setTags(tags);
    file.setMetadata(metadata);
    const fileSize = Buffer.byteLength(req.body);
    const fileObject = { file, fileSize };
    try {
      // run beforeSaveFile trigger
      const triggerResult = await triggers.maybeRunFileTrigger(
        triggers.Types.beforeSave,
        fileObject,
        config,
        req.auth
      );
      let saveResult;
      // if a new ParseFile is returned check if it's an already saved file
      if (triggerResult instanceof Parse.File) {
        fileObject.file = triggerResult;
        if (triggerResult.url()) {
          // set fileSize to null because we wont know how big it is here
          fileObject.fileSize = null;
          saveResult = {
            url: triggerResult.url(),
            name: triggerResult._name,
          };
        }
      }
      // if the file returned by the trigger has already been saved skip saving anything
      if (!saveResult) {
        // update fileSize
        const bufferData = Buffer.from(fileObject.file._data, 'base64');
        fileObject.fileSize = Buffer.byteLength(bufferData);
        // prepare file options
        const fileOptions = {
          metadata: fileObject.file._metadata,",0
"    public_id_and_format = PreloadedFile.split_format(this.filename);
    this.public_id = public_id_and_format[0];
    this.format = public_id_and_format[1];
  }

  is_valid() {
    return utils.verify_api_response_signature(this.public_id, this.version, this.signature);
  }

  static split_format(identifier) {
    let format, last_dot, public_id;
    last_dot = identifier.lastIndexOf(""."");
    if (last_dot === -1) {",0
"  background = background && background.replace(/^#/, ""rgb:"");
  let color = consumeOption(options, ""color"");
  color = color && color.replace(/^#/, ""rgb:"");
  let base_transformations = toArray(consumeOption(options, ""transformation"", []));
  let named_transformation = [];
  if (base_transformations.some(isObject)) {
    base_transformations = base_transformations.map(tr => utils.generate_transformation_string(isObject(tr) ? clone(tr) : {transformation: tr}));
  } else {
    named_transformation = base_transformations.join(""."");
    base_transformations = [];
  }
  let effect = consumeOption(options, ""effect"");
  if (isArray(effect)) {
    effect = effect.join("":"");
  } else if (isObject(effect)) {
    effect = entries(effect).map(([key, value]) => `${key}:${value}`);
  }
  let border = consumeOption(options, ""border"");
  if (isObject(border)) {
    border = `${border.width != null ? border.width : 2}px_solid_${(border.color != null ? border.color : ""black"").replace(/^#/, 'rgb:')}`;
  } else if (/^\d+$/.exec(border)) { // fallback to html border attributes
    options.border = border;
    border = void 0;
  }
  let flags = toArray(consumeOption(options, ""flags"")).join(""."");
  let dpr = consumeOption(options, ""dpr"", config().dpr);
  if (options.offset != null) {
    [options.start_offset, options.end_offset] = split_range(consumeOption(options, ""offset""));
  }
  if (options.start_offset) {
    options.start_offset = normalize_expression(options.start_offset);
  }
  if (options.end_offset) {
    options.end_offset = normalize_expression(options.end_offset);
  }
  let overlay = process_layer(consumeOption(options, ""overlay""));
  let radius = process_radius(consumeOption(options, ""radius""));
  let underlay = process_layer(consumeOption(options, ""underlay""));
  let ifValue = process_if(consumeOption(options, ""if""));
  let custom_function = process_custom_function(consumeOption(options, ""custom_function""));
  let custom_pre_function = process_custom_pre_function(consumeOption(options, ""custom_pre_function""));
  let fps = consumeOption(options, 'fps');
  if (isArray(fps)) {
    fps = fps.join('-');
  }
  let params = {
    a: normalize_expression(angle),
    ar: normalize_expression(consumeOption(options, ""aspect_ratio"")),
    b: background,
    bo: border,
    c: crop,
    co: color,
    dpr: normalize_expression(dpr),
    e: normalize_expression(effect),
    fl: flags,
    fn: custom_function || custom_pre_function,
    fps: fps,
    h: normalize_expression(height),
    ki: normalize_expression(consumeOption(options, ""keyframe_interval"")),
    l: overlay,
    o: normalize_expression(consumeOption(options, ""opacity"")),
    q: normalize_expression(consumeOption(options, ""quality"")),
    r: radius,
    t: named_transformation,
    u: underlay,
    w: normalize_expression(width),
    x: normalize_expression(consumeOption(options, ""x"")),
    y: normalize_expression(consumeOption(options, ""y"")),
    z: normalize_expression(consumeOption(options, ""zoom""))
  };

  SIMPLE_PARAMS.forEach(([name, short]) => {
    let value = consumeOption(options, name);
    if (value !== undefined) {
      params[short] = value;
    }
  });
  if (params.vc != null) {
    params.vc = process_video_params(params.vc);
  }
  [""so"", ""eo"", ""du""].forEach((short) => {
    if (params[short] !== undefined) {
      params[short] = norm_range_value(params[short]);
    }
  });

  let variablesParam = consumeOption(options, ""variables"", []);
  let variables = entries(options)
    .filter(([key, value]) => key.startsWith('$'))
    .map(([key, value]) => {
      delete options[key];
      return `${key}_${normalize_expression(value)}`;
    }).sort().concat(variablesParam.map(([name, value]) => `${name}_${normalize_expression(value)}`)).join(',');

  let transformations = entries(params)
    .filter(([key, value]) => utils.present(value))
    .map(([key, value]) => key + '_' + value)
    .sort()
    .join(',');

  let raw_transformation = consumeOption(options, 'raw_transformation');
  transformations = compact([ifValue, variables, transformations, raw_transformation]).join("","");
  base_transformations.push(transformations);
  transformations = base_transformations;
  if (responsive_width) {
    let responsive_width_transformation = config().responsive_width_transformation || DEFAULT_RESPONSIVE_WIDTH_TRANSFORMATION;

    transformations.push(utils.generate_transformation_string(clone(responsive_width_transformation)));
  }
  if (String(width).startsWith(""auto"") || responsive_width) {
    options.responsive = true;
  }
  if (dpr === ""auto"") {
    options.hidpi = true;
  }
  return filter(transformations, utils.present).join(""/"");
}

function updateable_resource_params(options, params = {}) {
  if (options.access_control != null) {
    params.access_control = utils.jsonArrayParam(options.access_control);
  }
  if (options.auto_tagging != null) {
    params.auto_tagging = options.auto_tagging;
  }
  if (options.background_removal != null) {
    params.background_removal = options.background_removal;
  }
  if (options.categorization != null) {
    params.categorization = options.categorization;
  }
  if (options.context != null) {
    params.context = utils.encode_context(options.context);
  }
  if (options.metadata != null) {
    params.metadata = utils.encode_context(options.metadata);
  }
  if (options.custom_coordinates != null) {
    params.custom_coordinates = encodeDoubleArray(options.custom_coordinates);
  }
  if (options.detection != null) {
    params.detection = options.detection;
  }
  if (options.face_coordinates != null) {
    params.face_coordinates = encodeDoubleArray(options.face_coordinates);
  }
  if (options.headers != null) {
    params.headers = utils.build_custom_headers(options.headers);
  }
  if (options.notification_url != null) {
    params.notification_url = options.notification_url;
  }
  if (options.ocr != null) {
    params.ocr = options.ocr;
  }
  if (options.raw_convert != null) {
    params.raw_convert = options.raw_convert;
  }
  if (options.similarity_search != null) {
    params.similarity_search = options.similarity_search;
  }
  if (options.tags != null) {
    params.tags = toArray(options.tags).join("","");
  }
  if (options.quality_override != null) {
    params.quality_override = options.quality_override;
  }
  if (options.asset_folder != null) {
    params.asset_folder = options.asset_folder;
  }
  if (options.display_name != null) {
    params.display_name = options.display_name;
  }
  if (options.unique_display_name != null) {
    params.unique_display_name = options.unique_display_name;
  }
  if (options.visual_search != null) {
    params.visual_search = options.visual_search;
  }
  if (options.regions != null) {
    params.regions = JSON.stringify(options.regions);
  }
  const autoTranscription = options.auto_transcription;
  if (autoTranscription != null) {
    if (typeof autoTranscription === 'boolean') {
      params.auto_transcription = utils.as_safe_bool(autoTranscription);
    } else {
      const isAutoTranscriptionObject = typeof autoTranscription === 'object' && !Array.isArray(autoTranscription);
      if (isAutoTranscriptionObject && Object.keys(autoTranscription).includes('translate')) {
        params.auto_transcription = JSON.stringify(autoTranscription);
      }
    }
  }
  return params;
}

/**
 * A list of keys used by the url() function.
 * @private
 */
const URL_KEYS = ['api_secret', 'auth_token', 'cdn_subdomain', 'cloud_name', 'cname', 'format', 'long_url_signature', 'private_cdn', 'resource_type', 'secure', 'secure_cdn_subdomain', 'secure_distribution', 'shorten', 'sign_url', 'ssl_detected', 'type', 'url_suffix', 'use_root_path', 'version'];

/**
 * Create a new object with only URL parameters
 * @param {object} options The source object
 * @return {Object} An object containing only URL parameters
 */

function extractUrlParams(options) {
  return pickOnlyExistingValues(options, ...URL_KEYS);
}

/**
 * Create a new object with only transformation parameters
 * @param {object} options The source object
 * @return {Object} An object containing only transformation parameters
 */

function extractTransformationParams(options) {
  return pickOnlyExistingValues(options, ...TRANSFORMATION_PARAMS);
}

/**
 * Handle the format parameter for fetch urls
 * @private
 * @param options url and transformation options. This argument may be changed by the function!
 */

function patchFetchFormat(options = {}) {
  if (options.type === ""fetch"") {
    if (options.fetch_format == null) {
      options.fetch_format = consumeOption(options, ""format"");
    }
  }
}

function build_distribution_domain(source, options) {
  const cloud_name = consumeOption(options, 'cloud_name', config().cloud_name);
  if (!cloud_name) {
    throw new Error('Must supply cloud_name in tag or in configuration');
  }

  let secure = consumeOption(options, 'secure', true);
  const ssl_detected = consumeOption(options, 'ssl_detected', config().ssl_detected);
  if (secure === null) {
    secure = ssl_detected || config().secure;
  }

  const private_cdn = consumeOption(options, 'private_cdn', config().private_cdn);
  const cname = consumeOption(options, 'cname', config().cname);
  const secure_distribution = consumeOption(options, 'secure_distribution', config().secure_distribution);
  const cdn_subdomain = consumeOption(options, 'cdn_subdomain', config().cdn_subdomain);
  const secure_cdn_subdomain = consumeOption(options, 'secure_cdn_subdomain', config().secure_cdn_subdomain);

  return unsigned_url_prefix(source, cloud_name, private_cdn, cdn_subdomain, secure_cdn_subdomain, cname, secure, secure_distribution);
}

function url(public_id, options = {}) {
  let signature, source_to_sign;
  utils.patchFetchFormat(options);
  let type = consumeOption(options, ""type"", null);
  let transformation = utils.generate_transformation_string(options);

  let resource_type = consumeOption(options, ""resource_type"", ""image"");
  let version = consumeOption(options, ""version"");
  let force_version = consumeOption(options, ""force_version"", config().force_version);
  if (force_version == null) {
    force_version = true;
  }
  let long_url_signature = !!consumeOption(options, ""long_url_signature"", config().long_url_signature);
  let format = consumeOption(options, ""format"");
  let shorten = consumeOption(options, ""shorten"", config().shorten);
  let sign_url = consumeOption(options, ""sign_url"", config().sign_url);
  let api_secret = consumeOption(options, ""api_secret"", config().api_secret);
  let url_suffix = consumeOption(options, ""url_suffix"");
  let use_root_path = consumeOption(options, ""use_root_path"", config().use_root_path);
  let signature_algorithm = consumeOption(options, ""signature_algorithm"", config().signature_algorithm || DEFAULT_SIGNATURE_ALGORITHM);
  if (long_url_signature) {
    signature_algorithm = 'sha256';
  }
  let auth_token = consumeOption(options, ""auth_token"");
  if (auth_token !== false) {
    auth_token = exports.merge(config().auth_token, auth_token);
  }
  let preloaded = /^(image|raw)\/([a-z0-9_]+)\/v(\d+)\/([^#]+)$/.exec(public_id);
  if (preloaded) {
    resource_type = preloaded[1];
    type = preloaded[2];
    version = preloaded[3];
    public_id = preloaded[4];
  }
  let original_source = public_id;
  if (public_id == null) {
    return original_source;
  }
  public_id = public_id.toString();
  if (type === null && public_id.match(/^https?:\//i)) {
    return original_source;
  }
  [resource_type, type] = finalize_resource_type(resource_type, type, url_suffix, use_root_path, shorten);
  [public_id, source_to_sign] = finalize_source(public_id, format, url_suffix);

  if (version == null && force_version && source_to_sign.indexOf(""/"") >= 0 && !source_to_sign.match(/^v[0-9]+/) && !source_to_sign.match(/^https?:\//)) {
    version = 1;
  }
  if (version != null) {
    version = `v${version}`;
  } else {
    version = null;
  }

  transformation = transformation.replace(/([^:])\/\//g, '$1/');
  if (sign_url && isEmpty(auth_token)) {
    let to_sign = [transformation, source_to_sign].filter(function (part) {
      return (part != null) && part !== '';
    }).join('/');

    const signatureConfig = {};
    if (long_url_signature) {
      signatureConfig.algorithm = 'sha256';
      signatureConfig.signatureLength = 32;
    } else {
      signatureConfig.algorithm = signature_algorithm;
      signatureConfig.signatureLength = 8;
    }

    const truncated = compute_hash(to_sign + api_secret, signatureConfig.algorithm, 'base64')
      .slice(0, signatureConfig.signatureLength)
      .replace(/\//g, '_')
      .replace(/\+/g, '-');
    signature = `s--${truncated}--`;
  }

  let prefix = build_distribution_domain(public_id, options);
  let resultUrl = [prefix, resource_type, type, signature, transformation, version, public_id].filter(function (part) {
    return (part != null) && part !== '';
  }).join('/').replace(/ /g, '%20');
  if (sign_url && !isEmpty(auth_token)) {
    auth_token.url = urlParse(resultUrl).path;
    let token = generate_token(auth_token);
    resultUrl += `?${token}`;
  }

  const urlAnalytics = ensureOption(options, 'urlAnalytics', ensureOption(options, 'analytics', true));

  if (urlAnalytics === true) {
    let {
      sdkCode: sdkCodeDefault,
      sdkSemver: sdkSemverDefault,
      techVersion: techVersionDefault,
      product: productDefault
    } = getSDKVersions();
    const sdkCode = ensureOption(options, 'sdkCode', ensureOption(options, 'sdk_code', sdkCodeDefault));
    const sdkSemver = ensureOption(options, 'sdkSemver', ensureOption(options, 'sdk_semver', sdkSemverDefault));
    const techVersion = ensureOption(options, 'techVersion', ensureOption(options, 'tech_version', techVersionDefault));
    const product = ensureOption(options, 'product', productDefault);

    let sdkVersions = {
      sdkCode: sdkCode,
      sdkSemver: sdkSemver,
      techVersion: techVersion,
      product: product,
      urlAnalytics
    };

    let analyticsOptions = getAnalyticsOptions(Object.assign({}, options, sdkVersions));

    let sdkAnalyticsSignature = getSDKAnalyticsSignature(analyticsOptions);

    // url might already have a '?' query param
    let appender = '?';
    if (resultUrl.indexOf('?') >= 0) {
      appender = '&';
    }
    resultUrl = `${resultUrl}${appender}_a=${sdkAnalyticsSignature}`;
  }

  return resultUrl;
}

function video_url(public_id, options) {
  options = extend({
    resource_type: 'video'
  }, options);
  return utils.url(public_id, options);
}

function finalize_source(source, format, url_suffix) {
  let source_to_sign;
  source = source.replace(/([^:])\/\//g, '$1/');
  if (source.match(/^https?:\//i)) {
    source = smart_escape(source);
    source_to_sign = source;
  } else {
    source = encodeURIComponent(decodeURIComponent(source)).replace(/%3A/g, "":"").replace(/%2F/g, ""/"");
    source_to_sign = source;
    if (url_suffix) {
      if (url_suffix.match(/[\.\/]/)) {
        throw new Error('url_suffix should not include . or /');
      }
      source = source + '/' + url_suffix;
    }
    if (format != null) {
      source = source + '.' + format;
      source_to_sign = source_to_sign + '.' + format;
    }
  }
  return [source, source_to_sign];
}

function video_thumbnail_url(public_id, options) {
  options = extend({}, DEFAULT_POSTER_OPTIONS, options);
  return utils.url(public_id, options);
}

function finalize_resource_type(resource_type, type, url_suffix, use_root_path, shorten) {
  if (type == null) {
    type = 'upload';
  }
  if (url_suffix != null) {
    if (resource_type === 'image' && type === 'upload') {
      resource_type = ""images"";
      type = null;
    } else if (resource_type === 'image' && type === 'private') {
      resource_type = 'private_images';
      type = null;
    } else if (resource_type === 'image' && type === 'authenticated') {
      resource_type = 'authenticated_images';
      type = null;
    } else if (resource_type === 'raw' && type === 'upload') {
      resource_type = 'files';
      type = null;
    } else if (resource_type === 'video' && type === 'upload') {
      resource_type = 'videos';
      type = null;
    } else {
      throw new Error(""URL Suffix only supported for image/upload, image/private, image/authenticated, video/upload and raw/upload"");
    }
  }
  if (use_root_path) {
    if ((resource_type === 'image' && type === 'upload') || (resource_type === 'images' && (type == null))) {
      resource_type = null;
      type = null;
    } else {
      throw new Error(""Root path only supported for image/upload"");
    }
  }
  if (shorten && resource_type === 'image' && type === 'upload') {
    resource_type = 'iu';
    type = null;
  }
  return [resource_type, type];
}

// cdn_subdomain and secure_cdn_subdomain
// 1) Customers in shared distribution (e.g. res.cloudinary.com)
//    if cdn_domain is true uses res-[1-5].cloudinary.com for both http and https.
//    Setting secure_cdn_subdomain to false disables this for https.
// 2) Customers with private cdn
//    if cdn_domain is true uses cloudname-res-[1-5].cloudinary.com for http
//    if secure_cdn_domain is true uses cloudname-res-[1-5].cloudinary.com for https
//      (please contact support if you require this)
// 3) Customers with cname
//    if cdn_domain is true uses a[1-5].cname for http.
//    For https, uses the same naming scheme as 1 for shared distribution and as 2 for private distribution.

function unsigned_url_prefix(source, cloud_name, private_cdn, cdn_subdomain, secure_cdn_subdomain, cname, secure, secure_distribution) {
  let prefix;
  if (cloud_name.indexOf(""/"") === 0) {
    return '/res' + cloud_name;
  }
  let shared_domain = !private_cdn;
  if (secure) {
    if ((secure_distribution == null) || secure_distribution === exports.OLD_AKAMAI_SHARED_CDN) {
      secure_distribution = private_cdn ? cloud_name + ""-res.cloudinary.com"" : exports.SHARED_CDN;
    }
    if (shared_domain == null) {
      shared_domain = secure_distribution === exports.SHARED_CDN;
    }
    if ((secure_cdn_subdomain == null) && shared_domain) {
      secure_cdn_subdomain = cdn_subdomain;
    }
    if (secure_cdn_subdomain) {
      secure_distribution = secure_distribution.replace('res.cloudinary.com', 'res-' + ((crc32(source) % 5) + 1 + '.cloudinary.com'));
    }
    prefix = 'https://' + secure_distribution;
  } else if (cname) {
    let subdomain = cdn_subdomain ? 'a' + ((crc32(source) % 5) + 1) + '.' : '';
    prefix = 'http://' + subdomain + cname;
  } else {
    let cdn_part = private_cdn ? cloud_name + '-' : '';
    let subdomain_part = cdn_subdomain ? '-' + ((crc32(source) % 5) + 1) : '';
    let host = [cdn_part, 'res', subdomain_part, '.cloudinary.com'].join('');
    prefix = 'http://' + host;
  }
  if (shared_domain) {
    prefix += '/' + cloud_name;
  }
  return prefix;
}

function base_api_url_v1_1() {
  return base_api_url('v1_1');
}

function base_api_url_v2() {
  return base_api_url('v2');
}

function base_api_url(api_version) {
  if (!api_version || api_version.length === 0) {
    throw new Error('api_version needs to be a non-empty string');
  }

  return (path = [], options = []) => {
    let cloudinary = ensureOption(options, ""upload_prefix"", UPLOAD_PREFIX);
    let cloud_name = ensureOption(options, ""cloud_name"");
    let encode_path = unencoded_path => encodeURIComponent(unencoded_path).replace(""'"", '%27');
    let encoded_path = Array.isArray(path) ? path.map(encode_path) : encode_path(path);
    return [cloudinary, api_version, cloud_name].concat(encoded_path).join(""/"");
  };
}

function api_url(action = 'upload', options = {}) {
  let resource_type = options.resource_type || ""image"";
  return base_api_url_v1_1()([resource_type, action], options);
}

function random_public_id() {
  return crypto.randomBytes(12).toString('base64').replace(/[^a-z0-9]/g, """");
}

function signed_preloaded_image(result) {
  return `${result.resource_type}/upload/v${result.version}/${filter([result.public_id, result.format], utils.present).join(""."")}#${result.signature}`;
}

// Encodes a parameter for safe inclusion in URL query strings (only replaces & with %26)
function encode_param(value) {
  return String(value).replace(/&/g, '%26');
}

// Generates a string to be signed for API requests
function api_string_to_sign(params_to_sign, signature_version = 2) {
  let params = entries(params_to_sign)
    .map(([k, v]) => [String(k), Array.isArray(v) ? v.join("","") : v])
    .filter(([k, v]) => v !== null && v !== undefined && v !== """");
  params.sort((a, b) => a[0].localeCompare(b[0]));
  let paramStrings = params.map(([k, v]) => {
    const paramString = `${k}=${v}`;
    return signature_version >= 2 ? encode_param(paramString) : paramString;
  });
  return paramStrings.join(""&"");
}

/**
 * Signs API request parameters
 * @param {Object} params_to_sign Parameters to sign
 * @param {string} api_secret API secret
 * @param {string|undefined|null} signature_algorithm Hash algorithm to use ('sha1' or 'sha256')
 * @param {number|undefined|null} signature_version Version of signature algorithm to use:
 *   - Version 1: Original behavior without parameter encoding
 *   - Version 2+ (default): Includes parameter encoding to prevent parameter smuggling
 * @return {string} Hexadecimal signature
 * @private
 */
function api_sign_request(params_to_sign, api_secret, signature_algorithm = null, signature_version = null) {
  if (signature_version == null) {
    signature_version = config().signature_version || 2;
  }
  const to_sign = api_string_to_sign(params_to_sign, signature_version);
  const algo = signature_algorithm || config().signature_algorithm || DEFAULT_SIGNATURE_ALGORITHM;
  return compute_hash(to_sign + api_secret, algo, 'hex');
}

/**
 * Computes hash from input string using specified algorithm.
 * @private
 * @param {string} input string which to compute hash from
 * @param {string} signature_algorithm algorithm to use for computing hash
 * @param {string} encoding type of encoding
 * @return {string} computed hash value
 */
function compute_hash(input, signature_algorithm, encoding) {
  if (!SUPPORTED_SIGNATURE_ALGORITHMS.includes(signature_algorithm)) {
    throw new Error(`Signature algorithm ${signature_algorithm} is not supported. Supported algorithms: ${SUPPORTED_SIGNATURE_ALGORITHMS.join(', ')}`);
  }
  const hash = crypto.createHash(signature_algorithm).update(input).digest();
  return Buffer.from(hash).toString(encoding);
}

function clear_blank(hash) {
  let filtered_hash = {};
  entries(hash).filter(([k, v]) => utils.present(v)).forEach(([k, v]) => {
    filtered_hash[k] = v.filter ? v.filter(x => x) : v;
  });
  return filtered_hash;
}

function sort_object_by_key(object) {
  return Object.keys(object).sort().reduce((obj, key) => {
    obj[key] = object[key];
    return obj;
  }, {});
}

function merge(hash1, hash2) {
  return {...hash1, ...hash2};
}

function sign_request(params, options = {}) {
  let apiKey = ensureOption(options, 'api_key');
  let apiSecret = ensureOption(options, 'api_secret');
  let signature_algorithm = options.signature_algorithm;
  let signature_version = options.signature_version;
  params = exports.clear_blank(params);
  params.signature = exports.api_sign_request(params, apiSecret, signature_algorithm, signature_version);
  params.api_key = apiKey;
  return params;
}

function webhook_signature(data, timestamp, options = {}) {
  ensurePresenceOf({
    data,
    timestamp
  });

  let api_secret = ensureOption(options, 'api_secret');
  let signature_algorithm = ensureOption(options, 'signature_algorithm', DEFAULT_SIGNATURE_ALGORITHM);
  return compute_hash(data + timestamp + api_secret, signature_algorithm, 'hex');
}

/**
 * Verifies the authenticity of a notification signature
 *
 * @param {string} body JSON of the request's body
 * @param {number} timestamp Unix timestamp in seconds. Can be retrieved from the X-Cld-Timestamp header
 * @param {string} signature Actual signature. Can be retrieved from the X-Cld-Signature header
 * @param {number} [valid_for=7200] The desired time in seconds for considering the request valid
 *
 * @return {boolean}
 */
function verifyNotificationSignature(body, timestamp, signature, valid_for = 7200) {
  // verify that signature is valid for the given timestamp
  if (timestamp < Math.round(Date.now() / 1000) - valid_for) {
    return false;
  }
  const payload_hash = utils.webhook_signature(body, timestamp, {
    api_secret: config().api_secret,
    signature_algorithm: config().signature_algorithm
  });
  return signature === payload_hash;
}

function process_request_params(params, options) {
  if ((options.unsigned != null) && options.unsigned) {
    params = exports.clear_blank(params);
    delete params.timestamp;
  } else if (options.oauth_token || config().oauth_token) {
    params = exports.clear_blank(params);
  } else if (options.signature) {
    params = exports.clear_blank(options);
  } else {
    params = exports.sign_request(params, options);
  }

  return params;
}

function private_download_url(public_id, format, options = {}) {
  let params = exports.sign_request({
    timestamp: options.timestamp || exports.timestamp(),
    public_id: public_id,
    format: format,
    type: options.type,
    attachment: options.attachment,
    expires_at: options.expires_at
  }, options);
  return exports.api_url(""download"", options) + ""?"" + querystring.stringify(params);
}

/**
 * Utility method that uses the deprecated ZIP download API.
 * @deprecated Replaced by {download_zip_url} that uses the more advanced and robust archive generation and download API
 */

function zip_download_url(tag, options = {}) {
  let params = exports.sign_request({
    timestamp: options.timestamp || exports.timestamp(),
    tag: tag,
    transformation: utils.generate_transformation_string(options)
  }, options);
  return exports.api_url(""download_tag.zip"", options) + ""?"" + hashToQuery(params);
}

/**
 * The returned url should allow downloading the backedup asset based on the
 * version and asset id
 * asset and version id are returned with resource(<PUBLIC_ID1>, { versions: true })
 * @param asset_id
 * @param version_id
 * @param options
 * @returns {string }
 */
function download_backedup_asset(asset_id, version_id, options = {}) {
  let params = exports.sign_request({
    timestamp: options.timestamp || exports.timestamp(),
    asset_id: asset_id,
    version_id: version_id
  }, options);
  return exports.base_api_url_v1()(['download_backup'], options) + ""?"" + hashToQuery(params);
}

/**
 * Utility method to create a signed URL for specified resources.
 * @param action
 * @param params
 * @param options
 */
function api_download_url(action, params, options) {
  const download_params = {
    ...params,
    mode: ""download""
  }
  let cloudinary_params = exports.sign_request(download_params, options);
  return exports.api_url(action, options) + ""?"" + hashToQuery(cloudinary_params);
}

/**
 * Returns a URL that when invokes creates an archive and returns it.
 * @param {object} options
 * @param {string} [options.resource_type=""image""] The resource type of files to include in the archive.
 *   Must be one of :image | :video | :raw
 * @param {string} [options.type=""upload""] The specific file type of resources: :upload|:private|:authenticated
 * @param {string|Array} [options.tags] list of tags to include in the archive
 * @param {string|Array<string>} [options.public_ids] list of public_ids to include in the archive
 * @param {string|Array<string>} [options.prefixes]  list of prefixes of public IDs (e.g., folders).
 * @param {string|Array<string>} [options.fully_qualified_public_ids] list of fully qualified public_ids to include
 *   in the archive.
 * @param {string|Array<string>} [options.transformations]  list of transformations.
 *   The derived images of the given transformations are included in the archive. Using the string representation of
 *   multiple chained transformations as we use for the 'eager' upload parameter.
 * @param {string} [options.mode=""create""] return the generated archive file or to store it as a raw resource and
 *   return a JSON with URLs for accessing the archive. Possible values: :download, :create
 * @param {string} [options.target_format=""zip""]
 * @param {string} [options.target_public_id]  public ID of the generated raw resource.
 *   Relevant only for the create mode. If not specified, random public ID is generated.
 * @param {boolean} [options.flatten_folders=false] If true, flatten public IDs with folders to be in the root
 *   of the archive. Add numeric counter to the file name in case of a name conflict.
 * @param {boolean} [options.flatten_transformations=false] If true, and multiple transformations are given,
 *   flatten the folder structure of derived images and store the transformation details on the file name instead.
 * @param {boolean} [options.use_original_filename] Use the original file name of included images
 *   (if available) instead of the public ID.
 * @param {boolean} [options.async=false] If true, return immediately and perform archive creation in the background.
 *   Relevant only for the create mode.
 * @param {string} [options.notification_url] URL to send an HTTP post request (webhook) to when the
 *   archive creation is completed.
 * @param {string|Array<string>} [options.target_tags=] Allows assigning one or more tags to the generated archive file
 *   (for later housekeeping via the admin API).
 * @param {string} [options.keep_derived=false] keep the derived images used for generating the archive
 * @return {String} archive url
 */
function download_archive_url(options = {}) {
  const params = exports.archive_params(merge(options, {
    mode: ""download""
  }))
  return api_download_url(""generate_archive"", params, options)
}

/**
 * Returns a URL that when invokes creates an zip archive and returns it.
 * @see download_archive_url
 */

function download_zip_url(options = {}) {
  return exports.download_archive_url(merge(options, {
    target_format: ""zip""
  }));
}

/**
 * Creates and returns a URL that when invoked creates an archive of a folder
 * @param {string} folder_path Full path (from the root) of the folder to download
 * @param {object} options Additional options
 * @returns {string} Url for downloading an archive of a folder
 */
function download_folder(folder_path, options = {}) {
  options.resource_type = options.resource_type || ""all"";
  options.prefixes = folder_path;
  let cloudinary_params = exports.sign_request(exports.archive_params(merge(options, {
    mode: ""download""
  })), options);
  return exports.api_url(""generate_archive"", options) + ""?"" + hashToQuery(cloudinary_params);
}

/**
 * Render the key/value pair as an HTML tag attribute
 * @private
 * @param {string} key
 * @param {string|boolean|number} [value]
 * @return {string} A string representing the HTML attribute
 */
function join_pair(key, value) {
  if (!value) {
    return void 0;
  }
  return value === true ? key : key + ""='"" + value + ""'"";
}

/**
 * If the given value is a string, replaces single or double quotes with character entities
 * @private
 * @param {*} value The string to encode quotes in
 * @return {*} Encoded string or original value if not a string
 */
function escapeQuotes(value) {
  return isString(value) ? value.replace(/\""/g, '&#34;').replace(/\'/g, '&#39;') : value;
}

/**
 *
 * @param attrs
 * @return {*}
 */
exports.html_attrs = function html_attrs(attrs) {
  return filter(map(attrs, function (value, key) {
    return join_pair(key, escapeQuotes(value));
  })).sort().join("" "");
};

const CLOUDINARY_JS_CONFIG_PARAMS = ['api_key', 'cloud_name', 'private_cdn', 'secure_distribution', 'cdn_subdomain'];

function cloudinary_js_config() {
  let params = pickOnlyExistingValues(config(), ...CLOUDINARY_JS_CONFIG_PARAMS);
  return `<script type='text/javascript'>\n$.cloudinary.config(${JSON.stringify(params)});\n</script>`;
}

function v1_result_adapter(callback) {
  if (callback == null) {
    return undefined;
  }
  return function (result) {
    if (result.error != null) {
      return callback(result.error);
    }
    return callback(void 0, result);
  };
}

function v1_adapter(name, num_pass_args, v1) {
  return function (...args) {
    let pass_args = take(args, num_pass_args);
    let options = args[num_pass_args];
    let callback = args[num_pass_args + 1];
    if ((callback == null) && isFunction(options)) {
      callback = options;
      options = {};
    }
    callback = v1_result_adapter(callback);
    args = pass_args.concat([callback, options]);
    return v1[name].apply(this, args);
  };
}

function v1_adapters(exports, v1, mapping) {
  return Object.keys(mapping).map((name) => {
    let num_pass_args = mapping[name];
    exports[name] = v1_adapter(name, num_pass_args, v1);
    return exports[name];
  });
}

function as_safe_bool(value) {
  if (value == null) {
    return void 0;
  }
  if (value === true || value === 'true' || value === '1') {
    value = 1;
  }
  if (value === false || value === 'false' || value === '0') {
    value = 0;
  }
  return value;
}

const NUMBER_PATTERN = ""([0-9]*)\\.([0-9]+)|([0-9]+)"";

const OFFSET_ANY_PATTERN = `(${NUMBER_PATTERN})([%pP])?`;
const RANGE_VALUE_RE = RegExp(`^${OFFSET_ANY_PATTERN}$`);
const OFFSET_ANY_PATTERN_RE = RegExp(`(${OFFSET_ANY_PATTERN})\\.\\.(${OFFSET_ANY_PATTERN})`);

// Split a range into the start and end values
function split_range(range) { // :nodoc:
  switch (range.constructor) {
  case String:
    if (!OFFSET_ANY_PATTERN_RE.test(range)) {
      return range;
    }
    return range.split("".."");
  case Array:
    return [first(range), last(range)];
  default:
    return [null, null];
  }
}

function norm_range_value(value) { // :nodoc:
  let offset = String(value).match(RANGE_VALUE_RE);
  if (offset) {
    let modifier = offset[5] ? 'p' : '';
    value = `${offset[1] || offset[4]}${modifier}`;
  }
  return value;
}

/**
 * A video codec parameter can be either a String or a Hash.
 * @param {Object} param <code>vc_<codec>[ : <profile> : [<level>]]</code>
 *                       or <code>{ codec: 'h264', profile: 'basic', level: '3.1' }</code>
 * @return {String} <code><codec> : <profile> : [<level>]]</code> if a Hash was provided
 *                   or the param if a String was provided.
 *                   Returns null if param is not a Hash or String
 */
function process_video_params(param) {
  switch (param.constructor) {
  case Object: {
    let video = """";
    if ('codec' in param) {
      video = param.codec;
      if ('profile' in param) {
        video += "":"" + param.profile;
        if ('level' in param) {
          video += "":"" + param.level;
        }
      }
    }
    return video;
  }
  case String:
    return param;
  default:
    return null;
  }
}

/**
 * Returns a Hash of parameters used to create an archive
 * @private
 * @param {object} options
 * @return {object} Archive API parameters
 */

function archive_params(options = {}) {
  return {
    allow_missing: exports.as_safe_bool(options.allow_missing),
    async: exports.as_safe_bool(options.async),
    expires_at: options.expires_at,
    flatten_folders: exports.as_safe_bool(options.flatten_folders),
    flatten_transformations: exports.as_safe_bool(options.flatten_transformations),
    keep_derived: exports.as_safe_bool(options.keep_derived),
    mode: options.mode,
    notification_url: options.notification_url,
    prefixes: options.prefixes && toArray(options.prefixes),
    fully_qualified_public_ids: options.fully_qualified_public_ids && toArray(options.fully_qualified_public_ids),
    public_ids: options.public_ids && toArray(options.public_ids),
    skip_transformation_name: exports.as_safe_bool(options.skip_transformation_name),
    tags: options.tags && toArray(options.tags),
    target_format: options.target_format,
    target_public_id: options.target_public_id,
    target_tags: options.target_tags && toArray(options.target_tags),
    timestamp: options.timestamp || exports.timestamp(),
    transformations: utils.build_eager(options.transformations),
    type: options.type,
    use_original_filename: exports.as_safe_bool(options.use_original_filename)
  };
}

exports.process_layer = process_layer;

exports.create_source_tag = function create_source_tag(src, source_type, codecs = null) {
  let video_type = source_type === 'ogv' ? 'ogg' : source_type;
  let mime_type = `video/${video_type}`;
  if (!isEmpty(codecs)) {
    let codecs_str = isArray(codecs) ? codecs.join(', ') : codecs;
    mime_type += `; codecs=${codecs_str}`;
  }
  return `<source ${utils.html_attrs({
    src,
    type: mime_type
  })}>`;
};

function build_explicit_api_params(public_id, options = {}) {
  return [exports.build_upload_params(extend({}, {public_id}, options))];
}

function generate_responsive_breakpoints_string(breakpoints) {
  if (breakpoints == null) {
    return null;
  }
  breakpoints = clone(breakpoints);
  if (!isArray(breakpoints)) {
    breakpoints = [breakpoints];
  }
  for (let j = 0; j < breakpoints.length; j++) {
    let breakpoint_settings = breakpoints[j];
    if (breakpoint_settings != null) {
      if (breakpoint_settings.transformation) {
        breakpoint_settings.transformation = utils.generate_transformation_string(clone(breakpoint_settings.transformation));
      }
    }
  }
  return JSON.stringify(breakpoints);
}

function build_streaming_profiles_param(options = {}) {
  let params = pickOnlyExistingValues(options, ""display_name"", ""representations"");
  if (isArray(params.representations)) {
    params.representations = JSON.stringify(params.representations.map(r => ({
      transformation: utils.generate_transformation_string(r.transformation)
    })));
  }
  return params;
}

function hashToParameters(hash) {
  return entries(hash).reduce((parameters, [key, value]) => {
    if (isArray(value)) {
      key = key.endsWith('[]') ? key : key + '[]';
      const items = value.map(v => [key, v]);
      parameters = parameters.concat(items);
    } else {
      parameters.push([key, value]);
    }
    return parameters;
  }, []);
}

/**
 * Convert a hash of values to a URI query string.
 * Array values are spread as individual parameters.
 * @param {object} hash Key-value parameters
 * @return {string} A URI query string.
 */
function hashToQuery(hash) {
  return hashToParameters(hash).map(([key, value]) => `${querystring.escape(key)}=${querystring.escape(value)}`).join('&');
}

/**
 * Verify that the parameter `value` is defined and it's string value is not zero.
 * <br>This function should not be confused with `isEmpty()`.
 * @private
 * @param {string|number} value The value to check.
 * @return {boolean} True if the value is defined and not empty.
 */

function present(value) {
  return value != null && ("""" + value).length > 0;
}

/**
 * Returns a new object with key values from source based on the keys.
 * `null` or `undefined` values are not copied.
 * @private
 * @param {object} source The object to pick values from.
 * @param {...string} keys One or more keys to copy from source.
 * @return {object} A new object with the required keys and values.
 */

function pickOnlyExistingValues(source, ...keys) {
  let result = {};
  if (source) {
    keys.forEach((key) => {
      if (source[key] != null) {
        result[key] = source[key];
      }
    });
  }
  return result;
}

/**
 * Returns a JSON array as String.
 * Yields the array before it is converted to JSON format
 * @private
 * @param {object|String|Array<object>} data
 * @param {function(*):*} [modifier] called with the array before the array is stringified
 * @return {String|null} a JSON array string or `null` if data is `null`
 */

function jsonArrayParam(data, modifier) {
  if (!data) {
    return null;
  }
  if (isString(data)) {
    data = JSON.parse(data);
  }
  if (!isArray(data)) {
    data = [data];
  }
  if (isFunction(modifier)) {
    data = modifier(data);
  }
  return JSON.stringify(data);
}

/**
 * Empty function - do nothing
 *
 */
exports.NOP = function () {
};
exports.generate_auth_token = generate_auth_token;
exports.getUserAgent = getUserAgent;
exports.build_upload_params = build_upload_params;
exports.build_multi_and_sprite_params = build_multi_and_sprite_params;
exports.api_download_url = api_download_url;
exports.timestamp = () => Math.floor(new Date().getTime() / 1000);
exports.option_consume = consumeOption; // for backwards compatibility
exports.build_array = toArray; // for backwards compatibility
exports.encode_double_array = encodeDoubleArray;
exports.encode_key_value = encode_key_value;
exports.encode_context = encode_context;
exports.build_eager = build_eager;
exports.build_custom_headers = build_custom_headers;
exports.generate_transformation_string = generate_transformation_string;
exports.updateable_resource_params = updateable_resource_params;
exports.extractUrlParams = extractUrlParams;
exports.extractTransformationParams = extractTransformationParams;
exports.patchFetchFormat = patchFetchFormat;
exports.url = url;
exports.video_url = video_url;
exports.video_thumbnail_url = video_thumbnail_url;
exports.api_url = api_url;
exports.random_public_id = random_public_id;
exports.signed_preloaded_image = signed_preloaded_image;
exports.api_sign_request = api_sign_request;
exports.clear_blank = clear_blank;
exports.merge = merge;
exports.sign_request = sign_request;
exports.webhook_signature = webhook_signature;
exports.verifyNotificationSignature = verifyNotificationSignature;
exports.process_request_params = process_request_params;
exports.private_download_url = private_download_url;
exports.zip_download_url = zip_download_url;
exports.download_archive_url = download_archive_url;
exports.download_zip_url = download_zip_url;
exports.cloudinary_js_config = cloudinary_js_config;
exports.v1_adapters = v1_adapters;
exports.as_safe_bool = as_safe_bool;
exports.archive_params = archive_params;
exports.build_explicit_api_params = build_explicit_api_params;
exports.generate_responsive_breakpoints_string = generate_responsive_breakpoints_string;
exports.build_streaming_profiles_param = build_streaming_profiles_param;
exports.hashToParameters = hashToParameters;
exports.present = present;
exports.only = pickOnlyExistingValues; // for backwards compatibility
exports.pickOnlyExistingValues = pickOnlyExistingValues;
exports.jsonArrayParam = jsonArrayParam;
exports.download_folder = download_folder;
exports.base_api_url_v1 = base_api_url_v1_1;
exports.base_api_url_v2 = base_api_url_v2;
exports.download_backedup_asset = download_backedup_asset;
exports.compute_hash = compute_hash;
exports.build_distribution_domain = build_distribution_domain;
exports.sort_object_by_key = sort_object_by_key;

// was exported before, so kept for backwards compatibility
exports.DEFAULT_POSTER_OPTIONS = DEFAULT_POSTER_OPTIONS;
exports.DEFAULT_VIDEO_SOURCE_TYPES = DEFAULT_VIDEO_SOURCE_TYPES;

Object.assign(module.exports, {
  normalize_expression,
  at,
  clone,
  extend,
  filter,
  includes,
  isArray,
  isEmpty,
  isNumber,
  isObject,
  isRemoteUrl,
  isString,
  isUndefined,
  keys: source => Object.keys(source),
  ensurePresenceOf
});

/**
 * Verifies an API response signature for a given public_id and version.
 * Always uses signature version 1 for backward compatibility, matching the Ruby SDK.
 * @param {string} public_id
 * @param {string|number} version
 * @param {string} signature
 * @returns {boolean}
 */
function verify_api_response_signature(public_id, version, signature) {
  const api_secret = config().api_secret;
  const expected = exports.api_sign_request(
    {
      public_id,
      version
    },
    api_secret,
    null,
    1
  );
  return signature === expected;
}

exports.verify_api_response_signature = verify_api_response_signature;",0
"      const getVersionsResp = await API_V2.resource(PUBLIC_ID_BACKUP_1, {versions: true});

      const firstAssetVersion = getVersionsResp.versions[0].version_id;
      const secondAssetVersion = getVersionsResp.versions[1].version_id;

      // Restore first version, ensure it's equal to the upload size
      await wait(2000)();
      const firstVerRestore = await API_V2.restore([PUBLIC_ID_BACKUP_1], {versions: [firstAssetVersion]});
      expect(firstVerRestore[PUBLIC_ID_BACKUP_1].bytes).to.eql(firstUpload.bytes);

      // Restore second version, ensure it's equal to the upload size
      await wait(2000)();
      const secondVerRestore = await API_V2.restore([PUBLIC_ID_BACKUP_1], {versions: [secondAssetVersion]});
      expect(secondVerRestore[PUBLIC_ID_BACKUP_1].bytes).to.eql(secondUpload.bytes);

      // Cleanup,
      const finalDeleteResp = await API_V2.delete_resources([PUBLIC_ID_BACKUP_1]);
      expect(finalDeleteResp).to.have.property(""deleted"");",0
"const METADATA_FIELD_VALUE = 'metadata_field_value_' + TEST_ID;
const METADATA_SAMPLE_DATA = { metadata_color: ""red"", metadata_shape: ""dodecahedron"" };
const METADATA_SAMPLE_DATA_ENCODED = ""metadata_color=red|metadata_shape=dodecahedron"";
const createTestConfig = require('../../../testUtils/createTestConfig');

const testConstants = require('../../../testUtils/testConstants');
const { shouldTestFeature, DYNAMIC_FOLDERS } = require(""../../../spechelper"");
const UPLOADER_V2 = cloudinary.v2.uploader;

const {
  TIMEOUT,
  TAGS,
  TEST_EVAL_STR,
  TEST_IMG_WIDTH
} = testConstants;

const {
  TEST_TAG,
  UPLOAD_TAGS
} = TAGS;

const SAMPLE_IMAGE_URL_1 = ""https://res.cloudinary.com/demo/image/upload/sample""
const SAMPLE_IMAGE_URL_2 = ""https://res.cloudinary.com/demo/image/upload/car""

require('jsdom-global')();

describe(""uploader"", function () {
  this.timeout(TIMEOUT.LONG);
  after(function () {
    var config = cloudinary.config(true);
    if (!(config.api_key && config.api_secret)) {
      expect().fail(""Missing key and secret. Please set CLOUDINARY_URL."");
    }
    return Q.allSettled([
      !cloudinary.config().keep_test_products ? cloudinary.v2.api.delete_resources_by_tag(TEST_TAG) : void 0,
      !cloudinary.config().keep_test_products ? cloudinary.v2.api.delete_resources_by_tag(TEST_TAG,
        {
          resource_type: ""video""
        }) : void 0
    ]);
  });
  beforeEach(function () {
    cloudinary.config(true);
    cloudinary.config(createTestConfig());
  });
  it(""should successfully upload file"", function () {
    this.timeout(TIMEOUT.LONG);
    return uploadImage().then(function (result) {
      var expected_signature;
      expect(result.width).to.eql(241);
      expect(result.height).to.eql(51);
      expected_signature = cloudinary.utils.api_sign_request({
        public_id: result.public_id,
        version: result.version
      }, cloudinary.config().api_secret);
      expect(result.signature).to.eql(expected_signature);
    });
  });
  it(""should successfully upload with metadata"", function () {
    return helper.provideMockObjects(function (mockXHR, writeSpy, requestSpy) {
      uploadImage({ metadata: METADATA_SAMPLE_DATA });
      sinon.assert.calledWith(requestSpy, sinon.match({
        method: sinon.match(""POST"")
      }));
      sinon.assert.calledWith(writeSpy, sinon.match(helper.uploadParamMatcher(""metadata"", METADATA_SAMPLE_DATA_ENCODED)));
    });
  });
  it('should upload a file with correctly encoded transformation string', () => {
    return helper.provideMockObjects(function (mockXHR, writeSpy, requestSpy) {
      const uploadResult = cloudinary.v2.uploader.upload('irrelevant', { transformation: { overlay: { text: 'test / 火' } } });
      sinon.assert.calledWith(writeSpy, sinon.match(helper.uploadParamMatcher('transformation', 'l_text:test %2F 火')));
    });
  });
  it('should upload a file with correctly encoded transformation string incl 4bytes characters', () => {
    return helper.provideMockObjects(function (mockXHR, writeSpy, requestSpy) {
      cloudinary.v2.uploader.upload('irrelevant', { transformation: { overlay: { text: 'test 𩸽 🍺' } } })
        .then((uploadResult) => {
          sinon.assert.calledWith(writeSpy, sinon.match(helper.uploadParamMatcher('transformation', 'l_text:test 𩸽 🍺')));
          expect(uploadResult).to.have.key(""created_at"");
        });
    });
  });
  it(""should successfully upload url"", function () {
    return cloudinary.v2.uploader.upload(""https://cloudinary.com/images/old_logo.png"", {
      tags: UPLOAD_TAGS
    }).then(function (result) {
      var expected_signature;
      expect(result.width).to.eql(241);
      expect(result.height).to.eql(51);
      expected_signature = cloudinary.utils.api_sign_request({
        public_id: result.public_id,
        version: result.version
      }, cloudinary.config().api_secret);
      expect(result.signature).to.eql(expected_signature);
    });
  });
  it(""should successfully override original_filename"", function () {
    return cloudinary.v2.uploader.upload(""https://cloudinary.com/images/old_logo.png"", {
      filename_override: 'overridden'
    }).then((result) => {
      expect(result.original_filename).to.eql('overridden');
    });
  });
  it(""Should upload a valid docx file as base64"", function () {
    let data = 'data:application/vnd.openxmlformats-officedocument.wordprocessingml.document;base64,UEsDBBQACAgIAI02LlAAAAAAAAAAAAAAAAASAAAAd29yZC9udW1iZXJpbmcueG1spZNNTsMwEIVPwB0i79skFSAUNe2CCjbsgAO4jpNYtT3W2Eno7XGbv1IklIZV5Izf98bj5/X2S8mg5mgF6JTEy4gEXDPIhC5S8vnxsngigXVUZ1SC5ik5cku2m7t1k+hK7Tn6fYFHaJsolpLSOZOEoWUlV9QuwXDtizmgos4vsQgVxUNlFgyUoU7shRTuGK6i6JF0GEhJhTrpEAslGIKF3J0kCeS5YLz79Aqc4ttKdsAqxbU7O4bIpe8BtC2FsT1NzaX5YtlD6r8OUSvZ72vMFLcMaePnrGRr1ABmBoFxa/3fXVsciHE0YYAnxKCY0sJPz74TRYUeMKd0XIEG76X37oZ2Ro0HGWdh5ZRG2tKb2CPF4+8u6Ix5XuqNmJTiK4JXuQqHQM5BsJKi6wFyDkECO/DsmeqaDmHOiklxviJlghZI1RhSe9PNxtFVXN5LavhIK/5He0WozBj3+zm0ixcYP9wGWPWAcPMNUEsHCEkTQ39oAQAAPQUAAFBLAwQUAAgICACNNi5QAAAAAAAAAAAAAAAAEQAAAHdvcmQvc2V0dGluZ3MueG1spZXNbtswDMefYO8Q6J74o0k2GHV6WLHtsJ7SPQAjybYQfUGS4+XtJ8eW1aRA4WanSH+SP9IMTT8+/RV8caLGMiVLlK1StKASK8JkXaI/rz+W39DCOpAEuJK0RGdq0dPuy2NXWOqc97ILT5C2ELhEjXO6SBKLGyrArpSm0hsrZQQ4fzV1IsAcW73ESmhw7MA4c+ckT9MtGjGqRK2RxYhYCoaNsqpyfUihqophOv6ECDMn7xDyrHArqHSXjImh3NegpG2YtoEm7qV5YxMgp48e4iR48Ov0nGzEQOcbLfiQqFOGaKMwtdarz4NxImbpjAb2iCliTgnXOUMlApicMP1w3ICm3Cufe2zaBRUfJPbC8jmFDKbf7GDAnN9XAXf08228ZrOm+Ibgo1xrpoG8B4EbMC4A+D0ErvCRku8gTzANM6lnjfMNiTCoDYg4pPZT/2yW3ozLvgFNI63+P9pPo1odx319D+3NG5htPgfIA2DnVyChFbTcvcJh75RedMUJ/BR/zVOU9OZhy8XTftiYwS/bIH+UIPybc7UQXxShvak1bH5xfcrkKic3+z6IvoDWQ9pDnZWIs7pxWc93/kb8Qr5cDnU+2vKLLR9slwtg7Pec9x4PUcuD9sbvIWgPUVsHbR21TdA2UdsGbdtrzVlTw5k8+jaEY69XinPVUfIr2t9JYz/CV2r3D1BLBwiOs8OkBQIAAOoGAABQSwMEFAAICAgAjTYuUAAAAAAAAAAAAAAAABIAAAB3b3JkL2ZvbnRUYWJsZS54bWyllE1OwzAQhU/AHSLv26QIEIqaVAgEG3bAAQbHSazaHmvsNPT2uDQ/UCSUhlWUjN/3xuMXrzcfWkU7QU6iydhqmbBIGI6FNFXG3l4fF7csch5MAQqNyNheOLbJL9ZtWqLxLgpy41LNM1Z7b9M4drwWGtwSrTChWCJp8OGVqlgDbRu74KgtePkulfT7+DJJbliHwYw1ZNIOsdCSEzos/UGSYllKLrpHr6ApvkfJA/JGC+O/HGMSKvSAxtXSup6m59JCse4hu782sdOqX9faKW4FQRvOQqujUYtUWEIunAtfH47FgbhKJgzwgBgUU1r46dl3okGaAXNIxglo8F4G725oX6hxI+MsnJrSyLH0LN8JaP+7C5gxz+96Kyel+IQQVL6hIZBzELwG8j1AzSEo5FtR3IPZwRDmopoU5xNSIaEi0GNI3Vknu0pO4vJSgxUjrfof7YmwsWPcr+bQvv2Bq+vzAJc9IO/uv6hNDegQ/juSoFicr+PuYsw/AVBLBwith20AeQEAAFoFAABQSwMEFAAICAgAjTYuUAAAAAAAAAAAAAAAAA8AAAB3b3JkL3N0eWxlcy54bWzVlt1u2jAUx59g74By3yYkgSFUWnWt2k2qumrtrqeDY4hVx7ZsB8qefs43JKFKAxIdXICPff7n+Ofjj4urt4gOVlgqwtnMGp471gAzxAPCljPr98vd2cQaKA0sAMoZnlkbrKyryy8X66nSG4rVwPgzNY3QzAq1FlPbVijEEahzLjAznQsuI9CmKZd2BPI1FmeIRwI0mRNK9MZ2HWds5TJ8ZsWSTXOJs4ggyRVf6MRlyhcLgnD+U3jILnEzl1uO4ggznUa0JaYmB85USIQq1KK+aqYzLERW701iFdFi3Fp0iRZIWJvFiGgWaM1lICRHWCljvc06S8Wh0wFgIlF6dElhN2aRSQSElTJJadSEytjnJnYOLZWqJlKxULRLIlnXA5lLkJtmFtCD57a/IJ2quKZgvHQsy4LsI4FCkLoQoH0UKEevOLgBtoKymINlp3KuKQUElhKiqkjVh1Z26NTK5TkEgSu15WFq95LHoip3v4/a1g4cjj4m4BYCl+YADDi6xQuIqVZJUz7JvJm30p87zrQarKegECEz61oSMOHXU6S2GhiUvlYEtkzhNVPleDuRUn+NeQVmo7huYblRdRsFtixsmP25/5aY7Twfu56lqLdSWQGIpCqUJPva/Tq28savmBoDxJrnsiKX3RayG2jSq8JI6I0w7gJkUmIiTFTTrh/BzHpMSjKdepB5mtsoxcwgwsWMWDYoi526NuU1zCnekX5JLJ3005GDxw5R2ifxHUNyczaFw6xjMMxWaQ4KBz9Z0VsFNF74TbfZ88V5xVg8bg3JBRPzg1kgVbNXawkLjc1lOXSdJOM5NkeAmYbvOO+vbVnJVfn5TrP8MttWnfXB5u7F5n4ybN64K7Z5oezUd7HXsosz24EYvb0YvVNjnOxSdPtSRJxyWdael3wbh+Sk5ZCcHAGvvxev/7nwupOueHdwjtNPA6ffgtM/As7RXpyjT4bTPybOvVf4gTjHe3GO/1ecpCZ8ErwvRJtXReO9kFpPzHW8w/Xj9/moBdboIFjP8Vy38io7TozMc3sxO+Jrvizqthutvai9lneXt+fdVfxTl/8AUEsHCCmXCZwiAwAA4hEAAFBLAwQUAAgICACNNi5QAAAAAAAAAAAAAAAAEQAAAHdvcmQvZG9jdW1lbnQueG1spZXdbtsgFMefYO9gcd/YTrOuteL0YtGmSdsUtekDEMA2Khh0wM6ypx/4Mx9V5Wa+Qecczu/8gWNYPv6RIqgZGK7KFMWzCAWsJIryMk/Ry/bbzT0KjMUlxUKVLEUHZtDj6tNyn1BFKslKGzhCaRJJUlRYq5MwNKRgEpuZ0qx0wUyBxNaZkIcSw2ulb4iSGlu+44LbQziPojvUYVSKKiiTDnEjOQFlVGZ9SqKyjBPWDX0GTKnbpqw7yU3FEJhwGlRpCq5NT5PX0lyw6CH1e4uopejn7fWUahTw3h2HFG2hvQKqQRFmjPOu2+BAjKMJG+gRQ8YUCac1eyUS83LA+OY4Aw21Z652t2kNalzIuBdGTBHShn7yHWA4XKrAV+zncb7mk7r4jOCybAVDQ16DIAUG2wPENQShyCujX3FZ46GZaT6pnc9IlOMcsByb1HzoZOPorF2eC6zZSMv/j/YdVKXHdl9cQzv6A+PPHwPMe8DKXYE7RQ9+1ME+cTcofUpR1H2oc62ZuHRuLl1Pa5bhStg3Ihs4ccaLRGPAP+jgjRsxegN+gA2Eq2U42u8JeUPwabmO2AxWuCk19hjUlugizROQGI2JuwM0MMOgZmi1Zca6Awvi+a2fbNuUVptPM4zYFqDz57+OXbgH6O7+duGluGspjh+iB1/JT/iF/UJ2ylrlejpeLBrBVunRECyzowU8L47MgmHK3Mq+zBszU8r2ZlfhdyW3B81c0L134FO7VfY6w/7Aw/HxW/0DUEsHCMFLkk43AgAAQQcAAFBLAwQUAAgICACNNi5QAAAAAAAAAAAAAAAAHAAAAHdvcmQvX3JlbHMvZG9jdW1lbnQueG1sLnJlbHOtkk1qwzAQhU/QO4jZ17LTH0qJnE0IZFvcAyjy+IdaIyFNSn37ipQkDgTThZfviXnzzYzWmx87iG8MsXekoMhyEEjG1T21Cj6r3eMbiMiaaj04QgUjRtiUD+sPHDSnmtj1PooUQlFBx+zfpYymQ6tj5jxSemlcsJqTDK302nzpFuUqz19lmGZAeZMp9rWCsK8LENXo8T/Zrml6g1tnjhaJ77SQnGoxBerQIis4yT+zyFIYyPsMqyUZIjKn5cYrxtmZQ3haEqFxxJU+DJNVXKw5iOclIehoDxjS3FeIizUH8bLoMXgccHqKkz63lzefvPwFUEsHCJAAq+vxAAAALAMAAFBLAwQUAAgICACNNi5QAAAAAAAAAAAAAAAACwAAAF9yZWxzLy5yZWxzjc87DsIwDAbgE3CHyDtNy4AQatIFIXVF5QBR4qYRzUNJePT2ZGAAxMBo+/dnue0ediY3jMl4x6CpaiDopFfGaQbn4bjeAUlZOCVm75DBggk6vmpPOItcdtJkQiIFcYnBlHPYU5rkhFakygd0ZTL6aEUuZdQ0CHkRGummrrc0vhvAP0zSKwaxVw2QYQn4j+3H0Ug8eHm16PKPE1+JIouoMTO4+6ioerWrwgLlLf14kT8BUEsHCC1ozyKxAAAAKgEAAFBLAwQUAAgICACNNi5QAAAAAAAAAAAAAAAAFQAAAHdvcmQvdGhlbWUvdGhlbWUxLnhtbO1ZS2/bNhy/D9h3IHRvZdlW6gR1itix261NGyRuhx5piZbYUKJA0kl8G9rjgAHDumGHFdhth2FbgRbYpfs02TpsHdCvsL8elimbzqNNtw6tDzZJ/f7vB0n58pXDiKF9IiTlcdtyLtYsRGKP+zQO2tbtQf9Cy0JS4djHjMekbU2ItK6sf/jBZbymQhIRBPSxXMNtK1QqWbNt6cEylhd5QmJ4NuIiwgqmIrB9gQ+Ab8Tseq22YkeYxhaKcQRsb41G1CNokLK01qfMewy+YiXTBY+JXS+TqFNkWH/PSX/kRHaZQPuYtS2Q4/ODATlUFmJYKnjQtmrZx7LXL9slEVNLaDW6fvYp6AoCf6+e0YlgWBI6/ebqpc2Sfz3nv4jr9XrdnlPyywDY88BSZwHb7LeczpSnBsqHi7y7NbfWrOI1/o0F/Gqn03FXK/jGDN9cwLdqK82NegXfnOHdRf07G93uSgXvzvArC/j+pdWVZhWfgUJG470FdBrPMjIlZMTZNSO8BfDWNAFmKFvLrpw+VstyLcL3uOgDIAsuVjRGapKQEfYA18WMDgVNBeA1grUn+ZInF5ZSWUh6giaqbX2cYKiIGeTlsx9fPnuCju4/Pbr/y9GDB0f3fzZQXcNxoFO9+P6Lvx99iv568t2Lh1+Z8VLH//7TZ7/9+qUZqHTg868f//H08fNvPv/zh4cG+IbAQx0+oBGR6CY5QDs8AsMMAshQnI1iEGKqU2zEgcQxTmkM6J4KK+ibE8ywAdchVQ/eEdACTMCr43sVhXdDMVbUALweRhXgFuesw4XRpuupLN0L4zgwCxdjHbeD8b5Jdncuvr1xArlMTSy7Iamouc0g5DggMVEofcb3CDGQ3aW04tct6gku+UihuxR1MDW6ZECHykx0jUYQl4lJQYh3xTdbd1CHMxP7TbJfRUJVYGZiSVjFjVfxWOHIqDGOmI68gVVoUnJ3IryKw6WCSAeEcdTziZQmmltiUlH3OrQOc9i32CSqIoWieybkDcy5jtzke90QR4lRZxqHOvYjuQcpitE2V0YleLVC0jnEAcdLw32HEnW22r5Ng9CcIOmTsTCVBOHVepywESZx0eErvTqi8XGNO4K+jc+7cUOrfP7to/9Ry94AJ5hqZr5RL8PNt+cuFz59+7vzJh7H2wQK4n1zft+c38XmvKyez78lz7qwrR+0MzbR0lP3iDK2qyaM3JBZ/5Zgnt+HxWySEZWH/CSEYSGuggsEzsZIcPUJVeFuiBMQ42QSAlmwDiRKuISrhbWUd3Y/pWBztuZOL5WAxmqL+/lyQ79slmyyWSB1QY2UwWmFNS69njAnB55SmuOapbnHSrM1b0LdIJy+SnBW6rloSBTMiJ/6PWcwDcsbDJFT02IUYp8YljX7nMYb8aZ7JiXOx8m1BSfbi9XE4uoMHbStVbfuWsjDSdsawWkJhlEC/GTaaTAL4rblqdzAk2txzuJVc1Y5NXeZwRURiZBqE8swp8oeTV+lxDP9624z9cP5GGBoJqfTotFy/kMt7PnQktGIeGrJymxaPONjRcRu6B+gIRuLHQx6N/Ps8qmETl+fTgTkdrNIvGrhFrUx/8qmqBnMkhAX2d7SYp/Ds3GpQzbT1LOX6P6KpjTO0RT33TUlzVw4nzb87NIEu7jAKM3RtsWFCjl0oSSkXl/Avp/JAr0QlEWqEmLpC+hUV7I/61s5j7zJBaHaoQESFDqdCgUh26qw8wRmTl3fHqeMij5TqiuT/HdI9gkbpNW7ktpvoXDaTQpHZLj5oNmm6hoG/bf44NJ8pY1nJqh5ls2vqTV9bStYfT0VTrMBa+LqZovr7tKdZ36rTeCWgdIvaNxUeGx2PB3wHYg+Kvd5BIl4oVWUX7k4BJ1bmnEpq3/rFNRaEu/zPDtqzm4scfbx4l7d2a7B1+7xrrYXS9TW7iHZbOGPKD68B7I34XozZvmKTGCWD7ZFZvCQ+5NiyGTeEnJHTFs6i3fICFH/cBrWOY8W//SUm/lOLiC1vSRsnExY4GebSElcP5m4pJje8Uri7BZnYsBmknN8HuWyRZaeYvHruOwUyptdZsze07rsFIF6BZepw+NdVnjKNiUeOVQCd6d/XUH+2rOUXf8HUEsHCCFaooQsBgAA2x0AAFBLAwQUAAgICACNNi5QAAAAAAAAAAAAAAAAEwAAAFtDb250ZW50X1R5cGVzXS54bWy1k01uwjAQhU/QO0TeVsTQRVVVBBb9WbZd0AMMzgSs+k+egcLtOwmQBQKplZqNZfvNvPd5JE/nO++KLWayMVRqUo5VgcHE2oZVpT4Xr6MHVRBDqMHFgJXaI6n57Ga62CekQpoDVWrNnB61JrNGD1TGhEGUJmYPLMe80gnMF6xQ343H99rEwBh4xK2Hmk2fsYGN4+LpcN9aVwpSctYAC5cWM1W87EQ8YLZn/Yu+bajPYEZHkDKj62pobRPdngeISm3Cu0wm2xr/FBGbxhqso9l4aSm/Y65TjgaJZKjelYTMsjumfkDmN/Biq9tKfVLL4yOHQeC9w2sAnTZofCNeC1g6vEzQy4NChI1fYpb9ZYheHhSiVzzYcBmkL/lHDpaPemX4nXRYJ6dI3f322Q9QSwcIM68PtywBAAAtBAAAUEsBAhQAFAAICAgAjTYuUEkTQ39oAQAAPQUAABIAAAAAAAAAAAAAAAAAAAAAAHdvcmQvbnVtYmVyaW5nLnhtbFBLAQIUABQACAgIAI02LlCOs8OkBQIAAOoGAAARAAAAAAAAAAAAAAAAAKgBAAB3b3JkL3NldHRpbmdzLnhtbFBLAQIUABQACAgIAI02LlCth20AeQEAAFoFAAASAAAAAAAAAAAAAAAAAOwDAAB3b3JkL2ZvbnRUYWJsZS54bWxQSwECFAAUAAgICACNNi5QKZcJnCIDAADiEQAADwAAAAAAAAAAAAAAAAClBQAAd29yZC9zdHlsZXMueG1sUEsBAhQAFAAICAgAjTYuUMFLkk43AgAAQQcAABEAAAAAAAAAAAAAAAAABAkAAHdvcmQvZG9jdW1lbnQueG1sUEsBAhQAFAAICAgAjTYuUJAAq+vxAAAALAMAABwAAAAAAAAAAAAAAAAAegsAAHdvcmQvX3JlbHMvZG9jdW1lbnQueG1sLnJlbHNQSwECFAAUAAgICACNNi5QLWjPIrEAAAAqAQAACwAAAAAAAAAAAAAAAAC1DAAAX3JlbHMvLnJlbHNQSwECFAAUAAgICACNNi5QIVqihCwGAADbHQAAFQAAAAAAAAAAAAAAAACfDQAAd29yZC90aGVtZS90aGVtZTEueG1sUEsBAhQAFAAICAgAjTYuUDOvD7csAQAALQQAABMAAAAAAAAAAAAAAAAADhQAAFtDb250ZW50X1R5cGVzXS54bWxQSwUGAAAAAAkACQBCAgAAexUAAAAA';

    return cloudinary.v2.uploader.upload(data, {
      resource_type: 'auto', // this defaults to 'image' if not specified
      tags: UPLOAD_TAGS
    });
  });
  it('should allow uploading with parameters containing &', function () {
    const publicId = `ampersand-test-${Date.now()}`;
    return cloudinary.v2.uploader.upload('https://cloudinary.com/images/old_logo.png', {
      notification_url: 'https://example.com?exampleparam1=aaa&exampleparam2=bbb',
      public_id: publicId
    }).then((result) => {
      expect(result).to.have.property('public_id');
      expect(result.public_id).to.equal(publicId);
    }).catch((error) => {
      expect(error).to.be(null);
    });
  });
  it('should allow upload with url safe base64 in overlay', function () {
    const overlayUrl = 'https://res.cloudinary.com/demo/image/upload/logos/cloudinary_full_logo_white_small.png';
    const baseImageUrl = 'https://cloudinary.com/images/old_logo.png';

    const options = { transformation: { overlay: { url: overlayUrl } } };
    return cloudinary.v2.uploader.upload(baseImageUrl, options)
      .then((result) => {
        expect(result).to.have.key(""created_at"");
      });
  });
  describe(""remote urls "", function () {
    const mocked = helper.mockTest();
    it(""should send s3:// URLs to server"", function () {
      cloudinary.v2.uploader.upload(""s3://test/1.jpg"", {
        tags: UPLOAD_TAGS
      });
      sinon.assert.calledWith(mocked.write, sinon.match(helper.uploadParamMatcher('file', ""s3://test/1.jpg"")));
    });
    it(""should send gs:// URLs to server"", function () {
      cloudinary.v2.uploader.upload(""gs://test/1.jpg"", {
        tags: UPLOAD_TAGS
      });
      sinon.assert.calledWith(mocked.write, sinon.match(helper.uploadParamMatcher('file', ""gs://test/1.jpg"")));
    });
    it(""should send ftp:// URLs to server"", function () {
      cloudinary.v2.uploader.upload(""ftp://example.com/1.jpg"", {
        tags: UPLOAD_TAGS
      });
      sinon.assert.calledWith(mocked.write, sinon.match(helper.uploadParamMatcher('file', ""ftp://example.com/1.jpg"")));
    });
  });
  describe(""rename"", function () {
    this.timeout(TIMEOUT.LONG);
    it(""should successfully rename a file"", function () {
      return uploadImage().then(function (result) {
        return cloudinary.v2.uploader.rename(result.public_id, result.public_id + ""2"").then(function () {
          return result.public_id;
        });
      }).then(function (public_id) {
        return cloudinary.v2.api.resource(public_id + ""2"");
      });
    });
    it(""should not rename to an existing public_id"", function () {
      return Promise.all([uploadImage(), uploadImage()]).then(function (results) {
        return cloudinary.v2.uploader.rename(results[0].public_id, results[1].public_id);
      }).then(function () {
        expect().fail();
      }).catch(function (error) {
        expect(error).to.be.ok();
      });
    });
    it(""should allow to rename to an existing ID, if overwrite is true"", function () {
      return Promise.all([uploadImage(), uploadImage()]).then(function (results) {
        return cloudinary.v2.uploader.rename(results[0].public_id, results[1].public_id, {
          overwrite: true
        });
      }).then(function ({ public_id }) {
        return cloudinary.v2.api.resource(public_id);
      }).then(function ({ format }) {
        expect(format).to.eql(""png"");
      });
    });
    it('should include tags in rename response if requested explicitly', async () => {
      const uploadResult = await cloudinary.v2.uploader.upload(IMAGE_FILE, { context: 'alt=Example|class=Example', tags: ['test-tag'] });

      const renameResult = await cloudinary.v2.uploader.rename(uploadResult.public_id, `${uploadResult.public_id}-renamed`, { tags: true, context: true });

      expect(renameResult).to.have.property('tags');
      expect(renameResult).to.have.property('context');
    });
    it('should include notification_url in rename response if included in the request', async () => {
      return helper.provideMockObjects(function (mockXHR, writeSpy, requestSpy) {
        const renameResult = cloudinary.v2.uploader.rename('irrelevant', 'irrelevant', { notification_url: 'https://notification-url.com' });
        sinon.assert.calledWith(writeSpy, sinon.match(helper.uploadParamMatcher('notification_url', 'https://notification-url.com')));
      });
    });
    return context("":invalidate"", function () {
      var spy, xhr;
      spy = void 0;
      xhr = void 0;
      before(function () {
        xhr = sinon.useFakeXMLHttpRequest();
        spy = sinon.spy(ClientRequest.prototype, 'write');
      });
      after(function () {
        spy.restore();
        return xhr.restore();
      });
      it(""should pass the invalidate value in rename to the server"", function () {
        cloudinary.v2.uploader.rename(""first_id"", ""second_id"", {
          invalidate: true
        });
        expect(spy.calledWith(sinon.match(function (arg) {
          return arg.toString().match(/name=""invalidate""/);
        }))).to.be.ok();
      });
    });
  });
  describe(""destroy"", function () {
    this.timeout(TIMEOUT.MEDIUM);
    it(""should delete a resource"", function () {
      var public_id;
      return uploadImage().then(function (result) {
        public_id = result.public_id;
        return cloudinary.v2.uploader.destroy(public_id);
      }).then(function (result) {
        expect(result.result).to.eql(""ok"");
        return cloudinary.v2.api.resource(public_id);
      }).then(function () {
        expect().fail();
      }).catch(function (error) {
        expect(error).to.be.ok();
      });
    });
    it('should pass notification_url', async () => {
      return helper.provideMockObjects(function (mockXHR, writeSpy, requestSpy) {
        const renameResult = cloudinary.v2.uploader.destroy('irrelevant', { notification_url: 'https://notification-url.com' });
        sinon.assert.calledWith(writeSpy, sinon.match(helper.uploadParamMatcher('notification_url', 'https://notification-url.com')));
      });
    });
  });
  it(""should support `async` option in explicit api"", function () {
    return cloudinary.v2.uploader.explicit(""sample"", {
      type: ""facebook"",
      eager: [
        {
          crop: ""scale"",
          width: ""2.0""
        }
      ],
      async: true
    }).then(function (result) {
      expect(result.status).to.eql('pending');
      expect(result.resource_type).to.eql('image');
      expect(result.type).to.eql('facebook');
      expect(result.public_id).to.eql('sample');
    });
  });
  it(""should successfully call explicit api"", function () {
    return cloudinary.v2.uploader.explicit(""sample"", {
      type: ""upload"",
      eager: [
        {
          crop: ""scale"",
          width: ""2.0""
        }
      ]
    }).then(function (result) {
      var url = cloudinary.utils.url(""sample"", {
        type: ""upload"",
        crop: ""scale"",
        width: ""2.0"",
        format: ""jpg"",
        version: result.version
      });
      expect(result.eager[0].secure_url).to.eql(url);
    });
  });
  it(""should support eager in upload"", function () {
    this.timeout(TIMEOUT.SHORT);
    return cloudinary.v2.uploader.upload(IMAGE_FILE, {
      eager: [
        {
          crop: ""scale"",
          width: ""2.0""
        }
      ],
      tags: UPLOAD_TAGS
    });
  });
  describe(""extra headers"", function () {
    it(""should support extra headers in object format e.g. {Link: \""1\""}"", function () {
      return helper.provideMockObjects(function (mockXHR, writeSpy, requestSpy) {
        cloudinary.v2.uploader.upload(IMAGE_FILE, {
          extra_headers: {
            Link: ""1""
          }
        });
        assert.ok(requestSpy.args[0][0].headers.Link);
        assert.equal(requestSpy.args[0][0].headers.Link, ""1"");
      });
    });
  });
  describe(""text images"", function () {
    it(""should successfully generate text image"", function () {
      return cloudinary.v2.uploader.text(""hello world"", {
        tags: UPLOAD_TAGS
      }).then(function (result) {
        expect(result.width).to.within(50, 70);
        expect(result.height).to.within(5, 15);
      });
    });
    var mocked = helper.mockTest();
    it(""should pass text image parameters to server"", function () {
      cloudinary.v2.uploader.text(""hello word"",
        {
          font_family: ""Arial"",
          font_size: 12,
          font_weight: ""black""
        });
      sinon.assert.calledWith(mocked.write, sinon.match(helper.uploadParamMatcher(""font_family"", ""Arial"")));
      sinon.assert.calledWith(mocked.write, sinon.match(helper.uploadParamMatcher(""font_size"", ""12"")));
      sinon.assert.calledWith(mocked.write, sinon.match(helper.uploadParamMatcher(""font_weight"", ""black"")));
    });
  });
  it(""should successfully upload stream"", function (done) {
    var file_reader, stream;
    stream = cloudinary.v2.uploader.upload_stream({
      tags: UPLOAD_TAGS
    }, function (error, result) {
      var expected_signature;
      expect(result.width).to.eql(241);
      expect(result.height).to.eql(51);
      expected_signature = cloudinary.utils.api_sign_request({
        public_id: result.public_id,
        version: result.version
      }, cloudinary.config().api_secret);
      expect(result.signature).to.eql(expected_signature);
      done();
    });
    file_reader = fs.createReadStream(IMAGE_FILE, {
      encoding: 'binary'
    });
    file_reader.on('data', function (chunk) {
      stream.write(chunk, 'binary');
    });
    file_reader.on('end', function () {
      stream.end();
    });
  });
  describe(""tags"", function () {
    this.timeout(TIMEOUT.MEDIUM);
    it(""should add tags to existing resources"", function () {
      return uploadImage().then(function (result) {
        return uploadImage().then(function (res) {
          return [result.public_id, res.public_id];
        });
      }).then(function ([firstId, secondId]) {
        return cloudinary.v2.uploader.add_tag(""tag1"", [firstId, secondId]).then(function () {
          return [firstId, secondId];
        });
      }).then(function ([firstId, secondId]) {
        return cloudinary.v2.api.resource(secondId).then(function (r1) {
          expect(r1.tags).to.contain(""tag1"");
        }).then(function () {
          return [firstId, secondId];
        });
      }).then(function ([firstId, secondId]) {
        return cloudinary.v2.uploader.remove_all_tags([firstId, secondId, 'noSuchId']).then(function (result) {
          return [firstId, secondId, result];
        });
      }).then(function ([firstId, secondId, result]) {
        expect(result.public_ids).to.contain(firstId);
        expect(result.public_ids).to.contain(secondId);
        expect(result.public_ids).to.not.contain('noSuchId');
      });
    });
    it(""should keep existing tags when adding a new tag"", function () {
      return uploadImage().then(function (result) {
        return cloudinary.v2.uploader.add_tag(""tag1"", result.public_id).then(function () {
          return result.public_id;
        });
      }).then(function (publicId) {
        return cloudinary.v2.uploader.add_tag(""tag2"", publicId).then(function () {
          return publicId;
        });
      }).then(function (publicId) {
        return cloudinary.v2.api.resource(publicId);
      }).then(function (result) {
        expect(result.tags).to.contain(""tag1"").and.contain(""tag2"");
      });
    });
    it(""should replace existing tag"", function () {
      return cloudinary.v2.uploader.upload(IMAGE_FILE, {
        tags: [""tag1"", ""tag2"", TEST_TAG]
      }).then(function (result) {
        var public_id = result.public_id;
        return cloudinary.v2.uploader.replace_tag(""tag3Å"", public_id).then(function () {
          return public_id;
        });
      }).then(function (public_id) { // TODO this also tests non ascii characters
        return cloudinary.v2.api.resource(public_id);
      }).then(function (result) {
        expect(result.tags).to.eql([""tag3Å""]);
      });
    });
  });
  describe(""context"", function () {
    this.timeout(TIMEOUT.MEDIUM);
    before(function () {
      return Q.all([uploadImage(), uploadImage()]).spread((result1, result2) => {
        this.first_id = result1.public_id;
        this.second_id = result2.public_id;
      });
    });
    it(""should add context to existing resources"", function () {
      return cloudinary.v2.uploader
        .add_context('alt=testAlt|custom=testCustom', [this.first_id, this.second_id])
        .then(() => cloudinary.v2.uploader.add_context({
          alt2: ""testAlt2"",
          custom2: ""testCustom2""
        }, [this.first_id, this.second_id]))
        .then(() => cloudinary.v2.api.resource(this.second_id))
        .then(({ context }) => {
          expect(context.custom.alt).to.equal('testAlt');
          expect(context.custom.alt2).to.equal('testAlt2');
          expect(context.custom.custom).to.equal('testCustom');
          expect(context.custom.custom2).to.equal('testCustom2');
          return cloudinary.v2.uploader.remove_all_context([this.first_id, this.second_id, 'noSuchId']);
        }).then(({ public_ids }) => {
          expect(public_ids).to.contain(this.first_id);
          expect(public_ids).to.contain(this.second_id);
          expect(public_ids).to.not.contain('noSuchId');
          return cloudinary.v2.api.resource(this.second_id);
        }).then(function ({ context }) {
          expect(context).to.be(void 0);
        });
    });
    it(""should upload with context containing reserved characters"", function () {
      var context = {
        key1: 'value1',
        key2: 'valu\e2',
        key3: 'val=u|e3',
        key4: 'val\=ue'
      };
      return cloudinary.v2.uploader.upload(IMAGE_FILE, {
        context: context
      }).then(function (result) {
        return cloudinary.v2.api.resource(result.public_id, {
          context: true
        });
      }).then(function (result) {
        expect(result.context.custom).to.eql(context);
      });
    });
  });
  it(""should support timeouts"", function () {
    // testing a 1ms timeout, nobody is that fast.
    return cloudinary.v2.uploader.upload(""https://cloudinary.com/images/old_logo.png"", {
      timeout: 1,
      tags: UPLOAD_TAGS
    }).then(function () {
      expect().fail();
    }).catch(function ({ error }) {
      expect(error.http_code).to.eql(499);
      expect(error.message).to.eql(""Request Timeout"");
    });
  });
  it(""should upload a file and base public id on the filename if use_filename is set to true"", function () {
    this.timeout(TIMEOUT.MEDIUM);
    return cloudinary.v2.uploader.upload(IMAGE_FILE, {
      use_filename: true,
      tags: UPLOAD_TAGS
    }).then(function ({ public_id }) {
      expect(public_id).to.match(/logo_[a-zA-Z0-9]{6}/);
    });
  });
  it(""should upload a file and set the filename as the public_id if use_filename is set to true and unique_filename is set to false"", function () {
    return cloudinary.v2.uploader.upload(IMAGE_FILE, {
      use_filename: true,
      unique_filename: false,
      tags: UPLOAD_TAGS
    }).then(function (result) {
      expect(result.public_id).to.eql(""logo"");
    });
  });
  describe(""allowed_formats"", function () {
    it(""should allow whitelisted formats"", function () {
      return cloudinary.v2.uploader.upload(IMAGE_FILE, {
        allowed_formats: [""png""],
        tags: UPLOAD_TAGS
      }).then(function (result) {
        expect(result.format).to.eql(""png"");
      });
    });
    it(""should prevent non whitelisted formats from being uploaded"", function () {
      return cloudinary.v2.uploader.upload(IMAGE_FILE, {
        allowed_formats: [""jpg""],
        tags: UPLOAD_TAGS
      }).then(function () {
        expect().fail();
      }).catch(function (error) {
        expect(error.http_code).to.eql(400);
      });
    });
    it(""should allow non whitelisted formats if type is specified and convert to that type"", function () {
      return cloudinary.v2.uploader.upload(IMAGE_FILE, {
        allowed_formats: [""jpg""],
        format: ""jpg"",
        tags: UPLOAD_TAGS
      }).then(function (result) {
        expect(result.format).to.eql(""jpg"");
      });
    });
  });
  it(""should allow sending face coordinates"", function () {
    var coordinates, custom_coordinates, different_coordinates, out_coordinates;
    this.timeout(TIMEOUT.LONG);
    coordinates = [[120, 30, 109, 150], [121, 31, 110, 151]];
    out_coordinates = [
      [120,
        30,
        109,
        51],
      [
        121,
        31,
        110,
        51 // coordinates are limited to the image dimensions
      ]
    ];
    different_coordinates = [[122, 32, 111, 152]];
    custom_coordinates = [1, 2, 3, 4];
    return cloudinary.v2.uploader.upload(IMAGE_FILE, {
      face_coordinates: coordinates,
      faces: true,
      tags: UPLOAD_TAGS
    }).then(function (result) {
      expect(result.faces).to.eql(out_coordinates);
      return cloudinary.v2.uploader.explicit(result.public_id, {
        faces: true,
        face_coordinates: different_coordinates,
        custom_coordinates: custom_coordinates,
        type: ""upload""
      });
    }).then(function (result) {
      expect(result.faces).not.to.be(void 0);
      return cloudinary.v2.api.resource(result.public_id, {
        faces: true,
        coordinates: true
      });
    }).then(function (info) {
      expect(info.faces).to.eql(different_coordinates);
      expect(info.coordinates).to.eql({
        faces: different_coordinates,
        custom: [custom_coordinates]
      });
    });
  });
  it(""should allow sending context"", function () {
    this.timeout(TIMEOUT.LONG);
    return cloudinary.v2.uploader.upload(IMAGE_FILE, {
      context: {
        caption: ""some caption"",
        alt: ""alternative""
      },
      tags: UPLOAD_TAGS
    }).then(function ({ public_id }) {
      return cloudinary.v2.api.resource(public_id, {
        context: true
      });
    }).then(function ({ context }) {
      expect(context.custom.caption).to.eql(""some caption"");
      expect(context.custom.alt).to.eql(""alternative"");
    });
  });
  it(""should support requesting manual moderation"", function () {
    this.timeout(TIMEOUT.LONG);
    return cloudinary.v2.uploader.upload(IMAGE_FILE, {
      moderation: ""manual"",
      tags: UPLOAD_TAGS
    }).then(function (result) {
      expect(result.moderation[0].status).to.eql(""pending"");
      expect(result.moderation[0].kind).to.eql(""manual"");
    });
  });
  it(""should support requesting raw conversion"", function () {
    return cloudinary.v2.uploader.upload(RAW_FILE, {
      raw_convert: ""illegal"",
      resource_type: ""raw"",
      tags: UPLOAD_TAGS
    }).then(function () {
      expect().fail();
    }).catch(function (error) {
      expect(error != null).to.be(true);
      expect(error.message).to.contain(""Raw convert is invalid"");
    });
  });
  it(""should support requesting categorization"", function () {
    return cloudinary.v2.uploader.upload(IMAGE_FILE, {
      categorization: ""illegal"",
      tags: UPLOAD_TAGS
    }).then(function () {
      expect().fail();
    }).catch(function (error) {
      expect(error != null).to.be(true);
    });
  });
  it(""should support requesting detection"", function () {
    return cloudinary.v2.uploader.upload(IMAGE_FILE, {
      detection: ""illegal"",
      tags: UPLOAD_TAGS
    }).then(function () {
      expect().fail();
    }).catch(function (error) {
      expect(error).not.to.be(void 0);
      expect(error.message).to.contain(""Detection invalid model 'illegal'"");
    });
  });
  it(""should support requesting background_removal"", function () {
    return cloudinary.v2.uploader.upload(IMAGE_FILE, {
      background_removal: ""illegal"",
      tags: UPLOAD_TAGS
    }).then(function () {
      expect().fail();
    }).catch(function (error) {
      expect(error != null).to.be(true);
      expect(error.message).to.contain(""is invalid"");
    });
  });
  it(""should support requesting analysis"", function () {
    return cloudinary.v2.uploader.upload(IMAGE_FILE, {
      quality_analysis: true,
      tags: UPLOAD_TAGS
    }).then(function (result) {
      expect(result).to.have.key(""quality_analysis"");
    });
  });

  describe('when passing visual_search in parameters', () => {
    var spy, xhr;
    spy = void 0;
    xhr = void 0;
    before(function () {
      xhr = sinon.useFakeXMLHttpRequest();
      spy = sinon.spy(ClientRequest.prototype, 'write');
    });
    after(function () {
      spy.restore();
      return xhr.restore();
    });

    it('should pass its value to the upload api', () => {
      cloudinary.v2.uploader.upload(IMAGE_FILE, {
        visual_search: true
      });

      expect(spy.calledWith(sinon.match((arg) => {
        return arg.toString().match(/visual_search=true/);
      })));
    });
  });

  describe('when passing on_success in parameters', () => {
    var spy, xhr;
    spy = void 0;
    xhr = void 0;
    before(function () {
      xhr = sinon.useFakeXMLHttpRequest();
      spy = sinon.spy(ClientRequest.prototype, 'write');
    });
    after(function () {
      spy.restore();
      return xhr.restore();
    });

    it('should pass its value to the upload api', () => {
      cloudinary.v2.uploader.upload(IMAGE_FILE, {
        on_success: 'current_asset.update({tags: [""autocaption""]});'
      });

      expect(spy.calledWith(sinon.match((arg) => {
        return arg.toString().match(/on_success='current_asset.update({tags: [""autocaption""]});'/);
      })));
    });
  });

  describe(""upload_chunked"", function () {
    this.timeout(TIMEOUT.LONG * 10);
    it(""should specify chunk size"", function (done) {
      return fs.stat(LARGE_RAW_FILE, function (err, stat) {
        cloudinary.v2.uploader.upload_large(LARGE_RAW_FILE, {
          chunk_size: 7000000,
          timeout: TIMEOUT.LONG,
          tags: UPLOAD_TAGS
        }, function (error, result) {
          if (error != null) {
            done(new Error(error.message));
          }
          expect(result.bytes).to.eql(stat.size);
          expect(result.etag).to.eql(""4c13724e950abcb13ec480e10f8541f5"");
          return done();
        });
      });
    });
    it(""should return error if value is less than 5MB"", function (done) {
      fs.stat(LARGE_RAW_FILE, function (err, stat) {
        cloudinary.v2.uploader.upload_large(LARGE_RAW_FILE, {
          chunk_size: 40000,
          tags: UPLOAD_TAGS
        }, function (error, result) {
          expect(error.message).to.eql(""All parts except EOF-chunk must be larger than 5mb"");
          done();
        });
      });
    });
    it(""should use file name"", function (done) {
      fs.stat(LARGE_RAW_FILE, function (err, stat) {
        return cloudinary.v2.uploader.upload_large(LARGE_RAW_FILE, {
          use_filename: true
        }, function (error, result) {
          if (error != null) {
            done(new Error(error.message));
          }
          expect(result.public_id).to.match(/TheCompleteWorksOfShakespeare_[a-zA-Z0-9]{6}/);
          done();
        });
      });
    });
    it(""should support uploading a small raw file"", function (done) {
      fs.stat(RAW_FILE, function (err, stat) {
        cloudinary.v2.uploader.upload_large(RAW_FILE, {
          tags: UPLOAD_TAGS
        }, function (error, result) {
          if (error != null) {
            done(new Error(error.message));
          }
          expect(result.bytes).to.eql(stat.size);
          expect(result.etag).to.eql(""ffc265d8d1296247972b4d478048e448"");
          done();
        });
      });
    });
    it(""should add original filename on upload large"", function (done) {
      fs.stat(RAW_FILE, function (err, stat) {
        cloudinary.v2.uploader.upload_large(RAW_FILE, {
          filename: 'my_file_name'
        }, function (error, result) {
          if (error != null) {
            done(new Error(error.message));
          }
          expect(result.original_filename).to.eql('my_file_name');
          done();
        });
      });
    });
    it(""should support uploading a small image file"", function (done) {
      fs.stat(IMAGE_FILE, function (err, stat) {
        return cloudinary.v2.uploader.upload_chunked(IMAGE_FILE, {
          tags: UPLOAD_TAGS
        }, function (error, result) {
          if (error != null) {
            done(new Error(error.message));
          }
          expect(result.bytes).to.eql(stat.size);
          expect(result.etag).to.eql(""7dc60722d4653261648038b579fdb89e"");
          done();
        });
      });
    });
    it(""should support uploading large video files"", function () {
      var stat, writeSpy;
      this.timeout(TIMEOUT.LONG * 10);
      writeSpy = sinon.spy(ClientRequest.prototype, 'write');
      stat = fs.statSync(LARGE_VIDEO);
      expect(stat).to.be.ok();
      return Q.denodeify(cloudinary.v2.uploader.upload_chunked)(LARGE_VIDEO, {
        chunk_size: 6000000,
        resource_type: 'video',
        timeout: TIMEOUT.LONG * 10,
        tags: UPLOAD_TAGS
      }).then(function (result) {
        var timestamps;
        expect(result.bytes).to.eql(stat.size);
        expect(result.etag).to.eql(""ff6c391d26be0837ee5229885b5bd571"");
        timestamps = writeSpy.args.map(function (a) {
          return a[0].toString();
        }).filter(function (p) {
          return p.match(/timestamp/);
        }).map(function (p) {
          return p.match(/""timestamp""\s+(\d+)/)[1];
        });
        expect(timestamps.length).to.be.greaterThan(1);
        expect(uniq(timestamps)).to.eql(uniq(timestamps)); // uniq b/c last timestamp may be duplicated
      }).finally(function () {
        writeSpy.restore();
      });
    });
    it(""should update timestamp for each chunk"", function () {
      var writeSpy = sinon.spy(ClientRequest.prototype, 'write');
      return Q.denodeify(cloudinary.v2.uploader.upload_chunked)(LARGE_VIDEO, {
        chunk_size: 6000000,
        resource_type: 'video',
        timeout: TIMEOUT.LONG * 10,
        tags: UPLOAD_TAGS
      }).then(function () {
        var timestamps = writeSpy.args.map(function (a) {
          return a[0].toString();
        }).filter(function (p) {
          return p.match(/timestamp/);
        }).map(function (p) {
          return p.match(/""timestamp""\s+(\d+)/)[1];
        });
        expect(timestamps.length).to.be.greaterThan(1);
        expect(uniq(timestamps)).to.eql(uniq(timestamps));
      }).finally(function () {
        writeSpy.restore();
      });
    });
    it(""should support uploading based on a url"", function (done) {
      this.timeout(TIMEOUT.MEDIUM);
      cloudinary.v2.uploader.upload_large(""https://cloudinary.com/images/old_logo.png"", {
        tags: UPLOAD_TAGS
      }, function (error, result) {
        if (error != null) {
          done(new Error(error.message));
        }
        expect(result.etag).to.eql(""7dc60722d4653261648038b579fdb89e"");
        done();
      });
    });
  });
  describe(""dynamic folders"", () => {
    const mocked = helper.mockTest();
    it('should pass dynamic folder params', () => {
      const public_id_prefix = ""fd_public_id_prefix"";
      const asset_folder = ""asset_folder"";
      const display_name = ""display_name"";
      const use_filename_as_display_name = true;
      const folder = ""folder/test"";
      UPLOADER_V2.upload(IMAGE_FILE, {
        public_id_prefix,
        asset_folder,
        display_name,
        use_filename_as_display_name,
        folder
      });
      sinon.assert.calledWithMatch(mocked.write, helper.uploadParamMatcher(""public_id_prefix"", public_id_prefix));
      sinon.assert.calledWithMatch(mocked.write, helper.uploadParamMatcher(""asset_folder"", asset_folder));
      sinon.assert.calledWithMatch(mocked.write, helper.uploadParamMatcher(""display_name"", display_name));
      sinon.assert.calledWithMatch(mocked.write, helper.uploadParamMatcher(""use_filename_as_display_name"", 1));
      sinon.assert.calledWithMatch(mocked.write, helper.uploadParamMatcher(""folder"", folder));
    });

    it('should not contain asset_folder in public_id', async function () {
      if (!shouldTestFeature(DYNAMIC_FOLDERS)) {
        this.skip();
      }

      const asset_folder = ""asset_folder"";
      return UPLOADER_V2.upload(IMAGE_FILE, {
        asset_folder
      }).then((result) => {
        expect(result.public_id).to.not.contain('asset_folder')
      });
    });

    it('should not contain asset_folder in public_id when use_asset_folder_as_public_id_prefix is false', async function () {
      if (!shouldTestFeature(DYNAMIC_FOLDERS)) {
        this.skip();
      }

      const asset_folder = ""asset_folder"";
      return UPLOADER_V2.upload(IMAGE_FILE, {
        asset_folder,
        use_asset_folder_as_public_id_prefix: false
      }).then((result) => {
        expect(result.public_id).to.not.contain('asset_folder')
      });
    });

    it('should contain asset_folder in public_id when use_asset_folder_as_public_id_prefix is true', async function () {
      if (!shouldTestFeature(DYNAMIC_FOLDERS)) {
        this.skip();
      }

      const asset_folder = ""asset_folder"";
      return UPLOADER_V2.upload(IMAGE_FILE, {
        asset_folder,
        use_asset_folder_as_public_id_prefix: true
      }).then((result) => {
        expect(result.public_id).to.contain('asset_folder')
      });
    });
  });
  it(""should support unsigned uploading using presets"", async function () {
    this.timeout(TIMEOUT.LONG);

    let preset = await cloudinary.v2.api.create_upload_preset({
      folder: ""upload_folder"",
      unsigned: true,
      tags: UPLOAD_TAGS
    }).catch((err) => {
      console.log(err);
      throw new Error('create_upload_preset failed');
    });

    let uploadResponse = await cloudinary.v2.uploader.unsigned_upload(IMAGE_FILE, preset.name, {
      tags: UPLOAD_TAGS
    }).catch((err) => {
      console.log(err);
      throw new Error('unsigned_upload failed');
    });

    expect(uploadResponse.public_id).to.match(/^upload_folder\/[a-z0-9]+$/);

    await cloudinary.v2.api.delete_upload_preset(preset.name).catch((err) => {
      console.log(err);
      // we don't fail the test if the delete fails
    });
  });

  it(""should reject with promise rejection if disable_promises: false"", function (done) {
    const spy = sinon.spy();

    cloudinary.v2.uploader.upload_large(EMPTY_IMAGE, { disable_promises: false }, () => { });

    function unhandledRejection() {
      spy();
    }
    process.on('unhandledRejection', unhandledRejection);

    // Promises are not disabled meaning we should throw unhandledRejection
    setTimeout(() => {
      expect(sinon.assert.called(spy));
      process.removeListener('unhandledRejection', unhandledRejection);
      done();
    }, 2000);
  });

  it(""should reject with promise rejection by default"", function (done) {
    const spy = sinon.spy();

    cloudinary.v2.uploader.upload_large(EMPTY_IMAGE, () => { });

    function unhandledRejection() {
      spy();
    }
    process.on('unhandledRejection', unhandledRejection);

    // Promises are not disabled meaning we should throw unhandledRejection
    setTimeout(() => {
      expect(sinon.assert.called(spy));
      process.removeListener('unhandledRejection', unhandledRejection);
      done();
    }, 2000);
  });

  it(""should reject without promise rejection if disable_promises: true"", function (done) {
    const spy = sinon.spy();

    cloudinary.v2.uploader.upload_large(EMPTY_IMAGE, { disable_promises: true }, () => { });

    function unhandledRejection() {
      spy();
    }
    process.on('unhandledRejection', unhandledRejection);

    // Promises are  disabled meaning unhandledRejection was not called
    setTimeout(() => {
      expect(sinon.assert.notCalled(spy));
      process.removeListener('unhandledRejection', unhandledRejection);
      done();
    }, 2000);
  });


  it(""should reject promise if error code is returned from the server"", function () {
    return cloudinary.v2.uploader.upload(EMPTY_IMAGE, {
      tags: UPLOAD_TAGS
    }).then(function () {
      expect().fail(""server should return an error when uploading an empty file"");
    }).catch(function (error) {
      expect(error.message.toLowerCase()).to.contain(""empty"");
    });
  });
  it(""should successfully upload with pipes"", function (done) {
    this.timeout(TIMEOUT.LONG);
    const upload = cloudinary.v2.uploader.upload_stream({
      tags: UPLOAD_TAGS
    }, function (error, result) {
      var expected_signature;
      expect(result.width).to.eql(241);
      expect(result.height).to.eql(51);
      expected_signature = cloudinary.utils.api_sign_request({
        public_id: result.public_id,
        version: result.version
      }, cloudinary.config().api_secret);
      expect(result.signature).to.eql(expected_signature);
      done();
    });
    fs.createReadStream(IMAGE_FILE).pipe(upload);
  });
  it(""should successfully upload in chunks with pipes"", (done) => {
    this.timeout(TIMEOUT.LONG);
    const upload = cloudinary.v2.uploader.upload_chunked_stream({
      chunk_size: 7000000,
      timeout: TIMEOUT.LONG
    }, (error, result) => {
      assert.strictEqual(error, undefined);
      assert.ok(result.public_id);
      done();
    });
    fs.createReadStream(LARGE_IMAGE_FILE).pipe(upload);
  });
  it(""should fail with http.Agent (non secure)"", function () {
    this.timeout(TIMEOUT.LONG);
    expect(cloudinary.v2.uploader.upload_stream).withArgs({
      agent: new http.Agent()
    }, function (error, result) { }).to.throwError();
  });
  it(""should successfully override https agent"", function () {
    var file_reader, upload;
    upload = cloudinary.v2.uploader.upload_stream({
      agent: new https.Agent(),
      tags: UPLOAD_TAGS
    }, function (error, result) {
      var expected_signature;
      expect(result.width).to.eql(241);
      expect(result.height).to.eql(51);
      expected_signature = cloudinary.utils.api_sign_request({
        public_id: result.public_id,
        version: result.version
      }, cloudinary.config().api_secret);
      expect(result.signature).to.eql(expected_signature);
    });
    file_reader = fs.createReadStream(IMAGE_FILE);
    file_reader.pipe(upload);
  });
  context("":responsive_breakpoints"", function () {
    context("":create_derived with different transformation settings"", function () {
      before(function () {
        helper.setupCache();
      });
      it('should return a responsive_breakpoints in the response', function () {
        return cloudinary.v2.uploader.upload(IMAGE_FILE, {
          responsive_breakpoints: [
            {
              transformation: {
                effect: ""sepia""
              },
              format: ""jpg"",
              bytes_step: 20000,
              create_derived: true,
              min_width: 200,
              max_width: 1000,
              max_images: 20
            },
            {
              transformation: {
                angle: 10
              },
              format: ""gif"",
              create_derived: true,
              bytes_step: 20000,
              min_width: 200,
              max_width: 1000,
              max_images: 20
            }
          ],
          tags: UPLOAD_TAGS
        }).then(function (result) {
          expect(result).to.have.key('responsive_breakpoints');
          expect(result.responsive_breakpoints).to.have.length(2);
          expect(at(result, ""responsive_breakpoints[0].transformation"")[0]).to.eql(""e_sepia"");
          expect(at(result, ""responsive_breakpoints[0].breakpoints[0].url"")[0]).to.match(/\.jpg$/);
          expect(at(result, ""responsive_breakpoints[1].transformation"")[0]).to.eql(""a_10"");
          expect(at(result, ""responsive_breakpoints[1].breakpoints[0].url"")[0]).to.match(/\.gif$/);
          result.responsive_breakpoints.forEach(function (bp) {
            var cached, format;
            format = path.extname(bp.breakpoints[0].url).slice(1);
            cached = cloudinary.Cache.get(result.public_id, {
              raw_transformation: bp.transformation,
              format
            });
            expect(cached).to.be.ok();
            expect(cached.length).to.be(bp.breakpoints.length);
            bp.breakpoints.forEach(function (o) {
              expect(cached).to.contain(o.width);
            });
          });
        });
      });
    });
  });
  describe(""async upload"", function () {
    var mocked = helper.mockTest();
    it(""should pass `async` value to the server"", function () {
      cloudinary.v2.uploader.upload(IMAGE_FILE, {
        async: true,
        transformation: {
          effect: ""sepia""
        }
      });
      sinon.assert.calledWith(mocked.write, sinon.match(helper.uploadParamMatcher(""async"", 1)));
    });
  });
  it(""should pass `accessibility_analysis` option to the server"", function () {
    return helper.provideMockObjects((mockXHR, writeSpy, requestSpy) => {
      cloudinary.v2.uploader.upload(IMAGE_FILE, { accessibility_analysis: true });
      return sinon.assert.calledWith(writeSpy, sinon.match(helper.uploadParamMatcher(""accessibility_analysis"", 1)));
    });
  });
  describe(""explicit"", function () {
    var spy, xhr;
    spy = void 0;
    xhr = void 0;
    before(function () {
      xhr = sinon.useFakeXMLHttpRequest();
      spy = sinon.spy(ClientRequest.prototype, 'write');
    });
    after(function () {
      spy.restore();
      xhr.restore();
    });
    describe("":invalidate"", function () {
      it(""should pass the invalidate value to the server"", function () {
        cloudinary.v2.uploader.explicit(""cloudinary"", {
          type: ""twitter_name"",
          eager: [
            {
              crop: ""scale"",
              width: ""2.0""
            }
          ],
          invalidate: true,
          quality_analysis: true,
          tags: [TEST_TAG]
        });
        sinon.assert.calledWith(spy, sinon.match(helper.uploadParamMatcher('invalidate', 1)));
        sinon.assert.calledWith(spy, sinon.match(helper.uploadParamMatcher('quality_analysis', 1)));
      });
    });
    it(""should support metadata"", function () {
      cloudinary.v2.uploader.explicit(""cloudinary"", { metadata: METADATA_SAMPLE_DATA });
      sinon.assert.calledWith(spy, sinon.match(helper.uploadParamMatcher(""metadata"", METADATA_SAMPLE_DATA_ENCODED)));
    });
    it(""should support raw_convert"", function () {
      cloudinary.v2.uploader.explicit(""cloudinary"", {
        raw_convert: ""google_speech"",
        tags: [TEST_TAG]
      });
      sinon.assert.calledWith(spy, sinon.match(helper.uploadParamMatcher('raw_convert', 'google_speech')));
    });
    it(""should pass `accessibility_analysis` to server"", function () {
      cloudinary.v2.uploader.explicit(""cloudinary"", { accessibility_analysis: true });
      sinon.assert.calledWith(spy, sinon.match(helper.uploadParamMatcher('accessibility_analysis', 1)));
    });
  });
  it(""should create an image upload tag with required properties"", function () {
    var fakeDiv, input_element, tag;
    this.timeout(TIMEOUT.LONG);
    tag = cloudinary.v2.uploader.image_upload_tag(""image_id"", {
      chunk_size: ""1234""
    });
    expect(tag).to.match(/^<input/);
    // Create an HTMLElement from the returned string to validate attributes
    fakeDiv = document.createElement('div');
    fakeDiv.innerHTML = tag;
    input_element = fakeDiv.firstChild;
    expect(input_element.tagName.toLowerCase()).to.be('input');
    expect(input_element.getAttribute(""data-url"")).to.be.ok();
    expect(input_element.getAttribute(""data-form-data"")).to.be.ok();
    expect(input_element.getAttribute(""data-cloudinary-field"")).to.match(/image_id/);
    expect(input_element.getAttribute(""data-max-chunk-size"")).to.match(/1234/);
    expect(input_element.getAttribute(""class"")).to.match(/cloudinary-fileupload/);
    expect(input_element.getAttribute(""name"")).to.be('file');
    expect(input_element.getAttribute(""type"")).to.be('file');
  });
  describe("":quality_override"", function () {
    const mocked = helper.mockTest();
    const qualityValues = [""auto:advanced"", ""auto:best"", ""80:420"", ""none""];
    function testValue(quality) {
      return it(""should pass '"" + quality + ""'"", function () {
        cloudinary.v2.uploader.upload(IMAGE_FILE, {
          ""quality_override"": quality
        });
        sinon.assert.calledWithMatch(mocked.write, helper.uploadParamMatcher(""quality_override"", quality));
      });
    }
    qualityValues.forEach(value => testValue(value));
    it(""should be supported by explicit api"", function () {
      cloudinary.v2.uploader.explicit(""cloudinary"", {
        ""quality_override"": ""auto:best""
      });
      sinon.assert.calledWithMatch(mocked.write, helper.uploadParamMatcher(""quality_override"", ""auto:best""));
    });
  });
  describe(""update_metadata"", function () {
    it(""should update metadata of existing resources"", function () {
      const metadata_fields = { metadata_color: ""red"", metadata_shape: """" };
      const public_ids = [""test_id_1"", ""test_id_2""];
      return helper.provideMockObjects(function (mockXHR, writeSpy, requestSpy) {
        cloudinary.v2.uploader.update_metadata(metadata_fields, public_ids);
        sinon.assert.calledWith(requestSpy, sinon.match({
          method: sinon.match(""POST"")
        }));
        sinon.assert.calledWith(writeSpy, sinon.match(helper.uploadParamMatcher(""metadata"", ""metadata_color=red|metadata_shape="")));
        sinon.assert.calledWith(writeSpy, sinon.match(helper.uploadParamMatcher(""public_ids[]"", public_ids[0])));
        sinon.assert.calledWith(writeSpy, sinon.match(helper.uploadParamMatcher(""public_ids[]"", public_ids[1])));
      });
    });
    it(""should support updating metadata with clear_invalid"", function () {
      const metadata_fields = { metadata_color: ""red"" };
      const public_ids = [""test_id_1""];
      return helper.provideMockObjects(function (mockXHR, writeSpy, requestSpy) {
        cloudinary.v2.uploader.update_metadata(metadata_fields, public_ids, { clear_invalid: true });
        sinon.assert.calledWith(requestSpy, sinon.match({
          method: sinon.match(""POST"")
        }));
        sinon.assert.calledWith(writeSpy, sinon.match(helper.uploadParamMatcher(""clear_invalid"", true)));
      });
    })
  });
  describe(""access_control"", function () {
    var acl, acl_string, options, requestSpy, writeSpy;
    writeSpy = void 0;
    requestSpy = void 0;
    options = void 0;
    beforeEach(function () {
      writeSpy = sinon.spy(ClientRequest.prototype, 'write');
      requestSpy = sinon.spy(http, 'request');
      options = {
        public_id: TEST_TAG,
        tags: [...UPLOAD_TAGS, 'access_control_test']
      };
    });
    afterEach(function () {
      requestSpy.restore();
      writeSpy.restore();
    });
    acl = {
      access_type: 'anonymous',
      start: new Date(Date.UTC(2019, 1, 22, 16, 20, 57)),
      end: '2019-03-22 00:00 +0200'
    };
    acl_string = '{""access_type"":""anonymous"",""start"":""2019-02-22T16:20:57.000Z"",""end"":""2019-03-22 00:00 +0200""}';
    it(""should allow the user to define ACL in the upload parameters"", function () {
      options.access_control = [acl];
      return uploadImage(options).then((resource) => {
        var response_acl;
        sinon.assert.calledWith(writeSpy, sinon.match(helper.uploadParamMatcher('access_control', `[${acl_string}]`)));
        expect(resource).to.have.key('access_control');
        response_acl = resource.access_control;
        expect(response_acl.length).to.be(1);
        expect(response_acl[0].access_type).to.be(""anonymous"");
        expect(Date.parse(response_acl[0].start)).to.be(Date.parse(acl.start));
        expect(Date.parse(response_acl[0].end)).to.be(Date.parse(acl.end));
      });
    });
  });
  describe("":ocr"", function () {
    const ocrType = ""adv_ocr"";

    it(""should support requesting ocr when uploading"", async function () {
      if (!shouldTestAddOn(ADDON_OCR)) {
        this.skip();
      }
      // Upload an image and request ocr details in the response
      const result = await UPLOADER_V2.upload(IMAGE_FILE, { ocr: ocrType, tags: [TEST_TAG] });

      // Ensure result includes properly structured ocr details
      expect(result).not.to.be.empty();
      expect(result.info).to.be.an(""object"");
      expect(result.info.ocr).to.be.an(""object"");
      expect(result.info.ocr).to.have.key(ocrType);
      expect(result.info.ocr[ocrType]).to.have.key(""status"");
      expect(result.info.ocr[ocrType]).to.have.key(""data"");
    });

    it(""should support ocr parameter in explicit"", async function () {
      if (!shouldTestAddOn(ADDON_OCR)) {
        this.skip();
      }
      // Upload an image
      const uploadResult = await UPLOADER_V2.upload(IMAGE_FILE, {
        tags: [TEST_TAG]
      });

      // Call explicit on the uploaded image with ocr parameter
      const explicitResult = await UPLOADER_V2.explicit(uploadResult.public_id, {
        ocr: ocrType,
        ""tags"": [TEST_TAG],
        type: ""upload""
      });

      // Ensure result isn't an error
      expect(explicitResult).not.to.be.empty();
      expect(explicitResult.public_id).to.eql(uploadResult.public_id);
    });
  });

  describe(""structured metadata fields"", function () {
    const metadata_fields = { [METADATA_FIELD_UNIQUE_EXTERNAL_ID]: METADATA_FIELD_VALUE };
    before(function () {
      return cloudinary.v2.api.add_metadata_field({
        external_id: METADATA_FIELD_UNIQUE_EXTERNAL_ID,
        label: METADATA_FIELD_UNIQUE_EXTERNAL_ID,
        type: ""string""
      }).finally(function () { });
    });
    after(function () {
      return cloudinary.v2.api.delete_metadata_field(METADATA_FIELD_UNIQUE_EXTERNAL_ID)
        .finally(function () { });
    });
    it(""should be set when calling upload with metadata"", function () {
      return uploadImage({
        tags: UPLOAD_TAGS,
        metadata: metadata_fields
      }).then((result) => {
        expect(result.metadata[METADATA_FIELD_UNIQUE_EXTERNAL_ID]).to.eql(METADATA_FIELD_VALUE);
      });
    });
    it(""should be set when calling explicit with metadata"", function () {
      return uploadImage({
        tags: UPLOAD_TAGS
      })
        .then(result => cloudinary.v2.uploader.explicit(result.public_id, {
          type: ""upload"",
          metadata: metadata_fields
        }))
        .then((result) => {
          expect(result.metadata[METADATA_FIELD_UNIQUE_EXTERNAL_ID]).to.eql(METADATA_FIELD_VALUE);
        });
    });
    it('should allow passing both string and a number for a number smd field', () => {
      const smdNumberField = 'smd_number_field';
      cloudinary.v2.api.add_metadata_field({
        external_id: smdNumberField,
        label: smdNumberField,
        type: 'number'
      }).then(() => {
        return Promise.all([
          uploadImage({
            tags: UPLOAD_TAGS,
            metadata: {
              [smdNumberField]: 123
            }
          }),
          uploadImage({
            tags: UPLOAD_TAGS,
            metadata: {
              [smdNumberField]: '123'
            }
          })
        ]);
      }).then(([firstUpload, secondUpload]) => {
        expect(firstUpload.metadata[smdNumberField]).to.eql(123);
        expect(secondUpload.metadata[smdNumberField]).to.eql(123);
      });
    });
    it(""should be updatable with uploader.update_metadata on an existing resource"", function () {
      let publicId;
      return uploadImage({
        tags: UPLOAD_TAGS
      })
        .then((result) => {
          publicId = result.public_id;
          return cloudinary.v2.uploader.update_metadata(metadata_fields, [publicId]);
        })
        .then((result) => {
          expect(result).not.to.be.empty();
          expect(result.public_ids.length).to.eql(1);
          expect(result.public_ids).to.contain(publicId);
        });
    });
    it(""should be updatable with uploader.update_metadata on multiple existing resources"", function () {
      let resource_1;
      let resource_2;

      return Q.allSettled(
        [
          uploadImage({
            tags: UPLOAD_TAGS
          }),
          uploadImage({
            tags: UPLOAD_TAGS
          })
        ]
      ).then(function ([result_1, result_2]) {
        resource_1 = result_1.value;
        resource_2 = result_2.value;
        return cloudinary.v2.uploader.update_metadata(metadata_fields, [resource_1.public_id, resource_2.public_id]);
      })
        .then((result) => {
          expect(result.public_ids.length).to.eql(2);
          expect(result.public_ids).to.contain(resource_1.public_id);
          expect(result.public_ids).to.contain(resource_2.public_id);
        });
    });
  });

  it('should add the eval parameter to an uploaded asset', async () => {
    const result = await UPLOADER_V2.upload(IMAGE_FILE, {
      tags: [TEST_TAG],
      eval: TEST_EVAL_STR
    });

    expect(result).not.to.be.empty();
    expect(result.context).to.be.an(""object"");
    expect(result.context.custom).to.be.an(""object"");
    expect(result.context.custom.width).to.eql(TEST_IMG_WIDTH);
    expect(result.quality_analysis).to.be.an(""object"");
    expect(result.quality_analysis.focus).to.be.an(""number"");
  });

  describe(""sign requests"", function () {
    var configBck2 = void 0;
    var writeSpy;
    writeSpy = void 0;
    beforeEach(function () {
      writeSpy = sinon.spy(ClientRequest.prototype, 'write');
      configBck2 = cloneDeep(cloudinary.config());
      cloudinary.config({
        api_key: ""1234"",
        api_secret: """"
      });
    });
    afterEach(function () {
      cloudinary.config(configBck2);
      writeSpy.restore();
    });
    it(""should allow a signature and timestamp parameter on uploads"", function () {
      cloudinary.v2.uploader.upload(IMAGE_FILE, {
        public_id: 'folder/file',
        version: '1234',
        timestamp: 1569707219,
        signature: 'b77fc0b0dffbf7e74bdad36b615225fb6daff81e'
      });
      sinon.assert.calledWith(writeSpy, sinon.match(helper.uploadParamMatcher('signature', ""b77fc0b0dffbf7e74bdad36b615225fb6daff81e"")));
      sinon.assert.calledWith(writeSpy, sinon.match(helper.uploadParamMatcher('timestamp', '1569707219')));
    });
  });

  describe("":cinemagraph_analysis"", function () {
    it(""should support requesting a cinemagraph_analysis when uploading"", async function () {
      // Upload an image and request a cinemagraph analysis value in the response
      const result = await UPLOADER_V2.upload(IMAGE_FILE, {
        ""cinemagraph_analysis"": true,
        ""tags"": [TEST_TAG]
      });

      // Ensure result includes a cinemagraph_analysis with a cinemagraph_score
      expect(result).not.to.be.empty();
      expect(result.cinemagraph_analysis).to.be.an(""object"");
      expect(result.cinemagraph_analysis).to.have.property(""cinemagraph_score"");
    });

    it(""should support requesting a cinemagraph_analysis when calling explicit"", async function () {
      // Upload an image
      const uploadResult = await UPLOADER_V2.upload(IMAGE_FILE, {
        ""tags"": [TEST_TAG]
      });

      // Call explicit on the uploaded image and request a cinemagraph analysis value in the response
      const explicitResult = await UPLOADER_V2.explicit(uploadResult.public_id, {
        ""cinemagraph_analysis"": true,
        ""tags"": [TEST_TAG],
        type: ""upload""
      });

      // Ensure result includes a cinemagraph_analysis with a cinemagraph_score
      expect(explicitResult).not.to.be.empty();
      expect(explicitResult.cinemagraph_analysis).to.be.an(""object"");
      expect(explicitResult.cinemagraph_analysis).to.have.property(""cinemagraph_score"");
    });
  });
  describe(""sprite"", function () {
    const SPRITE_TEST_TAG = `SPRITE_TEST_TAG${TEST_TAG}`

    let uploaded_url_1, uploaded_url_2;

    before(async function () {
      // Upload images to be used by sprite and multi
      const uploads = await Promise.all([
        uploadImage({ tags: [SPRITE_TEST_TAG, ...UPLOAD_TAGS] }),
        uploadImage({ tags: [SPRITE_TEST_TAG, ...UPLOAD_TAGS] })
      ]);
      uploaded_url_1 = uploads[0].url;
      uploaded_url_2 = uploads[1].url;
    });

    it(""should generate a sprite by tag"", async function () {
      const result = await UPLOADER_V2.generate_sprite(SPRITE_TEST_TAG);
      expect(result).to.beASprite();
      expect(Object.entries(result.image_infos).length).to.eql(2);
    });
    it(""should generate a sprite by tag with raw transformation"", async function () {
      const result = await UPLOADER_V2.generate_sprite(SPRITE_TEST_TAG, {
        transformation: { raw_transformation: 'w_100' }
      });
      expect(result).to.beASprite();
      expect(result.css_url).to.contain('w_100');
    });
    it(""should generate a sprite by tag with transformation params"", async function () {
      const result = await UPLOADER_V2.generate_sprite(SPRITE_TEST_TAG, { width: 100, format: 'jpg' });
      expect(result).to.beASprite('jpg');
      expect(result.css_url).to.contain('f_jpg,w_100');
    });
    it(""should generate a sprite by URLs array"", async function () {
      const result = await UPLOADER_V2.generate_sprite({ 'urls': [uploaded_url_1, uploaded_url_2] });
      expect(result).to.beASprite();
      expect(Object.entries(result.image_infos).length).to.eql(2);
    });
    it(""should generate an url to download a sprite by URLs array"", function () {
      const url = UPLOADER_V2.download_generated_sprite({ 'urls': [SAMPLE_IMAGE_URL_1, SAMPLE_IMAGE_URL_2] });
      expect(url).to.beASignedDownloadUrl(""image/sprite"", { urls: [SAMPLE_IMAGE_URL_1, SAMPLE_IMAGE_URL_2] });
    });
    it(""should generate an url to download a sprite by tag"", async function () {
      const url = UPLOADER_V2.download_generated_sprite(SPRITE_TEST_TAG);
      expect(url).to.beASignedDownloadUrl(""image/sprite"", { tag: SPRITE_TEST_TAG });
    });
  })
  describe(""multi"", function () {
    const MULTI_TEST_TAG = `MULTI_TEST_TAG${TEST_TAG}`

    let uploaded_url_1, uploaded_url_2;

    before(async function () {
      // Upload images to be used by sprite and multi
      const uploads = await Promise.all([
        uploadImage({ tags: [MULTI_TEST_TAG, ...UPLOAD_TAGS] }),
        uploadImage({ tags: [MULTI_TEST_TAG, ...UPLOAD_TAGS] })
      ]);
      uploaded_url_1 = uploads[0].url;
      uploaded_url_2 = uploads[1].url;
    });

    it(""should create a pdf by tag"", async function () {
      const result = await UPLOADER_V2.multi(MULTI_TEST_TAG, { format: ""pdf"" });
      expect(result).to.beAMulti();
      expect(result.url).to.match(new RegExp(`\.pdf$`));
    });
    it(""should create a gif with a transformation by tag"", async function () {
      const options = { width: 0.5, crop: ""crop"" };
      const transformation = cloudinary.utils.generate_transformation_string(Object.assign({}, options));
      const result = await UPLOADER_V2.multi(MULTI_TEST_TAG, { transformation: options });
      expect(result).to.beAMulti();
      expect(result.url).to.match(new RegExp(`/image/multi/${transformation}/.*\.gif$`));
    });
    it(""should generate a gif with a transformation by URLs array"", async function () {
      const options = { width: 0.5, crop: ""crop"" };
      const transformation = cloudinary.utils.generate_transformation_string(Object.assign({}, options));
      const result = await UPLOADER_V2.multi({ urls: [uploaded_url_1, uploaded_url_2], transformation: options });
      expect(result).to.beAMulti();
      expect(result.url).to.match(new RegExp(`/image/multi/${transformation}/.*\.gif$`));
    });
    it(""should generate a download URL for a gif by URLs array"", function () {
      const url = UPLOADER_V2.download_multi({ urls: [SAMPLE_IMAGE_URL_1, SAMPLE_IMAGE_URL_2] });
      expect(url).to.beASignedDownloadUrl(""image/multi"", { urls: [SAMPLE_IMAGE_URL_1, SAMPLE_IMAGE_URL_2] });
    });
    it(""should generate a download URL for a gif by tag"", function () {
      const url = UPLOADER_V2.download_multi(MULTI_TEST_TAG);
      expect(url).to.beASignedDownloadUrl(""image/multi"", { tag: MULTI_TEST_TAG });
    });
  });
  describe(""proxy support"", function () {
    const mocked = helper.mockTest();
    const proxy = ""https://myuser:mypass@example.com""
    it(""should support proxy for upload calls"", function () {
      cloudinary.config({ api_proxy: proxy });
      UPLOADER_V2.upload(IMAGE_FILE, { ""tags"": [TEST_TAG] });
      sinon.assert.calledWith(mocked.request, sinon.match(
        arg => arg.agent instanceof https.Agent
      ));
    });
    it(""should prioritize custom agent"", function () {
      cloudinary.config({ api_proxy: proxy });
      const custom_agent = https.Agent()
      UPLOADER_V2.upload(IMAGE_FILE, { ""tags"": [TEST_TAG], agent: custom_agent });
      sinon.assert.calledWith(mocked.request, sinon.match(
        arg => arg.agent === custom_agent
      ));
    });
    it(""should support api_proxy as options key"", function () {
      cloudinary.config({});
      UPLOADER_V2.upload(IMAGE_FILE, { ""tags"": [TEST_TAG], api_proxy: proxy });
      sinon.assert.calledWith(mocked.request, sinon.match(
        arg => arg.agent instanceof https.Agent
      ));
    });
  })
  describe(""signature_version parameter support"", function () {
    it(""should use signature_version from config when not specified"", function () {
      const original_signature_version = cloudinary.config().signature_version;
      cloudinary.config({ signature_version: 1 });
      let upload_result;
      return uploadImage()
        .then(function (result) {
          upload_result = result;
          const public_id = result.public_id;
          const version = result.version;
          const expected_signature_v1 = cloudinary.utils.api_sign_request(
            { public_id: public_id, version: version },
            cloudinary.config().api_secret,
            null,
            1
          );
          expect(result.signature).to.eql(expected_signature_v1);
        })
        .finally(function () {
          cloudinary.config({ signature_version: original_signature_version });
        });
    });
  });
});",0
"const cloudinary = require(""../../cloudinary"");
const createTestConfig = require('../testUtils/createTestConfig');

const API_SIGN_REQUEST_TEST_SECRET = ""hdcixPpR2iKERPwqvH6sHdK9cyac"";
const API_SIGN_REQUEST_CLOUD_NAME = ""dn6ot3ged"";

describe(""cloudinary"", function () {
  beforeEach(function () {
    cloudinary.config(createTestConfig({
      cloud_name: ""test123"",
      api_key: 'a',
      api_secret: 'b',
      responsive_width_transformation: null,
      signature_algorithm: 'sha1'
    }));
  });
  it(""should use cloud_name from config"", function () {
    var result = cloudinary.utils.url(""test"");
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/test"");
  });
  it(""should allow overriding cloud_name in options"", function () {
    var options, result;
    options = {
      cloud_name: ""test321""
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test321/image/upload/test"");
  });
  it(""should use format from options"", function () {
    var options, result;
    options = {
      format: ""jpg""
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/test.jpg"");
  });
  it(""should use default secure distribution if secure=true"", function () {
    var options, result;
    options = {
      secure: true
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/test"");
  });
  it(""should default to akamai if secure is given with private_cdn and no secure_distribution"", function () {
    var options, result;
    options = {
      secure: true,
      private_cdn: true
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://test123-res.cloudinary.com/image/upload/test"");
  });
  it(""should not add cloud_name if secure private_cdn and secure non akamai secure_distribution"", function () {
    var options, result;
    options = {
      secure: true,
      private_cdn: true,
      secure_distribution: ""something.cloudfront.net""
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://something.cloudfront.net/image/upload/test"");
  });
  it(""should not add cloud_name if private_cdn and not secure"", function () {
    var options, result;
    options = {
      private_cdn: true
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://test123-res.cloudinary.com/image/upload/test"");
  });
  it(""should use width and height from options only if crop is given"", function () {
    var options, result;
    options = {
      width: 100,
      height: 100
    };
    result = cloudinary.utils.url(""test"", options);
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/h_100,w_100/test"");
    expect(options).to.eql({
      width: 100,
      height: 100
    });
    options = {
      width: 100,
      height: 100,
      crop: ""crop""
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({
      width: 100,
      height: 100
    });
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/c_crop,h_100,w_100/test"");
  });
  it(""should not pass width and height to html in case of fit or limit crop"", function () {
    var options, result;
    options = {
      width: 100,
      height: 100,
      crop: ""limit""
    };
    result = cloudinary.utils.url(""test"", options);
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/c_limit,h_100,w_100/test"");
    expect(options).to.eql({});
    options = {
      width: 100,
      height: 100,
      crop: ""fit""
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/c_fit,h_100,w_100/test"");
  });
  it(""should not pass width and height to html in case angle was used"", function () {
    var options, result;
    options = {
      width: 100,
      height: 100,
      crop: ""scale"",
      angle: ""auto""
    };
    result = cloudinary.utils.url(""test"", options);
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/a_auto,c_scale,h_100,w_100/test"");
    expect(options).to.eql({});
  });
  it(""should use x, y, radius, opacity, prefix, gravity and quality from options"", function () {
    var options, result;
    options = {
      x: 1,
      y: 2,
      radius: 3,
      gravity: ""center"",
      quality: 0.4,
      prefix: ""a"",
      opacity: 20
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/g_center,o_20,p_a,q_0.4,r_3,x_1,y_2/test"");
  });
  describe("":gravity"", function () {
    it(""should support 'ocr_text' as a value for gravity parameter"", function () {
      const options = {
        gravity: ""ocr_text"",
        crop: ""crop"",
        width: 0.5
      };
      const result = cloudinary.utils.url(""test"", options);
      expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/c_crop,g_ocr_text,w_0.5/test"");
      expect(options).to.eql({});
    });
    it(""should support 'auto:ocr_text' as a value for gravity parameter"", function () {
      const options = {
        gravity: ""auto:ocr_text"",
        crop: ""crop"",
        width: 0.5
      };
      const result = cloudinary.utils.url(""test"", options);
      expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/c_crop,g_auto:ocr_text,w_0.5/test"");
      expect(options).to.eql({});
    });
  });
  describe("":quality"", function () {
    var upload_path = ""https://res.cloudinary.com/test123/image/upload"";
    it(""support a percent value"", function () {
      expect(cloudinary.utils.url(""test"", {
        x: 1,
        y: 2,
        radius: 3,
        gravity: ""center"",
        quality: 80,
        prefix: ""a""
      })).to.eql(`${upload_path}/g_center,p_a,q_80,r_3,x_1,y_2/test`);
      expect(cloudinary.utils.url(""test"", {
        x: 1,
        y: 2,
        radius: 3,
        gravity: ""center"",
        quality: ""80:444"",
        prefix: ""a""
      })).to.eql(`${upload_path}/g_center,p_a,q_80:444,r_3,x_1,y_2/test`);
    });
    it(""should support auto value"", function () {
      expect(cloudinary.utils.url(""test"", {
        x: 1,
        y: 2,
        radius: 3,
        gravity: ""center"",
        quality: ""auto"",
        prefix: ""a""
      })).to.eql(`${upload_path}/g_center,p_a,q_auto,r_3,x_1,y_2/test`);
      expect(cloudinary.utils.url(""test"", {
        x: 1,
        y: 2,
        radius: 3,
        gravity: ""center"",
        quality: ""auto:good"",
        prefix: ""a""
      })).to.eql(`${upload_path}/g_center,p_a,q_auto:good,r_3,x_1,y_2/test`);
    });
  });
  describe("":radius"", function () {
    const upload_path = 'https://res.cloudinary.com/test123/image/upload';
    it(""should support a single value"", function () {
      expect(cloudinary.utils.url(""test"", {
        radius: 10
      })).to.eql(`${upload_path}/r_10/test`);
      expect(cloudinary.utils.url(""test"", {
        radius: '10'
      })).to.eql(`${upload_path}/r_10/test`);
      expect(cloudinary.utils.url(""test"", {
        variables: [['$v', 10]],
        radius: '$v'
      })).to.eql(`${upload_path}/$v_10,r_$v/test`);
    });
    it(""should support an array of values"", function () {
      expect(cloudinary.utils.url(""test"", {
        radius: [10, 20, 30]
      })).to.eql(`${upload_path}/r_10:20:30/test`);
      expect(cloudinary.utils.url(""test"", {
        variables: [['$v', 10]],
        radius: [10, 20, '$v']
      })).to.eql(`${upload_path}/$v_10,r_10:20:$v/test`);
      expect(cloudinary.utils.url(""test"", {
        variables: [['$v', 10]],
        radius: [10, 20, '$v', 40]
      })).to.eql(`${upload_path}/$v_10,r_10:20:$v:40/test`);
    })
    it(""should support colon separated values"", function () {
      expect(cloudinary.utils.url(""test"", {
        radius: ""10:20""
      })).to.eql(`${upload_path}/r_10:20/test`);
      expect(cloudinary.utils.url(""test"", {
        variables: [['$v', 10]],
        radius: ""10:20:$v:40""
      })).to.eql(`${upload_path}/$v_10,r_10:20:$v:40/test`);
    })
  })
  it(""should support named transformation"", function () {
    var options, result;
    options = {
      transformation: ""blip""
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/t_blip/test"");
  });
  it(""should support array of named transformations"", function () {
    var options, result;
    options = {
      transformation: [""blip"", ""blop""]
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/t_blip.blop/test"");
  });
  it(""should support base transformation"", function () {
    var options, result;
    options = {
      transformation: {
        x: 100,
        y: 100,
        crop: ""fill""
      },
      crop: ""crop"",
      width: 100
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({
      width: 100
    });
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/c_fill,x_100,y_100/c_crop,w_100/test"");
  });
  it(""should support array of base transformations"", function () {
    var options, result;
    options = {
      transformation: [
        {
          x: 100,
          y: 100,
          width: 200,
          crop: ""fill""
        },
        {
          radius: 10
        }
      ],
      crop: ""crop"",
      width: 100
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({
      width: 100
    });
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/c_fill,w_200,x_100,y_100/r_10/c_crop,w_100/test"");
  });
  it(""should not include empty transformations"", function () {
    var options, result;
    options = {
      transformation: [
        {},
        {
          x: 100,
          y: 100,
          crop: ""fill""
        },
        {}
      ]
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/c_fill,x_100,y_100/test"");
  });
  it(""should support size"", function () {
    var options, result;
    options = {
      size: ""10x10"",
      crop: ""crop""
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({
      width: ""10"",
      height: ""10""
    });
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/c_crop,h_10,w_10/test"");
  });
  it(""should use type from options"", function () {
    var options, result;
    options = {
      type: ""facebook""
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/facebook/test"");
  });
  it(""should use resource_type from options"", function () {
    var options, result;
    options = {
      resource_type: ""raw""
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/raw/upload/test"");
  });
  it(""should ignore http links only if type is not given "", function () {
    var options, result;
    options = {
      type: null
    };
    result = cloudinary.utils.url(""https://example.com/"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://example.com/"");
    options = {
      type: ""fetch""
    };
    result = cloudinary.utils.url(""https://example.com/"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/fetch/https://example.com/"");
  });
  it(""should escape fetch urls"", function () {
    var options, result;
    options = {
      type: ""fetch""
    };
    result = cloudinary.utils.url(""https://blah.com/hello?a=b"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/fetch/https://blah.com/hello%3Fa%3Db"");
  });
  it(""should escape http urls"", function () {
    var options, result;
    options = {
      type: ""youtube""
    };
    result = cloudinary.utils.url(""https://www.youtube.com/watch?v=d9NF2edxy-M"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/youtube/https://www.youtube.com/watch%3Fv%3Dd9NF2edxy-M"");
  });
  it(""should support background"", function () {
    var options, result;
    options = {
      background: ""red""
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/b_red/test"");
    options = {
      background: ""#112233""
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/b_rgb:112233/test"");
  });
  it(""should support default_image"", function () {
    var options, result;
    options = {
      default_image: ""default""
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/d_default/test"");
  });
  it(""should support angle"", function () {
    var options, result;
    options = {
      angle: 12
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/a_12/test"");
  });
  it(""should support format for fetch urls"", function () {
    var options, result;
    options = {
      format: ""jpg"",
      type: ""fetch""
    };
    result = cloudinary.utils.url(""https://cloudinary.com/images/logo.png"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/fetch/f_jpg/https://cloudinary.com/images/logo.png"");
  });
  it(""should support effect"", function () {
    var options, result;
    options = {
      effect: ""sepia""
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/e_sepia/test"");
  });
  it(""should support effect with param"", function () {
    var options, result;
    options = {
      effect: [""sepia"", 10]
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/e_sepia:10/test"");
  });
  [
    [""overlay"", ""l""],
    [""underlay"", ""u""]
  ].forEach(([layer, short]) => {
    it(`should support ${layer}`, function () {
      var result;
      let options = {};
      options[layer] = ""text:hello"";
      result = cloudinary.utils.url(""test"", options);
      expect(options).to.eql({});
      expect(result).to.eql(`https://res.cloudinary.com/test123/image/upload/${short}_text:hello/test`);
    });
    it(`should not pass width/height to html for ${layer}`, function () {
      var options, result;
      options = {
        height: 100,
        width: 100
      };
      options[layer] = ""text:hello"";
      result = cloudinary.utils.url(""test"", options);
      expect(options).to.eql({});
      expect(result).to.eql(`https://res.cloudinary.com/test123/image/upload/h_100,${short}_text:hello,w_100/test`);
    });
  });
  it(""should correctly build signed preloaded image"", function () {
    expect(cloudinary.utils.signed_preloaded_image({
      resource_type: ""image"",
      version: 1251251251,
      public_id: ""abcd"",
      format: ""jpg"",
      signature: ""123515adfa151""
    })).to.eql(""image/upload/v1251251251/abcd.jpg#123515adfa151"");
  });
  it('should support custom function of type wasm with a source', function () {
    var options, result;
    options = {
      custom_function: { function_type: 'wasm', source: 'blur.wasm' }
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/fn_wasm:blur.wasm/test"");
  });
  it('should support arbitrary custom function types', function () {
    var options, result;
    options = {
      custom_function: { function_type: 'amazing', source: 'awesome' }
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/fn_amazing:awesome/test"");
  });
  it('should support custom function with no source', function () {
    var options, result;
    options = {
      custom_function: { function_type: 'wasm' }
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/fn_wasm:/test"");
  });
  it('should support custom function with no function_type', function () {
    var options, result;
    options = {
      custom_function: { source: 'blur.wasm' }
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/fn_:blur.wasm/test"");
  });
  it('should support custom function that is not an object', function () {
    var options, result;
    options = {
      custom_function: []
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/fn_:/test"");
  });
  it('should support custom function with no function_type or source', function () {
    var options, result;
    options = {
      custom_function: {}
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/fn_:/test"");
  });
  it('should support custom function of type remote', function () {
    var options, result;
    options = {
      custom_function: {
        function_type: 'remote',
        source:
          'https://df34ra4a.execute-api.us-west-2.amazonaws.com/default/cloudinaryFunction'
      }
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/fn_remote:aHR0cHM6Ly9kZjM0cmE0YS5leGVjdXRlLWFwaS51cy13ZXN0LTIuYW1hem9uYXdzLmNvbS9kZWZhdWx0L2Nsb3VkaW5hcnlGdW5jdGlvbg/test"");
  });
  it('should not include custom function with undefined value', function () {
    var options, result;
    options = {
      custom_function: undefined
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/test"");
  });
  it('should support custom pre function', function () {
    var options, result;
    options = {
      custom_pre_function: {
        function_type: 'remote',
        source:
          'https://df34ra4a.execute-api.us-west-2.amazonaws.com/default/cloudinaryFunction'
      }
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/fn_pre:remote:aHR0cHM6Ly9kZjM0cmE0YS5leGVjdXRlLWFwaS51cy13ZXN0LTIuYW1hem9uYXdzLmNvbS9kZWZhdWx0L2Nsb3VkaW5hcnlGdW5jdGlvbg/test"");
  });
  it('should generate url safe base64 in remote custom pre function', function () {
    var options, result;
    options = {
      custom_pre_function: {
        function_type: 'remote',
        source:
          ""https://opengraphimg.com/.netlify/functions/generate-opengraph?author=opengraphimg&title=Hey%20Chris%20this%20is%20working""
      }
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/fn_pre:remote:aHR0cHM6Ly9vcGVuZ3JhcGhpbWcuY29tLy5uZXRsaWZ5L2Z1bmN0aW9ucy9nZW5lcmF0ZS1vcGVuZ3JhcGg_YXV0aG9yPW9wZW5ncmFwaGltZyZ0aXRsZT1IZXklMjBDaHJpcyUyMHRoaXMlMjBpcyUyMHdvcmtpbmc/test"");
  });
  it('should support custom pre function with no function_type or source', function () {
    var options, result;
    options = {
      custom_pre_function: {}
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/fn_pre::/test"");
  });
  it(""should support density"", function () {
    var options, result;
    options = {
      density: 150
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/dn_150/test"");
  });
  it(""should support page"", function () {
    var options, result;
    options = {
      page: 5
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/pg_5/test"");
  });
  it(""should support external cname"", function () {
    var options, result;
    options = {
      cname: ""hello.com"",
      secure: false
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""http://hello.com/test123/image/upload/test"");
  });
  it(""should support external cname with cdn_subdomain on"", function () {
    var options, result;
    options = {
      cname: ""hello.com"",
      cdn_subdomain: true,
      secure: false
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""http://a2.hello.com/test123/image/upload/test"");
  });
  it(""should support border"", function () {
    var options, result;
    options = {
      border: {
        width: 5
      }
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/bo_5px_solid_black/test"");
    options = {
      border: {
        width: 5,
        color: ""#ffaabbdd""
      }
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/bo_5px_solid_rgb:ffaabbdd/test"");
    options = {
      border: ""1px_solid_blue""
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/bo_1px_solid_blue/test"");
  });
  it(""should support flags"", function () {
    var options, result;
    options = {
      flags: ""abc""
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/fl_abc/test"");
    options = {
      flags: [""abc"", ""def""]
    };
    result = cloudinary.utils.url(""test"", options);
    expect(options).to.eql({});
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/fl_abc.def/test"");
  });
  it(""should add version if public_id contains /"", function () {
    var result = cloudinary.utils.url(""folder/test"");
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/v1/folder/test"");
    result = cloudinary.utils.url(""folder/test"", {
      version: 123
    });
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/v123/folder/test"");
  });
  it(""should not add version if public_id contains version already"", function () {
    var result = cloudinary.utils.url(""v1234/test"");
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/v1234/test"");
  });
  it(""should allow to shorted image/upload urls"", function () {
    var result = cloudinary.utils.url(""test"", {
      shorten: true
    });
    expect(result).to.eql(""https://res.cloudinary.com/test123/iu/test"");
  });
  it(""should escape public_ids"", function () {
    const tests = [
      // [source, target]
      [""a b"", ""a%20b""],
      [""a+b"", ""a%2Bb""],
      [""a%20b"", ""a%20b""],
      [""a-b"", ""a-b""],
      [""a??b"", ""a%3F%3Fb""]
    ];
    tests.forEach(([source, target]) => {
      let result = cloudinary.utils.url(source);
      expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/"" + target);
    });
  });
  it(""should correctly sign a url"", function () {
    var actual, expected;
    expected = ""https://res.cloudinary.com/test123/image/upload/s--Ai4Znfl3--/c_crop,h_20,w_10/v1234/image.jpg"";
    actual = cloudinary.utils.url(""image.jpg"", {
      version: 1234,
      crop: ""crop"",
      width: 10,
      height: 20,
      sign_url: true
    });
    expect(actual).to.eql(expected);
    expected = ""https://res.cloudinary.com/test123/image/upload/s----SjmNDA--/v1234/image.jpg"";
    actual = cloudinary.utils.url(""image.jpg"", {
      version: 1234,
      sign_url: true
    });
    expect(actual).to.eql(expected);
    expected = ""https://res.cloudinary.com/test123/image/upload/s--Ai4Znfl3--/c_crop,h_20,w_10/image.jpg"";
    actual = cloudinary.utils.url(""image.jpg"", {
      crop: ""crop"",
      width: 10,
      height: 20,
      sign_url: true
    });
    expect(actual).to.eql(expected);
  });
  it(""should correctly sign_request"", function () {
    var params = cloudinary.utils.sign_request({
      public_id: ""folder/file"",
      version: ""1234""
    }, {
      api_key: '1234',
      api_secret: 'b'
    });
    expect(params).to.eql({
      public_id: ""folder/file"",
      version: ""1234"",
      signature: ""7a3349cbb373e4812118d625047ede50b90e7b67"",
      api_key: ""1234""
    });
  });
  it(""should correctly process_request_params"", function () {
    var params = cloudinary.utils.process_request_params({
      public_id: ""folder/file"",
      version: ""1234"",
      colors: void 0
    }, {
      api_key: '1234',
      api_secret: 'b',
      unsigned: true
    });
    expect(params).to.eql({
      public_id: ""folder/file"",
      version: ""1234""
    });
    params = cloudinary.utils.process_request_params({
      public_id: ""folder/file"",
      version: ""1234""
    }, {
      api_key: '1234',
      api_secret: 'b'
    });
    expect(params).to.eql({
      public_id: ""folder/file"",
      version: ""1234"",
      signature: ""7a3349cbb373e4812118d625047ede50b90e7b67"",
      api_key: ""1234""
    });
  });

  it(""should support preloaded identifier format"", function () {
    var result = cloudinary.utils.url(""raw/private/v123456/document.docx"");
    expect(result).to.eql(""https://res.cloudinary.com/test123/raw/private/v123456/document.docx"");
    result = cloudinary.utils.url(""image/private/v123456/img.jpg"", {
      crop: ""scale"",
      width: ""1.0""
    });
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/private/c_scale,w_1.0/v123456/img.jpg"");
  });

  it(""should add responsive width transformation"", function () {
    var options, result;
    options = {
      width: 100,
      height: 100,
      crop: ""crop"",
      responsive_width: true
    };
    result = cloudinary.utils.url(""test"", options);
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/c_crop,h_100,w_100/c_limit,w_auto/test"");
    expect(options).to.eql({
      responsive: true
    });
    cloudinary.config({
      responsive_width_transformation: {
        width: ""auto"",
        crop: ""pad""
      }
    });
    options = {
      width: 100,
      height: 100,
      crop: ""crop"",
      responsive_width: true
    };
    result = cloudinary.utils.url(""test"", options);
    expect(result).to.eql(""https://res.cloudinary.com/test123/image/upload/c_crop,h_100,w_100/c_pad,w_auto/test"");
    expect(options).to.eql({
      responsive: true
    });
  });
  it(""should generate urls with a 32 character signature when both sign_url and long_url_signature are true"", function () {
    var options, result;
    options = {
      sign_url: true,
      long_url_signature: true
    };
    result = cloudinary.utils.url(""sample.jpg"", options);
    expect(result).to.eql('https://res.cloudinary.com/test123/image/upload/s--2hbrSMPOjj5BJ4xV7SgFbRDevFaQNUFf--/sample.jpg');
  });
  it(""should generate urls with a 8 character signature when sign_url is true"", function () {
    var options, result;
    options = {
      sign_url: true
    };
    result = cloudinary.utils.url(""sample.jpg"", options);
    expect(result).to.eql('https://res.cloudinary.com/test123/image/upload/s--v2fTPYTu--/sample.jpg');
  });
  it(""should generate urls with signature algorithm SHA256 when sign_url is true"", function () {
    var options, result;
    options = {
      sign_url: true,
      signature_algorithm: 'sha256'
    };
    result = cloudinary.utils.url(""sample.jpg"", options);
    expect(result).to.eql('https://res.cloudinary.com/test123/image/upload/s--2hbrSMPO--/sample.jpg');
  });

  it(""should not affect user variable names containing predefined names"", function () {
    const options = {
      transformation: [
        {
          $mywidth: ""100"",
          $aheight: 300
        },
        {
          width: ""3 + $mywidth * 3 + 4 / 2 * initialWidth * $mywidth"",
          height: ""3 * initialHeight + $aheight"",
          crop: 'scale'
        }
      ]
    };
    const result = cloudinary.utils.url(""sample"", options);
    expect(result).to.contain(""$aheight_300,$mywidth_100/c_scale,h_3_mul_ih_add_$aheight,w_3_add_$mywidth_mul_3_add_4_div_2_mul_iw_mul_$mywidth"");
  });
});

describe(""api_sign_request"", function () {
  it(""should sign an API request using SHA1 by default"", function () {
    const signature = cloudinary.utils.api_sign_request({
      cloud_name: API_SIGN_REQUEST_CLOUD_NAME,
      timestamp: 1568810420,
      username: ""user@cloudinary.com""
    }, API_SIGN_REQUEST_TEST_SECRET);
    expect(signature).to.eql(""14c00ba6d0dfdedbc86b316847d95b9e6cd46d94"");
  });

  it(""should sign an API request using SHA256"", function () {
    cloudinary.config({ signature_algorithm: 'sha256' });
    const signature = cloudinary.utils.api_sign_request({
      cloud_name: API_SIGN_REQUEST_CLOUD_NAME,
      timestamp: 1568810420,
      username: ""user@cloudinary.com""
    }, API_SIGN_REQUEST_TEST_SECRET);
    expect(signature).to.eql(""45ddaa4fa01f0c2826f32f669d2e4514faf275fe6df053f1a150e7beae58a3bd"");
    cloudinary.config(true);
  });

  it(""should sign an API request using SHA256 via parameter"", function () {
    const signature = cloudinary.utils.api_sign_request({
      cloud_name: API_SIGN_REQUEST_CLOUD_NAME,
      timestamp: 1568810420,
      username: ""user@cloudinary.com""
    }, API_SIGN_REQUEST_TEST_SECRET, ""sha256"");
    expect(signature).to.eql(""45ddaa4fa01f0c2826f32f669d2e4514faf275fe6df053f1a150e7beae58a3bd"");
  });

  it(""should raise when unsupported algorithm is passed"", function () {
    const signature_algorithm = ""unsupported_algorithm"";
    expect(() => {
      cloudinary.utils.api_sign_request({
        cloud_name: API_SIGN_REQUEST_CLOUD_NAME,
        timestamp: 1568810420,
        username: ""user@cloudinary.com""
      }, API_SIGN_REQUEST_TEST_SECRET, signature_algorithm);
    }).to.throwException();
  });

  it(""should prevent parameter smuggling via & characters in parameter values with signature version 2"", function () {
    const params_with_ampersand = {
      cloud_name: API_SIGN_REQUEST_CLOUD_NAME,
      timestamp: 1568810420,
      notification_url: ""https://fake.com/callback?a=1&tags=hello,world""
    };
    const signature_v1_with_ampersand = cloudinary.utils.api_sign_request(params_with_ampersand, API_SIGN_REQUEST_TEST_SECRET, null, 1);
    const signature_v2_with_ampersand = cloudinary.utils.api_sign_request(params_with_ampersand, API_SIGN_REQUEST_TEST_SECRET, null, 2);

    const params_smuggled = {
      cloud_name: API_SIGN_REQUEST_CLOUD_NAME,
      timestamp: 1568810420,
      notification_url: ""https://fake.com/callback?a=1"",
      tags: ""hello,world""
    };
    const signature_v1_smuggled = cloudinary.utils.api_sign_request(params_smuggled, API_SIGN_REQUEST_TEST_SECRET, null, 1);
    const signature_v2_smuggled = cloudinary.utils.api_sign_request(params_smuggled, API_SIGN_REQUEST_TEST_SECRET, null, 2);

    expect(signature_v1_with_ampersand).to.eql(signature_v1_smuggled);
    expect(signature_v2_with_ampersand).to.not.eql(signature_v2_smuggled);
    expect(signature_v2_with_ampersand).to.eql(""4fdf465dd89451cc1ed8ec5b3e314e8a51695704"");
    expect(signature_v2_smuggled).to.eql(""7b4e3a539ff1fa6e6700c41b3a2ee77586a025f9"");
  });

  it(""should use signature version 1 (without parameter encoding) for backward compatibility"", function () {
    const public_id_with_ampersand = 'tests/logo&version=2';
    const test_version = 123456;
    const SIGNATURE_VERIFICATION_API_SECRET = ""testsecret"";
    const expected_signature_v1 = cloudinary.utils.api_sign_request(
      { public_id: public_id_with_ampersand, version: test_version },
      SIGNATURE_VERIFICATION_API_SECRET,
      null,
      1
    );
    const expected_signature_v2 = cloudinary.utils.api_sign_request(
      { public_id: public_id_with_ampersand, version: test_version },
      SIGNATURE_VERIFICATION_API_SECRET,
      null,
      2
    );
    expect(expected_signature_v1).to.not.eql(expected_signature_v2);
    expect(cloudinary.utils.verify_api_response_signature(public_id_with_ampersand, test_version, expected_signature_v1)).to.be.true;
    expect(cloudinary.utils.verify_api_response_signature(public_id_with_ampersand, test_version, expected_signature_v2)).to.be.false;
  });
});

describe(""Response signature verification fixes"", function () {
  const public_id = 'tests/logo.png';
  const test_version = 1234;
  const test_api_secret = ""testsecret"";

  describe(""api_sign_request signature_version parameter support"", function () {
    it(""should support signature_version parameter in api_sign_request"", function () {
      const params = { public_id: public_id, version: test_version };
      const signature_v1 = cloudinary.utils.api_sign_request(params, test_api_secret, null, 1);
      const signature_v2 = cloudinary.utils.api_sign_request(params, test_api_secret, null, 2);
      expect(signature_v1).to.be.a('string');
      expect(signature_v2).to.be.a('string');
      expect(signature_v1).to.eql(signature_v2); // No & in values, so should be the same
    });

    it(""should use default signature_version from config"", function () {
      const original_signature_version = cloudinary.config().signature_version;
      cloudinary.config({ signature_version: 2 });
      const params = { public_id: public_id, version: test_version };
      const signature_with_nil = cloudinary.utils.api_sign_request(params, test_api_secret, null, null);
      const signature_with_v2 = cloudinary.utils.api_sign_request(params, test_api_secret, null, 2);
      expect(signature_with_nil).to.eql(signature_with_v2);
      cloudinary.config({ signature_version: original_signature_version });
    });

    it(""should default to version 2 when no config is set"", function () {
      const original_signature_version = cloudinary.config().signature_version;
      cloudinary.config({ signature_version: null });
      const params = { public_id: public_id, version: test_version };
      const signature_with_nil = cloudinary.utils.api_sign_request(params, test_api_secret, null, null);
      const signature_with_v2 = cloudinary.utils.api_sign_request(params, test_api_secret, null, 2);
      expect(signature_with_nil).to.eql(signature_with_v2);
      cloudinary.config({ signature_version: original_signature_version });
    });
  });
});

describe(""verify_api_response_signature"", function () {
  const public_id = 'tests/logo.png';
  const version = 1234;
  const test_api_secret = ""testsecret"";
  before(function () {
    cloudinary.config({ api_secret: test_api_secret });
  });
  it(""should return true for a valid signature (number version)"", function () {
    const signature = cloudinary.utils.api_sign_request({ public_id, version }, test_api_secret, null, 1);
    expect(cloudinary.utils.verify_api_response_signature(public_id, version, signature)).to.be(true);
  });
  it(""should return true for a valid signature (string version)"", function () {
    const version_str = version.toString();
    const signature = cloudinary.utils.api_sign_request({ public_id, version: version_str }, test_api_secret, null, 1);
    expect(cloudinary.utils.verify_api_response_signature(public_id, version_str, signature)).to.be(true);
  });
  it(""should return false for an invalid signature"", function () {
    expect(cloudinary.utils.verify_api_response_signature(public_id, version, ""invalidsignature"")).to.be(false);
  });
});",0
"              },
            },
          },
        ]);
      });
    });

    it('should download files when intermediate file cannot be downloaded', async () => {
      const imageUrlA = `http://example.com/my-image-A.png`; // supported
      const fileUrl = `http://127.0.0.1:3000/file`; // unsupported
      const imageUrlB = `http://example.com/my-image-B.png`; // supported

      const mockDownload = vi.fn().mockResolvedValue([
        {
          url: new URL(imageUrlA),
          data: new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10, 0]), // empty png and 0
          mediaType: 'image/png',
        },
        null,
        {
          url: new URL(imageUrlB),
          data: new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10, 1]), // empty png and 1
          mediaType: 'image/png',
        },
      ]);

      const result = await convertToLanguageModelPrompt({
        prompt: {
          messages: [
            {
              role: 'user',
              content: [
                { type: 'image', image: imageUrlA, mediaType: 'image/png' },
                {
                  type: 'file',
                  data: new URL(fileUrl),
                  mediaType: 'application/octet-stream',
                },
                { type: 'image', image: imageUrlB, mediaType: 'image/png' },
              ],
            },
          ],
        },
        supportedUrls: {
          '*': [/^https:\/\/.*$/],
        },
        download: mockDownload,
      });

      expect(result).toMatchInlineSnapshot(`
        [
          {
            ""content"": [
              {
                ""data"": Uint8Array [
                  137,
                  80,
                  78,
                  71,
                  13,
                  10,
                  26,
                  10,
                  0,
                ],
                ""filename"": undefined,
                ""mediaType"": ""image/png"",
                ""providerOptions"": undefined,
                ""type"": ""file"",
              },
              {
                ""data"": ""http://127.0.0.1:3000/file"",
                ""filename"": undefined,
                ""mediaType"": ""application/octet-stream"",
                ""providerOptions"": undefined,
                ""type"": ""file"",
              },
              {
                ""data"": Uint8Array [
                  137,
                  80,
                  78,
                  71,
                  13,
                  10,
                  26,
                  10,
                  1,
                ],
                ""filename"": undefined,
                ""mediaType"": ""image/png"",
                ""providerOptions"": undefined,
                ""type"": ""file"",
              },
            ],
            ""providerOptions"": undefined,
            ""role"": ""user"",
          },
        ]
      `);
    });
  });

  describe('custom download function', () => {
    it('should use custom download function to fetch URL content', async () => {
      const mockDownload = vi.fn().mockResolvedValue([
        {",0
"
  // download in parallel:
  const downloadedFiles = await download(plannedDownloads);

  return Object.fromEntries(
    downloadedFiles
      .map((file, index) =>
        file == null
          ? null
          : [
              plannedDownloads[index].url.toString(),
              { data: file.data, mediaType: file.mediaType },
            ],
      )
      .filter(file => file != null),
  );
}

/**
 * Convert part of a message to a LanguageModelV2Part.
 * @param part The part to convert.",0
"      res.end('Missing request body');
      return;
    }

    const {url} = req.body as {url: string};

    try {
      const parsedUrl = new URL(url);
      if (parsedUrl.protocol !== 'http:' && parsedUrl.protocol !== 'https:') {
        res.writeHead(400);
        res.end('Invalid URL protocol');
        return;
      }
    } catch (error) {
      res.writeHead(400);
      res.end('Invalid URL format');
      return;
    }

    await open(url);

    res.writeHead(200);
    res.end();
  }
",0
"  try {
    fd = fs.openSync(file, 'r')
    const stat: fs.Stats = fs.fstatSync(fd)
    const readSize: number = opt.maxReadSize || 16 * 1024 * 1024
    if (stat.size < readSize) {
      const buf = Buffer.allocUnsafe(stat.size)
      const read = fs.readSync(fd, buf, 0, stat.size, 0)
      p.end(read === buf.byteLength ? buf : buf.subarray(0, read))
    } else {
      let pos = 0
      const buf = Buffer.allocUnsafe(readSize)
      while (pos < stat.size) {
        const bytesRead = fs.readSync(fd, buf, 0, readSize, pos)
        if (bytesRead === 0) break
        pos += bytesRead
        p.write(buf.subarray(0, bytesRead))
      }
      p.end()
    }
  } finally {",0
"import fs, { readFileSync, Stats } from 'fs'
//@ts-ignore
import mutateFS from 'mutate-fs'
import { dirname, resolve } from 'path'
import t, { Test } from 'tap'
import { fileURLToPath } from 'url'
import { list } from '../dist/esm/list.js'
import { Parser } from '../dist/esm/parse.js'
import { ReadEntry } from '../dist/esm/read-entry.js'
import { makeTar } from './fixtures/make-tar.js'

const __filename = fileURLToPath(import.meta.url)
const __dirname = dirname(__filename)

const lp = JSON.parse(
  readFileSync(__dirname + '/fixtures/parse/long-paths.json', 'utf8'),
) as (
  | ['meta', string]
  | ['entry', Record<string, any>]
  | ['nullBlock' | 'eof' | 'end']
)[]

t.test('basic', t => {
  const file = resolve(__dirname, 'fixtures/tars/long-paths.tar')
  const expect = (lp as any[])
    .filter(e => Array.isArray(e) && e[0] === 'entry')
    .map((e: ['entry', Record<string, any>]) => e[1].path as string)

  const check = (actual: string[], t: Test) => {
    t.same(actual, expect)
    return Promise.resolve(null)
  }

  ;[1000, undefined].forEach(maxReadSize => {
    t.test('file maxReadSize=' + maxReadSize, t => {
      t.test('sync', t => {
        const actual: string[] = []
        const onReadEntry = (entry: ReadEntry) =>
          actual.push(entry.path)
        list({
          file: file,
          sync: true,
          onReadEntry,
          maxReadSize,
        })
        return check(actual, t)
      })

      t.test('async promise', async t => {
        const actual: string[] = []
        const onReadEntry = (entry: ReadEntry) =>
          actual.push(entry.path)
        return await list({
          file,
          onReadEntry,
          maxReadSize,
        }).then(() => check(actual, t))
      })

      t.test('async cb', t => {
        const actual: string[] = []
        const onReadEntry = (entry: ReadEntry) =>
          actual.push(entry.path)
        list(
          {
            file: file,
            onReadEntry: onReadEntry,
            maxReadSize: maxReadSize,
          },
          (er?: Error) => {
            if (er) {
              throw er
            }
            check(actual, t)
            t.end()
          },
        )
      })
      t.end()
    })
  })

  t.test('stream', t => {
    t.test('sync', t => {
      const actual: string[] = []
      const onReadEntry = (entry: ReadEntry) =>
        actual.push(entry.path)
      const l = list({ sync: true, onReadEntry })
      l.end(fs.readFileSync(file))
      return check(actual, t)
    })

    t.test('async', t => {
      const actual: string[] = []
      const onReadEntry = (entry: ReadEntry) =>
        actual.push(entry.path)
      const l = list()
      l.on('entry', onReadEntry)
      l.on('end', _ => check(actual, t).then(_ => t.end()))
      fs.createReadStream(file).pipe(l)
    })
    t.end()
  })

  t.test('no onReadEntry function', () => list({ file: file }))

  t.test('limit to specific files', t => {
    const fileList = [
      'long-path/r/e/a/l/l/y/-/d/e/e/p/-/f/o/l/d/e/r/-/p/a/t',
      '170-byte-filename-cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc///',
    ]

    const expect = [
      '170-byte-filename-cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc',
      'long-path/r/e/a/l/l/y/-/d/e/e/p/-/f/o/l/d/e/r/-/p/a/t/',
      'long-path/r/e/a/l/l/y/-/d/e/e/p/-/f/o/l/d/e/r/-/p/a/t/h/',
      'long-path/r/e/a/l/l/y/-/d/e/e/p/-/f/o/l/d/e/r/-/p/a/t/h/a.txt',
      'long-path/r/e/a/l/l/y/-/d/e/e/p/-/f/o/l/d/e/r/-/p/a/t/h/cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc',
      'long-path/r/e/a/l/l/y/-/d/e/e/p/-/f/o/l/d/e/r/-/p/a/t/h/cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc',
      'long-path/r/e/a/l/l/y/-/d/e/e/p/-/f/o/l/d/e/r/-/p/a/t/h/xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxcccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc',
      'long-path/r/e/a/l/l/y/-/d/e/e/p/-/f/o/l/d/e/r/-/p/a/t/h/Ω.txt',
    ]

    t.test('no filter function', async t => {
      const check = () => t.same(actual, expect)
      const actual: string[] = []
      return list(
        {
          file: file,
          onReadEntry: entry => actual.push(entry.path),
        },
        fileList,
      ).then(check)
    })

    t.test('no filter function, stream', t => {
      const check = () => t.same(actual, expect)
      const actual: string[] = []
      const onReadEntry = (entry: ReadEntry) =>
        actual.push(entry.path)
      fs.createReadStream(file).pipe(
        list(fileList)
          .on('entry', onReadEntry)
          .on('end', _ => {
            check()
            t.end()
          }),
      )
    })

    t.test('filter function', async t => {
      const check = () => t.same(actual, expect.slice(0, 1))
      const actual: string[] = []
      return list(
        {
          file: file,
          filter: path => path === expect[0],
          onReadEntry: entry => actual.push(entry.path),
        },
        fileList,
      ).then(check)
    })

    return t.test('list is unmunged', t => {
      t.same(fileList, [
        'long-path/r/e/a/l/l/y/-/d/e/e/p/-/f/o/l/d/e/r/-/p/a/t',
        '170-byte-filename-cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc///',
      ])
      t.end()
    })
  })

  t.end()
})

t.test('bad args', t => {
  t.throws(
    () => list({ file: __filename, sync: true }, () => {}),
    new TypeError('callback not supported for sync tar functions'),
  )
  t.throws(
    () => list({}, () => {}),
    new TypeError('callback only supported with file option'),
  )
  t.end()
})

t.test('stat fails', t => {
  const poop = new Error('poop')
  t.teardown(mutateFS.statFail(poop))
  t.test('sync', t => {
    t.plan(1)
    t.throws(() => list({ file: __filename, sync: true }), poop)
  })
  t.test('cb', t => {
    t.plan(1)
    list({ file: __filename }, er => t.equal(er, poop))
  })
  t.test('promise', t => {
    t.plan(1)
    list({ file: __filename }).catch(er => t.equal(er, poop))
  })
  t.end()
})

t.test('read fail', t => {
  t.test('sync', t => {
    const poop = new Error('poop')
    t.teardown(mutateFS.fail('read', poop))
    t.plan(1)
    t.throws(
      () =>
        list({
          file: __filename,
          sync: true,
          maxReadSize: 10,
        }),
      poop,
    )
  })
  t.test('cb', t => {
    const poop = new Error('poop')
    t.teardown(mutateFS.fail('read', poop))
    t.plan(1)
    list({ file: __filename }, er => t.equal(er, poop))
  })
  t.test('promise', t => {
    const poop = new Error('poop')
    t.teardown(mutateFS.fail('read', poop))
    t.plan(1)
    list({ file: __filename }).catch(er => t.equal(er, poop))
  })
  t.end()
})

t.test('noResume option', t => {
  const file = resolve(__dirname, 'fixtures/tars/file.tar')
  t.test('sync', t => {
    let e!: ReadEntry
    list({
      file: file,
      onReadEntry: entry => {
        e = entry
        process.nextTick(() => {
          t.notOk(entry.flowing)
          entry.resume()
        })
      },
      sync: true,
      noResume: true,
    })
    t.ok(e)
    t.notOk(e.flowing)
    e.on('end', () => t.end())
  })

  t.test('async', t =>
    list({
      file: file,
      onReadEntry: entry => {
        process.nextTick(() => {
          t.notOk(entry.flowing)
          entry.resume()
        })
      },
      noResume: true,
    }),
  )

  t.end()
})

t.test('typechecks', t => {
  const p = list()
  //@ts-expect-error
  p.then
  t.type(p, Parser)
  t.end()
})

// GHSA-29xp-372q-xqph
t.test('reduce file size while synchronously reading', async t => {
  const data = makeTar([
    {
      type: 'File',
      path: 'a',
      size: 1,
    },
    'a',
    {
      type: 'File',
      path: 'b',
      size: 1,
    },
    'b',
    '',
    '',
  ])
  const dataLen = data.byteLength
  const truncLen = 512 * 2
  const truncData = data.subarray(0, truncLen)

  const setup = async (t: Test) => {
    const dir = t.testdir({ 'file.tar': data })
    const file = resolve(dir, 'file.tar')
    const { list } = await t.mockImport<
      typeof import('../src/list.js')
    >('../src/list.js', {
      'node:fs': t.createMock(fs, {
        fstatSync: (fd: number): Stats => {
          const st = fs.fstatSync(fd)
          // truncate the file before we have a chance to read
          fs.writeFileSync(file, truncData)
          return st
        },
      }),
    })

    return { file, list }
  }

  t.test(
    'gutcheck, reading normally reads the whole file',
    async t => {
      const dir = t.testdir({ 'file.tar': data })
      const file = resolve(dir, 'file.tar')
      const entries: string[] = []
      list({
        file,
        sync: true,
        maxReadSize: dataLen + 1,
        onReadEntry: e => entries.push(e.path),
      })
      t.strictSame(entries, ['a', 'b'])

      entries.length = 0
      list({
        file,
        sync: true,
        maxReadSize: dataLen - 1,
        onReadEntry: e => entries.push(e.path),
      })
      t.strictSame(entries, ['a', 'b'])
    },
  )

  t.test('read in one go', async t => {
    const { file, list } = await setup(t)
    const entries: string[] = []
    list({
      file,
      sync: true,
      maxReadSize: dataLen + 1,
      onReadEntry: e => entries.push(e.path),
    })
    t.strictSame(entries, ['a'])
  })

  t.test('read in parts', async t => {
    const { file, list } = await setup(t)
    const entries: string[] = []
    list({
      file,
      sync: true,
      maxReadSize: dataLen / 4,
      onReadEntry: e => entries.push(e.path),
    })
    t.strictSame(entries, ['a'])
  })
})",0
"	/**
	 * Whether to disable HTML sandboxing for webhooks. The sandboxing mechanism uses CSP headers now,
	 * but the name is kept for backwards compatibility.
	 */
	@Env('N8N_INSECURE_DISABLE_WEBHOOK_IFRAME_SANDBOX')
	disableWebhookHtmlSandboxing: boolean = false;

	/**
	 * Whether to disable bare repositories support in the Git node.
	 */
	@Env('N8N_GIT_NODE_DISABLE_BARE_REPOS')
	disableBareRepos: boolean = false;
}",0
"			restrictFileAccessTo: '',
			blockFileAccessToN8nFiles: true,
			daysAbandonedWorkflow: 90,
			contentSecurityPolicy: '{}',
			contentSecurityPolicyReportOnly: false,
			disableWebhookHtmlSandboxing: false,
			disableBareRepos: false,
		},
		executions: {
			timeout: -1,
			maxTimeout: 3600,
			pruneData: true,
			pruneDataMaxAge: 336,",0
"
	beforeEach(() => {
		// Ignore environment variables coming in from the environment when running
		// this test suite.
		process.env = {
			N8N_BLOCK_ENV_ACCESS_IN_NODE: 'false',
			N8N_GIT_NODE_DISABLE_BARE_REPOS: 'false',
		};

		jest.resetAllMocks();
	});

	describe('N8N_PARTIAL_EXECUTION_VERSION_DEFAULT', () => {
		test('supports multiple warnings for the same environment variable', () => {
			// ARRANGE
			process.env.N8N_PARTIAL_EXECUTION_VERSION_DEFAULT = '1';
			const dataCaptor = captor();

			// ACT
			deprecationService.warn();

			// ASSERT
			expect(logger.warn).toHaveBeenCalledTimes(1);
			expect(logger.warn).toHaveBeenCalledWith(dataCaptor);
			expect(dataCaptor.value.split('\n')).toEqual(
				expect.arrayContaining([
					' - N8N_PARTIAL_EXECUTION_VERSION_DEFAULT -> Version 1 of partial executions is deprecated and will be removed as early as v1.85.0',
					' - N8N_PARTIAL_EXECUTION_VERSION_DEFAULT -> This environment variable is internal and should not be set.',
				]),
			);
		});
	});

	const toTest = (envVar: string, value: string | undefined, mustWarn: boolean) => {
		const originalEnv = process.env[envVar];
		try {
			// ARRANGE
			if (value) {
				process.env[envVar] = value;
			} else {
				delete process.env[envVar];
			}

			// ACT
			deprecationService.warn();

			// ASSERT
			if (mustWarn) {
				expect(logger.warn).toHaveBeenCalledTimes(1);
				expect(logger.warn.mock.lastCall?.[0]).toMatch(envVar);
			} else {
				expect(logger.warn.mock.lastCall?.[0] ?? '').not.toMatch(envVar);
			}
		} finally {
			// CLEANUP
			if (originalEnv) {
				process.env[envVar] = originalEnv;
			} else {
				delete process.env[envVar];
			}
		}
	};

	test.each([
		['N8N_BINARY_DATA_TTL', '1', true],
		['N8N_PERSISTED_BINARY_DATA_TTL', '1', true],
		['EXECUTIONS_DATA_PRUNE_TIMEOUT', '1', true],
		['N8N_CONFIG_FILES', '1', true],
		['N8N_SKIP_WEBHOOK_DEREGISTRATION_SHUTDOWN', '1', true],
		['N8N_PARTIAL_EXECUTION_VERSION_DEFAULT', '1', true],
		['N8N_PARTIAL_EXECUTION_VERSION_DEFAULT', '2', true],
		['N8N_PARTIAL_EXECUTION_VERSION_DEFAULT', undefined, false],
	])('should detect when %s is `%s`', (envVar, value, mustWarn) => {
		toTest(envVar, value, mustWarn);
	});

	test.each([
		['default', true],
		['filesystem', false],
		['s3', false],
	])('should handle N8N_BINARY_DATA_MODE as %s', (mode, mustWarn) => {
		toTest('N8N_BINARY_DATA_MODE', mode, mustWarn);
	});

	test.each([
		['sqlite', false],
		['postgresdb', false],
		['mysqldb', true],
		['mariadb', true],
	])('should handle DB_TYPE as %s', (dbType, mustWarn) => {
		toTest('DB_TYPE', dbType, mustWarn);
	});

	describe('N8N_RUNNERS_ENABLED', () => {
		const envVar = 'N8N_RUNNERS_ENABLED';

		test.each([
			['false', true],
			['', true],
			['true', false],
			[undefined /* warnIfMissing */, true],
		])('should handle value: %s', (value, mustWarn) => {
			toTest(envVar, value, mustWarn);
		});

		test('should not warn when Code node is excluded', () => {
			process.env[envVar] = 'false';

			const globalConfig = mockInstance(GlobalConfig, {
				nodes: {
					exclude: ['n8n-nodes-base.code'],
				},
			});

			new DeprecationService(logger, globalConfig, instanceSettings).warn();

			expect(logger.warn).not.toHaveBeenCalled();
		});
	});

	describe('OFFLOAD_MANUAL_EXECUTIONS_TO_WORKERS', () => {
		const envVar = 'OFFLOAD_MANUAL_EXECUTIONS_TO_WORKERS';

		beforeEach(() => {
			process.env = {
				N8N_RUNNERS_ENABLED: 'true',
				N8N_BLOCK_ENV_ACCESS_IN_NODE: 'false',
				N8N_GIT_NODE_DISABLE_BARE_REPOS: 'false',
			};

			jest.spyOn(config, 'getEnv').mockImplementation((key) => {
				if (key === 'executions.mode') return 'queue';
				return undefined;
			});
		});

		describe('when executions.mode is not queue', () => {
			test.each([['main'], ['worker'], ['webhook']])(
				'should not warn for instanceType %s',
				(instanceType: InstanceType) => {
					jest.spyOn(config, 'getEnv').mockImplementation((key) => {
						if (key === 'executions.mode') return 'regular';
						return;
					});
					process.env[envVar] = 'false';
					const service = new DeprecationService(
						logger,
						globalConfig,
						mock<InstanceSettings>({ instanceType }),
					);
					service.warn();
					expect(logger.warn).not.toHaveBeenCalled();
				},
			);
		});

		describe('when executions.mode is queue', () => {
			describe('when instanceType is worker', () => {
				test.each([
					['false', 'false'],
					['empty string', ''],
				])(`should not warn when ${envVar} is %s`, (_description, envValue) => {
					process.env[envVar] = envValue;
					const service = new DeprecationService(
						logger,
						globalConfig,
						mock<InstanceSettings>({ instanceType: 'worker' }),
					);
					service.warn();
					expect(logger.warn).not.toHaveBeenCalled();
				});
			});

			describe('when instanceType is webhook', () => {
				test.each([
					['false', 'false'],
					['empty string', ''],
				])(`should not warn when ${envVar} is %s`, (_description, envValue) => {
					process.env[envVar] = envValue;
					const service = new DeprecationService(
						logger,
						globalConfig,
						mock<InstanceSettings>({ instanceType: 'webhook' }),
					);
					service.warn();
					expect(logger.warn).not.toHaveBeenCalled();
				});
			});

			describe('when instanceType is main', () => {
				test.each([
					['false', 'false'],
					['empty string', ''],
				])(`should warn when ${envVar} is %s`, (_description, envValue) => {
					process.env[envVar] = envValue;
					const service = new DeprecationService(logger, globalConfig, instanceSettings);
					service.warn();
					expect(logger.warn).toHaveBeenCalled();
				});

				test('should not warn when OFFLOAD_MANUAL_EXECUTIONS_TO_WORKERS is true', () => {
					process.env[envVar] = 'true';

					const service = new DeprecationService(logger, globalConfig, instanceSettings);
					service.warn();

					expect(logger.warn).not.toHaveBeenCalled();
				});

				test('should warn when OFFLOAD_MANUAL_EXECUTIONS_TO_WORKERS is undefined', () => {
					delete process.env[envVar];

					const service = new DeprecationService(logger, globalConfig, instanceSettings);
					service.warn();

					expect(logger.warn).toHaveBeenCalledTimes(1);
					const warningMessage = logger.warn.mock.calls[0][0];
					expect(warningMessage).toContain(envVar);
				});
			});
		});
	});

	describe('N8N_BLOCK_ENV_ACCESS_IN_NODE', () => {
		beforeEach(() => {
			process.env = {
				N8N_RUNNERS_ENABLED: 'true',
				N8N_GIT_NODE_DISABLE_BARE_REPOS: 'false',
			};

			jest.resetAllMocks();
		});

		test('should warn when N8N_BLOCK_ENV_ACCESS_IN_NODE is not set', () => {
			delete process.env.N8N_BLOCK_ENV_ACCESS_IN_NODE;
			deprecationService.warn();
			expect(logger.warn).toHaveBeenCalled();
		});

		test.each(['false', 'true'])(
			'should not warn when N8N_BLOCK_ENV_ACCESS_IN_NODE is %s',
			(value) => {
				process.env.N8N_BLOCK_ENV_ACCESS_IN_NODE = value;
				deprecationService.warn();
				expect(logger.warn).not.toHaveBeenCalled();
			},
		);
	});

	describe('N8N_GIT_NODE_DISABLE_BARE_REPOS', () => {
		beforeEach(() => {
			process.env = {
				N8N_RUNNERS_ENABLED: 'true',
				N8N_BLOCK_ENV_ACCESS_IN_NODE: 'false',
			};
			jest.resetAllMocks();
		});

		test('should warn when N8N_GIT_NODE_DISABLE_BARE_REPOS is not set', () => {
			delete process.env.N8N_GIT_NODE_DISABLE_BARE_REPOS;
			deprecationService.warn();
			expect(logger.warn).toHaveBeenCalled();
		});

		test.each(['false', 'true'])(
			'should not warn when N8N_GIT_NODE_DISABLE_BARE_REPOS is %s',
			(value) => {
				process.env.N8N_GIT_NODE_DISABLE_BARE_REPOS = value;
				deprecationService.warn();
				expect(logger.warn).not.toHaveBeenCalled();
			},
		);
	});
});",0
"		{
			envVar: 'N8N_BLOCK_ENV_ACCESS_IN_NODE',
			message:
				'The default value of N8N_BLOCK_ENV_ACCESS_IN_NODE will be changed from false to true in a future version. If you need to access environment variables from the Code Node or from expressions, please set N8N_BLOCK_ENV_ACCESS_IN_NODE=false. Learn more: https://docs.n8n.io/hosting/configuration/environment-variables/security/',
			checkValue: (value: string | undefined) => value === undefined || value === '',
		},
		{
			envVar: 'N8N_GIT_NODE_DISABLE_BARE_REPOS',
			message:
				'Support for bare repositories in the Git Node will be removed in a future version due to security concerns. If you are not using bare repositories in the Git Node, please set N8N_GIT_NODE_DISABLE_BARE_REPOS=true. Learn more: https://docs.n8n.io/hosting/configuration/environment-variables/security/',
			checkValue: (value: string | undefined) => value === undefined || value === '',
		},
	];

	/** Runtime state of deprecation-related env vars. */
	private readonly state: Map<Deprecation, { mustWarn: boolean }> = new Map();

	constructor(",0
"	commitFields,
	logFields,
	pushFields,
	switchBranchFields,
	tagFields,
} from './descriptions';
import { Container } from '@n8n/di';
import { DeploymentConfig, SecurityConfig } from '@n8n/config';

export class Git implements INodeType {
	description: INodeTypeDescription = {
		displayName: 'Git',
		name: 'git',
		icon: 'file:git.svg',
		group: ['transform'],
		version: 1,
		description: 'Control git.',
		defaults: {
			name: 'Git',
		},
		usableAsTool: true,
		inputs: [NodeConnectionTypes.Main],
		outputs: [NodeConnectionTypes.Main],
		credentials: [
			{
				name: 'gitPassword',
				required: true,
				displayOptions: {
					show: {
						authentication: ['gitPassword'],
					},
				},
			},
		],
		properties: [
			{
				displayName: 'Authentication',
				name: 'authentication',
				type: 'options',
				options: [
					{
						name: 'Authenticate',
						value: 'gitPassword',
					},
					{
						name: 'None',
						value: 'none',
					},
				],
				displayOptions: {
					show: {
						operation: ['clone', 'push'],
					},
				},
				default: 'none',
				description: 'The way to authenticate',
			},
			{
				displayName: 'Operation',
				name: 'operation',
				type: 'options',
				noDataExpression: true,
				default: 'log',
				options: [
					{
						name: 'Add',
						value: 'add',
						description: 'Add a file or folder to commit',
						action: 'Add a file or folder to commit',
					},
					{
						name: 'Add Config',
						value: 'addConfig',
						description: 'Add configuration property',
						action: 'Add configuration property',
					},
					{
						name: 'Clone',
						value: 'clone',
						description: 'Clone a repository',
						action: 'Clone a repository',
					},
					{
						name: 'Commit',
						value: 'commit',
						description: 'Commit files or folders to git',
						action: 'Commit files or folders to git',
					},
					{
						name: 'Fetch',
						value: 'fetch',
						description: 'Fetch from remote repository',
						action: 'Fetch from remote repository',
					},
					{
						name: 'List Config',
						value: 'listConfig',
						description: 'Return current configuration',
						action: 'Return current configuration',
					},
					{
						name: 'Log',
						value: 'log',
						description: 'Return git commit history',
						action: 'Return git commit history',
					},
					{
						name: 'Pull',
						value: 'pull',
						description: 'Pull from remote repository',
						action: 'Pull from remote repository',
					},
					{
						name: 'Push',
						value: 'push',
						description: 'Push to remote repository',
						action: 'Push to remote repository',
					},
					{
						name: 'Push Tags',
						value: 'pushTags',
						description: 'Push Tags to remote repository',
						action: 'Push tags to remote repository',
					},
					{
						name: 'Status',
						value: 'status',
						description: 'Return status of current repository',
						action: 'Return status of current repository',
					},
					{
						name: 'Switch Branch',
						value: 'switchBranch',
						description: 'Switch to a different branch',
						action: 'Switch to a different branch',
					},
					{
						name: 'Tag',
						value: 'tag',
						description: 'Create a new tag',
						action: 'Create a new tag',
					},
					{
						name: 'User Setup',
						value: 'userSetup',
						description: 'Set the user',
						action: 'Set up a user',
					},
				],
			},

			{
				displayName: 'Repository Path',
				name: 'repositoryPath',
				type: 'string',
				displayOptions: {
					hide: {
						operation: ['clone'],
					},
				},
				default: '',
				placeholder: '/tmp/repository',
				required: true,
				description: 'Local path of the git repository to operate on',
			},
			{
				displayName: 'New Repository Path',
				name: 'repositoryPath',
				type: 'string',
				displayOptions: {
					show: {
						operation: ['clone'],
					},
				},
				default: '',
				placeholder: '/tmp/repository',
				required: true,
				description: 'Local path to which the git repository should be cloned into',
			},

			...addFields,
			...addConfigFields,
			...cloneFields,
			...commitFields,
			...logFields,
			...pushFields,
			...switchBranchFields,
			...tagFields,
			// ...userSetupFields,
		],
	};

	async execute(this: IExecuteFunctions): Promise<INodeExecutionData[][]> {
		const items = this.getInputData();

		const prepareRepository = async (repositoryPath: string): Promise<string> => {
			const authentication = this.getNodeParameter('authentication', 0) as string;

			if (authentication === 'gitPassword') {
				const gitCredentials = await this.getCredentials('gitPassword');

				const url = new URL(repositoryPath);
				url.username = gitCredentials.username as string;
				url.password = gitCredentials.password as string;

				return url.toString();
			}

			return repositoryPath;
		};

		interface CheckoutBranchOptions {
			branchName: string;
			createBranch?: boolean;
			startPoint?: string;
			force?: boolean;
			setUpstream?: boolean;
			remoteName?: string;
		}

		const checkoutBranch = async (
			git: SimpleGit,
			options: CheckoutBranchOptions,
		): Promise<void> => {
			const {
				branchName,
				createBranch = true,
				startPoint,
				force = false,
				setUpstream = false,
				remoteName = 'origin',
			} = options;
			try {
				if (force) {
					await git.checkout(['-f', branchName]);
				} else {
					await git.checkout(branchName);
				}
			} catch (error) {
				if (createBranch) {
					// Try to create the branch when checkout fails
					if (startPoint) {
						await git.checkoutBranch(branchName, startPoint);
					} else {
						await git.checkoutLocalBranch(branchName);
					}
					// If we reach here, branch creation succeeded
				} else {
					// Don't create branch, throw original error
					throw error;
				}
			}

			if (setUpstream) {
				try {
					await git.addConfig(`branch.${branchName}.remote`, remoteName);
					await git.addConfig(`branch.${branchName}.merge`, `refs/heads/${branchName}`);
				} catch (upstreamError) {
					// Upstream setup failed but that's non-fatal
				}
			}
		};

		const operation = this.getNodeParameter('operation', 0);
		const returnItems: INodeExecutionData[] = [];
		for (let itemIndex = 0; itemIndex < items.length; itemIndex++) {
			try {
				const repositoryPath = this.getNodeParameter('repositoryPath', itemIndex, '') as string;
				const options = this.getNodeParameter('options', itemIndex, {});

				if (operation === 'clone') {
					// Create repository folder if it does not exist
					try {
						await access(repositoryPath);
					} catch (error) {
						await mkdir(repositoryPath);
					}
				}

				const gitConfig: string[] = [];
				const deploymentConfig = Container.get(DeploymentConfig);
				const isCloud = deploymentConfig.type === 'cloud';
				const securityConfig = Container.get(SecurityConfig);
				const disableBareRepos = securityConfig.disableBareRepos;
				if (isCloud || disableBareRepos) {
					gitConfig.push('safe.bareRepository=explicit');
				}

				const gitOptions: Partial<SimpleGitOptions> = {
					baseDir: repositoryPath,
					config: gitConfig,
				};

				const git: SimpleGit = simpleGit(gitOptions)
					// Tell git not to ask for any information via the terminal like for
					// example the username. As nobody will be able to answer it would
					// n8n keep on waiting forever.",0
"                        : true,
                dateStrings: options.dateStrings,
                debug: options.debug,
                trace: options.trace,
                multipleStatements: options.multipleStatements,
                flags: options.flags,
                stringifyObjects: true,
            },
            {
                host: credentials.host,
                user: credentials.username,
                password: credentials.password,
                database: credentials.database,
                port: credentials.port,
                ssl: options.ssl,
                socketPath: credentials.socketPath,
                connectionLimit: options.poolSize,
            },
            options.acquireTimeout === undefined
                ? {}
                : { acquireTimeout: options.acquireTimeout },
            options.extra || {},
        )
    }

    /**
     * Creates a new connection pool for a given database credentials.",0
"  } else if (provider.type === ""email"") {
    let email: string = body?.email
    if (!email) return { redirect: `${url}/error?error=EmailSignin` }
    const normalizer: (identifier: string) => string =
      provider.normalizeIdentifier ??
      ((identifier) => {
        const trimmedEmail = identifier.trim()

        // Validate email format according to RFC 5321/5322
        // Reject emails with quotes in the local part to prevent address parser exploits
        // Reject multiple @ symbols which could indicate an exploit attempt
        const atCount = (trimmedEmail.match(/@/g) ?? []).length
        if (atCount !== 1) {
          throw new Error(""Invalid email address format."")
        }

        // Check for quotes in the email address which could be used for exploits
        if (trimmedEmail.includes('""')) {
          throw new Error(""Invalid email address format."")
        }

        // Get the first two elements only,
        // separated by `@` from user input.
        let [local, domain] = trimmedEmail.toLowerCase().split(""@"")

        // Validate that both local and domain parts exist and are non-empty
        if (!local || !domain) {
          throw new Error(""Invalid email address format."")
        }

        // The part before ""@"" can contain a "",""
        // but we remove it on the domain part
        domain = domain.split("","")[0]

        // Additional validation: domain must have at least one dot
        if (!domain.includes(""."")) {
          throw new Error(""Invalid email address format."")
        }

        return `${local}@${domain}`
      })

    try {
      email = normalizer(body?.email)
    } catch (error) {",0
"  )

  app.get('/api/abc', (c) => {
    return c.json({ success: true })
  })

  app.get('/api/vary-header', () => {
    return new Response(JSON.stringify({ success: true }), {
      headers: {
        Vary: 'X-Custom-Vary-Value',
      },
    })
  })

  app.get('/api2/abc', (c) => {
    return c.json({ success: true })
  })

  app.get('/api3/abc', (c) => {
    return c.json({ success: true })
  })

  app.get('/api3/vary-header', () => {
    return new Response(JSON.stringify({ success: true }), {
      headers: {
        Vary: 'X-Custom-Vary-Value',
      },
    })
  })

  app.get('/api4/abc', (c) => {
    return c.json({ success: true })
  })

  app.get('/api5/abc', () => {
    return new Response(JSON.stringify({ success: true }))
  })

  app.get('/api7/abc', () => {
    return new Response(JSON.stringify({ success: true }))
  })

  it('GET default', async () => {
    const res = await app.request('http://localhost/api/abc')

    expect(res.status).toBe(200)
    expect(res.headers.get('Access-Control-Allow-Origin')).toBe('*')
    expect(res.headers.get('Vary')).toBeNull()
  })

  it('Preflight default', async () => {
    const req = new Request('https://localhost/api/abc', { method: 'OPTIONS' })
    req.headers.append('Access-Control-Request-Headers', 'X-PINGOTHER, Content-Type')
    const res = await app.request(req)

    expect(res.status).toBe(204)
    expect(res.statusText).toBe('No Content')
    expect(res.headers.get('Access-Control-Allow-Methods')?.split(',')[0]).toBe('GET')
    expect(res.headers.get('Access-Control-Allow-Headers')?.split(',')).toEqual([
      'X-PINGOTHER',
      'Content-Type',
    ])
  })

  it('Preflight with options', async () => {
    const req = new Request('https://localhost/api2/abc', {
      method: 'OPTIONS',
      headers: { origin: 'http://example.com' },
    })
    const res = await app.request(req)

    expect(res.headers.get('Access-Control-Allow-Origin')).toBe('http://example.com')
    expect(res.headers.get('Vary')?.split(/\s*,\s*/)).toEqual(expect.arrayContaining(['Origin']))
    expect(res.headers.get('Access-Control-Allow-Headers')?.split(/\s*,\s*/)).toEqual([
      'X-Custom-Header',
      'Upgrade-Insecure-Requests',
    ])
    expect(res.headers.get('Access-Control-Allow-Methods')?.split(/\s*,\s*/)).toEqual([
      'POST',
      'GET',
      'OPTIONS',
    ])
    expect(res.headers.get('Access-Control-Expose-Headers')?.split(/\s*,\s*/)).toEqual([
      'Content-Length',
      'X-Kuma-Revision',
    ])
    expect(res.headers.get('Access-Control-Max-Age')).toBe('600')
    expect(res.headers.get('Access-Control-Allow-Credentials')).toBe('true')
  })

  it('Disallow an unmatched origin', async () => {
    const req = new Request('https://localhost/api2/abc', {
      method: 'OPTIONS',
      headers: { origin: 'http://example.net' },
    })
    const res = await app.request(req)
    expect(res.headers.has('Access-Control-Allow-Origin')).toBeFalsy()
  })

  it('Allow multiple origins', async () => {
    let req = new Request('http://localhost/api3/abc', {
      headers: {
        Origin: 'http://example.org',
      },
    })
    let res = await app.request(req)
    expect(res.headers.get('Access-Control-Allow-Origin')).toBe('http://example.org')

    req = new Request('http://localhost/api3/abc')
    res = await app.request(req)
    expect(
      res.headers.has('Access-Control-Allow-Origin'),
      'An unmatched origin should be disallowed'
    ).toBeFalsy()

    req = new Request('http://localhost/api3/abc', {
      headers: {
        Referer: 'http://example.net/',
      },
    })
    res = await app.request(req)
    expect(
      res.headers.has('Access-Control-Allow-Origin'),
      'An unmatched origin should be disallowed'
    ).toBeFalsy()
  })

  it('Set ""Origin"" to Vary header', async () => {
    const res = await app.request('http://localhost/api3/abc', {
      headers: {
        Origin: 'http://example.com',
      },
    })

    expect(res.status).toBe(200)
    expect(res.headers.get('Access-Control-Allow-Origin')).toBe('http://example.com')
    expect(res.headers.get('Vary')).toBe('Origin')
  })

  it('Keep original Vary header', async () => {
    const res = await app.request('http://localhost/api/vary-header', {
      headers: {
        Origin: 'http://example.com',
      },
    })

    expect(res.status).toBe(200)
    expect(res.headers.get('Access-Control-Allow-Origin')).toBe('*')
    expect(res.headers.get('Vary')).toBe('X-Custom-Vary-Value')
  })

  it('Append ""Origin"" to Vary header, if response has some Vary header', async () => {
    const res = await app.request('http://localhost/api3/vary-header', {
      headers: {
        Origin: 'http://example.com',
      },
    })

    expect(res.status).toBe(200)
    expect(res.headers.get('Access-Control-Allow-Origin')).toBe('http://example.com')
    expect(res.headers.get('Vary')).toBe('X-Custom-Vary-Value, Origin')
  })

  it('Allow origins by function', async () => {
    let req = new Request('http://localhost/api4/abc', {
      headers: {
        Origin: 'http://subdomain.example.com',",0
"
    const allowOrigin = await findAllowOrigin(c.req.header('origin') || '', c)
    if (allowOrigin) {
      set('Access-Control-Allow-Origin', allowOrigin)
    }

    if (opts.credentials) {
      set('Access-Control-Allow-Credentials', 'true')
    }

    if (opts.exposeHeaders?.length) {
      set('Access-Control-Expose-Headers', opts.exposeHeaders.join(','))
    }

    if (c.req.method === 'OPTIONS') {
      if (opts.origin !== '*') {
        set('Vary', 'Origin')
      }

      if (opts.maxAge != null) {
        set('Access-Control-Max-Age', opts.maxAge.toString())
      }

      const allowMethods = await findAllowMethods(c.req.header('origin') || '', c)
      if (allowMethods.length) {
        set('Access-Control-Allow-Methods', allowMethods.join(','))
      }

      let headers = opts.allowHeaders
      if (!headers?.length) {
        const requestHeaders = c.req.header('Access-Control-Request-Headers')
        if (requestHeaders) {
          headers = requestHeaders.split(/\s*,\s*/)
        }
      }
      if (headers?.length) {
        set('Access-Control-Allow-Headers', headers.join(','))
        c.res.headers.append('Vary', 'Access-Control-Request-Headers')
      }

      c.res.headers.delete('Content-Length')
      c.res.headers.delete('Content-Type')

      return new Response(null, {
        headers: c.res.headers,
        status: 204,
        statusText: 'No Content',
      })
    }
    await next()

    // Suppose the server sends a response with an Access-Control-Allow-Origin value with an explicit origin (rather than the ""*"" wildcard).
    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin
    if (opts.origin !== '*') {
      c.header('Vary', 'Origin', { append: true })
    }
  }
}",0
"import { AlgorithmTypes } from './jwa'
import { signing } from './jws'
import * as JWT from './jwt'
import { verifyWithJwks } from './jwt'
import {
  JwtAlgorithmNotImplemented,
  JwtPayloadRequiresAud,
  JwtTokenAudience,
  JwtTokenExpired,
  JwtTokenInvalid,
  JwtTokenIssuedAt,
  JwtTokenIssuer,
  JwtTokenNotBefore,
  JwtTokenSignatureMismatched,
} from './types'
import { utf8Encoder } from './utf8'

describe('isTokenHeader', () => {
  it('should return true for valid TokenHeader', () => {
    const validTokenHeader: JWT.TokenHeader = {
      alg: AlgorithmTypes.HS256,
      typ: 'JWT',
    }

    expect(JWT.isTokenHeader(validTokenHeader)).toBe(true)
  })

  it('should return false for invalid TokenHeader', () => {
    const invalidTokenHeader = {
      alg: 'invalid',
      typ: 'JWT',
    }

    expect(JWT.isTokenHeader(invalidTokenHeader)).toBe(false)
  })

  it('returns true even if the typ field is absent in a TokenHeader', () => {
    const validTokenHeader: JWT.TokenHeader = {
      alg: AlgorithmTypes.HS256,
    }

    expect(JWT.isTokenHeader(validTokenHeader)).toBe(true)
  })

  it('returns false when the typ field is present but empty', () => {
    const invalidTokenHeader = {
      alg: AlgorithmTypes.HS256,
      typ: '',
    }

    expect(JWT.isTokenHeader(invalidTokenHeader)).toBe(false)
  })
})

describe('JWT', () => {
  it('JwtAlgorithmNotImplemented', async () => {
    const payload = { message: 'hello world' }
    const secret = 'a-secret'
    const alg = ''
    let tok = ''
    let err: JwtAlgorithmNotImplemented
    try {
      tok = await JWT.sign(payload, secret, alg as AlgorithmTypes)
    } catch (e) {
      err = e as JwtAlgorithmNotImplemented
    }
    expect(tok).toBe('')
    // @ts-ignore
    expect(err).toEqual(new JwtAlgorithmNotImplemented(alg))
  })

  it('JwtTokenInvalid', async () => {
    const tok = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJtZXNzYWdlIjoiaGVsbG8gd29ybGQifQ'
    const secret = 'a-secret'
    let err: JwtTokenInvalid
    let authorized
    try {
      authorized = await JWT.verify(tok, secret, AlgorithmTypes.HS256)
    } catch (e) {
      err = e as JwtTokenInvalid
    }
    // @ts-ignore
    expect(err).toEqual(new JwtTokenInvalid(tok))
    expect(authorized).toBeUndefined()
  })

  it('JwtTokenNotBefore', async () => {
    const tok =
      'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpYXQiOjE2NjQ2MDYzMzQsImV4cCI6MTY2NDYwOTkzNCwibmJmIjoiMzEwNDYwNjI2NCJ9.hpSDT_cfkxeiLWEpWVT8TDxFP3dFi27q1K7CcMcLXHc'
    const secret = 'a-secret'
    let err: JwtTokenNotBefore
    let authorized
    try {
      authorized = await JWT.verify(tok, secret, AlgorithmTypes.HS256)
    } catch (e) {
      err = e as JwtTokenNotBefore
    }
    // @ts-ignore
    expect(err).toEqual(new JwtTokenNotBefore(tok))
    expect(authorized).toBeUndefined()
  })

  it('JwtTokenExpired', async () => {
    const tok =
      'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpYXQiOjE2MzMwNDYxMDAsImV4cCI6MTYzMzA0NjQwMH0.H-OI1TWAbmK8RonvcpPaQcNvOKS9sxinEOsgKwjoiVo'
    const secret = 'a-secret'
    let err
    let authorized
    try {
      authorized = await JWT.verify(tok, secret, AlgorithmTypes.HS256)
    } catch (e) {
      err = e
    }
    expect(err).toEqual(new JwtTokenExpired(tok))
    expect(authorized).toBeUndefined()
  })

  it('JwtTokenIssuedAt', async () => {
    const now = 1633046400
    vi.useFakeTimers().setSystemTime(new Date().setTime(now * 1000))

    const iat = now + 1000 // after 1s
    const payload = { role: 'api_role', iat }
    const secret = 'a-secret'
    const tok = await JWT.sign(payload, secret, AlgorithmTypes.HS256)

    let err
    let authorized
    try {
      authorized = await JWT.verify(tok, secret, AlgorithmTypes.HS256)
    } catch (e) {
      err = e
    }
    expect(err).toEqual(new JwtTokenIssuedAt(now, iat))
    expect(authorized).toBeUndefined()
  })

  it('JwtTokenIssuer (none)', async () => {
    const tok =
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE2MzMwNDY0MDB9.Ha3tPZzmnLGyFfZYd7GSV0iCn2F9kbZffFVZcTe5kJo'
    const secret = 'a-secret'
    let err
    let authorized
    try {
      authorized = await JWT.verify(tok, secret, {
        alg: AlgorithmTypes.HS256,
        iss: 'some',
      })
    } catch (e) {
      err = e
    }
    expect(err).toEqual(new JwtTokenIssuer('some', null))
    expect(authorized).toBeUndefined()
  })

  it('JwtTokenIssuer (wrong - string)', async () => {
    const tok =
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE2MzMwNDY0MDAsImlzcyI6ImZha2UtaXNzdWVyIn0.miyPU40DBvhxpAUsndssJOMBsP1aqc8JClGnriPHfXk'
    const secret = 'a-secret'
    let err
    let authorized
    try {
      authorized = await JWT.verify(tok, secret, {
        alg: AlgorithmTypes.HS256,
        iss: 'expected-issuer',
      })
    } catch (e) {
      err = e
    }
    expect(err).toEqual(new JwtTokenIssuer('expected-issuer', 'fake-issuer'))
    expect(authorized).toBeUndefined()
  })

  it('JwtTokenIssuer (wrong - RegExp)', async () => {
    const tok =
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE2MzMwNDY0MDAsImlzcyI6ImhleSJ9.Q0NJwoj-meWy42pFFrPNlREe2lOagWioJUjR4eJCx0k'
    const secret = 'a-secret'
    let err
    let authorized
    try {
      authorized = await JWT.verify(tok, secret, {
        alg: AlgorithmTypes.HS256,
        iss: /^(hello|hi)$/,
      })
    } catch (e) {
      err = e
    }
    expect(err).toEqual(new JwtTokenIssuer(/^(hello|hi)$/, 'hey'))
    expect(authorized).toBeUndefined()
  })

  it('JwtTokenIssuer (correct - string)', async () => {
    const tok =
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE2MzMwNDY0MDAsImlzcyI6ImNvcnJlY3QtaXNzdWVyIn0.gF8S6M2QcfTTscgxeyihNk28JAOa8mfL1bXPb3_E3rk'
    const secret = 'a-secret'
    let err
    let authorized
    try {
      authorized = await JWT.verify(tok, secret, {
        alg: AlgorithmTypes.HS256,
        iss: 'correct-issuer',
      })
    } catch (e) {
      err = e
    }
    expect(err).toBeUndefined()
    expect(authorized?.iss).toEqual('correct-issuer')
  })

  it('JwtTokenIssuer (correct - RegExp)', async () => {
    const tok =
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOjE2MzMwNDY0MDAsImlzcyI6ImhlbGxvIn0.5DDuValGGQu4EfS3DY7C4hwwHyTNSTD93K_YEjBzgAc'
    const secret = 'a-secret'
    let err
    let authorized
    try {
      authorized = await JWT.verify(tok, secret, {
        alg: AlgorithmTypes.HS256,
        iss: /^(hello|hi)$/,
      })
    } catch (e) {
      err = e
    }
    expect(err).toBeUndefined()
    expect(authorized?.iss).toEqual('hello')
  })

  it('JwtPayloadRequireAud', async () => {
    const tok =
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJodHRwczovL2lzc3Vlci5leGFtcGxlIiwiaWF0IjoxfQ.3Yd0dDicCKA6zu_G6AvxMX_fRH5wMz9gMCedOsYNAGc'
    const secret = 'a-secret'
    let err
    let authorized
    try {
      authorized = await JWT.verify(tok, secret, {
        alg: AlgorithmTypes.HS256,
        aud: 'correct-audience',
      })
    } catch (e) {
      err = e
    }
    expect(err).toEqual(new JwtPayloadRequiresAud({ iss: 'https://issuer.example', iat: 1 }))
    expect(authorized).toBeUndefined()
  })

  it('JwtTokenAudience(correct string - string)', async () => {
    const tok =
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJodHRwczovL2lzc3Vlci5leGFtcGxlIiwiYXVkIjoiY29ycmVjdC1hdWRpZW5jZSIsImlhdCI6MX0.z8T6szX-k66de4xB9OFbpWAOfx0RTqKSUPBcdpSY5nk'
    const secret = 'a-secret'
    let err
    let authorized
    try {
      authorized = await JWT.verify(tok, secret, {
        alg: AlgorithmTypes.HS256,
        aud: 'correct-audience',
      })
    } catch (e) {
      err = e
    }
    expect(err).toBeUndefined()
    expect(authorized?.aud).toEqual('correct-audience')
  })

  it('JwtTokenAudience(correct string - string[])', async () => {
    const tok =
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJodHRwczovL2lzc3Vlci5leGFtcGxlIiwiYXVkIjoiY29ycmVjdC1hdWRpZW5jZSIsImlhdCI6MX0.z8T6szX-k66de4xB9OFbpWAOfx0RTqKSUPBcdpSY5nk'
    const secret = 'a-secret'
    let err
    let authorized
    try {
      authorized = await JWT.verify(tok, secret, {
        alg: AlgorithmTypes.HS256,
        aud: ['correct-audience', 'other-audience'],
      })
    } catch (e) {
      err = e
    }
    expect(err).toBeUndefined()
    expect(authorized?.aud).toEqual('correct-audience')
  })

  it('JwtTokenAudience(correct string - RegExp)', async () => {
    const tok =
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJodHRwczovL2lzc3Vlci5leGFtcGxlIiwiYXVkIjoiY29ycmVjdC1hdWRpZW5jZSIsImlhdCI6MX0.z8T6szX-k66de4xB9OFbpWAOfx0RTqKSUPBcdpSY5nk'
    const secret = 'a-secret'
    let err
    let authorized
    try {
      authorized = await JWT.verify(tok, secret, {
        alg: AlgorithmTypes.HS256,
        aud: /^correct-audience$/,
      })
    } catch (e) {
      err = e
    }
    expect(err).toBeUndefined()
    expect(authorized?.aud).toEqual('correct-audience')
  })

  it('JwtTokenAudience(correct string[] - string)', async () => {
    const tok =
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJodHRwczovL2lzc3Vlci5leGFtcGxlIiwiYXVkIjpbImNvcnJlY3QtYXVkaWVuY2UiLCJvdGhlci1hdWRpZW5jZSJdLCJpYXQiOjF9.l73pNR5zMMAyuoN3f32hKtRJkoxZNzgTcVBZ2A2EsJY'
    const secret = 'a-secret'
    let err
    let authorized
    try {
      authorized = await JWT.verify(tok, secret, {
        alg: AlgorithmTypes.HS256,
        aud: 'correct-audience',
      })
    } catch (e) {
      err = e
    }
    expect(err).toBeUndefined()
    expect(authorized?.aud).toEqual(['correct-audience', 'other-audience'])
  })

  it('JwtTokenAudience(correct string[] - string[])', async () => {
    const tok =
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJodHRwczovL2lzc3Vlci5leGFtcGxlIiwiYXVkIjpbImNvcnJlY3QtYXVkaWVuY2UiLCJvdGhlci1hdWRpZW5jZSJdLCJpYXQiOjF9.l73pNR5zMMAyuoN3f32hKtRJkoxZNzgTcVBZ2A2EsJY'
    const secret = 'a-secret'
    let err
    let authorized
    try {
      authorized = await JWT.verify(tok, secret, {
        alg: AlgorithmTypes.HS256,
        aud: ['correct-audience', 'test'],
      })
    } catch (e) {
      err = e
    }
    expect(err).toBeUndefined()
    expect(authorized?.aud).toEqual(['correct-audience', 'other-audience'])
  })

  it('JwtTokenAudience(correct string[] - RegExp)', async () => {
    const tok =
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJodHRwczovL2lzc3Vlci5leGFtcGxlIiwiYXVkIjpbImNvcnJlY3QtYXVkaWVuY2UiLCJvdGhlci1hdWRpZW5jZSJdLCJpYXQiOjF9.l73pNR5zMMAyuoN3f32hKtRJkoxZNzgTcVBZ2A2EsJY'
    const secret = 'a-secret'
    let err
    let authorized
    try {
      authorized = await JWT.verify(tok, secret, {
        alg: AlgorithmTypes.HS256,
        aud: /^correct-audience$/,
      })
    } catch (e) {
      err = e
    }
    expect(err).toBeUndefined()
    expect(authorized?.aud).toEqual(['correct-audience', 'other-audience'])
  })

  it('JwtTokenAudience(wrong string - string)', async () => {
    const tok =
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJodHRwczovL2lzc3Vlci5leGFtcGxlIiwiYXVkIjoid3JvbmctYXVkaWVuY2UiLCJpYXQiOjF9.2vTYLiYL5r6qN-iRQ0VSfXh4ioLFtNzo0qc-OoPZmow'
    const secret = 'a-secret'
    let err
    let authorized
    try {
      authorized = await JWT.verify(tok, secret, {
        alg: AlgorithmTypes.HS256,
        aud: 'correct-audience',
      })
    } catch (e) {
      err = e
    }
    expect(err).toEqual(new JwtTokenAudience('correct-audience', 'wrong-audience'))
    expect(authorized).toBeUndefined()
  })

  it('JwtTokenAudience(wrong string - string[])', async () => {
    const tok =
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJodHRwczovL2lzc3Vlci5leGFtcGxlIiwiYXVkIjoid3JvbmctYXVkaWVuY2UiLCJpYXQiOjF9.2vTYLiYL5r6qN-iRQ0VSfXh4ioLFtNzo0qc-OoPZmow'
    const secret = 'a-secret'
    let err
    let authorized
    try {
      authorized = await JWT.verify(tok, secret, {
        alg: AlgorithmTypes.HS256,
        aud: ['correct-audience', 'other-audience'],
      })
    } catch (e) {
      err = e
    }
    expect(err).toEqual(
      new JwtTokenAudience(['correct-audience', 'other-audience'], 'wrong-audience')
    )
    expect(authorized).toBeUndefined()
  })

  it('JwtTokenAudience(wrong string - RegExp)', async () => {
    const tok =
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJodHRwczovL2lzc3Vlci5leGFtcGxlIiwiYXVkIjoid3JvbmctYXVkaWVuY2UiLCJpYXQiOjF9.2vTYLiYL5r6qN-iRQ0VSfXh4ioLFtNzo0qc-OoPZmow'
    const secret = 'a-secret'
    let err
    let authorized
    try {
      authorized = await JWT.verify(tok, secret, {
        alg: AlgorithmTypes.HS256,
        aud: /^correct-audience$/,
      })
    } catch (e) {
      err = e
    }
    expect(err).toEqual(new JwtTokenAudience(/^correct-audience$/, 'wrong-audience'))
    expect(authorized).toBeUndefined()
  })

  it('JwtTokenAudience(wrong string[] - string)', async () => {
    const tok =
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJodHRwczovL2lzc3Vlci5leGFtcGxlIiwiYXVkIjpbIndyb25nLWF1ZGllbmNlIiwib3RoZXItYXVkaWVuY2UiXSwiaWF0IjoxfQ.YTAM1xtKP4AeEeQSFQ81rcJM1leW_uDayQcTE6LxoP0'
    const secret = 'a-secret'
    let err
    let authorized
    try {
      authorized = await JWT.verify(tok, secret, {
        alg: AlgorithmTypes.HS256,
        aud: 'correct-audience',
      })
    } catch (e) {
      err = e
    }
    expect(err).toEqual(
      new JwtTokenAudience('correct-audience', ['wrong-audience', 'other-audience'])
    )
    expect(authorized).toBeUndefined()
  })

  it('JwtTokenAudience(wrong string[] - string[])', async () => {
    const tok =
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJodHRwczovL2lzc3Vlci5leGFtcGxlIiwiYXVkIjpbIndyb25nLWF1ZGllbmNlIiwib3RoZXItYXVkaWVuY2UiXSwiaWF0IjoxfQ.YTAM1xtKP4AeEeQSFQ81rcJM1leW_uDayQcTE6LxoP0'
    const secret = 'a-secret'
    let err
    let authorized
    try {
      authorized = await JWT.verify(tok, secret, {
        alg: AlgorithmTypes.HS256,
        aud: ['correct-audience', 'test'],
      })
    } catch (e) {
      err = e
    }
    expect(err).toEqual(
      new JwtTokenAudience(['correct-audience', 'test'], ['wrong-audience', 'other-audience'])
    )
    expect(authorized).toBeUndefined()
  })

  it('JwtTokenAudience(wrong string[] - RegExp)', async () => {
    const tok =
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJodHRwczovL2lzc3Vlci5leGFtcGxlIiwiYXVkIjpbIndyb25nLWF1ZGllbmNlIiwib3RoZXItYXVkaWVuY2UiXSwiaWF0IjoxfQ.YTAM1xtKP4AeEeQSFQ81rcJM1leW_uDayQcTE6LxoP0'
    const secret = 'a-secret'
    let err
    let authorized
    try {
      authorized = await JWT.verify(tok, secret, {
        alg: AlgorithmTypes.HS256,
        aud: /^correct-audience$/,
      })
    } catch (e) {
      err = e
    }
    expect(err).toEqual(
      new JwtTokenAudience(/^correct-audience$/, ['wrong-audience', 'other-audience'])
    )
    expect(authorized).toBeUndefined()
  })

  it('JwtTokenAudience (no aud option and wrong aud in payload)', async () => {
    const tok =
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJodHRwczovL2lzc3Vlci5leGFtcGxlIiwiYXVkIjoid3JvbmctYXVkaWVuY2UiLCJpYXQiOjF9.2vTYLiYL5r6qN-iRQ0VSfXh4ioLFtNzo0qc-OoPZmow'
    const secret = 'a-secret'
    let err
    let authorized
    try {
      authorized = await JWT.verify(tok, secret, {
        alg: AlgorithmTypes.HS256,
      })
    } catch (e) {
      err = e
    }
    expect(err).toBeUndefined()
    expect(authorized?.aud).toEqual('wrong-audience')
  })

  it('HS256 sign & verify & decode', async () => {
    const payload = { message: 'hello world' }
    const secret = 'a-secret'
    const tok = await JWT.sign(payload, secret, AlgorithmTypes.HS256)
    const expected =
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJtZXNzYWdlIjoiaGVsbG8gd29ybGQifQ.B54pAqIiLbu170tGQ1rY06Twv__0qSHTA0ioQPIOvFE'",0
"import type { SignatureAlgorithm } from './jwa'
import { signing, verifying } from './jws'
import type { HonoJsonWebKey, SignatureKey } from './jws'
import {
  JwtHeaderInvalid,
  JwtHeaderRequiresKid,
  JwtPayloadRequiresAud,
  JwtTokenAudience,
  JwtTokenExpired,
  JwtTokenInvalid,
  JwtTokenIssuedAt,
  JwtTokenIssuer,
  JwtTokenNotBefore,
  JwtTokenSignatureMismatched,
} from './types'
import type { JWTPayload } from './types'
import { utf8Decoder, utf8Encoder } from './utf8'

const encodeJwtPart = (part: unknown): string =>
  encodeBase64Url(utf8Encoder.encode(JSON.stringify(part)).buffer).replace(/=/g, '')
const encodeSignaturePart = (buf: ArrayBufferLike): string => encodeBase64Url(buf).replace(/=/g, '')

const decodeJwtPart = (part: string): TokenHeader | JWTPayload | undefined =>
  JSON.parse(utf8Decoder.decode(decodeBase64Url(part)))

export interface TokenHeader {
  alg: SignatureAlgorithm
  typ?: 'JWT'
  kid?: string
}

export function isTokenHeader(obj: unknown): obj is TokenHeader {
  if (typeof obj === 'object' && obj !== null) {
    const objWithAlg = obj as { [key: string]: unknown }
    return (
      'alg' in objWithAlg &&
      Object.values(AlgorithmTypes).includes(objWithAlg.alg as AlgorithmTypes) &&
      (!('typ' in objWithAlg) || objWithAlg.typ === 'JWT')
    )
  }
  return false
}

export const sign = async (
  payload: JWTPayload,
  privateKey: SignatureKey,
  alg: SignatureAlgorithm = 'HS256'
): Promise<string> => {
  const encodedPayload = encodeJwtPart(payload)
  let encodedHeader
  if (typeof privateKey === 'object' && 'alg' in privateKey) {
    alg = privateKey.alg as SignatureAlgorithm
    encodedHeader = encodeJwtPart({ alg, typ: 'JWT', kid: privateKey.kid })
  } else {
    encodedHeader = encodeJwtPart({ alg, typ: 'JWT' })
  }

  const partialToken = `${encodedHeader}.${encodedPayload}`

  const signaturePart = await signing(privateKey, alg, utf8Encoder.encode(partialToken))
  const signature = encodeSignaturePart(signaturePart)

  return `${partialToken}.${signature}`
}

export type VerifyOptions = {
  /** The expected issuer used for verifying the token */
  iss?: string | RegExp
  /** Verify the `nbf` claim (default: `true`) */
  nbf?: boolean
  /** Verify the `exp` claim (default: `true`) */
  exp?: boolean
  /** Verify the `iat` claim (default: `true`) */
  iat?: boolean
  /** Acceptable audience(s) for the token */
  aud?: string | string[] | RegExp
}

export type VerifyOptionsWithAlg = {
  /** The algorithm used for decoding the token */
  alg?: SignatureAlgorithm
} & VerifyOptions

type StrictVerifyOptions = {
  iss?: string | RegExp
  nbf: boolean
  exp: boolean
  iat: boolean
  aud?: string | string[] | RegExp
}

type StrictVerifyOptionsWithAlg = {
  alg: SignatureAlgorithm
} & StrictVerifyOptions

export const verify = async (
  token: string,
  publicKey: SignatureKey,
  algOrOptions?: SignatureAlgorithm | VerifyOptionsWithAlg
): Promise<JWTPayload> => {
  const optsIn = typeof algOrOptions === 'string' ? { alg: algOrOptions } : algOrOptions || {}
  const opts: StrictVerifyOptionsWithAlg = {
    alg: optsIn.alg ?? 'HS256',
    iss: optsIn.iss,
    nbf: optsIn.nbf ?? true,
    exp: optsIn.exp ?? true,
    iat: optsIn.iat ?? true,
    aud: optsIn.aud,
  }

  const tokenParts = token.split('.')
  if (tokenParts.length !== 3) {
    throw new JwtTokenInvalid(token)
  }

  const { header, payload } = decode(token)
  if (!isTokenHeader(header)) {
    throw new JwtHeaderInvalid(header)
  }
  const now = (Date.now() / 1000) | 0
  if (opts.nbf && payload.nbf && payload.nbf > now) {
    throw new JwtTokenNotBefore(token)
  }
  if (opts.exp && payload.exp && payload.exp <= now) {
    throw new JwtTokenExpired(token)
  }
  if (opts.iat && payload.iat && now < payload.iat) {
    throw new JwtTokenIssuedAt(now, payload.iat)
  }
  if (opts.iss) {
    if (!payload.iss) {
      throw new JwtTokenIssuer(opts.iss, null)
    }
    if (typeof opts.iss === 'string' && payload.iss !== opts.iss) {
      throw new JwtTokenIssuer(opts.iss, payload.iss)
    }
    if (opts.iss instanceof RegExp && !opts.iss.test(payload.iss)) {
      throw new JwtTokenIssuer(opts.iss, payload.iss)
    }
  }

  if (opts.aud) {
    if (!payload.aud) {
      throw new JwtPayloadRequiresAud(payload)
    }
  }

  if (payload.aud) {
    const audiences = Array.isArray(payload.aud) ? payload.aud : [payload.aud]
    const matched = audiences.some((aud): boolean => {
      if (opts.aud instanceof RegExp && opts.aud.test(aud)) {
        return true
      } else if (typeof opts.aud === 'string') {
        if (aud === opts.aud) {
          return true
        }
      } else if (Array.isArray(opts.aud)) {
        if (opts.aud.includes(aud)) {
          return true
        }
      }
      return false
    })
    if (opts.aud && !matched) {
      throw new JwtTokenAudience(opts.aud, payload.aud)
    }
  }

  const headerPayload = token.substring(0, token.lastIndexOf('.'))
  const verified = await verifying(
    publicKey,
    opts.alg,
    decodeBase64Url(tokenParts[2]),
    utf8Encoder.encode(headerPayload)",0
"  constructor(token: string) {
    super(`token(${token}) signature mismatched`)
    this.name = 'JwtTokenSignatureMismatched'
  }
}

export class JwtPayloadRequiresAud extends Error {
  constructor(payload: object) {
    super(`required ""aud"" in jwt payload: ${JSON.stringify(payload)}`)
    this.name = 'JwtPayloadRequiresAud'
  }
}

export class JwtTokenAudience extends Error {
  constructor(expected: string | string[] | RegExp, aud: string | string[]) {
    super(
      `expected audience ""${
        Array.isArray(expected) ? expected.join(', ') : expected
      }"", got ""${aud}""`
    )
    this.name = 'JwtTokenAudience'
  }
}

export enum CryptoKeyUsage {
  Encrypt = 'encrypt',
  Decrypt = 'decrypt',
  Sign = 'sign',
  Verify = 'verify',
  DeriveKey = 'deriveKey',
  DeriveBits = 'deriveBits',
  WrapKey = 'wrapKey',
  UnwrapKey = 'unwrapKey',
}

/**
 * JWT Payload
 */
export type JWTPayload = {
  [key: string]: unknown
  /**
   * The token is checked to ensure it has not expired.
   */
  exp?: number
  /**
   * The token is checked to ensure it is not being used before a specified time.
   */
  nbf?: number
  /**
   * The token is checked to ensure it is not issued in the future.
   */
  iat?: number
  /**
   * The token is checked to ensure it has been issued by a trusted issuer.
   */
  iss?: string

  /**
   * The token is checked to ensure it is intended for a specific audience.
   */
  aud?: string | string[]
}

export type { HonoJsonWebKey } from './jws'",0
"function merge() {
  var i,
    src,
    copy,
    clone,
    name,
    result = Object.create(null), // no prototype pollution on Object
    current = null,
    length = arguments.length;

  for (i = 0; i < length; i++) {
    current = arguments[i];
    if (current == null) {",0
"}

function set(obj, path, value) {
  if (!obj) {
    return;
  }

  // Prevent prototype pollution by setting the prototype to null.
  Object.setPrototypeOf(obj, null);

  var keys = path.split('.');
  var len = keys.length;
  if (len < 1) {
    return;
  }
  if (len === 1) {",0
"    expect(e.payload.environment).to.eql('foo');
    expect(e.payload.fuzz).to.eql('buzz');
    expect(e.payload.other).to.eql('bar');
    expect(e.amihere).to.eql('yes');
    done();
  });
  it('should be secure against prototype pollution', function () {
    const o1 = JSON.parse('{""__proto__"": {""polluted"": ""yes""}}');
    const o2 = JSON.parse('{""__proto__"": {""polluted"": ""yes""}}');
    const result = _.merge(o1, o2);
    expect({}.polluted).to.not.eql('yes');
    expect(result.polluted).to.not.eql('yes');
  });
});

import traverse from '../src/utility/traverse.js';
describe('traverse', function () {
  describe('should call the func for every key,value', function () {
    it('simple object', function (done) {
      var obj = { a: 1, b: 2 };
      var expectedOutput = { a: 2, b: 3 };
      var callCount = 0;
      var result = traverse(obj, function (k, v) {
        callCount++;
        return v + 1;
      });
      expect(result).to.eql(expectedOutput);
      expect(callCount).to.eql(2);

      done();
    });
    it('nested object', function (done) {
      var obj = { a: 1, b: 2, c: { ca: 11 } };
      var expectedOutput = { a: 2, b: 3, c: { ca: 12 } };
      var callCount = 0;
      var result = traverse(obj, function (k, v) {
        callCount++;
        if (k === 'c') {
          return { ca: v.ca + 1 };
        }
        return v + 1;
      });
      expect(result).to.eql(expectedOutput);
      expect(callCount).to.eql(3);

      done();
    });
    it('array', function (done) {
      var obj = [1, 2, 3];
      var expected = [0, 1, 2];
      var callCount = 0;
      var result = traverse(
        obj,
        function (k, v) {
          callCount++;
          return v - 1;
        },
        [],
      );
      expect(result).to.eql(expected);
      expect(callCount).to.eql(3);
      done();
    });
  });
});

describe('uuid4', function () {
  it('should return a version 4 uuid', function (done) {
    var id = _.uuid4();
    var otherId = _.uuid4();
    expect(id).to.not.eql(otherId);
    var parts = id.split('-');
    expect(parts.length).to.eql(5);
    expect(parts[2][0]).to.eql('4');
    expect(parts[0].length).to.eql(8);
    expect(parts[1].length).to.eql(4);
    expect(parts[2].length).to.eql(4);
    expect(parts[3].length).to.eql(4);
    expect(parts[4].length).to.eql(12);
    done();
  });
});

describe('redact', function () {
  it('should return a string of stars', function (done) {
    var s1 = 'thisIsApasswrD';
    var s2 = 'short';
    var o = { a: 123 };
    var a = [12, 34, 56];

    expect(_.redact(s1)).to.not.match(/[^*]/);
    expect(_.redact(s2)).to.not.match(/[^*]/);
    expect(_.redact(s1)).to.eql(_.redact(s2));
    expect(_.redact(o)).to.not.match(/[^*]/);
    expect(_.redact(a)).to.not.match(/[^*]/);

    done();
  });
});

describe('LEVELS', function () {
  it('should include debug', function () {
    expect(_.LEVELS['debug']).to.not.eql(undefined);
  });
  it('should have critical higher than debug', function () {
    expect(_.LEVELS['critical']).to.be.greaterThan(_.LEVELS['debug']);
  });
});

describe('formatUrl', function () {
  it('should handle a missing protocol', function () {
    var u = { hostname: 'a.b.com', path: '/wooza/', port: 42 };
    expect(_.formatUrl(u)).to.eql('https://a.b.com:42/wooza/');
  });
  it('should use a forced protocol', function () {
    var u = { hostname: 'a.b.com', path: '/wooza/', port: 42 };
    expect(_.formatUrl(u, 'file:')).to.eql('file://a.b.com:42/wooza/');
  });
  it('should pick a protocol based on port if others are missing', function () {
    var u = { hostname: 'a.b.com', port: 80, path: '/woo' };
    expect(_.formatUrl(u)).to.eql('http://a.b.com:80/woo');
    u.protocol = 'https:';
    expect(_.formatUrl(u)).to.eql('https://a.b.com:80/woo');
  });
  it('should handle missing parts', function () {
    var u = { hostname: 'a.b.com' };
    expect(_.formatUrl(u)).to.eql('https://a.b.com');
    expect(_.formatUrl(u, 'http:')).to.eql('http://a.b.com');
  });
  it('should return null without a hostname', function () {
    var u = {};
    expect(_.formatUrl(u)).to.not.be.ok;
    expect(_.formatUrl(u, 'https:')).to.not.be.ok;
  });
});

describe('addParamsAndAccessTokenToPath', function () {
  var accessToken = 'abc123';
  it('should handle no params and no path', function () {
    var options = {};
    _.addParamsAndAccessTokenToPath(accessToken, options);
    expect(options.path).to.eql('?access_token=abc123');
  });
  it('should handle existing params', function () {
    var options = { path: '/api?a=b' };
    _.addParamsAndAccessTokenToPath(accessToken, options);
    expect(options.path).to.eql('/api?access_token=abc123&a=b');
  });
  it('should handle a hash with params', function () {
    var options = { path: '/api?a=b#moreStuff??here' };
    _.addParamsAndAccessTokenToPath(accessToken, options);
    expect(options.path).to.eql('/api?access_token=abc123&a=b#moreStuff??here');
  });
  it('should handle a hash without params', function () {
    var options = { path: '/api#moreStuff??here' };
    _.addParamsAndAccessTokenToPath(accessToken, options);
    expect(options.path).to.eql('/api?access_token=abc123#moreStuff??here');
  });
  it('should handle a hash without params and no ?', function () {
    var options = { path: '/api#moreStuff' };
    _.addParamsAndAccessTokenToPath(accessToken, options);
    expect(options.path).to.eql('/api?access_token=abc123#moreStuff');
  });
  it('should handle extra params', function () {
    var options = { path: '/api#moreStuff' };
    _.addParamsAndAccessTokenToPath(accessToken, options, { foo: 'boo' });
    expect(options.path).to.eql('/api?access_token=abc123&foo=boo#moreStuff');
  });
});

describe('get', function () {
  it('should get a deeply nested value', function () {
    var o = { a: { b: { c: { d: 42 } } } };
    expect(_.get(o, 'a.b.c.d')).to.eql(42);
  });
  it('should be undefined for a missing value', function () {
    var o = { a: { b: { c: { d: 42 } } } };
    expect(_.get(o, 'a.b.x.d')).to.not.be.ok;
  });
  it('should handle bad input', function () {
    var o = 'hello';
    expect(_.get(o, 'oops.1.2.3')).to.not.be.ok;
  });
  it('should actually work with arrays too', function () {
    var o = { a: [{ b: { c: [1, { d: 42 }, null] } }, 99] };
    expect(_.get(o, 'a.0.b.c.1.d')).to.eql(42);
  });
  it('should handle undefined input', function () {
    var u = undefined;
    expect(_.get(u, 'a.b.c')).to.not.be.ok;
  });
});

describe('filterIp', function () {
  it('no user_ip', function () {
    var requestData = { something: 'but no ip' };
    _.filterIp(requestData, false);
    expect(requestData['user_ip']).to.not.be.ok;
  });
  it('capture true', function () {
    var ip = '123.32.394.99';
    var requestData = { user_ip: ip };
    _.filterIp(requestData, true);
    expect(requestData['user_ip']).to.eql(ip);
  });
  it('anonymize ip4', function () {
    var ip = '123.32.394.99';
    var requestData = { user_ip: ip };
    _.filterIp(requestData, 'anonymize');
    expect(requestData['user_ip']).to.not.eql(ip);
    expect(requestData['user_ip']).to.be.ok;
  });
  it('capture false', function () {
    var ip = '123.32.394.99';
    var requestData = { user_ip: ip };
    _.filterIp(requestData, false);
    expect(requestData['user_ip']).to.not.eql(ip);
    expect(requestData['user_ip']).to.not.be.ok;
  });
  it('ipv6 capture false', function () {
    var ip = '2607:f0d0:1002:51::4';
    var requestData = { user_ip: ip };
    _.filterIp(requestData, false);
    expect(requestData['user_ip']).to.not.eql(ip);
    expect(requestData['user_ip']).to.not.be.ok;
  });
  it('ipv6 anonymize', function () {
    var ips = [
      'FE80:0000:0000:0000:0202:B3FF:FE1E:8329',
      'FE80::0202:B3FF:FE1E:8329',
      '2607:f0d0:1002:51::4',
    ];
    for (var i = 0; i < ips.length; i++) {
      var ip = ips[i];
      var requestData = { user_ip: ip };
      _.filterIp(requestData, 'anonymize');
      expect(requestData['user_ip']).to.not.eql(ip);
      expect(requestData['user_ip']).to.be.ok;
    }
  });
});

describe('set', function () {
  it('should handle a top level key', function () {
    var o = { a: 42 };
    _.set(o, 'b', 1);
    expect(o.b).to.eql(1);
    expect(o.a).to.eql(42);
  });
  it('should handle a top level key', function () {
    var o = { a: 42, b: { c: 44, d: { e: 99 } } };
    _.set(o, 'f', 1);
    expect(o.f).to.eql(1);
    expect(o.a).to.eql(42);
    expect(o.b.c).to.eql(44);
    expect(o.b.d.e).to.eql(99);
  });
  it('should replace a value that is already there', function () {
    var o = { a: 42 };
    _.set(o, 'a', 1);
    expect(o.a).to.eql(1);
  });
  it('should set a nested value with missing keys', function () {
    var o = { baz: 21 };
    _.set(o, 'foo.bar', [42]);
    expect(o.baz).to.eql(21);
    expect(o.foo.bar).to.eql([42]);
  });
  it('should replace a nested value', function () {
    var o = { woo: 99, foo: { bar: { baz: 42, buzz: 97 }, a: 98 } };
    _.set(o, 'foo.bar.baz', 1);
    expect(o.woo).to.eql(99);
    expect(o.foo.a).to.eql(98);
    expect(o.foo.bar.buzz).to.eql(97);
    expect(o.foo.bar.baz).to.eql(1);
  });
  it('should set a nested value with some missing keys', function () {
    var o = { woo: 99, foo: { bar: { buzz: 97 }, a: 98 } };
    _.set(o, 'foo.bar.baz.fizz', 1);
    expect(o.woo).to.eql(99);
    expect(o.foo.a).to.eql(98);
    expect(o.foo.bar.buzz).to.eql(97);
    expect(o.foo.bar.baz.fizz).to.eql(1);
  });
  it('should be secure against prototype pollution', function () {
    const o = {};
    _.set(o, '__proto__.polluted', 'yes');
    expect({}.polluted).to.not.eql('yes');
    expect(o.polluted).to.not.eql('yes');
  });
});

import scrub from '../src/scrub.js';
describe('scrub', function () {
  it('should not redact fields that are okay', function () {
    var data = { a: 'somestring', password: 'abc123', tempWorker: 'cool' };",0
"function merge() {
  var i,
    src,
    copy,
    clone,
    name,
    result = Object.create(null), // no prototype pollution on Object
    current = null,
    length = arguments.length;

  for (i = 0; i < length; i++) {
    current = arguments[i];
    if (current == null) {",0
"}

function set(obj, path, value) {
  if (!obj) {
    return;
  }

  // Prevent prototype pollution by setting the prototype to null.
  Object.setPrototypeOf(obj, null);

  var keys = path.split('.');
  var len = keys.length;
  if (len < 1) {
    return;
  }
  if (len === 1) {",0
"    expect(e.payload.environment).to.eql('foo');
    expect(e.payload.fuzz).to.eql('buzz');
    expect(e.payload.other).to.eql('bar');
    expect(e.amihere).to.eql('yes');
    done();
  });
  it('should be secure against prototype pollution', function () {
    const o1 = JSON.parse('{""__proto__"": {""polluted"": ""yes""}}');
    const o2 = JSON.parse('{""__proto__"": {""polluted"": ""yes""}}');
    const result = _.merge(o1, o2);
    expect({}.polluted).to.not.eql('yes');
    expect(result.polluted).to.not.eql('yes');
  });
});

var traverse = require('../src/utility/traverse');
describe('traverse', function () {
  describe('should call the func for every key,value', function () {
    it('simple object', function (done) {
      var obj = { a: 1, b: 2 };
      var expectedOutput = { a: 2, b: 3 };
      var callCount = 0;
      var result = traverse(obj, function (k, v) {
        callCount++;
        return v + 1;
      });
      expect(result).to.eql(expectedOutput);
      expect(callCount).to.eql(2);

      done();
    });
    it('nested object', function (done) {
      var obj = { a: 1, b: 2, c: { ca: 11 } };
      var expectedOutput = { a: 2, b: 3, c: { ca: 12 } };
      var callCount = 0;
      var result = traverse(obj, function (k, v) {
        callCount++;
        if (k === 'c') {
          return { ca: v.ca + 1 };
        }
        return v + 1;
      });
      expect(result).to.eql(expectedOutput);
      expect(callCount).to.eql(3);

      done();
    });
    it('array', function (done) {
      var obj = [1, 2, 3];
      var expected = [0, 1, 2];
      var callCount = 0;
      var result = traverse(
        obj,
        function (k, v) {
          callCount++;
          return v - 1;
        },
        [],
      );
      expect(result).to.eql(expected);
      expect(callCount).to.eql(3);
      done();
    });
  });
});

describe('uuid4', function () {
  it('should return a version 4 uuid', function (done) {
    var id = _.uuid4();
    var otherId = _.uuid4();
    expect(id).to.not.eql(otherId);
    var parts = id.split('-');
    expect(parts.length).to.eql(5);
    expect(parts[2][0]).to.eql('4');
    expect(parts[0].length).to.eql(8);
    expect(parts[1].length).to.eql(4);
    expect(parts[2].length).to.eql(4);
    expect(parts[3].length).to.eql(4);
    expect(parts[4].length).to.eql(12);
    done();
  });
});

describe('redact', function () {
  it('should return a string of stars', function (done) {
    var s1 = 'thisIsApasswrD';
    var s2 = 'short';
    var o = { a: 123 };
    var a = [12, 34, 56];

    expect(_.redact(s1)).to.not.match(/[^*]/);
    expect(_.redact(s2)).to.not.match(/[^*]/);
    expect(_.redact(s1)).to.eql(_.redact(s2));
    expect(_.redact(o)).to.not.match(/[^*]/);
    expect(_.redact(a)).to.not.match(/[^*]/);

    done();
  });
});

describe('LEVELS', function () {
  it('should include debug', function () {
    expect(_.LEVELS['debug']).to.not.eql(undefined);
  });
  it('should have critical higher than debug', function () {
    expect(_.LEVELS['critical']).to.be.greaterThan(_.LEVELS['debug']);
  });
});

describe('formatUrl', function () {
  it('should handle a missing protocol', function () {
    var u = {
      hostname: 'a.b.com',
      path: '/wooza/',
      port: 42,
    };
    expect(_.formatUrl(u)).to.eql('https://a.b.com:42/wooza/');
  });
  it('should use a forced protocol', function () {
    var u = {
      hostname: 'a.b.com',
      path: '/wooza/',
      port: 42,
    };
    expect(_.formatUrl(u, 'file:')).to.eql('file://a.b.com:42/wooza/');
  });
  it('should pick a protocol based on port if others are missing', function () {
    var u = {
      hostname: 'a.b.com',
      port: 80,
      path: '/woo',
    };
    expect(_.formatUrl(u)).to.eql('http://a.b.com:80/woo');
    u.protocol = 'https:';
    expect(_.formatUrl(u)).to.eql('https://a.b.com:80/woo');
  });
  it('should handle missing parts', function () {
    var u = {
      hostname: 'a.b.com',
    };
    expect(_.formatUrl(u)).to.eql('https://a.b.com');
    expect(_.formatUrl(u, 'http:')).to.eql('http://a.b.com');
  });
  it('should return null without a hostname', function () {
    var u = {};
    expect(_.formatUrl(u)).to.not.be.ok();
    expect(_.formatUrl(u, 'https:')).to.not.be.ok();
  });
});

describe('addParamsAndAccessTokenToPath', function () {
  var accessToken = 'abc123';
  it('should handle no params and no path', function () {
    var options = {};
    _.addParamsAndAccessTokenToPath(accessToken, options);
    expect(options.path).to.eql('?access_token=abc123');
  });
  it('should handle existing params', function () {
    var options = { path: '/api?a=b' };
    _.addParamsAndAccessTokenToPath(accessToken, options);
    expect(options.path).to.eql('/api?access_token=abc123&a=b');
  });
  it('should handle a hash with params', function () {
    var options = { path: '/api?a=b#moreStuff??here' };
    _.addParamsAndAccessTokenToPath(accessToken, options);
    expect(options.path).to.eql('/api?access_token=abc123&a=b#moreStuff??here');
  });
  it('should handle a hash without params', function () {
    var options = { path: '/api#moreStuff??here' };
    _.addParamsAndAccessTokenToPath(accessToken, options);
    expect(options.path).to.eql('/api?access_token=abc123#moreStuff??here');
  });
  it('should handle a hash without params and no ?', function () {
    var options = { path: '/api#moreStuff' };
    _.addParamsAndAccessTokenToPath(accessToken, options);
    expect(options.path).to.eql('/api?access_token=abc123#moreStuff');
  });
  it('should handle extra params', function () {
    var options = { path: '/api#moreStuff' };
    _.addParamsAndAccessTokenToPath(accessToken, options, { foo: 'boo' });
    expect(options.path).to.eql('/api?access_token=abc123&foo=boo#moreStuff');
  });
});

describe('json3', function () {
  var setupCustomJSON = require('../vendor/JSON-js/json3.js');
  it('should replace stringify if not there', function () {
    var j = {};
    setupCustomJSON(j);
    expect(j.stringify({ a: 1 })).to.eql('{""a"":1}');
  });
  it('should replace parse if not there', function () {
    var j = {};
    setupCustomJSON(j);
    expect(j.parse('{""a"":1}').a).to.eql(1);
  });
  it('should not replace parse if there', function () {
    var j = {
      parse: function (s) {
        return 42;
      },
    };
    setupCustomJSON(j);
    expect(j.parse('{""a"":1}')).to.eql(42);
    expect(j.stringify({ a: 1 })).to.eql('{""a"":1}');
  });
  it('should not replace stringify if there', function () {
    var j = {
      stringify: function (s) {
        return '42';
      },
    };
    setupCustomJSON(j);
    expect(j.stringify({ a: 1 })).to.eql('42');
    expect(j.parse('{""a"":1}').a).to.eql(1);
  });
});

describe('get', function () {
  it('should get a deeply nested value', function () {
    var o = { a: { b: { c: { d: 42 } } } };
    expect(_.get(o, 'a.b.c.d')).to.eql(42);
  });
  it('should be undefined for a missing value', function () {
    var o = { a: { b: { c: { d: 42 } } } };
    expect(_.get(o, 'a.b.x.d')).to.not.be.ok();
  });
  it('should handle bad input', function () {
    var o = 'hello';
    expect(_.get(o, 'oops.1.2.3')).to.not.be.ok();
  });
  it('should actually work with arrays too', function () {
    var o = { a: [{ b: { c: [1, { d: 42 }, null] } }, 99] };
    expect(_.get(o, 'a.0.b.c.1.d')).to.eql(42);
  });
  it('should handle undefined input', function () {
    var u = undefined;
    expect(_.get(u, 'a.b.c')).to.not.be.ok();
  });
});

describe('filterIp', function () {
  it('no user_ip', function () {
    var requestData = { something: 'but no ip' };
    _.filterIp(requestData, false);
    expect(requestData['user_ip']).to.not.be.ok();
  });
  it('capture true', function () {
    var ip = '123.32.394.99';
    var requestData = { user_ip: ip };
    _.filterIp(requestData, true);
    expect(requestData['user_ip']).to.eql(ip);
  });
  it('anonymize ip4', function () {
    var ip = '123.32.394.99';
    var requestData = { user_ip: ip };
    _.filterIp(requestData, 'anonymize');
    expect(requestData['user_ip']).to.not.eql(ip);
    expect(requestData['user_ip']).to.be.ok();
  });
  it('capture false', function () {
    var ip = '123.32.394.99';
    var requestData = { user_ip: ip };
    _.filterIp(requestData, false);
    expect(requestData['user_ip']).to.not.eql(ip);
    expect(requestData['user_ip']).to.not.be.ok();
  });
  it('ipv6 capture false', function () {
    var ip = '2607:f0d0:1002:51::4';
    var requestData = { user_ip: ip };
    _.filterIp(requestData, false);
    expect(requestData['user_ip']).to.not.eql(ip);
    expect(requestData['user_ip']).to.not.be.ok();
  });
  it('ipv6 anonymize', function () {
    var ips = [
      'FE80:0000:0000:0000:0202:B3FF:FE1E:8329',
      'FE80::0202:B3FF:FE1E:8329',
      '2607:f0d0:1002:51::4',
    ];
    for (var i = 0; i < ips.length; i++) {
      var ip = ips[i];
      var requestData = { user_ip: ip };
      _.filterIp(requestData, 'anonymize');
      expect(requestData['user_ip']).to.not.eql(ip);
      expect(requestData['user_ip']).to.be.ok();
    }
  });
});

describe('set', function () {
  it('should handle a top level key', function () {
    var o = { a: 42 };
    _.set(o, 'b', 1);
    expect(o.b).to.eql(1);
    expect(o.a).to.eql(42);
  });
  it('should handle a top level key', function () {
    var o = { a: 42, b: { c: 44, d: { e: 99 } } };
    _.set(o, 'f', 1);
    expect(o.f).to.eql(1);
    expect(o.a).to.eql(42);
    expect(o.b.c).to.eql(44);
    expect(o.b.d.e).to.eql(99);
  });
  it('should replace a value that is already there', function () {
    var o = { a: 42 };
    _.set(o, 'a', 1);
    expect(o.a).to.eql(1);
  });
  it('should set a nested value with missing keys', function () {
    var o = { baz: 21 };
    _.set(o, 'foo.bar', [42]);
    expect(o.baz).to.eql(21);
    expect(o.foo.bar).to.eql([42]);
  });
  it('should replace a nested value', function () {
    var o = { woo: 99, foo: { bar: { baz: 42, buzz: 97 }, a: 98 } };
    _.set(o, 'foo.bar.baz', 1);
    expect(o.woo).to.eql(99);
    expect(o.foo.a).to.eql(98);
    expect(o.foo.bar.buzz).to.eql(97);
    expect(o.foo.bar.baz).to.eql(1);
  });
  it('should set a nested value with some missing keys', function () {
    var o = { woo: 99, foo: { bar: { buzz: 97 }, a: 98 } };
    _.set(o, 'foo.bar.baz.fizz', 1);
    expect(o.woo).to.eql(99);
    expect(o.foo.a).to.eql(98);
    expect(o.foo.bar.buzz).to.eql(97);
    expect(o.foo.bar.baz.fizz).to.eql(1);
  });
  it('should be secure against prototype pollution', function () {
    const o = {};
    _.set(o, '__proto__.polluted', 'yes');
    expect({}.polluted).to.not.eql('yes');
    expect(o.polluted).to.not.eql('yes');
  });
});

var scrub = require('../src/scrub');
describe('scrub', function () {
  it('should not redact fields that are okay', function () {
    var data = {",0
"    const fileCreator = new FileCreator({
      projectDir,
      usingTsc: projectSetupData.useTypeScript,
    })
    fileCreator.createProject({
      projectName,
      packageManager: projectSetupData.packageManager,
    })

    if (options.skipInstall || projectSetupData.skipPackageInstallation) {
      // Skip package installation
      console.log(chalk.yellow('Skipping package installation'))
    } else {",0
"import path from 'path'
import fs from 'fs'
import { dataSourcesTypeData, DataSourceType } from '@kottster/common'
import { FileTemplateManager } from './fileTemplateManager.service'
import { VERSION } from '../version'
import { PackageManager } from '../models/packageManager'

interface FileCreatorOptions {
  projectDir?: string
  usingTsc?: boolean
}

interface CreateProjectOptions {
  projectName: string;
  packageManager: PackageManager;
}

interface PackageJsonOptions {
  name: string;
  type?: 'module';
  version?: string;
  dependencies?: Record<string, string>;
  devDependencies?: Record<string, string>;
  pnpm?: {
    onlyBuiltDependencies?: string[];
  }
}

type EnvOptions = {
  key: string;
  comment?: string;
  value: string;
}[];

/**
 * Service for creating files in the project.
 */
export class FileCreator {
  private readonly projectDir: string;
  private readonly usingTsc: boolean;
  private readonly fileTemplateManager: FileTemplateManager;

  constructor (options?: FileCreatorOptions) {
    this.projectDir = options?.projectDir ?? process.cwd();
    this.usingTsc = options?.usingTsc ?? false;
    this.fileTemplateManager = new FileTemplateManager(this.usingTsc);
  }

  get jsExt () {
    return this.usingTsc ? 'ts' : 'js';
  }
  
  get jsxExt () {
    return this.usingTsc ? 'tsx' : 'jsx';
  }

  /**
   * Create a new project files.
   * @param options The new project options.
   */
  public createProject (options: CreateProjectOptions): void {
    // Check if project directory already exists
    if (fs.existsSync(this.projectDir) && options.projectName !== '.') {
      throw new Error(`Project directory already exists: ${this.projectDir}`)
    };

    // Create directories
    this.createDir()
    this.createDir('app')
    this.createDir('app/pages')
    this.createDir('app/_server')
    this.createDir('app/_server/data-sources')

    // Create root files
    this.createPackageJson({ 
      name: options.projectName,
      dependencies: {},
      devDependencies: this.usingTsc ? this.getTypescriptDependencies() : {},
      pnpm: options.packageManager === 'pnpm' ? {
        onlyBuiltDependencies: ['better-sqlite3'],
      } : undefined,
    });
    this.createGitIgnore()
    
    // Create files
    this.createFileFromTemplate('vite.config.js', path.join(this.projectDir, `vite.config.${this.jsExt}`));
    this.createFileFromTemplate('Dockerfile', path.join(this.projectDir, 'Dockerfile'));
    this.createFileFromTemplate('docker-compose.yml', path.join(this.projectDir, 'docker-compose.yml'));
    this.createFileFromTemplate('app/index.html', path.join(this.projectDir, `app/index.html`));
    this.createFileFromTemplate('app/main.jsx', path.join(this.projectDir, `app/main.${this.jsxExt}`));
    this.createFileFromTemplate('app/_server/app.js', path.join(this.projectDir, `app/_server/app.${this.jsExt}`));
    this.createFileFromTemplate('app/_server/server.js', path.join(this.projectDir, `app/_server/server.${this.jsExt}`));
    if (this.usingTsc) {
      this.createFileFromTemplate('tsconfig.json', path.join(this.projectDir, 'tsconfig.json'));
    }
    
    this.createSchema()
  }

  /**
   * Get the additional dependencies for a TypeScript project.
   * @returns The TypeScript dependencies.
   */
  private getTypescriptDependencies(): Record<string, string> {
    return {
      'typescript': '^5.x',
      '@types/node': '^20.x',
      '@types/react': '^19.x',
      '@types/react-dom': ""^19.x"",
    };
  }

  /**
   * Add a data source to the project.
   * @param dataSourceType The type of the data source.
   * @returns The path to the data source file.
   */
  public addDataSource (dataSourceType: DataSourceType, dataSourceName?: string, data: Record<string, unknown> = {}): string {
    const dataSourceTypeData = dataSourcesTypeData[dataSourceType];
    const { fileTemplateName } = dataSourceTypeData;

    const finalDataSourceName = dataSourceName || `${dataSourceType}-db`;
    const directory = `app/_server/data-sources/${finalDataSourceName}`;

    // Create directory
    this.createDir(directory);

    // Create file with adapter
    const filePath = path.join(directory, `index.${this.jsExt}`)
    const fileContent = this.fileTemplateManager.getTemplate(fileTemplateName as keyof typeof FileTemplateManager.templates, data);
    this.writeFile(filePath, fileContent)

    // Create dataSource.json file
    const dataSourceJsonPath = path.join(directory, 'dataSource.json');
    const dataSourceJsonContent = JSON.stringify({
      type: dataSourceType,
      tablesConfig: {},
    }, null, 2);
    this.writeFile(dataSourceJsonPath, dataSourceJsonContent);

    return filePath;
  }

  /**
   * Create a package.json file
   * @param options The package.json content
   */
  private createPackageJson(options: PackageJsonOptions) {
    const packageJsonPath = path.join(this.projectDir, 'package.json')

    const {
      KOTTSTER_COMMON_DEP_VER,
      KOTTSTER_CLI_DEP_VER,
      KOTTSTER_SERVER_DEP_VER,
      KOTTSTER_REACT_DEP_VER,
    } = process.env;

    const packageJson = {
      name: options.name,
      version: options.version || '1.0.0',
      type: 'module',
      private: true,
      sideEffects: false,
      scripts: {
        'dev': 'kottster dev',
        'dev:add-data-source': 'kottster add-data-source',
        'dev:upgrade-kottster': 'kottster upgrade',
        ""build"": ""vite build && kottster build:server"",
        ""start"": ""node dist/server/server.cjs""
      },
      dependencies: {
        'react': '^19.x',
        'react-dom': '^19.x',
        'react-router-dom': '^7.x',
        'better-sqlite3': '^12.x',

        // Using exact same version as the CLI.
        // This ensures compatibility between the core packages
        '@kottster/common': KOTTSTER_COMMON_DEP_VER ?? VERSION,
        '@kottster/cli': KOTTSTER_CLI_DEP_VER ?? VERSION,
        '@kottster/server': KOTTSTER_SERVER_DEP_VER ?? VERSION,
        '@kottster/react': KOTTSTER_REACT_DEP_VER ?? VERSION,

        ...(options.dependencies ?? {}),
      },
      devDependencies: {
        'vite': ""^6.x"",
        'vite-tsconfig-paths': ""^4.x"",
        ""@vitejs/plugin-react"": ""^4.x"",
        
        // Using tsx to run TS/JS files directly
        'tsx': '^4.x',
        ...(options.devDependencies ?? {}),
      },
      engines: {
        node: '>=20',
      },
      pnpm: options.pnpm || undefined,
    }
    const packageJsonContent = JSON.stringify(packageJson, null, 2)

    this.writeFile(packageJsonPath, packageJsonContent)
  }
",0
export const VERSION = '3.3.2';,0
"import { DashboardPageConfig, DashboardPageConfigCard, DashboardPageConfigStat } from ""./dashboardPage.model"";
import { RelationalDatabaseSchema } from ""./databaseSchema.model"";
import { DataSourceType, PublicDataSource } from ""./dataSource.model"";
import { Page, PageFileStructure } from ""./page.model"";
import { TablePageConfig } from ""./tablePage.model"";
import { Template } from ""./template.model"";
import { ClientIdentityProviderRole, ClientIdentityProviderUser, ClientIdentityProviderUserWithRoles, IdentityProviderUserPermission, User } from ""./idp.model"";

export interface InternalApiSchema {
  getUsers: {
    body: unknown;
    result: {
      users: ClientIdentityProviderUser[];
    };
  };

  createUser: {
    body: {
      user: Pick<ClientIdentityProviderUser, 'firstName' | 'email' | 'avatarUrl' | 'lastName' | 'username' | 'roleIds' | 'temporaryPassword'>;
      password: string;
    };
    result: {
      user: ClientIdentityProviderUser;
    };
  };

  updateUser: {
    body: {
      userId: ClientIdentityProviderUser['id'];
      user: Partial<ClientIdentityProviderUser>;
      newPassword?: string;
    };
    result: {
      user: ClientIdentityProviderUser;
    };
  };

  deleteUser: {
    body: {
      userId: ClientIdentityProviderUser['id'];
    };
    result: void;
  };

  createRole: {
    body: {
      role: Pick<ClientIdentityProviderRole, 'name' | 'permissions'>;
    };
    result: {
      role: ClientIdentityProviderRole;
    };
  };

  updateRole: {
    body: {
      roleId: ClientIdentityProviderRole['id'];
      role: Partial<ClientIdentityProviderRole>;
    };
    result: {
      role: ClientIdentityProviderRole;
    };
  };

  deleteRole: {
    body: {
      roleId: ClientIdentityProviderRole['id'];
    };
    result: void;
  };

  getApp: {
    body: unknown;
    result: {
      schema: ClientAppSchema; 

      // Pass only if user is authenticated
      user?: ClientIdentityProviderUserWithRoles;
      roles?: ClientIdentityProviderRole[];
      userPermissions?: (keyof typeof IdentityProviderUserPermission | string)[];
    };
  };

  generateSql: {",0
"  jwtTokenCheck?: string;
  settings?: Record<string, any>;
  createdAt?: Date | string;
  updatedAt?: Date | string;
}

export interface IdentityProviderUserWithRoles extends IdentityProviderUser {
  roles: IdentityProviderRole[];
}

export interface ClientIdentityProviderUser extends Omit<
  IdentityProviderUser, 
  'passwordHash' | 'passwordResetToken' | 'twoFactorSecret' | 'jwtTokenSecret'
> {}

export interface ClientIdentityProviderUserWithRoles extends ClientIdentityProviderUser {
  roles: IdentityProviderRole[];
}

export interface IdentityProviderRole {
  id: number | string;
  name: string;
  permissions?: (keyof typeof IdentityProviderUserPermission)[];
  createdAt?: Date | string;
  updatedAt?: Date | string;
}

export interface ClientIdentityProviderRole extends IdentityProviderRole {}",0
"
interface BasePage {
  version: string;
  key: string;
  title?: string;
  icon?: string;
  hideInSidebar?: boolean;

  allowedRoles?: string[];

  /**
   * @deprecated Legacy - to be removed in v4. Use `allowedRoles` instead.
   */
  allowedRoleIds?: string[];
}

interface TablePage extends BasePage {
  type: 'table';
  config: TablePageConfig;
}

interface DashboardPage extends BasePage {
  type: 'dashboard';
  config: DashboardPageConfig;
}

interface CustomPage extends BasePage {
  type: 'custom';
  key: string;
  title: string;
}

export type Page = TablePage | DashboardPage | CustomPage;

interface PublicTablePage extends Pick<TablePage, 'key' | 'title' | 'icon' | 'type' | 'allowedRoles' | 'allowedRoleIds' | 'version' | 'hideInSidebar'> {
  config: TablePage['config'];
}

interface PublicDashboardPage extends Pick<DashboardPage, 'key' | 'title' | 'icon' | 'type' | 'allowedRoles' | 'allowedRoleIds' | 'version' | 'hideInSidebar'> {
  config: DashboardPage['config'];
}

interface PublicCustomPage extends Pick<CustomPage, 'key' | 'title' | 'icon' | 'type' | 'allowedRoles' | 'allowedRoleIds' | 'version' | 'hideInSidebar'> {}

export type PublicPage = PublicTablePage | PublicDashboardPage | PublicCustomPage;

export interface PageFileStructure {
  pageKey: string;
",0
"  sorting?: {
    column: string;
    direction: 'asc' | 'desc';
  };
  filters?: FilterItem[];
  
  viewKey?: string;

  getByForeignRecord?: {
    relationship: OneToManyRelationship;
    recordPrimaryKeyValue: string | number;
  };
}

export interface TablePageInitiateRecordsExportInput extends TablePageGetRecordsInput {
  format: 'csv' | 'json' | 'xlsx';
}

export interface TablePageCustomDataFetcherInput extends TablePageInputBase {
  page: number;
  pageSize: number;
  search?: string;
}

export interface TablePageGetRecordInput extends TablePageInputBase {
  nestedTableKey?: TablePageNestedTableKey;

  /** For selecting particular records */
  primaryKeyValues?: any[];

  forPreview?: boolean;
}

export interface TablePageCreateRecordInput extends TablePageInputBase {
  nestedTableKey?: TablePageNestedTableKey;
  values: Record<string, any>;
}

export interface TablePageUpdateRecordInput extends TablePageInputBase {
  nestedTableKey?: TablePageNestedTableKey;
  primaryKeyValue: any;
  values: Record<string, any>;
}

export interface TablePageDeleteRecordInput extends TablePageInputBase {
  nestedTableKey?: TablePageNestedTableKey;
  primaryKeyValues: any[];
}

export enum TablePageFieldRequirement {
  none = 'none',
  notEmpty = 'notEmpty',
  notZero = 'notZero',
}

export interface TablePageConfigColumn {
  /** Column name in the database table or any other unique identifier */
  column: string;

  /** Display name for the column */
  label?: string;

  /** Prefix for the column value (goes before the value) */
  prefix?: string;

  /** Suffix for the column value (goes after the value) */
  suffix?: string;
  
  /** 
   * Whether the column is hidden in the table 
   * @default false
   */
  hiddenInTable?: boolean;

  /** Whether the column is sortable */
  sortable?: boolean;

  /** Whether the column is searchable */
  searchable?: boolean;

  /** Whether the column is filterable */
  filterable?: boolean;
  
  /** 
   * Whether the column is hidden in the form
   * @default false
   */
  hiddenInForm?: boolean;

  /**
   * Form input type and its properties
   */
  fieldInput?: FieldInput;

  /** 
   * Validation rule for the column
   */
  fieldRequirement?: string | keyof typeof TablePageFieldRequirement;

  /** Grid field span for the field in the form (12, 8, 6, 4) */
  formFieldSpan?: string;
  
  /** If the column is a foreign key, this specifies the column in the related table to be displayed as the label */
  relationshipPreviewColumns?: string[];
  
  /** Client-side index of the column in the table */
  position?: number;

  /** 
   * Client-side custom render function for the column 
   * 
   * @param record - The record object containing all columns
   * @param recordIndex - The index of the record in the current page
   * @param data - Additional data including all records and total count
   * 
   * @example render: (record) => <span>{record.first_name} {record.last_name}</span>
   * 
   * @returns The rendered React element or content for the column
   */
  render?: (
    record: TablePageRecord,
    recordIndex: number, 
    data: {
      records: TablePageRecord[];
      total: number;
    }
  ) => any;

  /** Client-side custom width for the column */
  width?: number;
}

export interface TablePageConfigCalculatedColumn {
  /** Display name for the column */
  label?: string;

  /** Client-side index of the column in the table */
  position?: number;

  /**
   * Raw SQL expression for the calculated column
   * Use 'main' as the alias for the main table
   * @example 'SELECT COUNT(*) FROM orders WHERE orders.user_id = main.id'
   */
  sqlExpression: string;

  /**
   * Alias for the calculated column in SQL results and display
   * This will be used as both the SQL alias and the property name in result objects
   */
  alias: string;
}

export enum TableFetchStrategy {
  databaseTable = 'databaseTable',
  rawSqlQuery = 'rawSqlQuery',
  customFetch = 'customFetch',
}

export enum TablePageConfigViewFilteringStrategy {
  filter = 'filter',
  sqlWhereExpression = 'sqlWhereExpression',
}

export interface TablePageConfigView {
  key: string;
  label: string;
  filteringStrategy: TablePageConfigViewFilteringStrategy;
  filterItems?: FilterItem[];
  sqlWhereExpression?: string;
}

export interface TablePageConfig {
  /** 
   * Set up using no-code 
   */

  table?: string;
  dataSource?: string;
  fetchStrategy: keyof typeof TableFetchStrategy;

  primaryKeyColumn?: string;
  
  /** 
   * @deprecated Deprecated since now users can now set page size in the UI 
   */
  pageSize?: number;
  
  columns?: TablePageConfigColumn[];
  calculatedColumns?: TablePageConfigCalculatedColumn[];

  allowInsert?: boolean;
  allowUpdate?: boolean;
  allowDelete?: boolean;

  allowedRolesToInsert?: string[];
  allowedRolesToUpdate?: string[];
  allowedRolesToDelete?: string[];
  
  /**
   * @deprecated Legacy - to be removed in v4. Use `allowedRolesToInsert` instead
   */
  allowedRoleIdsToInsert?: string[];

  /**
   * @deprecated Legacy - to be removed in v4. Use `allowedRolesToUpdate` instead
   */
  allowedRoleIdsToUpdate?: string[];
  
  /**
   * @deprecated Legacy - to be removed in v4. Use `allowedRolesToDelete` instead
   */
  allowedRoleIdsToDelete?: string[];

  customSqlQuery?: string;
  customSqlCountQuery?: string;

  /** 
   * Views for pre-defined filters or SQL WHERE clauses
   */
  views?: TablePageConfigView[];

  /** 
   * Set up using manual configuration
   */

  /**
   * Custom fetcher function to retrieve data.",0
"import { ROOT_USER_ID } from ""../constants/idp"";
import { ClientIdentityProviderRole, ClientIdentityProviderUser, IdentityProviderRole, IdentityProviderUser, User } from ""../models/idp.model"";

type UnifiedUser = IdentityProviderUser | ClientIdentityProviderUser | User | ClientIdentityProviderUser;

type UnifiedRole = IdentityProviderRole | ClientIdentityProviderRole;

/**
 * Checks if the user has at least one of the specified roles.
 * @description Role IDs properties have been replaced with role names. This function supports both for backward compatibility.
 */
export function checkUserForRoles(
  userId: UnifiedUser['id'], 
  userRoles: UnifiedRole[],
  roles?: string[],
  roleIds?: string[]
) {
  // If no user is provided, deny access
  if (!userId) {
    return false;
  }

  // It's assumed that the root user has all roles
  if (userId === ROOT_USER_ID) {
    return true;
  }

  // If no roles or roleIds are specified, allow access
  if ((!roles || roles.length === 0) && (!roleIds || roleIds.length === 0)) {
    return true;
  }  
  
  // TODO: Remove in v4 - only keep role names
  // Get user role IDs (for backward compatibility)
  const userRoleIds = userRoles.map(r => r.id).map(v => v.toString());
  
  // Get user role names
  const userRoleNames = userRoles.map(r => r.name).filter(n => n) as string[];

  return roles?.some(n => userRoleNames.includes(n)) || roleIds?.some(rid => userRoleIds.includes(rid.toString()));
}",0
"      hiddenColumns,
      
      relationships: sortedRelationships,
      hiddenRelationships,
  
      allowInsert,
      allowedRolesToInsert: tablePageConfig.allowedRolesToInsert,
      allowUpdate,
      allowedRolesToUpdate: tablePageConfig.allowedRolesToUpdate,
      allowDelete,
      allowedRolesToDelete: tablePageConfig.allowedRolesToDelete,

      pageSize: tablePageConfig?.pageSize ?? defaultTablePageSize,

      defaultSortColumn: tablePageConfig?.defaultSortColumn ?? primaryKeyColumn,
      defaultSortDirection: tablePageConfig?.defaultSortDirection ?? 'desc',

      views: tablePageConfig?.views || [],

      // Deprecated values replaced by allowedRoles fields
      allowedRoleIdsToInsert: tablePageConfig?.allowedRoleIdsToInsert,
      allowedRoleIdsToUpdate: tablePageConfig?.allowedRoleIdsToUpdate,
      allowedRoleIdsToDelete: tablePageConfig?.allowedRoleIdsToDelete,
    },
  };
}",0
"import { IdentityProviderUserWithRoles, InternalApiBody, InternalApiResult } from ""@kottster/common"";
import { Action } from ""../models/action.model"";

/**
 * Change the password of a current user
 */
export class ChangePassword extends Action {
  public async execute({ password, newPassword }: InternalApiBody<'changePassword'>, user: IdentityProviderUserWithRoles): Promise<InternalApiResult<'changePassword'>> {
    const isPasswordVerified = user.passwordHash && await this.app.identityProvider.verifyPassword(password, user.passwordHash);
    if (!isPasswordVerified) {
      throw new Error('Password is incorrect');
    }

    await this.app.identityProvider.updateUserPassword(user.id, newPassword);",0
" * Delete the role
 */
export class DeleteRole extends Action {
  protected requiredPermissions = [IdentityProviderUserPermission.manage_users];
  
  public async execute({ roleId }: InternalApiBody<'deleteRole'>): Promise<InternalApiResult<'deleteRole'>> {
    // TODO: Update all references in the app configuration

    await this.app.identityProvider.deleteRole(roleId);
  }
}",0
"import { IdentityProviderUserWithRoles, InternalApiBody, InternalApiResult, Page, Stage } from ""@kottster/common"";
import { Action } from ""../models/action.model"";
import { FileReader } from ""../services/fileReader.service"";

/**
 * Get the app data
 */
export class GetApp extends Action {
  private cachedPages: Page[] | null = null;

  public async execute(_: InternalApiBody<'getApp'>, user?: IdentityProviderUserWithRoles): Promise<InternalApiResult<'getApp'>> {
    
    const roles = user ? await this.app.identityProvider.getRoles() : [];
    const userPermissions = user ? await this.app.identityProvider.getUserPermissions(user.id) : [];
    const fileReader = new FileReader(this.app.stage === Stage.development);

    // Cache pages in production to avoid reading files every time
    const pages = this.app.stage === Stage.production && this.cachedPages
      ? this.cachedPages
      : this.app.loadedPageConfigs;
    
    if (this.app.stage === Stage.production && !this.cachedPages) {
      this.cachedPages = pages;
    }
    
    // In production, use the in-memory schema; in development, read from file
    const appSchema = this.app.stage === Stage.production ? this.app.schema : fileReader.readSchemaJsonFile();

    return {
      schema: {
        ...appSchema,
        pages,
        dataSources: this.app.dataSources.map((dataSource) => {
          return {
            name: dataSource.name,
            type: dataSource.type,
          };
        }),
        enterpriseHub: appSchema.enterpriseHub,
      },
      user: user ? this.app.identityProvider.prepareUserForClient(user) : undefined,
      roles,
      userPermissions,
    };
  }
}",0
"import { IdentityProviderUserWithRoles, InternalApiBody, InternalApiResult } from ""@kottster/common"";
import { Action } from ""../models/action.model"";
import { KottsterApi } from ""../services/kottsterApi.service"";

const emptyResult: InternalApiResult<'getKottsterContext'> = {
  imposedLimits: {},
};

/**
 * Get the information about the current Kottster version, 
 * and what limits are in place for the kottster api token in use
 */
export class GetKottsterContext extends Action {
  public async execute(_: InternalApiBody<'getKottsterContext'>, user: IdentityProviderUserWithRoles): Promise<InternalApiResult<'getKottsterContext'>> {
    const kottsterApi = new KottsterApi();
    const kottsterApiToken = this.app.getKottsterApiToken();
    if (!kottsterApiToken) {
      return emptyResult;
    }
",0
"import { generateRandomString, InternalApiBody, InternalApiResult, isSchemaEmpty } from ""@kottster/common"";
import { DevAction } from ""../models/action.model"";
import { FileWriter } from ""../services/fileWriter.service"";
import { randomUUID } from ""crypto"";
import { KottsterApi } from ""../services/kottsterApi.service"";

/**
 * Initialize the Kottster app
 */
export class InitApp extends DevAction {
  public async execute({ name, rootUsername, rootPassword }: InternalApiBody<'initApp'>): Promise<InternalApiResult<'initApp'>> {
    if (!isSchemaEmpty(this.app.schema)) {
      throw new Error('The app has already been initialized.');
    }

    const fileWrtier = new FileWriter({ usingTsc: this.app.usingTsc });
    const id = randomUUID();

    // Get API token from Kottster API
    let apiToken: string | undefined = undefined;
    try {",0
" * Install the required packages for the data source
 */
export class InstallPackagesForDataSource extends DevAction {
  public async execute(data: InternalApiBody<'installPackagesForDataSource'>): Promise<InternalApiResult<'installPackagesForDataSource'>> {
    return new Promise((resolve, reject) => {
      const { type } = data;
      if (!Object.values(DataSourceType).includes(type)) {
        reject(new Error(`Unsupported data source type: ${type}`));
        return;
      }

      const command = this.getCommand(type);
      exec(command, { cwd: PROJECT_DIR }, (error) => {
        if (error) {
          console.error(`Error executing command: ${error}`);
          reject(error);",0
"import { IdentityProviderUserWithRoles, InternalApiBody, InternalApiResult } from ""@kottster/common"";
import { Action } from ""../models/action.model"";

/**
 * Log out all sessions of a current user
 */
export class LogOutAllSessions extends Action {
  public async execute({ password }: InternalApiBody<'logOutAllSessions'>, user: IdentityProviderUserWithRoles): Promise<InternalApiResult<'logOutAllSessions'>> {
    const isPasswordVerified = user.passwordHash && await this.app.identityProvider.verifyPassword(password, user.passwordHash);
    if (!isPasswordVerified) {
      throw new Error('Current password is incorrect');
    }

    await this.app.identityProvider.invalidateAllSessions(user.id);",0
"import { IdentityProviderUser, IdentityProviderUserWithRoles, InternalApiBody, InternalApiResult } from ""@kottster/common"";
import { Action } from ""../models/action.model"";
import { Request } from ""express"";

/**
 * Login into an account
 */
export class Login extends Action {
  public async execute({ usernameOrEmail, password, newPassword }: InternalApiBody<'login'>, _: IdentityProviderUserWithRoles, req?: Request): Promise<InternalApiResult<'login'>> {
    const rootUser = this.app.identityProvider.getRootUserByUsername(usernameOrEmail);
    const ipAddress = this.getClientIp(req);

    // Fake await to mitigate timing attacks
    await new Promise((resolve) => setTimeout(resolve, 500));
",0
"export class UpdateRole extends Action {
  protected requiredPermissions = [IdentityProviderUserPermission.manage_users];

  public async execute({ roleId, role }: InternalApiBody<'updateRole'>): Promise<InternalApiResult<'updateRole'>> {
    const updatedRole = await this.app.identityProvider.updateRole(roleId, role);

    // TODO: When name is changed, update all references in the app configuration

    return {
      role: this.app.identityProvider.prepareRoleForClient(updatedRole),
    }
  }
}",0
"import { IdentityProviderUserPermission, IdentityProviderUserWithRoles, InternalApiBody, InternalApiResult } from ""@kottster/common"";
import { Action } from ""../models/action.model"";

/**
 * Update the user
 */
export class UpdateUser extends Action {
  public async execute({ userId, user, newPassword }: InternalApiBody<'updateUser'>, currentUser: IdentityProviderUserWithRoles): Promise<InternalApiResult<'updateUser'>> {
    const hasPermission = await this.app.identityProvider.userHasPermissions(currentUser.id, [IdentityProviderUserPermission.manage_users]);
    if (!hasPermission && currentUser.id !== userId) {
      throw new Error(""You don't have permission to update this user"");
    }

    const updatedUser = await this.app.identityProvider.updateUser(userId, user);",0
"import { ExtendAppContextFunction } from '../models/appContext.model';
import { PROJECT_DIR } from '../constants/projectDir';
import { AppSchema, checkTsUsage, DataSource, Stage, RpcActionBody, TablePageGetRecordsInput, TablePageDeleteRecordInput, TablePageUpdateRecordInput, TablePageCreateRecordInput, isSchemaEmpty, schemaPlaceholder, TablePageGetRecordInput, Page, TablePageConfig, TablePageCustomDataFetcherInput, TablePageGetRecordsResult, DashboardPageConfig, DashboardPageGetStatDataInput, DashboardPageGetCardDataInput, DashboardPageGetStatDataResult, DashboardPageGetCardDataResult, checkUserForRoles, InternalApiSchema, PartialTablePageConfig, transformStringToTablePageNestedTableKey, PartialDashboardPageConfig, DashboardPageConfigStat, DashboardPageConfigCard, TablePageInitiateRecordsExportInput, TablePageInitiateRecordsExportResult, Procedure, ProcedureContext, normalizeAppBasePath, IdentityProviderUserWithRoles } from '@kottster/common';
import { DataSourceRegistry } from './dataSourceRegistry';
import { ActionService } from '../services/action.service';
import { DataSourceAdapter } from '../models/dataSourceAdapter.model';
import { parse as parseCookie } from 'cookie';
import { Request, Response, NextFunction } from 'express';
import { createServer } from '../factories/createServer';
import { IdentityProvider } from './identityProvider';
import { HttpException, UnauthorizedException } from '../exceptions/httpException';
import { FileReader } from '../services/fileReader.service';
import { Exporter } from '../services/exporter.service';
import dayjs from 'dayjs';

type RequestHandler = (req: Request, res: Response, next: NextFunction) => void;

type PostAuthMiddleware = (user: IdentityProviderUserWithRoles, request: Request) => void | Promise<void>;

export interface KottsterAppOptions {
  schema: AppSchema | Record<string, never>;

  /**
   * The secret key used to sign JWT tokens
   */
  secretKey?: string;

  /**
   * The root admin username
   */
  rootUsername?: string;

  /**
   * The root admin password
   */
  rootPassword?: string;

  /**
   * The root admin custom permissions
   */
  rootCustomPermissions?: string[];

  /**
   * The salt used to sign JWT tokens
   */
  jwtSecretSalt?: string;

  /**
   * The identity provider configuration
   */
  identityProvider?: IdentityProvider;

  /**
   * The Kottster API token for the appen.
   * If not provided, some features that require server-side requests to Kottster API will not work (e.g. sql query generation, AI features, etc.)
   */
  kottsterApiToken?: string;

  /** 
   * Custom validation middleware
   * @description This middleware will be called after the JWT token is validated. You can use it to perform additional checks or modify the request object.
   * @example https://kottster.app/docs/security/authentication#custom-validation-middleware 
   */
  postAuthMiddleware?: PostAuthMiddleware;

  /** Enable read-only mode */
  __readOnlyMode?: boolean;

  /** Custom token validation function */
  __ensureValidToken?: (request: Request) => Promise<EnsureValidTokenResponse>;
}

interface EnsureValidTokenResponse {
  isTokenValid: boolean;
  user: IdentityProviderUserWithRoles | null;
  invalidTokenErrorMessage?: string;
}

/**
 * The main app class
 */
export class KottsterApp {
  public readonly appId: string;

  private readonly secretKey: string;
  private readonly kottsterApiToken?: string;

  public readonly usingTsc: boolean;
  public readonly readOnlyMode: boolean = false;
  public readonly stage: Stage = process.env.KOTTSTER_APP_STAGE === Stage.development ? Stage.development : Stage.production;
  public readonly basePath: string = '/';

  // TODO: store registry instead of data sources
  public dataSources: DataSource[] = [];

  public identityProvider: IdentityProvider;
  public exporter: Exporter;

  public schema: AppSchema;
  private customEnsureValidToken?: (request: Request) => Promise<EnsureValidTokenResponse>;
  private postAuthMiddleware?: PostAuthMiddleware;

  public loadedPageConfigs: Page[] = [];

  public loadPageConfigs(): Page[] {
    const isDevelopment = this.stage === Stage.development;
    const fileReader = new FileReader(isDevelopment);
    this.loadedPageConfigs = fileReader.getPageConfigs();

    return this.loadedPageConfigs;
  }

  public extendContext: ExtendAppContextFunction;

  public getSecretKey() {
    return `${this.secretKey}`;
  }

  public getKottsterApiToken() {
    return this.kottsterApiToken;
  }

  constructor(options: KottsterAppOptions) {
    this.appId = options.schema.id ?? '';
    this.secretKey = options.secretKey ?? '';
    this.kottsterApiToken = options.kottsterApiToken;
    this.usingTsc = checkTsUsage(PROJECT_DIR);
    this.schema = (!isSchemaEmpty(options.schema) ? options.schema : schemaPlaceholder) as AppSchema;
    this.customEnsureValidToken = options.__ensureValidToken;
    this.postAuthMiddleware = options.postAuthMiddleware;
    this.readOnlyMode = options.__readOnlyMode ?? false;
    
    // Set base path
    const basePath = options.schema.basePath;
    if (basePath) {
      this.basePath = normalizeAppBasePath(basePath);
    }

    // Set identity provider
    if (!options.identityProvider) {
      throw new Error('Your KottsterApp must be configured with an identity provider. See https://kottster.app/docs/upgrade-to-v3-2 for more details.');
    } else {
      this.identityProvider = options.identityProvider;
      this.identityProvider.setApp(this);
    }

    // Set up exporter
    this.exporter = new Exporter();
  }

  async initialize() {
    await this.identityProvider.initialize();
  }

  /**
   * Load from a data source registry
   * @param registry The data source registry
   */
  public loadFromDataSourceRegistry(registry: DataSourceRegistry<{}>) {
    this.dataSources = Object.values(registry.dataSources);

    this.dataSources.forEach(dataSource => {
      const adapter = dataSource.adapter as DataSourceAdapter;

      if (this) {
        adapter.setApp(this);
        adapter.setData(dataSource);
        adapter.setTablesConfig(dataSource.tablesConfig);
        adapter.connect();
      };
    });
  }

  /**
   * Register a context middleware
   * @param fn The function to extend the context
   */
  public registerContextMiddleware(fn: ExtendAppContextFunction) {
    this.extendContext = fn;
  }

  public async executeAction(action: string, data: any, user?: IdentityProviderUserWithRoles, req?: Request): Promise<any> {
    return await ActionService.getAction(this, action).executeWithCheckings(data, user, req);
  }

  /**
   * Get the middleware for the app
   * @param req The request object
   * @returns The middleware function
   */
  public getInternalApiRoute() {
    return async (req: Request, res: Response, next: NextFunction) => {
      if (req.method === 'GET') {
        next();
        return;
      }

      try {
        const result = await this.handleInternalApiRequest(req);

        if (result) {
          res.setHeader('Content-Type', 'application/json');
          res.status(200).json(result);
          return;
        } else {
          res.status(404).json({ error: 'Not Found' });
          return;
        }
      } catch (error) {
        if (error instanceof HttpException) {
          res.status(error.statusCode).json({
            status: 'error',
            statusCode: error.statusCode,
            message: error.message
          });
          return;
        }

        console.error('Internal API error:', error);
        res.status(500).json({ error: 'Internal Server Error' });
        return;
      }
    }
  }

  public getDownloadRoute() {
    return async (req: Request, res: Response) => {
      try {
        if (req.method !== 'GET') {
          res.status(405).json({ error: 'Method Not Allowed' });
          return;
        }

        const operationId = req.params.operationId;
        if (!operationId) {
          res.status(400).json({ error: 'Bad Request' });
          return;
        }

        const operation = this.exporter.getOperation(operationId);
        const dataSource = this.dataSources.find(ds => ds.name === operation?.dataSourceName);
        if (!operation || !dataSource) {
          res.status(404).json({ error: 'Not Found' });
          return;
        }

        const dataSourceAdapter = dataSource.adapter as DataSourceAdapter | undefined;
        if (!dataSourceAdapter) {
          throw new Error(`Data source adapter for ""${dataSource.name}"" not found`);
        }

        const stream = await dataSourceAdapter.getTableRecordsStream(
          ...operation.parameters
        );

        const filename = `export-${dayjs().format('YYYY-MM-DD-HH-mm-ss')}-${operationId}`;
        const headers = this.exporter.getHeadersByFormat(operation.format, filename);
        Object.entries(headers).forEach(([key, value]) => {
          res.setHeader(key, value);
        });

        switch (operation.format) {
          case 'json': {
            this.exporter.convertToJSON(stream, res);
            break;
          };
          case 'csv': {
            this.exporter.convertToCSV(stream, res);
            break;
          }
          case 'xlsx': {
            this.exporter.convertToXLSX(stream, res);
            break;
          }
          default: {
            throw new Error('Unsupported export format');
          }
        };
      } catch (error) {
        console.error('Export route error:', error);
        if (!res.headersSent) {
          res.status(500).json({ error: 'Export failed' });
        }
      }
    };
  }

  private async handleInternalApiRequest(request: Request): Promise<{
    status: 'success' | 'error';
    result?: any;
    error?: string;
  }> {
    try {
      const { isTokenValid, invalidTokenErrorMessage, user } = await this.ensureValidToken(request);

      const action = request.query.action as keyof InternalApiSchema | undefined;
      const actionData = request.body;

      if (!action) {
        throw new Error('Action not found in request');
      }

      if (!isTokenValid && action && !(['getApp', 'initApp', 'login'] as (keyof InternalApiSchema)[]).includes(action)) {
        throw new UnauthorizedException(`Invalid JWT token: ${invalidTokenErrorMessage}`);
      }

      return {
        status: 'success',
        result: await this.executeAction(action, actionData, user ?? undefined, request),
      };
    } catch (error) {
      // If the error is an instance of HttpException, we can rethrow it
      if (error instanceof HttpException) {
        throw error;
      }

      console.error('Kottster API error:', error);

      return {
        status: 'error',
        error: error.message,
      };
    }
  }

  /**
   * Define a custom controller
   * @param procedures The procedures
   * @returns The express request handler
   */
  public defineCustomController<T extends Record<string, Procedure>>(
    procedures: T
  ): RequestHandler & { procedures: T } {
    const func: RequestHandler = async (req, res) => {
      const { isTokenValid, user, invalidTokenErrorMessage } = await this.ensureValidToken(req);
      if (!isTokenValid || !user) {
        res.status(401).json({ error: `Invalid JWT token: ${invalidTokenErrorMessage}` });
        return;
      }

      const body = await req.body as RpcActionBody<'custom'>;
      const { procedure, procedureInput } = body.input;
      const ctx: ProcedureContext = {
        user: {
          id: user.id,
          username: user.username,
          email: user.email,
          firstName: user.firstName,
          lastName: user.lastName,
          roleIds: user.roleIds,
        },
        req,
      };

      if (procedure in procedures) {
        try {
          const result = await procedures[procedure](procedureInput, ctx);
          res.json({
            status: 'success',
            result,
          });
          return;
        } catch (error) {
          console.error(`Error executing procedure ""${procedure}"":`, error);
          res.status(500).json({
            status: 'error',
            error: error.message,
          });
          return;
        }
      }

      res.status(404).json({ error: `Procedure ""${procedure}"" not found` });
      return;
    };

    // Attach the procedures to the function for later reference
    (func as any).procedures = procedures;

    return func as RequestHandler & { procedures: T };
  }

  /**
   * Define a dashboard controller
   * @param dashboardPageConfig The dashboard page config
   * @returns The express request handler
   */
  public defineDashboardController(partialDashboardPageConfig: PartialDashboardPageConfig) {
    const func: RequestHandler = async (req, res) => {
      const { isTokenValid, user, invalidTokenErrorMessage } = await this.ensureValidToken(req);
      if (!isTokenValid || !user) {
        res.status(401).json({ error: `Invalid JWT token: ${invalidTokenErrorMessage}` });
        return;
      }

      const page = (req as Request & { page?: Page }).page;
      if (!page || page.type !== 'dashboard') {
        res.status(404).json({ error: 'Specified page not found' });
        return;
      }

      // Merge the partial config with the page config
      const dashboardPageConfig: DashboardPageConfig = {
        ...page.config,
        ...partialDashboardPageConfig as Partial<DashboardPageConfig>,
        stats: [
          ...(page.config.stats ?? []),
          ...(partialDashboardPageConfig.stats ?? [])
        ].reduce((acc, stat) => {
          const existingIndex = acc.findIndex(s => s.key === stat.key);
          if (existingIndex >= 0) {
            acc[existingIndex] = { ...acc[existingIndex], ...stat } as DashboardPageConfigStat;
          } else {
            acc.push(stat as DashboardPageConfigStat);
          }
          return acc;
        }, [] as NonNullable<DashboardPageConfig['stats']>),
        cards: [
          ...(page.config.cards ?? []),
          ...(partialDashboardPageConfig.cards ?? [])
        ].reduce((acc, card) => {
          const existingIndex = acc.findIndex(c => c.key === card.key);
          if (existingIndex >= 0) {
            acc[existingIndex] = { ...acc[existingIndex], ...card } as DashboardPageConfigCard;
          } else {
            acc.push(card as DashboardPageConfigCard);
          }
          return acc;
        }, [] as NonNullable<DashboardPageConfig['cards']>)
      };

      try {
        const body = await req.body as RpcActionBody<'dashboard_getCardData' | 'dashboard_getStatData'>;
        let result: any;

        try {
          if (this.stage === Stage.production && !checkUserForRoles(user.id, user.roles, page.allowedRoles, page.allowedRoleIds)) {
            throw new Error('You do not have access to this page');
          }

          if (body.action === 'dashboard_getStatData') {
            const input = body.input as DashboardPageGetStatDataInput;
            const stat = dashboardPageConfig.stats?.find(s => s.key === input.statKey);
            if (!stat) {
              res.status(404).json({ error: `Specified stat ""${input.statKey}"" not found` });
              return;
            }

            if (stat.fetchStrategy === 'rawSqlQuery') {
              if (!stat.dataSource) {
                throw new Error(`Data source for stat not specified`);
              }

              const dataSource = this.dataSources.find(ds => ds.name === stat.dataSource);
              if (!dataSource) {
                throw new Error(`Data source ""${stat.dataSource}"" not found`);
              }

              const dataSourceAdapter = dataSource.adapter as DataSourceAdapter | undefined;
              if (!dataSourceAdapter) {
                throw new Error(`Data source adapter for ""${stat.dataSource}"" not found`);
              }

              result = await dataSourceAdapter.getStatData(input, stat);
            } else if (stat.fetchStrategy === 'customFetch') {
              if (!stat.customDataFetcher) {
                // Fallback to default result if no custom fetcher is provided
                console.warn(`Custom data fetcher for stat ""${stat.key}"" not specified`);
                result = {
                  value: 0,
                  total: 0,
                } as DashboardPageGetStatDataResult;
              } else {
                result = await stat.customDataFetcher(input);
              }
            }
          }
          else if (body.action === 'dashboard_getCardData') {
            const input = body.input as DashboardPageGetCardDataInput;
            const card = dashboardPageConfig.cards?.find(c => c.key === input.cardKey);
            if (!card) {
              res.status(404).json({ error: `Specified card ""${input.cardKey}"" not found` });
              return;
            }

            if (card.fetchStrategy === 'rawSqlQuery') {
              if (!card.dataSource) {
                throw new Error(`Data source for card not specified`);
              }

              const dataSource = this.dataSources.find(ds => ds.name === card.dataSource);
              if (!dataSource) {
                throw new Error(`Data source ""${card.dataSource}"" not found`);
              }

              const dataSourceAdapter = dataSource.adapter as DataSourceAdapter | undefined;
              if (!dataSourceAdapter) {
                throw new Error(`Data source adapter for ""${card.dataSource}"" not found`);
              }

              result = await dataSourceAdapter.getCardData(input, card);
            } else if (card.fetchStrategy === 'customFetch') {
              if (!card.customDataFetcher) {
                // Fallback to default result if no custom fetcher is provided
                console.warn(`Custom data fetcher for card ""${card.key}"" not specified`);
                result = {
                  items: [],
                } as DashboardPageGetCardDataResult;
              } else {
                result = await card.customDataFetcher(input);
              }
            }
          }
        } catch (error) {
          throw new Error(error);
        }

        res.json({
          status: 'success',
          result,
        });
      } catch (error) {
        if (error instanceof Error && error.message === 'Unauthorized') {
          return new Response('Unauthorized', { status: 401 });
        }

        console.error('Error executing dashboard RPC:', error);
        res.status(500).json({
          status: 'error',
          error: error.message,
        });
        return;
      }
    }

    return func;
  }

  /**
   * Define a table controller
   * @param dataSource The data source
   * @param pageSettings The page settings
   * @returns The express request handler
   */
  public defineTableController<T extends Record<string, Procedure>>(
    partialTablePageConfig: PartialTablePageConfig,
    procedures?: T
  ): RequestHandler & { procedures: T } {
    const func: RequestHandler = async (req, res, next) => {
      const { isTokenValid, user, invalidTokenErrorMessage } = await this.ensureValidToken(req);
      if (!isTokenValid || !user) {
        res.status(401).json({ error: `Invalid JWT token: ${invalidTokenErrorMessage}` });
        return;
      }

      const page = (req as Request & { page?: Page }).page;
      if (!page || page.type !== 'table') {
        res.status(404).json({ error: 'Specified page not found' });
        return;
      }

      // Merge the partial config with the page config
      const tablePageConfig: TablePageConfig = {
        ...page.config,
        ...partialTablePageConfig as Partial<TablePageConfig>,
        nested: {
          ...page.config.nested,
          ...Object.keys(partialTablePageConfig.nested || {}).reduce((acc, key) => {
            const tablePageNestedTableKey = transformStringToTablePageNestedTableKey(key);
            acc[key] = {
              // We need to pass these required properties for nested table config
              table: tablePageNestedTableKey[tablePageNestedTableKey.length - 1]?.table,
              fetchStrategy: 'databaseTable',

              ...page.config.nested?.[key],
              ...partialTablePageConfig.nested?.[key] as Partial<TablePageConfig>,
            };
            return acc;
          }, {} as Record<string, TablePageConfig>)
        }
      };


      try {
        // Check if specified data source exists
        const dataSource = this.dataSources.find(ds => ds.name === tablePageConfig.dataSource);
        if (!dataSource && (tablePageConfig.fetchStrategy === 'databaseTable' || tablePageConfig.fetchStrategy === 'rawSqlQuery')) {
          throw new Error(`Data source ""${tablePageConfig.dataSource}"" not found`);
        }

        const body = await req.body as RpcActionBody<'table_getRecords' | 'table_initiateRecordsExport' | 'table_getRecord' | 'table_createRecord' | 'table_updateRecord' | 'table_deleteRecord' | 'custom'>;
        const action = body.action;
        
        // TODO: add typeing for result
        let result: any;

        // If the request is a custom one, handle it by the custom controller
        if (action === 'custom') {
          return this.defineCustomController(procedures as T)(req, res, next);
        }

        try {
          const dataSourceAdapter = dataSource?.adapter as DataSourceAdapter | undefined;
          const databaseSchema = dataSourceAdapter ? await dataSourceAdapter.getDatabaseSchema() : undefined;

          if (this.stage === Stage.production && !checkUserForRoles(user.id, user.roles, page.allowedRoles, page.allowedRoleIds)) {
            throw new Error('You do not have access to this page');
          }

          // If the table select action is used and fetch strategy is 'customFetch', we need to execute the custom query right away
          if (body.action === 'table_getRecords' && tablePageConfig.fetchStrategy === 'customFetch') {
            result = tablePageConfig.customDataFetcher ? await tablePageConfig.customDataFetcher(body.input as TablePageCustomDataFetcherInput) : {
              records: [],
            } as TablePageGetRecordsResult;
          } else {
            if (!dataSource) {
              throw new Error(`Data source ""${tablePageConfig.dataSource}"" not found`);
            }
            if (!dataSourceAdapter) {
              throw new Error(`Data source adapter for ""${tablePageConfig.dataSource}"" not found`);
            }
            if (!databaseSchema) {
              throw new Error(`Database schema for ""${tablePageConfig.dataSource}"" not found`);
            }

            if (body.action === 'table_getRecords') {
              result = await dataSourceAdapter?.getTableRecords(tablePageConfig, body.input as TablePageGetRecordsInput, databaseSchema);
            } else if (body.action === 'table_initiateRecordsExport') {
              const operationId = this.exporter.createOperation({
                parameters: [
                  tablePageConfig, body.input as TablePageGetRecordsInput, databaseSchema,
                ],
                dataSourceName: dataSource.name,
                format: (body.input as TablePageInitiateRecordsExportInput).format,
              });
              result = {
                operationId
              } as TablePageInitiateRecordsExportResult;
            } else if (body.action === 'table_getRecord') {
              result = await dataSourceAdapter.getOneTableRecord(tablePageConfig, body.input as TablePageGetRecordInput, databaseSchema);
            } else if (body.action === 'table_createRecord') {
              if (this.stage === Stage.production && !checkUserForRoles(user.id, user.roles, tablePageConfig.allowedRolesToInsert, tablePageConfig.allowedRoleIdsToInsert)) {
                throw new Error('You do not have permission to create records in this table');
              }

              result = await dataSourceAdapter.insertTableRecord(tablePageConfig, body.input as TablePageCreateRecordInput, databaseSchema);
            } else if (body.action === 'table_updateRecord') {
              if (this.stage === Stage.production && !checkUserForRoles(user.id, user.roles, tablePageConfig.allowedRolesToUpdate, tablePageConfig.allowedRoleIdsToUpdate)) {
                throw new Error('You do not have permission to update records in this table');
              }

              result = await dataSourceAdapter.updateTableRecords(tablePageConfig, body.input as TablePageUpdateRecordInput, databaseSchema);
            } else if (body.action === 'table_deleteRecord') {
              if (this.stage === Stage.production && !checkUserForRoles(user.id, user.roles, tablePageConfig.allowedRolesToDelete, tablePageConfig.allowedRoleIdsToDelete)) {
                throw new Error('You do not have permission to delete records in this table');
              }

              result = await dataSourceAdapter.deleteTableRecords(tablePageConfig, body.input as TablePageDeleteRecordInput, databaseSchema);
            };
          };
        } catch (error) {
          throw new Error(error);
        }

        res.json({
          status: 'success',
          result,
        });
      } catch (error) {
        if (error instanceof Error && error.message === 'Unauthorized') {
          return new Response('Unauthorized', { status: 401 });
        }

        console.error('Error executing table RPC:', error);
        res.status(500).json({
          status: 'error',
          error: error.message,
        });
        return;
      }
    };

    // Attach the procedures to the function for later reference
    (func as any).procedures = procedures;

    return func as RequestHandler & { procedures: T };
  };

  public createRequestWithPageDataMiddleware(pageConfig: Page): RequestHandler {
    const handler: RequestHandler = (req, res, next) => {
      (req as Request & { page?: Page }).page = pageConfig;

      next();
    };

    return handler;
  }

  private async ensureValidToken(request: Request): Promise<EnsureValidTokenResponse> {
    try {
      // If a custom token validation function is provided, use it
      if (this.customEnsureValidToken) {
        return this.customEnsureValidToken(request);
      }

      let token = request.get('authorization')?.replace('Bearer ', '');
      if (!token) {
        const cookieHeader = request.get('Cookie');
        const cookieData = parseCookie(cookieHeader ?? '');
        token = cookieData.jwtToken;
      }
      if (!token) {
        return {
          isTokenValid: false,
          user: null,
          invalidTokenErrorMessage: 'Invalid JWT token: token not passed'
        };
      }

      const user = await this.identityProvider.verifyTokenAndGetUser(token);
      const userRoles = await this.identityProvider.getUserRoles(user.id);
      const extendedUser: IdentityProviderUserWithRoles = {
        ...user,
        roles: userRoles,
      };

      // If a post-auth middleware is provided, call it
      if (this.postAuthMiddleware) {
        await this.postAuthMiddleware(extendedUser, request);
      }

      return {
        isTokenValid: true,
        user: extendedUser,
      };
    } catch (error) {
      return {
        isTokenValid: false,
        user: null,
        invalidTokenErrorMessage: error.message",0
"import { IdentityProviderUser, IdentityProviderRole, IdentityProviderUserPermission, ROOT_USER_ID, ClientIdentityProviderUser, IdentityProviderLoginAttempt, generateRandomString, Stage, IdentityProviderUserWithRoles, ClientIdentityProviderUserWithRoles } from ""@kottster/common"";
import crypto from 'crypto';
import bcrypt from 'bcryptjs';
import { SignJWT, jwtVerify } from 'jose';
import { KottsterApp } from ""./app"";
import knex, { Knex } from ""knex"";

/**
 * Supported hashing algorithms
 */
export enum HashAlgorithm {
  bcrypt = 'bcrypt',
  sha256 = 'sha256',
}

/**
 * JWT payload interface
 */
export interface JwtPayload {
  id: IdentityProviderUser['id'];
  check: string;
  iat?: number;
  exp?: number;
}

export enum IdentityProviderStrategyType {
  sqlite = 'sqlite',
}

export interface IdentityProviderOptions {
  fileName: string;
  passwordHashAlgorithm: keyof typeof HashAlgorithm;
  jwtSecretSalt?: string;
  rootUsername?: string;
  rootPassword?: string;
  rootCustomPermissions?: string[];
}

/**
 * The identity provider
 */
export class IdentityProvider {
  private app: KottsterApp;
  
  private jwtSecretSalt?: string;
  private passwordHashAlgorithm: keyof typeof HashAlgorithm;
  private rootUserUsername?: string;
  private rootUserPassword?: string;
  private rootUserSalt?: string;
  private rootCustomPermissions: string[] = [];

  private db: Knex;

  constructor({ 
    fileName,
    jwtSecretSalt,
    passwordHashAlgorithm = HashAlgorithm.bcrypt,
    rootUsername,
    rootPassword,
    rootCustomPermissions,
  }: IdentityProviderOptions) {
    this.jwtSecretSalt = jwtSecretSalt;
    this.passwordHashAlgorithm = passwordHashAlgorithm;
    this.rootUserUsername = rootUsername;
    this.rootUserPassword = rootPassword;
    this.rootCustomPermissions = rootCustomPermissions || [];

    this.db = knex({
      client: 'better-sqlite3',
      connection: {
        filename: fileName
      },
      useNullAsDefault: true
    });
  }

  /**
   * Prepare a user object for sending to the client by removing sensitive fields
   * @param user - The user object to prepare
   * @returns The prepared user object
   */
  public prepareUserForClient<T extends IdentityProviderUser | IdentityProviderUserWithRoles>(
    user: T
  ): T extends IdentityProviderUserWithRoles 
    ? ClientIdentityProviderUserWithRoles 
    : ClientIdentityProviderUser {
    const sanitized = { ...user };
    
    sanitized.passwordHash = '';
    sanitized.twoFactorSecret = undefined;
    sanitized.jwtTokenCheck = undefined;

    if ('roles' in sanitized && Array.isArray(sanitized.roles)) {
      sanitized.roles = sanitized.roles.map(role => this.app.identityProvider.prepareRoleForClient(role));
    }

    return sanitized as any;
  }

  /**
   * Prepare a role object for sending to the client by removing sensitive fields
   * @param role - The role object to prepare
   * @returns The prepared role object
   */
  public prepareRoleForClient(role: IdentityProviderRole): IdentityProviderRole {
    return role; 
  }

  get jwtSecret(): string | undefined {
    const appId = this.app.appId;
    const secretKey = this.app ? this.app.getSecretKey() : '';

    return `${appId}${secretKey}${this.jwtSecretSalt || ''}`;
  }

  setApp(app: KottsterApp): void {
    this.app = app;
  }

  recordLoginAttempt(attempt: Omit<IdentityProviderLoginAttempt, ""id"" | ""attemptedAt"">): Promise<void> {
    return this.createdLoginAttempt(attempt);
  }

  getRootUserSalt(): string {
    if (this.rootUserSalt) {
      return this.rootUserSalt;
    }

    // Generate a random salt for the root user but only for production
    const salt = this.app.stage === Stage.development ? '' : generateRandomString(24);

    this.rootUserSalt = salt;
    return salt;
  }

  async updateRole(roleId: IdentityProviderRole['id'], role: Partial<IdentityProviderRole>): Promise<IdentityProviderRole> {
    const existingRole = await this.getRoleBy('id', roleId);
    if (!existingRole) {
      throw new Error(`Role with ID ""${roleId}"" not found`);
    }

    const roleData: any = {};
    if (role.name !== undefined) roleData.name = role.name;
    if (role.permissions !== undefined) roleData.permissions = JSON.stringify(role.permissions);
    roleData.updated_at = this.db.fn.now();
    await this.db('roles').where({ id: roleId }).update(roleData);

    const updatedRole = await this.getRoleBy('id', roleId);
    if (!updatedRole) {
      throw new Error(`Failed to update role with ID ""${roleId}""`);
    }

    return updatedRole;
  }

  async deleteRole(roleId: IdentityProviderRole['id']): Promise<void> {
    const existingRole = await this.getRoleBy('id', roleId);
    if (!existingRole) {
      throw new Error(`Role with ID ""${roleId}"" not found`);
    }

    await this.db('roles').where({ id: roleId }).delete();
  }

  async createUser(user: Omit<IdentityProviderUser, 'id' | 'passwordHash'>, password: string): Promise<IdentityProviderUser> {
    if (user.username && await this.getUserBy('username', user.username)) {
      throw new Error(`Username ""${user.username}"" is already taken`);
    }
    if (user.email && await this.getUserBy('email', user.email)) {
      throw new Error(`Email ""${user.email}"" is already taken`);
    }

    const passwordHash = password && await this.hashPassword(password);

    const finalData: any = {
      username: user.username,
      email: user.email,
      first_name: user.firstName,
      last_name: user.lastName,
      password_hash: passwordHash,
      avatar_url: user.avatarUrl,
      temporary_password: user.temporaryPassword,
      password_reset_token: user.passwordResetToken,
      two_factor_secret: user.twoFactorSecret,
      last_login_at: user.lastLoginAt,
      jwt_token_check: user.jwtTokenCheck,
      settings: user.settings ? JSON.stringify(user.settings) : null
    };
    
    const [userId] = await this.db('users').insert(finalData);
    
    if (user.roleIds && user.roleIds.length > 0) {
      const userRoles = user.roleIds.map(roleId => ({ user_id: userId, role_id: roleId }));
      await this.db('user_roles').insert(userRoles);
    }

    const createdUser = await this.getUserBy('id', userId);
    if (!createdUser) {
      throw new Error('Failed to create user');
    }

    return createdUser;
  }

  async updateUser(userId: IdentityProviderUser['id'], data: Partial<IdentityProviderUser>): Promise<IdentityProviderUser> {
    const existingUser = await this.getUserBy('id', userId);
    if (!existingUser) {
      throw new Error(`User with ID ""${userId}"" not found`);
    }

    if (data.username) {
      const otherUserWithSameUsername = await this.getUserWhere(q => q.where({ username: data.username }).whereNot({ id: existingUser.id }));
      if (otherUserWithSameUsername) {
        throw new Error(`Username ""${data.username}"" is already taken`);
      }
    }
    if (data.email) {
      const otherUserWithSameEmail = await this.getUserWhere(q => q.where({ email: data.email }).whereNot({ id: existingUser.id }));
      if (otherUserWithSameEmail) {
        throw new Error(`Email ""${data.email}"" is already taken`);
      }
    }

    if (Object.keys(data).length > 0 || data.settings !== undefined) {
      const finalData: any = {};
      if (data.username !== undefined) finalData.username = data.username;
      if (data.email !== undefined) finalData.email = data.email;
      if (data.firstName !== undefined) finalData.first_name = data.firstName;
      if (data.lastName !== undefined) finalData.last_name = data.lastName;
      if (data.avatarUrl !== undefined) finalData.avatar_url = data.avatarUrl;
      if (data.temporaryPassword !== undefined) finalData.temporary_password = data.temporaryPassword;
      if (data.passwordResetToken !== undefined) finalData.password_reset_token = data.passwordResetToken;
      if (data.twoFactorSecret !== undefined) finalData.two_factor_secret = data.twoFactorSecret;
      if (data.lastLoginAt !== undefined) finalData.last_login_at = data.lastLoginAt;
      if (data.jwtTokenCheck !== undefined) finalData.jwt_token_check = data.jwtTokenCheck;
      if (data.settings !== undefined) finalData.settings = JSON.stringify(data.settings);

      finalData.updated_at = this.db.fn.now();

      await this.db('users').where({ id: userId }).update(finalData);
    }

    if (data.roleIds !== undefined) {
      await this.db('user_roles').where({ user_id: userId }).delete();
      if (data.roleIds.length > 0) {
        const userRoles = data.roleIds.map(roleId => ({ user_id: userId, role_id: roleId }));
        await this.db('user_roles').insert(userRoles);
      }
    }

    const updatedUser = await this.getUserBy('id', userId);
    if (!updatedUser) {
      throw new Error(`Failed to update user with ID ""${userId}""`);
    }

    return updatedUser;
  }

  async updateUserPassword(userId: IdentityProviderUser['id'], newPassword: string, temporaryPassword?: boolean): Promise<void> {
    const existingUser = await this.getUserBy('id', userId);
    if (!existingUser) {
      throw new Error(`User with ID ""${userId}"" not found`);
    }

    const passwordHash = await this.hashPassword(newPassword);
    await this.db('users').where({ id: userId }).update({ password_hash: passwordHash, temporary_password: temporaryPassword ?? undefined });
  }

  async deleteUser(userId: IdentityProviderUser['id']): Promise<void> {
    if (this.isUserRoot(userId)) {
      throw new Error('Cannot delete root user');
    }

    const existingUser = await this.getUserBy('id', userId);
    if (!existingUser) {
      throw new Error(`User with ID ""${userId}"" not found`);
    }

    await this.db('users').where({ id: userId }).delete();
  }

  async getUserPermissions(userId: number | string): Promise<string[]> {
    if (this.isUserRoot(userId)) {
      return [
        ...Object.keys(IdentityProviderUserPermission) as string[],
        ...this.rootCustomPermissions,
      ];
    }

    const user = await this.getUserBy('id', userId);
    if (!user) return [];
    
    const userRoles = await this.getRolesByIds(user.roleIds || []);
    const permissions: string[] = [];

    userRoles.forEach(role => {
      if (role.permissions) {
        role.permissions.forEach(permission => {
          if (!permissions.includes(permission)) {
            permissions.push(permission);
          }
        });
      }
    });

    return permissions;
  }

  /**
   * Hash a password using the configured algorithm
   */
  async hashPassword(password: string): Promise<string> {
    switch (this.passwordHashAlgorithm) {
      case HashAlgorithm.bcrypt:
        return bcrypt.hash(password, 10);
      
      case HashAlgorithm.sha256:
        return crypto.createHash('sha256').update(password).digest('hex');
      
      default:
        throw new Error(`Unsupported hash algorithm: ${this.passwordHashAlgorithm}`);
    }
  }

  /**
   * Verify a password against a hash
   */
  async verifyPassword(password: string, hash: string): Promise<boolean> {
    switch (this.passwordHashAlgorithm) {
      case HashAlgorithm.bcrypt:
        return bcrypt.compare(password, hash);
      case HashAlgorithm.sha256: {
        const testHash = crypto.createHash('sha256').update(password).digest('hex');
        return testHash === hash;
      };
      default:
        throw new Error(`Unsupported hash algorithm: ${this.passwordHashAlgorithm}`);
    }
  }

  public getRootUserByUsername(username: string): IdentityProviderUser | undefined {
    if (!this.rootUserUsername || !this.rootUserPassword) {
      return undefined;
    }
    if (username !== this.rootUserUsername) {
      return undefined;
    }

    return {
      id: ROOT_USER_ID,
      username: this.rootUserUsername,
      passwordHash: '',
      roleIds: [],
      jwtTokenCheck: this.getRootUserSalt(),
    }
  };

  public getRootUserById(userId: number | string): IdentityProviderUser | undefined {
    if (!this.rootUserUsername || !this.rootUserPassword) {
      return undefined;
    }

    if (userId !== ROOT_USER_ID) {
      return undefined;
    }

    return {
      id: ROOT_USER_ID,
      username: this.rootUserUsername,
      passwordHash: '',
      roleIds: [],
      jwtTokenCheck: this.getRootUserSalt(),
    };
  }

  isUserRoot(userId: number | string): boolean {
    return userId === ROOT_USER_ID;
  }

  async authenticateRootUser(username: string, password: string): Promise<IdentityProviderUser> {
    if (!this.rootUserUsername || !this.rootUserPassword) {
      throw new Error('Root user not configured');
    }
    if (username !== this.rootUserUsername) {
      throw new Error('Invalid username/email or password');
    }

    const isValid = password === this.rootUserPassword;
    if (!isValid) {
      throw new Error('Invalid username/email or password');
    }

    const rootUser = this.getRootUserByUsername(username);
    if (!rootUser) {
      throw new Error('Root user not configured');
    }
    return rootUser;
  }

  /**
   * Authenticate a user by username/email and password
   * @param usernameOrEmail - Username or email to identify the user
   * @param password - Plain text password to check
   * @returns Authenticated user
   */
  async authenticateUser(usernameOrEmail: string, password: string): Promise<IdentityProviderUser> {
    const rootUser = this.getRootUserByUsername(usernameOrEmail);
    if (rootUser) {
      const isValid = await this.verifyPassword(password, this.rootUserPassword!);
      if (!isValid) {
        throw new Error('Invalid username/email or password');
      }

      return { ...rootUser };
    } else {
      const user = await this.getUserBy('username', usernameOrEmail) || await this.getUserBy('email', usernameOrEmail);
      if (!user) {
        throw new Error('Invalid username/email or password');
      }
      if (!user.passwordHash) {
        throw new Error('User has no password set');
      }
      
      const isValid = await this.verifyPassword(password, user.passwordHash);
      if (!isValid) {
        throw new Error('Invalid username/email or password');
      }
      return { ...user };
    }
  }

  /**
   * Generate a JWT token for the root user
   * @param expiresIn - Token expiration in seconds (default: 24h = 86400s)
   * @returns JWT token string
   */
  async generateTokenForRootUser(expiresIn: number = 86400, providedJwtSecret?: string): Promise<string> {
    const payload: JwtPayload = {
      id: ROOT_USER_ID,
      check: this.getRootUserSalt(),
    };

    const secret = new TextEncoder().encode(providedJwtSecret ?? this.jwtSecret);
    
    return await new SignJWT({ ...payload })
      .setProtectedHeader({ alg: 'HS256' })
      .setIssuedAt()
      .setExpirationTime(Math.floor(Date.now() / 1000) + expiresIn)
      .sign(secret);
  }

  /**
   * Generate a JWT token for a user
   * @param usernameOrEmail - Username or email to identify the user
   * @param expiresIn - Token expiration in seconds (default: 24h = 86400s)
   * @returns JWT token string
   */
  async generateToken(userId: number | string, expiresIn: number = 86400): Promise<string> {
    if (!this.jwtSecret) {
      throw new Error('JWT secret not configured');
    }

    const user = await this.getUserBy('id', userId);
    if (!user) {
      throw new Error('User not found');
    }

    let jwtTokenCheck = user.jwtTokenCheck;
    if (!jwtTokenCheck) {
      jwtTokenCheck = crypto.randomBytes(16).toString('hex');
      await this.updateUser(user.id, { jwtTokenCheck });
    }

    const payload: JwtPayload = {
      id: user.id,
      check: jwtTokenCheck,
    };

    const secret = new TextEncoder().encode(`${this.jwtSecret}`);
    
    return await new SignJWT({ ...payload })
      .setProtectedHeader({ alg: 'HS256' })
      .setIssuedAt()
      .setExpirationTime(Math.floor(Date.now() / 1000) + expiresIn)
      .sign(secret);
  }

  /**
   * Verify and decode a JWT token
   * @param token - JWT token to verify
   * @returns Decoded JWT payload or null if invalid
   */
  async verifyToken(token: string): Promise<JwtPayload | null> {
    if (!this.jwtSecret) {
      throw new Error('JWT secret not configured');
    }

    try {
      const secret = new TextEncoder().encode(this.jwtSecret);
      const { payload } = await jwtVerify(token, secret);
      return payload as unknown as JwtPayload;
    } catch (error) {
      return null;
    }
  }

  async verifyTokenAndGetUser(token: string): Promise<IdentityProviderUser> {
    const payload = await this.verifyToken(token);
    if (!payload || !payload.id) {
      throw new Error('Invalid token');
    }

    // If it's the root user, return the root user
    const rootUser = this.getRootUserById(payload.id);
    if (rootUser) {
      if (rootUser.jwtTokenCheck !== payload.check) {
        throw new Error('Invalid token');
      }

      return { ...rootUser };
    }
    
    const user = await this.getUserBy('id', payload.id);
    if (!user) {
      throw new Error('Invalid token');
    }
    if (user.jwtTokenCheck !== payload.check) {
      throw new Error('Invalid token');
    }
    
    return { ...user };
  }

  /**
   * Check if a user has a specific role by role ID
   */
  async userHasRole(userId: number | string, roleId: number | string): Promise<boolean> {
    const isRoot = this.isUserRoot(userId);
    if (isRoot) {
      return true;
    }
    
    const user = await this.getUserBy('id', userId);
    if (!user) return false;
    
    return user.roleIds?.includes(roleId) ?? false;
  }

  async userHasPermissions(userId: number | string, permissions: (keyof typeof IdentityProviderUserPermission | string)[]): Promise<boolean> {
    const isRoot = this.isUserRoot(userId);
    if (isRoot) {
      return true;
    }
    
    const userPermissions = await this.getUserPermissions(userId);
    for (const permission of permissions) {
      if (!userPermissions.includes(permission)) {
        return false;
      }
    }
    return true;
  }

  /**
   * Check if a user has a specific role by role name
   */
  async userHasRoleByName(userId: number | string, roleName: string): Promise<boolean> {
    const user = await this.getUserBy('id', userId);
    if (!user) return false;

    const role = await this.getRoleBy('name', roleName);
    if (!role) return false;
    
    return user.roleIds?.includes(role.id) ?? false;
  }

  /**
   * Get all roles for a specific user
   */
  async getUserRoles(userId: number | string): Promise<IdentityProviderRole[]> {
    const user = await this.getUserBy('id', userId);
    if (!user || !user.roleIds) return [];

    const roles = await this.getRolesByIds(user.roleIds);
    return roles;
  }

  public async initialize(): Promise<void> {
    await this.ensureTablesExist();
  }

  private async ensureTablesExist(): Promise<void> {
    const usersTableExists = await this.db.schema.hasTable('users');
    if (!usersTableExists) {
      await this.createUsersTable();
    }

    const rolesTableExists = await this.db.schema.hasTable('roles');
    if (!rolesTableExists) {
      await this.createRolesTable();
    }

    const userRolesTableExists = await this.db.schema.hasTable('user_roles');
    if (!userRolesTableExists) {
      await this.createUserRolesTable();
    }

    const loginAttemptsTableExists = await this.db.schema.hasTable('login_attempts');
    if (!loginAttemptsTableExists) {
      await this.createLoginAttemptsTable();
    }

    const schemaVersionsTableExists = await this.db.schema.hasTable('schema_versions');
    if (!schemaVersionsTableExists) {
      await this.createSchemaVersionsTable();
    }
  }

  private async createUsersTable(): Promise<void> {
    await this.db.schema.createTable('users', (table) => {
      table.increments('id').primary();
      table.string('username').nullable().index();
      table.string('email').nullable().index();
      table.string('first_name').nullable();
      table.string('last_name').nullable();
      table.string('password_hash').nullable();
      table.string('avatar_url').nullable();
      table.boolean('temporary_password').nullable().defaultTo(false);
      table.string('password_reset_token').nullable();
      table.string('two_factor_secret').nullable();
      table.timestamp('last_login_at').nullable();
      table.string('jwt_token_check').nullable();
      table.json('settings').nullable();
      table.timestamps(true, true);
    });
  }

  private async createRolesTable(): Promise<void> {
    await this.db.schema.createTable('roles', (table) => {
      table.increments('id').primary();
      table.string('name').nullable();
      table.json('permissions').nullable();
      table.timestamps(true, true);
    });
  }

  private async createUserRolesTable(): Promise<void> {
    await this.db.schema.createTable('user_roles', (table) => {
      table.integer('user_id').references('id').inTable('users').onDelete('CASCADE');
      table.integer('role_id').references('id').inTable('roles').onDelete('CASCADE');
      table.primary(['user_id', 'role_id']);
    });
  }

  private async createLoginAttemptsTable(): Promise<void> {
    await this.db.schema.createTable('login_attempts', (table) => {
      table.increments('id').primary();
      table.string('ip_address').nullable().index();
      table.string('identifier').nullable().index();
      table.integer('user_id').nullable().references('id').inTable('users').onDelete('SET NULL');
      table.boolean('success').nullable().defaultTo(false);
      table.string('failure_reason').nullable();
      table.string('user_agent').nullable();
      table.timestamp('attempted_at').defaultTo(this.db.fn.now()).index();
    });
  }

  private async createSchemaVersionsTable(): Promise<void> {
    await this.db.schema.createTable('schema_versions', (table) => {
      table.string('table_name').primary();
      table.integer('version').notNullable();
      table.timestamps(true, true);
    });

    // Insert initial version records for all tables
    await this.db('schema_versions').insert([
      { table_name: 'users', version: 1 },
      { table_name: 'roles', version: 1 },
      { table_name: 'user_roles', version: 1 },
      { table_name: 'login_attempts', version: 1 },
      { table_name: 'schema_versions', version: 1 }
    ]);
  }

  async getUserBy(field: 'id' | 'email' | 'username', value: string | number): Promise<IdentityProviderUser | null> {
    const user = await this.db('users').where({ [field]: value }).first();
    if (!user) return null;
    
    const roleIds = await this.db('user_roles')
      .where({ user_id: user.id })
      .pluck('role_id');
    
    return this.mapUserFromDb(user, roleIds);
  }

  async getUserWhere(where: Record<string, any> | ((qb: Knex.QueryBuilder) => void)): Promise<IdentityProviderUser | null> {
    const query = this.db('users');
    
    if (typeof where === 'function') {
      where(query);
    } else {
      query.where(where);
    }
    
    const user = await query.first();
    if (!user) return null;
    
    const roleIds = await this.db('user_roles')
      .where({ user_id: user.id })
      .pluck('role_id');
    
    return this.mapUserFromDb(user, roleIds);
  }

  async getUsers(): Promise<IdentityProviderUser[]> {
    const users = await this.db('users').select().orderBy('id', 'desc');
    
    const usersWithRoles = await Promise.all(
      users.map(async (user) => {
        const roleIds = await this.db('user_roles')
          .where({ user_id: user.id })
          .pluck('role_id');
        return this.mapUserFromDb(user, roleIds);
      })
    );
    
    return usersWithRoles;
  }

  private mapUserFromDb(dbUser: any, roleIds: any[]): IdentityProviderUser {
    return {
      id: dbUser.id,
      username: dbUser.username,
      email: dbUser.email,
      firstName: dbUser.first_name,
      lastName: dbUser.last_name,
      passwordHash: dbUser.password_hash,
      avatarUrl: dbUser.avatar_url,
      temporaryPassword: dbUser.temporary_password,
      passwordResetToken: dbUser.password_reset_token,
      twoFactorSecret: dbUser.two_factor_secret,
      lastLoginAt: dbUser.last_login_at,
      jwtTokenCheck: dbUser.jwt_token_check,
      settings: dbUser.settings ? JSON.parse(dbUser.settings) : undefined,
      createdAt: dbUser.created_at,
      updatedAt: dbUser.updated_at,
      roleIds
    };
  }

  // Role CRUD methods
  async createRole(role: Omit<IdentityProviderRole, 'id'>): Promise<IdentityProviderRole> {
    if (role.name && await this.getRoleBy('name', role.name)) {
      throw new Error(`Name ""${role.name}"" is already taken`);
    }
    
    const roleData: any = {
      name: role.name,
      permissions: role.permissions ? JSON.stringify(role.permissions) : null,
    };
    
    const [roleId] = await this.db('roles').insert(roleData);",0
"import { IdentityProviderUserPermission, IdentityProviderUserWithRoles, Stage } from ""@kottster/common"";
import { KottsterApp } from ""../core/app"";
import { Request } from ""express"";

/**
 * The base class for actions
 * @abstract
 */
export abstract class Action {
  constructor(protected readonly app: KottsterApp) {}

  protected requiredPermissions: (keyof typeof IdentityProviderUserPermission)[] = [];

  public async executeWithCheckings(data: unknown, user?: IdentityProviderUserWithRoles, req?: Request): Promise<unknown> {
    // Ensure that user has the required permissions
    if (this.requiredPermissions.length > 0) {
      if (!user) {
        throw new Error(""This action requires authentication."");
      }

      for (const permission of this.requiredPermissions) {
        const hasPermission = await this.app.identityProvider.userHasPermissions(user.id, [permission]);

        if (!hasPermission) {
          throw new Error(`This action requires the '${permission}' permission.`);
        }
      }
    }

    return this.execute(data, user, req);
  };

  protected abstract execute(data: unknown, user?: IdentityProviderUserWithRoles, req?: Request): Promise<unknown>;
}

/**
 * The base class for developer actions
 * @abstract
 */",0
"    }

    const tableAlias = 'main';
    let query = this.client(table).from({ [tableAlias]: table });
    let countQuery = options.includeCount ? this.client(table).from({ [tableAlias]: table }) : null;

    // Filter by view
    if (input.viewKey) {
      const view = tablePageConfig.views?.find(v => v.key === input.viewKey);
      if (view) {
        if (view.filteringStrategy === 'filter') {
          if (!view.filterItems || view.filterItems.length === 0) {
            throw new Error('Filter items not provided for the selected view');
          }
          this.applyFilters(query, view.filterItems, tableSchema.name, databaseSchema);
          if (countQuery) {
            this.applyFilters(countQuery, view.filterItems, tableSchema.name, databaseSchema);
          }
        }
        if (view.filteringStrategy === 'sqlWhereExpression') {
          if (!view.sqlWhereExpression) {
            throw new Error('SQL expression WHERE clause not provided for the selected view');
          }
          query.whereRaw(`(${view.sqlWhereExpression})`);
          countQuery?.whereRaw(`(${view.sqlWhereExpression})`);
        }
      }
    }

    // Foreign record filter
    if (input.getByForeignRecord) {
      const { relationship, recordPrimaryKeyValue } = input.getByForeignRecord;
      if (relationship.relation === 'oneToMany' && relationship.targetTableForeignKeyColumn) {
        query.where(relationship.targetTableForeignKeyColumn, recordPrimaryKeyValue);
        countQuery?.where(relationship.targetTableForeignKeyColumn, recordPrimaryKeyValue);",0
export const VERSION = '3.3.2';,0
"const { describe, it } = require('node:test')
const assert = require('node:assert/strict')
const context = require('../../test-helpers/context')

describe('ctx.back([alt])', () => {
  it('should redirect to Referrer', () => {
    const ctx = context({ url: '/', headers: { host: 'example.com' } })
    ctx.req.headers.referrer = '/login'
    ctx.back()
    assert.equal(ctx.response.header.location, '/login')
  })

  it('should redirect to the same origin referrer', () => {
    const ctx = context()
    ctx.req.headers.host = 'example.com'
    ctx.req.headers.referrer = 'https://example.com/login'
    ctx.back()
    assert.equal(ctx.response.header.location, 'https://example.com/login')
  })

  it('should redirect to root if the same origin referrer is not present', () => {
    const ctx = context()
    ctx.req.headers.host = 'example.com'
    ctx.req.headers.referrer = 'https://other.com/login'
    ctx.back()
    assert.equal(ctx.response.header.location, '/')
  })

  it('should redirect to Referer to a relative path', () => {
    const ctx = context({ url: '/', headers: { host: 'example.com' } })
    ctx.req.headers.referer = '/login'
    ctx.back()
    assert.equal(ctx.response.header.location, '/login')
  })

  it('should redirect to Referer to a same origin url', () => {
    const ctx = context({ url: '/', headers: { host: 'example.com', referer: 'https://example.com/login' } })
    ctx.back()
    assert.equal(ctx.response.header.location, 'https://example.com/login')
  })

  it('should default to alt', () => {
    const ctx = context()
    ctx.back('/index.html')
    assert.equal(ctx.response.header.location, '/index.html')
  })

  it('should default redirect to /', () => {
    const ctx = context()
    ctx.back()
    assert.equal(ctx.response.header.location, '/')
  })

  it('should fix Trailing Double-Slash security issue', () => {
    const ctx = context({ url: '/', headers: { host: 'example.com' } })
    ctx.req.headers.referrer = '//evil.com/login/'
    ctx.back()
    assert.equal(ctx.response.header.location, '/')

    ctx.back('/home')
    assert.equal(ctx.response.header.location, '/home')
  })
})",0
"   * @api public
   */

  back (alt) {
    const referrer = this.ctx.get('Referrer')
    if (referrer) {
      // referrer is an absolute URL, check if it's the same origin
      const url = new URL(referrer, this.ctx.href)
      if (url.host === this.ctx.host) {
        this.redirect(referrer)
        return
      }",0
"  filePath: string,
): boolean {
  const { fs } = config.server

  if (!fs.strict) return true

  // NOTE: `fs.readFile('/foo.png/')` tries to load `'/foo.png'`
  // so we should check the path without trailing slash
  const filePathWithoutTrailingSlash = filePath.endsWith('/')
    ? filePath.slice(0, -1)
    : filePath
  if (config.fsDenyGlob(filePathWithoutTrailingSlash)) return false

  if (config.safeModulePaths.has(filePath)) return true

  if (fs.allow.some((uri) => isFileInTargetPath(uri, filePath))) return true

  return false",0
"  expect,
  test,
} from 'vitest'
import type { Page } from 'playwright-chromium'
import WebSocket from 'ws'
import testJSON from '../safe.json'
import {
  browser,
  isServe,
  isWindows,
  page,
  viteServer,
  viteTestUrl,
} from '~utils'

const __dirname = path.dirname(fileURLToPath(import.meta.url))

const getViteTestIndexHtmlUrl = () => {
  const srcPrefix = viteTestUrl.endsWith('/') ? '' : '/'
  // NOTE: viteTestUrl is set lazily
  return viteTestUrl + srcPrefix + 'src/'
}

const stringified = JSON.stringify(testJSON)

describe.runIf(isServe)('main', () => {
  beforeAll(async () => {
    await page.goto(getViteTestIndexHtmlUrl())
  })

  test('default import', async () => {
    await expect.poll(() => page.textContent('.full')).toBe(stringified)
  })

  test('named import', async () => {
    await expect.poll(() => page.textContent('.named')).toBe(testJSON.msg)
  })

  test('virtual svg module', async () => {
    await expect.poll(() => page.textContent('.virtual-svg')).toMatch('<svg')
  })

  test('safe fetch', async () => {
    await expect.poll(() => page.textContent('.safe-fetch')).toMatch('KEY=safe')
    await expect.poll(() => page.textContent('.safe-fetch-status')).toBe('200')
  })

  test('safe fetch with query', async () => {
    await expect
      .poll(() => page.textContent('.safe-fetch-query'))
      .toMatch('KEY=safe')
    await expect
      .poll(() => page.textContent('.safe-fetch-query-status'))
      .toBe('200')
  })

  test('safe fetch with special characters', async () => {
    await expect
      .poll(() => page.textContent('.safe-fetch-subdir-special-characters'))
      .toMatch('KEY=safe')
    await expect
      .poll(() =>
        page.textContent('.safe-fetch-subdir-special-characters-status'),
      )
      .toBe('200')
  })

  test('unsafe fetch', async () => {
    await expect
      .poll(() => page.textContent('.unsafe-fetch'))
      .toMatch('403 Restricted')
    await expect
      .poll(() => page.textContent('.unsafe-fetch-status'))
      .toBe('403')
  })

  test('unsafe HTML fetch', async () => {
    await expect
      .poll(() => page.textContent('.unsafe-fetch-html'))
      .toMatch('403 Restricted')
    await expect
      .poll(() => page.textContent('.unsafe-fetch-html-status'))
      .toBe('403')
  })

  test('unsafe fetch with special characters (#8498)', async () => {
    await expect.poll(() => page.textContent('.unsafe-fetch-8498')).toBe('')
    await expect
      .poll(() => page.textContent('.unsafe-fetch-8498-status'))
      .toBe('404')
  })

  test('unsafe fetch with special characters 2 (#8498)', async () => {
    await expect.poll(() => page.textContent('.unsafe-fetch-8498-2')).toBe('')
    await expect
      .poll(() => page.textContent('.unsafe-fetch-8498-2-status'))
      .toBe('404')
  })

  test('unsafe fetch import inline', async () => {
    await expect
      .poll(() => page.textContent('.unsafe-fetch-import-inline-status'))
      .toBe('403')
  })

  test('unsafe fetch raw query import', async () => {
    await expect
      .poll(() => page.textContent('.unsafe-fetch-raw-query-import-status'))
      .toBe('403')
  })

  test('unsafe fetch ?.svg?import', async () => {
    await expect
      .poll(() => page.textContent('.unsafe-fetch-query-dot-svg-import-status'))
      .toBe('403')
  })

  test('unsafe fetch .svg?import', async () => {
    await expect
      .poll(() => page.textContent('.unsafe-fetch-svg-status'))
      .toBe('403')
  })

  test('safe fs fetch', async () => {
    await expect
      .poll(() => page.textContent('.safe-fs-fetch'))
      .toBe(stringified)
    await expect
      .poll(() => page.textContent('.safe-fs-fetch-status'))
      .toBe('200')
  })

  test('safe fs fetch', async () => {
    await expect
      .poll(() => page.textContent('.safe-fs-fetch-query'))
      .toBe(stringified)
    await expect
      .poll(() => page.textContent('.safe-fs-fetch-query-status'))
      .toBe('200')
  })

  test('safe fs fetch with special characters', async () => {
    await expect
      .poll(() => page.textContent('.safe-fs-fetch-special-characters'))
      .toBe(stringified)
    await expect
      .poll(() => page.textContent('.safe-fs-fetch-special-characters-status'))
      .toBe('200')
  })

  test('unsafe fs fetch', async () => {
    await expect.poll(() => page.textContent('.unsafe-fs-fetch')).toBe('')
    await expect
      .poll(() => page.textContent('.unsafe-fs-fetch-status'))
      .toBe('403')
  })

  test('unsafe fs fetch', async () => {
    await expect.poll(() => page.textContent('.unsafe-fs-fetch-raw')).toBe('')
    await expect
      .poll(() => page.textContent('.unsafe-fs-fetch-raw-status'))
      .toBe('403')
  })

  test('unsafe fs fetch query 1', async () => {
    await expect
      .poll(() => page.textContent('.unsafe-fs-fetch-raw-query1'))
      .toBe('')
    await expect
      .poll(() => page.textContent('.unsafe-fs-fetch-raw-query1-status'))
      .toBe('403')
  })

  test('unsafe fs fetch query 2', async () => {
    await expect
      .poll(() => page.textContent('.unsafe-fs-fetch-raw-query2'))
      .toBe('')
    await expect
      .poll(() => page.textContent('.unsafe-fs-fetch-raw-query2-status'))
      .toBe('403')
  })

  test('unsafe fs fetch with special characters (#8498)', async () => {
    await expect.poll(() => page.textContent('.unsafe-fs-fetch-8498')).toBe('')
    await expect
      .poll(() => page.textContent('.unsafe-fs-fetch-8498-status'))
      .toBe('404')
  })

  test('unsafe fs fetch with special characters 2 (#8498)', async () => {
    await expect
      .poll(() => page.textContent('.unsafe-fs-fetch-8498-2'))
      .toBe('')
    await expect
      .poll(() => page.textContent('.unsafe-fs-fetch-8498-2-status'))
      .toBe('404')
  })

  test('unsafe fs fetch import inline', async () => {
    await expect
      .poll(() => page.textContent('.unsafe-fs-fetch-import-inline-status'))
      .toBe('403')
  })

  test('unsafe fs fetch import inline wasm init', async () => {
    await expect
      .poll(() =>
        page.textContent('.unsafe-fs-fetch-import-inline-wasm-init-status'),
      )
      .toBe('403')
  })

  test('unsafe fs fetch with relative path after query status', async () => {
    await expect
      .poll(() =>
        page.textContent('.unsafe-fs-fetch-relative-path-after-query-status'),
      )
      .toBe('404')
  })

  test('nested entry', async () => {
    await expect.poll(() => page.textContent('.nested-entry')).toBe('foobar')
  })

  test('denied', async () => {
    await expect.poll(() => page.textContent('.unsafe-dotenv')).toBe('403')
  })

  test('denied EnV casing', async () => {
    // It is 403 in case insensitive system, 404 in others
    await expect
      .poll(() => page.textContent('.unsafe-dotEnV-casing'))
      .toStrictEqual(expect.toBeOneOf(['403', '404']))
  })

  test('denied env with ?.svg?.wasm?init', async () => {
    await expect
      .poll(() => page.textContent('.unsafe-dotenv-query-dot-svg-wasm-init'))
      .toBe('403')
  })
})

describe('fetch', () => {
  test('serve with configured headers', async () => {
    const res = await fetch(viteTestUrl + '/src/')
    expect(res.headers.get('x-served-by')).toBe('vite')
  })
})

describe('cross origin', () => {
  const fetchStatusFromPage = async (page: Page, url: string) => {
    return await page.evaluate(async (url: string) => {
      try {
        const res = await globalThis.fetch(url)
        return res.status
      } catch {
        return -1
      }
    }, url)
  }

  const connectWebSocketFromPage = async (page: Page, url: string) => {
    return await page.evaluate(async (url: string) => {
      try {
        const ws = new globalThis.WebSocket(url, ['vite-hmr'])
        await new Promise<void>((resolve, reject) => {
          ws.addEventListener('open', () => {
            resolve()
            ws.close()
          })
          ws.addEventListener('error', () => {
            reject()
          })
        })
        return true
      } catch {
        return false
      }
    }, url)
  }

  const connectWebSocketFromServer = async (
    url: string,
    host: string,
    origin: string | undefined,
  ) => {
    try {
      const ws = new WebSocket(url, ['vite-hmr'], {
        headers: {
          Host: host,
          ...(origin ? { Origin: origin } : undefined),
        },
      })
      await new Promise<void>((resolve, reject) => {
        ws.addEventListener('open', () => {
          resolve()
          ws.close()
        })
        ws.addEventListener('error', () => {
          reject()
        })
      })
      return true
    } catch {
      return false
    }
  }

  describe('allowed for same origin', () => {
    beforeEach(async () => {
      await page.goto(getViteTestIndexHtmlUrl())
    })

    test('fetch HTML file', async () => {
      const status = await fetchStatusFromPage(page, viteTestUrl + '/src/')
      expect(status).toBe(200)
    })

    test.runIf(isServe)('fetch JS file', async () => {
      const status = await fetchStatusFromPage(
        page,
        viteTestUrl + '/src/code.js',
      )
      expect(status).toBe(200)
    })

    test.runIf(isServe)('connect WebSocket with valid token', async () => {
      const token = viteServer.config.webSocketToken
      const result = await connectWebSocketFromPage(
        page,
        `${viteTestUrl}?token=${token}`,
      )
      expect(result).toBe(true)
    })

    test('fetch with allowed hosts', async () => {
      const viteTestUrlUrl = new URL(viteTestUrl)
      const res = await fetch(viteTestUrl + '/src/index.html', {
        headers: { Host: viteTestUrlUrl.host },
      })
      expect(res.status).toBe(200)
    })

    test.runIf(isServe)(
      'connect WebSocket with valid token with allowed hosts',
      async () => {
        const viteTestUrlUrl = new URL(viteTestUrl)
        const token = viteServer.config.webSocketToken
        const result = await connectWebSocketFromServer(
          `${viteTestUrl}?token=${token}`,
          viteTestUrlUrl.host,
          viteTestUrlUrl.origin,
        )
        expect(result).toBe(true)
      },
    )

    test.runIf(isServe)(
      'connect WebSocket without a token without the origin header',
      async () => {
        const viteTestUrlUrl = new URL(viteTestUrl)
        const result = await connectWebSocketFromServer(
          viteTestUrl,
          viteTestUrlUrl.host,
          undefined,
        )
        expect(result).toBe(true)
      },
    )
  })

  describe('denied for different origin', async () => {
    let page2: Page
    beforeEach(async () => {
      page2 = await browser.newPage()
      await page2.goto('http://vite.dev/404')
    })
    afterEach(async () => {
      await page2.close()
    })

    test('fetch HTML file', async () => {
      const status = await fetchStatusFromPage(page2, viteTestUrl + '/src/')
      expect(status).not.toBe(200)
    })

    test.runIf(isServe)('fetch JS file', async () => {
      const status = await fetchStatusFromPage(
        page2,
        viteTestUrl + '/src/code.js',
      )
      expect(status).not.toBe(200)
    })

    test.runIf(isServe)('connect WebSocket without token', async () => {
      const result = await connectWebSocketFromPage(page, viteTestUrl)
      expect(result).toBe(false)

      const result2 = await connectWebSocketFromPage(
        page,
        `${viteTestUrl}?token=`,
      )
      expect(result2).toBe(false)
    })

    test.runIf(isServe)('connect WebSocket with invalid token', async () => {
      const token = viteServer.config.webSocketToken
      const result = await connectWebSocketFromPage(
        page,
        `${viteTestUrl}?token=${'t'.repeat(token.length)}`,
      )
      expect(result).toBe(false)

      const result2 = await connectWebSocketFromPage(
        page,
        `${viteTestUrl}?token=${'t'.repeat(token.length)}t`, // different length
      )
      expect(result2).toBe(false)
    })

    test('fetch with non-allowed hosts', async () => {
      // NOTE: fetch cannot be used here as `fetch` sets the correct `Host` header
      const res = await new Promise<http.IncomingMessage>((resolve, reject) => {
        http
          .get(
            viteTestUrl + '/src/index.html',
            {
              headers: {
                Host: 'vite.dev',
              },
            },
            (res) => {
              resolve(res)
            },
          )
          .on('error', (e) => {
            reject(e)
          })
      })
      expect(res.statusCode).toBe(403)
    })

    test.runIf(isServe)(
      'connect WebSocket with valid token with non-allowed hosts',
      async () => {
        const token = viteServer.config.webSocketToken
        const result = await connectWebSocketFromServer(
          `${viteTestUrl}?token=${token}`,
          'vite.dev',
          'http://vite.dev',
        )
        expect(result).toBe(false)

        const result2 = await connectWebSocketFromServer(
          `${viteTestUrl}?token=${token}`,
          'vite.dev',
          undefined,
        )
        expect(result2).toBe(false)
      },
    )
  })
})

describe.runIf(isServe)('invalid request', () => {
  const sendRawRequest = async (baseUrl: string, requestTarget: string) => {
    return new Promise<string>((resolve, reject) => {
      const parsedUrl = new URL(baseUrl)

      const buf: Buffer[] = []
      const client = net.createConnection(
        { port: +parsedUrl.port, host: parsedUrl.hostname },
        () => {
          client.write(
            [
              `GET ${encodeURI(requestTarget)} HTTP/1.1`,
              `Host: ${parsedUrl.host}`,
              'Connection: Close',
              '\r\n',
            ].join('\r\n'),
          )
        },
      )
      client.on('data', (data) => {
        buf.push(data)
      })
      client.on('end', (hadError) => {
        if (!hadError) {
          resolve(Buffer.concat(buf).toString())
        }
      })
      client.on('error', (err) => {
        reject(err)
      })
    })
  }

  const root = path
    .resolve(__dirname.replace('playground', 'playground-temp'), '..')
    .replace(/\\/g, '/')

  test('request with sendRawRequest should work', async () => {
    const response = await sendRawRequest(viteTestUrl, '/src/safe.txt')
    expect(response).toContain('HTTP/1.1 200 OK')
    expect(response).toContain('KEY=safe')
  })

  test('request with sendRawRequest should work with /@fs/', async () => {
    const response = await sendRawRequest(
      viteTestUrl,
      path.posix.join('/@fs/', root, 'root/src/safe.txt'),
    )
    expect(response).toContain('HTTP/1.1 200 OK')
    expect(response).toContain('KEY=safe')
  })

  test('should reject request that has # in request-target', async () => {
    const response = await sendRawRequest(
      viteTestUrl,
      '/src/safe.txt#/../../unsafe.txt',
    )
    expect(response).toContain('HTTP/1.1 400 Bad Request')
  })

  test('should reject request that has # in request-target with /@fs/', async () => {
    const response = await sendRawRequest(
      viteTestUrl,
      path.posix.join('/@fs/', root, 'root/src/safe.txt') +
        '#/../../unsafe.txt',
    )
    expect(response).toContain('HTTP/1.1 400 Bad Request')
  })

  test('should deny request to denied file when a request has /.', async () => {
    const response = await sendRawRequest(viteTestUrl, '/src/dummy.crt/.')
    expect(response).toContain('HTTP/1.1 403 Forbidden')
  })

  test('should deny request to denied file when a request ends with \\', async () => {
    const response = await sendRawRequest(viteTestUrl, '/src/.env\\')
    expect(response).toContain(
      isWindows ? 'HTTP/1.1 403 Forbidden' : 'HTTP/1.1 404 Not Found',
    )
  })

  test('should deny request to denied file when a request ends with \\ with /@fs/', async () => {
    const response = await sendRawRequest(
      viteTestUrl,
      path.posix.join('/@fs/', root, 'root/src/.env') + '\\',
    )
    expect(response).toContain(
      isWindows ? 'HTTP/1.1 403 Forbidden' : 'HTTP/1.1 404 Not Found',
    )
  })

  test('should deny request with /@fs/ to denied file when a request has /.', async () => {
    const response = await sendRawRequest(
      viteTestUrl,
      path.posix.join('/@fs/', root, 'root/src/dummy.crt/') + '.',
    )
    expect(response).toContain('HTTP/1.1 403 Forbidden')",0
"import path from 'path';

import { isAxiosError } from 'axios';
import express from 'express';

import { sha256String } from '../util/hash.js';
import {
  requestLoggerMiddleware,
  validateSessionMiddleware,
} from '../util/middlewares.js';

import {
  AccountNotLinkedToRequisition,
  GenericGoCardlessError,
  RateLimitError,
  RequisitionNotLinked,
} from './errors.js';
import { goCardlessService } from './services/gocardless-service.js';
import { handleError } from './util/handle-error.js';

const app = express();
app.use(requestLoggerMiddleware);

app.get('/link', function (req, res) {
  res.sendFile('link.html', { root: path.resolve('./src/app-gocardless') });
});

export { app as handlers };
app.use(express.json());
app.use(validateSessionMiddleware);

app.post('/status', async (req, res) => {
  res.send({
    status: 'ok',
    data: {
      configured: goCardlessService.isConfigured(),
    },
  });
});

app.post(
  '/create-web-token',
  handleError(async (req, res) => {
    const { institutionId } = req.body || {};
    const { origin } = req.headers;

    const { link, requisitionId } = await goCardlessService.createRequisition({
      institutionId,
      host: origin,
    });

    res.send({
      status: 'ok',
      data: {
        link,
        requisitionId,
      },
    });
  }),
);

app.post(
  '/get-accounts',
  handleError(async (req, res) => {
    const { requisitionId } = req.body || {};

    try {
      const { requisition, accounts } =
        await goCardlessService.getRequisitionWithAccounts(requisitionId);

      res.send({
        status: 'ok',
        data: {
          ...requisition,
          accounts: await Promise.all(
            accounts.map(async account =>
              account?.iban
                ? { ...account, iban: await sha256String(account.iban) }
                : account,
            ),
          ),
        },
      });
    } catch (error) {
      if (error instanceof RequisitionNotLinked) {
        res.send({
          status: 'ok',
          requisitionStatus: error.details.requisitionStatus,
        });
      } else {
        throw error;
      }
    }
  }),
);

app.post(
  '/get-banks',
  handleError(async (req, res) => {
    const { country, showDemo = false } = req.body || {};

    await goCardlessService.setToken();
    const data = await goCardlessService.getInstitutions(country);

    res.send({
      status: 'ok',
      data: showDemo
        ? [
            {
              id: 'SANDBOXFINANCE_SFIN0000',
              name: 'DEMO bank (used for testing bank-sync)',
            },
            ...data,
          ]
        : data,
    });
  }),
);

app.post(
  '/remove-account',
  handleError(async (req, res) => {
    const { requisitionId } = req.body || {};

    const data = await goCardlessService.deleteRequisition(requisitionId);
    if (data.summary === 'Requisition deleted') {
      res.send({
        status: 'ok',
        data,
      });
    } else {
      res.send({
        status: 'error',
        data: {
          data,
          reason: 'Can not delete requisition',
        },
      });
    }
  }),
);

app.post(
  '/transactions',
  handleError(async (req, res) => {
    const {
      requisitionId,
      startDate,
      endDate,
      accountId,
      includeBalance = true,
    } = req.body || {};

    try {
      if (includeBalance) {
        const {
          balances,
          institutionId,
          startingBalance,
          transactions: { booked, pending, all },
        } = await goCardlessService.getTransactionsWithBalance(
          requisitionId,
          accountId,
          startDate,
          endDate,
        );

        res.send({
          status: 'ok',
          data: {
            balances,
            institutionId,
            startingBalance,
            transactions: {
              booked,
              pending,
              all,
            },
          },
        });
      } else {
        const {
          institutionId,
          transactions: { booked, pending, all },
        } = await goCardlessService.getNormalizedTransactions(
          requisitionId,
          accountId,
          startDate,
          endDate,
        );

        res.send({
          status: 'ok',
          data: {
            institutionId,
            transactions: {
              booked,
              pending,
              all,
            },
          },
        });
      }
    } catch (error) {
      const headers = error.details?.response?.headers ?? {};

      const rateLimitHeaders = Object.fromEntries(
        Object.entries(headers).filter(([key]) =>
          key.startsWith('http_x_ratelimit'),
        ),
      );

      const sendErrorResponse = data =>
        res.send({
          status: 'ok',
          data: { ...data, details: error.details, rateLimitHeaders },
        });

      switch (true) {
        case error instanceof RequisitionNotLinked:
          sendErrorResponse({
            error_type: 'ITEM_ERROR',
            error_code: 'ITEM_LOGIN_REQUIRED',
            status: 'expired',
            reason:
              'Access to account has expired as set in End User Agreement',
          });
          break;
        case error instanceof AccountNotLinkedToRequisition:
          sendErrorResponse({
            error_type: 'INVALID_INPUT',
            error_code: 'INVALID_ACCESS_TOKEN',
            status: 'rejected',
            reason: 'Account not linked with this requisition',
          });
          break;
        case error instanceof RateLimitError:
          sendErrorResponse({
            error_type: 'RATE_LIMIT_EXCEEDED',
            error_code: 'NORDIGEN_ERROR',
            status: 'rejected',
            reason: 'Rate limit exceeded',
          });
          break;
        case error instanceof GenericGoCardlessError:
          console.log('Something went wrong', error.message);
          sendErrorResponse({
            error_type: 'SYNC_ERROR',
            error_code: 'NORDIGEN_ERROR',
          });
          break;
        case isAxiosError(error):
          console.log(
            'Something went wrong',
            error.message,
            error.response?.data?.summary || error.response?.data?.detail || '',
          );
          sendErrorResponse({
            error_type: 'SYNC_ERROR',
            error_code: 'NORDIGEN_ERROR',
          });
          break;
        default:
          console.log('Something went wrong', error.message || String(error));
          sendErrorResponse({
            error_type: 'UNKNOWN',
            error_code: 'UNKNOWN',
            reason: 'Something went wrong',
          });
          break;",0
"
/** @type {import('./bank.interface.js').IBank} */
export default {
  institutionIds: ['IntegrationBank'],

  normalizeAccount(account) {
    return {
      account_id: account.id,
      institution: account.institution,
      mask: (account?.iban || '0000').slice(-4),
      iban: account?.iban || null,
      name: [
        account.name ?? account.displayName ?? account.product,
        printIban(account),
        account.currency,
      ]
        .filter(Boolean)
        .join(' '),
      official_name: account.product ?? `integration-${account.institution_id}`,
      type: 'checking',
    };
  },

  normalizeTransaction(transaction, _booked, editedTransaction = null) {
    const trans = editedTransaction ?? transaction;

    const date =
      trans.date ||
      transaction.bookingDate ||
      transaction.bookingDateTime ||
      transaction.valueDate ||
      transaction.valueDateTime;

    // If we couldn't find a valid date field we filter out this transaction
    // and hope that we will import it again once the bank has processed the
    // transaction further.
    if (!date) {
      return null;
    }

    const notes =
      trans.notes ??
      trans.remittanceInformationUnstructured ??
      trans.remittanceInformationUnstructuredArray?.join(' ');

    transaction.remittanceInformationUnstructuredArrayString =
      transaction.remittanceInformationUnstructuredArray?.join(',');
    transaction.remittanceInformationStructuredArrayString =
      transaction.remittanceInformationStructuredArray?.join(',');

    return {
      ...transaction,
      payeeName: trans.payeeName ?? formatPayeeName(trans),
      date: d.format(d.parseISO(date), 'yyyy-MM-dd'),
      notes,
    };
  },

  sortTransactions(transactions = []) {
    return sortByBookingDateOrValueDate(transactions);
  },

  calculateStartingBalance(sortedTransactions = [], balances = []) {
    const currentBalance = balances
      .filter(item => SORTED_BALANCE_TYPE_LIST.includes(item.balanceType))
      .sort(
        (a, b) =>
          SORTED_BALANCE_TYPE_LIST.indexOf(a.balanceType) -
          SORTED_BALANCE_TYPE_LIST.indexOf(b.balanceType),",0
"  mockExtendAccountsAboutInstitutions,
  mockInstitution,
} from '../../services/tests/fixtures.js';
import IntegrationBank from '../integration-bank.js';

describe('IntegrationBank', () => {
  describe('normalizeAccount', () => {
    const account = mockExtendAccountsAboutInstitutions[0];

    it('should return a normalized account object', () => {
      const normalizedAccount = IntegrationBank.normalizeAccount(account);
      expect(normalizedAccount).toEqual({
        account_id: account.id,
        institution: mockInstitution,
        mask: '4321',
        iban: account.iban,
        name: 'account-example-one (XXX 4321) PLN',
        official_name: 'Savings Account for Individuals (Retail)',
        type: 'checking',
      });
    });

    it('should return a normalized account object with masked value ""0000"" when no iban property is provided', () => {
      const normalizedAccount = IntegrationBank.normalizeAccount({
        ...account,
        iban: undefined,
      });
      expect(normalizedAccount).toEqual({
        account_id: account.id,
        institution: mockInstitution,
        mask: '0000',
        iban: null,
        name: 'account-example-one PLN',
        official_name: 'Savings Account for Individuals (Retail)',
        type: 'checking',
      });
    });
  });

  describe('sortTransactions', () => {
    const transactions = [
      {
        date: '2022-01-01',
        bookingDate: '2022-01-01',
        transactionAmount: { amount: '100', currency: 'EUR' },
      },
      {
        date: '2022-01-03',
        bookingDate: '2022-01-03',
        transactionAmount: { amount: '100', currency: 'EUR' },
      },
      {
        date: '2022-01-02',
        bookingDate: '2022-01-02',
        transactionAmount: { amount: '100', currency: 'EUR' },
      },
    ];

    it('should return transactions sorted by bookingDate', () => {
      const sortedTransactions = IntegrationBank.sortTransactions(transactions);
      expect(sortedTransactions).toEqual([
        {
          date: '2022-01-03',
          bookingDate: '2022-01-03',
          transactionAmount: { amount: '100', currency: 'EUR' },
        },
        {
          date: '2022-01-02',
          bookingDate: '2022-01-02',
          transactionAmount: { amount: '100', currency: 'EUR' },
        },
        {
          date: '2022-01-01',
          bookingDate: '2022-01-01',
          transactionAmount: { amount: '100', currency: 'EUR' },
        },
      ]);
    });
  });

  describe('calculateStartingBalance', () => {
    /** @type {import('../../gocardless-node.types.js').Transaction[]} */
    const transactions = [
      {
        bookingDate: '2022-01-01',
        transactionAmount: { amount: '100', currency: 'EUR' },
      },
      {
        bookingDate: '2022-02-01',
        transactionAmount: { amount: '100', currency: 'EUR' },
      },
      {
        bookingDate: '2022-03-01',
        transactionAmount: { amount: '100', currency: 'EUR' },
      },
    ];

    /** @type {import('../../gocardless-node.types.js').Balance[]} */
    const balances = [
      {
        balanceAmount: { amount: '1000.00', currency: 'EUR' },
        balanceType: 'interimBooked',
      },
    ];

    it('should return 0 when no transactions or balances are provided', () => {
      const startingBalance = IntegrationBank.calculateStartingBalance([], []);
      expect(startingBalance).toEqual(0);
    });

    it('should return 70000 when transactions and balances are provided', () => {
      const startingBalance = IntegrationBank.calculateStartingBalance(
        transactions,
        balances,
      );
      expect(startingBalance).toEqual(70000);
    });
  });
});",0
"export function handleError(func) {
  return (req, res) => {
    func(req, res).catch(err => {
      console.log('Error', req.originalUrl, err.message || String(err));
      res.send({
        status: 'ok',
        data: {
          error_code: 'INTERNAL_ERROR',
          error_type: err.message ? err.message : 'internal-error',
        },",0
"  let rest = null;
  let auth = null;
  let username = null;
  let password = null;
  let baseUrl = null;
  if (!accessKey || !accessKey.match(/^.*\/\/.*:.*@.*$/)) {
    console.log('Invalid SimpleFIN access key');
    throw new Error(`Invalid access key`);
  }
  [scheme, rest] = accessKey.split('//');
  [auth, rest] = rest.split('@');
  [username, password] = auth.split(':');
  baseUrl = `${scheme}//${rest}`;",0
"import { CrawlImpl, CrawlSuccessResult } from '../type';
import { ssrfSafeFetch } from 'ssrf-safe-fetch';
import { NetworkConnectionError, PageNotFoundError, TimeoutError } from '../utils/errorType';
import { htmlToMarkdown } from '../utils/htmlToMarkdown';
import { DEFAULT_TIMEOUT, withTimeout } from '../utils/withTimeout';

const mixinHeaders = {
  // 接受的内容类型
  'Accept':
    'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7',
  // 接受的编码方式
  'Accept-Encoding': 'gzip, deflate, br',
  // 接受的语言
  'Accept-Language': 'en-US,en;q=0.9,zh;q=0.8',
  // 缓存控制
  'Cache-Control': 'max-age=0',
  // 连接类型
  'Connection': 'keep-alive',
  // 表明请求来自哪个站点
  'Referer': 'https://www.google.com/',
  // 升级不安全请求
  'Upgrade-Insecure-Requests': '1',
  // 模拟真实浏览器的 User-Agent
  'User-Agent':
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36',
  // 防止跨站请求伪造
  'sec-ch-ua': '""Google Chrome"";v=""121"", ""Not A(Brand"";v=""99"", ""Chromium"";v=""121""',
  'sec-ch-ua-mobile': '?0',
  'sec-ch-ua-platform': '""Windows""',
  'sec-fetch-dest': 'document',
  'sec-fetch-mode': 'navigate',
  'sec-fetch-site': 'none',
  'sec-fetch-user': '?1',
};

export const naive: CrawlImpl = async (url, { filterOptions }) => {
  let res: Response;

  try {
    res = await withTimeout(
      ssrfSafeFetch(url, {
        headers: mixinHeaders,
        signal: new AbortController().signal,
      }),
      DEFAULT_TIMEOUT,
    );
  } catch (e) {",0
"/**
 * Creates a `URL` object from a Node.js `IncomingMessage`, taking into account the protocol, host, and port.
 *
 * @param nodeRequest - The Node.js `IncomingMessage` or `Http2ServerRequest` object to extract URL information from.
 * @returns A `URL` object representing the request URL.
 */
export function createRequestUrl(nodeRequest: IncomingMessage | Http2ServerRequest): URL {
  const {
    headers,
    socket,
    url = '',
    originalUrl,
  } = nodeRequest as IncomingMessage & { originalUrl?: string };
  const protocol =
    getFirstHeaderValue(headers['x-forwarded-proto']) ??
    ('encrypted' in socket && socket.encrypted ? 'https' : 'http');
  const hostname =
    getFirstHeaderValue(headers['x-forwarded-host']) ?? headers.host ?? headers[':authority'];

  if (Array.isArray(hostname)) {
    throw new Error('host value cannot be an array.');
  }

  let hostnameWithPort = hostname;
  if (!hostname?.includes(':')) {
    const port = getFirstHeaderValue(headers['x-forwarded-port']);
    if (port) {
      hostnameWithPort += `:${port}`;
    }
  }

  return new URL(`${protocol}://${hostnameWithPort}${originalUrl ?? url}`);
}

/**
 * Extracts the first value from a multi-value header string.
 *
 * @param value - A string or an array of strings representing the header values.",0
"        ' the exported array in config/middleware.js'
    );
  }

  return koaCors({
    async origin(ctx) {
      const requestOrigin = ctx.get('Origin');

      if (!requestOrigin) {
        return '*';
      }

      let originList: string | string[];

      if (typeof origin === 'function') {
        originList = await origin(ctx);
      } else {
        originList = origin;
      }

      // Handle arrays of origins
      if (Array.isArray(originList)) {
        return originList.includes(requestOrigin) ? requestOrigin : '';
      }

      // Handle comma-separated string of origins
      const parsedOrigin = originList.split(',').map((origin) => origin.trim());
      if (parsedOrigin.length > 1) {
        return parsedOrigin.includes(requestOrigin) ? requestOrigin : '';
      }

      // Handle string of one origin with exact match (protocol, subdomain, domain, and port)
      if (typeof originList === 'string') {
        return originList === requestOrigin ? requestOrigin : '';
      }

      // block the request
      return '';
    },
    exposeHeaders: expose,
    maxAge,
    credentials,
    allowMethods: methods,
    allowHeaders: headers,",0
"    .string()
    .min(8, {
      id: translatedErrors.minLength.id,
      defaultMessage: 'Password must be at least 8 characters',
      values: { min: 8 },
    })
    .test('max-bytes', 'Password must be less than 73 bytes', (value) => {
      if (!value) return false;
      const byteSize = new TextEncoder().encode(value).length;
      return byteSize <= 72;
    })
    .matches(/[a-z]/, {
      message: {
        id: 'components.Input.error.contain.lowercase',
        defaultMessage: 'Password must contain at least 1 lowercase letter',
      },
    })
    .matches(/[A-Z]/, {
      message: {
        id: 'components.Input.error.contain.uppercase',
        defaultMessage: 'Password must contain at least 1 uppercase letter',
      },
    })
    .matches(/\d/, {
      message: {
        id: 'components.Input.error.contain.number',
        defaultMessage: 'Password must contain at least 1 number',
      },
    })
    .required({
      id: translatedErrors.required.id,
      defaultMessage: 'Password is required',
    })
    .nullable(),
  confirmPassword: yup
    .string()
    .required({
      id: translatedErrors.required.id,
      defaultMessage: 'Confirm password is required',
    })
    .oneOf([yup.ref('password'), null], {
      id: 'components.Input.error.password.noMatch',
      defaultMessage: 'Passwords must match',
    })
    .nullable(),
  registrationToken: yup.string().required({
    id: translatedErrors.required.id,
    defaultMessage: 'Registration token is required',
  }),
});

const REGISTER_ADMIN_SCHEMA = yup.object().shape({
  firstname: yup
    .string()
    .trim()
    .required({
      id: translatedErrors.required.id,
      defaultMessage: 'Firstname is required',
    })
    .nullable(),
  lastname: yup.string().nullable(),
  password: yup
    .string()
    .min(8, {
      id: translatedErrors.minLength.id,
      defaultMessage: 'Password must be at least 8 characters',
      values: { min: 8 },
    })
    .test('max-bytes', 'Password must be less than 73 bytes', (value) => {
      if (!value) return false;
      const byteSize = new TextEncoder().encode(value).length;
      return byteSize <= 72;
    })
    .matches(/[a-z]/, {
      message: {
        id: 'components.Input.error.contain.lowercase',
        defaultMessage: 'Password must contain at least 1 lowercase letter',
      },",0
"    .string()
    .min(8, {
      id: translatedErrors.minLength.id,
      defaultMessage: 'Password must be at least 8 characters',
      values: { min: 8 },
    })
    // bcrypt has a max length of 72 bytes (not characters!)
    .test('required-byte-size', 'Password must be less than 73 bytes', (value) => {
      if (!value) return false;
      const byteSize = new TextEncoder().encode(value).length;
      return byteSize <= 72;
    })
    .matches(/[a-z]/, {
      message: {
        id: 'components.Input.error.contain.lowercase',
        defaultMessage: 'Password must contain at least 1 lowercase letter',
      },
    })
    .matches(/[A-Z]/, {
      message: {
        id: 'components.Input.error.contain.uppercase',
        defaultMessage: 'Password must contain at least 1 uppercase letter',
      },
    })
    .matches(/\d/, {
      message: {
        id: 'components.Input.error.contain.number',
        defaultMessage: 'Password must contain at least 1 number',
      },
    })
    .required({
      id: translatedErrors.required.id,
      defaultMessage: 'Password is required',
    })
    .nullable(),
  confirmPassword: yup
    .string()
    .required({
      id: translatedErrors.required.id,
      defaultMessage: 'Confirm password is required',
    })
    .oneOf([yup.ref('password'), null], {
      id: 'components.Input.error.password.noMatch',
      defaultMessage: 'Passwords must match',
    })
    .nullable(),
});

const ResetPassword = () => {
  const { formatMessage } = useIntl();
  const dispatch = useTypedDispatch();
  const navigate = useNavigate();
  const { search: searchString } = useLocation();
  const query = React.useMemo(() => new URLSearchParams(searchString), [searchString]);
  const { _unstableFormatAPIError: formatAPIError } = useAPIErrorHandler();

  const [resetPassword, { error }] = useResetPasswordMutation();

  const handleSubmit = async (body: ResetPassword.Request['body']) => {
    const res = await resetPassword(body);

    if ('data' in res) {
      dispatch(login({ token: res.data.token }));
      navigate('/');
    }
  };
  /**
   * If someone doesn't have a reset password token
   * then they should just be redirected back to the login page.
   */
  if (!query.get('code')) {
    return <Navigate to=""/auth/login"" />;
  }

  return (
    <UnauthenticatedLayout>
      <Main>
        <LayoutContent>
          <Column>
            <Logo />
            <Box paddingTop={6} paddingBottom={7}>
              <Typography tag=""h1"" variant=""alpha"">
                {formatMessage({
                  id: 'global.reset-password',
                  defaultMessage: 'Reset password',
                })}
              </Typography>
            </Box>
            {error ? (
              <Typography id=""global-form-error"" role=""alert"" tabIndex={-1} textColor=""danger600"">
                {isBaseQueryError(error)
                  ? formatAPIError(error)
                  : formatMessage({
                      id: 'notification.error',
                      defaultMessage: 'An error occurred',
                    })}
              </Typography>
            ) : null}
          </Column>
          <Form
            method=""POST""
            initialValues={{",0
"    .transform((value) => (value === '' || value === null ? undefined : value))
    .nullable()
    .min(8, {
      ...translatedErrors.minLength,
      values: { min: 8 },
    })
    .test('max-bytes', 'Password must be less than 73 bytes', (value) => {
      if (!value) return false;
      const byteSize = new TextEncoder().encode(value).length;
      return byteSize <= 72;
    })
    .matches(/[a-z]/, {
      id: 'components.Input.error.contain.lowercase',
      defaultMessage: 'Password must contain at least one lowercase character',
    })
    .matches(/[A-Z]/, {
      id: 'components.Input.error.contain.uppercase',
      defaultMessage: 'Password must contain at least one uppercase character',
    })
    .matches(/\\d/, {
      id: 'components.Input.error.contain.number',
      defaultMessage: 'Password must contain at least one number',
    }),
  confirmPassword: yup
    .string()
    .transform((value) => (value === '' ? null : value))",0
"
export const username = yup.string().min(1);

export const password = yup
  .string()
  .min(8)
  .test('required-byte-size', 'Password must be less than 73 bytes', (value) => {
    if (!value) return false;
    const byteSize = new TextEncoder().encode(value).length;
    return byteSize <= 72;
  })
  .matches(/[a-z]/, '${path} must contain at least one lowercase character')
  .matches(/[A-Z]/, '${path} must contain at least one uppercase character')
  .matches(/\d/, '${path} must contain at least one number');

export const roles = yup.array(yup.strapiID()).min(1);
",0
"    getService: jest.fn(() => {
      return {
        add: jest.fn((user) => {
          return user;
        }),
        issue: jest.fn(),
        edit: jest.fn(async (id, data) => {
          if (id === 1 && data.password) {
            return { id, ...data };
          }
          throw new Error('Failed to edit user');
        }),
      };
    }),
  };
});

describe('user-permissions auth', () => {
  beforeAll(() => {
    global.strapi = mockStrapi;
  });

  describe('register', () => {
    const registerCases = [
      {
        description: 'Accepts valid registration with a typical password',
        password: 'Testpassword1!',
      },
      {
        description: 'Password is exactly 72 bytes with valid ASCII characters',
        password: 'a'.repeat(72), // 72 ASCII characters
      },
      {
        description:
          'Password is exactly 72 bytes with a mix of multibyte and single-byte characters',
        password: `${'a'.repeat(69)}测`, // 70 single-byte characters + 1 three-byte character 测
      },
    ];

    test.each(registerCases)('$description', async ({ password }) => {
      const ctx = {
        state: {
          auth: {},
        },
        request: {
          body: { username: 'testuser', email: 'test@example.com', password },
        },
        send: jest.fn(),
      };

      const authorization = auth({ strapi: global.strapi });
      await authorization.register(ctx);
      expect(ctx.send).toHaveBeenCalledTimes(1);
    });

    test('throws ValidationError when passed extra fields when allowedField is undefined', async () => {
      global.strapi = {
        ...mockStrapi,
        config: {
          get: jest.fn(() => {
            return {
              register: {
                // empty
              },
            };
          }),
        },
      };

      const ctx = {
        state: {
          auth: {},
        },
        request: {
          body: {
            confirmed: true,
            username: 'testuser',
            email: 'test@example.com',
            password: 'Testpassword1!',
          },
        },
        send: jest.fn(),
      };
      const authorization = auth({ strapi: global.strapi });
      await expect(authorization.register(ctx)).rejects.toThrow(errors.ValidationError);
      expect(ctx.send).toHaveBeenCalledTimes(0);
    });

    test('throws ValidationError when passed extra fields when allowedField is []', async () => {
      global.strapi = {
        ...mockStrapi,
        config: {
          get: jest.fn(() => {
            return {
              register: {
                allowedFields: [],
              },
            };
          }),
        },
      };

      const ctx = {
        state: {
          auth: {},
        },
        request: {
          body: {
            confirmed: true,
            username: 'testuser',
            email: 'test@example.com',
            password: 'Testpassword1!',
          },
        },
        send: jest.fn(),
      };
      const authorization = auth({ strapi: global.strapi });
      await expect(authorization.register(ctx)).rejects.toThrow(errors.ValidationError);
      expect(ctx.send).toHaveBeenCalledTimes(0);
    });

    test('allows exceptions from config register.allowedFields', async () => {
      global.strapi = {
        ...mockStrapi,
        config: {
          get: jest.fn(() => {
            return {
              register: {
                allowedFields: ['confirmed'],
              },
            };
          }),
        },
      };

      const ctx = {
        state: {
          auth: {},
        },
        request: {
          body: {
            confirmed: true,
            username: 'testuser',
            email: 'test@example.com',
            password: 'Testpassword1!',
          },
        },
        send: jest.fn(),
      };
      const authorization = auth({ strapi: global.strapi });
      await authorization.register(ctx);
      expect(ctx.send).toHaveBeenCalledTimes(1);
    });

    test('password does not follow custom validation pattern', async () => {
      global.strapi = {
        ...mockStrapi,
        config: {
          get: jest.fn((path) => {
            if (path === 'plugin::users-permissions.validationRules') {
              return {
                validatePassword(value) {
                  // Custom validation logic: at least 1 uppercase, 1 lowercase, and 1 number
                  const hasUpperCase = /[A-Z]/.test(value);
                  const hasLowerCase = /[a-z]/.test(value);
                  const hasNumber = /[0-9]/.test(value);
                  return hasUpperCase && hasLowerCase && hasNumber && value.length >= 6;
                },
              };
            }
            return {
              register: {
                allowedFields: [],
              },
            };
          }),
        },
      };

      const ctx = {
        state: {
          auth: {},
        },
        request: {
          body: {
            username: 'testuser',
            email: 'test@example.com',
            password: 'TestingPassword',
          },
        },
        send: jest.fn(),
      };
      const authorization = auth({ strapi: global.strapi });
      await expect(authorization.register(ctx)).rejects.toThrow(errors.ValidationError);
      expect(ctx.send).toHaveBeenCalledTimes(0);
    });

    test('password follows custom validation pattern', async () => {
      global.strapi = {
        ...mockStrapi,
        config: {
          get: jest.fn((path) => {
            if (path === 'plugin::users-permissions.validationRules') {
              return {
                validatePassword(value) {
                  // Custom validation logic: at least 1 uppercase, 1 lowercase, and 1 number
                  const hasUpperCase = /[A-Z]/.test(value);
                  const hasLowerCase = /[a-z]/.test(value);
                  const hasNumber = /[0-9]/.test(value);
                  return hasUpperCase && hasLowerCase && hasNumber && value.length >= 6;
                },
              };
            }
            return {
              register: {
                allowedFields: [],
              },
            };
          }),
        },
      };

      const ctx = {
        state: {
          auth: {},
        },
        request: {
          body: {
            username: 'testuser',
            email: 'test@example.com',
            password: 'Password123',
          },
        },
        send: jest.fn(),
      };
      const authorization = auth({ strapi: global.strapi });
      await authorization.register(ctx);
      expect(ctx.send).toHaveBeenCalledTimes(1);
    });

    const cases = [
      {
        description: 'Password is exactly 73 bytes with valid ASCII characters',
        password: `a${'b'.repeat(72)}`, // 1 byte ('a') + 72 bytes ('b') = 73 bytes
        expectedMessage: 'Password must be less than 73 bytes',
      },
      {
        description: 'Password is 73 bytes but contains a character cut in half (UTF-8)',
        password: `a${'b'.repeat(70)}=\uD83D`, // 1 byte ('a') + 70 bytes ('b') + 3 bytes for half of a surrogate pair
        expectedMessage: 'Password must be less than 73 bytes',
      },
      {
        description: 'Password is 73 bytes but contains a character cut in half (UTF-8)',
        password: `${'a'.repeat(70)}测`, // 1 byte ('a') + 70 bytes ('b') + 3 bytes for 测
        expectedMessage: 'Password must be less than 73 bytes',
      },
    ];

    test.each(cases)('$description', async ({ password, expectedMessage }) => {
      global.strapi = {
        ...mockStrapi,
        config: {
          get: jest.fn(() => {
            return {
              register: {
                allowedFields: [],
              },
            };
          }),
        },
      };

      const ctx = {
        state: {
          auth: {},
        },
        request: {
          body: {
            username: 'testuser',
            email: 'test@example.com',
            password,
          },
        },
        send: jest.fn(),
      };

      const authorization = auth({ strapi: global.strapi });
      await expect(authorization.register(ctx)).rejects.toThrow(errors.ValidationError);
      expect(ctx.send).toHaveBeenCalledTimes(0);
    });
  });

  describe('resetPassword', () => {
    const resetPasswordCases = [
      {
        description: 'Fails if passwords do not match',
        body: {
          password: 'NewPassword123',
          passwordConfirmation: 'DifferentPassword123',
          code: 'valid-reset-token',
        },
        expectedMessage: 'Passwords do not match',
      },
      {
        description: 'Fails if reset token is invalid',
        body: {
          password: 'NewPassword123',
          passwordConfirmation: 'NewPassword123',
          code: 'invalid-reset-token',
        },
        expectedMessage: 'Incorrect code provided',
      },
      {
        description: 'Successfully resets the password with valid input',
        body: {
          password: 'NewPassword123',
          passwordConfirmation: 'NewPassword123',
          code: 'valid-reset-token',
        },
        expectedResponse: {
          user: { id: 1 },
        },
      },
    ];

    test.each(resetPasswordCases)(
      '$description',
      async ({ body, expectedMessage, expectedResponse }) => {
        global.strapi = {
          ...mockStrapi,
          db: {
            query: jest.fn(() => ({
              findOne: jest.fn((query) => {
                if (query.where.resetPasswordToken === 'valid-reset-token') {
                  return { id: 1, resetPasswordToken: 'valid-reset-token' };
                }
                return null;
              }),
            })),
          },
          services: {
            user: {
              edit: jest.fn(async (id, data) => {
                if (id === 1 && data.password) {
                  return { id, ...data }; // Simulate successful password update
                }
                throw new Error('Failed to edit user');
              }),
            },
            jwt: {
              issue: jest.fn((payload) => `fake-jwt-token-for-user-${payload.id}`), // Ensure JWT mock works
            },
          },
          contentAPI: {
            sanitize: {
              output: jest.fn((user) => {
                // Simulate sanitizing the user object
                const { resetPasswordToken, ...sanitizedUser } = user; // Remove token from sanitized output
                return sanitizedUser;
              }),
            },
          },
        };

        const ctx = {
          request: { body },
          state: {
            auth: {}, // Mock auth object
          },
          send: jest.fn(),
        };

        const authorization = auth({ strapi: global.strapi });

        if (expectedMessage) {
          await expect(authorization.resetPassword(ctx)).rejects.toThrow(expectedMessage);
          expect(ctx.send).toHaveBeenCalledTimes(0);
        } else {
          await authorization.resetPassword(ctx);
          expect(ctx.send).toHaveBeenCalledWith(expectedResponse);
        }
      }
    );
  });
});",0
"  yup.object({
    email: yup.string().email().required(),
    username: yup.string().required(),
    password: yup
      .string()
      .required()
      .test('max-bytes', 'Password must be less than 73 bytes', (value) => {
        if (!value) return false;
        const byteSize = new TextEncoder().encode(value).length;
        return byteSize <= 72;
      })
      .test(async function (value) {
        if (typeof config?.validatePassword === 'function') {
          try {
            const isValid = await config.validatePassword(value);
            if (!isValid) {
              return this.createError({ message: 'Password validation failed.' });
            }
          } catch (error) {
            return this.createError({ message: error.message || 'An error occurred.' });
          }
        }
        return true;
      }),
  });

const sendEmailConfirmationSchema = yup.object({
  email: yup.string().email().required(),
});

const validateEmailConfirmationSchema = yup.object({
  confirmation: yup.string().required(),
});

const forgotPasswordSchema = yup
  .object({
    email: yup.string().email().required(),
  })
  .noUnknown();

const createResetPasswordSchema = (config) =>
  yup
    .object({
      password: yup
        .string()
        .required()
        .test('max-bytes', 'Password must be less than 73 bytes', (value) => {
          if (!value) return false;
          const byteSize = new TextEncoder().encode(value).length;
          return byteSize <= 72;
        })
        .test(async function (value) {
          if (typeof config?.validatePassword === 'function') {
            try {
              const isValid = await config.validatePassword(value);
              if (!isValid) {
                return this.createError({ message: 'Password validation failed.' });
              }
            } catch (error) {
              return this.createError({ message: error.message || 'An error occurred.' });
            }
          }
          return true;
        }),
      passwordConfirmation: yup
        .string()
        .required()
        .oneOf([yup.ref('password')], 'Passwords do not match'),

      code: yup.string().required(),
    })
    .noUnknown();

const createChangePasswordSchema = (config) =>
  yup
    .object({
      password: yup
        .string()
        .required()
        .test('max-bytes', 'Password must be less than 73 bytes', (value) => {
          if (!value) return false;
          const byteSize = new TextEncoder().encode(value).length;
          return byteSize <= 72;
        })
        .test(async function (value) {
          if (typeof config?.validatePassword === 'function') {
            try {
              const isValid = await config.validatePassword(value);
              if (!isValid) {
                return this.createError({ message: 'Password validation failed.' });",0
"          password: internals.newPassword,
        },
      });

      expect(res.statusCode).toBe(200);
    });

    const cases = [
      {
        description: 'Password is exactly 73 bytes with valid ASCII characters',
        password: `a${'b'.repeat(100)}`, // 1 byte ('a') + 72 bytes ('b') = 73 bytes
        expectedStatus: 400,
        expectedMessage: 'Password must be less than 73 bytes',
      },
      {
        description: 'Password is 73 bytes but contains a character cut in half (UTF-8)',
        password: `a${'b'.repeat(100)}\uD83D`, // 1 byte ('a') + 70 bytes ('b') + 3 bytes for half of a surrogate pair
        expectedStatus: 400,
        expectedMessage: 'Password must be less than 73 bytes',
      },
    ];

    test.each(cases)('$description', async ({ password, expectedStatus, expectedMessage }) => {
      const res = await rq({
        method: 'POST',
        url: '/change-password',
        body: {
          password,
          passwordConfirmation: password,
          currentPassword: internals.newPassword,
        },
      });

      expect(res.statusCode).toBe(expectedStatus);
      expect(res.body.error.name).toBe('ValidationError');
      expect(res.body.error.message).toBe(expectedMessage);
    });
  });
});",0
" */
const statusToLookup: TransformWithContentType = (contentType, params) => {
  if (!contentTypes.hasDraftAndPublish(contentType)) {
    return params;
  }

  // @ts-expect-error: we need to create a different typing for internal params
  const lookup = params.lookup || {};

  switch (params?.status) {
    case 'published':
      return assoc(['lookup', 'publishedAt'], { $notNull: true }, params);
    case 'draft':",0
"import { omit, assoc, merge, curry } from 'lodash/fp';

import { async, contentTypes as contentTypesUtils, validate, errors } from '@strapi/utils';

import { UID } from '@strapi/types';
import { wrapInTransaction, type RepositoryFactoryMethod } from './common';
import * as DP from './draft-and-publish';
import * as i18n from './internationalization';
import * as components from './components';

import { createEntriesService } from './entries';
import { pickSelectionParams } from './params';
import { createDocumentId } from '../../utils/transform-content-types-to-models';
import { getDeepPopulate } from './utils/populate';
import { transformParamsToQuery } from './transform/query';
import { transformParamsDocumentId } from './transform/id-transform';
import { createEventManager } from './events';
import * as unidirectionalRelations from './utils/unidirectional-relations';
import entityValidator from '../entity-validator';

const { validators } = validate;

// we have to typecast to reconcile the differences between validator and database getModel
const getModel = ((schema: UID.Schema) => strapi.getModel(schema)) as (schema: string) => any;

export const createContentTypeRepository: RepositoryFactoryMethod = (
  uid,
  validator = entityValidator
) => {
  const contentType = strapi.contentType(uid);
  const hasDraftAndPublish = contentTypesUtils.hasDraftAndPublish(contentType);

  // Define the validations that should be performed
  const sortValidations = ['nonAttributesOperators', 'dynamicZones', 'morphRelations'];
  const fieldValidations = ['scalarAttributes'];
  const filtersValidations = ['nonAttributesOperators', 'dynamicZones', 'morphRelations'];
  const populateValidations = {
    sort: sortValidations,
    field: fieldValidations,
    filters: filtersValidations,
    populate: ['nonAttributesOperators'],
  };

  const validateParams = async (params: any) => {
    const ctx = { schema: contentType, getModel };
    await validators.validateFilters(ctx, params.filters, filtersValidations);
    await validators.validateSort(ctx, params.sort, sortValidations);
    await validators.validateFields(ctx, params.fields, fieldValidations);
    await validators.validatePopulate(ctx, params.populate, populateValidations);

    // Strip lookup from params, it's only used internally
    if (params.lookup) {
      throw new errors.ValidationError(""Invalid params: 'lookup'"");
    }

    // TODO: add validate status, locale, pagination

    return params;
  };

  const entries = createEntriesService(uid, validator);",0
"          strapi.documents(ARTICLE_UID)[methodName]({
            populate: ['categories', 'fakekey'],
          })
        ).rejects.toThrow(errors.ValidationError);
      });
    });

    /**
     * Lookup is an internal parameter used to filter by locale and status.
     * It should not be exposed to the public API.
     */
    describe('lookup', () => {
      it('should throw ValidationError', async () => {
        await expect(
          strapi.documents(ARTICLE_UID)[methodName]({
            lookup: {
              title: 'Hello World',
            },
          })
        ).rejects.toThrow(errors.ValidationError);
      });
    });
  });
});",0
"				expect(worker.postedData.length).toBe(1);

				expect(worker.scriptPath.toString()).toBe(
					'file://' + Path.resolve(Path.join('src', 'ServerRendererWorker.js'))
				);

				expect(worker.execArgv).toEqual([
					'--disallow-code-generation-from-strings',
					'--frozen-intrinsics'
				]);

				expect(worker.workerData.configuration.cache.directory).toBe(
					Path.resolve(Path.join('happy-dom', 'cache'))
				);
				expect(worker.workerData.configuration.outputDirectory).toBe(
					Path.resolve(Path.join('happy-dom', 'render'))
				);

				expect(worker.workerData.configuration).toEqual({
					...DefaultServerRendererConfiguration,
					outputDirectory: Path.resolve(Path.join('happy-dom', 'render')),
					cache: {
						...DefaultServerRendererConfiguration.cache,
						directory: Path.resolve(Path.join('happy-dom', 'cache'))
					},
					worker: {
						...DefaultServerRendererConfiguration.worker,
						maxConcurrency: 10
					}
				});

				expect(worker.listeners.message.length).toBe(1);
				expect(worker.listeners.error.length).toBe(1);
				expect(worker.listeners.exit.length).toBe(1);
				expect(worker.postedData.length).toBe(1);

				const postedData = worker.postedData[0];
				worker.postedData = [];

				worker.listeners.message[0]({
					results: postedData.items.map((item) => ({
						url: item.url,
						content: '<html></html>',
						outputFile: null,
						error: null,
						pageConsole: '',
						pageErrors: [],
						status: 200,
						statusText: 'OK',
						headers: {
							test: 'value'
						}
					}))
				});
			}

			await new Promise((resolve) => setTimeout(resolve));

			// 10 workers are still open (no workers are terminated)
			expect(MockedWorker.openWorkers.length).toBe(10);

			// 4 workers are busy and are waiting for post message
			for (const worker of MockedWorker.openWorkers.slice(0, 4)) {
				expect(worker.listeners.message.length).toBe(1);
				expect(worker.postedData.length).toBe(1);
				const postedData = worker.postedData[0];
				worker.postedData = [];
				worker.listeners.message[0]({
					results: postedData.items.map((item) => ({
						url: item.url,
						content: '<html></html>',
						outputFile: null,
						error: null,
						pageConsole: '',
						pageErrors: [],
						status: 200,
						statusText: 'OK',
						headers: {
							test: 'value'
						}
					}))
				});
			}

			// 4 workers are free and idle
			for (const worker of MockedWorker.openWorkers.slice(4)) {
				expect(worker.postedData.length).toBe(0);
			}

			await new Promise((resolve) => setTimeout(resolve));

			// All workers have been terminated
			expect(MockedWorker.openWorkers.length).toBe(0);
			expect(MockedWorker.terminatedWorkers.length).toBe(10);

			expect(log).toEqual([
				Chalk.bold(`Rendering ${MockedURLList.length} pages...\n`),
				...MockedURLList.map((url) => Chalk.bold(`• Rendered page ""${url}""`)),
				Chalk.bold(`\nRendered ${MockedURLList.length} pages in 0 seconds\n`)
			]);

			expect(results!).toEqual(
				MockedURLList.map((url) => ({
					url,
					content: '<html></html>',
					outputFile: null,
					error: null,
					pageErrors: [],
					pageConsole: '',
					status: 200,
					statusText: 'OK',
					headers: {
						test: 'value'
					}
				}))
			);
		});

		it('Renders pages in workers with cache warmup.', async () => {
			const renderer = new ServerRenderer({
				cache: {
					warmup: true
				},
				worker: {
					maxConcurrency: 10
				}
			});
			let results: IServerRendererResult[];

			renderer.render(MockedURLList).then((r) => {
				results = r;
			});

			// Cache warmup opens 1 worker first
			expect(MockedWorker.openWorkers.length).toBe(1);

			const worker = MockedWorker.openWorkers[0];
			const postedData = worker.postedData[0];
			worker.postedData = [];
			worker.listeners.message[0]({
				results: postedData.items.map((item) => ({
					url: item.url,
					content: '<html>Warmup</html>',
					outputFile: null,
					error: null,
					pageConsole: '',
					pageErrors: [],
					status: 200,
					statusText: 'OK',
					headers: {
						test: 'value'
					}
				}))
			});

			await new Promise((resolve) => setTimeout(resolve));

			expect(MockedWorker.openWorkers.length).toBe(10);

			for (const worker of MockedWorker.openWorkers) {
				expect(worker.listeners.message.length).toBe(1);
				expect(worker.postedData.length).toBe(1);

				expect(worker.scriptPath.toString()).toBe(
					'file://' + Path.resolve(Path.join('src', 'ServerRendererWorker.js'))
				);

				expect(worker.execArgv).toEqual([
					'--disallow-code-generation-from-strings',
					'--frozen-intrinsics'
				]);

				expect(worker.workerData.configuration.cache.directory).toBe(
					Path.resolve(Path.join('happy-dom', 'cache'))
				);
				expect(worker.workerData.configuration.outputDirectory).toBe(
					Path.resolve(Path.join('happy-dom', 'render'))",0
"export function traversePath<T extends object>(
	obj: T,
	realPath: (string | number | symbol)[],
	modifier?: (data: PathData) => undefined | unknown | void
): PathData | undefined {
	if (!realPath.length) return undefined;

	// Prevent prototype injection
	if (realPath.includes('__proto__') || realPath.includes('prototype')) {
		throw new Error(""Cannot set an object's `__proto__` or `prototype` property"");
	}

	const path = [realPath[0]];

	let parent = obj;

	while (parent && path.length < realPath.length) {
		const key = path[path.length - 1] as keyof typeof parent;",0
"    }

    // Decode HTML entities such as &copy;
    output = he.decode(output);

    // Strip all HTML tags from plaintext output
    output = output.replace(/<.+?>/gs, '');

    // All done!
    return output;
};

// Validates, parses and returns injectable ejs parameters",0
"import ParseFile from './ParseFile';
import ParseRelation from './ParseRelation';
import TaskQueue from './TaskQueue';
import { RelationOp } from './ParseOp';
import type { Op } from './ParseOp';
import type ParseObject from './ParseObject';
import { isDangerousKey } from ""./isDangerousKey"";

export type AttributeMap = Record<string, any>;
export type OpsMap = Record<string, Op>;
export type ObjectCache = Record<string, string>;

export interface State {
  serverData: AttributeMap;
  pendingOps: OpsMap[];
  objectCache: ObjectCache;
  tasks: TaskQueue;
  existed: boolean;
}

export function defaultState(): State {
  return {
    serverData: Object.create(null),
    pendingOps: [Object.create(null)],
    objectCache: Object.create(null),
    tasks: new TaskQueue(),
    existed: false,
  };
}

export function setServerData(serverData: AttributeMap, attributes: AttributeMap) {
  for (const attr in attributes) {
    // Skip properties from prototype chain
    if (!Object.prototype.hasOwnProperty.call(attributes, attr)) {
      continue;
    }
    // Skip dangerous keys that could pollute prototypes
    if (isDangerousKey(attr)) {
      continue;
    }
    if (typeof attributes[attr] !== ""undefined"") {
      serverData[attr] = attributes[attr];
    } else {
      delete serverData[attr];
    }
  }
}

export function setPendingOp(pendingOps: OpsMap[], attr: string, op?: Op) {
  // Skip dangerous keys that could pollute prototypes
  if (isDangerousKey(attr)) {
    return;
  }
  const last = pendingOps.length - 1;
  if (op) {
    pendingOps[last][attr] = op;
  } else {
    delete pendingOps[last][attr];
  }
}

export function pushPendingState(pendingOps: OpsMap[]) {
  pendingOps.push(Object.create(null));
}

export function popPendingState(pendingOps: OpsMap[]): OpsMap {
  const first = pendingOps.shift();
  if (!pendingOps.length) {
    pendingOps[0] = Object.create(null);
  }
  return first;
}

export function mergeFirstPendingState(pendingOps: OpsMap[]) {
  const first = popPendingState(pendingOps);
  const next = pendingOps[0];
  for (const attr in first) {
    // Skip properties from prototype chain
    if (!Object.prototype.hasOwnProperty.call(first, attr)) {
      continue;
    }
    // Skip dangerous keys that could pollute prototypes
    if (isDangerousKey(attr)) {
      continue;
    }
    if (next[attr] && first[attr]) {
      const merged = next[attr].mergeWith(first[attr]);
      if (merged) {
        next[attr] = merged;
      }
    } else {
      next[attr] = first[attr];
    }
  }
}

export function estimateAttribute(
  serverData: AttributeMap,
  pendingOps: OpsMap[],
  object: ParseObject,
  attr: string
): any {
  // Skip dangerous keys that could pollute prototypes
  if (isDangerousKey(attr)) {
    return undefined;
  }
  let value = serverData[attr];
  for (let i = 0; i < pendingOps.length; i++) {
    if (pendingOps[i][attr]) {
      if (pendingOps[i][attr] instanceof RelationOp) {
        if (object.id) {
          value = (pendingOps[i][attr] as RelationOp).applyTo(value, object, attr);
        }
      } else {
        value = pendingOps[i][attr].applyTo(value);
      }
    }
  }
  return value;
}

export function estimateAttributes(
  serverData: AttributeMap,
  pendingOps: OpsMap[],
  object: ParseObject
): AttributeMap {
  const data = Object.create(null);
  let attr;
  for (attr in serverData) {
    data[attr] = serverData[attr];
  }
  for (let i = 0; i < pendingOps.length; i++) {
    for (attr in pendingOps[i]) {
      // Skip properties from prototype chain
      if (!Object.prototype.hasOwnProperty.call(pendingOps[i], attr)) {
        continue;
      }
      // Skip dangerous keys that could pollute prototypes
      if (isDangerousKey(attr)) {
        continue;
      }
      if (pendingOps[i][attr] instanceof RelationOp) {
        if (object.id) {
          data[attr] = (pendingOps[i][attr] as RelationOp).applyTo(data[attr], object, attr);
        }
      } else {
        if (attr.includes('.')) {
          // similar to nestedSet function
          const fields = attr.split('.');
          const last = fields[fields.length - 1];
          let object = data;
          for (let i = 0; i < fields.length - 1; i++) {
            const key = fields[i];
            if (!(key in object)) {
              const nextKey = fields[i + 1];
              if (!isNaN(nextKey)) {
                object[key] = [];
              } else {
                object[key] = Object.create(null);
              }
            } else {
              if (Array.isArray(object[key])) {
                object[key] = [...object[key]];
              } else {
                object[key] = { ...object[key] };
              }
            }
            object = object[key];
          }
          object[last] = pendingOps[i][attr].applyTo(object[last]);
        } else {
          data[attr] = pendingOps[i][attr].applyTo(data[attr]);
        }
      }
    }
  }
  return data;
}

/**
 * Allows setting properties/variables deep in an object.
 * Converts a.b into { a: { b: value } } for dot notation on Objects
 * Converts a.0.b into { a: [{ b: value }] } for dot notation on Arrays
 *
 * @param obj The object to assign the value to
 * @param key The key to assign. If it's in a deeper path, then use dot notation (`prop1.prop2.prop3`)
 * Note that intermediate object(s) in the nested path are automatically created if they don't exist.
 * @param value The value to assign. If it's an `undefined` then the key is deleted.
 */
function nestedSet(obj, key, value) {
  const paths = key.split('.');
  for (let i = 0; i < paths.length - 1; i++) {
    const path = paths[i];
    if (!(path in obj)) {
      const nextPath = paths[i + 1];
      if (!isNaN(nextPath)) {
        obj[path] = [];
      } else {
        obj[path] = Object.create(null);
      }
    }
    obj = obj[path];
  }
  if (typeof value === 'undefined') {
    delete obj[paths[paths.length - 1]];
  } else {
    obj[paths[paths.length - 1]] = value;
  }
}

export function commitServerChanges(
  serverData: AttributeMap,
  objectCache: ObjectCache,
  changes: AttributeMap
) {
  const ParseObject = CoreManager.getParseObject();
  for (const attr in changes) {
    // Skip properties from prototype chain
    if (!Object.prototype.hasOwnProperty.call(changes, attr)) {
      continue;
    }
    // Skip dangerous keys that could pollute prototypes
    if (isDangerousKey(attr)) {
      continue;
    }
    const val = changes[attr];
    nestedSet(serverData, attr, val);
    if (
      val &&
      typeof val === 'object' &&
      !(val instanceof ParseObject) &&",0
"type ToJSON<T> = {
  [K in keyof T]: Encode<T[K]>;
};

// Mapping of class names to constructors, so we can populate objects from the
// server with appropriate subclasses of ParseObject
const classMap: AttributeMap = Object.create(null);

// Global counter for generating unique Ids for non-single-instance objects
let objectCount = 0;
// On web clients, objects are single-instance: any two objects with the same Id
// will have the same attributes. However, this may be dangerous default
// behavior in a server scenario",0
"jest.dontMock('../decode');
jest.dontMock('../encode');
jest.dontMock('../CoreManager');
jest.dontMock('../isDangerousKey');
jest.dontMock('../ObjectStateMutations');
jest.dontMock('../ParseFile');
jest.dontMock('../ParseGeoPoint');
jest.dontMock('../ParseOp');
jest.dontMock('../ParseRelation');
jest.dontMock('../TaskQueue');

const mockObject = function (className) {
  this.className = className;
};
mockObject.registerSubclass = function () { };
jest.setMock('../ParseObject', mockObject);
const CoreManager = require('../CoreManager').default;
CoreManager.setParseObject(mockObject);

const ObjectStateMutations = require('../ObjectStateMutations');
const ParseOps = require('../ParseOp');
const TaskQueue = require('../TaskQueue').default;

describe('ObjectStateMutations', () => {
  it('can apply server data', () => {
    const serverData = {};
    ObjectStateMutations.setServerData(serverData, { counter: 12 });
    expect(serverData).toEqual({ counter: 12 });
    ObjectStateMutations.setServerData(serverData, { counter: undefined });
    expect(serverData).toEqual({});
  });

  it('can set a pending op', () => {
    let pendingOps = [{}];
    const op = new ParseOps.IncrementOp(1);
    ObjectStateMutations.setPendingOp(pendingOps, 'counter', op);
    expect(pendingOps).toEqual([{ counter: op }]);

    pendingOps = [{}, {}];
    ObjectStateMutations.setPendingOp(pendingOps, 'counter', op);
    expect(pendingOps).toEqual([{}, { counter: op }]);

    ObjectStateMutations.setPendingOp(pendingOps, 'counter', null);
    expect(pendingOps).toEqual([{}, {}]);
  });

  it('can push a new pending state', () => {
    const pendingOps = [{}];
    ObjectStateMutations.pushPendingState(pendingOps);
    expect(pendingOps).toEqual([{}, {}]);

    ObjectStateMutations.pushPendingState(pendingOps);
    expect(pendingOps).toEqual([{}, {}, {}]);
  });

  it('can pop a pending state', () => {
    let pendingOps = [{}];
    let first = pendingOps[0];
    expect(ObjectStateMutations.popPendingState(pendingOps)).toBe(first);
    expect(pendingOps).toEqual([{}]);

    const op = new ParseOps.IncrementOp(1);
    pendingOps = [{ counter: op }, {}, {}];
    first = pendingOps[0];
    expect(ObjectStateMutations.popPendingState(pendingOps)).toBe(first);
    expect(pendingOps).toEqual([{}, {}]);
  });

  it('can merge the first op set into the next', () => {
    let pendingOps = [{ counter: new ParseOps.SetOp(1), name: new ParseOps.SetOp('foo') }, {}];
    ObjectStateMutations.mergeFirstPendingState(pendingOps);
    expect(pendingOps).toEqual([
      { counter: new ParseOps.SetOp(1), name: new ParseOps.SetOp('foo') },
    ]);

    pendingOps = [{ counter: new ParseOps.SetOp(1) }, { counter: new ParseOps.IncrementOp(1) }];
    ObjectStateMutations.mergeFirstPendingState(pendingOps);
    expect(pendingOps).toEqual([{ counter: new ParseOps.SetOp(2) }]);
  });

  it('can estimate an attribute value', () => {
    const serverData = { counter: 12 };
    const pendingOps = [{ counter: new ParseOps.IncrementOp(2), name: new ParseOps.SetOp('foo') }];
    expect(
      ObjectStateMutations.estimateAttribute(
        serverData,
        pendingOps,
        { className: 'someClass', id: 'someId' },
        'counter'
      )
    ).toBe(14);
    expect(
      ObjectStateMutations.estimateAttribute(
        serverData,
        pendingOps,
        { className: 'someClass', id: 'someId' },
        'name'
      )
    ).toBe('foo');

    pendingOps.push({
      counter: new ParseOps.IncrementOp(1),
      name: new ParseOps.SetOp('override'),
    });
    expect(
      ObjectStateMutations.estimateAttribute(
        serverData,
        pendingOps,
        { className: 'someClass', id: 'someId' },
        'counter'
      )
    ).toBe(15);
    expect(
      ObjectStateMutations.estimateAttribute(
        serverData,
        pendingOps,
        { className: 'someClass', id: 'someId' },
        'name'
      )
    ).toBe('override');

    pendingOps.push({ likes: new ParseOps.RelationOp([], []) });
    const relation = ObjectStateMutations.estimateAttribute(
      serverData,
      pendingOps,
      { className: 'someClass', id: 'someId' },
      'likes'
    );
    expect(relation.parent.id).toBe('someId');
    expect(relation.parent.className).toBe('someClass');
    expect(relation.key).toBe('likes');
  });

  it('can estimate all attributes', () => {
    const serverData = { counter: 12 };
    const pendingOps = [{ counter: new ParseOps.IncrementOp(2), name: new ParseOps.SetOp('foo') }];
    expect(
      ObjectStateMutations.estimateAttributes(serverData, pendingOps, 'someClass', 'someId')
    ).toEqual({
      counter: 14,
      name: 'foo',
    });

    pendingOps.push({
      counter: new ParseOps.IncrementOp(1),
      name: new ParseOps.SetOp('override'),
    });
    expect(
      ObjectStateMutations.estimateAttributes(serverData, pendingOps, 'someClass', 'someId')
    ).toEqual({
      counter: 15,
      name: 'override',
    });

    pendingOps.push({ likes: new ParseOps.RelationOp([], []) });
    const attributes = ObjectStateMutations.estimateAttributes(serverData, pendingOps, {
      className: 'someClass',
      id: 'someId',
    });
    expect(attributes.likes.parent.id).toBe('someId');
    expect(attributes.likes.parent.className).toBe('someClass');
    expect(attributes.likes.key).toBe('likes');
  });

  it('can estimate attributes for nested documents', () => {
    let serverData = { objectField: { counter: 10, letter: 'a' } };
    let pendingOps = [{ 'objectField.counter': new ParseOps.IncrementOp(2) }];
    expect(
      ObjectStateMutations.estimateAttributes(serverData, pendingOps, 'someClass', 'someId')
    ).toEqual({
      objectField: {
        counter: 12,
        letter: 'a',
      },
    });
    pendingOps = [{ 'objectField.counter': new ParseOps.SetOp(20) }];
    expect(
      ObjectStateMutations.estimateAttributes(serverData, pendingOps, 'someClass', 'someId')
    ).toEqual({
      objectField: {
        counter: 20,
        letter: 'a',
      },
    });
    serverData = {};
    pendingOps = [{ 'objectField.subField.subField.counter': new ParseOps.IncrementOp(20) }];
    expect(
      ObjectStateMutations.estimateAttributes(serverData, pendingOps, 'someClass', 'someId')
    ).toEqual({
      objectField: {
        subField: {
          subField: {
            counter: 20,
          },
        },
      },
    });
  });

  it('can estimate attributes for nested array documents', () => {
    // Test without initial value
    let serverData = { _id: 'someId', className: 'bug' };
    let pendingOps = [{ 'items.0.count': new ParseOps.IncrementOp(1) }];
    expect(
      ObjectStateMutations.estimateAttributes(serverData, pendingOps, 'someClass', 'someId')
    ).toEqual({
      _id: 'someId',
      items: [{ count: 1 }],
      className: 'bug',
    });

    // Test one level nested
    serverData = {
      _id: 'someId',
      items: [
        { value: 'a', count: 5 },
        { value: 'b', count: 1 },
      ],
      className: 'bug',
      number: 2,
    };
    pendingOps = [{ 'items.0.count': new ParseOps.IncrementOp(1) }];
    expect(
      ObjectStateMutations.estimateAttributes(serverData, pendingOps, 'someClass', 'someId')
    ).toEqual({
      _id: 'someId',
      items: [
        { value: 'a', count: 6 },
        { value: 'b', count: 1 },
      ],
      className: 'bug',
      number: 2,
    });

    // Test multiple level nested fields
    serverData = {
      _id: 'someId',
      items: [
        { value: { count: 54 }, count: 5 },
        { value: 'b', count: 1 },
      ],
      className: 'bug',
      number: 2,
    };
    pendingOps = [{ 'items.0.value.count': new ParseOps.IncrementOp(6) }];
    expect(
      ObjectStateMutations.estimateAttributes(serverData, pendingOps, 'someClass', 'someId')
    ).toEqual({
      _id: 'someId',
      items: [
        { value: { count: 60 }, count: 5 },
        { value: 'b', count: 1 },
      ],
      className: 'bug',
      number: 2,
    });
  });

  it('can commit changes from the server', () => {
    const serverData = {};
    const objectCache = {};
    ObjectStateMutations.commitServerChanges(serverData, objectCache, {
      name: 'foo',
      data: { count: 5 },
    });
    expect(serverData).toEqual({ name: 'foo', data: { count: 5 } });
    expect(objectCache).toEqual({ data: '{""count"":5}' });
  });

  it('can commit nested changes from the server', () => {
    const serverData = {};
    const objectCache = {};
    ObjectStateMutations.commitServerChanges(serverData, objectCache, {
      'name.foo': 'bar',
      data: { count: 5 },
    });
    expect(serverData).toEqual({ name: { foo: 'bar' }, data: { count: 5 } });
    expect(objectCache).toEqual({ data: '{""count"":5}' });
  });

  it('can commit dot notation array changes from the server', () => {
    const serverData = {
      items: [
        { value: 'a', count: 5 },
        { value: 'b', count: 1 },
      ],
    };
    ObjectStateMutations.commitServerChanges(
      serverData,
      {},
      {
        'items.0.count': 15,
        'items.1.count': 4,
      }
    );
    expect(serverData).toEqual({
      items: [
        { value: 'a', count: 15 },
        { value: 'b', count: 4 },
      ],
    });
  });

  it('can commit dot notation array changes from the server to empty serverData', () => {
    const serverData = {};
    ObjectStateMutations.commitServerChanges(
      serverData,
      {},
      {
        'items.0.count': 15,
        'items.1.count': 4,
      }
    );
    expect(serverData).toEqual({ items: [{ count: 15 }, { count: 4 }] });
  });

  it('can commit nested json array changes from the server to empty serverData', () => {
    const serverData = {};
    const objectCache = {};
    ObjectStateMutations.commitServerChanges(serverData, objectCache, {
      items: { '0': { count: 20 }, '1': { count: 5 } },
    });
    // Should not transform
    expect(serverData).toEqual({ items: { '0': { count: 20 }, '1': { count: 5 } } });
    expect(objectCache).toEqual({ items: '{""0"":{""count"":20},""1"":{""count"":5}}' });
  });

  it('can commit json array with PushStatus offset fields', () => {
    const serverData = {};
    const objectCache = {};
    ObjectStateMutations.commitServerChanges(serverData, objectCache, {
      sentPerUTCOffset: { '1': { count: 20 } },
      failedPerUTCOffset: { '5': { count: 25 } },
    });
    // Should not transform to an array
    expect(serverData).toEqual({
      sentPerUTCOffset: { '1': { count: 20 } },
      failedPerUTCOffset: { '5': { count: 25 } },
    });
    expect(objectCache).toEqual({
      sentPerUTCOffset: '{""1"":{""count"":20}}',
      failedPerUTCOffset: '{""5"":{""count"":25}}',
    });
  });

  it('can generate a default state for implementations', () => {
    expect(ObjectStateMutations.defaultState()).toEqual({
      serverData: {},
      pendingOps: [{}],
      objectCache: {},
      tasks: new TaskQueue(),
      existed: false,
    });
  });

  describe('Prototype Pollution Protection', () => {
    beforeEach(() => {
      // Clear any pollution before each test
      delete Object.prototype.polluted;
      delete Object.prototype.malicious;
    });

    afterEach(() => {
      // Clean up after tests
      delete Object.prototype.polluted;
      delete Object.prototype.malicious;
    });

    it('should not pollute Object.prototype in estimateAttributes with malicious attribute names', () => {
      const testObj = {};

      const serverData = {};
      const pendingOps = [
        {
          __proto__: new ParseOps.SetOp({ polluted: 'yes' }),
          constructor: new ParseOps.SetOp({ malicious: 'data' }),
        },
      ];

      ObjectStateMutations.estimateAttributes(serverData, pendingOps, {
        className: 'TestClass',
        id: 'test123',
      });

      // Verify Object.prototype was not polluted
      expect(testObj.polluted).toBeUndefined();
      expect(testObj.malicious).toBeUndefined();
      expect({}.polluted).toBeUndefined();
      expect({}.malicious).toBeUndefined();
    });

    it('should not pollute Object.prototype in commitServerChanges with nested __proto__ path', () => {
      const testObj = {};

      const serverData = {};
      const objectCache = {};
      ObjectStateMutations.commitServerChanges(serverData, objectCache, {
        '__proto__.polluted': 'exploited',
      });

      // Verify Object.prototype was not polluted
      expect(testObj.polluted).toBeUndefined();
      expect({}.polluted).toBeUndefined();
      expect(Object.prototype.polluted).toBeUndefined();
    });
  });
});",0
"CoreManager.setRESTController(RESTController);
CoreManager.setEventuallyQueue(EventuallyQueue);
CoreManager.setInstallationController({
  currentInstallationId() {
    return Promise.resolve('iid');
  },
  currentInstallation() { },
  updateInstallationOnDisk() { },
});
CoreManager.set('APPLICATION_ID', 'A');
CoreManager.set('JAVASCRIPT_KEY', 'B');
CoreManager.set('MASTER_KEY', 'C');
CoreManager.set('VERSION', 'V');
// Register our mocks
jest.spyOn(CoreManager, 'getParseQuery').mockImplementation(() => mockQuery);
jest.spyOn(CoreManager, 'getEventuallyQueue').mockImplementation(() => EventuallyQueue);
jest.spyOn(CoreManager, 'getParseUser').mockImplementation(() => require('../ParseUser').default);

const { SetOp, UnsetOp, IncrementOp } = require('../ParseOp');

describe('ParseObject', () => {
  beforeEach(() => {
    ParseObject.enableSingleInstance();
    jest.clearAllMocks();
  });

  it('is initially created with no Id', () => {
    const o = new ParseObject('Item');
    expect(o.id).toBe(undefined);
    expect(o._localId).toBe(undefined);
    expect(o.dirty()).toBe(true);
  });

  it('can be created with initial attributes', () => {
    const o = new ParseObject({
      className: 'Item',
      value: 12,
    });
    expect(o.className).toBe('Item');
    expect(o.attributes).toEqual({ value: 12 });
  });

  it('can be created with attributes parameter', () => {
    const o = new ParseObject('Item', {
      value: 12,
    });
    expect(o.className).toBe('Item');
    expect(o.attributes).toEqual({ value: 12 });
  });

  it('can ignore setting invalid key', () => {
    const o = new ParseObject('Item');
    const o2 = o.set(1234);
    expect(o).toEqual(o2);
  });

  it('can ignore setting createdAt', () => {
    const o = new ParseObject('Item');
    o.set('createdAt', '1234');
    expect(o.get('createdAt')).toEqual(undefined);
  });

  it('can handle setting relationOp', () => {
    const child = new ParseObject('Child');
    child.id = 'child1234';
    const relationOpJSON = { __op: 'AddRelation', objects: [child] };
    const o = new ParseObject('Item');
    o.set('friends', relationOpJSON);
    o._handleSaveResponse({});
    expect(o.get('friends').targetClassName).toBe('Child');
  });

  it('cannot create with invalid attributes', () => {
    expect(() => {
      new ParseObject({
        className: 'Item',
        'invalid#name': 'foo',
      });
    }).toThrow(""Can't create an invalid Parse Object"");
  });

  it('can ignore validation if ignoreValidation option is provided', () => {
    class ValidatedObject extends ParseObject {
      validate(attrs) {
        if (Object.hasOwn(attrs, 'badAttr')) {
          return 'you have the bad attr';
        }
      }
    }

    const o = new ValidatedObject(
      {
        className: 'Item',
        value: 12,
        badAttr: true,
      },
      { ignoreValidation: true }
    );

    expect(o.attributes.value).toBe(12);
    expect(o.attributes.badAttr).toBe(true);
  });

  it('can be inflated from server JSON', () => {
    const date = new Date();
    const json = {
      className: 'Item',
      createdAt: '2013-12-14T04:51:19Z',
      objectId: 'I1',
      size: 'medium',
      date: date,
    };
    const o = ParseObject.fromJSON(json);
    expect(o.className).toBe('Item');
    expect(o.id).toBe('I1');
    expect(o.attributes).toEqual({
      size: 'medium',
      createdAt: new Date(Date.UTC(2013, 11, 14, 4, 51, 19)),
      updatedAt: new Date(Date.UTC(2013, 11, 14, 4, 51, 19)),
      date,
    });
    expect(o.dirty()).toBe(false);
    expect(o.get('date')).toBeInstanceOf(Date);
  });

  it('can be dirty with fromJSON', () => {
    const date = new Date();
    const json = {
      className: 'Item',
      createdAt: '2013-12-14T04:51:19Z',
      objectId: 'I1',
      size: 'medium',
      date: date,
    };
    const o = ParseObject.fromJSON(json, false, true);
    expect(o.className).toBe('Item');
    expect(o.id).toBe('I1');
    expect(o.attributes).toEqual({
      size: 'medium',
      createdAt: new Date(Date.UTC(2013, 11, 14, 4, 51, 19)),
      updatedAt: new Date(Date.UTC(2013, 11, 14, 4, 51, 19)),
      date,
    });
    expect(o.dirty()).toBe(true);
    expect(o.dirtyKeys()).toEqual(['size', 'date']);
  });

  it('can override old data when inflating from the server', () => {
    const o = ParseObject.fromJSON({
      className: 'Item',
      objectId: 'I01',
      size: 'small',
    });
    expect(o.get('size')).toBe('small');
    const o2 = ParseObject.fromJSON(
      {
        className: 'Item',
        objectId: 'I01',
        disabled: true,
      },
      true
    );
    expect(o.get('disabled')).toBe(true);
    expect(o.get('size')).toBe(undefined);
    expect(o.has('size')).toBe(false);

    expect(o2.get('disabled')).toBe(true);
    expect(o2.get('size')).toBe(undefined);
    expect(o2.has('size')).toBe(false);
  });

  it('is given a local Id once dirtied', () => {
    const o = new ParseObject('Item');
    o.set('size', 'small');
    expect(o._localId).toBeTruthy();
  });

  it('has a read-only attributes property', () => {
    const o = new ParseObject('Item');
    o.set('size', 'small');
    expect(function () {
      o.attributes.size = 'large';
    }).toThrow();
  });

  it('exposes read-only createdAt and updatedAt', () => {
    const o = new ParseObject('Item');
    expect(o.get('createdAt')).toBe(undefined);
    expect(o.get('updatedAt')).toBe(undefined);
    const created = new Date();
    const updated = new Date();
    o._finishFetch({
      objectId: 'O1',
      createdAt: { __type: 'Date', iso: created.toISOString() },
      updatedAt: { __type: 'Date', iso: updated.toISOString() },
    });
    expect(o.get('createdAt')).toEqual(created);
    expect(o.get('updatedAt')).toEqual(updated);
    expect(o.createdAt).toEqual(created);
    expect(o.updatedAt).toEqual(updated);
  });

  it('fetch ACL from serverData', () => {
    const ACL = new ParseACL({ user1: { read: true } });
    const o = new ParseObject('Item');
    o._finishFetch({
      objectId: 'O1',
      ACL: { user1: { read: true } },
    });
    expect(o.getACL()).toEqual(ACL);
  });

  it('encodes ACL from json', () => {
    const ACL = new ParseACL({ user1: { read: true } });
    const o = new ParseObject('Item');
    o.set({ ACL: ACL.toJSON() });
    expect(o.getACL()).toEqual(ACL);
  });

  it('can be rendered to JSON', () => {
    let o = new ParseObject('Item');
    o.set({
      size: 'large',
      inStock: 18,
    });
    expect(o.toJSON()).toEqual({
      size: 'large',
      inStock: 18,
    });
    o = new ParseObject('Item');
    o._finishFetch({
      objectId: 'O2',
      size: 'medium',
      inStock: 12,
    });
    expect(o.id).toBe('O2');
    expect(o.toJSON()).toEqual({
      objectId: 'O2',
      size: 'medium',
      inStock: 12,
    });
  });

  it('encodes createdAt and updatedAt fields as strings', () => {
    const o = ParseObject.fromJSON({
      id: 'hasDates',
      className: 'Item',
      createdAt: {
        __type: 'Date',
        iso: new Date(Date.UTC(2015, 0, 1)).toJSON(),
      },
      updatedAt: {
        __type: 'Date',
        iso: new Date(Date.UTC(2015, 0, 1)).toJSON(),
      },
      foo: 'bar',
    });
    expect(o.toJSON()).toEqual({
      id: 'hasDates',
      createdAt: '2015-01-01T00:00:00.000Z',
      updatedAt: '2015-01-01T00:00:00.000Z',
      foo: 'bar',
    });
  });

  it('can convert to a pointer', () => {
    const o = new ParseObject('Item');
    expect(function () {
      o.toPointer();
    }).toThrow('Cannot create a pointer to an unsaved ParseObject');
    o.id = 'anObjectId';
    expect(o.toPointer()).toEqual({
      __type: 'Pointer',
      className: 'Item',
      objectId: 'anObjectId',
    });
  });

  it('can convert to a offline pointer', () => {
    const o = new ParseObject('Item');
    o.id = 'AnObjectId';
    expect(function () {
      o.toOfflinePointer();
    }).toThrow('Cannot create a offline pointer to a saved ParseObject');
    o._localId = 'local1234';
    expect(o.toOfflinePointer()).toEqual({
      __type: 'Object',
      className: 'Item',
      _localId: 'local1234',
    });
  });

  it('can test equality against another ParseObject', () => {
    const a = new ParseObject('Item');
    expect(a.equals(a)).toBe(true);
    const b = new ParseObject('Item');
    expect(a.equals(b)).toBe(false);
    expect(b.equals(a)).toBe(false);
    a.id = 'anObjectId';
    b.id = 'anObjectId';
    expect(a.equals(b)).toBe(true);
    expect(b.equals(a)).toBe(true);
  });

  it('can set a field', () => {
    const o = new ParseObject('Person');
    expect(o.attributes).toEqual({});
    o.set('name', 'Will');
    expect(o.attributes).toEqual({ name: 'Will' });
    expect(o.op('name') instanceof SetOp).toBe(true);
    expect(o.dirtyKeys()).toEqual(['name']);
    expect(o.dirty()).toBe(true);
    expect(o.dirty('name')).toBe(true);
    expect(o._getSaveJSON()).toEqual({ name: 'Will' });

    // set multiple fields at once
    o.set({ name: 'William', behavior: 'formal' });
    expect(o.attributes).toEqual({ name: 'William', behavior: 'formal' });
  });

  it('can set id with the objectId attribute', () => {
    const o = new ParseObject('Person');
    expect(o.attributes).toEqual({});
    expect(o.id).toBe(undefined);
    o.set({ objectId: 'oid' });
    expect(o.attributes).toEqual({});
    expect(o.id).toBe('oid');
  });

  it('can get an escaped version of a field', () => {
    const o = new ParseObject('Person');
    o.set('age', 28);
    o.set('phoneProvider', 'AT&T');
    o.set('objectField', { toString: 'hacking' });
    expect(o.escape('notSet')).toBe('');
    expect(o.escape('age')).toBe('28');
    expect(o.escape('phoneProvider')).toBe('AT&amp;T');
    expect(o.escape('objectField')).toBe('');
  });

  it('can tell if it has an attribute', () => {
    const o = new ParseObject('Person');
    o.set('age', 28);
    expect(o.has('name')).toBe(false);
    expect(o.has('age')).toBe(true);
  });

  it('can tell if a field is dirty', () => {
    const o = new ParseObject('Person');
    o._finishFetch({
      objectId: 'p99',
      age: 28,
      human: true,
      objectField: { foo: 'bar' },
    });
    expect(o.dirty()).toBe(false);
    expect(o.dirty('age')).toBe(false);
    expect(o.dirty('human')).toBe(false);
    expect(o.dirty('unset')).toBe(false);
    expect(o.dirty('objectField')).toBe(false);
    o.set('human', false);
    o.set('objectField', { foo: 'baz' });
    expect(o.dirty()).toBe(true);
    expect(o.dirty('age')).toBe(false);
    expect(o.dirty('human')).toBe(true);
    expect(o.dirty('unset')).toBe(false);
    expect(o.dirty('objectField')).toBe(true);
  });

  it('can unset a field', () => {
    const o = new ParseObject('Person');
    o.id = 'anObjectId';
    o.set('name', 'Will');
    expect(o.attributes).toEqual({ name: 'Will' });
    o.unset('name');
    expect(o.attributes).toEqual({});
    // Even when you unset an unsaved set, it's still dirty
    expect(o.op('name') instanceof UnsetOp).toBe(true);
    expect(o.dirty()).toBe(true);
    expect(o.dirtyKeys()).toEqual(['name']);

    const o2 = new ParseObject('Person');
    o2._finishFetch({
      objectId: 'P1',
      name: 'Will',
    });
    expect(o2.attributes).toEqual({ name: 'Will' });
    o2.unset('name');
    expect(o2.attributes).toEqual({});
  });

  it('can clear all fields', () => {
    const o = new ParseObject('Person');
    o._finishFetch({
      objectId: 'P95',
      createdAt: { __type: 'Date', iso: new Date().toISOString() },
      updatedAt: { __type: 'Date', iso: new Date().toISOString() },
    });
    o.set({ a: 'a', b: 'b', c: 'c' });
    expect(o.dirty('a')).toBe(true);
    expect(o.dirty('b')).toBe(true);
    expect(o.dirty('c')).toBe(true);
    o.clear();
    expect(o.get('a')).toBe(undefined);
    expect(o.get('b')).toBe(undefined);
    expect(o.get('c')).toBe(undefined);
  });

  it('can increment a field', () => {
    const o = new ParseObject('Person');
    o.increment('age');
    expect(o.attributes).toEqual({ age: 1 });
    expect(o.op('age') instanceof IncrementOp).toBe(true);
    expect(o.dirtyKeys()).toEqual(['age']);
    expect(o._getSaveJSON()).toEqual({
      age: { __op: 'Increment', amount: 1 },
    });

    o.increment('age', 4);
    expect(o.attributes).toEqual({ age: 5 });
    expect(o._getSaveJSON()).toEqual({
      age: { __op: 'Increment', amount: 5 },
    });

    expect(o.increment.bind(o, 'age', 'four')).toThrow('Cannot increment by a non-numeric amount.');
    expect(o.increment.bind(o, 'age', null)).toThrow('Cannot increment by a non-numeric amount.');
    expect(o.increment.bind(o, 'age', { amount: 4 })).toThrow(
      'Cannot increment by a non-numeric amount.'
    );

    o.set('age', 30);
    o.increment('age');
    expect(o.attributes).toEqual({ age: 31 });
    expect(o._getSaveJSON()).toEqual({
      age: 31,
    });

    const o2 = new ParseObject('Person');
    o2._finishFetch({
      objectId: 'P2',
      age: 40,
    });
    expect(o2.attributes).toEqual({ age: 40 });
    o2.increment('age');
    expect(o2.attributes).toEqual({ age: 41 });
  });

  it('can decrement a field', () => {
    const o = new ParseObject('Person');
    o.decrement('age');
    expect(o.attributes).toEqual({ age: -1 });
    expect(o.op('age') instanceof IncrementOp).toBe(true);
    expect(o.dirtyKeys()).toEqual(['age']);
    expect(o._getSaveJSON()).toEqual({
      age: { __op: 'Increment', amount: -1 },
    });

    o.decrement('age', 4);
    expect(o.attributes).toEqual({ age: -5 });
    expect(o._getSaveJSON()).toEqual({
      age: { __op: 'Increment', amount: -5 },
    });

    expect(o.decrement.bind(o, 'age', 'four')).toThrow('Cannot decrement by a non-numeric amount.');
    expect(o.decrement.bind(o, 'age', null)).toThrow('Cannot decrement by a non-numeric amount.');
    expect(o.decrement.bind(o, 'age', { amount: 4 })).toThrow(
      'Cannot decrement by a non-numeric amount.'
    );

    o.set('age', 30);
    o.decrement('age');
    expect(o.attributes).toEqual({ age: 29 });
    expect(o._getSaveJSON()).toEqual({
      age: 29,
    });

    const o2 = new ParseObject('Person');
    o2._finishFetch({
      objectId: 'ABC123',
      age: 40,
    });
    expect(o2.attributes).toEqual({ age: 40 });
    o2.decrement('age');
    expect(o2.attributes).toEqual({ age: 39 });
  });

  it('can set nested field', () => {
    const o = new ParseObject('Person');
    o._finishFetch({
      objectId: 'setNested',
      objectField: {
        number: 5,
        letter: 'a',
      },
      otherField: {},
    });

    expect(o.attributes).toEqual({
      objectField: { number: 5, letter: 'a' },
      otherField: {},
    });
    o.set('otherField', { hello: 'world' });
    o.set('objectField.number', 20);

    expect(o.attributes).toEqual({
      objectField: { number: 20, letter: 'a' },
      otherField: { hello: 'world' },
    });
    expect(o.op('objectField.number') instanceof SetOp).toBe(true);
    expect(o.dirtyKeys()).toEqual(['otherField', 'objectField.number', 'objectField']);
    expect(o._getSaveJSON()).toEqual({
      'objectField.number': 20,
      otherField: { hello: 'world' },
    });
    expect(o.toJSON()).toEqual({
      objectField: {
        number: 20,
        letter: 'a',
      },
      otherField: { hello: 'world' },
      objectId: 'setNested',
    });
  });

  it('can set multiple nested fields (regression test for #1450)', () => {
    const o = new ParseObject('Person');
    o._finishFetch({
      objectId: 'setNested2_1450',
      objectField: {
        number: 5,
        letter: 'a',
        nested: {
          number: 0,
          letter: 'b',
        },
      },
    });

    expect(o.attributes).toEqual({
      objectField: { number: 5, letter: 'a', nested: { number: 0, letter: 'b' } },
    });
    o.set('objectField.number', 20);
    o.set('objectField.letter', 'b');
    o.set('objectField.nested.number', 1);
    o.set('objectField.nested.letter', 'c');

    expect(o.attributes).toEqual({
      objectField: { number: 20, letter: 'b', nested: { number: 1, letter: 'c' } },
    });
    expect(o.op('objectField.number') instanceof SetOp).toBe(true);
    expect(o.dirtyKeys()).toEqual([
      'objectField.number',
      'objectField.letter',
      'objectField.nested.number',
      'objectField.nested.letter',
      'objectField',
    ]);
    expect(o._getSaveJSON()).toEqual({
      'objectField.number': 20,
      'objectField.letter': 'b',
      'objectField.nested.number': 1,
      'objectField.nested.letter': 'c',
    });

    o.revert('objectField.nested.number');
    o.revert('objectField.nested.letter');
    expect(o._getSaveJSON()).toEqual({
      'objectField.number': 20,
      'objectField.letter': 'b',
    });
    expect(o.attributes).toEqual({
      objectField: { number: 20, letter: 'b', nested: { number: 0, letter: 'b' } },
    });

    // Also test setting new root fields using the dot notation
    o.set('objectField2.number', 0);
    expect(o._getSaveJSON()).toEqual({
      'objectField.number': 20,
      'objectField.letter': 'b',
      'objectField2.number': 0,
    });
    expect(o.attributes).toEqual({
      objectField: { number: 20, letter: 'b', nested: { number: 0, letter: 'b' } },
      objectField2: { number: 0 },
    });
  });

  it('can increment a nested field', () => {
    const o = new ParseObject('Person');
    o._finishFetch({
      objectId: 'incNested',
      objectField: {
        number: 5,
        letter: 'a',
      },
    });

    expect(o.attributes).toEqual({
      objectField: { number: 5, letter: 'a' },
    });
    o.increment('objectField.number');

    expect(o.attributes).toEqual({
      objectField: { number: 6, letter: 'a' },
    });
    expect(o.op('objectField.number') instanceof IncrementOp).toBe(true);
    expect(o.dirtyKeys()).toEqual(['objectField.number', 'objectField']);
    expect(o._getSaveJSON()).toEqual({
      'objectField.number': {
        __op: 'Increment',
        amount: 1,
      },
    });

    // Nested objects only return values changed
    o._handleSaveResponse({
      objectId: 'incNested',
      objectField: {
        number: 6,
      },
    });
    expect(o.get('objectField').number).toEqual(6);
    expect(o.get('objectField').letter).toEqual('a');
  });

  it('can add elements to an array field', () => {
    const o = new ParseObject('Schedule');
    o.add('available', 'Monday');
    o.add('available', 'Wednesday');
    expect(o.get('available')).toEqual(['Monday', 'Wednesday']);

    o.set('colors', ['red', 'green']);
    o.add('colors', 'blue');
    expect(o.get('colors')).toEqual(['red', 'green', 'blue']);

    o._handleSaveResponse({
      objectId: 'S1',
      available: ['Monday', 'Wednesday'],
      colors: ['red', 'green', 'blue'],
    });

    o.addUnique('available', 'Thursday');
    o.addUnique('available', 'Monday');
    expect(o.get('available')).toEqual(['Monday', 'Wednesday', 'Thursday']);
  });

  it('can add elements to an array field in batch mode', () => {
    const o = new ParseObject('Schedule');
    o.addAll('available', ['Monday', 'Wednesday']);
    expect(o.get('available')).toEqual(['Monday', 'Wednesday']);

    o.set('colors', ['red']);
    o.addAll('colors', ['green', 'blue']);
    expect(o.get('colors')).toEqual(['red', 'green', 'blue']);

    o._handleSaveResponse({
      objectId: 'S1',
      available: ['Monday', 'Wednesday'],
      colors: ['red', 'green', 'blue'],
    });

    o.addAllUnique('available', ['Thursday', 'Monday']);
    expect(o.get('available').length).toEqual(3);
  });

  it('can remove elements from an array field', () => {
    const o = new ParseObject('Schedule');
    o.set('available', ['Monday', 'Tuesday']);
    o.remove('available', 'Tuesday');
    o.remove('available', 'Saturday');
    expect(o.get('available')).toEqual(['Monday']);

    o._handleSaveResponse({
      objectId: 'S2',
      available: ['Monday'],
    });

    o.remove('available', 'Monday');
    o.remove('available', 'Tuesday');
    expect(o.get('available')).toEqual([]);
  });

  it('can remove elements from an array field in batch mode', () => {
    const o = new ParseObject('Schedule');
    o.set('available', ['Monday', 'Tuesday']);
    o.removeAll('available', ['Tuesday', 'Saturday']);
    expect(o.get('available')).toEqual(['Monday']);

    o._handleSaveResponse({
      objectId: 'S2',
      available: ['Monday'],
    });

    o.removeAll('available', ['Monday', 'Tuesday']);
    expect(o.get('available')).toEqual([]);
  });

  it('can chain sets', () => {
    const o = new ParseObject('Person');
    o.set('developer', true).set('platform', 'web');
    expect(o.attributes).toEqual({
      developer: true,
      platform: 'web',
    });
  });

  it('can set and retrieve ACLs', () => {
    const acl = new ParseACL();
    const o = new ParseObject('Listing');
    o.setACL(acl);
    expect(o.get('ACL')).toBe(acl);
    expect(o.getACL()).toBe(acl);
  });

  it('can manipulate relations on fields', () => {
    const o = new ParseObject('Person');
    o.id = 'AA';
    o.set('age', 38);
    expect(o.relation.bind(o, 'age')).toThrow('Called relation() on non-relation field age');
    const rel = o.relation('friends');
    expect(rel.parentClass).toBe('Person');
    expect(rel.parentId).toBe('AA');
    expect(rel.key).toBe('friends');
    const friend = new ParseObject('Person');
    friend.id = 'BB';
    rel.add(friend);
    expect(rel.targetClassName).toBe('Person');
  });

  it('can be cloned with relation (#381)', () => {
    const relationJSON = { __type: 'Relation', className: 'Bar' };
    const o = ParseObject.fromJSON({
      objectId: '7777777777',
      className: 'Foo',
      aRelation: relationJSON,
    });
    const o2 = o.clone();
    expect(o2._getSaveJSON().aRelation).toEqual(relationJSON);
  });

  it('can get relation from relation field', () => {
    const relationJSON = { __type: 'Relation', className: 'Bar' };
    const o = ParseObject.fromJSON({
      objectId: '999',
      className: 'Foo',
      aRelation: relationJSON,
    });
    const rel = o.relation('aRelation');
    expect(rel.toJSON()).toEqual(relationJSON);
  });

  it('can detect dirty object children', () => {
    const o = new ParseObject('Person');
    o._finishFetch({
      objectId: 'dirtyObj',
      obj: { a: 12 },
      location: {
        __type: 'GeoPoint',
        latitude: 20,
        longitude: 20,
      },
    });
    expect(o.dirty()).toBe(false);
    o.get('obj').b = 21;
    expect(o.get('obj')).toEqual({
      a: 12,
      b: 21,
    });
    expect(o.dirty()).toBe(true);
    expect(o.dirtyKeys()).toEqual(['obj']);
    expect(o._getSaveJSON()).toEqual({
      obj: {
        a: 12,
        b: 21,
      },
    });
    delete o.get('obj').b;
    expect(o.dirty()).toBe(false);
    expect(o.dirtyKeys()).toEqual([]);
    const loc = o.get('location');
    expect(loc instanceof ParseGeoPoint).toBe(true);
    expect(loc.latitude).toBe(20);
    expect(loc.longitude).toBe(20);
    loc.latitude = 30;
    expect(loc.latitude).toBe(30);
    expect(o.dirty()).toBe(true);
    expect(o.dirtyKeys()).toEqual(['location']);

    const p = new ParseObject('Parent');
    p.set('children', [o]);
    expect(p.dirtyKeys()).toEqual(['children']);
  });

  it('can validate attributes', () => {
    const o = new ParseObject('Listing');
    expect(
      o.validate({
        ACL: 'not an acl',
      })
    ).toEqual(new ParseError(ParseError.OTHER_CAUSE, 'ACL must be a Parse ACL.'));

    expect(
      o.validate({
        'invalid!key': 12,
      })
    ).toEqual(new ParseError(ParseError.INVALID_KEY_NAME, 'Invalid key name: invalid!key'));

    expect(
      o.validate({
        noProblem: 'here',
      })
    ).toBe(false);

    expect(
      o.validate({
        'dot.field': 'here',
      })
    ).toBe(false);
  });

  it('validates attributes on set()', () => {
    const o = new ParseObject('Listing');
    expect(() => {
      o.set('ACL', 'not an acl');
    }).toThrow(new ParseError(ParseError.OTHER_CAUSE, 'ACL must be a Parse ACL.'));
    expect(o.set('ACL', { '*': { read: true, write: false } })).toBe(o);
    expect(() => {
      o.set('$$$', 'o_O');
    }).toThrow(new ParseError(ParseError.INVALID_KEY_NAME, 'Invalid key name: $$$'));
  });

  it('ignores validation if ignoreValidation option is passed to set()', () => {
    const o = new ParseObject('Listing');
    expect(o.set('$$$', 'o_O', { ignoreValidation: true })).toBe(o);
  });

  it('can test object validity', () => {
    // Note: an object should never become invalid through normal use, but
    // it's possible that someone could manipulate it to become invalid
    const o = new ParseObject('Item');
    expect(o.isValid()).toBe(true);
    o.set('someKey', 'someValue');
    expect(o.isValid()).toBe(true);
    o.set('_internalField', 'allow_underscore');
    expect(o.isValid()).toBe(true);
    o._finishFetch({
      objectId: 'O3',
      'invalid!key': 'oops',
    });
    expect(o.isValid()).toBe(false);
  });

  it('shares data among different instances of an object', () => {
    const o = new ParseObject('Person');
    o.id = 'P2';
    const o2 = new ParseObject('Person');
    o2.id = 'P2';
    o.set('age', 22);
    expect(o.get('age')).toBe(22);
    expect(o2.get('age')).toBe(22);
  });

  it('does not stack-overflow when encoding recursive pointers', () => {
    const o = ParseObject.fromJSON({
      __type: 'Object',
      className: 'Item',
      objectId: 'recurParent',
      child: {
        __type: 'Pointer',
        className: 'Item',
        objectId: 'recurChild',
      },
    });
    expect(o.toJSON()).toEqual({
      objectId: 'recurParent',
      child: {
        __type: 'Pointer',
        className: 'Item',
        objectId: 'recurChild',
      },
    });

    ParseObject.fromJSON({
      __type: 'Object',
      className: 'Item',
      objectId: 'recurChild',
      parent: {
        __type: 'Pointer',
        className: 'Item',
        objectId: 'recurParent',
      },
    });

    expect(o.toJSON()).toEqual({
      objectId: 'recurParent',
      child: {
        __type: 'Object',
        className: 'Item',
        objectId: 'recurChild',
        parent: {
          __type: 'Pointer',
          className: 'Item',
          objectId: 'recurParent',
        },
      },
    });
  });

  it('properly encodes createdAt/updatedAt dates on nested objects', () => {
    const o = ParseObject.fromJSON({
      __type: 'Object',
      className: 'Item',
      objectId: 'recurParent',
      createdAt: '1970-01-01T00:00:00.000Z',
      updatedAt: '1970-01-01T00:00:00.000Z',
      aDate: {
        __type: 'Date',
        iso: '1970-01-01T00:00:00.000Z',
      },
      child: {
        __type: 'Pointer',
        className: 'Item',
        objectId: 'recurChild',
      },
    });
    expect(o.createdAt.getTime()).toBe(new Date(0).getTime());
    expect(o.updatedAt.getTime()).toBe(new Date(0).getTime());
    expect(o.get('aDate').getTime()).toBe(new Date(0).getTime());

    ParseObject.fromJSON({
      __type: 'Object',
      className: 'Item',
      objectId: 'recurChild',
      createdAt: '1970-01-01T00:00:00.000Z',
      updatedAt: '1970-01-01T00:00:00.000Z',
      parent: {
        __type: 'Pointer',
        className: 'Item',
        objectId: 'recurParent',
      },
    });

    expect(o.toJSON()).toEqual({
      objectId: 'recurParent',
      createdAt: '1970-01-01T00:00:00.000Z',
      updatedAt: '1970-01-01T00:00:00.000Z',
      aDate: {
        __type: 'Date',
        iso: '1970-01-01T00:00:00.000Z',
      },
      child: {
        __type: 'Object',
        className: 'Item',
        objectId: 'recurChild',
        createdAt: '1970-01-01T00:00:00.000Z',
        updatedAt: '1970-01-01T00:00:00.000Z',
        parent: {
          __type: 'Pointer',
          className: 'Item',
          objectId: 'recurParent',
        },
      },
    });
  });

  it('encodes multiple layers of nested objects', () => {
    const grandparent = ParseObject.fromJSON({
      __type: 'Object',
      className: 'Item',
      objectId: 'nestedGrand',
      child: {
        __type: 'Pointer',
        className: 'Item',
        objectId: 'nestedParent',
      },
    });

    const parent = ParseObject.fromJSON({
      __type: 'Object',
      className: 'Item',
      objectId: 'nestedParent',
      child: {
        __type: 'Pointer',
        className: 'Item',
        objectId: 'nestedChild',
      },
    });

    const child = ParseObject.fromJSON({
      __type: 'Object',
      className: 'Item',
      objectId: 'nestedChild',
      count: 12,
    });

    expect(grandparent.get('child').id).toBe(parent.id);
    expect(grandparent.get('child').get('child').id).toBe(child.id);

    expect(grandparent.toJSON()).toEqual({
      objectId: 'nestedGrand',
      child: {
        __type: 'Object',
        className: 'Item',
        objectId: 'nestedParent',
        child: {
          __type: 'Object',
          className: 'Item',
          objectId: 'nestedChild',
          count: 12,
        },
      },
    });
  });

  it('updates the existed flag when saved', () => {
    const o = new ParseObject('Item');
    expect(o.existed()).toBe(false);
    expect(o.isNew()).toBe(true);
    o._handleSaveResponse(
      {
        objectId: 'I2',
      },
      201
    );
    expect(o.existed()).toBe(false);
    o._handleSaveResponse({}, 200);
    expect(o.existed()).toBe(true);
  });

  it('check existed without object state', () => {
    const o = new ParseObject('Item');
    o.id = 'test890';
    expect(o.existed()).toBe(false);
  });

  it('commits changes to server data when saved', () => {
    const p = new ParseObject('Person');
    p.id = 'P3';
    p.set('age', 24);
    expect(p._getServerData()).toEqual({});
    expect(p.op('age') instanceof SetOp).toBe(true);
    const updated = new Date();
    p._handleSaveResponse({
      updatedAt: { __type: 'Date', iso: updated.toISOString() },
    });
    expect(p._getServerData()).toEqual({
      updatedAt: updated,
      age: 24,
    });
    expect(p.op('age')).toBe(undefined);
  });

  it('handle GeoPoint changes for server', () => {
    const p = new ParseObject('Person');
    p.id = 'PPoint';
    const created = new Date();
    const geopoint = new ParseGeoPoint(0, 0);
    p._handleSaveResponse({
      createdAt: created.toISOString(),
      point: geopoint.toJSON(),
    });
    expect(p._getServerData()).toEqual({
      updatedAt: created,
      createdAt: created,
      point: geopoint,
    });
    expect(p._getServerData().point instanceof ParseGeoPoint).toBe(true);
  });

  it('handle Polygon changes for server', () => {
    const p = new ParseObject('Person');
    p.id = 'PPolygon';
    const created = new Date();
    const polygon = new ParsePolygon([
      [0, 0],
      [0, 1],
      [1, 1],
      [1, 0],
      [0, 0],
    ]);
    p._handleSaveResponse({
      createdAt: created.toISOString(),
      shape: polygon.toJSON(),
    });
    expect(p._getServerData()).toEqual({
      updatedAt: created,
      createdAt: created,
      shape: polygon,
    });
    expect(p._getServerData().shape instanceof ParsePolygon).toBe(true);
  });

  it('handle createdAt string for server', () => {
    const p = new ParseObject('Person');
    p.id = 'P9';
    const created = new Date();
    p._handleSaveResponse({
      createdAt: created.toISOString(),
    });
    expect(p._getServerData()).toEqual({
      updatedAt: created,
      createdAt: created,
    });
  });

  it('isDataAvailable', () => {
    const p = new ParseObject('Person');
    p.id = 'isdataavailable';
    p.set('age', 24);
    expect(p.isDataAvailable()).toBe(false);
    const updated = new Date();
    p._handleSaveResponse({
      updatedAt: { __type: 'Date', iso: updated.toISOString() },
    });
    expect(p.isDataAvailable()).toBe(true);
  });

  it('handles ACL when saved', () => {
    const p = new ParseObject('Person');

    p._handleSaveResponse(
      {
        ACL: {},
      },
      201
    );

    const acl = p.getACL();
    expect(acl).not.toEqual(null);
    expect(acl instanceof ParseACL).toBe(true);
  });

  it('replaces a local id with a real one when saved', () => {
    const p = new ParseObject('Person');
    p.set('age', 34);
    expect(p._localId).toBeTruthy();
    expect(p.id).toBe(undefined);
    const oldState = SingleInstanceStateController.getState({
      className: 'Person',
      id: p._localId,
    });
    p._handleSaveResponse({
      objectId: 'P4',
    });
    expect(p._localId).toBe(undefined);
    expect(p.id).toBe('P4');
    const newState = SingleInstanceStateController.getState({
      className: 'Person',
      id: 'P4',
    });
    expect(oldState.serverData).toBe(newState.serverData);
    expect(oldState.pendingOps).toBe(newState.pendingOps);
    expect(oldState.tasks).toBe(newState.tasks);
  });

  it('marks inflated objects as existed', () => {
    const o = ParseObject.fromJSON({
      className: 'Item',
      objectId: 'iexist',
      count: 7,
    });
    expect(o.existed()).toBe(true);
  });

  it('can revert unsaved ops', () => {
    const o = ParseObject.fromJSON({
      className: 'Item',
      objectId: 'canrevert',
      count: 5,
    });
    o.set({ cool: true });
    o.increment('count');
    expect(o.get('cool')).toBe(true);
    expect(o.get('count')).toBe(6);
    o.revert();
    expect(o.get('cool')).toBe(undefined);
    expect(o.op('cool')).toBe(undefined);
    expect(o.get('count')).toBe(5);
    expect(o.op('count')).toBe(undefined);
  });

  it('can revert a specific field in unsaved ops', () => {
    const o = ParseObject.fromJSON({
      className: 'Item',
      objectId: 'canrevertspecific',
      count: 5,
    });
    o.set({ cool: true });
    o.increment('count');
    expect(o.get('cool')).toBe(true);
    expect(o.get('count')).toBe(6);
    o.revert('cool');
    expect(o.get('cool')).toBe(undefined);
    expect(o.op('cool')).toBe(undefined);
    expect(o.get('count')).toBe(6);
    expect(o.op('count')).not.toBe(undefined);
  });

  it('can revert multiple fields in unsaved ops', () => {
    const o = ParseObject.fromJSON({
      className: 'Item',
      objectId: 'canrevertmultiple',
      count: 5,
      age: 18,
      gender: 'female',
    });
    o.set({ cool: true, gender: 'male' });
    o.increment('count');
    o.increment('age');
    expect(o.get('cool')).toBe(true);
    expect(o.get('count')).toBe(6);
    expect(o.get('age')).toBe(19);
    expect(o.get('gender')).toBe('male');
    o.revert('age', 'count', 'gender');
    expect(o.get('cool')).toBe(true);
    expect(o.op('cool')).not.toBe(undefined);
    expect(o.get('count')).toBe(5);
    expect(o.op('count')).toBe(undefined);
    expect(o.get('age')).toBe(18);
    expect(o.op('age')).toBe(undefined);
    expect(o.get('gender')).toBe('female');
    expect(o.op('gender')).toBe(undefined);
  });

  it('throws if an array is provided', () => {
    const o = ParseObject.fromJSON({
      className: 'Item',
      objectId: 'throwforarray',
      count: 5,
      age: 18,
      gender: 'female',
    });
    o.set({ cool: true, gender: 'male' });

    const err = 'Parse.Object#revert expects either no, or a list of string, arguments.';

    expect(function () {
      o.revert(['age']);
    }).toThrow(err);

    expect(function () {
      o.revert([]);
    }).toThrow(err);

    expect(function () {
      o.revert('gender', ['age']);
    }).toThrow(err);
  });

  it('can fetchWithInclude', async () => {
    const objectController = CoreManager.getObjectController();
    const spy = jest
      .spyOn(objectController, 'fetch')
      .mockImplementationOnce(() => { })
      .mockImplementationOnce(() => { })
      .mockImplementationOnce(() => { });

    const parent = new ParseObject('Person');
    await parent.fetchWithInclude('child', {
      useMasterKey: true,
      sessionToken: '123',
    });
    await parent.fetchWithInclude(['child']);
    await parent.fetchWithInclude([['child']]);
    expect(objectController.fetch).toHaveBeenCalledTimes(3);

    expect(objectController.fetch.mock.calls[0]).toEqual([
      parent,
      true,
      { useMasterKey: true, sessionToken: '123', include: ['child'] },
    ]);
    expect(objectController.fetch.mock.calls[1]).toEqual([parent, true, { include: ['child'] }]);
    expect(objectController.fetch.mock.calls[2]).toEqual([parent, true, { include: ['child'] }]);

    spy.mockRestore();
  });

  it('fetchAll with empty values', async () => {
    mockFetch([{ status: 200, response: [{}] }]);
    const controller = CoreManager.getRESTController();
    jest.spyOn(controller, 'ajax');

    const results = await ParseObject.fetchAll([]);
    expect(results).toEqual([]);
    expect(controller.ajax).toHaveBeenCalledTimes(0);
  });

  it('fetchAll with null', async () => {
    mockFetch([{ status: 200, response: [{}] }]);
    const controller = CoreManager.getRESTController();
    jest.spyOn(controller, 'ajax');

    const results = await ParseObject.fetchAll(null);
    expect(results).toEqual(undefined);
    expect(controller.ajax).toHaveBeenCalledTimes(0);
  });

  it('fetchAll unique instance', async () => {
    ParseObject.disableSingleInstance();
    const obj = new ParseObject('Item');
    obj.id = 'fetch0';
    const results = await ParseObject.fetchAll([obj]);
    expect(results[0].id).toEqual(obj.id);
  });

  it('fetchAll objects does not exist on server', async () => {
    jest.spyOn(mockQuery.prototype, 'find').mockImplementationOnce(() => {
      return Promise.resolve([]);
    });
    const obj = new ParseObject('Item');
    obj.id = 'fetch-1';
    try {
      await ParseObject.fetchAll([obj]);
      expect(true).toBe(false);
    } catch (e) {
      expect(e.message).toBe('All objects must exist on the server.');
    }
  });

  it('fetchAll unsaved objects', async () => {
    const obj = new ParseObject('Item');
    try {
      await ParseObject.fetchAll([obj]);
      expect(true).toBe(false);
    } catch (e) {
      expect(e.message).toBe('All objects must have an ID');
    }
  });

  it('fetchAll objects with different classes', async () => {
    const obj = new ParseObject('Item');
    const obj2 = new ParseObject('TestObject');
    try {
      await ParseObject.fetchAll([obj, obj2]);
      expect(true).toBe(false);
    } catch (e) {
      expect(e.message).toBe('All objects must have an ID');
    }
  });

  it('fetchAll saved objects with different classes', async () => {
    const obj1 = new ParseObject('Item');
    const obj2 = new ParseObject('TestObject');
    obj1.id = 'fetch1';
    obj2.id = 'fetch2';
    try {
      await ParseObject.fetchAll([obj1, obj2]);
      expect(true).toBe(false);
    } catch (e) {
      expect(e.message).toBe('All objects should be of the same class');
    }
  });

  it('can fetchAllWithInclude', async () => {
    const objectController = CoreManager.getObjectController();
    const spy = jest
      .spyOn(objectController, 'fetch')
      .mockImplementationOnce(() => { })
      .mockImplementationOnce(() => { })
      .mockImplementationOnce(() => { });

    const parent = new ParseObject('Person');
    await ParseObject.fetchAllWithInclude([parent], 'child', {
      useMasterKey: true,
      sessionToken: '123',
    });
    await ParseObject.fetchAllWithInclude([parent], ['child']);
    await ParseObject.fetchAllWithInclude([parent], [['child']]);
    expect(objectController.fetch).toHaveBeenCalledTimes(3);

    expect(objectController.fetch.mock.calls[0]).toEqual([
      [parent],
      true,
      { useMasterKey: true, sessionToken: '123', include: ['child'] },
    ]);
    expect(objectController.fetch.mock.calls[1]).toEqual([[parent], true, { include: ['child'] }]);
    expect(objectController.fetch.mock.calls[2]).toEqual([[parent], true, { include: ['child'] }]);

    spy.mockRestore();
  });

  it('can fetchAllIfNeededWithInclude', async () => {
    const objectController = CoreManager.getObjectController();
    const spy = jest
      .spyOn(objectController, 'fetch')
      .mockImplementationOnce(() => { })
      .mockImplementationOnce(() => { })
      .mockImplementationOnce(() => { });

    const parent = new ParseObject('Person');
    await ParseObject.fetchAllIfNeededWithInclude([parent], 'child', {
      useMasterKey: true,
      sessionToken: '123',
    });
    await ParseObject.fetchAllIfNeededWithInclude([parent], ['child']);
    await ParseObject.fetchAllIfNeededWithInclude([parent], [['child']]);
    expect(objectController.fetch).toHaveBeenCalledTimes(3);

    expect(objectController.fetch.mock.calls[0]).toEqual([
      [parent],
      false,
      { useMasterKey: true, sessionToken: '123', include: ['child'] },
    ]);
    expect(objectController.fetch.mock.calls[1]).toEqual([[parent], false, { include: ['child'] }]);
    expect(objectController.fetch.mock.calls[2]).toEqual([[parent], false, { include: ['child'] }]);

    spy.mockRestore();
  });

  it('can check if object exists', async () => {
    const parent = new ParseObject('Person');
    expect(await parent.exists()).toBe(false);
    parent.id = '1234';
    expect(await parent.exists()).toBe(true);

    jest.spyOn(mockQuery.prototype, 'get').mockImplementationOnce(() => {
      return Promise.reject({
        code: 101,
      });
    });
    expect(await parent.exists()).toBe(false);

    jest.spyOn(mockQuery.prototype, 'get').mockImplementationOnce(() => {
      return Promise.reject({
        code: 1,
        message: 'Internal Server Error',
      });
    });
    try {
      await parent.exists();
      expect(true).toBe(false);
    } catch (e) {
      expect(e.code).toBe(1);
    }
  });

  it('can save the object', async () => {
    mockFetch([{ status: 200, response: { objectId: 'P5', count: 1 } }]);
    const p = new ParseObject('Person');
    p.set('age', 38);
    p.increment('count');
    const obj = await p.save();
    expect(obj).toBe(p);
    expect(obj.get('age')).toBe(38);
    expect(obj.get('count')).toBe(1);
    expect(obj.op('age')).toBe(undefined);
    expect(obj.dirty()).toBe(false);
  });

  it('can save the object eventually', async () => {
    mockFetch([{ status: 200, response: { objectId: 'PFEventually' } }]);
    const p = new ParseObject('Person');
    p.set('age', 38);
    const obj = await p.saveEventually();
    expect(obj).toBe(p);
    expect(obj.get('age')).toBe(38);
    expect(obj.op('age')).toBe(undefined);
    expect(obj.dirty()).toBe(false);
  });

  it('can save the object eventually on network failure', async () => {
    const p = new ParseObject('Person');
    jest.spyOn(EventuallyQueue, 'save').mockImplementationOnce(() => Promise.resolve());
    jest.spyOn(EventuallyQueue, 'poll').mockImplementationOnce(() => { });
    jest.spyOn(p, 'save').mockImplementationOnce(() => {
      throw new ParseError(
        ParseError.CONNECTION_FAILED,
        'XMLHttpRequest failed: ""Unable to connect to the Parse API""'
      );
    });
    await p.saveEventually();
    expect(EventuallyQueue.save).toHaveBeenCalledTimes(1);
    expect(EventuallyQueue.poll).toHaveBeenCalledTimes(1);
  });

  it('should not save the object eventually on error', async () => {
    const p = new ParseObject('Person');
    jest.spyOn(EventuallyQueue, 'save').mockImplementationOnce(() => Promise.resolve());
    jest.spyOn(EventuallyQueue, 'poll').mockImplementationOnce(() => { });
    jest.spyOn(p, 'save').mockImplementationOnce(() => {
      throw new ParseError(ParseError.OTHER_CAUSE, 'Tried to save a batch with a cycle.');
    });
    await p.saveEventually();
    expect(EventuallyQueue.save).toHaveBeenCalledTimes(0);
    expect(EventuallyQueue.poll).toHaveBeenCalledTimes(0);
  });

  it('can save the object with key / value', async () => {
    mockFetch([{ status: 200, response: { objectId: 'P8' } }]);
    const p = new ParseObject('Person');
    const obj = await p.save('foo', 'bar');
    expect(obj).toBe(p);
    expect(obj.get('foo')).toBe('bar');
  });

  it('accepts attribute changes on save', (done) => {
    mockFetch([{ status: 200, response: { objectId: 'newattributes' } }]);
    let o = new ParseObject('Item');
    o.save({ key: 'value' })
      .then(() => {
        expect(o.get('key')).toBe('value');

        o = new ParseObject('Item');
        return o.save({ ACL: 'not an acl' });
      })
      .then(null, error => {
        expect(error.code).toBe(-1);
        done();
      });
  });

  it('accepts context on save', async () => {
    mockFetch([{ status: 200, response: { objectId: 'newattributes' } }]);
    // Spy on REST controller
    const controller = CoreManager.getRESTController();
    jest.spyOn(controller, 'ajax');
    // Save object
    const context = { a: 'a' };
    const obj = new ParseObject('Item');
    await obj.save(null, { context });
    // Validate
    const jsonBody = JSON.parse(controller.ajax.mock.calls[0][2]);
    expect(jsonBody._context).toEqual(context);
  });

  it('interpolates delete operations', async () => {
    mockFetch([{ status: 200, response: { objectId: 'newattributes', deletedKey: { __op: 'Delete' } } }]);
    const o = new ParseObject('Item');
    await o.save({ key: 'value', deletedKey: 'keyToDelete' });
    expect(o.get('key')).toBe('value');
    expect(o.get('deletedKey')).toBeUndefined();
  });

  it('can make changes while in the process of a save', async () => {
    mockFetch([{ status: 200, response: { objectId: 'P12', age: 38 } }]);
    const p = new ParseObject('Person');
    p.set('age', 38);
    const result = p.save().then(() => {
      expect(p._getServerData()).toEqual({ age: 38 });
      expect(p._getPendingOps().length).toBe(1);
      expect(p.get('age')).toBe(38);
    });
    expect(p._getPendingOps().length).toBe(1);
    p.increment('age');
    expect(p.get('age')).toBe(39);
    await result;
  });

  it('will queue save operations', async () => {
    mockFetch([
      { status: 200, response: { objectId: 'P15', updates: 1 } },
      { status: 200, response: { objectId: 'P15', updates: 2 } },
    ]);
    const p = new ParseObject('Person');
    expect(p._getPendingOps().length).toBe(1);
    p.increment('updates');
    await p.save();

    expect(p._getPendingOps().length).toBe(1);
    p.increment('updates');
    await p.save();

    expect(p._getPendingOps().length).toBe(1);
    expect(p._getServerData()).toEqual({ updates: 2 });
    expect(p.get('updates')).toBe(2);
    expect(p._getPendingOps().length).toBe(1);
  });

  it('will leave the pending ops queue untouched when a lone save fails', async () => {
    mockFetch([{ status: 404, response: { code: 103, error: 'Invalid class name' } }]);
    const p = new ParseObject('Per$on');
    expect(p._getPendingOps().length).toBe(1);
    p.increment('updates');
    const result = p.save().then(null, err => {
      expect(err.code).toBe(103);
      expect(err.message).toBe('Invalid class name');
      expect(p._getPendingOps().length).toBe(1);
      expect(p.dirtyKeys()).toEqual(['updates']);
      expect(p.get('updates')).toBe(1);
    });
    await result;
  });

  it('will merge pending Ops when a save fails and others are pending', async () => {
    mockFetch([
      { status: 404, response: { code: 103, error: 'Invalid class name' } },
      { status: 404, response: { code: 103, error: 'Invalid class name' } },
    ]);
    const p = new ParseObject('Per$on');
    expect(p._getPendingOps().length).toBe(1);
    p.increment('updates');
    p.save().catch(() => { });
    jest.runAllTicks();
    await flushPromises();
    expect(p._getPendingOps().length).toBe(1);
    p.set('updates', 12);
    p.save().catch(() => { });
    jest.runAllTicks();
    await flushPromises();
    expect(p._getPendingOps().length).toBe(1);
    jest.runAllTicks();
    await flushPromises();
    expect(p._getPendingOps().length).toBe(1);
    expect(p._getPendingOps()[0]).toEqual({
      updates: new ParseOp.SetOp(12),
    });
  });

  it('will deep-save the children of an object', async () => {
    expect.assertions(4);
    mockFetch([
      { status: 200, response: [{ success: { objectId: 'child' } }] },
      { status: 200, response: { objectId: 'parent' } },
    ])
    const parent = new ParseObject('Item');
    const child = new ParseObject('Item');
    child.set('value', 5);
    parent.set('child', child);
    const result = parent.save().then(() => {
      expect(child.id).toBe('child');
      expect(child.dirty()).toBe(false);
      expect(parent.id).toBe('parent');
    });
    await result;
    expect(fetch.mock.calls[0][0]).toEqual('https://api.parse.com/1/batch');
  });

  it('will fail for a circular dependency of non-existing objects', async () => {
    const parent = new ParseObject('Item');
    const child = new ParseObject('Item');
    parent.set('child', child);
    child.set('parent', parent);
    await expect(parent.save()).rejects.toThrowError(
      'Cannot create a pointer to an unsaved Object.'
    );
  });

  it('will fail for deeper unsaved objects', async () => {
    const parent = new ParseObject('Item');
    const child = new ParseObject('Item');
    const grandchild = new ParseObject('Item');
    parent.set('child', child);
    child.set('child', grandchild);
    await expect(parent.save()).rejects.toThrowError(
      'Cannot create a pointer to an unsaved Object.'
    );
  });

  it('does not mark shallow objects as dirty', () => {
    const post = new ParseObject('Post');
    post.id = '141414';
    expect(post.dirty()).toBe(false);

    const comment = new ParseObject('Comment');
    comment.set('parent', post);
    expect(unsavedChildren(comment)).toEqual([]);
  });

  it('can fetch an object given an id', async () => {
    expect.assertions(2);
    mockFetch([{ status: 200, response: { count: 10 } }]);
    const p = new ParseObject('Person');
    p.id = 'P55';
    await p.fetch().then(res => {
      expect(p).toBe(res);
      expect(p.attributes).toEqual({ count: 10 });
    });
  });

  it('throw for fetch with empty string as ID', async () => {
    expect.assertions(1);
    mockFetch([{ status: 200, response: { count: 10 } }]);
    const p = new ParseObject('Person');
    p.id = '';
    await expect(p.fetch()).rejects.toThrowError(
      new ParseError(ParseError.MISSING_OBJECT_ID, 'Object does not have an ID')
    );
  });

  it('should fail saveAll batch cycle', async () => {
    const obj = new ParseObject('Item');
    obj.set('child', obj);

    await expect(ParseObject.saveAll([obj])).rejects.toEqual(
      expect.objectContaining({
        message: 'Tried to save a batch with a cycle.',
      })
    );
  });

  it('should fail save with transaction and batchSize option', async () => {
    const obj1 = new ParseObject('TestObject');
    const obj2 = new ParseObject('TestObject');

    await expect(
      ParseObject.saveAll([obj1, obj2], { transaction: true, batchSize: 20 })
    ).rejects.toEqual(
      expect.objectContaining({
        message: 'You cannot use both transaction and batchSize options simultaneously.',
      })
    );
  });

  it('should fail destroy with transaction and batchSize option', async () => {
    const obj1 = new ParseObject('TestObject');
    const obj2 = new ParseObject('TestObject');

    await expect(
      ParseObject.destroyAll([obj1, obj2], { transaction: true, batchSize: 20 })
    ).rejects.toEqual(
      expect.objectContaining({
        message: 'You cannot use both transaction and batchSize options simultaneously.',
      })
    );
  });

  it('should fail save batch with unserializable attribute and transaction option', async () => {
    const obj1 = new ParseObject('TestObject');
    const obj2 = new ParseObject('TestObject');
    obj1.set('relatedObject', obj2);

    await expect(ParseObject.saveAll([obj1, obj2], { transaction: true })).rejects.toEqual(
      expect.objectContaining({
        message:
          'Tried to save a transactional batch containing an object with unserializable attributes.',
      })
    );
  });

  it('should fail to save object when its children lack IDs using transaction option', async () => {
    mockFetch([{ status: 200, response: [] }]);

    const obj1 = new ParseObject('TestObject');
    const obj2 = new ParseObject('TestObject');
    obj1.set('relatedObject', obj2);

    await expect(obj1.save(null, { transaction: true })).rejects.toEqual(
      expect.objectContaining({
        message:
          'Tried to save a transactional batch containing an object with unserializable attributes.',
      })
    );
  });

  it('should save batch with serializable attribute and transaction option', async () => {
    mockFetch([{
      status: 200,
      response: [{ success: { objectId: 'parent' } }, { success: { objectId: 'id2' } }],
    }]);
    const controller = CoreManager.getRESTController();
    jest.spyOn(controller, 'request');

    const obj1 = new ParseObject('TestObject');
    const obj2 = new ParseObject('TestObject');
    obj2.id = 'id2';
    obj1.set('relatedObject', obj2);

    const [saved1, saved2] = await ParseObject.saveAll([obj1, obj2], { transaction: true });

    expect(saved1.dirty()).toBe(false);
    expect(saved2.dirty()).toBe(false);
    expect(saved1.id).toBe('parent');
    expect(saved2.id).toBe('id2');

    expect(controller.request).toHaveBeenCalledWith(
      'POST',
      'batch',
      {
        requests: [
          {
            method: 'POST',
            body: {
              relatedObject: { __type: 'Pointer', className: 'TestObject', objectId: 'id2' },
            },
            path: '/1/classes/TestObject',
          },
          { method: 'PUT', body: {}, path: '/1/classes/TestObject/id2' },
        ],
        transaction: true,
      },
      expect.anything()
    );
  });

  it('should save object along with its children using transaction option', async () => {
    mockFetch([{
      status: 200,
      response: [{ success: { objectId: 'id2' } }, { success: { objectId: 'parent' } }],
    }]);
    const controller = CoreManager.getRESTController();
    jest.spyOn(controller, 'request');

    const obj1 = new ParseObject('TestObject');
    const obj2 = new ParseObject('TestObject');
    obj2.id = 'id2';
    obj2.set('attribute', true);

    obj1.set('relatedObject', obj2);

    const saved1 = await obj1.save(null, { transaction: true });

    const saved2 = saved1.get('relatedObject');
    expect(saved1.dirty()).toBe(false);
    expect(saved2.dirty()).toBe(false);
    expect(saved1.id).toBe('parent');
    expect(saved2.id).toBe('id2');

    expect(controller.request).toHaveBeenCalledWith(
      'POST',
      'batch',
      {
        requests: [
          {
            method: 'PUT',
            body: { attribute: true },
            path: '/1/classes/TestObject/id2',
          },
          {
            method: 'POST',
            body: {
              relatedObject: { __type: 'Pointer', className: 'TestObject', objectId: 'id2' },
            },
            path: '/1/classes/TestObject',
          },
        ],
        transaction: true,
      },
      expect.anything()
    );
  });

  it('should save file & object along with its children using transaction option', async () => {
    mockFetch([
      {
        status: 200,
        response: { name: 'mock-name', url: 'mock-url' },
      },
      {
        status: 200,
        response: [{ success: { objectId: 'id2' } }, { success: { objectId: 'parent' } }],
      },
    ]);
    const controller = CoreManager.getRESTController();
    jest.spyOn(controller, 'request');

    const file1 = new ParseFile('parse-server-logo', [0, 1, 2, 3]);
    const obj1 = new ParseObject('TestObject');
    const obj2 = new ParseObject('TestObject');
    obj2.id = 'id2';
    obj2.set('file', file1);

    obj1.set('relatedObject', obj2);

    const saved1 = await obj1.save(null, { transaction: true });

    const saved2 = saved1.get('relatedObject');
    expect(saved1.dirty()).toBe(false);
    expect(saved2.dirty()).toBe(false);
    expect(saved1.id).toBe('parent');
    expect(saved2.id).toBe('id2');

    const file = saved2.get('file');
    expect(file.name()).toBe('mock-name');
    expect(file.url()).toBe('mock-url');

    expect(controller.request).toHaveBeenCalledWith(
      'POST',
      'batch',
      {
        requests: [
          {
            method: 'PUT',
            body: { file: { __type: 'File', name: 'mock-name', url: 'mock-url' } },
            path: '/1/classes/TestObject/id2',
          },
          {
            method: 'POST',
            body: {
              relatedObject: { __type: 'Pointer', className: 'TestObject', objectId: 'id2' },
            },
            path: '/1/classes/TestObject',
          },
        ],
        transaction: true,
      },
      expect.anything()
    );
  });

  it('should destroy batch with transaction option', async () => {
    mockFetch([
      {
        status: 200,
        response: [{ success: { objectId: 'parent' } }, { success: { objectId: 'id2' } }],
      },
    ]);
    const controller = CoreManager.getRESTController();
    jest.spyOn(controller, 'request');

    const obj1 = new ParseObject('TestObject');
    const obj2 = new ParseObject('TestObject');
    obj1.id = 'parent';
    obj2.id = 'id2';

    await ParseObject.destroyAll([obj1, obj2], { transaction: true });

    expect(controller.request).toHaveBeenCalledWith(
      'POST',
      'batch',
      {
        requests: [
          { method: 'DELETE', body: {}, path: '/1/classes/TestObject/parent' },
          { method: 'DELETE', body: {}, path: '/1/classes/TestObject/id2' },
        ],
        transaction: true,
      },
      expect.anything()
    );
  });

  it('should fail on invalid date', done => {
    const obj = new ParseObject('Item');
    obj.set('when', new Date(Date.parse(null)));
    ParseObject.saveAll([obj])
      .then(() => {
        done.fail('Expected invalid date to fail');
      })
      .catch(error => {
        expect(error[0].code).toEqual(ParseError.INCORRECT_TYPE);
        expect(error[0].message).toEqual('Tried to encode an invalid date.');
        done();
      });
    jest.runAllTicks();
  });

  it('can save a ring of objects, given one exists', async () => {
    mockFetch([
      { status: 200, response: [{ success: { objectId: 'parent' } }] },
      { status: 200, response: [{ success: {} }] },
    ]);
    const parent = new ParseObject('Item');
    const child = new ParseObject('Item');
    child.id = 'child';
    parent.set('child', child);
    child.set('parent', parent);

    const result = ParseObject.saveAll([parent, child]).then(() => {
      expect(child.dirty()).toBe(false);
      expect(parent.id).toBe('parent');
    });
    jest.runAllTicks();
    await flushPromises();

    expect(fetch.mock.calls[0][0]).toEqual('https://api.parse.com/1/batch');
    expect(JSON.parse(fetch.mock.calls[0][1].body).requests).toEqual([
      {
        method: 'POST',
        path: '/1/classes/Item',
        body: {
          child: {
            __type: 'Pointer',
            className: 'Item',
            objectId: 'child',
          },
        },
      },
    ]);
    jest.runAllTicks();
    await flushPromises();

    expect(parent.id).toBe('parent');
    jest.runAllTicks();

    await result;
  });

  it('accepts context on saveAll', async () => {
    mockFetch([{ status: 200, response: [{}] }]);
    // Spy on REST controller
    const controller = CoreManager.getRESTController();
    jest.spyOn(controller, 'ajax');
    // Save object
    const context = { a: 'saveAll' };
    const obj = new ParseObject('Item');
    obj.id = 'pid';
    obj.set('test', 'value');
    await ParseObject.saveAll([obj], { context, useMasterKey: true });
    // Validate
    const jsonBody = JSON.parse(controller.ajax.mock.calls[0][2]);
    expect(jsonBody._context).toEqual(context);
  });

  it('accepts context on destroyAll', async () => {
    mockFetch([{ status: 200, response: [{}] }]);
    // Spy on REST controller
    const controller = CoreManager.getRESTController();
    jest.spyOn(controller, 'ajax');
    // Save object
    const context = { a: 'b' };
    const obj = new ParseObject('Item');
    obj.id = 'pid';
    await ParseObject.destroyAll([obj], { context: context });
    // Validate
    const jsonBody = JSON.parse(controller.ajax.mock.calls[0][2]);
    expect(jsonBody._context).toEqual(context);
  });

  it('destroyAll with options', async () => {
    mockFetch([{ status: 200, response: [{}] }]);
    const controller = CoreManager.getRESTController();
    jest.spyOn(controller, 'ajax');

    const obj = new ParseObject('Item');
    obj.id = 'pid';
    await ParseObject.destroyAll([obj], {
      useMasterKey: true,
      sessionToken: 'r:1234',
      batchSize: 25,
    });

    const jsonBody = JSON.parse(controller.ajax.mock.calls[0][2]);
    expect(jsonBody._MasterKey).toBe('C');
    expect(jsonBody._SessionToken).toBe('r:1234');
  });

  it('destroyAll with empty values', async () => {
    mockFetch([{ status: 200, response: [{}] }]);
    const controller = CoreManager.getRESTController();
    jest.spyOn(controller, 'ajax');

    let results = await ParseObject.destroyAll([]);
    expect(results).toEqual([]);

    results = await ParseObject.destroyAll(null);
    expect(results).toEqual(null);
    expect(controller.ajax).toHaveBeenCalledTimes(0);
  });

  it('destroyAll unsaved objects', async () => {
    mockFetch([{ status: 200, response: [{}] }]);
    const controller = CoreManager.getRESTController();
    jest.spyOn(controller, 'ajax');

    const obj = new ParseObject('Item');
    const results = await ParseObject.destroyAll([obj]);
    expect(results).toEqual([obj]);
    expect(controller.ajax).toHaveBeenCalledTimes(0);
  });

  it('destroyAll handle error response', async () => {
    mockFetch([
      {
        status: 200,
        response: [
          {
            error: {
              code: 101,
              error: 'Object not found',
            },
          },
        ],
      },
    ]);
    const obj = new ParseObject('Item');
    obj.id = 'toDelete1';
    try {
      await ParseObject.destroyAll([obj]);
      expect(true).toBe(false);
    } catch (e) {
      expect(e.code).toBe(600);
    }
  });

  it('can save a chain of unsaved objects', async () => {
    mockFetch([
      { status: 200, response: [{ success: { objectId: 'grandchild' } }] },
      { status: 200, response: [{ success: { objectId: 'child' } }] },
      { status: 200, response: [{ success: { objectId: 'parent' } }] },
    ]);
    const parent = new ParseObject('Item');
    const child = new ParseObject('Item');
    const grandchild = new ParseObject('Item');
    parent.set('child', child);
    child.set('child', grandchild);

    const result = ParseObject.saveAll([parent]).then(() => {
      expect(child.dirty()).toBe(false);
      expect(grandchild.dirty()).toBe(false);
      expect(parent.id).toBe('parent');
      expect(child.id).toBe('child');
      expect(grandchild.id).toBe('grandchild');
    });
    jest.runAllTicks();
    await flushPromises();

    expect(fetch.mock.calls[0][0]).toEqual('https://api.parse.com/1/batch');
    expect(JSON.parse(fetch.mock.calls[0][1].body).requests).toEqual([
      {
        method: 'POST',
        path: '/1/classes/Item',
        body: {},
      },
    ]);
    expect(fetch.mock.calls[1][0]).toEqual('https://api.parse.com/1/batch');
    expect(JSON.parse(fetch.mock.calls[1][1].body).requests).toEqual([
      {
        method: 'POST',
        path: '/1/classes/Item',
        body: {
          child: {
            __type: 'Pointer',
            className: 'Item',
            objectId: 'grandchild',
          },
        },
      },
    ]);
    expect(fetch.mock.calls[2][0]).toEqual('https://api.parse.com/1/batch');
    expect(JSON.parse(fetch.mock.calls[2][1].body).requests).toEqual([
      {
        method: 'POST',
        path: '/1/classes/Item',
        body: {
          child: {
            __type: 'Pointer',
            className: 'Item',
            objectId: 'child',
          },
        },
      },
    ]);
    jest.runAllTicks();
    await result;
  });

  it('can update fields via a fetch() call', done => {
    mockFetch([
      {
        status: 200,
        response: {
          count: 11,
        },
      },
      {
        status: 200,
        response: {
          count: 20,
        },
      },
    ]);
    const p = new ParseObject('Person');
    p.id = 'P55';
    p.increment('count');
    p.save()
      .then(() => {
        expect(p.get('count')).toBe(11);
        return p.fetch();
      })
      .then(() => {
        expect(p.get('count')).toBe(20);
        expect(p.dirty()).toBe(false);
        done();
      });
  });

  it('replaces old data when fetch() is called', done => {
    mockFetch([
      {
        status: 200,
        response: {
          count: 10,
        },
      },
    ])
    const p = ParseObject.fromJSON({
      className: 'Person',
      objectId: 'P200',
      name: 'Fred',
      count: 0,
    });
    expect(p.get('name')).toBe('Fred');
    expect(p.get('count')).toBe(0);
    p.fetch().then(() => {
      expect(p.get('count')).toBe(10);
      expect(p.get('name')).toBe(undefined);
      expect(p.has('name')).toBe(false);
      done();
    });
  });

  it('can destroy an object', async () => {
    mockFetch([{ status: 200, response: { objectId: 'pid' } }]);
    const p = new ParseObject('Person');
    p.id = 'pid';
    await p.destroy({ sessionToken: 't_1234' });
    expect(fetch.mock.calls[0][0]).toEqual('https://api.parse.com/1/classes/Person/pid');
    expect(JSON.parse(fetch.mock.calls[0][1].body)._method).toBe('DELETE');
    expect(JSON.parse(fetch.mock.calls[0][1].body)._SessionToken).toBe('t_1234');
  });

  it('accepts context on destroy', async () => {
    mockFetch([{ status: 200, response: [{}] }]);
    // Spy on REST controller
    const controller = CoreManager.getRESTController();
    jest.spyOn(controller, 'ajax');
    // Save object
    const context = { a: 'a' };
    const obj = new ParseObject('Item');
    obj.id = 'pid';
    await obj.destroy({ context });
    // Validate
    const jsonBody = JSON.parse(controller.ajax.mock.calls[0][2]);
    expect(jsonBody._context).toEqual(context);
  });

  it('handle destroy on new object', async () => {
    const controller = CoreManager.getRESTController();
    jest.spyOn(controller, 'ajax');

    const obj = new ParseObject('Item');

    await obj.destroy({ useMasterKey: true });

    expect(controller.ajax).toHaveBeenCalledTimes(0);
  });

  it('can save an array of objects', async () => {
    mockFetch([{
      status: 200,
      response: [
        { success: { objectId: 'pid0' } },
        { success: { objectId: 'pid1' } },
        { success: { objectId: 'pid2' } },
        { success: { objectId: 'pid3' } },
        { success: { objectId: 'pid4' } },
      ],
    }]);
    const objects = [];
    for (let i = 0; i < 5; i++) {
      objects[i] = new ParseObject('Person');
    }
    const results = await ParseObject.saveAll(objects);
    expect(results.every(obj => obj.id !== undefined)).toBe(true);
    expect(fetch.mock.calls[0][0]).toEqual('https://api.parse.com/1/batch');
    expect(JSON.parse(fetch.mock.calls[0][1].body).requests[0]).toEqual({
      method: 'POST',
      path: '/1/classes/Person',
      body: {},
    });
  });

  it('can saveAll with batchSize', async () => {
    const objects = [];
    const response = [];
    for (let i = 0; i < 22; i++) {
      objects[i] = new ParseObject('Person');
      response[i] = { success: { objectId: `pid${i}` } };
    }
    mockFetch([
      { status: 200, response: response.slice(0, 20) },
      { status: 200, response: response.slice(20) },
    ]);
    await ParseObject.saveAll(objects, { batchSize: 20 });
    expect(fetch.mock.calls[0][0]).toEqual('https://api.parse.com/1/batch');
    expect(fetch.mock.calls[1][0]).toEqual('https://api.parse.com/1/batch');
  });

  it('can saveAll with global batchSize', async () => {
    const objects = [];
    const response = [];
    for (let i = 0; i < 22; i++) {
      objects[i] = new ParseObject('Person');
      response[i] = { success: { objectId: `pid${i}` } };
    }
    mockFetch([
      { status: 200, response: response.slice(0, 20) },
      { status: 200, response: response.slice(20) },
    ]);
    await ParseObject.saveAll(objects);
    expect(fetch.mock.calls[0][0]).toEqual('https://api.parse.com/1/batch');
    expect(fetch.mock.calls[1][0]).toEqual('https://api.parse.com/1/batch');
  });

  it('returns the first error when saving an array of objects', async () => {
    expect.assertions(4);
    const response = [
      { success: { objectId: 'pid0' } },
      { success: { objectId: 'pid1' } },
      { success: { objectId: 'pid2' } },
      { success: { objectId: 'pid3' } },
      { success: { objectId: 'pid4' } },
      { success: { objectId: 'pid5' } },
      { error: { code: -1, error: 'first error' } },
      { success: { objectId: 'pid7' } },
      { success: { objectId: 'pid8' } },
      { success: { objectId: 'pid9' } },
      { success: { objectId: 'pid10' } },
      { success: { objectId: 'pid11' } },
      { success: { objectId: 'pid12' } },
      { success: { objectId: 'pid13' } },
      { success: { objectId: 'pid14' } },
      { error: { code: -1, error: 'second error' } },
      { success: { objectId: 'pid16' } },
      { success: { objectId: 'pid17' } },
      { success: { objectId: 'pid18' } },
      { success: { objectId: 'pid19' } },
    ];
    mockFetch([{ status: 200, response }, { status: 200, response }]);
    const objects = [];
    for (let i = 0; i < 22; i++) {
      objects[i] = new ParseObject('Person');
    }
    try {
      await ParseObject.saveAll(objects);
    } catch (error) {
      // The second batch never ran
      expect(objects[19].dirty()).toBe(false);
      expect(objects[20].dirty()).toBe(true);
      expect(error.message).toBe('first error');
      expect(fetch.mock.calls.length).toBe(1);
    }
  });
});

describe('ObjectController', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('can fetch a single object', async () => {
    const objectController = CoreManager.getObjectController();
    mockFetch([{ status: 200, response: { objectId: 'pid' } }]);

    const o = new ParseObject('Person');
    o.id = 'pid';
    await objectController.fetch(o);
    expect(fetch.mock.calls[0][0]).toEqual('https://api.parse.com/1/classes/Person/pid');
    const body = JSON.parse(fetch.mock.calls[0][1].body);
    expect(body._method).toBe('GET');
  });

  it('accepts context on fetch', async () => {
    mockFetch([{ status: 200, response: {} }]);
    // Spy on REST controller
    const controller = CoreManager.getRESTController();
    jest.spyOn(controller, 'ajax');
    // Save object
    const context = { a: 'fetch' };
    const obj = new ParseObject('Item');
    obj.id = 'pid';
    await obj.fetch({ context });
    // Validate
    const jsonBody = JSON.parse(controller.ajax.mock.calls[0][2]);
    expect(jsonBody._context).toEqual(context);
  });

  it('can fetch an array of objects', done => {
    const objectController = CoreManager.getObjectController();
    const objects = [];
    for (let i = 0; i < 5; i++) {
      objects[i] = new ParseObject('Person');
      objects[i].id = 'pid' + i;
    }
    objectController.fetch(objects).then(results => {
      expect(results.length).toBe(5);
      expect(results[0] instanceof ParseObject).toBe(true);
      expect(results[0].id).toBe('pid0');
      expect(results[0].className).toBe('Person');
      done();
    });
  });

  it('can fetch a single object with include', async () => {
    expect.assertions(2);
    const objectController = CoreManager.getObjectController();
    mockFetch([{ status: 200, response: { objectId: 'pid' } }]);

    const o = new ParseObject('Person');
    o.id = 'pid';
    await objectController.fetch(o, false, { include: ['child'] });
    expect(fetch.mock.calls[0][0]).toEqual('https://api.parse.com/1/classes/Person/pid');
    const body = JSON.parse(fetch.mock.calls[0][1].body);
    expect(body._method).toBe('GET');
  });

  it('can fetch an array of objects with include', async () => {
    const objectController = CoreManager.getObjectController();
    const objects = [];
    for (let i = 0; i < 5; i++) {
      objects[i] = new ParseObject('Person');
      objects[i].id = 'pid' + i;
    }
    const results = await objectController.fetch(objects, false, {
      include: ['child'],
    });
    expect(results.length).toBe(5);
    expect(results[0] instanceof ParseObject).toBe(true);
    expect(results[0].id).toBe('pid0');
    expect(results[0].className).toBe('Person');
  });

  it('can destroy an object', async () => {
    const objectController = CoreManager.getObjectController();
    mockFetch([
      { status: 200, response: { results: [] } },
      { status: 200, response: { results: [] } },
    ]);
    const p = new ParseObject('Person');
    p.id = 'pid';
    await objectController.destroy(p, {});
    expect(fetch.mock.calls[0][0]).toEqual('https://api.parse.com/1/classes/Person/pid');
    expect(JSON.parse(fetch.mock.calls[0][1].body)._method).toBe('DELETE');
    const p2 = new ParseObject('Person');
    p2.id = 'pid2';
    await objectController.destroy(p2, {
      useMasterKey: true,
    });
    expect(fetch.mock.calls[1][0]).toEqual('https://api.parse.com/1/classes/Person/pid2');
    const body = JSON.parse(fetch.mock.calls[1][1].body);
    expect(body._method).toBe('DELETE');
    expect(body._MasterKey).toBe('C');
  });

  it('can destroy an array of objects with batchSize', async () => {
    const objectController = CoreManager.getObjectController();
    let response = [];
    let objects = [];
    for (let i = 0; i < 5; i++) {
      objects[i] = new ParseObject('Person');
      objects[i].id = 'pid' + i;
      response.push({
        success: { objectId: 'pid' + i },
      });
    }
    mockFetch([{ status: 200, response }]);

    await objectController.destroy(objects, { batchSize: 20 });
    expect(fetch.mock.calls[0][0]).toEqual('https://api.parse.com/1/batch');
    expect(JSON.parse(fetch.mock.calls[0][1].body).requests).toEqual([
      {
        method: 'DELETE',
        path: '/1/classes/Person/pid0',
        body: {},
      },
      {
        method: 'DELETE',
        path: '/1/classes/Person/pid1',
        body: {},
      },
      {
        method: 'DELETE',
        path: '/1/classes/Person/pid2',
        body: {},
      },
      {
        method: 'DELETE',
        path: '/1/classes/Person/pid3',
        body: {},
      },
      {
        method: 'DELETE',
        path: '/1/classes/Person/pid4',
        body: {},
      },
    ]);

    objects = [];
    response = [];
    for (let i = 0; i < 22; i++) {
      objects[i] = new ParseObject('Person');
      objects[i].id = 'pid' + i;
      response.push({
        success: { objectId: 'pid' + i },
      });
    }
    mockFetch([{ status: 200, response }, { status: 200, response: response.slice(20) }]);

    await objectController.destroy(objects, { batchSize: 20 });
    expect(fetch.mock.calls.length).toBe(2);
    expect(JSON.parse(fetch.mock.calls[0][1].body).requests.length).toBe(20);
    expect(JSON.parse(fetch.mock.calls[1][1].body).requests.length).toBe(2);
  });

  it('can destroy an array of objects', async () => {
    const objectController = CoreManager.getObjectController();
    let response = [];
    let objects = [];
    for (let i = 0; i < 5; i++) {
      objects[i] = new ParseObject('Person');
      objects[i].id = 'pid' + i;
      response.push({
        success: { objectId: 'pid' + i },
      });
    }
    mockFetch([{ status: 200, response }]);

    await objectController.destroy(objects, {});
    expect(fetch.mock.calls[0][0]).toEqual('https://api.parse.com/1/batch');
    expect(JSON.parse(fetch.mock.calls[0][1].body).requests).toEqual([
      {
        method: 'DELETE',
        path: '/1/classes/Person/pid0',
        body: {},
      },
      {
        method: 'DELETE',
        path: '/1/classes/Person/pid1',
        body: {},
      },
      {
        method: 'DELETE',
        path: '/1/classes/Person/pid2',
        body: {},
      },
      {
        method: 'DELETE',
        path: '/1/classes/Person/pid3',
        body: {},
      },
      {
        method: 'DELETE',
        path: '/1/classes/Person/pid4',
        body: {},
      },
    ]);

    objects = [];
    response = [];
    for (let i = 0; i < 22; i++) {
      objects[i] = new ParseObject('Person');
      objects[i].id = 'pid' + i;
      response.push({
        success: { objectId: 'pid' + i },
      });
    }
    mockFetch([{ status: 200, response }, { status: 200, response: response.slice(20) }]);

    await objectController.destroy(objects, {});
    expect(fetch.mock.calls.length).toBe(2);
    expect(JSON.parse(fetch.mock.calls[0][1].body).requests.length).toBe(20);
    expect(JSON.parse(fetch.mock.calls[1][1].body).requests.length).toBe(2);
  });

  it('can destroy the object eventually on network failure', async () => {
    const p = new ParseObject('Person');
    jest.spyOn(EventuallyQueue, 'destroy').mockImplementationOnce(() => Promise.resolve());
    jest.spyOn(EventuallyQueue, 'poll').mockImplementationOnce(() => { });
    jest.spyOn(p, 'destroy').mockImplementationOnce(() => {
      throw new ParseError(
        ParseError.CONNECTION_FAILED,
        'XMLHttpRequest failed: ""Unable to connect to the Parse API""'
      );
    });
    await p.destroyEventually();
    expect(EventuallyQueue.destroy).toHaveBeenCalledTimes(1);
    expect(EventuallyQueue.poll).toHaveBeenCalledTimes(1);
  });

  it('should not destroy object eventually on error', async () => {
    const p = new ParseObject('Person');
    jest.spyOn(EventuallyQueue, 'destroy').mockImplementationOnce(() => Promise.resolve());
    jest.spyOn(EventuallyQueue, 'poll').mockImplementationOnce(() => { });
    jest.spyOn(p, 'destroy').mockImplementationOnce(() => {
      throw new ParseError(ParseError.OTHER_CAUSE, 'Unable to delete.');
    });
    await p.destroyEventually();
    expect(EventuallyQueue.destroy).toHaveBeenCalledTimes(0);
    expect(EventuallyQueue.poll).toHaveBeenCalledTimes(0);
  });

  it('can save an object', async () => {
    const objectController = CoreManager.getObjectController();
    mockFetch([{ status: 200, response: { objectId: 'pid', key: 'value' } }]);

    const p = new ParseObject('Person');
    p.id = 'pid';
    p.set('key', 'value');
    await objectController.save(p, {});
    expect(fetch.mock.calls[0][0]).toEqual('https://api.parse.com/1/classes/Person/pid');
    const body = JSON.parse(fetch.mock.calls[0][1].body);
    expect(body.key).toBe('value');
  });

  it('returns an empty promise from an empty save', done => {
    const objectController = CoreManager.getObjectController();
    objectController.save().then(() => {
      done();
    });
    jest.runAllTicks();
  });

  it('can save an array of files', async () => {
    const objectController = CoreManager.getObjectController();
    const names = ['parse.txt', 'parse2.txt', 'parse3.txt'];
    const responses = [];
    for (let i = 0; i < 3; i++) {
      responses.push({
        status: 200,
        response: {
          name: names[i],
          url: 'http://files.parsetfss.com/a/' + names[i],
        },
      });
    }
    mockFetch(responses);
    const files = [
      new ParseFile('parse.txt', { base64: 'ParseA==' }),
      new ParseFile('parse2.txt', { base64: 'ParseA==' }),
      new ParseFile('parse3.txt', { base64: 'ParseA==' }),
    ];
    await objectController.save(files, {});
    // TODO: why they all have same url?
    // expect(files[0].url()).toBe('http://files.parsetfss.com/a/parse.txt');
    // expect(files[1].url()).toBe('http://files.parsetfss.com/a/parse2.txt');
    expect(files[2].url()).toBe('http://files.parsetfss.com/a/parse3.txt');
  });

  it('can save an array of objects', async () => {
    const objectController = CoreManager.getObjectController();
    let response = [];
    const objects = [];
    for (let i = 0; i < 5; i++) {
      objects[i] = new ParseObject('Person');
      objects[i].set('index', i);
      response.push({
        success: { objectId: 'pid' + i, index: i },
      });
    }
    mockFetch([{ status: 200, response }]);
    const results = await objectController.save(objects, {});
    expect(results.length).toBe(5);
    expect(results[0].id).toBe('pid0');
    expect(results[0].get('index')).toBe(0);
    expect(results[0].dirty()).toBe(false);

    response = [];
    for (let i = 0; i < 22; i++) {
      objects[i] = new ParseObject('Person');
      objects[i].set('index', i);
      response.push({
        success: { objectId: 'pid' + i, index: i },
      });
    }
    mockFetch([
      { status: 200, response: response.slice(0, 20) },
      { status: 200, response: response.slice(20) },
    ]);
    const saved = await objectController.save(objects, {});

    for (let i = 0; i < saved.length; i += 1) {
      expect(objects[i].dirty()).toBe(false);
      expect(objects[i].id).toBe(`pid${i}`);
      expect(objects[i].get('index')).toBe(i);
    }
    expect(saved.length).toBe(22);
    expect(fetch.mock.calls.length).toBe(2);
  });

  it('does not fail when checking if arrays of pointers are dirty', async () => {
    mockFetch([
      { status: 200, response: [{ success: { objectId: 'i333' } }] },
      { status: 200, response: {} },
    ])
    const brand = ParseObject.fromJSON({
      className: 'Brand',
      objectId: 'b123',
      items: [{ __type: 'Pointer', objectId: 'i222', className: 'Item' }],
    });
    expect(brand._getSaveJSON()).toEqual({});
    const items = brand.get('items');
    items.push(new ParseObject('Item'));
    brand.set('items', items);
    expect(function () {
      brand.save();
    }).not.toThrow();
  });

  it('can create a new instance of an object', () => {
    const o = ParseObject.fromJSON({
      className: 'Clone',
      objectId: 'C12',
    });
    const o2 = o.newInstance();
    expect(o.id).toBe(o2.id);
    expect(o.className).toBe(o2.className);
    o.set({ valid: true });
    expect(o2.get('valid')).toBe(true);

    expect(o).not.toBe(o2);
  });

  it('cannot create a new instance of an object without className', () => {
    expect(() => {
      ParseObject.fromJSON({});
    }).toThrow('Cannot create an object without a className');
  });
});

describe('ParseObject (unique instance mode)', () => {
  beforeEach(() => {
    ParseObject.disableSingleInstance();
  });

  it('can be created with initial attributes', () => {
    const o = new ParseObject({
      className: 'Item',
      value: 12,
    });
    expect(o.className).toBe('Item');
    expect(o.attributes).toEqual({ value: 12 });
  });

  it('can be inflated from server JSON', () => {
    const json = {
      className: 'Item',
      createdAt: '2013-12-14T04:51:19Z',
      objectId: 'I1',
      size: 'medium',
    };
    const o = ParseObject.fromJSON(json);
    expect(o.className).toBe('Item');
    expect(o.id).toBe('I1');
    expect(o.attributes).toEqual({
      size: 'medium',
      createdAt: new Date(Date.UTC(2013, 11, 14, 4, 51, 19)),
      updatedAt: new Date(Date.UTC(2013, 11, 14, 4, 51, 19)),
    });
    expect(o.dirty()).toBe(false);
  });

  it('can be rendered to JSON', () => {
    let o = new ParseObject('Item');
    o.set({
      size: 'large',
      inStock: 18,
    });
    expect(o.toJSON()).toEqual({
      size: 'large',
      inStock: 18,
    });
    o = new ParseObject('Item');
    o._finishFetch({
      objectId: 'O2',
      size: 'medium',
      inStock: 12,
    });
    expect(o.id).toBe('O2');
    expect(o.toJSON()).toEqual({
      objectId: 'O2',
      size: 'medium',
      inStock: 12,
    });
  });

  it('can add, update, and remove attributes', () => {
    const o = new ParseObject({
      className: 'Item',
      objectId: 'anObjectId',
      value: 12,
      valid: true,
    });
    o.set({ value: 14 });
    expect(o.get('value')).toBe(14);
    o.unset('valid');
    expect(o.get('valid')).toBe(undefined);
    expect(o.dirtyKeys()).toEqual(['value', 'valid']);
    o.increment('value');
    expect(o.get('value')).toEqual(15);

    o.clear();
    expect(o.get('value')).toBe(undefined);

    const o2 = ParseObject.fromJSON({
      className: 'Item',
      tags: ['#tbt'],
    });

    o2.add('tags', '#nofilter');
    expect(o2.get('tags')).toEqual(['#tbt', '#nofilter']);

    o2.revert();
    o2.addUnique('tags', '#tbt');
    expect(o2.get('tags')).toEqual(['#tbt']);

    o2.revert();
    o2.remove('tags', '#tbt');
    expect(o2.get('tags')).toEqual([]);
  });

  it('can save the object', done => {
    mockFetch([
      {
        status: 200,
        response: {
          objectId: 'P1',
          count: 1,
        },
      },
    ]);
    const p = new ParseObject('Person');
    p.set('age', 38);
    p.increment('count');
    p.save().then(obj => {
      expect(obj).toBe(p);
      expect(obj.get('age')).toBe(38);
      expect(obj.get('count')).toBe(1);
      expect(obj.op('age')).toBe(undefined);
      expect(obj.dirty()).toBe(false);
      done();
    });
  });

  it('can save an array of objects', async () => {
    mockFetch([{
      status: 200,
      response: [
        { success: { objectId: 'pid0' } },
        { success: { objectId: 'pid1' } },
        { success: { objectId: 'pid2' } },
        { success: { objectId: 'pid3' } },
        { success: { objectId: 'pid4' } },
      ],
    }]);
    const objects = [];
    for (let i = 0; i < 5; i++) {
      objects[i] = new ParseObject('Person');
    }
    const results = await ParseObject.saveAll(objects);
    expect(results.every(obj => obj.id !== undefined)).toBe(true);
    expect(fetch.mock.calls[0][0]).toEqual('https://api.parse.com/1/batch');
    expect(JSON.parse(fetch.mock.calls[0][1].body).requests[0]).toEqual({
      method: 'POST',
      path: '/1/classes/Person',
      body: {},
    });
  });

  it('preserves changes when changing the id', () => {
    const o = new ParseObject({
      className: 'Item',
      objectId: 'anObjectId',
      value: 12,
    });
    o.id = 'otherId';
    expect(o.get('value')).toBe(12);
  });

  it('can maintain differences between two instances of an object', () => {
    const o = new ParseObject({
      className: 'Item',
      objectId: 'anObjectId',
      value: 12,
    });
    const o2 = new ParseObject({
      className: 'Item',
      objectId: 'anObjectId',
      value: 12,
    });
    o.set({ value: 100 });
    expect(o.get('value')).toBe(100);
    expect(o2.get('value')).toBe(12);

    o2.set({ name: 'foo' });
    expect(o.has('name')).toBe(false);
    expect(o2.has('name')).toBe(true);
  });

  it('can create a new instance of an object', () => {
    const o = ParseObject.fromJSON({
      className: 'Clone',
      objectId: 'C14',
    });
    let o2 = o.newInstance();
    expect(o.id).toBe(o2.id);
    expect(o.className).toBe(o2.className);
    expect(o).not.toBe(o2);
    o.set({ valid: true });
    expect(o2.get('valid')).toBe(undefined);
    o2 = o.newInstance();
    expect(o2.get('valid')).toBe(true);
  });
});

class MyObject extends ParseObject {
  constructor() {
    super('MyObject');
  }

  doSomething() {
    return 5;
  }

  static readOnlyAttributes() {
    return ['readonly', 'static', 'frozen'];
  }
}

ParseObject.registerSubclass('MyObject', MyObject);

describe('ParseObject Subclasses', () => {
  beforeEach(() => {
    ParseObject.enableSingleInstance();
  });

  it('can be extended with ES6 classes', () => {
    const o = new MyObject();
    expect(o.className).toBe('MyObject');
    expect(MyObject.className).toBe('MyObject');
    o.id = 'anObjectId';
    expect(o.toPointer()).toEqual({
      __type: 'Pointer',
      className: 'MyObject',
      objectId: 'anObjectId',
    });

    expect(o.doSomething()).toBe(5);

    const o2 = MyObject.createWithoutData('otherId');
    expect(o2 instanceof ParseObject).toBe(true);
    expect(o2 instanceof MyObject).toBe(true);
    expect(o2.toPointer()).toEqual({
      __type: 'Pointer',
      className: 'MyObject',
      objectId: 'otherId',
    });
    expect(o2.doSomething()).toBe(5);
  });

  it('respects readonly attributes of subclasses', () => {
    const o = new MyObject();
    o.set('readwrite', true);
    expect(o.set.bind(o, 'readonly')).toThrow('Cannot modify readonly attribute: readonly');
    expect(o.set.bind(o, 'static')).toThrow('Cannot modify readonly attribute: static');
    expect(o.set.bind(o, 'frozen')).toThrow('Cannot modify readonly attribute: frozen');
  });

  it('registerSubclass errors', () => {
    expect(() => {
      ParseObject.registerSubclass(1234);
    }).toThrow('The first argument must be a valid class name.');

    expect(() => {
      ParseObject.registerSubclass('TestObject', undefined);
    }).toThrow('You must supply a subclass constructor.');

    expect(() => {
      ParseObject.registerSubclass('TestObject', {});
    }).toThrow(
      'You must register the subclass constructor. Did you attempt to register an instance of the subclass?'
    );

    expect(() => {
      ParseObject.unregisterSubclass(1234);
    }).toThrow('The first argument must be a valid class name.');
  });

  it('can use on ParseObject subclass for multiple Parse.Object class names', () => {
    class MyParseObjects extends ParseObject { }
    ParseObject.registerSubclass('TestObject', MyParseObjects);
    ParseObject.registerSubclass('TestObject1', MyParseObjects);
    ParseObject.registerSubclass('TestObject2', MyParseObjects);

    const obj = new MyParseObjects('TestObject');
    expect(obj.className).toBe('TestObject');
    const obj1 = new MyParseObjects('TestObject1');
    expect(obj1.className).toBe('TestObject1');
    const obj2 = new MyParseObjects('TestObject2');
    expect(obj2.className).toBe('TestObject2');

    let classMap = ParseObject._getClassMap();
    expect(classMap.TestObject).toEqual(MyParseObjects);
    expect(classMap.TestObject1).toEqual(MyParseObjects);
    expect(classMap.TestObject2).toEqual(MyParseObjects);

    ParseObject.unregisterSubclass('TestObject');
    ParseObject.unregisterSubclass('TestObject1');
    ParseObject.unregisterSubclass('TestObject2');

    classMap = ParseObject._getClassMap();
    expect(classMap.TestObject).toBeUndefined();
    expect(classMap.TestObject1).toBeUndefined();
    expect(classMap.TestObject2).toBeUndefined();
  });

  it('can inflate subclasses from server JSON', () => {
    const json = {
      className: 'MyObject',
      objectId: 'anotherId',
    };
    const o = ParseObject.fromJSON(json);
    expect(o instanceof ParseObject).toBe(true);
    expect(o.className).toBe('MyObject');
    expect(o.id).toBe('anotherId');
    expect(o.doSomething()).toBe(5);
  });

  it('can be cloned', () => {
    const o = new MyObject();
    o.set({
      size: 'large',
      count: 7,
    });
    const o2 = o.clone();
    expect(o2 instanceof MyObject).toBe(true);
    expect(o2.className).toBe('MyObject');
    expect(o2.attributes).toEqual({
      size: 'large',
      count: 7,
    });
    expect(o2.id).toBe(undefined);
    expect(o.equals(o2)).toBe(false);
  });

  it('can be cleared', () => {
    const o = new MyObject();
    o.set({
      size: 'large',
      count: 7,
    });
    jest.spyOn(o, 'set');
    o.clear();
    expect(o.set).toHaveBeenCalledWith(
      {
        count: true,
        size: true,
      },
      {
        unset: true,
      }
    );
  });
});

describe('ParseObject extensions', () => {
  beforeEach(() => {
    ParseObject.enableSingleInstance();
  });

  it('can extend object', () => {
    const startExtend = Date.now();
    for (let i = 0; i < 100000; i++) {
      const Parent = ParseObject.extend('Parent');

      const parent = new Parent();
    }
    expect(Date.now() - startExtend).toBeLessThan(200);

    const startNew = Date.now();
    for (let i = 0; i < 100000; i++) {
      const parent = new ParseObject('Parent');
    }
    expect(Date.now() - startNew).toBeLessThan(200);
  });

  it('can generate ParseObjects with a default className', () => {
    const YourObject = ParseObject.extend('YourObject');
    const yo = new YourObject();
    expect(yo instanceof ParseObject).toBe(true);
    expect(yo instanceof YourObject).toBe(true);
    expect(yo.className).toBe('YourObject');
    yo.set('greeting', 'yo');
    expect(yo.get('greeting')).toBe('yo');
    expect(yo.attributes).toEqual({
      greeting: 'yo',
    });

    const yo2 = YourObject.createWithoutData('otherId');
    expect(yo2 instanceof ParseObject).toBe(true);
    expect(yo2 instanceof YourObject).toBe(true);
    expect(yo2.toPointer()).toEqual({
      __type: 'Pointer',
      className: 'YourObject',
      objectId: 'otherId',
    });
  });

  it('can extend the prototype and statics of ParseObject', () => {
    const ExtendedObject = ParseObject.extend(
      'ExtendedObject',
      {
        getFoo() {
          return 12;
        },
      },
      {
        isFoo(value) {
          return value === 'foo';
        },
      }
    );
    const e = new ExtendedObject();
    expect(e instanceof ParseObject).toBe(true);
    expect(e instanceof ExtendedObject).toBe(true);
    expect(e.getFoo()).toBe(12);
    expect(ExtendedObject.isFoo(12)).toBe(false);
    expect(ExtendedObject.isFoo('foo')).toBe(true);
  });

  it('can extend a previous extension', () => {
    let FeatureObject = ParseObject.extend('FeatureObject', {
      foo() {
        return 'F';
      },
    });
    let f = new FeatureObject();
    expect(f.foo()).toBe('F');
    FeatureObject = ParseObject.extend('FeatureObject', {
      bar() {
        return 'B';
      },
    });
    f = new FeatureObject();
    expect(f.foo() + f.bar()).toBe('FB');
  });

  it('can specify a custom initializer', () => {
    const InitObject = ParseObject.extend('InitObject', {
      initialize: function () {
        this.set('field', 12);
      },
    });

    const i = new InitObject();
    expect(i.get('field')).toBe(12);
  });

  it('can handle className parameters', () => {
    expect(() => {
      ParseObject.extend();
    }).toThrow(""Parse.Object.extend's first argument should be the className."");

    let CustomObject = ParseObject.extend('Item');
    expect(CustomObject.className).toBe('Item');

    CustomObject = ParseObject.extend({ className: 'Test' });
    expect(CustomObject.className).toBe('Test');
  });

  it('can extend with user rewrite', () => {
    const CustomObject = ParseObject.extend('User');
    expect(CustomObject.className).toBe('_User');
  });

  it('can extend multiple subclasses', () => {
    const CustomObject = ParseObject.extend('Item');
    expect(() => {
      new CustomObject({ 'invalid#name': 'bar' });
    }).toThrow(""Can't create an invalid Parse Object"");

    const CustomUserObject = CustomObject.extend('User');
    const CustomRewrite = CustomUserObject.extend();
    expect(CustomRewrite.className).toBe('_User');
  });
});

describe('ParseObject pin', () => {
  beforeEach(() => {
    ParseObject.enableSingleInstance();
    jest.clearAllMocks();
    mockLocalDatastore.isEnabled = true;
  });

  it('can pin to default', async () => {
    const object = new ParseObject('Item');
    await object.pin();
    expect(mockLocalDatastore._handlePinAllWithName).toHaveBeenCalledTimes(1);
    expect(mockLocalDatastore._handlePinAllWithName).toHaveBeenCalledWith(DEFAULT_PIN, [object]);
  });

  it('can unPin to default', async () => {
    const object = new ParseObject('Item');
    await object.unPin();
    expect(mockLocalDatastore._handleUnPinAllWithName).toHaveBeenCalledTimes(1);
    expect(mockLocalDatastore._handleUnPinAllWithName).toHaveBeenCalledWith(DEFAULT_PIN, [object]);
  });

  it('can pin to specific pin', async () => {
    const object = new ParseObject('Item');
    await object.pinWithName('test_pin');
    expect(mockLocalDatastore._handlePinAllWithName).toHaveBeenCalledTimes(1);
    expect(mockLocalDatastore._handlePinAllWithName).toHaveBeenCalledWith('test_pin', [object]);
  });

  it('can unPin to specific', async () => {
    const object = new ParseObject('Item');
    await object.unPinWithName('test_pin');
    expect(mockLocalDatastore._handleUnPinAllWithName).toHaveBeenCalledTimes(1);
    expect(mockLocalDatastore._handleUnPinAllWithName).toHaveBeenCalledWith('test_pin', [object]);
  });

  it('can check if pinned', async () => {
    const object = new ParseObject('Item');
    object.id = '1234';
    mockLocalDatastore.fromPinWithName
      .mockImplementationOnce(() => {
        return [object._toFullJSON()];
      })
      .mockImplementationOnce(() => []);

    let isPinned = await object.isPinned();
    expect(isPinned).toEqual(true);
    isPinned = await object.isPinned();
    expect(isPinned).toEqual(false);
  });

  it('can fetchFromLocalDatastore', async () => {
    const object = new ParseObject('Item');
    object.id = '123';
    mockLocalDatastore.getKeyForObject.mockImplementationOnce(() => 'Item_123');

    mockLocalDatastore._serializeObject.mockImplementationOnce(() => object._toFullJSON());

    await object.fetchFromLocalDatastore();
    expect(mockLocalDatastore._serializeObject).toHaveBeenCalledTimes(1);
    expect(mockLocalDatastore._serializeObject).toHaveBeenCalledWith('Item_123');
  });

  it('cannot fetchFromLocalDatastore if unsaved', async () => {
    try {
      const object = new ParseObject('Item');
      await object.fetchFromLocalDatastore();
    } catch (e) {
      expect(e.message).toBe('Cannot fetch an unsaved ParseObject');
    }
  });

  it('can pinAll', async () => {
    const obj1 = new ParseObject('Item');
    const obj2 = new ParseObject('Item');
    await ParseObject.pinAll([obj1, obj2]);
    expect(mockLocalDatastore._handlePinAllWithName).toHaveBeenCalledTimes(1);
    expect(mockLocalDatastore._handlePinAllWithName.mock.calls[0]).toEqual([
      DEFAULT_PIN,
      [obj1, obj2],
    ]);
  });

  it('can unPinAll', async () => {
    const obj1 = new ParseObject('Item');
    const obj2 = new ParseObject('Item');
    await ParseObject.unPinAll([obj1, obj2]);
    expect(mockLocalDatastore._handleUnPinAllWithName).toHaveBeenCalledTimes(1);
    expect(mockLocalDatastore._handleUnPinAllWithName.mock.calls[0]).toEqual([
      DEFAULT_PIN,
      [obj1, obj2],
    ]);
  });

  it('can unPinAllObjects', async () => {
    await ParseObject.unPinAllObjects();
    expect(mockLocalDatastore.unPinWithName).toHaveBeenCalledTimes(1);
    expect(mockLocalDatastore.unPinWithName.mock.calls[0]).toEqual([DEFAULT_PIN]);
  });

  it('can unPinAllObjectsWithName', async () => {
    await ParseObject.unPinAllObjectsWithName('123');
    expect(mockLocalDatastore.unPinWithName).toHaveBeenCalledTimes(1);
    expect(mockLocalDatastore.unPinWithName.mock.calls[0]).toEqual([PIN_PREFIX + '123']);
  });

  it('cannot pin when localDatastore disabled', async () => {
    mockLocalDatastore.isEnabled = false;
    const name = 'test_pin';
    const obj = new ParseObject('Item');
    try {
      await obj.pin();
    } catch (error) {
      expect(error).toBe('Parse.enableLocalDatastore() must be called first');
    }
    try {
      await obj.unPin();
    } catch (error) {
      expect(error).toBe('Parse.enableLocalDatastore() must be called first');
    }
    try {
      await obj.isPinned();
    } catch (error) {
      expect(error).toBe('Parse.enableLocalDatastore() must be called first');
    }
    try {
      await obj.pinWithName();
    } catch (error) {
      expect(error).toBe('Parse.enableLocalDatastore() must be called first');
    }
    try {
      await obj.unPinWithName();
    } catch (error) {
      expect(error).toBe('Parse.enableLocalDatastore() must be called first');
    }
    try {
      await obj.fetchFromLocalDatastore();
    } catch (error) {
      expect(error.message).toBe('Parse.enableLocalDatastore() must be called first');
    }
    try {
      await ParseObject.pinAll([obj]);
    } catch (error) {
      expect(error).toBe('Parse.enableLocalDatastore() must be called first');
    }
    try {
      await ParseObject.unPinAll([obj]);
    } catch (error) {
      expect(error).toBe('Parse.enableLocalDatastore() must be called first');
    }
    try {
      await ParseObject.pinAllWithName(name, [obj]);
    } catch (error) {
      expect(error).toBe('Parse.enableLocalDatastore() must be called first');
    }
    try {
      await ParseObject.unPinAllWithName(name, [obj]);
    } catch (error) {
      expect(error).toBe('Parse.enableLocalDatastore() must be called first');
    }
    try {
      await ParseObject.unPinAllObjects();
    } catch (error) {
      expect(error).toBe('Parse.enableLocalDatastore() must be called first');
    }
    try {
      await ParseObject.unPinAllObjectsWithName(name);
    } catch (error) {
      expect(error).toBe('Parse.enableLocalDatastore() must be called first');
    }
  });
  it('gets id for new object when cascadeSave = false and singleInstance = false', done => {
    ParseObject.disableSingleInstance();
    mockFetch([
      {
        status: 200,
        response: {
          objectId: 'P5',
        },
      },
    ])
    const p = new ParseObject('Person');
    p.save(null, { cascadeSave: false }).then(obj => {
      expect(obj).toBe(p);
      expect(obj.id).toBe('P5');
      done();
    });
  });

  it('can allowCustomObjectId', async () => {
    CoreManager.set('ALLOW_CUSTOM_OBJECT_ID', true);
    const o = new ParseObject('Person');
    o.id = '';
    let params = o._getSaveParams();
    expect(params).toEqual({
      method: 'POST',
      body: { objectId: '' },
      path: 'classes/Person',
    });
    await expect(o.save()).rejects.toEqual(
      new ParseError(ParseError.MISSING_OBJECT_ID, 'objectId must not be empty or null')
    );
    await expect(ParseObject.saveAll([o])).rejects.toEqual(
      new ParseError(ParseError.MISSING_OBJECT_ID, 'objectId must not be empty or null')
    );
    o._finishFetch({
      objectId: 'CUSTOM_ID',
      createdAt: { __type: 'Date', iso: new Date().toISOString() },
      updatedAt: { __type: 'Date', iso: new Date().toISOString() },
    });
    params = o._getSaveParams();
    expect(params).toEqual({
      method: 'PUT',
      body: {},
      path: 'classes/Person/CUSTOM_ID',
    });
    CoreManager.set('ALLOW_CUSTOM_OBJECT_ID', false);
  });

  it('can log an object', () => {
    CoreManager.set('NODE_LOGGING', true);
    const o = new ParseObject('Person', { foo: 'bar' });
    const symbol = Symbol.for('nodejs.util.inspect.custom');
    expect(o[symbol]()).toBe(
      `ParseObject: className: Person, id: undefined\nAttributes: {\n  \""foo\"": \""bar\""\n}`
    );
    CoreManager.set('NODE_LOGGING', false);
  });

  describe('Prototype Pollution Protection', () => {
    beforeEach(() => {
      // Clear any pollution before each test
      delete Object.prototype.polluted;
      delete Object.prototype.malicious;
      delete Object.prototype.exploit;
    });

    afterEach(() => {
      // Clean up after tests
      delete Object.prototype.polluted;
      delete Object.prototype.malicious;
      delete Object.prototype.exploit;
    });

    it('should not pollute Object.prototype via prototype className in registerSubclass', () => {
      const testObj = {};

      class MaliciousClass extends ParseObject {
        constructor() {
          super('prototype');
        }
      }

      ParseObject.registerSubclass('prototype', MaliciousClass);

      // Verify Object.prototype was not polluted
      expect(testObj.polluted).toBeUndefined();
      expect({}.polluted).toBeUndefined();
    });

    it('should not pollute Object.prototype when parsing JSON with __proto__ className', () => {
      const testObj = {};

      const maliciousJSON = {
        className: '__proto__',
        objectId: 'test123',
        polluted: 'yes',
      };

      ParseObject.fromJSON(maliciousJSON);

      // Verify Object.prototype was not polluted
      expect(testObj.polluted).toBeUndefined();
      expect({}.polluted).toBeUndefined();
    });

    it('should not pollute Object.prototype when parsing JSON with constructor className', () => {
      const testObj = {};

      const maliciousJSON = {
        className: 'constructor',
        objectId: 'test456',
        malicious: 'data',
      };

      ParseObject.fromJSON(maliciousJSON);

      // Verify Object.prototype was not polluted
      expect(testObj.malicious).toBeUndefined();
      expect({}.malicious).toBeUndefined();
    });

    it('should not pollute Object.prototype when parsing JSON with prototype className', () => {
      const testObj = {};

      const maliciousJSON = {
        className: 'prototype',
        objectId: 'test789',
        exploit: 'here',
      };

      ParseObject.fromJSON(maliciousJSON);

      // Verify Object.prototype was not polluted
      expect(testObj.exploit).toBeUndefined();
      expect({}.exploit).toBeUndefined();
    });

    it('should not pollute when creating objects with malicious class names', () => {
      const testObj = {};

      const maliciousClasses = ['__proto__', 'constructor', 'prototype'];

      maliciousClasses.forEach(className => {
        const obj = new ParseObject(className);
        obj.set('polluted', 'yes');
      });

      // Verify Object.prototype was not polluted
      expect(testObj.polluted).toBeUndefined();
      expect({}.polluted).toBeUndefined();
    });

    it('should not pollute when fromJSON is called multiple times with malicious classNames', () => {
      const testObj = {};

      const maliciousObjects = [
        { className: '__proto__', objectId: '1', polluted: 'yes' },
        { className: 'constructor', objectId: '2', malicious: 'data' },
        { className: 'prototype', objectId: '3', exploit: 'here' },
      ];

      maliciousObjects.forEach(json => ParseObject.fromJSON(json));

      // Verify Object.prototype was not polluted
      expect(testObj.polluted).toBeUndefined();
      expect(testObj.malicious).toBeUndefined();
      expect(testObj.exploit).toBeUndefined();
      expect({}.polluted).toBeUndefined();
      expect({}.malicious).toBeUndefined();
      expect({}.exploit).toBeUndefined();
    });
  });
});",0
"jest.dontMock('../decode');
jest.dontMock('../CoreManager');
jest.dontMock('../isDangerousKey');
jest.dontMock('../ParseFile');
jest.dontMock('../ParseGeoPoint');
jest.dontMock('../ParseObject');
jest.dontMock('../ParsePolygon');

const decode = require('../decode').default;

const ParseFile = require('../ParseFile').default;
const ParseGeoPoint = require('../ParseGeoPoint').default;
const ParseObject = require('../ParseObject').default;
const ParsePolygon = require('../ParsePolygon').default;

describe('decode', () => {
  it('ignores primitives', () => {
    expect(decode(undefined)).toBe(undefined);
    expect(decode(null)).toBe(null);
    expect(decode(true)).toBe(true);
    expect(decode(12)).toBe(12);
    expect(decode('string')).toBe('string');
  });

  it('decodes dates', () => {
    expect(
      decode({
        __type: 'Date',
        iso: '2015-02-01T00:00:00.000Z',
      })
    ).toEqual(new Date(Date.UTC(2015, 1)));
  });

  it('decodes GeoPoints', () => {
    const point = decode({
      __type: 'GeoPoint',
      latitude: 40.5,
      longitude: 50.4,
    });
    expect(point instanceof ParseGeoPoint).toBe(true);
    expect(point.latitude).toBe(40.5);
    expect(point.longitude).toBe(50.4);
  });

  it('decodes Polygons', () => {
    const points = [
      [0, 0],
      [0, 1],
      [1, 1],
      [1, 0],
      [0, 0],
    ];
    const polygon = decode({
      __type: 'Polygon',
      coordinates: points,
    });
    expect(polygon instanceof ParsePolygon).toBe(true);
    expect(polygon.coordinates).toEqual(points);
  });

  it('decodes Files', () => {
    const file = decode({
      __type: 'File',
      name: 'parse.txt',
      url: 'https://files.parsetfss.com/a/parse.txt',
    });
    expect(file instanceof ParseFile).toBe(true);
    expect(file.name()).toBe('parse.txt');
    expect(file.url()).toBe('https://files.parsetfss.com/a/parse.txt');
  });

  it('decodes Relations', () => {
    const obj = decode({
      __type: 'Relation',
      className: 'Delivery',
    });
    expect(obj.constructor.mock.calls[0]).toEqual([null, null]);
    expect(obj.targetClassName).toBe('Delivery');
  });

  it('decodes Pointers', () => {
    const spy = jest.spyOn(ParseObject, 'fromJSON');
    const data = {
      __type: 'Pointer',
      className: 'Item',
      objectId: '1001',
    };
    decode(data);
    expect(spy.mock.calls[0][0]).toEqual(data);
  });

  it('decodes ParseObjects', () => {
    const spy = jest.spyOn(ParseObject, 'fromJSON');
    const data = {
      __type: 'Object',
      className: 'Item',
      objectId: '1001',
    };
    decode(data);
    expect(spy.mock.calls[1][0]).toEqual(data);
  });

  it('iterates over arrays', () => {
    expect(decode([{ __type: 'Date', iso: '2015-02-01T00:00:00.000Z' }, 12, 'string'])).toEqual([
      new Date(Date.UTC(2015, 1)),
      12,
      'string',
    ]);
  });

  it('iterates over objects', () => {
    expect(
      decode({
        empty: null,
        when: { __type: 'Date', iso: '2015-04-01T00:00:00.000Z' },
        count: 15,
      })
    ).toEqual({
      empty: null,
      when: new Date(Date.UTC(2015, 3)),
      count: 15,
    });
  });

  describe('Prototype Pollution Protection', () => {
    beforeEach(() => {
      // Clear any pollution before each test
      delete Object.prototype.polluted;
      delete Object.prototype.malicious;
      delete Object.prototype.exploit;
    });

    afterEach(() => {
      // Clean up after tests
      delete Object.prototype.polluted;
      delete Object.prototype.malicious;
      delete Object.prototype.exploit;
    });

    it('should not pollute Object.prototype when decoding object with __proto__ key', () => {
      const testObj = {};
      const maliciousInput = {
        normalKey: 'value',
        __proto__: { polluted: 'yes' },
      };

      const result = decode(maliciousInput);

      // Verify Object.prototype was not polluted
      expect(testObj.polluted).toBeUndefined();
      expect({}.polluted).toBeUndefined();
      expect(Object.prototype.polluted).toBeUndefined();

      // Verify result only has own property
      expect(Object.prototype.hasOwnProperty.call(result, '__proto__')).toBe(false);
      expect(result.normalKey).toBe('value');
    });

    it('should not pollute Object.prototype when decoding object with constructor key', () => {
      const testObj = {};
      const maliciousInput = {
        normalKey: 'value',
        constructor: { polluted: 'yes' },
      };

      const result = decode(maliciousInput);

      // Verify Object.prototype was not polluted
      expect(testObj.polluted).toBeUndefined();
      expect({}.polluted).toBeUndefined();
      expect(Object.prototype.polluted).toBeUndefined();

      // Verify result doesn't contain constructor from prototype chain
      expect(result.normalKey).toBe('value');
    });

    it('should not pollute Object.prototype when decoding object with prototype key', () => {
      const testObj = {};
      const maliciousInput = {
        normalKey: 'value',
        prototype: { polluted: 'yes' },
      };

      const result = decode(maliciousInput);

      // Verify Object.prototype was not polluted
      expect(testObj.polluted).toBeUndefined();
      expect({}.polluted).toBeUndefined();
      expect(Object.prototype.polluted).toBeUndefined();

      // Verify result contains only own properties
      expect(result.normalKey).toBe('value');
    });

    it('should not pollute Object.prototype when decoding nested objects with dangerous keys', () => {
      const testObj = {};
      const maliciousInput = {
        nested: {
          __proto__: { polluted: 'nested' },
          data: 'value',
        },
        normal: 'key',
      };

      const result = decode(maliciousInput);

      // Verify Object.prototype was not polluted
      expect(testObj.polluted).toBeUndefined();
      expect({}.polluted).toBeUndefined();
      expect(Object.prototype.polluted).toBeUndefined();

      // Verify result structure
      expect(result.normal).toBe('key');
      expect(result.nested).toBeDefined();
      expect(result.nested.data).toBe('value');
      expect(Object.prototype.hasOwnProperty.call(result.nested, '__proto__')).toBe(false);
    });

    it('should not pollute Object.prototype when decoding arrays with objects containing dangerous keys', () => {
      const testObj = {};
      const maliciousInput = [
        { __proto__: { polluted: 'array1' } },
        { constructor: { malicious: 'array2' } },
        { normalKey: 'value' },
      ];

      const result = decode(maliciousInput);

      // Verify Object.prototype was not polluted
      expect(testObj.polluted).toBeUndefined();
      expect(testObj.malicious).toBeUndefined();
      expect({}.polluted).toBeUndefined();
      expect({}.malicious).toBeUndefined();
      expect(Object.prototype.polluted).toBeUndefined();
      expect(Object.prototype.malicious).toBeUndefined();

      // Verify result array
      expect(Array.isArray(result)).toBe(true);
      expect(result.length).toBe(3);
      expect(result[2].normalKey).toBe('value');
    });

    it('should only decode own properties, not inherited ones', () => {
      const parent = { inherited: 'parent' };
      const child = Object.create(parent);
      child.own = 'child';

      const result = decode(child);

      // Should only include own property
      expect(result.own).toBe('child');
      expect(result.inherited).toBeUndefined();
    });

    it('should not decode properties from prototype chain', () => {
      Object.prototype.exploit = 'malicious';
      const obj = { normalKey: 'value' };

      const result = decode(obj);

      // Should not include prototype property
      expect(result.normalKey).toBe('value');
      expect(Object.prototype.hasOwnProperty.call(result, 'exploit')).toBe(false);

      delete Object.prototype.exploit;
    });

    it('should not pollute Object.prototype when decoding Parse type with dangerous className', () => {
      const testObj = {};
      const maliciousInput = {
        __type: 'Pointer',
        className: '__proto__',
        objectId: 'test123',
      };

      // This should be handled by ParseObject.fromJSON
      decode(maliciousInput);

      // Verify Object.prototype was not polluted
      expect(testObj.polluted).toBeUndefined();
      expect({}.polluted).toBeUndefined();
      expect(Object.prototype.polluted).toBeUndefined();
    });

    it('should not pollute Object.prototype when decoding deeply nested dangerous keys', () => {
      const testObj = {};
      const maliciousInput = {
        level1: {
          level2: {
            level3: {
              __proto__: { polluted: 'deep' },
              normalData: 'value',
            },
          },
        },
      };

      const result = decode(maliciousInput);

      // Verify Object.prototype was not polluted
      expect(testObj.polluted).toBeUndefined();
      expect({}.polluted).toBeUndefined();
      expect(Object.prototype.polluted).toBeUndefined();

      // Verify result structure is preserved (without dangerous keys)
      expect(result.level1.level2.level3.normalData).toBe('value');
      expect(Object.prototype.hasOwnProperty.call(result.level1.level2.level3, '__proto__')).toBe(
        false
      );
    });
  });
});",0
"jest.dontMock('../encode');
jest.dontMock('../isDangerousKey');
jest.dontMock('../ParseACL');
jest.dontMock('../ParseFile');
jest.dontMock('../ParseGeoPoint');
jest.dontMock('../ParseOp');
jest.dontMock('../ParseUser');
jest.dontMock('../CoreManager');

const mockObject = function (className) {
  this.className = className;
};
mockObject.registerSubclass = function () {};
mockObject.prototype = {
  _getServerData() {
    return this._serverData;
  },
  toPointer() {
    return 'POINTER';
  },
  toOfflinePointer() {
    return 'OFFLINE_POINTER';
  },
  _getId() {
    return 'local1234';
  },
  dirty() {},
  toJSON() {
    return this.attributes;
  },
  _toFullJSON(seen, offline) {
    const json = {
      __type: 'Object',
      className: this.className,
    };
    for (const attr in this.attributes) {
      json[attr] = encode(this.attributes[attr], false, false, seen.concat(this), offline);
    }
    return json;
  },
};
jest.setMock('../ParseObject', {
  __esModule: true,
  default: mockObject,
});

const encode = require('../encode').default;
const ParseACL = require('../ParseACL').default;
const ParseFile = require('../ParseFile').default;
const ParseGeoPoint = require('../ParseGeoPoint').default;
const ParseObject = require('../ParseObject').default;
const ParseRelation = require('../ParseRelation').default;
const CoreManager = require('../CoreManager').default;
CoreManager.setParseObject(mockObject);
CoreManager.setParseOp(require('../ParseOp'));
CoreManager.setParseUser(require('../ParseUser').default);

describe('encode', () => {
  it('ignores primitives', () => {
    expect(encode(undefined)).toBe(undefined);
    expect(encode(null)).toBe(null);
    expect(encode(true)).toBe(true);
    expect(encode(12)).toBe(12);
    expect(encode('string')).toBe('string');
  });

  it('encodes dates', () => {
    expect(encode(new Date(Date.UTC(2015, 1)))).toEqual({
      __type: 'Date',
      iso: '2015-02-01T00:00:00.000Z',
    });
    expect(encode.bind(null, new Date(Date.parse(null)))).toThrow(
      'Tried to encode an invalid date.'
    );
  });

  it('encodes regular expressions', () => {
    expect(encode(new RegExp('^hello'))).toEqual('^hello');
    expect(encode(/a[^b]+c/g)).toEqual('a[^b]+c');
  });

  it('encodes GeoPoints', () => {
    const point = new ParseGeoPoint(40.5, 50.4);
    expect(encode(point)).toEqual({
      __type: 'GeoPoint',
      latitude: 40.5,
      longitude: 50.4,
    });
  });

  it('encodes Files', () => {
    const file = new ParseFile('parse.txt');
    expect(encode.bind(null, file)).toThrow('Tried to encode an unsaved file.');
    file._url = 'https://files.parsetfss.com/a/parse.txt';
    expect(encode(file)).toEqual({
      __type: 'File',
      name: 'parse.txt',
      url: 'https://files.parsetfss.com/a/parse.txt',
    });
  });

  it('encodes Relations', () => {
    const rel = new ParseRelation();
    encode(rel);
    expect(rel.toJSON.mock.calls.length).toBe(1);
  });

  it('encodes ACLs', () => {
    const acl = new ParseACL({ aUserId: { read: true, write: false } });
    expect(encode(acl)).toEqual({
      aUserId: {
        read: true,
        write: false,
      },
    });
  });

  it('encodes ParseObjects', () => {
    const obj = new ParseObject('Item');
    obj._serverData = {};
    expect(encode(obj)).toEqual('POINTER');

    obj._serverData = obj.attributes = {
      str: 'string',
      date: new Date(Date.UTC(2015, 1, 1)),
    };
    expect(encode(obj)).toEqual({
      __type: 'Object',
      className: 'Item',
      str: 'string',
      date: {
        __type: 'Date',
        iso: '2015-02-01T00:00:00.000Z',
      },
    });

    obj.attributes.self = obj;
    expect(encode(obj)).toEqual({
      __type: 'Object',
      className: 'Item',
      str: 'string',
      date: {
        __type: 'Date',
        iso: '2015-02-01T00:00:00.000Z',
      },
      self: 'POINTER',
    });
  });

  it('encodes ParseObjects offline', () => {
    const obj = new ParseObject('Item');
    obj._serverData = {};
    expect(encode(obj, false, false, undefined, true)).toEqual('OFFLINE_POINTER');
    obj._serverData = obj.attributes = {
      str: 'string',
      date: new Date(Date.UTC(2015, 1, 1)),
    };
    obj.attributes.self = obj;

    expect(encode(obj, false, false, undefined, true)).toEqual({
      __type: 'Object',
      className: 'Item',
      str: 'string',
      date: {
        __type: 'Date',
        iso: '2015-02-01T00:00:00.000Z',
      },
      self: 'OFFLINE_POINTER',
    });
  });

  it('does not encode ParseObjects when they are disallowed', () => {
    const obj = new ParseObject('Item');
    expect(encode.bind(null, obj, true)).toThrow('Parse Objects not allowed here');
  });

  it('iterates over arrays', () => {
    let arr = [12, new Date(Date.UTC(2015, 1)), 'str'];
    expect(encode(arr)).toEqual([12, { __type: 'Date', iso: '2015-02-01T00:00:00.000Z' }, 'str']);

    arr = [arr];
    expect(encode(arr)).toEqual([[12, { __type: 'Date', iso: '2015-02-01T00:00:00.000Z' }, 'str']]);
  });

  it('iterates over objects', () => {
    const obj = {
      num: 12,
      date: new Date(Date.UTC(2015, 1)),
      str: 'abc',
    };
    expect(encode(obj)).toEqual({
      num: 12,
      date: { __type: 'Date', iso: '2015-02-01T00:00:00.000Z' },
      str: 'abc',
    });
  });

  describe('Prototype Pollution Protection', () => {
    beforeEach(() => {
      // Clear any pollution before each test
      delete Object.prototype.polluted;
      delete Object.prototype.malicious;
      delete Object.prototype.exploit;
    });

    afterEach(() => {
      // Clean up after tests
      delete Object.prototype.polluted;
      delete Object.prototype.malicious;
      delete Object.prototype.exploit;
    });

    it('should not pollute Object.prototype when encoding object with __proto__ key', () => {
      const testObj = {};
      const maliciousInput = {
        normalKey: 'value',
        __proto__: { polluted: 'yes' },
      };

      const result = encode(maliciousInput);

      // Verify Object.prototype was not polluted
      expect(testObj.polluted).toBeUndefined();
      expect({}.polluted).toBeUndefined();
      expect(Object.prototype.polluted).toBeUndefined();

      // Verify result only has own property
      expect(Object.prototype.hasOwnProperty.call(result, '__proto__')).toBe(false);
      expect(result.normalKey).toBe('value');
    });

    it('should not pollute Object.prototype when encoding object with constructor key', () => {
      const testObj = {};
      const maliciousInput = {
        normalKey: 'value',
        constructor: { polluted: 'yes' },
      };

      const result = encode(maliciousInput);

      // Verify Object.prototype was not polluted
      expect(testObj.polluted).toBeUndefined();
      expect({}.polluted).toBeUndefined();
      expect(Object.prototype.polluted).toBeUndefined();

      // Verify result doesn't contain constructor from prototype chain
      expect(result.normalKey).toBe('value');
    });

    it('should not pollute Object.prototype when encoding object with prototype key', () => {
      const testObj = {};
      const maliciousInput = {
        normalKey: 'value',
        prototype: { polluted: 'yes' },
      };

      const result = encode(maliciousInput);

      // Verify Object.prototype was not polluted
      expect(testObj.polluted).toBeUndefined();
      expect({}.polluted).toBeUndefined();
      expect(Object.prototype.polluted).toBeUndefined();

      // Verify result contains only own properties
      expect(result.normalKey).toBe('value');
    });

    it('should not pollute Object.prototype when encoding nested objects with dangerous keys', () => {
      const testObj = {};
      const maliciousInput = {
        nested: {
          __proto__: { polluted: 'nested' },
          data: 'value',
        },
        normal: 'key',
      };

      const result = encode(maliciousInput);

      // Verify Object.prototype was not polluted
      expect(testObj.polluted).toBeUndefined();
      expect({}.polluted).toBeUndefined();
      expect(Object.prototype.polluted).toBeUndefined();

      // Verify result structure
      expect(result.normal).toBe('key');
      expect(result.nested).toBeDefined();
      expect(result.nested.data).toBe('value');
      expect(Object.prototype.hasOwnProperty.call(result.nested, '__proto__')).toBe(false);
    });

    it('should not pollute Object.prototype when encoding arrays with objects containing dangerous keys', () => {
      const testObj = {};
      const maliciousInput = [
        { __proto__: { polluted: 'array1' } },
        { constructor: { malicious: 'array2' } },
        { normalKey: 'value' },
      ];

      const result = encode(maliciousInput);

      // Verify Object.prototype was not polluted
      expect(testObj.polluted).toBeUndefined();
      expect(testObj.malicious).toBeUndefined();
      expect({}.polluted).toBeUndefined();
      expect({}.malicious).toBeUndefined();
      expect(Object.prototype.polluted).toBeUndefined();
      expect(Object.prototype.malicious).toBeUndefined();

      // Verify result array
      expect(Array.isArray(result)).toBe(true);
      expect(result.length).toBe(3);
      expect(result[2].normalKey).toBe('value');
    });

    it('should only encode own properties, not inherited ones', () => {
      const parent = { inherited: 'parent' };
      const child = Object.create(parent);
      child.own = 'child';

      const result = encode(child);

      // Should only include own property
      expect(result.own).toBe('child');
      expect(result.inherited).toBeUndefined();
    });

    it('should not encode properties from prototype chain', () => {
      Object.prototype.exploit = 'malicious';
      const obj = { normalKey: 'value' };

      const result = encode(obj);

      // Should not include prototype property
      expect(result.normalKey).toBe('value');
      expect(Object.prototype.hasOwnProperty.call(result, 'exploit')).toBe(false);

      delete Object.prototype.exploit;
    });
  });
});",0
"import CoreManager from './CoreManager';
import ParseFile from './ParseFile';
import ParseGeoPoint from './ParseGeoPoint';
import ParsePolygon from './ParsePolygon';
import ParseRelation from './ParseRelation';
import { isDangerousKey } from ""./isDangerousKey"";

export default function decode(value: any): any {
  if (value === null || typeof value !== 'object' || value instanceof Date) {
    return value;
  }
  if (Array.isArray(value)) {
    const dup = [];
    value.forEach((v, i) => {
      dup[i] = decode(v);
    });
    return dup;
  }
  if (typeof value.__op === 'string') {
    const { opFromJSON } = CoreManager.getParseOp();
    return opFromJSON(value);
  }
  const ParseObject = CoreManager.getParseObject();
  if (value.__type === 'Pointer' && value.className) {
    return ParseObject.fromJSON(value);
  }
  if (value.__type === 'Object' && value.className) {
    return ParseObject.fromJSON(value);
  }
  if (value.__type === 'Relation') {
    // The parent and key fields will be populated by the parent
    const relation = new ParseRelation(null, null);
    relation.targetClassName = value.className;
    return relation;
  }
  if (value.__type === 'Date') {
    return new Date(value.iso);
  }
  if (value.__type === 'File') {
    return ParseFile.fromJSON(value);
  }
  if (value.__type === 'GeoPoint') {
    return new ParseGeoPoint({
      latitude: value.latitude,
      longitude: value.longitude,
    });
  }
  if (value.__type === 'Polygon') {
    return new ParsePolygon(value.coordinates);
  }
  const copy = {};
  for (const k in value) {
    if (Object.prototype.hasOwnProperty.call(value, k)) {
      // Skip dangerous keys that could pollute prototypes
      if (isDangerousKey(k)) {
        continue;
      }
      copy[k] = decode(value[k]);
    }
  }
  return copy;
}",0
"import CoreManager from './CoreManager';
import ParseACL from './ParseACL';
import ParseFile from './ParseFile';
import ParseGeoPoint from './ParseGeoPoint';
import ParsePolygon from './ParsePolygon';
import ParseRelation from './ParseRelation';
import { isDangerousKey } from ""./isDangerousKey"";

function encode(
  value: any,
  disallowObjects: boolean,
  forcePointers: boolean,
  seen: any[],
  offline: boolean
): any {
  const ParseObject = CoreManager.getParseObject();
  if (value instanceof ParseObject) {
    if (disallowObjects) {
      throw new Error('Parse Objects not allowed here');
    }
    const seenEntry = value.id ? value.className + ':' + value.id : value;
    if (
      forcePointers ||
      !seen ||
      seen.indexOf(seenEntry) > -1 ||
      value.dirty() ||
      Object.keys(value._getServerData()).length < 1
    ) {
      if (offline && value._getId().startsWith('local')) {
        return value.toOfflinePointer();
      }
      return value.toPointer();
    }
    seen = seen.concat(seenEntry);
    return value._toFullJSON(seen, offline);
  }
  const { Op } = CoreManager.getParseOp();
  if (
    value instanceof Op ||
    value instanceof ParseACL ||
    value instanceof ParseGeoPoint ||
    value instanceof ParsePolygon ||
    value instanceof ParseRelation
  ) {
    return value.toJSON();
  }
  if (value instanceof ParseFile) {
    if (!value.url()) {
      throw new Error('Tried to encode an unsaved file.');
    }
    return value.toJSON();
  }
  if (Object.prototype.toString.call(value) === '[object Date]') {
    if (isNaN(value)) {
      throw new Error('Tried to encode an invalid date.');
    }
    return { __type: 'Date', iso: (value as Date).toJSON() };
  }
  if (
    Object.prototype.toString.call(value) === '[object RegExp]' &&
    typeof value.source === 'string'
  ) {
    return value.source;
  }

  if (Array.isArray(value)) {
    return value.map(v => {
      return encode(v, disallowObjects, forcePointers, seen, offline);
    });
  }

  if (value && typeof value === 'object') {
    const output = {};
    for (const k in value) {
      // Only iterate over own properties
      if (Object.prototype.hasOwnProperty.call(value, k)) {
        // Skip dangerous keys that could pollute prototypes
        if (isDangerousKey(k)) {
          continue;
        }
        output[k] = encode(
          value[k],
          disallowObjects,
          forcePointers,
          seen,
          offline
        );
      }
    }
    return output;
  }

  return value;
}",0
