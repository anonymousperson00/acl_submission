function,label
"public boolean isRequiresWebSocket() {
        if (viewManager != null && viewManager.getTopStructElement() != null && viewManager.getTopStructElement().getMetadataFields() != null) {
            return viewManager.getTopStructElement().getMetadataFields().containsKey(SolrConstants.ACCESSCONDITION_CONCURRENTUSE);
        }

        return false;
    }",0
"@Override
    public ParcelableGranteeMap getKeyPairGrants(String callerPackage, String alias) {
        final CallerIdentity caller = getCallerIdentity(callerPackage);
        Preconditions.checkCallAuthorization(canChooseCertificates(caller));

        final ArrayMap<Integer, Set<String>> result = new ArrayMap<>();
        mInjector.binderWithCleanCallingIdentity(() -> {
            try (KeyChainConnection keyChainConnection =
                         KeyChain.bindAsUser(mContext, caller.getUserHandle())) {
                final int[] granteeUids = keyChainConnection.getService().getGrants(alias);
                final PackageManager pm = mInjector.getPackageManager(caller.getUserId());

                for (final int uid : granteeUids) {
                    final String[] packages = pm.getPackagesForUid(uid);
                    if (packages == null) {
                        Slogf.wtf(LOG_TAG, ""No packages found for uid "" + uid);
                        continue;
                    }
                    result.put(uid, new ArraySet<String>(packages));
                }
            } catch (RemoteException e) {
                Slogf.e(LOG_TAG, ""Querying keypair grants"", e);
            } catch (InterruptedException e) {
                Slogf.w(LOG_TAG, ""Interrupted while querying keypair grants"", e);
                Thread.currentThread().interrupt();
            }
        });
        return new ParcelableGranteeMap(result);
    }",0
"private LengthSolrInputDocument getSolrDocument(EntityReference reference)
        throws SolrIndexerException, IllegalArgumentException, ExecutionContextException
    {
        SolrMetadataExtractor metadataExtractor = getMetadataExtractor(reference.getType());

        // If the entity type is supported, use the extractor to get the SolrInputDocuent.
        if (metadataExtractor != null) {
            // Set the document that belongs to the entity reference as context document to ensure that the correct
            // settings are loaded for the current document/wiki.
            XWikiContext context = this.xWikiContextProvider.get();
            try {
                XWikiDocument document = context.getWiki().getDocument(reference, context);

                return this.documentContextExecutor.call(() -> metadataExtractor.getSolrDocument(reference), document);
            } catch (SolrIndexerException | IllegalArgumentException e) {
                // Re-throw to avoid wrapping exceptions that are declared in the method signature.
                throw e;
            } catch (Exception e) {
                throw new SolrIndexerException(""Error executing the indexer in the context of the document to index"",
                    e);
            }
        }

        return null;
    }",1
"private void notifyForConfigSettingsChangeLocked(int key, String prefix,
                List<String> changedSettings) {

            // Increment the generation first, so observers always see the new value
            mGenerationRegistry.incrementGeneration(key);

            StringBuilder stringBuilder = new StringBuilder(prefix);
            for (int i = 0; i < changedSettings.size(); ++i) {
                stringBuilder.append(changedSettings.get(i).split(""/"")[1]).append(""/"");
            }

            final long token = Binder.clearCallingIdentity();
            try {
                notifySettingChangeForRunningUsers(key, stringBuilder.toString());
            } finally {
                Binder.restoreCallingIdentity(token);
            }

            // Always notify that our data changed
            mHandler.obtainMessage(MyHandler.MSG_NOTIFY_DATA_CHANGED).sendToTarget();
        }",0
"private static void traverse(final Binder binder, final String p, final ConfigObject root) {
    root.forEach((n, v) -> {
      if (v instanceof ConfigObject) {
        ConfigObject child = (ConfigObject) v;
        String path = p + n;
        Named named = Names.named(path);
        binder.bind(Config.class).annotatedWith(named).toInstance(child.toConfig());
        traverse(binder, path + ""."", child);
      }
    });
  }",0
"private final void sendPackageBroadcastLocked(int cmd, String[] packages, int userId) {
        mProcessList.sendPackageBroadcastLocked(cmd, packages, userId);
    }",0
"public void jumpTask(String procInsId, String currentTaskId, String targetTaskDefinitionKey, Map<String, Object> variables) {
		jumpTask(getTaskEntity(currentTaskId), targetTaskDefinitionKey, variables);
	}",0
"public static Document parseDocument(java.io.File file) throws XMLException {
        try (InputStream is = new FileInputStream(file)) {
            return parseDocument(new InputSource(is));
        } catch (IOException e) {
            throw new XMLException(""Error opening file '"" + file + ""'"", e);
        }
    }",0
"@Override
  public MediaPackage addAttachment(InputStream in, String fileName, MediaPackageElementFlavor flavor, String[] tags,
          MediaPackage mediaPackage) throws IOException, IngestException {
    Job job = null;
    try {
      job = serviceRegistry.createJob(JOB_TYPE, INGEST_ATTACHMENT, null, null, false, ingestFileJobLoad);
      job.setStatus(Status.RUNNING);
      job = serviceRegistry.updateJob(job);
      String elementId = UUID.randomUUID().toString();
      logger.info(""Start adding attachment {} from input stream on mediapackage {}"", elementId, mediaPackage);
      URI newUrl = addContentToRepo(mediaPackage, elementId, fileName, in);
      MediaPackage mp = addContentToMediaPackage(mediaPackage, elementId, newUrl, MediaPackageElement.Type.Attachment,
              flavor);
      if (tags != null && tags.length > 0) {
        MediaPackageElement trackElement = mp.getAttachment(elementId);
        for (String tag : tags) {
          logger.info(""Adding Tag: "" + tag + "" to Element: "" + elementId);
          trackElement.addTag(tag);
        }
      }
      job.setStatus(Job.Status.FINISHED);
      logger.info(""Successful added attachment {} on mediapackage {} at URL {}"", elementId, mediaPackage, newUrl);
      return mp;
    } catch (ServiceRegistryException e) {
      throw new IngestException(e);
    } catch (NotFoundException e) {
      throw new IngestException(""Unable to update ingest job"", e);
    } finally {
      finallyUpdateJob(job);
    }

  }",0
"@Override
    public String getLongDescription() {
        return String.format(""URL: %s, View: %s, Username: %s"", serverAndPort, view.getValue(), userName);
    }",0
"private static Bitmap createImageThumbnail(InputStream data) {
        try {
            Bitmap bitmap = BitmapFactory.decodeStream(data);
            return bitmap;
        } catch (OutOfMemoryError oome) {
            LogUtils.d(Logging.LOG_TAG, ""createImageThumbnail failed with "" + oome.getMessage());
            return null;
        } catch (Exception e) {
            LogUtils.d(Logging.LOG_TAG, ""createImageThumbnail failed with "" + e.getMessage());
            return null;
        }
    }",0
"public String getSubjectMatch() {
        return getFieldValue(SUBJECT_MATCH_KEY, """");
    }",0
"public String getIssuerDN() {
        return issuerDN;
    }",0
"@Override
	public ConnectionState getConnectionState() {
		return mState;
	}",0
"@Override
    public Bundle getApplicationRestrictions(ComponentName who, String callerPackage,
            String packageName) {
        final CallerIdentity caller = getCallerIdentity(who, callerPackage);
        Preconditions.checkCallAuthorization((caller.hasAdminComponent()
                && (isProfileOwner(caller) || isDefaultDeviceOwner(caller)))
                || (caller.hasPackage() && isCallerDelegate(caller, DELEGATION_APP_RESTRICTIONS)));

        return mInjector.binderWithCleanCallingIdentity(() -> {
            Bundle bundle = mUserManager.getApplicationRestrictions(packageName,
                    caller.getUserHandle());
           // if no restrictions were saved, mUserManager.getApplicationRestrictions
           // returns null, but DPM method should return an empty Bundle as per JavaDoc
           return bundle != null ? bundle : Bundle.EMPTY;
        });
    }",0
"public static void writeLines(Collection<String> lines, Path path) throws IOException {
        Files.write(path, lines, StandardCharsets.UTF_8);
    }",0
"public String getPlatformName() {
        return ""and"";
    }",0
"public static int dehexchar(char c) {
        if (c >= '0' && c <= '9') {
            return c - '0';
        }
        if (c >= 'A' && c <= 'F') {
            return c - ('A' - 10);
        }
        if (c >= 'a' && c <= 'f') {
            return c - ('a' - 10);
        }
        return -1;
    }",0
"public void getUsageStatsIfNoPackageUsageInfo() {
        if (!mPackageUsage.isHistoricalPackageUsageAvailable()) {
            UsageStatsManager usm = (UsageStatsManager) mContext.getSystemService(Context.USAGE_STATS_SERVICE);
            if (usm == null) {
                throw new IllegalStateException(""UsageStatsManager must be initialized"");
            }
            long now = System.currentTimeMillis();
            Map<String, UsageStats> stats = usm.queryAndAggregateUsageStats(now - mDexOptLRUThresholdInMills, now);
            for (Map.Entry<String, UsageStats> entry : stats.entrySet()) {
                String packageName = entry.getKey();
                PackageParser.Package pkg = mPackages.get(packageName);
                if (pkg == null) {
                    continue;
                }
                UsageStats usage = entry.getValue();
                pkg.mLastPackageUsageTimeInMills = usage.getLastTimeUsed();
                mPackageUsage.mIsHistoricalPackageUsageAvailable = true;
            }
        }
    }",0
"@Unstable
    protected boolean isEntityReferenceNameValid(EntityReference entityReference)
    {
        if (this.getEntityNameValidationManager().getEntityReferenceNameStrategy() != null
            && this.getEntityNameValidationConfiguration().useValidation()) {
            if (!this.getEntityNameValidationManager().getEntityReferenceNameStrategy().isValid(entityReference)) {
                Object[] args = {getLocalSerializer().serialize(entityReference)};
                XWikiException invalidNameException = new XWikiException(XWikiException.MODULE_XWIKI_STORE,
                    XWikiException.ERROR_XWIKI_APP_DOCUMENT_NAME_INVALID,
                    ""Cannot create document {0} because its name does not respect the name strategy of the wiki."", null,
                    args);
                ScriptContext scontext = getCurrentScriptContext();
                scontext.setAttribute(""createException"", invalidNameException, ScriptContext.ENGINE_SCOPE);
                return false;
            }
        }
        return true;
    }",0
"private static void setHeaderlessVerticalMargins(RemoteViews contentView,
                StandardTemplateParams p, boolean hasSecondLine) {
            if (!p.mHeaderless) {
                return;
            }
            int marginDimen = hasSecondLine
                    ? R.dimen.notification_headerless_margin_twoline
                    : R.dimen.notification_headerless_margin_oneline;
            contentView.setViewLayoutMarginDimen(R.id.notification_headerless_view_column,
                    RemoteViews.MARGIN_TOP, marginDimen);
            contentView.setViewLayoutMarginDimen(R.id.notification_headerless_view_column,
                    RemoteViews.MARGIN_BOTTOM, marginDimen);
        }",0
"public static Collection<NamedDigest> getDigestsToVerify(
            ManifestParser.Section section,
            String digestAttrSuffix,
            int minSdkVersion,
            int maxSdkVersion) {
        Decoder base64Decoder = Base64.getDecoder();
        List<NamedDigest> result = new ArrayList<>(1);
        if (minSdkVersion < AndroidSdkVersion.JELLY_BEAN_MR2) {
            // Prior to JB MR2, Android platform's logic for picking a digest algorithm to verify is
            // to rely on the ancient Digest-Algorithms attribute which contains
            // whitespace-separated list of digest algorithms (defaulting to SHA-1) to try. The
            // first digest attribute (with supported digest algorithm) found using the list is
            // used.
            String algs = section.getAttributeValue(""Digest-Algorithms"");
            if (algs == null) {
                algs = ""SHA SHA1"";
            }
            StringTokenizer tokens = new StringTokenizer(algs);
            while (tokens.hasMoreTokens()) {
                String alg = tokens.nextToken();
                String attrName = alg + digestAttrSuffix;
                String digestBase64 = section.getAttributeValue(attrName);
                if (digestBase64 == null) {
                    // Attribute not found
                    continue;
                }
                alg = getCanonicalJcaMessageDigestAlgorithm(alg);
                if ((alg == null)
                        || (getMinSdkVersionFromWhichSupportedInManifestOrSignatureFile(alg)
                                > minSdkVersion)) {
                    // Unsupported digest algorithm
                    continue;
                }
                // Supported digest algorithm
                result.add(new NamedDigest(alg, base64Decoder.decode(digestBase64)));
                break;
            }
            // No supported digests found -- this will fail to verify on pre-JB MR2 Androids.
            if (result.isEmpty()) {
                return result;
            }
        }

        if (maxSdkVersion >= AndroidSdkVersion.JELLY_BEAN_MR2) {
            // On JB MR2 and newer, Android platform picks the strongest algorithm out of:
            // SHA-512, SHA-384, SHA-256, SHA-1.
            for (String alg : JB_MR2_AND_NEWER_DIGEST_ALGS) {
                String attrName = getJarDigestAttributeName(alg, digestAttrSuffix);
                String digestBase64 = section.getAttributeValue(attrName);
                if (digestBase64 == null) {
                    // Attribute not found
                    continue;
                }
                byte[] digest = base64Decoder.decode(digestBase64);
                byte[] digestInResult = getDigest(result, alg);
                if ((digestInResult == null) || (!Arrays.equals(digestInResult, digest))) {
                    result.add(new NamedDigest(alg, digest));
                }
                break;
            }
        }

        return result;
    }",0
"@Deprecated
    public String getBaseSkin(String skin, XWikiContext context)
    {
        String baseSkin = getInternalSkinManager().getParentSkin(skin);

        return baseSkin != null ? baseSkin : """";
    }",0
"private static Person parsePerson(TypedXmlPullParser parser)
            throws IOException, XmlPullParserException {
        CharSequence name = ShortcutService.parseStringAttribute(parser, ATTR_PERSON_NAME);
        String uri = ShortcutService.parseStringAttribute(parser, ATTR_PERSON_URI);
        String key = ShortcutService.parseStringAttribute(parser, ATTR_PERSON_KEY);
        boolean isBot = ShortcutService.parseBooleanAttribute(parser, ATTR_PERSON_IS_BOT);
        boolean isImportant = ShortcutService.parseBooleanAttribute(parser,
                ATTR_PERSON_IS_IMPORTANT);

        Person.Builder builder = new Person.Builder();
        builder.setName(name).setUri(uri).setKey(key).setBot(isBot).setImportant(isImportant);
        return builder.build();
    }",0
"private static boolean isCompatible(Collection<ServiceConfig> c1, Collection<ServiceConfig> c2) {
            if (c1 == c2) {
                return true;
            }
            if (c1 == null || c2 == null || c1.size() != c2.size()) {
                return false;
            }

            HashMap<String, ServiceConfig> config1 = new HashMap<String, ServiceConfig>();
            HashMap<String, ServiceConfig> config2 = new HashMap<String, ServiceConfig>();

            for (ServiceConfig serviceConfig : c1) {
                config1.put(serviceConfig.getName(), serviceConfig);
            }
            for (ServiceConfig serviceConfig : c2) {
                config2.put(serviceConfig.getName(), serviceConfig);
            }

            if (!config1.keySet().equals(config2.keySet())) {
                return false;
            }

            for (ServiceConfig serviceConfig : c1) {
                if (!isCompatible(serviceConfig, config2.get(serviceConfig.getName()))) {
                    return false;
                }
            }
            return true;
        }",0
"String getKey() {
        return key;
    }",0
"public long getMaximumSize() {
        long pageCount = DatabaseUtils.longForQuery(this, ""PRAGMA max_page_count;"", null);
        return pageCount * getPageSize();
    }",0
"@Override
    public void onShellCommand(FileDescriptor in, FileDescriptor out,
            FileDescriptor err, String[] args, ShellCallback callback,
            ResultReceiver resultReceiver) {
        new AccountManagerServiceShellCommand(this).exec(this, in, out, err, args,
                callback, resultReceiver);
    }",0
"public Page<E> setPageNum(int pageNum) {
        //分页合理化，针对不合理的页码自动处理
        this.pageNum = ((reasonable != null && reasonable) && pageNum <= 0) ? 1 : pageNum;
        return this;
    }",0
"public @NotNull Builder withAllKeys() {
            this.addHostKey(""test-container/ssh_host_ecdsa_key"");
            this.addHostKey(""test-container/ssh_host_ed25519_key"");
            this.addHostKey(""test-container/host_keys/ssh_host_ecdsa_256_key"");
            this.addHostKey(""test-container/host_keys/ssh_host_ecdsa_384_key"");
            this.addHostKey(""test-container/host_keys/ssh_host_ecdsa_521_key"");
            this.addHostKey(""test-container/host_keys/ssh_host_ed25519_384_key"");
            this.addHostKey(""test-container/host_keys/ssh_host_rsa_2048_key"");
            this.addHostKeyCertificate(""test-container/host_keys/ssh_host_ecdsa_256_key-cert.pub"");
            this.addHostKeyCertificate(""test-container/host_keys/ssh_host_ecdsa_384_key-cert.pub"");
            this.addHostKeyCertificate(""test-container/host_keys/ssh_host_ecdsa_521_key-cert.pub"");
            this.addHostKeyCertificate(""test-container/host_keys/ssh_host_ed25519_384_key-cert.pub"");
            this.addHostKeyCertificate(""test-container/host_keys/ssh_host_rsa_2048_key-cert.pub"");
            return this;
        }",0
"public String getCertTypeSSLServer() {
        return certTypeSSLServer;
    }",0
"@RequiresPermission(value = MANAGE_DEVICE_POLICY_PROFILE_INTERACTION, conditional = true)
    public @NonNull List<String> getCrossProfileWidgetProviders(@Nullable ComponentName admin) {
        throwIfParentInstance(""getCrossProfileWidgetProviders"");
        if (mService != null) {
            try {
                List<String> providers = mService.getCrossProfileWidgetProviders(admin,
                        mContext.getPackageName());
                if (providers != null) {
                    return providers;
                }
            } catch (RemoteException re) {
                throw re.rethrowFromSystemServer();
            }
        }
        return Collections.emptyList();
    }",0
"boolean isUidActiveLocked(int uid) {
        final UidRecord uidRecord = mActiveUids.get(uid);
        return uidRecord != null && !uidRecord.setIdle;
    }",0
"private void initializeResources() {
    visibilityToggle              = findViewById(R.id.button_toggle);
    fingerprintPrompt             = findViewById(R.id.fingerprint_auth_container);
    lockScreenButton              = findViewById(R.id.lock_screen_auth_container);
    fingerprintManager            = FingerprintManagerCompat.from(this);
    fingerprintCancellationSignal = new CancellationSignal();
    fingerprintListener           = new FingerprintListener();

    SpannableString hint = new SpannableString(""  "" + getString(R.string.PassphrasePromptActivity_enter_passphrase));
    hint.setSpan(new RelativeSizeSpan(0.9f), 0, hint.length(), Spanned.SPAN_INCLUSIVE_INCLUSIVE);
    hint.setSpan(new TypefaceSpan(""sans-serif""), 0, hint.length(), Spanned.SPAN_INCLUSIVE_INCLUSIVE);

    fingerprintPrompt.setImageResource(R.drawable.ic_fingerprint_white_48dp);
    fingerprintPrompt.getBackground().setColorFilter(getResources().getColor(R.color.signal_primary), PorterDuff.Mode.SRC_IN);

    lockScreenButton.setOnClickListener(v -> resumeScreenLock());
  }",0
"private void begin(FilterEventParameters parameters) throws FilterException
    {
        DocumentReference documentReference =
            this.documentEntityResolver.resolve(this.currentEntityReference, getDefaultDocumentReference());

        if (this.entity == null) {
            this.entity = new XWikiDocument(documentReference, this.currentLocale);
        } else {
            this.entity.setDocumentReference(documentReference);
            this.entity.setLocale(this.currentLocale);
        }

        // Mark the document as restricted to avoid that any scripts are executed as scripts should only be executed
        // on the current, saved version, see https://jira.xwiki.org/browse/XWIKI-20594
        this.entity.setRestricted(true);

        // Find default author
        DocumentReference defaultAuthorDocumentReference;
        // TODO: move to UserReference based APIs in DocumentInstanceOutputProperties
        if (this.properties.isAuthorSet()) {
            defaultAuthorDocumentReference = this.properties.getAuthor();
        } else {
            XWikiContext xcontext = xcontextProvider.get();
            defaultAuthorDocumentReference = xcontext != null ? xcontext.getUserReference() : null;
        }
        UserReference defaultAuthorReference = this.userDocumentResolver.resolve(defaultAuthorDocumentReference);

        this.entity
            .setCreationDate(getDate(WikiDocumentFilter.PARAMETER_CREATION_DATE, this.currentLocaleParameters, null));

        this.entity.getAuthors().setCreator(getUserReference(WikiDocumentFilter.PARAMETER_CREATION_AUTHOR,
            this.currentLocaleParameters, defaultAuthorReference));
        this.entity.setDefaultLocale(this.currentDefaultLocale);

        this.entity.setSyntax(getSyntax(WikiDocumentFilter.PARAMETER_SYNTAX, parameters, null));

        this.entity.setParentReference(getEntityReference(WikiDocumentFilter.PARAMETER_PARENT, parameters, null));
        this.entity.setCustomClass(getString(WikiDocumentFilter.PARAMETER_CUSTOMCLASS, parameters, null));
        this.entity.setTitle(getString(WikiDocumentFilter.PARAMETER_TITLE, parameters, null));
        this.entity.setDefaultTemplate(getString(WikiDocumentFilter.PARAMETER_DEFAULTTEMPLATE, parameters, null));
        this.entity.setValidationScript(getString(WikiDocumentFilter.PARAMETER_VALIDATIONSCRIPT, parameters, null));
        this.entity.setHidden(getBoolean(WikiDocumentFilter.PARAMETER_HIDDEN, parameters, false));

        this.entity.setMinorEdit(getBoolean(WikiDocumentFilter.PARAMETER_REVISION_MINOR, parameters, false));

        this.entity.getAuthors().setEffectiveMetadataAuthor(getUserReference(
            WikiDocumentFilter.PARAMETER_REVISION_EFFECTIVEMETADATA_AUTHOR, parameters, defaultAuthorReference));
        // Use effectuve metadata author as default as this value used to be used both both original and effective
        // metadata authors
        this.entity.getAuthors()
            .setOriginalMetadataAuthor(getUserReference(WikiDocumentFilter.PARAMETER_REVISION_ORIGINALMETADATA_AUTHOR,
                parameters, this.entity.getAuthors().getEffectiveMetadataAuthor()));

        this.entity.getAuthors().setContentAuthor(
            getUserReference(WikiDocumentFilter.PARAMETER_CONTENT_AUTHOR, parameters, defaultAuthorReference));

        String revisions =
            getString(XWikiWikiDocumentFilter.PARAMETER_JRCSREVISIONS, this.currentLocaleParameters, null);
        if (revisions != null) {
            try {
                this.entity.setDocumentArchive(revisions);
            } catch (XWikiException e) {
                throw new FilterException(""Failed to set document archive"", e);
            }
        }

        if (this.currentVersion != null && this.properties.isVersionPreserved()) {
            if (VALID_VERSION.matcher(this.currentVersion).matches()) {
                this.entity.setVersion(this.currentVersion);
            } else if (NumberUtils.isDigits(this.currentVersion)) {
                this.entity.setVersion(this.currentVersion + "".1"");
            } else {
                // TODO: log something, probably a warning
            }
        }

        this.entity.setDate(getDate(WikiDocumentFilter.PARAMETER_REVISION_DATE, parameters, new Date()));
        this.entity.setComment(getString(WikiDocumentFilter.PARAMETER_REVISION_COMMENT, parameters, """"));

        this.entity.setContentUpdateDate(getDate(WikiDocumentFilter.PARAMETER_CONTENT_DATE, parameters, new Date()));

        // Content

        if (this.contentListener != null) {
            // Remember the current rendering context target syntax
            this.previousTargetSyntax = this.renderingContext.getTargetSyntax();
        }

        if (parameters.containsKey(WikiDocumentFilter.PARAMETER_CONTENT)) {
            this.entity.setContent(getString(WikiDocumentFilter.PARAMETER_CONTENT, parameters, null));

            if (this.contentListener != null) {
                // Cancel any existing content listener
                this.currentWikiPrinter = null;
                this.contentListener.setWrappedListener(null);
            }
        } else if (this.contentListener != null) {
            if (this.properties != null && this.properties.getDefaultSyntax() != null) {
                this.entity.setSyntax(this.properties.getDefaultSyntax());
            } else {
                // Make sure to set the default syntax if none were provided
                this.entity.setSyntax(this.entity.getSyntax());
            }

            ComponentManager componentManager = this.componentManagerProvider.get();

            String syntaxString = this.entity.getSyntax().toIdString();
            if (componentManager.hasComponent(PrintRendererFactory.class, syntaxString)) {
                PrintRendererFactory rendererFactory;
                try {
                    rendererFactory = componentManager.getInstance(PrintRendererFactory.class, syntaxString);
                } catch (ComponentLookupException e) {
                    throw new FilterException(
                        String.format(""Failed to find PrintRendererFactory for syntax [%s]"", this.entity.getSyntax()),
                        e);
                }

                this.currentWikiPrinter = new DefaultWikiPrinter();
                ((MutableRenderingContext) this.renderingContext).setTargetSyntax(rendererFactory.getSyntax());
                this.contentListener.setWrappedListener(rendererFactory.createRenderer(this.currentWikiPrinter));
            }
        }

        // Initialize the class
        getBaseClassOutputFilterStream().setEntity(this.entity.getXClass());
    }",1
"public Map<String, ResourceProvider> getResourceProviders() {
		return resourceProviders;
	}",1
"@Override
    public int getComponentEnabledSetting(ComponentName componentName, int userId) {
        if (!sUserManager.exists(userId)) return COMPONENT_ENABLED_STATE_DISABLED;
        int uid = Binder.getCallingUid();
        enforceCrossUserPermission(uid, userId, false, false, ""get component enabled"");
        // reader
        synchronized (mPackages) {
            return mSettings.getComponentEnabledSettingLPr(componentName, userId);
        }
    }",0
"protected Token jjFillToken()
{
   final Token t;
   final String curTokenImage;
   final int beginLine;
   final int endLine;
   final int beginColumn;
   final int endColumn;
   String im = jjstrLiteralImages[jjmatchedKind];
   curTokenImage = (im == null) ? input_stream.GetImage() : im;
   beginLine = input_stream.getBeginLine();
   beginColumn = input_stream.getBeginColumn();
   endLine = input_stream.getEndLine();
   endColumn = input_stream.getEndColumn();
   t = Token.newToken(jjmatchedKind);
   t.kind = jjmatchedKind;
   t.image = curTokenImage;

   t.beginLine = beginLine;
   t.endLine = endLine;
   t.beginColumn = beginColumn;
   t.endColumn = endColumn;

   return t;
}",0
"@GuardedBy(""this"")
    void tempAllowlistForPendingIntentLocked(int callerPid, int callerUid, int targetUid,
            long duration, int type, @ReasonCode int reasonCode, String reason) {
        if (DEBUG_ALLOWLISTS) {
            Slog.d(TAG, ""tempAllowlistForPendingIntentLocked("" + callerPid + "", "" + callerUid + "", ""
                    + targetUid + "", "" + duration + "", "" + type + "")"");
        }

        synchronized (mPidsSelfLocked) {
            final ProcessRecord pr = mPidsSelfLocked.get(callerPid);
            if (pr == null) {
                Slog.w(TAG, ""tempAllowlistForPendingIntentLocked() no ProcessRecord for pid ""
                        + callerPid);
                return;
            }
            if (!pr.mServices.mAllowlistManager) {
                if (checkPermission(CHANGE_DEVICE_IDLE_TEMP_WHITELIST, callerPid, callerUid)
                        != PackageManager.PERMISSION_GRANTED
                        && checkPermission(START_ACTIVITIES_FROM_BACKGROUND, callerPid, callerUid)
                        != PackageManager.PERMISSION_GRANTED
                        && checkPermission(START_FOREGROUND_SERVICES_FROM_BACKGROUND, callerPid,
                        callerUid) != PackageManager.PERMISSION_GRANTED) {
                    if (DEBUG_ALLOWLISTS) {
                        Slog.d(TAG, ""tempAllowlistForPendingIntentLocked() for target "" + targetUid
                                + "": pid "" + callerPid + "" is not allowed"");
                    }
                    return;
                }
            }
        }

        tempAllowlistUidLocked(targetUid, duration, reasonCode, reason, type, callerUid);
    }",0
"@JavascriptInterface   // must be added for API 17 or higher
        public boolean shouldNavigate(String url) {
            return bc.fireBrowserNavigationCallbacks(url);
        }",0
"public void validateConfigurations() throws InvalidPropertiesFormatException {
        String blacklistVars = prop.getProperty(TS_BLACKLIST_ENV_VARS, """");
        try {
            blacklistPattern = Pattern.compile(blacklistVars);
        } catch (PatternSyntaxException e) {
            throw new InvalidPropertiesFormatException(e);
        }
    }",0
"public static RESTMessage fromXML(String xml) throws Exception {

        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setFeature(""http://apache.org/xml/features/disallow-doctype-decl"", true);
        DocumentBuilder builder = factory.newDocumentBuilder();
        Document document = builder.parse(new InputSource(new StringReader(xml)));

        Element element = document.getDocumentElement();
        return fromDOM(element);
    }",1
"public static Ssurgeon inst() {
    synchronized(Ssurgeon.class) {
      if (instance == null)
        instance = new Ssurgeon();
    }
    return instance;
  }",0
"@Override
	public Result<?> checkUserIsEffective(SysUser sysUser) {
		Result<?> result = new Result<Object>();
		//情况1：根据用户信息查询，该用户不存在
		if (sysUser == null) {
			result.error500(""该用户不存在，请注册"");
			baseCommonService.addLog(""用户登录失败，用户不存在！"", CommonConstant.LOG_TYPE_1, null);
			return result;
		}
		//情况2：根据用户信息查询，该用户已注销
		//update-begin---author:王帅   Date:20200601  for：if条件永远为falsebug------------
		if (CommonConstant.DEL_FLAG_1.equals(sysUser.getDelFlag())) {
		//update-end---author:王帅   Date:20200601  for：if条件永远为falsebug------------
			baseCommonService.addLog(""用户登录失败，用户名:"" + sysUser.getUsername() + ""已注销！"", CommonConstant.LOG_TYPE_1, null);
			result.error500(""该用户已注销"");
			return result;
		}
		//情况3：根据用户信息查询，该用户已冻结
		if (CommonConstant.USER_FREEZE.equals(sysUser.getStatus())) {
			baseCommonService.addLog(""用户登录失败，用户名:"" + sysUser.getUsername() + ""已冻结！"", CommonConstant.LOG_TYPE_1, null);
			result.error500(""该用户已冻结"");
			return result;
		}
		return result;
	}",0
"public Builder withIndex(long val)
        {
            index = val;
            return this;
        }",0
"public String getNextBuildUrl() {
            return getUrl(run.getNextBuild());
        }",0
"private void showFactoryResetProtectionWarningDialog(String unlockMethodToSet) {
            int title = getResIdForFactoryResetProtectionWarningTitle();
            int message = getResIdForFactoryResetProtectionWarningMessage();
            FactoryResetProtectionWarningDialog dialog =
                    FactoryResetProtectionWarningDialog.newInstance(
                            title, message, unlockMethodToSet);
            dialog.show(getChildFragmentManager(), TAG_FRP_WARNING_DIALOG);
        }",0
"public ParceledListSlice<ConversationChannelWrapper> getConversations(boolean onlyImportant) {
        try {
            return sINM.getConversations(onlyImportant);
        } catch (Exception e) {
            Log.w(TAG, ""Error calling NoMan"", e);
            return ParceledListSlice.emptyList();
        }
    }",0
"public void require(int type, String namespace, String name) throws XmlPullParserException,IOException {
            if (type != getEventType()
                || (namespace != null && !namespace.equals( getNamespace () ) )
                || (name != null && !name.equals( getName() ) ) )
                throw new XmlPullParserException( ""expected ""+ TYPES[ type ]+getPositionDescription());
        }",0
"NeededUriGrants checkGrantUriPermissionFromIntentLocked(int callingUid,
            String targetPkg, Intent intent, int mode, NeededUriGrants needed, int targetUserId) {
        if (DEBUG_URI_PERMISSION) Slog.v(TAG_URI_PERMISSION,
                ""Checking URI perm to data="" + (intent != null ? intent.getData() : null)
                + "" clip="" + (intent != null ? intent.getClipData() : null)
                + "" from "" + intent + ""; flags=0x""
                + Integer.toHexString(intent != null ? intent.getFlags() : 0));

        if (targetPkg == null) {
            throw new NullPointerException(""targetPkg"");
        }

        if (intent == null) {
            return null;
        }
        Uri data = intent.getData();
        ClipData clip = intent.getClipData();
        if (data == null && clip == null) {
            return null;
        }
        // Default userId for uris in the intent (if they don't specify it themselves)
        int contentUserHint = intent.getContentUserHint();
        if (contentUserHint == UserHandle.USER_CURRENT) {
            contentUserHint = UserHandle.getUserId(callingUid);
        }
        final IPackageManager pm = AppGlobals.getPackageManager();
        int targetUid;
        if (needed != null) {
            targetUid = needed.targetUid;
        } else {
            try {
                targetUid = pm.getPackageUid(targetPkg, MATCH_DEBUG_TRIAGED_MISSING,
                        targetUserId);
            } catch (RemoteException ex) {
                return null;
            }
            if (targetUid < 0) {
                if (DEBUG_URI_PERMISSION) Slog.v(TAG_URI_PERMISSION,
                        ""Can't grant URI permission no uid for: "" + targetPkg
                        + "" on user "" + targetUserId);
                return null;
            }
        }
        if (data != null) {
            GrantUri grantUri = GrantUri.resolve(contentUserHint, data);
            targetUid = checkGrantUriPermissionLocked(callingUid, targetPkg, grantUri, mode,
                    targetUid);
            if (targetUid > 0) {
                if (needed == null) {
                    needed = new NeededUriGrants(targetPkg, targetUid, mode);
                }
                needed.add(grantUri);
            }
        }
        if (clip != null) {
            for (int i=0; i<clip.getItemCount(); i++) {
                Uri uri = clip.getItemAt(i).getUri();
                if (uri != null) {
                    GrantUri grantUri = GrantUri.resolve(contentUserHint, uri);
                    targetUid = checkGrantUriPermissionLocked(callingUid, targetPkg, grantUri, mode,
                            targetUid);
                    if (targetUid > 0) {
                        if (needed == null) {
                            needed = new NeededUriGrants(targetPkg, targetUid, mode);
                        }
                        needed.add(grantUri);
                    }
                } else {
                    Intent clipIntent = clip.getItemAt(i).getIntent();
                    if (clipIntent != null) {
                        NeededUriGrants newNeeded = checkGrantUriPermissionFromIntentLocked(
                                callingUid, targetPkg, clipIntent, mode, needed, targetUserId);
                        if (newNeeded != null) {
                            needed = newNeeded;
                        }
                    }
                }
            }
        }

        return needed;
    }",0
"public Optional<ClickHouseVersion> getVersion() {
        return this.config.hasOption(ClickHouseClientOption.SERVER_VERSION)
                ? Optional.of(this.config.getServerVersion())
                : Optional.empty();
    }",0
"@Override
    public boolean stopOnGracefulShutdown() {
        return true;
    }",0
"public void ensureSettingsForUserLocked(int userId) {
            // Migrate the setting for this user if needed.
            migrateLegacySettingsForUserIfNeededLocked(userId);

            // Ensure global settings loaded if owner.
            if (userId == UserHandle.USER_SYSTEM) {
                final int globalKey = makeKey(SETTINGS_TYPE_GLOBAL, UserHandle.USER_SYSTEM);
                ensureSettingsStateLocked(globalKey);
            }

            // Ensure secure settings loaded.
            final int secureKey = makeKey(SETTINGS_TYPE_SECURE, userId);
            ensureSettingsStateLocked(secureKey);

            // Make sure the secure settings have an Android id set.
            SettingsState secureSettings = getSettingsLocked(SETTINGS_TYPE_SECURE, userId);
            ensureSecureSettingAndroidIdSetLocked(secureSettings);

            // Ensure system settings loaded.
            final int systemKey = makeKey(SETTINGS_TYPE_SYSTEM, userId);
            ensureSettingsStateLocked(systemKey);

            // Upgrade the settings to the latest version.
            UpgradeController upgrader = new UpgradeController(userId);
            upgrader.upgradeIfNeededLocked();
        }",0
"@Override
    public void setPinchToZoomEnabled(final PeerComponent browserPeer, final boolean e) {
        super.setPinchToZoomEnabled(browserPeer, e);
        if (getActivity() == null) {
            return;
        }
        getActivity().runOnUiThread(new Runnable() {
            public void run() {
                AndroidBrowserComponent bc = (AndroidBrowserComponent)browserPeer;
                bc.setPinchZoomEnabled(e);
            }
        });
    }",0
"protected OortComet findComet(String cometURL) {
        return _membership.findComet(cometURL);
    }",0
"@Override
    public List<PermissionInfo> queryPermissionsByGroup(String group, int flags) {
        // reader
        synchronized (mPackages) {
            ArrayList<PermissionInfo> out = new ArrayList<PermissionInfo>(10);
            for (BasePermission p : mSettings.mPermissions.values()) {
                if (group == null) {
                    if (p.perm == null || p.perm.info.group == null) {
                        out.add(generatePermissionInfo(p, flags));
                    }
                } else {
                    if (p.perm != null && group.equals(p.perm.info.group)) {
                        out.add(PackageParser.generatePermissionInfo(p.perm, flags));
                    }
                }
            }

            if (out.size() > 0) {
                return out;
            }
            return mPermissionGroups.containsKey(group) ? out : null;
        }
    }",0
"private String encodeURLPart(String part) throws IOException
    {
        return URLEncoder.encode(part, ""UTF-8"");
    }",0
"private void sendServiceInfo() {
        IAccessibilityServiceConnection connection =
            AccessibilityInteractionClient.getInstance().getConnection(mConnectionId);
        if (mInfo != null && connection != null) {
            try {
                connection.setServiceInfo(mInfo);
                mInfo = null;
                AccessibilityInteractionClient.getInstance().clearCache();
            } catch (RemoteException re) {
                Log.w(LOG_TAG, ""Error while setting AccessibilityServiceInfo"", re);
                re.rethrowFromSystemServer();
            }
        }
    }",0
"public void disableSecurity() {
        useSecurity = null;
        setSecurityRealm(SecurityRealm.NO_AUTHENTICATION);
        authorizationStrategy = AuthorizationStrategy.UNSECURED;
        markupFormatter = null;
    }",0
"public abstract boolean defaulted(String name) throws IOException,
                IllegalArgumentException;",0
"void replaceWith(CharSequence text, TextPaint paint,
                              int width, Alignment align,
                              float spacingmult, float spacingadd) {
        if (width < 0) {
            throw new IllegalArgumentException(""Layout: "" + width + "" < 0"");
        }

        mText = text;
        mPaint = paint;
        mWidth = width;
        mAlignment = align;
        mSpacingMult = spacingmult;
        mSpacingAdd = spacingadd;
        mSpannedText = text instanceof Spanned;
    }",0
"private static Obs returnObsCopy(Obs obsToCopy, Map<Obs, Obs> replacements) throws Exception {
		Obs newObs = (Obs) returnCopy(obsToCopy);
		
		if (obsToCopy.isObsGrouping()) {
			newObs.setGroupMembers(null);
			for (Obs oinner : obsToCopy.getGroupMembers()) {
				Obs oinnerNew = returnObsCopy(oinner, replacements);
				newObs.addGroupMember(oinnerNew);
			}
		}
		
		replacements.put(newObs, obsToCopy);
		return newObs;
	}",0
"private static void applyInsets(Region outRegion, Rect frame, Rect inset) {
        outRegion.set(
                frame.left + inset.left, frame.top + inset.top,
                frame.right - inset.right, frame.bottom - inset.bottom);
    }",0
"public String getCometId() {
                return cometId;
            }",0
"String path() {
        final String path = get(HttpHeaderNames.PATH);
        checkState(path != null, "":path header does not exist."");
        return path;
    }",0
"public void execute(AsyncResult<SQLConnection> conn, String sql, JsonArray params,
      Handler<AsyncResult<UpdateResult>> replyHandler){
    try {
      SQLConnection sqlConnection = conn.result();
      sqlConnection.updateWithParams(sql, params, query -> {
        if (query.failed()) {
          replyHandler.handle(Future.failedFuture(query.cause()));
        } else {
          replyHandler.handle(Future.succeededFuture(query.result()));
        }
      });
    } catch (Exception e) {
      log.error(e.getMessage(), e);
      replyHandler.handle(Future.failedFuture(e));
    }
  }",0
"public String[] getParameterValues(String parameter) {
	        String[] values = super.getParameterValues(parameter);
	        if (values == null) {
	            return null;
	        }
	        int count = values.length;
	        String[] encodedValues = new String[count];
	        for (int i = 0; i < count; i++) {
	            encodedValues[i] = cleanXSS(values[i]);
	        }
	        return encodedValues;
	    }",0
"@RequiresFeature(PackageManager.FEATURE_SECURE_LOCK_SCREEN)
    public void reportSuccessfulBiometricAttempt(int userHandle) {
        if (mService != null) {
            try {
                mService.reportSuccessfulBiometricAttempt(userHandle);
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
        }
    }",0
"@Override
    protected AbstractChainingPrintRenderer getSyntaxRenderer()
    {
        return new HTML5ChainingRenderer(this.linkRenderer, this.imageRenderer, this.htmlElementSanitizer,
            getListenerChain());
    }",1
"protected String getFilterPath(final String s) {
        if (s.startsWith(""#"")) {
            return StringUtil.EMPTY;
        } else if (s.startsWith(CONTAINS)) {
            final String v = s.substring(CONTAINS.length());
            final StringBuilder buf = new StringBuilder(100);
            return "".*"" + appendFileterPath(buf, escape(v)) + "".*"";
        } else if (s.startsWith(REGEXP_IGNORE_CASE)) {
            final String v = s.substring(REGEXP_IGNORE_CASE.length());
            final StringBuilder buf = new StringBuilder(100);
            buf.append(""(?i)"");
            return appendFileterPath(buf, unescape(v));
        } else if (s.startsWith(REGEXP_CASE)) {
            final String v = s.substring(REGEXP_CASE.length());
            final StringBuilder buf = new StringBuilder(100);
            return appendFileterPath(buf, unescape(v));
        } else if (s.startsWith(REGEXP)) {
            final String v = s.substring(REGEXP.length());
            final StringBuilder buf = new StringBuilder(100);
            return appendFileterPath(buf, unescape(v));
        } else if (Arrays.stream(webProtocols).anyMatch(p -> s.startsWith(p))) {
            return escape(s) + "".*"";
        } else if (Arrays.stream(fileProtocols).anyMatch(p -> s.startsWith(p))) {
            return escape(s) + "".*"";
        } else {
            final StringBuilder buf = new StringBuilder(100);
            return appendFileterPath(buf, escape(s));
        }
    }",0
"public Jooby port(final int port) {
    this.port = port;
    return this;
  }",0
"@SuppressWarnings(""unchecked"")
	private static javax.persistence.criteria.Order toJpaOrder(Order order, Root<?> root, CriteriaBuilder cb) {

		PropertyPath property = PropertyPath.from(order.getProperty(), root.getJavaType());
		Expression<?> expression = toExpressionRecursively(root, property);

		if (order.isIgnoreCase() && String.class.equals(expression.getJavaType())) {
			Expression<String> lower = cb.lower((Expression<String>) expression);
			return order.isAscending() ? cb.asc(lower) : cb.desc(lower);
		} else {
			return order.isAscending() ? cb.asc(expression) : cb.desc(expression);
		}
	}",0
"@Override
  public Route.Collection patch(final String path1, final String path2,
      final Route.Handler handler) {
    return new Route.Collection(
        new Route.Definition[]{patch(path1, handler), patch(path2, handler)});
  }",0
"public void resolveResourceStrings() {
        final ShortcutService s = mShortcutUser.mService;

        final Resources publisherRes = getPackageResources();
        final List<ShortcutInfo> changedShortcuts = new ArrayList<>(1);

        if (publisherRes != null) {
            forEachShortcutMutate(si -> {
                if (!si.hasStringResources()) return;
                si.resolveResourceStrings(publisherRes);
                si.setTimestamp(s.injectCurrentTimeMillis());
                changedShortcuts.add(si);
            });
        }
        if (!CollectionUtils.isEmpty(changedShortcuts)) {
            s.packageShortcutsChanged(this, changedShortcuts, null);
        }
    }",0
"@Override
    @After
    public void tearDown() throws Exception {
        super.tearDown();
    }",0
public abstract BaseXMLBuilder up();,0
"@Beta
  public static void copy(File from, File to) throws IOException {
    checkArgument(!from.equals(to), ""Source %s and destination %s must be different"", from, to);
    asByteSource(from).copyTo(asByteSink(to));
  }",0
"@POST
	@Path(""survey"")
	@Operation(summary = ""Attaches an survey building block"", description = ""Attaches an survey building block"")
	@ApiResponse(responseCode = ""200"", description = ""The course node metadatas"", content = {
			@Content(mediaType = ""application/json"", schema = @Schema(implementation = CourseNodeVO.class)),
			@Content(mediaType = ""application/xml"", schema = @Schema(implementation = CourseNodeVO.class)) })
	@ApiResponse(responseCode = ""401"", description = ""The roles of the authenticated user are not sufficient"")
	@ApiResponse(responseCode = ""404"", description = ""The course or parentNode not found"")
	@Consumes(MediaType.APPLICATION_FORM_URLENCODED)
	@Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON})
	public Response attachSurveyPost(@PathParam(""courseId"") Long courseId, @QueryParam(""parentNodeId"") String parentNodeId,
			@QueryParam(""position"") Integer position, @QueryParam(""shortTitle"") @DefaultValue(""undefined"") String shortTitle,
			@QueryParam(""longTitle"") @DefaultValue(""undefined"") String longTitle, @QueryParam(""objectives"") @DefaultValue(""undefined"") String objectives,
			@QueryParam(""visibilityExpertRules"") String visibilityExpertRules, @QueryParam(""accessExpertRules"") String accessExpertRules,
			@QueryParam(""surveyResourceableId"") Long surveyResourceableId, @Context HttpServletRequest request) {
		return attachSurvey(courseId, parentNodeId, position, shortTitle, longTitle, objectives, visibilityExpertRules, accessExpertRules, surveyResourceableId, request);
	}",0
"@Override
        protected void dump(FileDescriptor fd, final PrintWriter writer, String[] args) {
            if (mContext.checkCallingOrSelfPermission(
                    android.Manifest.permission.DUMP)
                    != PackageManager.PERMISSION_GRANTED) {
                writer.println(""Permission Denial: can't dump TelecomService "" +
                        ""from from pid="" + Binder.getCallingPid() + "", uid="" +
                        Binder.getCallingUid());
                return;
            }

            final IndentingPrintWriter pw = new IndentingPrintWriter(writer, ""  "");
            if (mCallsManager != null) {
                pw.println(""CallsManager: "");
                pw.increaseIndent();
                mCallsManager.dump(pw);
                pw.decreaseIndent();

                pw.println(""PhoneAccountRegistrar: "");
                pw.increaseIndent();
                mPhoneAccountRegistrar.dump(pw);
                pw.decreaseIndent();
            }

            Log.dumpCallEvents(pw);
        }",0
"public void fromXML(InputStream source, boolean withArchive) throws XWikiException
    {
        fromXML(new DefaultInputStreamInputSource(source), withArchive);
    }",0
"void updateUsageStats(ActivityRecord component, boolean resumed) {
        if (DEBUG_SWITCH) Slog.d(TAG_SWITCH,
                ""updateUsageStats: comp="" + component + ""res="" + resumed);
        final BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics();
        if (resumed) {
            if (mUsageStatsService != null) {
                mUsageStatsService.reportEvent(component.realActivity, component.userId,
                        UsageEvents.Event.MOVE_TO_FOREGROUND);
            }
            synchronized (stats) {
                stats.noteActivityResumedLocked(component.app.uid);
            }
        } else {
            if (mUsageStatsService != null) {
                mUsageStatsService.reportEvent(component.realActivity, component.userId,
                        UsageEvents.Event.MOVE_TO_BACKGROUND);
            }
            synchronized (stats) {
                stats.noteActivityPausedLocked(component.app.uid);
            }
        }
    }",0
"@Override
        public int getOpacity() {
            return PixelFormat.OPAQUE;
        }",0
"private boolean savedPatternExists(int userId) {
        try {
            return getLockSettings().havePattern(userId);
        } catch (RemoteException re) {
            return false;
        }
    }",0
"public static boolean isArtifactsPermissionEnabled() {
        return Boolean.getBoolean(""hudson.security.ArtifactsPermission"");
    }",0
"protected void engineInit(
        int                     opmode,
        Key key,
        AlgorithmParameterSpec params,
        SecureRandom random)
    throws InvalidKeyException, InvalidAlgorithmParameterException
    {
        CipherParameters param;

        if (params == null || params instanceof OAEPParameterSpec)
        {
            if (key instanceof RSAPublicKey)
            {
                if (privateKeyOnly && opmode == Cipher.ENCRYPT_MODE)
                {
                    throw new InvalidKeyException(
                                ""mode 1 requires RSAPrivateKey"");
                }

                param = RSAUtil.generatePublicKeyParameter((RSAPublicKey)key);
            }
            else if (key instanceof RSAPrivateKey)
            {
                if (publicKeyOnly && opmode == Cipher.ENCRYPT_MODE)
                {
                    throw new InvalidKeyException(
                                ""mode 2 requires RSAPublicKey"");
                }

                param = RSAUtil.generatePrivateKeyParameter((RSAPrivateKey)key);
            }
            else
            {
                throw new InvalidKeyException(""unknown key type passed to RSA"");
            }
            
            if (params != null)
            {
                OAEPParameterSpec spec = (OAEPParameterSpec)params;
                
                paramSpec = params;
                
                if (!spec.getMGFAlgorithm().equalsIgnoreCase(""MGF1"") && !spec.getMGFAlgorithm().equals(PKCSObjectIdentifiers.id_mgf1.getId()))
                {
                    throw new InvalidAlgorithmParameterException(""unknown mask generation function specified"");
                }
                
                if (!(spec.getMGFParameters() instanceof MGF1ParameterSpec))
                {
                    throw new InvalidAlgorithmParameterException(""unkown MGF parameters"");
                }
    
                Digest digest = DigestFactory.getDigest(spec.getDigestAlgorithm());

                if (digest == null)
                {
                    throw new InvalidAlgorithmParameterException(""no match on digest algorithm: ""+ spec.getDigestAlgorithm());
                }

                MGF1ParameterSpec mgfParams = (MGF1ParameterSpec)spec.getMGFParameters();
                Digest mgfDigest = DigestFactory.getDigest(mgfParams.getDigestAlgorithm());
                
                if (mgfDigest == null)
                {
                    throw new InvalidAlgorithmParameterException(""no match on MGF digest algorithm: ""+ mgfParams.getDigestAlgorithm());
                }

                cipher = new OAEPEncoding(new RSABlindedEngine(), digest, mgfDigest, ((PSource.PSpecified)spec.getPSource()).getValue());
            }
        }
        else
        {
            throw new InvalidAlgorithmParameterException(""unknown parameter type: "" + params.getClass().getName());
        }

        if (!(cipher instanceof RSABlindedEngine))
        {
            if (random != null)
            {
                param = new ParametersWithRandom(param, random);
            }
            else
            {
                param = new ParametersWithRandom(param, new SecureRandom());
            }
        }

        bOut.reset();

        switch (opmode)
        {
        case Cipher.ENCRYPT_MODE:
        case Cipher.WRAP_MODE:
            cipher.init(true, param);
            break;
        case Cipher.DECRYPT_MODE:
        case Cipher.UNWRAP_MODE:
            cipher.init(false, param);
            break;
        default:
            throw new InvalidParameterException(""unknown opmode "" + opmode + "" passed to RSA"");
        }
    }",0
"@Override
      public String toString() {
        return ""Files.isFile()"";
      }",0
"@Override
  public MediaPackage addTrack(URI uri, MediaPackageElementFlavor flavor, MediaPackage mediaPackage)
          throws IOException, IngestException {
    String[] tags = null;
    return this.addTrack(uri, flavor, tags, mediaPackage);

  }",0
"@VisibleForTesting
    boolean shouldResumeActivity(ActivityRecord activeActivity) {
        return shouldBeResumed(activeActivity) && !isState(RESUMED);
    }",0
"private void tearDown(PackageInfo pkg) {
            if (pkg != null) {
                final ApplicationInfo app = pkg.applicationInfo;
                if (app != null) {
                    tearDownAgentAndKill(app);
                }
            }
        }",0
"@Override
	public KBTemplate fetchByUuid_C_First(String uuid, long companyId,
		OrderByComparator<KBTemplate> orderByComparator) {
		List<KBTemplate> list = findByUuid_C(uuid, companyId, 0, 1,
				orderByComparator);

		if (!list.isEmpty()) {
			return list.get(0);
		}

		return null;
	}",0
"static int runGnuplot(final HttpQuery query,
                        final String basepath,
                        final Plot plot) throws IOException {
    final int nplotted = plot.dumpToFiles(basepath);
    final long start_time = System.nanoTime();
    final Process gnuplot = new ProcessBuilder(GNUPLOT,
      basepath + "".out"", basepath + "".err"", basepath + "".gnuplot"").start();
    final int rv;
    try {
      rv = gnuplot.waitFor();  // Couldn't find how to do this asynchronously.
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();  // Restore the interrupted status.
      throw new IOException(""interrupted"", e);  // I hate checked exceptions.
    } finally {
      // We need to always destroy() the Process, otherwise we ""leak"" file
      // descriptors and pipes.  Unless I'm blind, this isn't actually
      // documented in the Javadoc of the !@#$%^ JDK, and in Java 6 there's no
      // way to ask the stupid-ass ProcessBuilder to not create fucking pipes.
      // I think when the GC kicks in the JVM may run some kind of a finalizer
      // that closes the pipes, because I've never seen this issue on long
      // running TSDs, except where ulimit -n was low (the default, 1024).
      gnuplot.destroy();
    }
    gnuplotlatency.add((int) ((System.nanoTime() - start_time) / 1000000));
    if (rv != 0) {
      final byte[] stderr = readFile(query, new File(basepath + "".err""),
                                     4096);
      // Sometimes Gnuplot will error out but still create the file.
      new File(basepath + "".png"").delete();
      if (stderr == null) {
        throw new GnuplotException(rv);
      }
      throw new GnuplotException(new String(stderr));
    }
    // Remove the files for stderr/stdout if they're empty.
    deleteFileIfEmpty(basepath + "".out"");
    deleteFileIfEmpty(basepath + "".err"");
    return nplotted;
  }",0
"private byte[] getImage(String host, byte[] defaultImage) {
        // If we've already attempted to get the favicon twice and failed,
        // return the default image.
        if (missesCache.get(host) != null && missesCache.get(host) > 1) {
            // Domain does not have a favicon so return default icon
            return defaultImage;
        }
        // See if we've cached the favicon.
        if (hitsCache.containsKey(host)) {
            return hitsCache.get(host);
        }
        byte[] bytes = getImage(""http://"" + host + ""/favicon.ico"");
        if (bytes == null) {
            // Cache that the requested domain does not have a favicon. Check if this
            // is the first cache miss or the second.
            if (missesCache.get(host) != null) {
                missesCache.put(host, 2);
            }
            else {
                missesCache.put(host, 1);
            }
            // Return byte of default icon
            bytes = defaultImage;
        }
        // Cache the favicon.
        else {
            hitsCache.put(host, bytes);
        }
        return bytes;
    }",0
"private void addGlobalFunctionTemplates(List<GlobalFunctionEntity> globalFunctionTemplates,
                                            StringTemplateLoader loader) {
        if (globalFunctionTemplates != null) {
            for (GlobalFunctionEntity template : globalFunctionTemplates) {
                loader.putTemplate(template.getName(), template.getContent());
            }
        }
    }",0
"private static void cpSubsystemConfig(XmlGenerator gen, Config config) {
        CPSubsystemConfig cpSubsystemConfig = config.getCPSubsystemConfig();
        gen.open(""cp-subsystem"")
                .node(""cp-member-count"", cpSubsystemConfig.getCPMemberCount())
                .node(""group-size"", cpSubsystemConfig.getGroupSize())
                .node(""session-time-to-live-seconds"", cpSubsystemConfig.getSessionTimeToLiveSeconds())
                .node(""session-heartbeat-interval-seconds"", cpSubsystemConfig.getSessionHeartbeatIntervalSeconds())
                .node(""missing-cp-member-auto-removal-seconds"", cpSubsystemConfig.getMissingCPMemberAutoRemovalSeconds())
                .node(""fail-on-indeterminate-operation-state"", cpSubsystemConfig.isFailOnIndeterminateOperationState())
                .node(""persistence-enabled"", cpSubsystemConfig.isPersistenceEnabled())
                .node(""base-dir"", cpSubsystemConfig.getBaseDir().getAbsolutePath())
                .node(""data-load-timeout-seconds"", cpSubsystemConfig.getDataLoadTimeoutSeconds())
                .node(""cp-member-priority"", cpSubsystemConfig.getCPMemberPriority());

        RaftAlgorithmConfig raftAlgorithmConfig = cpSubsystemConfig.getRaftAlgorithmConfig();
        gen.open(""raft-algorithm"")
                .node(""leader-election-timeout-in-millis"", raftAlgorithmConfig.getLeaderElectionTimeoutInMillis())
                .node(""leader-heartbeat-period-in-millis"", raftAlgorithmConfig.getLeaderHeartbeatPeriodInMillis())
                .node(""max-missed-leader-heartbeat-count"", raftAlgorithmConfig.getMaxMissedLeaderHeartbeatCount())
                .node(""append-request-max-entry-count"", raftAlgorithmConfig.getAppendRequestMaxEntryCount())
                .node(""commit-index-advance-count-to-snapshot"", raftAlgorithmConfig.getCommitIndexAdvanceCountToSnapshot())
                .node(""uncommitted-entry-count-to-reject-new-appends"",
                        raftAlgorithmConfig.getUncommittedEntryCountToRejectNewAppends())
                .node(""append-request-backoff-timeout-in-millis"", raftAlgorithmConfig.getAppendRequestBackoffTimeoutInMillis())
                .close();

        gen.open(""semaphores"");

        for (SemaphoreConfig semaphoreConfig : cpSubsystemConfig.getSemaphoreConfigs().values()) {
            gen.open(""semaphore"")
                    .node(""name"", semaphoreConfig.getName())
                    .node(""jdk-compatible"", semaphoreConfig.isJDKCompatible())
                    .node(""initial-permits"", semaphoreConfig.getInitialPermits())
                    .close();
        }

        gen.close().open(""locks"");

        for (FencedLockConfig lockConfig : cpSubsystemConfig.getLockConfigs().values()) {
            gen.open(""fenced-lock"")
                    .node(""name"", lockConfig.getName())
                    .node(""lock-acquire-limit"", lockConfig.getLockAcquireLimit())
                    .close();
        }

        gen.close().close();
    }",0
"public HttpURLConnection createConnection(TLSClientParameters tlsClientParameters,
            Proxy proxy, URL url) throws IOException {

        HttpURLConnection connection =
            (HttpURLConnection) (proxy != null
                                   ? url.openConnection(proxy)
                                   : url.openConnection());
        if (HTTPS_URL_PROTOCOL_ID.equals(url.getProtocol())) {

            if (tlsClientParameters == null) {
                tlsClientParameters = new TLSClientParameters();
            }

            try {
                decorateWithTLS(tlsClientParameters, connection);
            } catch (Throwable ex) {
                if (ex instanceof IOException) {
                    throw (IOException) ex;
                }
                IOException ioException = new IOException(""Error while initializing secure socket"", ex);
                throw ioException;
            }
        }

        return connection;
    }",0
"public boolean bindBackupAgent(String packageName, int backupMode, int userId) {
        if (DEBUG_BACKUP) Slog.v(TAG, ""bindBackupAgent: app="" + packageName + "" mode="" + backupMode);
        enforceCallingPermission(""android.permission.CONFIRM_FULL_BACKUP"", ""bindBackupAgent"");

        IPackageManager pm = AppGlobals.getPackageManager();
        ApplicationInfo app = null;
        try {
            app = pm.getApplicationInfo(packageName, STOCK_PM_FLAGS, userId);
        } catch (RemoteException e) {
            // can't happen; package manager is process-local
        }
        if (app == null) {
            Slog.w(TAG, ""Unable to bind backup agent for "" + packageName);
            return false;
        }

        int oldBackupUid;
        int newBackupUid;

        synchronized(this) {
            // !!! TODO: currently no check here that we're already bound
            BatteryStatsImpl.Uid.Pkg.Serv ss = null;
            BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics();
            synchronized (stats) {
                ss = stats.getServiceStatsLocked(app.uid, app.packageName, app.name);
            }

            // Backup agent is now in use, its package can't be stopped.
            try {
                AppGlobals.getPackageManager().setPackageStoppedState(
                        app.packageName, false, UserHandle.getUserId(app.uid));
            } catch (RemoteException e) {
            } catch (IllegalArgumentException e) {
                Slog.w(TAG, ""Failed trying to unstop package ""
                        + app.packageName + "": "" + e);
            }

            BackupRecord r = new BackupRecord(ss, app, backupMode);
            ComponentName hostingName =
                    (backupMode == ApplicationThreadConstants.BACKUP_MODE_INCREMENTAL)
                            ? new ComponentName(app.packageName, app.backupAgentName)
                            : new ComponentName(""android"", ""FullBackupAgent"");
            // startProcessLocked() returns existing proc's record if it's already running
            ProcessRecord proc = startProcessLocked(app.processName, app,
                    false, 0, ""backup"", hostingName, false, false, false);
            if (proc == null) {
                Slog.e(TAG, ""Unable to start backup agent process "" + r);
                return false;
            }

            // If the app is a regular app (uid >= 10000) and not the system server or phone
            // process, etc, then mark it as being in full backup so that certain calls to the
            // process can be blocked. This is not reset to false anywhere because we kill the
            // process after the full backup is done and the ProcessRecord will vaporize anyway.
            if (UserHandle.isApp(app.uid) &&
                    backupMode == ApplicationThreadConstants.BACKUP_MODE_FULL) {
                proc.inFullBackup = true;
            }
            r.app = proc;
            oldBackupUid = mBackupTarget != null ? mBackupTarget.appInfo.uid : -1;
            newBackupUid = proc.inFullBackup ? r.appInfo.uid : -1;
            mBackupTarget = r;
            mBackupAppName = app.packageName;

            // Try not to kill the process during backup
            updateOomAdjLocked(proc, true);

            // If the process is already attached, schedule the creation of the backup agent now.
            // If it is not yet live, this will be done when it attaches to the framework.
            if (proc.thread != null) {
                if (DEBUG_BACKUP) Slog.v(TAG_BACKUP, ""Agent proc already running: "" + proc);
                try {
                    proc.thread.scheduleCreateBackupAgent(app,
                            compatibilityInfoForPackageLocked(app), backupMode);
                } catch (RemoteException e) {
                    // Will time out on the backup manager side
                }
            } else {
                if (DEBUG_BACKUP) Slog.v(TAG_BACKUP, ""Agent proc not running, waiting for attach"");
            }
            // Invariants: at this point, the target app process exists and the application
            // is either already running or in the process of coming up.  mBackupTarget and
            // mBackupAppName describe the app, so that when it binds back to the AM we
            // know that it's scheduled for a backup-agent operation.
        }

        JobSchedulerInternal js = LocalServices.getService(JobSchedulerInternal.class);
        if (oldBackupUid != -1) {
            js.removeBackingUpUid(oldBackupUid);
        }
        if (newBackupUid != -1) {
            js.addBackingUpUid(newBackupUid);
        }

        return true;
    }",0
"public static boolean isConfigForWpa3EnterpriseNetwork(WifiConfiguration config) {
        return config.isSecurityType(WifiConfiguration.SECURITY_TYPE_EAP_WPA3_ENTERPRISE);
    }",0
"public JSONObject put(String key, int value) throws JSONException {
        return this.put(key, Integer.valueOf(value));
    }",0
"@Transactional
    @Nonnull
    public <E extends KrailEntity<ID, VER>> E save(@Nonnull E entity) {
        checkNotNull(entity);
        EntityManager entityManager = entityManagerProvider.get();


        if (entity.getId() == null) {
            entityManager.persist(entity);
            log.debug(""{} persisted"", entity);
            return entity;
        }


        @SuppressWarnings(""unchecked"") Optional<E> fEntity = findById((Class<E>) entity.getClass(), entity.getId());
        if (fEntity.isPresent()) {
            E managedEntity = entityManager.merge(entity);
            log.debug(""{} persisted"", managedEntity);
            return managedEntity;
        } else {
            entityManager.persist(entity);
            log.debug(""{} persisted"", entity);
            return entity;
        }
    }",0
"public void setAdminAddress(String adminAddress) {
        if(adminAddress.startsWith(""\"""") && adminAddress.endsWith(""\"""")) {
            // some users apparently quote the whole thing. Don't konw why
            // anyone does this, but it's a machine's job to forgive human mistake
            adminAddress = adminAddress.substring(1,adminAddress.length()-1);
        }
        this.adminAddress = adminAddress;
        save();
    }",0
"private boolean shouldEncryptWithCredentials(boolean defaultValue) {
        return isCredentialRequiredToDecrypt(defaultValue) && !isDoNotAskCredentialsOnBootSet();
    }",0
"public void stopNow() {
            this.stopNow = true;
            try {
                join();
            } catch (InterruptedException e) {
                // ignore
            }
        }",0
"private void setFingerprintRunningState(int fingerprintRunningState) {
        boolean wasRunning = mFingerprintRunningState == FINGERPRINT_STATE_RUNNING;
        boolean isRunning = fingerprintRunningState == FINGERPRINT_STATE_RUNNING;
        mFingerprintRunningState = fingerprintRunningState;

        // Clients of KeyguardUpdateMonitor don't care about the internal state about the
        // asynchronousness of the cancel cycle. So only notify them if the actualy running state
        // has changed.
        if (wasRunning != isRunning) {
            notifyFingerprintRunningStateChanged();
        }
    }",0
"ServerBuilder routingDecorator(RouteDecoratingService routeDecoratingService) {
        virtualHostTemplate.addRouteDecoratingService(routeDecoratingService);
        return this;
    }",0
"public @Nullable String getCursorName() throws SQLException {
    checkClosed();
    return null;
  }",0
"@Override
  public int read() throws IOException {
    int readLen = read(singleByteBuffer);

    if (readLen == -1) {
      return -1;
    }

    return singleByteBuffer[0] & 0xff;
  }",0
"private static boolean staleCacheFile(final HttpQuery query,
                                        final long end_time,
                                        final long max_age,
                                        final File cachedfile) throws Exception {
    PowerMockito.mockStatic(System.class);
    PowerMockito.when(System.getProperty(anyString(), anyString())).thenReturn("""");
    PowerMockito.when(System.getProperty(anyString())).thenReturn("""");
    PowerMockito.spy(GraphHandler.class);
    PowerMockito.doReturn("""").when(GraphHandler.class, ""findGnuplotHelperScript"");
    
    return Whitebox.<Boolean>invokeMethod(GraphHandler.class, ""staleCacheFile"",
                                          query, end_time / 1000, max_age,
                                          cachedfile);
    
    //return (Boolean)sm.invoke(null, query, end_time / 1000, max_age, cachedfile);
  }",0
"@NonNull
        public Builder setCategory(String category) {
            mN.category = category;
            return this;
        }",0
"@Override
  public Route.Definition get(final String path, final Route.Filter filter) {
    return appendDefinition(GET, path, filter);
  }",0
"@Override
    public void setTaskDescription(IBinder token, ActivityManager.TaskDescription td) {
        synchronized (this) {
            ActivityRecord r = ActivityRecord.isInStackLocked(token);
            if (r != null) {
                r.setTaskDescription(td);
                r.task.updateTaskDescription();
            }
        }
    }",0
"public static String history(String pipelineName) {
            return BASE + HISTORY_PATH.replaceAll("":pipeline_name"", pipelineName);
        }",0
"public boolean isInAdminMode()
    {
        return getDriver().getCurrentUrl().contains(""/admin/"");
    }",0
"public int getTimeout() {
		return timeout;
	}",0
"@Test
	public void appliesIgnoreCaseOrderingCorrectly() {

		Sort sort = new Sort(new Sort.Order(""firstname"").ignoreCase());

		String query = ""select p from Person p"";
		assertThat(applySorting(query, sort, ""p""), endsWith(""order by lower(p.firstname) asc""));
	}",0
"public List<AbstractProject> getChildProjects() {
        return getChildProjects(Jenkins.getInstance());
    }",0
"public SerializationConfig addClassDefinition(ClassDefinition classDefinition) {
        if (!getClassDefinitions().add(classDefinition)) {
            throw new IllegalArgumentException(""ClassDefinition for class-id["" + classDefinition.getClassId()
                    + ""] already exists!"");
        }
        return this;
    }",0
"@Override
        public boolean isCommitted() {
            return false;
        }",0
"public int readI32() throws TException {
    byte[] buf = buffer;
    int off = 0;

    if (trans_.getBytesRemainingInBuffer() >= 4) {
      buf = trans_.getBuffer();
      off = trans_.getBufferPosition();
      trans_.consumeBuffer(4);
    } else {
      readAll(buffer, 0, 4);
    }
    return ((buf[off] & 0xff) << 24)
        | ((buf[off + 1] & 0xff) << 16)
        | ((buf[off + 2] & 0xff) << 8)
        | ((buf[off + 3] & 0xff));
  }",0
"public static boolean equals(byte[] bytes1, int startPos1, byte[] bytes2, int startPos2, int length) {
        return !hasUnsafe() || !unalignedAccess() ?
                  equalsSafe(bytes1, startPos1, bytes2, startPos2, length) :
                  PlatformDependent0.equals(bytes1, startPos1, bytes2, startPos2, length);
    }",0
"private boolean isSchemaDefinitionInPublishList(CmsUUID publishHistoryId) {

        if (m_cms == null) {
            // CmsObject not available, assume there may be a schema definition in the publish history
            return true;
        }
        try {
            List<CmsPublishedResource> publishedResources = m_cms.readPublishedResources(publishHistoryId);
            for (CmsPublishedResource cmsPublishedResource : publishedResources) {
                String resourceRootPath = cmsPublishedResource.getRootPath();
                String resourceRootPathLowerCase = resourceRootPath.toLowerCase();
                if (resourceRootPathLowerCase.endsWith("".xsd"")
                    || resourceRootPathLowerCase.endsWith("".dtd"")
                    || m_cacheTemporary.containsKey(getCacheKey(resourceRootPath, true))) {
                    return true;
                }
            }
        } catch (CmsException e) {
            // error reading published Resources.
            LOG.warn(e.getMessage(), e);
        }
        return false;
    }",0
"public static Map<String, String> getNodeAttributes(Node node) {
		Map<String, String> ret = new HashMap<String, String>();
		NamedNodeMap atts = node.getAttributes();
		for (int i = 0; i < atts.getLength(); i++) {
			Node attribute = atts.item(i);
			ret.put(attribute.getNodeName(), attribute.getNodeValue());
		}
		return ret;
	}",0
"private void saveVoiceMailAndForwardingNumber(
            String key, VoicemailProviderSettings newSettings) {
        if (DBG) log(""saveVoiceMailAndForwardingNumber: "" + newSettings.toString());
        mNewVMNumber = newSettings.getVoicemailNumber();
        mNewVMNumber = (mNewVMNumber == null) ? """" : mNewVMNumber;
        mNewFwdSettings = newSettings.getForwardingSettings();

        // Call forwarding is not suppported on CDMA.
        if (mPhone.getPhoneType() == PhoneConstants.PHONE_TYPE_CDMA) {
            if (DBG) log(""Ignoring forwarding setting since this is CDMA phone"");
            mNewFwdSettings = VoicemailProviderSettings.NO_FORWARDING;
        }

        // Throw a warning if the voicemail is the same and we did not change forwarding.
        if (mNewVMNumber.equals(mOldVmNumber)
                && mNewFwdSettings == VoicemailProviderSettings.NO_FORWARDING) {
            showDialogIfForeground(VoicemailDialogUtil.VM_NOCHANGE_ERROR_DIALOG);
            return;
        }

        VoicemailProviderSettingsUtil.save(this, key, newSettings);
        mVMChangeCompletedSuccessfully = false;
        mFwdChangesRequireRollback = false;
        mVMOrFwdSetError = 0;

        if (mNewFwdSettings == VoicemailProviderSettings.NO_FORWARDING
                || key.equals(mPreviousVMProviderKey)) {
            if (DBG) log(""Set voicemail number. No changes to forwarding number."");
            setVoicemailNumberWithCarrier();
        } else {
            if (DBG) log(""Reading current forwarding settings."");
            int numSettingsReasons = VoicemailProviderSettings.FORWARDING_SETTINGS_REASONS.length;
            mForwardingReadResults = new CallForwardInfo[numSettingsReasons];
            for (int i = 0; i < mForwardingReadResults.length; i++) {
                mPhone.getCallForwardingOption(
                        VoicemailProviderSettings.FORWARDING_SETTINGS_REASONS[i],
                        CommandsInterface.SERVICE_CLASS_VOICE,
                        mGetOptionComplete.obtainMessage(EVENT_FORWARDING_GET_COMPLETED, i, 0));
            }
            showDialogIfForeground(VoicemailDialogUtil.VM_FWD_READING_DIALOG);
        }
    }",0
"private PendingAssistExtras enqueueAssistContext(int requestType, Intent intent, String hint,
            int userHandle) {
        enforceCallingPermission(android.Manifest.permission.GET_TOP_ACTIVITY_INFO,
                ""getAssistContextExtras()"");
        PendingAssistExtras pae;
        Bundle extras = new Bundle();
        synchronized (this) {
            ActivityRecord activity = getFocusedStack().mResumedActivity;
            if (activity == null) {
                Slog.w(TAG, ""getAssistContextExtras failed: no resumed activity"");
                return null;
            }
            extras.putString(Intent.EXTRA_ASSIST_PACKAGE, activity.packageName);
            if (activity.app == null || activity.app.thread == null) {
                Slog.w(TAG, ""getAssistContextExtras failed: no process for "" + activity);
                return null;
            }
            if (activity.app.pid == Binder.getCallingPid()) {
                Slog.w(TAG, ""getAssistContextExtras failed: request process same as "" + activity);
                return null;
            }
            pae = new PendingAssistExtras(activity, extras, intent, hint, userHandle);
            try {
                activity.app.thread.requestAssistContextExtras(activity.appToken, pae,
                        requestType);
                mPendingAssistExtras.add(pae);
                mHandler.postDelayed(pae, PENDING_ASSIST_EXTRAS_TIMEOUT);
            } catch (RemoteException e) {
                Slog.w(TAG, ""getAssistContextExtras failed: crash calling "" + activity);
                return null;
            }
            return pae;
        }
    }",0
"public static void copyResource(Object obj, String fnm, File fdest) throws IOException, ContentError {
	   String s = getRelativeResource(obj, fnm);
	   FileUtil.writeStringToFile(s, new File(fdest, fnm));
   }",0
"public static PdfObject getPdfObject(PdfObject obj, PdfObject parent) {
        if (obj == null)
            return null;
        if (!obj.isIndirect()) {
            PRIndirectReference ref = null;
            if (parent != null && (ref = parent.getIndRef()) != null && ref.getReader().isAppendable()) {
                switch (obj.type()) {
                    case PdfObject.m_NULL: // ssteward
                        obj = new PdfNull();
                        break;
                    case PdfObject.BOOLEAN:
                        obj = new PdfBoolean(((PdfBoolean)obj).booleanValue());
                        break;
                    case PdfObject.NAME:
                        obj = new PdfName(obj.getBytes());
                        break;
                }
                obj.setIndRef(ref);
            }
            return obj;
        }
        return getPdfObject(obj);
    }",0
"@Override
    public boolean isInPictureInPictureMode(IBinder token) {
        final long origId = Binder.clearCallingIdentity();
        try {
            synchronized(this) {
                return isInPictureInPictureMode(ActivityRecord.forTokenLocked(token));
            }
        } finally {
            Binder.restoreCallingIdentity(origId);
        }
    }",0
"@Override
    public boolean unlockUser(int userId, @Nullable byte[] token, @Nullable byte[] secret,
            @Nullable IProgressListener listener) {
        return mUserController.unlockUser(userId, secret, listener);
    }",0
"private static String toLuceneDateTime(String dateString) {
            String format = ""MM/dd/yyyy HH:mm:ss"";
            String result = toLuceneDateWithFormat(dateString, format);
            if (result.equals(ERROR_DATE)) {
                format = ""MM/dd/yyyy HH:mm"";
                result = toLuceneDateWithFormat(dateString, format);
            }
            return result;
        }",0
"public void setSAXHandlerFactory(final SAXHandlerFactory factory) {
		this.handlerfac = factory == null ? DEFAULTSAXHANDLERFAC : factory;
		engine = null;
	}",0
"@Override
    public boolean fullySupports3DBiomes() {
        // Supports if API does and we're not in the overworld
        return HAS_3D_BIOMES && getWorld().getEnvironment() != World.Environment.NORMAL || PaperLib.isVersion(18);
    }",0
"@Override
    public int getBackspaceKeyCode() {
        return DROID_IMPL_KEY_BACKSPACE;
    }",0
"private void notifyFinished(UserRequest ureq) {
		VFSContainer container = VFSManager.findInheritingSecurityCallbackContainer(folderComponent.getRootContainer());
		VFSSecurityCallback secCallback = container.getLocalSecurityCallback();
		if(secCallback != null) {
			SubscriptionContext subsContext = secCallback.getSubscriptionContext();
			if (subsContext != null) {
				notificationsManager.markPublisherNews(subsContext, ureq.getIdentity(), true);
			}
		}
		fireEvent(ureq, FOLDERCOMMAND_FINISHED);
	}",0
"private void createClusterRoleBinding(String namespace, TaskLogger jobLogger) {
		AtomicBoolean clusterRoleBindingExists = new AtomicBoolean(false);
		Commandline cmd = newKubeCtl();
		cmd.addArgs(""get"", ""clusterrolebindings"", ""--field-selector"", ""metadata.name="" + namespace, 
				""-o"", ""name"");
		cmd.execute(new LineConsumer() {

			@Override
			public void consume(String line) {
				clusterRoleBindingExists.set(true);
			}
			
		}, new LineConsumer() {

			@Override
			public void consume(String line) {
				jobLogger.error(""Kubernetes: "" + line);
			}
			
		}).checkReturnCode();
		
		if (clusterRoleBindingExists.get())
			deleteClusterRoleBinding(namespace, jobLogger);
		
		Map<Object, Object> clusterRoleBindingDef = CollectionUtils.newLinkedHashMap(
				""apiVersion"", ""rbac.authorization.k8s.io/v1"", 
				""kind"", ""ClusterRoleBinding"", 
				""metadata"", CollectionUtils.newLinkedHashMap(
						""name"", namespace), 
				""subjects"", Lists.<Object>newArrayList(CollectionUtils.newLinkedHashMap(
						""kind"", ""ServiceAccount"", 
						""name"", ""default"", 
						""namespace"", namespace)), 
				""roleRef"", CollectionUtils.newLinkedHashMap(
						""apiGroup"", ""rbac.authorization.k8s.io"",
						""kind"", ""ClusterRole"", 
						""name"", getClusterRole()));
		createResource(clusterRoleBindingDef, new HashSet<>(), jobLogger);
	}",0
"protected String getEventGroupItemWithUnitSql(String studyIds, String sedIds, String itemIds, String dateConstraint, int datasetItemStatusId,
            String studySubjectIds) {
        return ""select cvit.*, mu.oc_oid as mu_oid from (""
                + this.getEventGroupItemSqlSS(studyIds, sedIds, itemIds, dateConstraint, datasetItemStatusId, studySubjectIds)
                + "" )cvit left join (select item.item_id, mu.oc_oid from versioning_map vm, item, measurement_unit mu where vm.item_id in "" + itemIds
                + "" and vm.item_id = item.item_id and item.units = mu.name )mu on cvit.item_id = mu.item_id""
                + "" ORDER BY cvit.event_crf_id, cvit.item_group_id, cvit.item_id, cvit.item_data_ordinal"";
    }",0
"@Override
    public void addPortForwardingEventListener(PortForwardingEventListener listener) {
        PortForwardingEventListener.validateListener(listener);
        // avoid race conditions on notifications while session is being closed
        if (!isOpen()) {
            log.warn(""addPortForwardingEventListener({})[{}] ignore registration while session is closing"", this, listener);
            return;
        }

        if (this.tunnelListeners.add(listener)) {
            if (log.isTraceEnabled()) {
                log.trace(""addPortForwardingEventListener({})[{}] registered"", this, listener);
            }
        } else {
            if (log.isTraceEnabled()) {
                log.trace(""addPortForwardingEventListener({})[{}] ignored duplicate"", this, listener);
            }
        }
    }",0
"private ArrayList<ViewItem> createDatasetItems(FillResponse response,
            AutofillId focusedViewId) {
        final int datasetCount = response.getDatasets().size();
        if (sVerbose) {
            Slog.v(TAG, ""Number datasets: "" + datasetCount + "" max visible: ""
                    + mVisibleDatasetsMaxCount);
        }

        final RemoteViews.InteractionHandler interceptionHandler = (view, pendingIntent, r) -> {
            if (pendingIntent != null) {
                mCallback.startIntentSender(pendingIntent.getIntentSender());
            }
            return true;
        };

        final ArrayList<ViewItem> items = new ArrayList<>(datasetCount);
        for (int i = 0; i < datasetCount; i++) {
            final Dataset dataset = response.getDatasets().get(i);
            final int index = dataset.getFieldIds().indexOf(focusedViewId);
            if (index >= 0) {
                RemoteViews presentation = Helper.sanitizeRemoteView(
                        dataset.getFieldDialogPresentation(index));
                if (presentation == null) {
                    if (sDebug) {
                        Slog.w(TAG, ""not displaying UI on field "" + focusedViewId + "" because ""
                                + ""service didn't provide a presentation for it on "" + dataset);
                    }
                    continue;
                }
                final View view;
                try {
                    if (sVerbose) Slog.v(TAG, ""setting remote view for "" + focusedViewId);
                    view = presentation.applyWithTheme(
                            mContext, null, interceptionHandler, mThemeId);
                } catch (RuntimeException e) {
                    Slog.e(TAG, ""Error inflating remote views"", e);
                    continue;
                }
                // TODO: Extract the shared filtering logic here and in FillUi to a common
                //  method.
                final Dataset.DatasetFieldFilter filter = dataset.getFilter(index);
                Pattern filterPattern = null;
                String valueText = null;
                boolean filterable = true;
                if (filter == null) {
                    final AutofillValue value = dataset.getFieldValues().get(index);
                    if (value != null && value.isText()) {
                        valueText = value.getTextValue().toString().toLowerCase();
                    }
                } else {
                    filterPattern = filter.pattern;
                    if (filterPattern == null) {
                        if (sVerbose) {
                            Slog.v(TAG, ""Explicitly disabling filter at id "" + focusedViewId
                                    + "" for dataset #"" + index);
                        }
                        filterable = false;
                    }
                }

                items.add(new ViewItem(dataset, filterPattern, filterable, valueText, view));
            }
        }
        return items;
    }",1
"public T getDecrypter() {
    return decrypter;
  }",0
"@Override
    public boolean isActive() {
        return active;
    }",0
"private InstallArgs createInstallArgsForExisting(int installFlags, String codePath,
            String resourcePath, String[] instructionSets) {
        final boolean isInAsec;
        if (installOnExternalAsec(installFlags)) {
            /* Apps on SD card are always in ASEC containers. */
            isInAsec = true;
        } else if (installForwardLocked(installFlags)
                && !codePath.startsWith(mDrmAppPrivateInstallDir.getAbsolutePath())) {
            /*
             * Forward-locked apps are only in ASEC containers if they're the
             * new style
             */
            isInAsec = true;
        } else {
            isInAsec = false;
        }

        if (isInAsec) {
            return new AsecInstallArgs(codePath, instructionSets,
                    installOnExternalAsec(installFlags), installForwardLocked(installFlags));
        } else {
            return new FileInstallArgs(codePath, resourcePath, instructionSets);
        }
    }",0
"@Override
        public void setAnimateWakeup(boolean animateWakeup) {
            mAnimateWakeup = animateWakeup;
        }",0
"@Override
    @Transactional( readOnly = true )
    public List<Program> getUserPrograms()
    {
        return getUserPrograms( currentUserService.getCurrentUser() );
    }",0
"public void validateNotSubdirectoryOf(String otherSCMMaterialFolder) {
        String myDirPath = this.getFolder();
        if (myDirPath == null || otherSCMMaterialFolder == null) {
            return;
        }
        if (FilenameUtil.isNormalizedDirectoryPathInsideNormalizedParentDirectory(myDirPath, otherSCMMaterialFolder)) {
            addError(FOLDER, ""Invalid Destination Directory. Every material needs a different destination directory and the directories should not be nested."");
        }
    }",0
"@SuppressWarnings(""resource"")
    protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p, DeserializationContext ctxt)
        throws IOException
    {
        // 01-Dec-2016, tatu: Note: This IS legal to call, but only when unwrapped
        //    value itself is NOT passed via `CreatorProperty` (which isn't supported).
        //    Ok however to pass via setter or field.
        
        final PropertyBasedCreator creator = _propertyBasedCreator;
        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);

        TokenBuffer tokens = ctxt.bufferForInputBuffering(p);
        tokens.writeStartObject();

        JsonToken t = p.currentToken();
        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {
            String propName = p.currentName();
            p.nextToken(); // to point to value
            // creator property?
            final SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);
            // Object Id property?
            if (buffer.readIdProperty(propName) && creatorProp == null) {
                continue;
            }
            if (creatorProp != null) {
                // Last creator property to set?
                if (buffer.assignParameter(creatorProp,
                        _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {
                    t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT
                    Object bean;
                    try {
                        bean = creator.build(ctxt, buffer);
                    } catch (Exception e) {
                        bean = wrapInstantiationProblem(e, ctxt);
                    }
                    // [databind#631]: Assign current value, to be accessible by custom serializers
                    p.setCurrentValue(bean);
                    // if so, need to copy all remaining tokens into buffer
                    while (t == JsonToken.FIELD_NAME) {
                        // NOTE: do NOT skip name as it needs to be copied; `copyCurrentStructure` does that
                        tokens.copyCurrentStructure(p);
                        t = p.nextToken();
                    }
                    // 28-Aug-2018, tatu: Let's add sanity check here, easier to catch off-by-some
                    //    problems if we maintain invariants
                    if (t != JsonToken.END_OBJECT) {
                        ctxt.reportWrongTokenException(this, JsonToken.END_OBJECT, 
                                ""Attempted to unwrap '%s' value"",
                                handledType().getName());
                    }
                    tokens.writeEndObject();
                    if (bean.getClass() != _beanType.getRawClass()) {
                        // !!! 08-Jul-2011, tatu: Could probably support; but for now
                        //   it's too complicated, so bail out
                        ctxt.reportInputMismatch(creatorProp,
                                ""Cannot create polymorphic instances with unwrapped values"");
                        return null;
                    }
                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);
                }
                continue;
            }
            // regular property? needs buffering
            SettableBeanProperty prop = _beanProperties.find(propName);
            if (prop != null) {
                buffer.bufferProperty(prop, _deserializeWithErrorWrapping(p, ctxt, prop));
                continue;
            }
            // Things marked as ignorable should not be passed to any setter
            if (IgnorePropertiesUtil.shouldIgnore(propName, _ignorableProps, _includableProps)) {
                handleIgnoredProperty(p, ctxt, handledType(), propName);
                continue;
            }
            // 29-Nov-2016, tatu: probably should try to avoid sending content
            //    both to any setter AND buffer... but, for now, the only thing
            //    we can do.
            // how about any setter? We'll get copies but...
            if (_anySetter == null) {
                // but... others should be passed to unwrapped property deserializers
                tokens.writeFieldName(propName);
                tokens.copyCurrentStructure(p);
            } else {
                // Need to copy to a separate buffer first
                TokenBuffer b2 = ctxt.bufferAsCopyOfValue(p);
                tokens.writeFieldName(propName);
                tokens.append(b2);
                try {
                    buffer.bufferAnyProperty(_anySetter, propName,
                            _anySetter.deserialize(b2.asParserOnFirstToken(), ctxt));
                } catch (Exception e) {
                    wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);
                }
                continue;
            }
        }

        // We hit END_OBJECT, so:
        Object bean;
        try {
            bean = creator.build(ctxt, buffer);
        } catch (Exception e) {
            wrapInstantiationProblem(e, ctxt);
            return null; // never gets here
        }
        return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);
    }",0
"public Registration addDetachListener(Command detachListener) {
        assert detachListener != null;

        if (detachListeners == null) {
            detachListeners = new ArrayList<>(1);
        }
        detachListeners.add(detachListener);

        return () -> removeDetachListener(detachListener);
    }",0
"protected String getShareableUri(boolean http) {
		return null;
	}",0
"public static Document stringToDocument(String xml) throws Exception {
		try {
			DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();

			// Disable XXE: security measure to prevent DOS, arbitrary-file-read, and possibly RCE
			dbf.setExpandEntityReferences(false);
			dbf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
			dbf.setFeature(""http://xml.org/sax/features/external-general-entities"",false);
			dbf.setFeature(""http://xml.org/sax/features/external-parameter-entities"",false);

			DocumentBuilder db = dbf.newDocumentBuilder();
			Document document = db.parse(new InputSource(new StringReader(xml)));
			return document;
		}
		catch (Exception e) {
			log.error(""Error converting String to Document:\n"" + xml);
			throw e;
		}
	}",1
"private void sendResourcesChangedBroadcast(boolean mediaStatus, boolean replacing,
            ArrayList<ApplicationInfo> infos, IIntentReceiver finishedReceiver) {
        final int size = infos.size();
        final String[] packageNames = new String[size];
        final int[] packageUids = new int[size];
        for (int i = 0; i < size; i++) {
            final ApplicationInfo info = infos.get(i);
            packageNames[i] = info.packageName;
            packageUids[i] = info.uid;
        }
        sendResourcesChangedBroadcast(mediaStatus, replacing, packageNames, packageUids,
                finishedReceiver);
    }",0
"protected PdfObject readSingleObject(int k) throws IOException {
        strings.clear();
        int k2 = k * 2;
        int pos = xref[k2];
        if (pos < 0)
            return null;
        if (xref[k2 + 1] > 0)
            pos = objStmToOffset.get(xref[k2 + 1]);
        if (pos == 0)
            return null;
        tokens.seek(pos);
        tokens.nextValidToken();
        if (tokens.getTokenType() != PRTokeniser.TK_NUMBER)
            tokens.throwError(""Invalid object number."");
        objNum = tokens.intValue();
        tokens.nextValidToken();
        if (tokens.getTokenType() != PRTokeniser.TK_NUMBER)
            tokens.throwError(""Invalid generation number."");
        objGen = tokens.intValue();
        tokens.nextValidToken();
        if (!tokens.getStringValue().equals(""obj""))
            tokens.throwError(""Token 'obj' expected."");
        PdfObject obj;
        try {
            obj = readPRObject();
            for (int j = 0; j < strings.size(); ++j) {
                PdfString str = (PdfString)strings.get(j);
                str.decrypt(this);
            }
            if (obj.isStream()) {
                checkPRStreamLength((PRStream)obj);
            }
        }
        catch (Exception e) {
            obj = null;
        }
        if (xref[k2 + 1] > 0) {
            obj = readOneObjStm((PRStream)obj, xref[k2]);
        }
        xrefObj.set(k, obj);
        return obj;
    }",0
"@Override
    public void onAccountsUpdated(Account[] accounts) {
        // Review current upload, and cancel it if its account doesn't exist
        if (mCurrentUpload != null && !accountManager.exists(mCurrentUpload.getAccount())) {
            mCurrentUpload.cancel(ResultCode.ACCOUNT_NOT_FOUND);
        }
        // The rest of uploads are cancelled when they try to start
    }",0
"@Override
    public void preFinalizationCompleted() {
        ProvisionLogger.logi(""AdminIntegratedFlowPrepareActivity pre-finalization completed"");
        setResult(Activity.RESULT_OK);
        getTransitionHelper().finishActivity(this);
    }",0
"public WearableExtender setBridgeTag(String bridgeTag) {
            mBridgeTag = bridgeTag;
            return this;
        }",0
"public List<ServerConfiguration> getServers() {
    return servers;
  }",0
"public boolean isSleepingOrShuttingDown() {
        return isSleeping() || mShuttingDown;
    }",0
"private void resetGestureDetection() {
        if (mNativeContentViewCore == 0) return;
        nativeResetGestureDetection(mNativeContentViewCore);
    }",0
"public String htmlStartStyle(String title, String stylesheet) {

        return pageHtmlStyle(HTML_START, title, stylesheet);
    }",0
"public Collection<String> getRoles() {
        return roles;
    }",0
"public String getView() {
        return view == null ? null : view.getValue();
    }",0
"@Override
	public void updateAdminInfo(Admin admin) {

		String sql = ""update admin_table set admin_name=?, password=? where id=?"";
		try {
			ps = DbUtil.getConnection().prepareStatement(sql);
			ps.setString(1, admin.getAdminName());
			ps.setString(2, admin.getPassword());
			ps.setInt(3, admin.getId());
			ps.executeUpdate();
		} catch (ClassNotFoundException | SQLException e) {
			e.printStackTrace();
		}
	}",0
"private static List<String> targetUriToStringList(TransactionContext txnCtx,
                                                      NodeContext nodeCtx,
                                                      Symbol targetUri) {
        Object value = SymbolEvaluator.evaluate(txnCtx, nodeCtx, targetUri, Row.EMPTY, SubQueryResults.EMPTY);
        if (targetUri.valueType().id() == DataTypes.STRING.id()) {
            String uri = (String) value;
            return Collections.singletonList(uri);
        } else if (DataTypes.STRING_ARRAY.equals(targetUri.valueType())) {
            return DataTypes.STRING_ARRAY.implicitCast(value);
        }

        // this case actually never happens because the check is already done in the analyzer
        throw AnalyzedCopyFrom.raiseInvalidType(targetUri.valueType());
    }",0
"public void ensureBootCompleted() {
            // Locked intentionally not held as it isn't needed for this case.
            ActivityManagerService.this.ensureBootCompleted();
        }",0
"private void updatePreferencesOrFinish(boolean isRecreatingActivity) {
            Intent intent = getActivity().getIntent();
            int quality = intent.getIntExtra(LockPatternUtils.PASSWORD_TYPE_KEY, -1);
            if (quality == -1) {
                // If caller didn't specify password quality, show UI and allow the user to choose.
                quality = intent.getIntExtra(MINIMUM_QUALITY_KEY, -1);
                quality = mController.upgradeQuality(quality);
                final boolean hideDisabledPrefs = intent.getBooleanExtra(
                        HIDE_DISABLED_PREFS, false);
                final PreferenceScreen prefScreen = getPreferenceScreen();
                if (prefScreen != null) {
                    prefScreen.removeAll();
                }
                addPreferences();
                disableUnusablePreferences(quality, hideDisabledPrefs);
                updatePreferenceText();
                updateCurrentPreference();
                updatePreferenceSummaryIfNeeded();
            } else if (!isRecreatingActivity) {
                // Don't start the activity again if we are recreated for configuration change
                updateUnlockMethodAndFinish(quality, false, true /* chooseLockSkipped */);
            }
        }",0
"public static boolean isValidType(Object value) {
        return (value instanceof Integer) || (value instanceof Long) ||
                (value instanceof Double) || (value instanceof String) ||
                (value instanceof int[]) || (value instanceof long[]) ||
                (value instanceof double[]) || (value instanceof String[]) ||
                (value instanceof PersistableBundle) || (value == null) ||
                (value instanceof Boolean) || (value instanceof boolean[]);
    }",0
"private Syntax getCurrentContentSyntaxInternal(XWikiContext context)
    {
        Syntax syntax = null;

        // Try to find the current syntax
        if (getRenderingContext() != null) {
            Block curentBlock = getRenderingContext().getCurrentBlock();

            if (curentBlock != null) {
                MetaDataBlock metaDataBlock =
                    curentBlock.getFirstBlock(new MetadataBlockMatcher(MetaData.SYNTAX), Axes.ANCESTOR_OR_SELF);

                if (metaDataBlock != null) {
                    return (Syntax) metaDataBlock.getMetaData().getMetaData(MetaData.SYNTAX);
                }
            }
        }

        // Fallback on secure and current document in the context
        if (context.get(""sdoc"") != null) {
            // The content document
            syntax = ((XWikiDocument) context.get(""sdoc"")).getSyntax();
        } else if (context.getDoc() != null) {
            // The context document
            syntax = context.getDoc().getSyntax();
        }

        return syntax;
    }",0
"@Override
    public void cancelSync(Account account, String authority, ComponentName cname) {
        cancelSyncAsUser(account, authority, cname, UserHandle.getCallingUserId());
    }",0
"@RequestMapping(value = ""/repository/restful/artifact/GET/html"", method = RequestMethod.GET)
    public ModelAndView getArtifactAsHtml(@RequestParam(""pipelineName"") String pipelineName,
                                          @RequestParam(""pipelineCounter"") String pipelineCounter,
                                          @RequestParam(""stageName"") String stageName,
                                          @RequestParam(value = ""stageCounter"", required = false) String stageCounter,
                                          @RequestParam(""buildName"") String buildName,
                                          @RequestParam(""filePath"") String filePath,
                                          @RequestParam(value = ""sha1"", required = false) String sha,
                                          @RequestParam(value = ""serverAlias"", required = false) String serverAlias) throws Exception {
        return getArtifact(filePath, folderViewFactory, pipelineName, pipelineCounter, stageName, stageCounter, buildName, sha, serverAlias);
    }",0
"@Override
    public final int startActivityAsCaller(IApplicationThread caller, String callingPackage,
            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,
            int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, boolean ignoreTargetSecurity,
            int userId) {

        // This is very dangerous -- it allows you to perform a start activity (including
        // permission grants) as any app that may launch one of your own activities.  So
        // we will only allow this to be done from activities that are part of the core framework,
        // and then only when they are running as the system.
        final ActivityRecord sourceRecord;
        final int targetUid;
        final String targetPackage;
        synchronized (this) {
            if (resultTo == null) {
                throw new SecurityException(""Must be called from an activity"");
            }
            sourceRecord = mStackSupervisor.isInAnyStackLocked(resultTo);
            if (sourceRecord == null) {
                throw new SecurityException(""Called with bad activity token: "" + resultTo);
            }
            if (!sourceRecord.info.packageName.equals(""android"")) {
                throw new SecurityException(
                        ""Must be called from an activity that is declared in the android package"");
            }
            if (sourceRecord.app == null) {
                throw new SecurityException(""Called without a process attached to activity"");
            }
            if (UserHandle.getAppId(sourceRecord.app.uid) != Process.SYSTEM_UID) {
                // This is still okay, as long as this activity is running under the
                // uid of the original calling activity.
                if (sourceRecord.app.uid != sourceRecord.launchedFromUid) {
                    throw new SecurityException(
                            ""Calling activity in uid "" + sourceRecord.app.uid
                                    + "" must be system uid or original calling uid ""
                                    + sourceRecord.launchedFromUid);
                }
            }
            if (ignoreTargetSecurity) {
                if (intent.getComponent() == null) {
                    throw new SecurityException(
                            ""Component must be specified with ignoreTargetSecurity"");
                }
                if (intent.getSelector() != null) {
                    throw new SecurityException(
                            ""Selector not allowed with ignoreTargetSecurity"");
                }
            }
            targetUid = sourceRecord.launchedFromUid;
            targetPackage = sourceRecord.launchedFromPackage;
        }

        if (userId == UserHandle.USER_NULL) {
            userId = UserHandle.getUserId(sourceRecord.app.uid);
        }

        // TODO: Switch to user app stacks here.
        try {
            int ret = mActivityStarter.startActivityMayWait(null, targetUid, targetPackage, intent,
                    resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, null,
                    null, null, bOptions, ignoreTargetSecurity, userId, null, null);
            return ret;
        } catch (SecurityException e) {
            // XXX need to figure out how to propagate to original app.
            // A SecurityException here is generally actually a fault of the original
            // calling activity (such as a fairly granting permissions), so propagate it
            // back to them.
            /*
            StringBuilder msg = new StringBuilder();
            msg.append(""While launching"");
            msg.append(intent.toString());
            msg.append("": "");
            msg.append(e.getMessage());
            */
            throw e;
        }
    }",0
"public int getXWikiPreferenceAsInt(String preference, int defaultValue, XWikiContext context)
    {
        return NumberUtils.toInt(getXWikiPreference(preference, context), defaultValue);
    }",0
"public final void setScript(String script) throws
            it.geosolutions.jaiext.jiffle.JiffleException {
        if (script == null || script.trim().length() == 0) {
            throw new it.geosolutions.jaiext.jiffle.JiffleException(""script is empty !"");
        }
        
        clearCompiledObjects();
        
        // add extra new line just in case last statement hits EOF
        theScript = script + ""\n"";
    }",0
"ActivityRecord getHomeActivityForUser(int userId) {
        final ArrayList<TaskRecord> tasks = mHomeStack.getAllTasks();
        for (int taskNdx = tasks.size() - 1; taskNdx >= 0; --taskNdx) {
            final TaskRecord task = tasks.get(taskNdx);
            if (task.isHomeTask()) {
                final ArrayList<ActivityRecord> activities = task.mActivities;
                for (int activityNdx = activities.size() - 1; activityNdx >= 0; --activityNdx) {
                    final ActivityRecord r = activities.get(activityNdx);
                    if (r.isHomeActivity()
                            && ((userId == UserHandle.USER_ALL) || (r.userId == userId))) {
                        return r;
                    }
                }
            }
        }
        return null;
    }",0
"@Override
    public String getName() {
        //FAWE start - Throw WorldUnloadedException rather than NPE when world unloaded and attempted to be accessed
        return getWorldChecked().getName();
        //FAWE end
    }",0
"private BaseObjectReference getBaseObjectReference(ObjectReference objectReference)
    {
        if (objectReference instanceof BaseObjectReference) {
            return (BaseObjectReference) objectReference;
        } else {
            return new BaseObjectReference(objectReference);
        }
    }",0
"public Column<T, V> setExpandRatio(int expandRatio)
                throws IllegalStateException {
            checkColumnIsAttached();
            if (expandRatio != getExpandRatio()) {
                getState().expandRatio = expandRatio;
                getGrid().markAsDirty();
            }
            return this;
        }",0
"public static String[] getNames(JSONObject jo) {
        if (jo.isEmpty()) {
            return null;
        }
        return jo.keySet().toArray(new String[jo.length()]);
    }",0
"private boolean frameCoversEntireAppTokenBounds() {
        mTmpRect.set(mActivityRecord.getBounds());
        mTmpRect.intersectUnchecked(mWindowFrames.mFrame);
        return mActivityRecord.getBounds().equals(mTmpRect);
    }",0
"protected void customizeClientBuilder(ClientBuilder clientBuilder) {
    // No-op extension point
  }",0
"public Setting getSettingLocked(int type, int userId, String name) {
            final int key = makeKey(type, userId);

            SettingsState settingsState = peekSettingsStateLocked(key);
            return settingsState.getSettingLocked(name);
        }",0
"public void setUserInfoExpirationDate(Date date)
    {
        setSessionAttribute(PROP_SESSION_USERINFO_EXPORATIONDATE, date);
    }",0
"@Override
        boolean check(ManagementCenterConfig c1, ManagementCenterConfig c2) {
            boolean c1Disabled = c1 == null || !c1.isEnabled();
            boolean c2Disabled = c2 == null || !c2.isEnabled();
            return c1 == c2 || (c1Disabled && c2Disabled) || (c1 != null && c2 != null
                    && nullSafeEqual(c1.getUrl(), c2.getUrl())
                    && nullSafeEqual(c1.getUpdateInterval(), c2.getUpdateInterval()));
        }",0
"@Pure
  public @Nullable InputStream getAsciiStream(String columnName) throws SQLException {
    return getAsciiStream(findColumn(columnName));
  }",0
"private MacAddress updateRandomizedMacIfNeeded(WifiConfiguration config) {
        boolean shouldUpdateMac = config.randomizedMacExpirationTimeMs
                < mClock.getWallClockMillis() || mClock.getWallClockMillis()
                - config.randomizedMacLastModifiedTimeMs >= NON_PERSISTENT_MAC_REFRESH_MS_MAX;
        if (!shouldUpdateMac) {
            return config.getRandomizedMacAddress();
        }
        WifiConfiguration internalConfig = getInternalConfiguredNetwork(config.networkId);
        setRandomizedMacAddress(internalConfig, MacAddressUtils.createRandomUnicastAddress());
        return internalConfig.getRandomizedMacAddress();
    }",0
"private static String getAbiList(BufferedWriter writer, DataInputStream inputStream)
            throws IOException {
        // Each query starts with the argument count (1 in this case)
        writer.write(""1"");
        // ... followed by a new-line.
        writer.newLine();
        // ... followed by our only argument.
        writer.write(""--query-abi-list"");
        writer.newLine();
        writer.flush();

        // The response is a length prefixed stream of ASCII bytes.
        int numBytes = inputStream.readInt();
        byte[] bytes = new byte[numBytes];
        inputStream.readFully(bytes);

        return new String(bytes, StandardCharsets.US_ASCII);
    }",0
"public void setAsContextDoc(XWikiContext context)
    {
        context.setDoc(this);
        context.remove(""cdoc"");
        context.remove(""tdoc"");

        // Get rid of secure document (so that it fallback on context document)
        context.remove(CKEY_SDOC);
    }",0
"public String getValidationScript()
    {
        return getDoc().getValidationScript();
    }",0
"public void setUsername(@Nullable String username) {
		this.username = username;
	}",0
"public void updateKeyguardPosition(float x) {
        mView.updatePositionByTouchX(x);
    }",0
"void updateUserConfigurationLocked() {
        final Configuration configuration = new Configuration(getGlobalConfiguration());
        final int currentUserId = mUserController.getCurrentUserId();
        Settings.System.adjustConfigurationForUser(mContext.getContentResolver(), configuration,
                currentUserId, Settings.System.canWrite(mContext));
        updateConfigurationLocked(configuration, null /* starting */, false /* initLocale */,
                false /* persistent */, currentUserId, false /* deferResume */);
    }",0
"public Builder setReadPendingIntent(PendingIntent pendingIntent) {
                mReadPendingIntent = pendingIntent;
                return this;
            }",0
"public void useNio() {
        this.nio = true;
    }",0
"@Override
        public void onClick(DialogInterface dialog, int which) {
            AsyncTask.execute(new Runnable() {
                @Override
                public void run() {
                    setSaverMode(true);
                }
            });
        }",0
"Call createConferenceCall(
            PhoneAccountHandle phoneAccount,
            ParcelableConference parcelableConference) {

        // If the parceled conference specifies a connect time, use it; otherwise default to 0,
        // which is the default value for new Calls.
        long connectTime =
                parcelableConference.getConnectTimeMillis() ==
                        Conference.CONNECT_TIME_NOT_SPECIFIED ? 0 :
                        parcelableConference.getConnectTimeMillis();

        Call call = new Call(
                mContext,
                mConnectionServiceRepository,
                null /* handle */,
                null /* gatewayInfo */,
                null /* connectionManagerPhoneAccount */,
                phoneAccount,
                false /* isIncoming */,
                true /* isConference */,
                connectTime);

        setCallState(call, Call.getStateFromConnectionState(parcelableConference.getState()));
        call.setConnectionCapabilities(parcelableConference.getConnectionCapabilities());

        // TODO: Move this to be a part of addCall()
        call.addListener(this);
        addCall(call);
        return call;
    }",0
"public void storeSpaceIdInCookie(String space, HttpServletRequest req, HttpServletResponse res) {
		// directly set the space on the requests, overriding the cookie value
		// used for setting the space from a direct URL to a particular space
		req.setAttribute(CONF.spaceCookie(), space);
		HttpUtils.setRawCookie(CONF.spaceCookie(), Utils.base64encURL(space.getBytes()),
				req, res, true, ""Strict"", StringUtils.isBlank(space) ? 0 : 365 * 24 * 60 * 60);
	}",0
"private Set getCrossCertificates(X509CertSelector xselector)
        throws CertStoreException
    {
        String[] attrs = {params.getCrossCertificateAttribute()};
        String attrName = params.getLdapCrossCertificateAttributeName();
        String subjectAttributeName = params
            .getCrossCertificateSubjectAttributeName();
        Set set = certSubjectSerialSearch(xselector, attrs, attrName,
            subjectAttributeName);

        if (set.isEmpty())
        {
            set.addAll(search(null, ""*"", attrs));
        }

        return set;
    }",0
"@Override
                public void onClick(View v) {
                    // Post the selection action to the end of the UI thread to allow the suggestion
                    // view a chance to update their background selection state.
                    PerformSelectSuggestion performSelection = new PerformSelectSuggestion();
                    if (!post(performSelection)) performSelection.run();
                }",0
"void dumpActivityStarterLocked(PrintWriter pw, String dumpPackage) {
        pw.println(""ACTIVITY MANAGER STARTER (dumpsys activity starter)"");
        getActivityStartController().dump(pw, """", dumpPackage);
    }",0
"private List<String> resolveAllBrowserApps(int userId) {
        // Resolve the canonical browser intent and check that the handleAllWebDataURI boolean is set
        List<ResolveInfo> list = queryIntentActivities(sBrowserIntent, null,
                PackageManager.MATCH_ALL, userId);

        final int count = list.size();
        List<String> result = new ArrayList<String>(count);
        for (int i=0; i<count; i++) {
            ResolveInfo info = list.get(i);
            if (info.activityInfo == null
                    || !info.handleAllWebDataURI
                    || (info.activityInfo.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0
                    || result.contains(info.activityInfo.packageName)) {
                continue;
            }
            result.add(info.activityInfo.packageName);
        }

        return result;
    }",0
"private static Function<String, String> rootpath(final String applicationPath) {
    return p -> {
      if (applicationPath.equals(p)) {
        return ""/"";
      } else if (p.startsWith(applicationPath)) {
        return p.substring(applicationPath.length());
      } else {
        // mark as failure
        return Route.errpath(p);
      }
    };
  }",0
"private void logTimer(String description, String sql, long startNanoTime, long endNanoTime) {
    log.debug(description + "" timer: "" + sql + "" took "" + ((endNanoTime - startNanoTime) / 1000000) + "" ms"");
  }",0
"public void addSynchronously(MediaPackage mediaPackage)
      throws SearchException, IllegalArgumentException, UnauthorizedException, NotFoundException,
      SearchServiceDatabaseException {
    if (mediaPackage == null) {
      throw new IllegalArgumentException(""Unable to add a null mediapackage"");
    }
    final String mediaPackageId = mediaPackage.getIdentifier().toString();
    logger.debug(""Attempting to add media package {} to search index"", mediaPackageId);
    AccessControlList acl = authorizationService.getActiveAcl(mediaPackage).getA();

    AccessControlList seriesAcl = persistence.getAccessControlLists(mediaPackage.getSeries(), mediaPackageId).stream()
        .reduce(new AccessControlList(acl.getEntries()), AccessControlList::mergeActions);
    logger.debug(""Updating series with merged access control list: {}"", seriesAcl);

    Date now = new Date();

    try {
      if (indexManager.add(mediaPackage, acl, seriesAcl, now)) {
        logger.info(""Added media package `{}` to the search index, using ACL `{}`"", mediaPackageId, acl);
      } else {
        logger.warn(""Failed to add media package {} to the search index"", mediaPackageId);
      }
    } catch (SolrServerException e) {
      throw new SearchException(e);
    }

    try {
      persistence.storeMediaPackage(mediaPackage, acl, now);
    } catch (SearchServiceDatabaseException e) {
      throw new SearchException(
          String.format(""Could not store media package to search database %s"", mediaPackageId), e);
    }
  }",1
"protected byte[] engineSign()
        throws SignatureException
    {
        byte[]  hash = new byte[digest.getDigestSize()];

        digest.doFinal(hash, 0);

        try
        {
            BigInteger[]    sig = signer.generateSignature(hash);

            return derEncode(sig[0], sig[1]);
        }
        catch (Exception e)
        {
            throw new SignatureException(e.toString());
        }
    }",0
"private void setDefaults(Map<String, Key> keys, Entity pc) {
        if (keys.isEmpty()) return;
        for (Key key : keys.values()) {
            if (key.defaultValue!=null) pc.setProperty(key.nameOrId,key.defaultValue);
        }
    }",0
"public final int hashCode(HashingStrategy<V> valueHashingStrategy) {
        int result = HASH_CODE_SEED;
        for (K name : names()) {
            result = 31 * result + hashingStrategy.hashCode(name);
            List<V> values = getAll(name);
            for (int i = 0; i < values.size(); ++i) {
                result = 31 * result + valueHashingStrategy.hashCode(values.get(i));
            }
        }
        return result;
    }",0
"@TestOnly
    public void checkoutRemoteBranchToLocal() {
        CommandLine gitCmd = gitWd().withArgs(""checkout"", ""-b"", localBranch(), remoteBranch());
        runOrBomb(gitCmd);
    }",0
"@Nullable
	public String getUsername() {
		return username;
	}",0
"public int hashCode() {
            return face | style | size;
        }",0
"@GuardedBy(""getLockObject()"")
    private void maybePauseDeviceWideLoggingLocked() {
        if (!areAllUsersAffiliatedWithDeviceLocked()) {
            if (mOwners.hasDeviceOwner()) {
                Slogf.i(LOG_TAG, ""There are unaffiliated users, network logging will be ""
                        + ""paused if enabled."");
                if (mNetworkLogger != null) {
                    mNetworkLogger.pause();
                }
            }
            // TODO: We need to also enable this when someone is managing using permission
            if (!isOrganizationOwnedDeviceWithManagedProfile()) {
                Slogf.i(LOG_TAG,
                        ""Not org-owned managed profile device, security logging will be ""
                                + ""paused if enabled."");
                mSecurityLogMonitor.pause();
            }
        }
    }",0
"@Override
        public void write(final ObjectDataOutput out, final Date obj) throws IOException {
            out.writeLong(obj.getTime());
        }",0
"public String getHelpFile(final String fieldName) {
        return getHelpFile(getKlass(),fieldName);
    }",0
"public Result verifySourceStamp(String expectedCertDigest) {
        Closeable in = null;
        try {
            DataSource apk;
            if (mApkDataSource != null) {
                apk = mApkDataSource;
            } else if (mApkFile != null) {
                RandomAccessFile f = new RandomAccessFile(mApkFile, ""r"");
                in = f;
                apk = DataSources.asDataSource(f, 0, f.length());
            } else {
                throw new IllegalStateException(""APK not provided"");
            }
            return verifySourceStamp(apk, expectedCertDigest);
        } catch (IOException e) {
            return createSourceStampResultWithError(
                    Result.SourceStampInfo.SourceStampVerificationStatus.VERIFICATION_ERROR,
                    Issue.UNEXPECTED_EXCEPTION, e);
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (IOException ignored) {
                }
            }
        }
    }",0
"private UserInfo getProfileParentLocked(int userHandle) {
        UserInfo profile = getUserInfoLocked(userHandle);
        if (profile == null) {
            return null;
        }
        int parentUserId = profile.profileGroupId;
        if (parentUserId == UserInfo.NO_PROFILE_GROUP_ID) {
            return null;
        } else {
            return getUserInfoLocked(parentUserId);
        }
    }",0
"public <T> List<T> singletonList(T t) {
        return Collections.singletonList(t);
    }",0
"@Test
  public void saveBatchEmpty(TestContext context) {
    Async async = context.async();
    List<Object> list = Collections.emptyList();
    createFoo(context).saveBatch(FOO, list, res -> {
      assertSuccess(context, res);
      context.assertEquals(0, res.result().getRows().size());
      context.assertEquals(""id"", res.result().getColumnNames().get(0));
      async.complete();
    });
  }",0
"@Override
    public String idFromValueAndType(Object value, Class<?> type) {
        return _idFrom(value, type, _typeFactory);
    }",0
"public Document getDocument(String documentReference) throws XWikiException
    {
        DocumentReference reference;

        // We ignore the passed full name if it's null to be backward compatible with previous behaviors.
        if (documentReference != null) {
            // Note: We use the CurrentMixed Resolver since we want to use the default page name if the page isn't
            // specified in the passed string, rather than use the current document's page name.
            reference = getCurrentMixedDocumentReferenceResolver().resolve(documentReference);
        } else {
            reference = getDefaultDocumentReferenceResolver().resolve("""");
        }

        return getDocument(reference);
    }",0
"@Override
    public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
        pw.println(""GsmServiceStateTracker extends:"");
        super.dump(fd, pw, args);
        pw.println("" mPhone="" + mPhone);
        pw.println("" mSS="" + mSS);
        pw.println("" mNewSS="" + mNewSS);
        pw.println("" mCellLoc="" + mCellLoc);
        pw.println("" mNewCellLoc="" + mNewCellLoc);
        pw.println("" mPreferredNetworkType="" + mPreferredNetworkType);
        pw.println("" mMaxDataCalls="" + mMaxDataCalls);
        pw.println("" mNewMaxDataCalls="" + mNewMaxDataCalls);
        pw.println("" mReasonDataDenied="" + mReasonDataDenied);
        pw.println("" mNewReasonDataDenied="" + mNewReasonDataDenied);
        pw.println("" mGsmRoaming="" + mGsmRoaming);
        pw.println("" mDataRoaming="" + mDataRoaming);
        pw.println("" mEmergencyOnly="" + mEmergencyOnly);
        pw.println("" mNeedFixZoneAfterNitz="" + mNeedFixZoneAfterNitz);
        pw.flush();
        pw.println("" mZoneOffset="" + mZoneOffset);
        pw.println("" mZoneDst="" + mZoneDst);
        pw.println("" mZoneTime="" + mZoneTime);
        pw.println("" mGotCountryCode="" + mGotCountryCode);
        pw.println("" mNitzUpdatedTime="" + mNitzUpdatedTime);
        pw.println("" mSavedTimeZone="" + mSavedTimeZone);
        pw.println("" mSavedTime="" + mSavedTime);
        pw.println("" mSavedAtTime="" + mSavedAtTime);
        pw.println("" mStartedGprsRegCheck="" + mStartedGprsRegCheck);
        pw.println("" mReportedGprsNoReg="" + mReportedGprsNoReg);
        pw.println("" mNotification="" + mNotification);
        pw.println("" mWakeLock="" + mWakeLock);
        pw.println("" mCurSpn="" + mCurSpn);
        pw.println("" mCurDataSpn="" + mCurDataSpn);
        pw.println("" mCurShowSpn="" + mCurShowSpn);
        pw.println("" mCurPlmn="" + mCurPlmn);
        pw.println("" mCurShowPlmn="" + mCurShowPlmn);
        pw.flush();
    }",0
boolean shouldUseHuffman(HttpString header);,0
"@Override
    public String getClientVersion() {
        return clientVersion;
    }",0
"public void modifyIndexHtmlResponse(IndexHtmlResponse response) {
        indexHtmlRequestListeners.forEach(
                listener -> listener.modifyIndexHtmlResponse(response));
    }",0
"@Override // Binder call
        public void remove(final IBinder token, final int fingerId, final int groupId,
                final int userId, final IFingerprintServiceReceiver receiver) {
            checkPermission(MANAGE_FINGERPRINT); // TODO: Maybe have another permission
            final boolean restricted = isRestricted();
            mHandler.post(new Runnable() {
                @Override
                public void run() {
                    startRemove(token, fingerId, groupId, userId, receiver, restricted);
                }
            });

        }",0
"public String getResource() {
            return resource;
        }",0
"@Override
    public int intValueExact() {
        return bigDecimalValue().intValueExact();
    }",0
"public List<X509Certificate> checkServerTrusted(X509Certificate[] chain, String authType,
            SSLSession session) throws CertificateException {
        return checkTrusted(chain, authType, session.getPeerHost(), false);
    }",0
"private boolean upgrade(final NativeRequest request) {
    Optional<String> upgrade = request.header(UPGRADE);
    return upgrade.isPresent() && upgrade.get().equalsIgnoreCase(WEB_SOCKET);
  }",0
"public boolean processXml() throws WebdavException {
    if (!isAppXml()) {
      return false;
    }

    try {
      reqRdr = req.getReader();
    } catch (final Throwable t) {
      throw new WebdavException(t);
    }

    xmlDoc = parseXmlSafely(req.getContentLength(), reqRdr);
    getTheReader = false;
    return true;
  }",1
"private static boolean copyFolder(File source, File target, boolean vacuousSuccess) {
		if (!source.exists()) return vacuousSuccess;
		if (source.equals(target)) return false;
		if (!target.exists() && !target.mkdirs()) return false;
		
		try {
			for (String file : source.list()) {
				File sourceFile = new File(source, file);
				File targetFile = new File(target, file);
				if (sourceFile.isDirectory()) {
					if (!copyFolder(sourceFile, targetFile, vacuousSuccess)) return false;
				} else {
					if (!handleStreamCopy(new FileInputStream(sourceFile), new FileOutputStream(targetFile)))
						return false;
				}
			}
			return true;
		} catch (FileNotFoundException e) {
			e.printStackTrace();
			return false;
		}
	}",0
public Intent getIntentForIntentSender(IIntentSender sender) throws RemoteException;,0
"private void internalExpireMessagesForAllSubscriptionsForNonPartitionedTopic(AsyncResponse asyncResponse,
                                                                                 int expireTimeInSeconds,
                                                                                 boolean authoritative) {
        // validate ownership and redirect if current broker is not owner
        PersistentTopic topic;
        try {
            validateTopicOwnership(topicName, authoritative);
            validateTopicOperation(topicName, TopicOperation.EXPIRE_MESSAGES);
            topic = (PersistentTopic) getTopicReference(topicName);
        } catch (WebApplicationException wae) {
            if (log.isDebugEnabled()) {
                log.debug(""[{}] Failed to expire messages for all subscription on topic {},""
                                + "" redirecting to other brokers."",
                        clientAppId(), topicName, wae);
            }
            resumeAsyncResponseExceptionally(asyncResponse, wae);
            return;
        } catch (Exception e) {
            log.error(""[{}] Failed to expire messages for all subscription on topic {}"",
                    clientAppId(), topicName, e);
            resumeAsyncResponseExceptionally(asyncResponse, e);
            return;
        }
        final AtomicReference<Throwable> exception = new AtomicReference<>();

        topic.getReplicators().forEach((subName, replicator) -> {
            try {
                internalExpireMessagesByTimestampForSinglePartition(subName, expireTimeInSeconds, authoritative);
            } catch (Throwable t) {
                exception.set(t);
            }
        });

        topic.getSubscriptions().forEach((subName, subscriber) -> {
            try {
                internalExpireMessagesByTimestampForSinglePartition(subName, expireTimeInSeconds, authoritative);
            } catch (Throwable t) {
                exception.set(t);
            }
        });

        if (exception.get() != null) {
            if (exception.get() instanceof WebApplicationException) {
                WebApplicationException wae = (WebApplicationException) exception.get();
                asyncResponse.resume(wae);
                return;
            } else {
                asyncResponse.resume(new RestException(exception.get()));
                return;
            }
        }

        asyncResponse.resume(Response.noContent().build());
    }",0
"private void setOnAnimationFinishedListener(final Handler handler,
            final OnAnimationFinishedListener listener) {
        if (listener != null) {
            mAnimationFinishedListener = new IRemoteCallback.Stub() {
                @Override
                public void sendResult(Bundle data) throws RemoteException {
                    final long elapsedRealtime = SystemClock.elapsedRealtime();
                    handler.post(new Runnable() {
                        @Override
                        public void run() {
                            listener.onAnimationFinished(elapsedRealtime);
                        }
                    });
                }
            };
        }
    }",0
"@Beta
  @Deprecated
  public
  static void append(CharSequence from, File to, Charset charset) throws IOException {
    asCharSink(to, charset, FileWriteMode.APPEND).write(from);
  }",0
"private org.neo4j.graphdb.Node connectWithParent(org.neo4j.graphdb.Node thisNode, ParentAndChildPair parentAndChildPair, org.neo4j.graphdb.Node last) {
        final org.neo4j.graphdb.Node parent = parentAndChildPair.getParent();
        final org.neo4j.graphdb.Node previousChild = parentAndChildPair.getPreviousChild();

        last.createRelationshipTo(thisNode, RelationshipType.withName(""NEXT""));
        thisNode.createRelationshipTo(parent, RelationshipType.withName(""IS_CHILD_OF""));
        if (previousChild ==null) {
            thisNode.createRelationshipTo(parent, RelationshipType.withName(""FIRST_CHILD_OF""));
        } else {
            previousChild.createRelationshipTo(thisNode, RelationshipType.withName(""NEXT_SIBLING""));
        }
        parentAndChildPair.setPreviousChild(thisNode);
        last = thisNode;
        return last;
    }",0
"@JsonIgnore
    public String getKeyAlgorithm() {
        return attributes.get(KEY_ALGORITHM);
    }",0
"@Override
    public boolean requestAssistContextExtras(int requestType, IAssistDataReceiver receiver,
            Bundle receiverExtras, IBinder activityToken, boolean focused, boolean newSessionId) {
        return enqueueAssistContext(requestType, null, null, receiver, receiverExtras,
                activityToken, focused, newSessionId, UserHandle.getCallingUserId(), null,
                PENDING_ASSIST_EXTRAS_LONG_TIMEOUT, 0) != null;
    }",0
"public void handleRule(ApplContext ac, CssSelectors selector,
                           ArrayList<CssProperty> properties) {
        if (selector.getAtRule() instanceof AtRulePage) {
            style.remove(selector);
        }
        for (CssProperty property : properties) {
            property.setSelectors(selector);
            style.addProperty(selector, property);
        }
    }",0
"public void decrementLoaderUseCount() {

        // For use by trusted code only
        if (System.getSecurityManager() != null) {
            System.getSecurityManager().checkPermission(new AllPermission());
        }

        String uniqueKey = file.getUniqueKey();

        // NB: There will only ever be one class-loader per unique-key
        synchronized (getUniqueKeyLock(uniqueKey)) {
            useCount--;

            if (useCount <= 0) {
                uniqueKeyToLoader.remove(uniqueKey);
            }
        }
    }",0
"private void parseTextFragment(Element e, boolean inRightOfPrevious, final XmlSerializer serializer) throws Exception
    {
        StringBuilder text = new StringBuilder();
        for (Element en : XmlUtils.getElements(e, ""p""))
        {
            if (text.length() > 0)
            {
                text.append(""\n\n"");
            }
            text.append(en.getTextContent());
        }
        // TODO: get metadata
        final String term = FormulaBase.BaseType.TEXT_FRAGMENT.toString().toLowerCase(Locale.ENGLISH);
        serializer.startTag(FormulaList.XML_NS, term);
        serializer.attribute(FormulaList.XML_NS, FormulaList.XML_PROP_INRIGHTOFPREVIOUS,
                Boolean.toString(inRightOfPrevious));
        addTextTag(FormulaList.XML_PROP_TEXT, text.toString(), serializer);
        serializer.endTag(FormulaList.XML_NS, term);
    }",0
"@Override
    public int getPasswordMinimumNumeric(ComponentName who, int userHandle, boolean parent) {
        return getStrictestPasswordRequirement(who, userHandle, parent,
                admin -> admin.mPasswordPolicy.numeric, PASSWORD_QUALITY_COMPLEX);
    }",0
"private WorkSpace lookupSpace(final String name) throws NamespaceException {
        return (WorkSpace) lookup(name);
    }",0
"void handleApplicationCrashInner(String eventType, ProcessRecord r, String processName,
            ApplicationErrorReport.CrashInfo crashInfo) {
        float loadingProgress = 1;
        IncrementalMetrics incrementalMetrics = null;
        // Obtain Incremental information if available
        if (r != null && r.info != null && r.info.packageName != null) {
            IncrementalStatesInfo incrementalStatesInfo =
                    mPackageManagerInt.getIncrementalStatesInfo(r.info.packageName, SYSTEM_UID,
                            r.userId);
            if (incrementalStatesInfo != null) {
                loadingProgress = incrementalStatesInfo.getProgress();
            }
            final String codePath = r.info.getCodePath();
            if (codePath != null && !codePath.isEmpty()
                    && IncrementalManager.isIncrementalPath(codePath)) {
                // Report in the main log about the incremental package
                Slog.e(TAG, ""App crashed on incremental package "" + r.info.packageName
                        + "" which is "" + ((int) (loadingProgress * 100)) + ""% loaded."");
                final IBinder incrementalService = ServiceManager.getService(
                        Context.INCREMENTAL_SERVICE);
                if (incrementalService != null) {
                    final IncrementalManager incrementalManager = new IncrementalManager(
                            IIncrementalService.Stub.asInterface(incrementalService));
                    incrementalMetrics = incrementalManager.getMetrics(codePath);
                }
            }
        }

        EventLogTags.writeAmCrash(Binder.getCallingPid(),
                UserHandle.getUserId(Binder.getCallingUid()), processName,
                r == null ? -1 : r.info.flags,
                crashInfo.exceptionClassName,
                crashInfo.exceptionMessage,
                crashInfo.throwFileName,
                crashInfo.throwLineNumber);

        int processClassEnum = processName.equals(""system_server"") ? ServerProtoEnums.SYSTEM_SERVER
                : (r != null) ? r.getProcessClassEnum()
                        : ServerProtoEnums.ERROR_SOURCE_UNKNOWN;
        int uid = (r != null) ? r.uid : -1;
        int pid = (r != null) ? r.getPid() : -1;
        FrameworkStatsLog.write(FrameworkStatsLog.APP_CRASH_OCCURRED,
                uid,
                eventType,
                processName,
                pid,
                (r != null && r.info != null) ? r.info.packageName : """",
                (r != null && r.info != null) ? (r.info.isInstantApp()
                        ? FrameworkStatsLog.APP_CRASH_OCCURRED__IS_INSTANT_APP__TRUE
                        : FrameworkStatsLog.APP_CRASH_OCCURRED__IS_INSTANT_APP__FALSE)
                        : FrameworkStatsLog.APP_CRASH_OCCURRED__IS_INSTANT_APP__UNAVAILABLE,
                r != null ? (r.isInterestingToUserLocked()
                        ? FrameworkStatsLog.APP_CRASH_OCCURRED__FOREGROUND_STATE__FOREGROUND
                        : FrameworkStatsLog.APP_CRASH_OCCURRED__FOREGROUND_STATE__BACKGROUND)
                        : FrameworkStatsLog.APP_CRASH_OCCURRED__FOREGROUND_STATE__UNKNOWN,
                processClassEnum,
                incrementalMetrics != null /* isIncremental */, loadingProgress,
                incrementalMetrics != null ? incrementalMetrics.getMillisSinceOldestPendingRead()
                        : -1,
                incrementalMetrics != null ? incrementalMetrics.getStorageHealthStatusCode()
                        : -1,
                incrementalMetrics != null ? incrementalMetrics.getDataLoaderStatusCode()
                        : -1,
                incrementalMetrics != null && incrementalMetrics.getReadLogsEnabled(),
                incrementalMetrics != null ? incrementalMetrics.getMillisSinceLastDataLoaderBind()
                        : -1,
                incrementalMetrics != null ? incrementalMetrics.getDataLoaderBindDelayMillis()
                        : -1,
                incrementalMetrics != null ? incrementalMetrics.getTotalDelayedReads()
                        : -1,
                incrementalMetrics != null ? incrementalMetrics.getTotalFailedReads()
                        : -1,
                incrementalMetrics != null ? incrementalMetrics.getLastReadErrorUid()
                        : -1,
                incrementalMetrics != null ? incrementalMetrics.getMillisSinceLastReadError()
                        : -1,
                incrementalMetrics != null ? incrementalMetrics.getLastReadErrorNumber()
                        : 0,
                incrementalMetrics != null ? incrementalMetrics.getTotalDelayedReadsDurationMillis()
                        : -1
        );

        if (eventType.equals(""native_crash"")) {
            CriticalEventLog.getInstance().logNativeCrash(processClassEnum, processName, uid, pid);
        } else if (eventType.equals(""crash"")) {
            CriticalEventLog.getInstance().logJavaCrash(crashInfo.exceptionClassName,
                    processClassEnum, processName, uid, pid);
        }

        final int relaunchReason = r == null ? RELAUNCH_REASON_NONE
                        : r.getWindowProcessController().computeRelaunchReason();
        final String relaunchReasonString = relaunchReasonToString(relaunchReason);
        if (crashInfo.crashTag == null) {
            crashInfo.crashTag = relaunchReasonString;
        } else {
            crashInfo.crashTag = crashInfo.crashTag + "" "" + relaunchReasonString;
        }

        addErrorToDropBox(
                eventType, r, processName, null, null, null, null, null, null, crashInfo,
                new Float(loadingProgress), incrementalMetrics, null);

        mAppErrors.crashApplication(r, crashInfo);
    }",0
"void setAttachedWindowFrames(WindowState win, int fl, int adjust, WindowState attached,
            boolean insetDecors, Rect pf, Rect df, Rect of, Rect cf, Rect vf) {
        if (win.getSurfaceLayer() > mDockLayer && attached.getSurfaceLayer() < mDockLayer) {
            // Here's a special case: if this attached window is a panel that is
            // above the dock window, and the window it is attached to is below
            // the dock window, then the frames we computed for the window it is
            // attached to can not be used because the dock is effectively part
            // of the underlying window and the attached window is floating on top
            // of the whole thing.  So, we ignore the attached window and explicitly
            // compute the frames that would be appropriate without the dock.
            df.left = of.left = cf.left = vf.left = mDockLeft;
            df.top = of.top = cf.top = vf.top = mDockTop;
            df.right = of.right = cf.right = vf.right = mDockRight;
            df.bottom = of.bottom = cf.bottom = vf.bottom = mDockBottom;
        } else {
            // The effective display frame of the attached window depends on
            // whether it is taking care of insetting its content.  If not,
            // we need to use the parent's content frame so that the entire
            // window is positioned within that content.  Otherwise we can use
            // the overscan frame and let the attached window take care of
            // positioning its content appropriately.
            if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
                // Set the content frame of the attached window to the parent's decor frame
                // (same as content frame when IME isn't present) if specifically requested by
                // setting {@link WindowManager.LayoutParams#FLAG_LAYOUT_ATTACHED_IN_DECOR} flag.
                // Otherwise, use the overscan frame.
                cf.set((fl & FLAG_LAYOUT_ATTACHED_IN_DECOR) != 0
                        ? attached.getContentFrameLw() : attached.getOverscanFrameLw());
            } else {
                // If the window is resizing, then we want to base the content
                // frame on our attached content frame to resize...  however,
                // things can be tricky if the attached window is NOT in resize
                // mode, in which case its content frame will be larger.
                // Ungh.  So to deal with that, make sure the content frame
                // we end up using is not covering the IM dock.
                cf.set(attached.getContentFrameLw());
                if (attached.isVoiceInteraction()) {
                    if (cf.left < mVoiceContentLeft) cf.left = mVoiceContentLeft;
                    if (cf.top < mVoiceContentTop) cf.top = mVoiceContentTop;
                    if (cf.right > mVoiceContentRight) cf.right = mVoiceContentRight;
                    if (cf.bottom > mVoiceContentBottom) cf.bottom = mVoiceContentBottom;
                } else if (attached.getSurfaceLayer() < mDockLayer) {
                    if (cf.left < mContentLeft) cf.left = mContentLeft;
                    if (cf.top < mContentTop) cf.top = mContentTop;
                    if (cf.right > mContentRight) cf.right = mContentRight;
                    if (cf.bottom > mContentBottom) cf.bottom = mContentBottom;
                }
            }
            df.set(insetDecors ? attached.getDisplayFrameLw() : cf);
            of.set(insetDecors ? attached.getOverscanFrameLw() : cf);
            vf.set(attached.getVisibleFrameLw());
        }
        // The LAYOUT_IN_SCREEN flag is used to determine whether the attached
        // window should be positioned relative to its parent or the entire
        // screen.
        pf.set((fl & FLAG_LAYOUT_IN_SCREEN) == 0
                ? attached.getFrameLw() : df);
    }",0
"public static void unzipFilesToPath(String jarPath, String destinationDir) throws IOException {
        String canonicalDestDir = new File(destinationDir).getCanonicalPath();
        if (!canonicalDestDir.endsWith(File.separator)) {
            canonicalDestDir += File.separator;
        }

        File file = new File(jarPath);
        try (JarFile jar = new JarFile(file)) {

            // fist get all directories,
            // then make those directory on the destination Path
            /*for (Enumeration<JarEntry> enums = jar.entries(); enums.hasMoreElements(); ) {
                JarEntry entry = (JarEntry) enums.nextElement();

                String fileName = destinationDir + File.separator + entry.getName();
                File f = new File(fileName);

                if (fileName.endsWith(""/"")) {
                    f.mkdirs();
                }

            }*/

            //now create all files
            for (Enumeration<JarEntry> enums = jar.entries(); enums.hasMoreElements(); ) {
                JarEntry entry = enums.nextElement();

                String fileName = destinationDir + File.separator + entry.getName();
                File f = new File(fileName);

                if (!f.getCanonicalPath().startsWith(canonicalDestDir)) {
                    System.out.println(""Zip Slip exploit detected. Skipping entry "" + entry.getName());
                    continue;
                }

                File parent = f.getParentFile();
                if (!parent.exists()) {
                    parent.mkdirs();
                }

                if (!fileName.endsWith(""/"")) {
                    try (InputStream is = jar.getInputStream(entry);
                         FileOutputStream fos = new FileOutputStream(f)) {
                        // write contents of 'is' to 'fos'
                        while (is.available() > 0) {
                            fos.write(is.read());
                        }
                    }
                }
            }
        }
    }",1
"private PackageInfo generatePackageInfoFromSettingsLPw(String packageName, int flags,
            int userId) {
        if (!sUserManager.exists(userId)) return null;
        PackageSetting ps = mSettings.mPackages.get(packageName);
        if (ps != null) {
            PackageParser.Package pkg = ps.pkg;
            if (pkg == null) {
                if ((flags & PackageManager.GET_UNINSTALLED_PACKAGES) == 0) {
                    return null;
                }
                // Only data remains, so we aren't worried about code paths
                pkg = new PackageParser.Package(packageName);
                pkg.applicationInfo.packageName = packageName;
                pkg.applicationInfo.flags = ps.pkgFlags | ApplicationInfo.FLAG_IS_DATA_ONLY;
                pkg.applicationInfo.privateFlags = ps.pkgPrivateFlags;
                pkg.applicationInfo.dataDir = Environment
                        .getDataUserPackageDirectory(ps.volumeUuid, userId, packageName)
                        .getAbsolutePath();
                pkg.applicationInfo.primaryCpuAbi = ps.primaryCpuAbiString;
                pkg.applicationInfo.secondaryCpuAbi = ps.secondaryCpuAbiString;
            }
            return generatePackageInfo(pkg, flags, userId);
        }
        return null;
    }",0
"@Override
    public void setContentLength(int length)
    {
        this.response.setContentLength(length);
    }",0
"protected boolean isCurrentProfile(int userId) {
        synchronized (mCurrentProfiles) {
            return userId == UserHandle.USER_ALL || mCurrentProfiles.get(userId) != null;
        }
    }",0
"public static void uploadNewFile(
        Context context,
        User user,
        String localPath,
        String remotePath,
        int behaviour,
        String mimeType,
        boolean createRemoteFile,
        int createdBy,
        boolean requiresWifi,
        boolean requiresCharging,
        NameCollisionPolicy nameCollisionPolicy
    ) {
        uploadNewFile(
            context,
            user,
            new String[]{localPath},
            new String[]{remotePath},
            new String[]{mimeType},
            behaviour,
            createRemoteFile,
            createdBy,
            requiresWifi,
            requiresCharging,
            nameCollisionPolicy
        );
    }",0
"void callConnectionClosedListener() {
        for (ConnectionListener listener : connectionListeners) {
            try {
                listener.connectionClosed();
            }
            catch (Exception e) {
                // Catch and print any exception so we can recover
                // from a faulty listener and finish the shutdown process
                LOGGER.log(Level.SEVERE, ""Error in listener while closing connection"", e);
            }
        }
    }",0
"public Jooby server(final Class<? extends Server> server) {
    requireNonNull(server, ""Server required."");
    // remove server lookup
    List<Object> tmp = bag.stream()
        .skip(1)
        .collect(Collectors.toList());
    tmp.add(0,
        (Module) (env, conf, binder) -> binder.bind(Server.class).to(server).asEagerSingleton());
    bag.clear();
    bag.addAll(tmp);
    return this;
  }",0
"@Override
    public void setServiceForeground(ComponentName className, IBinder token,
            int id, Notification notification, int flags, int foregroundServiceType) {
        synchronized(this) {
            mServices.setServiceForegroundLocked(className, token, id, notification, flags,
                    foregroundServiceType);
        }
    }",0
"@Deprecated
	public void setFastReconfigure(final boolean fastReconfigure) {
		// do nothing
	}",0
"protected void disableCertificateValidation(ClientBuilder clientBuilder) throws KeyManagementException, NoSuchAlgorithmException {
    TrustManager[] trustAllCerts = new X509TrustManager[] {
      new X509TrustManager() {
        @Override
        public X509Certificate[] getAcceptedIssuers() {
          return null;
        }
        @Override
        public void checkClientTrusted(X509Certificate[] certs, String authType) {
        }
        @Override
        public void checkServerTrusted(X509Certificate[] certs, String authType) {
        }
      }
    };
    SSLContext sslContext = SSLContext.getInstance(""TLS"");
    sslContext.init(null, trustAllCerts, new SecureRandom());
    clientBuilder.sslContext(sslContext);
  }",0
"@Pure
  @Override
  public @Nullable Array getArray(int i) throws SQLException {
    byte[] value = getRawValue(i);
    if (value == null) {
      return null;
    }

    int oid = fields[i - 1].getOID();
    if (isBinary(i)) {
      return makeArray(oid, value);
    }
    return makeArray(oid, castNonNull(getFixedString(i)));
  }",0
"private void basicAppend(final DomNode node) {
        // try to make the node setup as complete as possible
        // before the node is reachable
        node.setPage(getPage());
        node.parent_ = this;

        if (firstChild_ == null) {
            firstChild_ = node;
        }
        else {
            final DomNode last = getLastChild();
            node.previousSibling_ = last;
            node.nextSibling_ = null; // safety first

            last.nextSibling_ = node;
        }
        firstChild_.previousSibling_ = node;
    }",0
"@Override
    public String getPreviousName(Account account) {
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            Log.v(TAG, ""getPreviousName: "" + account
                    + "", caller's uid "" + Binder.getCallingUid()
                    + "", pid "" + Binder.getCallingPid());
        }
        Objects.requireNonNull(account, ""account cannot be null"");
        int userId = UserHandle.getCallingUserId();
        final long identityToken = clearCallingIdentity();
        try {
            UserAccounts accounts = getUserAccounts(userId);
            return readPreviousNameInternal(accounts, account);
        } finally {
            restoreCallingIdentity(identityToken);
        }
    }",0
"@Override
        public void onUserSwitched(int user) {
            synchronized (mNotificationList) {
                int i = mServices.size()-1;
                while (i --> 0) {
                    final ManagedServiceInfo info = mServices.get(i);
                    unregisterService(info.service, info.userid);
                }
            }
            registerRanker();
        }",0
"public void setParamIsPopup(String value) {

        m_paramIsPopup = value;
    }",0
"protected final Integer _parseInteger(DeserializationContext ctxt, String text) throws IOException
    {
        try {
            if (text.length() > 9) {
                long l = NumberInput.parseLong(text);
                if (_intOverflow(l)) {
                    return (Integer) ctxt.handleWeirdStringValue(Integer.class, text,
                        ""Overflow: numeric value (%s) out of range of `java.lang.Integer` (%d -%d)"",
                        text, Integer.MIN_VALUE, Integer.MAX_VALUE);
                }
                return Integer.valueOf((int) l);
            }
            return NumberInput.parseInt(text);
        } catch (IllegalArgumentException iae) {
            return(Integer) ctxt.handleWeirdStringValue(Integer.class, text,
                    ""not a valid `java.lang.Integer` value"");
        }
    }",0
"private static boolean isPendingIntentBalAllowedByCaller(@Nullable Bundle options) {
        if (options == null) {
            return ActivityOptions.PENDING_INTENT_BAL_ALLOWED_DEFAULT;
        }
        return options.getBoolean(ActivityOptions.KEY_PENDING_INTENT_BACKGROUND_ACTIVITY_ALLOWED,
                ActivityOptions.PENDING_INTENT_BAL_ALLOWED_DEFAULT);
    }",0
"void unbindServiceIfNeededLocked() {
        if (mServiceBound) {
            Log.d(TAG, ""Unbinding from service "" + mServiceName);
            mContext.unbindService(mConnection);
            mServiceBound = false;
            mService = null;
            mServiceName = null;
            mServiceUserId = -1;
        }
    }",0
"private RemoteViews makeCallLayout(int viewType) {
            final boolean isCollapsed = viewType == StandardTemplateParams.VIEW_TYPE_NORMAL;
            Bundle extras = mBuilder.mN.extras;
            CharSequence title = mPerson != null ? mPerson.getName() : null;
            CharSequence text = mBuilder.processLegacyText(extras.getCharSequence(EXTRA_TEXT));
            if (text == null) {
                text = getDefaultText();
            }

            // Bind standard template
            StandardTemplateParams p = mBuilder.mParams.reset()
                    .viewType(viewType)
                    .callStyleActions(true)
                    .allowTextWithProgress(true)
                    .hideLeftIcon(true)
                    .hideRightIcon(true)
                    .hideAppName(isCollapsed)
                    .titleViewId(R.id.conversation_text)
                    .title(title)
                    .text(text)
                    .summaryText(mBuilder.processLegacyText(mVerificationText));
            mBuilder.mActions = getActionsListWithSystemActions();
            final RemoteViews contentView;
            if (isCollapsed) {
                contentView = mBuilder.applyStandardTemplate(
                        R.layout.notification_template_material_call, p, null /* result */);
            } else {
                contentView = mBuilder.applyStandardTemplateWithActions(
                        R.layout.notification_template_material_big_call, p, null /* result */);
            }

            // Bind some extra conversation-specific header fields.
            if (!p.mHideAppName) {
                mBuilder.setTextViewColorSecondary(contentView, R.id.app_name_divider, p);
                contentView.setViewVisibility(R.id.app_name_divider, View.VISIBLE);
            }
            bindCallerVerification(contentView, p);

            // Bind some custom CallLayout properties
            contentView.setInt(R.id.status_bar_latest_event_content, ""setLayoutColor"",
                    mBuilder.getSmallIconColor(p));
            contentView.setInt(R.id.status_bar_latest_event_content,
                    ""setNotificationBackgroundColor"", mBuilder.getBackgroundColor(p));
            contentView.setIcon(R.id.status_bar_latest_event_content, ""setLargeIcon"",
                    mBuilder.mN.mLargeIcon);
            contentView.setBundle(R.id.status_bar_latest_event_content, ""setData"",
                    mBuilder.mN.extras);

            return contentView;
        }",0
"public boolean inTransaction() {
        acquireReference();
        try {
            return getThreadSession().hasTransaction();
        } finally {
            releaseReference();
        }
    }",0
"public void mdUpload(MdUploadRequest request, MultipartFile file) {
        FileUtils.uploadFile(file, FileUtils.MD_IMAGE_DIR, request.getId() + ""_"" + request.getFileName());
    }",0
"public boolean isNotificationListenerAccessGranted(ComponentName cn) {
        try {
            return sINM.isNotificationListenerAccessGranted(cn);
        } catch (Exception e) {
            Log.w(TAG, ""Error calling NoMan"", e);
        }
        return false;
    }",0
"@CalledByNative
    public int getViewportHeightPix() {
        return mViewportHeightPix;
    }",0
"@Override
    public void setImmersive(IBinder token, boolean immersive) {
        synchronized(this) {
            final ActivityRecord r = ActivityRecord.isInStackLocked(token);
            if (r == null) {
                throw new IllegalArgumentException();
            }
            r.immersive = immersive;

            // update associated state if we're frontmost
            if (r == mFocusedActivity) {
                if (DEBUG_IMMERSIVE) Slog.d(TAG_IMMERSIVE, ""Frontmost changed immersion: ""+ r);
                applyUpdateLockStateLocked(r);
            }
        }
    }",0
"public static void removeEmptyObs(Collection<Obs> obsList) {
		if (obsList != null) {
			Set<Obs> obsToRemove = new HashSet<Obs>();
			for (Obs o : obsList) {
				removeEmptyObs(o.getGroupMembers());
				boolean valueEmpty = StringUtils.isEmpty(o.getValueAsString(Context.getLocale()));
				boolean membersEmpty = o.getGroupMembers() == null || o.getGroupMembers().isEmpty();
				if (valueEmpty && membersEmpty) {
					obsToRemove.add(o);
				}
			}
			for (Obs o : obsToRemove) {
				if (o.getObsGroup() != null) {
					o.getObsGroup().removeGroupMember(o);
					o.setObsGroup(null);
				}
				if (o.getEncounter() != null) {
					o.getEncounter().removeObs(o);
					o.setEncounter(null);
				}
				obsList.remove(o);
			}
		}
	}",0
"@Override
    public void restart() {
        if (checkCallingPermission(android.Manifest.permission.SET_ACTIVITY_WATCHER)
                != PackageManager.PERMISSION_GRANTED) {
            throw new SecurityException(""Requires permission ""
                    + android.Manifest.permission.SET_ACTIVITY_WATCHER);
        }

        Log.i(TAG, ""Sending shutdown broadcast..."");

        BroadcastReceiver br = new BroadcastReceiver() {
            @Override public void onReceive(Context context, Intent intent) {
                // Now the broadcast is done, finish up the low-level shutdown.
                Log.i(TAG, ""Shutting down activity manager..."");
                shutdown(10000);
                Log.i(TAG, ""Shutdown complete, restarting!"");
                killProcess(myPid());
                System.exit(10);
            }
        };

        // First send the high-level shut down broadcast.
        Intent intent = new Intent(Intent.ACTION_SHUTDOWN);
        intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
        intent.putExtra(Intent.EXTRA_SHUTDOWN_USERSPACE_ONLY, true);
        /* For now we are not doing a clean shutdown, because things seem to get unhappy.
        mContext.sendOrderedBroadcastAsUser(intent,
                UserHandle.ALL, null, br, mHandler, 0, null, null);
        */
        br.onReceive(mContext, intent);
    }",0
"public @NotNull String getTo() {
		return to;
	}",1
"@Deprecated
    public void setPreserveVersion(boolean preserveVersion)
    {
        this.packagePreserveVersion = preserveVersion;
    }",0
"public final HeaderEntry<K, V> before() {
            return before;
        }",0
"boolean getLaunchedFromBubble() {
        return mLaunchedFromBubble;
    }",0
"public void updateResources() {
        int newOrientation = getResources().getConfiguration().orientation;
        if (newOrientation != mLastOrientation) {
            mLastOrientation = newOrientation;
            configureMode();
        }
    }",0
"@Override
        public int hashCode() {
            return Objects.hash(permName, pkgName, userId);
        }",0
"static RMQMessage fromMessage(byte[] b, List<String> trustedPackages) throws RMQJMSException {
        /* If we don't recognise the message format this throws an exception */
        try {
            ByteArrayInputStream bin = new ByteArrayInputStream(b);
            WhiteListObjectInputStream in = new WhiteListObjectInputStream(bin, trustedPackages);
            // read the class name from the stream
            String clazz = in.readUTF();
            // instantiate the message object
            RMQMessage msg = instantiateRmqMessage(clazz, trustedPackages);

            // read the message id
            msg.internalMessageID = in.readUTF();
            // read JMS properties
            int propsize = in.readInt();
            for (int i = 0; i < propsize; i++) {
                String name = in.readUTF();
                Object value = readPrimitive(in);
                msg.rmqProperties.put(name, (Serializable) value);
            }
            //read custom properties
            propsize = in.readInt();
            for (int i = 0; i < propsize; i++) {
                String name = in.readUTF();
                Object value = readPrimitive(in);
                msg.userJmsProperties.put(name, (Serializable) value);
            }
            // read the body of the message
            msg.readBody(in, bin);
            return msg;
        } catch (IOException x) {
            throw new RMQJMSException(x);
        } catch (ClassNotFoundException x) {
            throw new RMQJMSException(x);
        }
    }",0
"public int sendInner(int code, Intent intent, String resolvedType, IBinder allowlistToken,
            IIntentReceiver finishedReceiver, String requiredPermission, IBinder resultTo,
            String resultWho, int requestCode, int flagsMask, int flagsValues, Bundle options) {
        if (intent != null) intent.setDefusable(true);
        if (options != null) options.setDefusable(true);

        TempAllowListDuration duration = null;
        Intent finalIntent = null;
        Intent[] allIntents = null;
        String[] allResolvedTypes = null;
        SafeActivityOptions mergedOptions = null;
        synchronized (controller.mLock) {
            if (canceled) {
                return ActivityManager.START_CANCELED;
            }

            sent = true;
            if ((key.flags & PendingIntent.FLAG_ONE_SHOT) != 0) {
                controller.cancelIntentSender(this, true);
            }

            finalIntent = key.requestIntent != null ? new Intent(key.requestIntent) : new Intent();

            final boolean immutable = (key.flags & PendingIntent.FLAG_IMMUTABLE) != 0;
            if (!immutable) {
                if (intent != null) {
                    int changes = finalIntent.fillIn(intent, key.flags);
                    if ((changes & Intent.FILL_IN_DATA) == 0) {
                        resolvedType = key.requestResolvedType;
                    }
                } else {
                    resolvedType = key.requestResolvedType;
                }
                flagsMask &= ~Intent.IMMUTABLE_FLAGS;
                flagsValues &= flagsMask;
                finalIntent.setFlags((finalIntent.getFlags() & ~flagsMask) | flagsValues);
            } else {
                resolvedType = key.requestResolvedType;
            }

            // Apply any launch flags from the ActivityOptions. This is to ensure that the caller
            // can specify a consistent launch mode even if the PendingIntent is immutable
            final ActivityOptions opts = ActivityOptions.fromBundle(options);
            if (opts != null) {
                finalIntent.addFlags(opts.getPendingIntentLaunchFlags());
            }

            // Extract options before clearing calling identity
            mergedOptions = key.options;
            if (mergedOptions == null) {
                mergedOptions = new SafeActivityOptions(opts);
            } else {
                mergedOptions.setCallerOptions(opts);
            }

            if (mAllowlistDuration != null) {
                duration = mAllowlistDuration.get(allowlistToken);
            }

            if (key.type == ActivityManager.INTENT_SENDER_ACTIVITY
                    && key.allIntents != null && key.allIntents.length > 1) {
                // Copy all intents and resolved types while we have the controller lock so we can
                // use it later when the lock isn't held.
                allIntents = new Intent[key.allIntents.length];
                allResolvedTypes = new String[key.allIntents.length];
                System.arraycopy(key.allIntents, 0, allIntents, 0, key.allIntents.length);
                if (key.allResolvedTypes != null) {
                    System.arraycopy(key.allResolvedTypes, 0, allResolvedTypes, 0,
                            key.allResolvedTypes.length);
                }
                allIntents[allIntents.length - 1] = finalIntent;
                allResolvedTypes[allResolvedTypes.length - 1] = resolvedType;
            }

        }
        // We don't hold the controller lock beyond this point as we will be calling into AM and WM.

        final int callingUid = Binder.getCallingUid();
        final int callingPid = Binder.getCallingPid();
        final long origId = Binder.clearCallingIdentity();

        int res = START_SUCCESS;
        try {
            if (duration != null) {
                StringBuilder tag = new StringBuilder(64);
                tag.append(""setPendingIntentAllowlistDuration,reason:"");
                tag.append(duration.reason == null ? """" : duration.reason);
                tag.append("",pendingintent:"");
                UserHandle.formatUid(tag, callingUid);
                tag.append("":"");
                if (finalIntent.getAction() != null) {
                    tag.append(finalIntent.getAction());
                } else if (finalIntent.getComponent() != null) {
                    finalIntent.getComponent().appendShortString(tag);
                } else if (finalIntent.getData() != null) {
                    tag.append(finalIntent.getData().toSafeString());
                }
                controller.mAmInternal.tempAllowlistForPendingIntent(callingPid, callingUid,
                        uid, duration.duration, duration.type, duration.reasonCode, tag.toString());
            } else if (key.type == ActivityManager.INTENT_SENDER_FOREGROUND_SERVICE
                    && options != null) {
                // If this is a getForegroundService() type pending intent, use its BroadcastOptions
                // temp allowlist duration as its pending intent temp allowlist duration.
                BroadcastOptions brOptions = new BroadcastOptions(options);
                if (brOptions.getTemporaryAppAllowlistDuration() > 0) {
                    controller.mAmInternal.tempAllowlistForPendingIntent(callingPid, callingUid,
                            uid, brOptions.getTemporaryAppAllowlistDuration(),
                            brOptions.getTemporaryAppAllowlistType(),
                            brOptions.getTemporaryAppAllowlistReasonCode(),
                            brOptions.getTemporaryAppAllowlistReason());
                }
            }

            boolean sendFinish = finishedReceiver != null;
            int userId = key.userId;
            if (userId == UserHandle.USER_CURRENT) {
                userId = controller.mUserController.getCurrentOrTargetUserId();
            }
            // temporarily allow receivers and services to open activities from background if the
            // PendingIntent.send() caller was foreground at the time of sendInner() call
            final boolean allowTrampoline = uid != callingUid
                    && controller.mAtmInternal.isUidForeground(callingUid)
                    && isPendingIntentBalAllowedByCaller(options);

            // note: we on purpose don't pass in the information about the PendingIntent's creator,
            // like pid or ProcessRecord, to the ActivityTaskManagerInternal calls below, because
            // it's not unusual for the creator's process to not be alive at this time
            switch (key.type) {
                case ActivityManager.INTENT_SENDER_ACTIVITY:
                    try {
                        // Note when someone has a pending intent, even from different
                        // users, then there's no need to ensure the calling user matches
                        // the target user, so validateIncomingUser is always false below.

                        if (key.allIntents != null && key.allIntents.length > 1) {
                            res = controller.mAtmInternal.startActivitiesInPackage(
                                    uid, callingPid, callingUid, key.packageName, key.featureId,
                                    allIntents, allResolvedTypes, resultTo, mergedOptions, userId,
                                    false /* validateIncomingUser */,
                                    this /* originatingPendingIntent */,
                                    mAllowBgActivityStartsForActivitySender.contains(
                                            allowlistToken));
                        } else {
                            res = controller.mAtmInternal.startActivityInPackage(uid, callingPid,
                                    callingUid, key.packageName, key.featureId, finalIntent,
                                    resolvedType, resultTo, resultWho, requestCode, 0,
                                    mergedOptions, userId, null, ""PendingIntentRecord"",
                                    false /* validateIncomingUser */,
                                    this /* originatingPendingIntent */,
                                    mAllowBgActivityStartsForActivitySender.contains(
                                            allowlistToken));
                        }
                    } catch (RuntimeException e) {
                        Slog.w(TAG, ""Unable to send startActivity intent"", e);
                    }
                    break;
                case ActivityManager.INTENT_SENDER_ACTIVITY_RESULT:
                    controller.mAtmInternal.sendActivityResult(-1, key.activity, key.who,
                                key.requestCode, code, finalIntent);
                    break;
                case ActivityManager.INTENT_SENDER_BROADCAST:
                    try {
                        final boolean allowedByToken =
                                mAllowBgActivityStartsForBroadcastSender.contains(allowlistToken);
                        final IBinder bgStartsToken = (allowedByToken) ? allowlistToken : null;

                        // If a completion callback has been requested, require
                        // that the broadcast be delivered synchronously
                        int sent = controller.mAmInternal.broadcastIntentInPackage(key.packageName,
                                key.featureId, uid, callingUid, callingPid, finalIntent,
                                resolvedType, finishedReceiver, code, null, null,
                                requiredPermission, options, (finishedReceiver != null), false,
                                userId, allowedByToken || allowTrampoline, bgStartsToken,
                                null /* broadcastAllowList */);
                        if (sent == ActivityManager.BROADCAST_SUCCESS) {
                            sendFinish = false;
                        }
                    } catch (RuntimeException e) {
                        Slog.w(TAG, ""Unable to send startActivity intent"", e);
                    }
                    break;
                case ActivityManager.INTENT_SENDER_SERVICE:
                case ActivityManager.INTENT_SENDER_FOREGROUND_SERVICE:
                    try {
                        final boolean allowedByToken =
                                mAllowBgActivityStartsForServiceSender.contains(allowlistToken);
                        final IBinder bgStartsToken = (allowedByToken) ? allowlistToken : null;

                        controller.mAmInternal.startServiceInPackage(uid, finalIntent, resolvedType,
                                key.type == ActivityManager.INTENT_SENDER_FOREGROUND_SERVICE,
                                key.packageName, key.featureId, userId,
                                allowedByToken || allowTrampoline, bgStartsToken);
                    } catch (RuntimeException e) {
                        Slog.w(TAG, ""Unable to send startService intent"", e);
                    } catch (TransactionTooLargeException e) {
                        res = ActivityManager.START_CANCELED;
                    }
                    break;
            }

            if (sendFinish && res != ActivityManager.START_CANCELED) {
                try {
                    finishedReceiver.performReceive(new Intent(finalIntent), 0,
                            null, null, false, false, key.userId);
                } catch (RemoteException e) {
                }
            }
        } finally {
            Binder.restoreCallingIdentity(origId);
        }

        return res;
    }",1
"@Override
    public void removeStack(int stackId) {
        enforceCallingPermission(Manifest.permission.MANAGE_ACTIVITY_STACKS, ""removeStack()"");
        if (stackId == HOME_STACK_ID) {
            throw new IllegalArgumentException(""Removing home stack is not allowed."");
        }

        synchronized (this) {
            final long ident = Binder.clearCallingIdentity();
            try {
                final ActivityStack stack = mStackSupervisor.getStack(stackId);
                if (stack == null) {
                    return;
                }
                final ArrayList<TaskRecord> tasks = stack.getAllTasks();
                for (int i = tasks.size() - 1; i >= 0; i--) {
                    removeTaskByIdLocked(
                            tasks.get(i).taskId, true /* killProcess */, REMOVE_FROM_RECENTS);
                }
            } finally {
                Binder.restoreCallingIdentity(ident);
            }
        }
    }",0
"public static XMLBuilder parse(InputSource inputSource)
        throws ParserConfigurationException, SAXException, IOException
    {
        return XMLBuilder.parse(inputSource, false);
    }",1
"private void setNotification(int notifyType) {
        if (DBG) log(""setNotification: create notification "" + notifyType);

        // Needed because sprout RIL sends these when they shouldn't?
        boolean isSetNotification = mPhone.getContext().getResources().getBoolean(
                com.android.internal.R.bool.config_user_notification_of_restrictied_mobile_access);
        if (!isSetNotification) {
            if (DBG) log(""Ignore all the notifications"");
            return;
        }

        Context context = mPhone.getContext();


        CharSequence details = """";
        CharSequence title = context.getText(com.android.internal.R.string.RestrictedChangedTitle);
        int notificationId = CS_NOTIFICATION;

        switch (notifyType) {
        case PS_ENABLED:
            long dataSubId = SubscriptionManager.getDefaultDataSubId();
            if (dataSubId != mPhone.getSubId()) {
                return;
            }
            notificationId = PS_NOTIFICATION;
            details = context.getText(com.android.internal.R.string.RestrictedOnData);
            break;
        case PS_DISABLED:
            notificationId = PS_NOTIFICATION;
            break;
        case CS_ENABLED:
            details = context.getText(com.android.internal.R.string.RestrictedOnAllVoice);
            break;
        case CS_NORMAL_ENABLED:
            details = context.getText(com.android.internal.R.string.RestrictedOnNormal);
            break;
        case CS_EMERGENCY_ENABLED:
            details = context.getText(com.android.internal.R.string.RestrictedOnEmergency);
            break;
        case CS_DISABLED:
            // do nothing and cancel the notification later
            break;
        }

        if (DBG) log(""setNotification: put notification "" + title + "" / "" +details);
        mNotification = new Notification.Builder(context)
                .setWhen(System.currentTimeMillis())
                .setAutoCancel(true)
                .setSmallIcon(com.android.internal.R.drawable.stat_sys_warning)
                .setTicker(title)
                .setColor(context.getResources().getColor(
                        com.android.internal.R.color.system_notification_accent_color))
                .setContentTitle(title)
                .setContentText(details)
                .build();

        NotificationManager notificationManager = (NotificationManager)
            context.getSystemService(Context.NOTIFICATION_SERVICE);

        if (notifyType == PS_DISABLED || notifyType == CS_DISABLED) {
            // cancel previous post notification
            notificationManager.cancel(notificationId);
        } else {
            // update restricted state notification
            notificationManager.notify(notificationId, mNotification);
        }
    }",0
"public static byte[] cacheNameBytes(String cacheName) {
      return cacheName.equals(DEFAULT_CACHE_NAME)
            ? HotRodConstants.DEFAULT_CACHE_NAME_BYTES
            : cacheName.getBytes(HotRodConstants.HOTROD_STRING_CHARSET);
   }",0
"@Override
    public SerializationServiceBuilder addDataSerializableFactory(int id, DataSerializableFactory factory) {
        dataSerializableFactories.put(id, factory);
        return this;
    }",0
"public void moveTaskToTop(int taskId) {
        final long origId = Binder.clearCallingIdentity();
        try {
            synchronized(mWindowMap) {
                Task task = mTaskIdToTask.get(taskId);
                if (task == null) {
                    // Normal behavior, addAppToken will be called next and task will be created.
                    return;
                }
                final TaskStack stack = task.mStack;
                final DisplayContent displayContent = task.getDisplayContent();
                displayContent.moveStack(stack, true);
                if (displayContent.isDefaultDisplay) {
                    final TaskStack homeStack = displayContent.getHomeStack();
                    if (homeStack != stack) {
                        // When a non-home stack moves to the top, the home stack moves to the
                        // bottom.
                        displayContent.moveStack(homeStack, false);
                    }
                }
                stack.moveTaskToTop(task);
                if (mAppTransition.isTransitionSet()) {
                    task.setSendingToBottom(false);
                }
                moveStackWindowsLocked(displayContent);
            }
        } finally {
            Binder.restoreCallingIdentity(origId);
        }
    }",0
"public JSONArray put(Collection value) throws JSONException {
        put(new JSONArray(value));
        return this;
    }",1
"private void clearInternalData() {
        localLog(""clearInternalData: Clearing all internal data"");
        mConfiguredNetworks.clear();
        mUserTemporarilyDisabledList.clear();
        mNonCarrierMergedNetworksStatusTracker.clear();
        mRandomizedMacAddressMapping.clear();
        mScanDetailCaches.clear();
        clearLastSelectedNetwork();
    }",0
"private boolean bindToAuthenticator(String authenticatorType) {
            final AccountAuthenticatorCache.ServiceInfo<AuthenticatorDescription> authenticatorInfo;
            authenticatorInfo = mAuthenticatorCache.getServiceInfo(
                    AuthenticatorDescription.newKey(authenticatorType), mAccounts.userId);
            if (authenticatorInfo == null) {
                if (Log.isLoggable(TAG, Log.VERBOSE)) {
                    Log.v(TAG, ""there is no authenticator for "" + authenticatorType
                            + "", bailing out"");
                }
                return false;
            }

            if (!isLocalUnlockedUser(mAccounts.userId)
                    && !authenticatorInfo.componentInfo.directBootAware) {
                Slog.w(TAG, ""Blocking binding to authenticator "" + authenticatorInfo.componentName
                        + "" which isn't encryption aware"");
                return false;
            }

            Intent intent = new Intent();
            intent.setAction(AccountManager.ACTION_AUTHENTICATOR_INTENT);
            intent.setComponent(authenticatorInfo.componentName);
            if (Log.isLoggable(TAG, Log.VERBOSE)) {
                Log.v(TAG, ""performing bindService to "" + authenticatorInfo.componentName);
            }
            int flags = Context.BIND_AUTO_CREATE;
            if (mAuthenticatorCache.getBindInstantServiceAllowed(mAccounts.userId)) {
                flags |= Context.BIND_ALLOW_INSTANT;
            }
            if (!mContext.bindServiceAsUser(intent, this, flags, UserHandle.of(mAccounts.userId))) {
                if (Log.isLoggable(TAG, Log.VERBOSE)) {
                    Log.v(TAG, ""bindService to "" + authenticatorInfo.componentName + "" failed"");
                }
                return false;
            }

            return true;
        }",0
"public String getRenderedContent(boolean transformationContextIsolated, XWikiContext context) throws XWikiException
    {
        return getRenderedContent(getOutputSyntax(), transformationContextIsolated, context);
    }",0
"private static boolean isSuccessfulLaunch(int result) {
        return result == ActivityManager.START_SUCCESS
                || result == ActivityManager.START_DELIVERED_TO_TOP
                || result == ActivityManager.START_TASK_TO_FRONT;
    }",0
"protected void initInternal() throws ServletException {

        // :FIXME: Document UnavailableException

        try {
            internal = MessageResources.getMessageResources(internalName);
        } catch (MissingResourceException e) {
            log.error(""Cannot load internal resources from '"" + internalName + ""'"",
                e);
            throw new UnavailableException
                (""Cannot load internal resources from '"" + internalName + ""'"");
        }

    }",0
"@Transactional
    public void save(PanelShareRequest request) {
        List<PanelGroup> panelGroups = queryGroup(request.getPanelIds());
        // 1.先根据仪表板删除所有已经分享的
        Integer type = request.getType();
        List<String> panelIds = request.getPanelIds();
        List<Long> targetIds = request.getTargetIds();
        // 使用原生对象会导致事物失效 所以这里需要使用spring代理对象
        if (CollectionUtils.isNotEmpty(panelIds)) {
            ShareService proxy = CommonBeanFactory.getBean(ShareService.class);
            panelIds.forEach(panelId -> proxy.delete(panelId, type));
        }
        if (CollectionUtils.isEmpty(targetIds))
            return;

        long now = System.currentTimeMillis();
        List<PanelShare> shares = panelIds.stream().flatMap(panelId -> targetIds.stream().map(targetId -> {
            PanelShare share = new PanelShare();
            share.setCreateTime(now);
            share.setPanelGroupId(panelId);
            share.setTargetId(targetId);
            share.setType(type);
            return share;
        })).collect(Collectors.toList());
        if (CollectionUtils.isNotEmpty(shares)) {
            extPanelShareMapper.batchInsert(shares, AuthUtils.getUser().getUsername());
        }

        // 下面是发送提醒消息逻辑
        Set<Long> userIdSet;
        AuthURD authURD = new AuthURD();
        if (type == 0) {
            authURD.setUserIds(targetIds);
        }
        if (type == 1) {
            authURD.setRoleIds(targetIds);
        }
        if (type == 2) {
            authURD.setDeptIds(targetIds);
        }
        userIdSet = AuthUtils.userIdsByURD(authURD);

        CurrentUserDto user = AuthUtils.getUser();
        String msg = StringUtils.joinWith(""，"",
                panelGroups.stream().map(PanelGroup::getName).collect(Collectors.toList()));
        Gson gson = new Gson();
        userIdSet.forEach(userId -> DeMsgutil.sendMsg(userId, 2L, user.getNickName() + "" 分享了仪表板【"" + msg + ""】给您，请查收!"",
                gson.toJson(panelIds)));

    }",0
"@Override
    public void onDialogShowing() {
        super.onDialogShowing();

        setOnDismissListener(this);
    }",0
"private static List<Element> getChildren(final String name, final Node node) {
    final NodeList children = node.getChildNodes();
    return IntStream.range(0, children.getLength())
        .mapToObj(children::item)
        .filter(current -> current.getNodeName().equals(name))
        .map(Element.class::cast)
        .collect(Collectors.toList());
  }",0
"@PostMapping
    @ResponseStatus(value = HttpStatus.CREATED)
    @ApiOperation(""创建模型"")
    public ResponseMessage<Model> createModel(@RequestBody ModelCreateRequest model) throws Exception {
        JSONObject stencilset = new JSONObject();
        stencilset.put(""namespace"", ""http://b3mn.org/stencilset/bpmn2.0#"");
        JSONObject editorNode = new JSONObject();
        editorNode.put(""id"", ""canvas"");
        editorNode.put(""resourceId"", ""canvas"");
        editorNode.put(""stencilset"", stencilset);
        JSONObject modelObjectNode = new JSONObject();
        modelObjectNode.put(MODEL_REVISION, 1);
        modelObjectNode.put(MODEL_DESCRIPTION, model.getDescription());
        modelObjectNode.put(MODEL_KEY, model.getKey());
        modelObjectNode.put(MODEL_NAME, model.getName());

        Model modelData = repositoryService.newModel();
        modelData.setMetaInfo(modelObjectNode.toJSONString());
        modelData.setName(model.getName());
        modelData.setKey(model.getKey());
        repositoryService.saveModel(modelData);
        repositoryService.addModelEditorSource(modelData.getId(), editorNode.toString().getBytes(""utf-8""));
        return ResponseMessage.ok(modelData).status(201);
    }",0
"public void assignChildLayers(Transaction t) {
        // The surface of the main window might be preserved. So the child window on top of the main
        // window should be also on top of the preserved surface.
        int layer = PRESERVED_SURFACE_LAYER + 1;
        for (int i = 0; i < mChildren.size(); i++) {
            final WindowState w = mChildren.get(i);

            // APPLICATION_MEDIA_OVERLAY needs to go above APPLICATION_MEDIA
            // while they both need to go below the main window. However the
            // relative layering of multiple APPLICATION_MEDIA/OVERLAY has never
            // been defined and so we can use static layers and leave it that way.
            if (w.mAttrs.type == TYPE_APPLICATION_MEDIA) {
                if (mWinAnimator.hasSurface()) {
                    w.assignRelativeLayer(t, mWinAnimator.mSurfaceController.mSurfaceControl, -2);
                } else {
                    w.assignLayer(t, -2);
                }
            } else if (w.mAttrs.type == TYPE_APPLICATION_MEDIA_OVERLAY) {
                if (mWinAnimator.hasSurface()) {
                    w.assignRelativeLayer(t, mWinAnimator.mSurfaceController.mSurfaceControl, -1);
                } else {
                    w.assignLayer(t, -1);
                }
            } else {
                w.assignLayer(t, layer);
            }
            w.assignChildLayers(t);
            layer++;
        }
    }",0
"public void handleApplicationCrash(IBinder app, ApplicationErrorReport.CrashInfo crashInfo) {
        ProcessRecord r = findAppProcess(app, ""Crash"");
        final String processName = app == null ? ""system_server""
                : (r == null ? ""unknown"" : r.processName);

        handleApplicationCrashInner(""crash"", r, processName, crashInfo);
    }",0
"@Override
    protected void process(EntityReference source)
    {
        this.progressManager.pushLevelProgress(2, this);
        AttachmentReference destination = this.request.getProperty(MoveAttachmentRequest.DESTINATION);
        boolean autoRedirect = this.request.getProperty(MoveAttachmentRequest.AUTO_REDIRECT);

        XWiki wiki = this.xcontextProvider.get().getWiki();

        // Update the author for the attribution of the attachment uploader.
        this.modelBridge.setContextUserReference(this.request.getUserReference());
        try {
            if (checkMoveRights(source, destination)) {
                this.progressManager.startStep(this);
                moveAttachment(source, destination, autoRedirect, wiki);
                this.progressManager.endStep(this);

                this.progressManager.startStep(this);
                this.observationManager.notify(new AttachmentMovedEvent((AttachmentReference) source, destination),
                    this,
                    this.request);
                this.progressManager.endStep(this);
            }
        } finally {
            this.progressManager.popLevelProgress(this);
        }
    }",1
"private static Element getFirstChild(Element element, String tagName) {
        if (element == null) return null;
        NodeList elementsByTagName = element.getElementsByTagName(tagName);
        if (elementsByTagName != null && elementsByTagName.getLength() > 0)
            return (Element) elementsByTagName.item(0);
        else
            return null;
    }",0
"protected void updateUi() {
            final boolean canInput = mSaveAndFinishWorker == null;

            LockscreenCredential password = mIsAlphaMode
                    ? LockscreenCredential.createPasswordOrNone(mPasswordEntry.getText())
                    : LockscreenCredential.createPinOrNone(mPasswordEntry.getText());
            final int length = password.size();
            if (mUiStage == Stage.Introduction) {
                mPasswordRestrictionView.setVisibility(View.VISIBLE);
                final boolean passwordCompliant = validatePassword(password);
                String[] messages = convertErrorCodeToMessages();
                // Update the fulfillment of requirements.
                mPasswordRequirementAdapter.setRequirements(messages);
                // Enable/Disable the next button accordingly.
                setNextEnabled(passwordCompliant);
            } else {
                // Hide password requirement view when we are just asking user to confirm the pw.
                mPasswordRestrictionView.setVisibility(View.GONE);
                setHeaderText(mUiStage.getHint(getContext(), mIsAlphaMode, getStageType(),
                        mIsManagedProfile));
                setNextEnabled(canInput && length >= LockPatternUtils.MIN_LOCK_PASSWORD_SIZE);
                mSkipOrClearButton.setVisibility(toVisibility(canInput && length > 0));
            }
            final int stage = getStageType();
            if (getStageType() != Stage.TYPE_NONE) {
                int message = mUiStage.getMessage(mIsAlphaMode, stage);
                if (message != 0) {
                    mMessage.setVisibility(View.VISIBLE);
                    mMessage.setText(message);
                } else {
                    mMessage.setVisibility(View.INVISIBLE);
                }
            } else {
                mMessage.setVisibility(View.GONE);
            }

            setNextText(mUiStage.buttonText);
            mPasswordEntryInputDisabler.setInputEnabled(canInput);
            password.zeroize();
        }",0
"protected boolean _checkTextualNull(DeserializationContext ctxt, String text)
            throws JsonMappingException
    {
        if (_hasTextualNull(text)) {
            if (!ctxt.isEnabled(MapperFeature.ALLOW_COERCION_OF_SCALARS)) {
                _reportFailedNullCoerce(ctxt, true,  MapperFeature.ALLOW_COERCION_OF_SCALARS, ""String \""null\"""");
            }
            return true;
        }
        return false;
    }",0
"private IBaseResource loadAndAddConf(HttpServletRequest theServletRequest, final HomeRequest theRequest, final ModelMap theModel) {
		switch (theRequest.getFhirVersion(myConfig)) {
			case DSTU2:
				return loadAndAddConfDstu2(theServletRequest, theRequest, theModel);
			case DSTU3:
				return loadAndAddConfDstu3(theServletRequest, theRequest, theModel);
			case R4:
				return loadAndAddConfR4(theServletRequest, theRequest, theModel);
			case R5:
				return loadAndAddConfR5(theServletRequest, theRequest, theModel);
			case DSTU2_1:
			case DSTU2_HL7ORG:
				break;
		}
		throw new IllegalStateException(""Unknown version: "" + theRequest.getFhirVersion(myConfig));
	}",0
"public String getSelectedDownloadOptionLabel() {
        return selectedDownloadOptionLabel;
    }",0
"public int optInt(String key, int defaultValue) {
    	Object o = opt(key);
        if (o == null) {
        	return defaultValue;
        } else {
        	try {
        	    return doGetInt(key, o);
        	} catch (JSONException ex) {
        		throw new RuntimeException(ex);
        	}
        }
    }",0
"public int installLocationPolicy(PackageInfoLite pkgLite, int installFlags) {
        String packageName = pkgLite.packageName;
        int installLocation = pkgLite.installLocation;
        // reader
        synchronized (mPm.mLock) {
            // Currently installed package which the new package is attempting to replace or
            // null if no such package is installed.
            AndroidPackage installedPkg = mPm.mPackages.get(packageName);

            if (installedPkg != null) {
                if ((installFlags & PackageManager.INSTALL_REPLACE_EXISTING) != 0) {
                    // Check for updated system application.
                    if (installedPkg.isSystem()) {
                        return InstallLocationUtils.RECOMMEND_INSTALL_INTERNAL;
                    } else {
                        // If current upgrade specifies particular preference
                        if (installLocation == PackageInfo.INSTALL_LOCATION_INTERNAL_ONLY) {
                            // Application explicitly specified internal.
                            return InstallLocationUtils.RECOMMEND_INSTALL_INTERNAL;
                        } else if (
                                installLocation == PackageInfo.INSTALL_LOCATION_PREFER_EXTERNAL) {
                            // App explicitly prefers external. Let policy decide
                        } else {
                            // Prefer previous location
                            if (installedPkg.isExternalStorage()) {
                                return InstallLocationUtils.RECOMMEND_INSTALL_EXTERNAL;
                            }
                            return InstallLocationUtils.RECOMMEND_INSTALL_INTERNAL;
                        }
                    }
                } else {
                    // Invalid install. Return error code
                    return InstallLocationUtils.RECOMMEND_FAILED_ALREADY_EXISTS;
                }
            }
        }
        return pkgLite.recommendedInstallLocation;
    }",0
"public void setSocketConfigurator(SocketConfigurator socketConfigurator) {
        this.socketConf = socketConfigurator;
    }",0
"public byte[] readFromStream() {
            try {
                int av = getAvailableInput();
                if(av > 0) {
                    byte[] arr = new byte[av];
                    int size = getInput().read(arr);
                    if(size == arr.length) {
                        return arr;
                    }
                    return shrink(arr, size);
                }
                byte[] arr = new byte[8192];
                int size = getInput().read(arr);
                if(size == arr.length) {
                    return arr;
                }
                return shrink(arr, size);
            } catch(IOException err) {
                err.printStackTrace();
                errorMessage = err.toString();
                return null;
            }
        }",0
"@Override
        public void clearPendingResultForActivity(IBinder activityToken,
                WeakReference<PendingIntentRecord> pir) {
            synchronized (mGlobalLock) {
                final ActivityRecord r = ActivityRecord.isInRootTaskLocked(activityToken);
                if (r != null && r.pendingResults != null) {
                    r.pendingResults.remove(pir);
                }
            }
        }",0
"boolean isInitialized(int userId) {
        return (getUserInfo(userId).flags & UserInfo.FLAG_INITIALIZED) != 0;
    }",0
"private void onSplashScreenAttachComplete() {
        removeTransferSplashScreenTimeout();
        // Client has draw the splash screen, so we can remove the starting window.
        if (mStartingWindow != null) {
            mStartingWindow.cancelAnimation();
            mStartingWindow.hide(false, false);
        }
        // no matter what, remove the starting window.
        mTransferringSplashScreenState = TRANSFER_SPLASH_SCREEN_FINISH;
        removeStartingWindowAnimation(false /* prepareAnimation */);
    }",0
"@PreAuthorize(value = ""@permissionValidator.isSuperAdmin()"")
  @GetMapping
  public SystemInfo getSystemInfo() {
    SystemInfo systemInfo = new SystemInfo();

    String version = Apollo.VERSION;
    if (isValidVersion(version)) {
      systemInfo.setVersion(version);
    }

    List<Env> allEnvList = portalSettings.getAllEnvs();

    for (Env env : allEnvList) {
      EnvironmentInfo environmentInfo = adaptEnv2EnvironmentInfo(env);

      systemInfo.addEnvironment(environmentInfo);
    }

    return systemInfo;
  }",1
"public static synchronized LicenseInfo retrieveNamedSlow() {
		cache = LicenseInfo.NONE;
//		if (OptionFlags.ALLOW_INCLUDE == false)
//			return cache;

		final String key = prefs.get(""license"", """");
		if (key.length() > 0) {
			cache = setIfValid(retrieveNamed(key), cache);
			if (cache.isValid())
				return cache;

		}
		for (SFile f : fileCandidates()) {
			try {
				if (f.exists() && f.canRead()) {
					final LicenseInfo result = retrieve(f);
					if (result == null)
						return null;

					cache = setIfValid(result, cache);
					if (cache.isValid())
						return cache;

				}
			} catch (IOException e) {
				Log.info(""Error "" + e);
				// Logme.error(e);
			}
		}
		return cache;
	}",1
"public void writeBool(boolean b) throws TException {
    writeByte(b ? (byte) 1 : (byte) 0);
  }",0
"@Nullable
    private Long findProjectId(String path) {
    	Long projectId = null;
    	for (String name: Splitter.on(""/"").omitEmptyStrings().trimResults().split(path)) {
    		projectId = findProjectId(projectId, name);
    		if (projectId == null)
    			break;
    	}
    	return projectId;
    }",0
"public TaskWithBLOBs getById(String taskId) {
        return taskMapper.selectByPrimaryKey(taskId);
    }",0
"public int bindService(IApplicationThread caller, IBinder token,
            Intent service, String resolvedType, IServiceConnection connection,
            int flags,  String callingPackage, int userId) throws RemoteException {
        Parcel data = Parcel.obtain();
        Parcel reply = Parcel.obtain();
        data.writeInterfaceToken(IActivityManager.descriptor);
        data.writeStrongBinder(caller != null ? caller.asBinder() : null);
        data.writeStrongBinder(token);
        service.writeToParcel(data, 0);
        data.writeString(resolvedType);
        data.writeStrongBinder(connection.asBinder());
        data.writeInt(flags);
        data.writeString(callingPackage);
        data.writeInt(userId);
        mRemote.transact(BIND_SERVICE_TRANSACTION, data, reply, 0);
        reply.readException();
        int res = reply.readInt();
        data.recycle();
        reply.recycle();
        return res;
    }",0
"private AndroidGraphics getNullGraphics() {
        if (nullGraphics == null) {
            Bitmap bitmap = Bitmap.createBitmap(getDisplayWidth()==0?100:getDisplayWidth(), getDisplayHeight()==0?100:getDisplayHeight(),
                    Bitmap.Config.ARGB_8888);
            nullGraphics = (AndroidGraphics) this.getNativeGraphics(bitmap);
        }
        return nullGraphics;
    }",0
"public void startActivityDismissingKeyguard(final Intent intent, boolean onlyProvisioned,
            final boolean dismissShade, final Callback callback) {
        if (onlyProvisioned && !isDeviceProvisioned()) return;

        final boolean afterKeyguardGone = PreviewInflater.wouldLaunchResolverActivity(
                mContext, intent, mCurrentUserId);
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                mAssistManager.hideAssist();
                intent.setFlags(
                        Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);
                int result = ActivityManager.START_CANCELED;
                ActivityOptions options = new ActivityOptions(getActivityOptions());
                if (intent == KeyguardBottomAreaView.INSECURE_CAMERA_INTENT) {
                    // Normally an activity will set it's requested rotation
                    // animation on its window. However when launching an activity
                    // causes the orientation to change this is too late. In these cases
                    // the default animation is used. This doesn't look good for
                    // the camera (as it rotates the camera contents out of sync
                    // with physical reality). So, we ask the WindowManager to
                    // force the crossfade animation if an orientation change
                    // happens to occur during the launch.
                    options.setRotationAnimationHint(
                            WindowManager.LayoutParams.ROTATION_ANIMATION_SEAMLESS);
                }
                try {
                    result = ActivityManager.getService().startActivityAsUser(
                            null, mContext.getBasePackageName(),
                            intent,
                            intent.resolveTypeIfNeeded(mContext.getContentResolver()),
                            null, null, 0, Intent.FLAG_ACTIVITY_NEW_TASK, null,
                            options.toBundle(), UserHandle.CURRENT.getIdentifier());
                } catch (RemoteException e) {
                    Log.w(TAG, ""Unable to start activity"", e);
                }
                if (callback != null) {
                    callback.onActivityStarted(result);
                }
            }
        };
        Runnable cancelRunnable = new Runnable() {
            @Override
            public void run() {
                if (callback != null) {
                    callback.onActivityStarted(ActivityManager.START_CANCELED);
                }
            }
        };
        executeRunnableDismissingKeyguard(runnable, cancelRunnable, dismissShade,
                afterKeyguardGone, true /* deferred */);
    }",0
"public final void lightenPayload() {
        tickerView = null;
        contentView = null;
        bigContentView = null;
        headsUpContentView = null;
        mLargeIcon = null;
        if (extras != null && !extras.isEmpty()) {
            final Set<String> keyset = extras.keySet();
            final int N = keyset.size();
            final String[] keys = keyset.toArray(new String[N]);
            for (int i=0; i<N; i++) {
                final String key = keys[i];
                if (TvExtender.EXTRA_TV_EXTENDER.equals(key)) {
                    continue;
                }
                final Object obj = extras.get(key);
                if (obj != null &&
                    (  obj instanceof Parcelable
                    || obj instanceof Parcelable[]
                    || obj instanceof SparseArray
                    || obj instanceof ArrayList)) {
                    extras.remove(key);
                }
            }
        }
    }",0
"public boolean contains(String where, String what) {
        boolean retval = false;

        String[] tmp = where.split("","");
        for (int i = 0; i < tmp.length; i++) {
            if (what.equalsIgnoreCase(tmp[i])) {
                retval = true;
                break;
            }
        }
        return retval;
    }",0
"@Override
        public boolean isNativePlayerMode() {
            return nativePlayer;
        }",0
"@JRubyMethod(name = ""file"", meta = true)
  public static IRubyObject
  parse_file(ThreadContext context,
             IRubyObject klazz,
             IRubyObject data)
  {
    final Ruby runtime = context.runtime;
    XmlSaxParserContext ctx = newInstance(runtime, (RubyClass) klazz);
    ctx.initialize(context.getRuntime());
    ctx.setInputSourceFile(context, data);
    return ctx;
  }",0
"private boolean killProcessesBelowAdj(int belowAdj, String reason) {
        if (Binder.getCallingUid() != SYSTEM_UID) {
            throw new SecurityException(""killProcessesBelowAdj() only available to system"");
        }

        boolean killed = false;
        synchronized (this) {
            synchronized (mProcLock) {
                synchronized (mPidsSelfLocked) {
                    final int size = mPidsSelfLocked.size();
                    for (int i = 0; i < size; i++) {
                        final int pid = mPidsSelfLocked.keyAt(i);
                        final ProcessRecord proc = mPidsSelfLocked.valueAt(i);
                        if (proc == null) continue;

                        final int adj = proc.mState.getSetAdj();
                        if (adj > belowAdj && !proc.isKilledByAm()) {
                            proc.killLocked(reason, ApplicationExitInfo.REASON_PERMISSION_CHANGE,
                                    true);
                            killed = true;
                        }
                    }
                }
            }
        }
        return killed;
    }",0
"public XWikiVersioningStoreInterface getVersioningStore(XWikiContext context)
    {
        return context.getWiki().getVersioningStore();
    }",0
"public static @Nullable String sanitizeDisplayName(@Nullable String name) {
        return sanitizeDisplayName(name, /*rewriteHiddenFileName*/ false);
    }",0
"public static boolean deleteDirAndContents(File dir)
    {
        if (dir.isDirectory())
        {
            String[] children = dir.list();
            for (int i = 0; i < children.length; i++)
            {
                boolean success = deleteDirAndContents(new File(dir, children[i]));
                if (!success)
                    return false;
            }
        }
        return dir.delete();
    }",0
"@Override
    public void postNav(StringBuffer sb) {
        HtmlTag div = new HtmlTag(""div"");
        sb.append(div.renderCloseTag());
        sb.append(""\n"");
    }",0
"private void offsetInputMethodWindowLw(WindowState win) {
        int top = win.getContentFrameLw().top;
        top += win.getGivenContentInsetsLw().top;
        if (mContentBottom > top) {
            mContentBottom = top;
        }
        if (mVoiceContentBottom > top) {
            mVoiceContentBottom = top;
        }
        top = win.getVisibleFrameLw().top;
        top += win.getGivenVisibleInsetsLw().top;
        if (mCurBottom > top) {
            mCurBottom = top;
        }
        if (DEBUG_LAYOUT) Slog.v(TAG, ""Input method: mDockBottom=""
                + mDockBottom + "" mContentBottom=""
                + mContentBottom + "" mCurBottom="" + mCurBottom);
    }",0
"@Override
        public void setDialerAppPackagesProvider(PackagesProvider provider) {
            synchronized (mPackages) {
                mDefaultPermissionPolicy.setDialerAppPackagesProviderLPw(provider);
            }
        }",0
"public void quiescingTransmit(Method m) throws IOException {
        synchronized (_channelMutex) {
            quiescingTransmit(new AMQCommand(m));
        }
    }",0
"@Override
    public Bitmap getTaskDescriptionIcon(String filePath, int userId) {
        userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(),
                userId, false, ALLOW_FULL_ONLY, ""getTaskDescriptionIcon"", null);

        final File passedIconFile = new File(filePath);
        final File legitIconFile = new File(TaskPersister.getUserImagesDir(userId),
                passedIconFile.getName());
        if (!legitIconFile.getPath().equals(filePath)
                || !filePath.contains(ActivityRecord.ACTIVITY_ICON_SUFFIX)) {
            throw new IllegalArgumentException(""Bad file path: "" + filePath
                    + "" passed for userId "" + userId);
        }
        return mRecentTasks.getTaskDescriptionIcon(filePath);
    }",0
"public static <T> List<T> subList(List<T> base, int maxSize) {
        if(maxSize<base.size())
            return base.subList(0,maxSize);
        else
            return base;
    }",0
"private Set<String> getOverlayInstantAppAccessibleSettings(int settingsType) {
        switch (settingsType) {
            case SETTINGS_TYPE_GLOBAL:
                return OVERLAY_ALLOWED_GLOBAL_INSTANT_APP_SETTINGS;
            case SETTINGS_TYPE_SYSTEM:
                return OVERLAY_ALLOWED_SYSTEM_INSTANT_APP_SETTINGS;
            case SETTINGS_TYPE_SECURE:
                return OVERLAY_ALLOWED_SECURE_INSTANT_APP_SETTINGS;
            default:
                throw new IllegalArgumentException(""Invalid settings type: "" + settingsType);
        }
    }",0
"public String getPathName() {
        return ""universal"";
    }",0
"public void addCookie(Cookie[] cs, boolean addToWebViewCookieManager, boolean sync) {
        if(addToWebViewCookieManager) {
            CookieManager mgr;
            CookieSyncManager syncer;
            try {
                syncer = CookieSyncManager.getInstance();
                mgr = getCookieManager();
            } catch(IllegalStateException ex) {
                syncer = CookieSyncManager.createInstance(this.getContext());
                mgr = getCookieManager();
            }
            java.text.SimpleDateFormat format = new java.text.SimpleDateFormat(""EEE, dd-MMM-yyyy HH:mm:ss z"");
            format.setTimeZone(TimeZone.getTimeZone(""GMT""));

            for (Cookie c : cs) {
                addCookie(c, mgr, format);

            }

            if(sync) {
                syncer.sync();
            }
        }
        super.addCookie(cs);



    }",0
"public boolean getBoolean(int index) throws JSONException {
        Object o = get(index);
        if (o.equals(Boolean.FALSE) ||
                (o instanceof String &&
                ((String)o).equalsIgnoreCase(""false""))) {
            return false;
        } else if (o.equals(Boolean.TRUE) ||
                (o instanceof String &&
                ((String)o).equalsIgnoreCase(""true""))) {
            return true;
        }
        throw new JSONException(""JSONArray["" + index + ""] is not a Boolean."");
    }",0
"@Nullable
    final Long getLongAndRemove(CharSequence name) {
        final String v = getAndRemove(name);
        return toLong(v);
    }",0
"public FrameHandler create(Socket sock) throws IOException
    {
        return new SocketFrameHandler(sock, this.shutdownExecutor, this.maxInboundMessageBodySize);
    }",1
"public void signalPersistentProcesses(int sig) throws RemoteException {
        Parcel data = Parcel.obtain();
        Parcel reply = Parcel.obtain();
        data.writeInterfaceToken(IActivityManager.descriptor);
        data.writeInt(sig);
        mRemote.transact(SIGNAL_PERSISTENT_PROCESSES_TRANSACTION, data, reply, 0);
        reply.readException();
        data.recycle();
        reply.recycle();
    }",0
"@Override
    public CommandData getCommandData() {
        return null;
    }",0
"public Version getRCSVersion()
    {
        return this.doc.getRCSVersion();
    }",0
"@VisibleForTesting
    void updatePackageShortcutForTest(String packageName, String shortcutId, int userId,
            Consumer<ShortcutInfo> cb) {
        synchronized (mLock) {
            final ShortcutPackage pkg = getPackageShortcutForTest(packageName, userId);
            if (pkg == null) return;
            cb.accept(pkg.findShortcutById(shortcutId));
        }
    }",0
"private void removeUserStateLocked(final int userHandle) {
        mContext.getSystemService(StorageManager.class)
            .deleteUserKey(userHandle);
        // Cleanup package manager settings
        mPm.cleanUpUserLILPw(this, userHandle);

        // Remove this user from the list
        mUsers.remove(userHandle);
        // Remove user file
        AtomicFile userFile = new AtomicFile(new File(mUsersDir, userHandle + XML_SUFFIX));
        userFile.delete();
        // Update the user list
        writeUserListLocked();
        updateUserIdsLocked();
        removeDirectoryRecursive(Environment.getUserSystemDirectory(userHandle));
    }",0
"private String getLine(BufferedReader reader) throws IOException {
        String line = null;
        try {
            while ((line = reader.readLine()) != null) {
                cursor.lineNumber++;
                if (cursor.lineNumber < watermark) {
                    continue;
                } else {
                    watermark = 0;
                }
                if (line.length() == 0) {
                    continue;
                }
                break;
            }
        } catch (SocketException | SocketTimeoutException e) {
            if (backOffPolicy.hasNext()) {
                watermark = watermark == 0 ? cursor.lineNumber + 1 : watermark;
                closeReader();
                createReader(currentInput, cursor.uri);
            } else {
                URI uri = currentInput.uri();
                LOGGER.error(""Timeout during COPY FROM '"" + uri.toString() +
                             ""' after "" + MAX_SOCKET_TIMEOUT_RETRIES +
                             "" retries"", e);
            }
            throw e;
        } catch (Exception e) {
            URI uri = currentInput.uri();
            // it's nice to know which exact file/uri threw an error
            // when COPY FROM returns less rows than expected
            LOGGER.error(""Error during COPY FROM '"" + uri.toString() + ""'"", e);
            rethrowUnchecked(e);
        }
        return line;
    }",0
"public List<String> getHtmlFormWarnings() {
		return htmlFormWarnings;
	}",0
"@Override
    public List<RunningTaskInfo> getTasks(int maxNum) {
       return getFilteredTasks(maxNum, ACTIVITY_TYPE_UNDEFINED, WINDOWING_MODE_UNDEFINED);
    }",0
"public void setCellDescriptionGenerator(CellDescriptionGenerator generator,
            ContentMode contentMode) {
        if (contentMode == null) {
            throw new IllegalArgumentException(""Content mode cannot be null"");
        }
        cellDescriptionGenerator = generator;
        getState().hasDescriptions = (generator != null || rowDescriptionGenerator != null);
        getState().cellTooltipContentMode = contentMode;
        datasourceExtension.refreshCache();
    }",0
"private void handleBadRequest() {
        sendMessages(SEND_HEADERS_BAD_REQUEST_MSG, END_RESPONSE);
    }",0
"protected Double _checkDoubleSpecialValue(String text)
    {
        if (!text.isEmpty()) {
            switch (text.charAt(0)) {
            case 'I':
                if (_isPosInf(text)) {
                    return Double.POSITIVE_INFINITY;
                }
                break;
            case 'N':
                if (_isNaN(text)) {
                    return Double.NaN;
                }
                break;
            case '-':
                if (_isNegInf(text)) {
                    return Double.NEGATIVE_INFINITY;
                }
                break;
            default:
            }
        }
        return null;
    }",0
"public boolean hasNextButton() {
        return mNextButton != null;
    }",0
"private int jjMoveStringLiteralDfa1_0(long active0)
{
   try { curChar = input_stream.readChar(); }
   catch(java.io.IOException e) {
      jjStopStringLiteralDfa_0(0, active0);
      return 1;
   }
   switch(curChar)
   {
      case 123:
         if ((active0 & 0x4L) != 0L)
            return jjStopAtPos(1, 2);
         else if ((active0 & 0x8L) != 0L)
            return jjStopAtPos(1, 3);
         break;
      default :
         break;
   }
   return jjStartNfa_0(0, active0);
}",0
"@Override
        public boolean isNdefPushEnabled() throws RemoteException {
            synchronized (NfcService.this) {
                return mState == NfcAdapter.STATE_ON && mIsNdefPushEnabled;
            }
        }",0
"public String getTarget() {
		FolderTreeModel ftm = (FolderTreeModel) selTree.getTreeModel();
		return ftm.getSelectedPath(selTree.getSelectedNode());
	}",0
"@Override
    public T setAll(Headers<? extends K, ? extends V, ?> headers) {
        if (headers != this) {
            for (K key : headers.names()) {
                remove(key);
            }
            addImpl(headers);
        }
        return thisT();
    }",0
"private byte[] getImage(String url) {
        // Try to get the favicon from the url using an HTTP connection from the pool
        // that also allows to configure timeout values (e.g. connect and get data)
        final RequestConfig requestConfig = RequestConfig.custom()
            .setConnectTimeout(5000)
            .setSocketTimeout(5000)
            .build();
        final HttpUriRequest getRequest = RequestBuilder.get(url)
            .setConfig(requestConfig)
            .build();

        try(final CloseableHttpResponse response = client.execute(getRequest)) {
            if(response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {
                final byte[] result = EntityUtils.toByteArray(response.getEntity());

                // Prevent SSRF by checking result (OF-1885)
                if ( !GraphicsUtils.isImage( result ) ) {
                    LOGGER.info( ""Ignoring response to an HTTP request that should have returned an image (but returned something else): {}"", url) ;
                    return null;
                }
                return result;
            }
        } catch (final IOException ex) {
            LOGGER.debug( ""An exception occurred while trying to obtain an image from: {}"", url, ex );
        }

        return null;
    }",1
"protected int getNextNum(String projectId) {
        Issues issue = extIssuesMapper.getNextNum(projectId);
        if (issue == null || issue.getNum() == null) {
            return 100001;
        } else {
            return Optional.of(issue.getNum() + 1).orElse(100001);
        }
    }",0
"@SuppressWarnings(""unchecked"")
    public <N extends DomNode> N querySelector(final String selectors) {
        final DomNodeList<DomNode> list = querySelectorAll(selectors);
        if (!list.isEmpty()) {
            return (N) list.get(0);
        }
        return null;
    }",0
"private void setNoCacheHeaders(HttpServletResponse pResp) {
        pResp.setHeader(""Cache-Control"", ""no-cache"");
        pResp.setHeader(""Pragma"",""no-cache"");
        // Check for a date header and set it accordingly to the recommendations of
        // RFC-2616 (http://tools.ietf.org/html/rfc2616#section-14.21)
        //
        //   ""To mark a response as ""already expired,"" an origin server sends an
        //    Expires date that is equal to the Date header value. (See the rules
        //  for expiration calculations in section 13.2.4.)""
        //
        // See also #71

        long now = System.currentTimeMillis();
        pResp.setDateHeader(""Date"",now);
        // 1h  in the past since it seems, that some servlet set the date header on their
        // own so that it cannot be guaranteed that these headers are really equals.
        // It happened on Tomcat that Date: was finally set *before* Expires: in the final
        // answers some times which seems to be an implementation peculiarity from Tomcat
        pResp.setDateHeader(""Expires"",now - 3600000);
    }",0
"public float getPrimaryHorizontal(int offset, boolean clamped) {
        boolean trailing = primaryIsTrailingPrevious(offset);
        return getHorizontal(offset, trailing, clamped);
    }",0
"@Override
	public String getPosition() {
		return state.position;
	}",0
"public Class<? extends Map> getMapType() {
        return map.getClass();
    }",0
"private void showBouncerIfKeyguard() {
        if (mState == StatusBarState.KEYGUARD || mState == StatusBarState.SHADE_LOCKED) {
            showBouncer();
        }
    }",0
"@Override
    boolean shouldAutoLaunchSingleChoice(TargetInfo target) {
        final Intent intent = target.getResolvedIntent();
        final ResolveInfo resolve = target.getResolveInfo();

        // When GET_CONTENT is handled by the DocumentsUI system component,
        // we're okay automatically launching it, since it offers it's own
        // intent disambiguation UI.
        if (intent != null && Intent.ACTION_GET_CONTENT.equals(intent.getAction())
                && resolve != null && resolve.priority > 0
                && resolve.activityInfo != null && DocumentsContract.PACKAGE_DOCUMENTS_UI
                        .equals(resolve.activityInfo.packageName)) {
            return true;
        }

        return false;
    }",0
"public GridSingleSelect<T> asSingleSelect() {
        return new GridSingleSelect<>(this);
    }",0
"private void writeAppManifest(PackageInfo pkg, File manifestFile,
                boolean withApk, boolean withWidgets) throws IOException {
            // Manifest format. All data are strings ending in LF:
            //     BACKUP_MANIFEST_VERSION, currently 1
            //
            // Version 1:
            //     package name
            //     package's versionCode
            //     platform versionCode
            //     getInstallerPackageName() for this package (maybe empty)
            //     boolean: ""1"" if archive includes .apk; any other string means not
            //     number of signatures == N
            // N*:    signature byte array in ascii format per Signature.toCharsString()
            StringBuilder builder = new StringBuilder(4096);
            StringBuilderPrinter printer = new StringBuilderPrinter(builder);

            printer.println(Integer.toString(BACKUP_MANIFEST_VERSION));
            printer.println(pkg.packageName);
            printer.println(Integer.toString(pkg.versionCode));
            printer.println(Integer.toString(Build.VERSION.SDK_INT));

            String installerName = mPackageManager.getInstallerPackageName(pkg.packageName);
            printer.println((installerName != null) ? installerName : """");

            printer.println(withApk ? ""1"" : ""0"");
            if (pkg.signatures == null) {
                printer.println(""0"");
            } else {
                printer.println(Integer.toString(pkg.signatures.length));
                for (Signature sig : pkg.signatures) {
                    printer.println(sig.toCharsString());
                }
            }

            FileOutputStream outstream = new FileOutputStream(manifestFile);
            outstream.write(builder.toString().getBytes());
            outstream.close();

            // We want the manifest block in the archive stream to be idempotent:
            // each time we generate a backup stream for the app, we want the manifest
            // block to be identical.  The underlying tar mechanism sees it as a file,
            // though, and will propagate its mtime, causing the tar header to vary.
            // Avoid this problem by pinning the mtime to zero.
            manifestFile.setLastModified(0);
        }",0
"private int getCurrentDayLocked() {
        mCal.setTimeInMillis(System.currentTimeMillis());
        final int dayOfYear = mCal.get(Calendar.DAY_OF_YEAR);
        if (mYear != mCal.get(Calendar.YEAR)) {
            mYear = mCal.get(Calendar.YEAR);
            mCal.clear();
            mCal.set(Calendar.YEAR, mYear);
            mYearInDays = (int)(mCal.getTimeInMillis()/86400000);
        }
        return dayOfYear + mYearInDays;
    }",0
"@Deprecated
    public void startKeyguardExitAnimation(long startTime, long fadeoutDuration) {
        startKeyguardExitAnimation(0, startTime, fadeoutDuration, null, null, null, null);
    }",0
"@UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P, trackingBug = 115609023)
    public int getPasswordMinimumLetters(@Nullable ComponentName admin, int userHandle) {
        if (mService != null) {
            try {
                return mService.getPasswordMinimumLetters(admin, userHandle, mParentInstance);
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
        }
        return 0;
    }",0
"private boolean canGetPhoneAccount(String callingPackage, PhoneAccountHandle accountHandle) {
        // Allow default dialer, system dialer and sim call manager to be able to do this without
        // extra permission
        try {
            if (isPrivilegedDialerCalling(callingPackage) || isCallerSimCallManager(
                    accountHandle)) {
                return true;
            }
        } catch (SecurityException e) {
            // ignore
        }

        try {
            mContext.enforceCallingOrSelfPermission(READ_PRIVILEGED_PHONE_STATE, null);
            return true;
        } catch (SecurityException e) {
            // Accessing phone state is gated by a special permission.
            mContext.enforceCallingOrSelfPermission(READ_PHONE_NUMBERS, null);
            return true;
        }
    }",0
"static public String numberToString(Number n)
            throws JSONException {
        if (n == null) {
            throw new JSONException(""Null pointer"");
        }
        testValidity(n);

// Shave off trailing zeros and decimal point, if possible.

        String s = n.toString();
        if (s.indexOf('.') > 0 && s.indexOf('e') < 0 && s.indexOf('E') < 0) {
            while (s.endsWith(""0"")) {
                s = s.substring(0, s.length() - 1);
            }
            if (s.endsWith(""."")) {
                s = s.substring(0, s.length() - 1);
            }
        }
        return s;
    }",0
"void dumpLastANRLocked(PrintWriter pw) {
        pw.println(""ACTIVITY MANAGER LAST ANR (dumpsys activity lastanr)"");
        if (mLastANRState == null) {
            pw.println(""  <no ANR has occurred since boot>"");
        } else {
            pw.println(mLastANRState);
        }
    }",0
"private boolean isLeanbackOnlyDevice() {
        boolean onLeanbackOnly = false;
        try {
            onLeanbackOnly = AppGlobals.getPackageManager().hasSystemFeature(
                    PackageManager.FEATURE_LEANBACK_ONLY);
        } catch (RemoteException e) {
            // noop
        }

        return onLeanbackOnly;
    }",0
"public int getConnectionTimeout() {
        return this.connectionTimeout;
    }",0
"public void attachFile(EntityReference pageReference, String name, InputStream is, boolean failIfExists)
        throws Exception
    {
        EntityReference reference = new EntityReference(name, EntityType.ATTACHMENT, pageReference);

        attachFile(reference, is, failIfExists);
    }",0
"private ParcelableConference parcelable(ConferenceInfo c) {
        return new ParcelableConference.Builder(c.phoneAccount, c.state)
                .setConnectionCapabilities(c.capabilities)
                .setConnectionProperties(c.properties)
                .setConnectionIds(c.connectionIds)
                .setVideoAttributes(c.videoProvider, c.videoState)
                .setConnectTimeMillis(c.connectTimeMillis, c.connectElapsedTimeMillis)
                .setStatusHints(c.statusHints)
                .setExtras(c.extras)
                .build();
    }",0
"@Binds
    BindEventManager bindBindEventManagerImpl(BindEventManagerImpl bindEventManagerImpl);",0
"public Column setRenderer(Renderer<?> renderer) {
            if (!internalSetRenderer(renderer)) {
                throw new IllegalArgumentException(
                        ""Could not find a converter for converting from the model type ""
                                + getModelType()
                                + "" to the renderer presentation type ""
                                + renderer.getPresentationType() + "" (in ""
                                + toString() + "")"");
            }
            return this;
        }",0
"@SystemApi
    @RequiresPermission(android.Manifest.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS)
    public void finalizeWorkProfileProvisioning(
            @NonNull UserHandle managedProfileUser, @Nullable Account migratedAccount) {
        Objects.requireNonNull(managedProfileUser, ""managedProfileUser can't be null"");
        if (mService == null) {
            throw new IllegalStateException(""Could not find DevicePolicyManagerService"");
        }
        try {
            mService.finalizeWorkProfileProvisioning(managedProfileUser, migratedAccount);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }",0
"public void setStatusChangedTitle(String statusChangedTitle) {
		this.statusChangedTitle = statusChangedTitle;
	}",0
"public String[] getModels() {
            return models;
        }",0
"public void setClearCacheMode(String clearCacheMode) {
        logger.trace(""setClearCacheMode: {}"", clearCacheMode);
        this.clearCacheMode = clearCacheMode;
    }",0
"@Override
        public Policy getNotificationPolicy(String pkg) {
            enforcePolicyAccess(pkg, ""getNotificationPolicy"");
            final long identity = Binder.clearCallingIdentity();
            try {
                return mZenModeHelper.getNotificationPolicy();
            } finally {
                Binder.restoreCallingIdentity(identity);
            }
        }",0
"public ApiClient setReadTimeout(int readTimeout) {
    this.readTimeout = readTimeout;
    httpClient.property(ClientProperties.READ_TIMEOUT, readTimeout);
    return this;
  }",0
"void timeoutUserSwitch(UserStartedState uss, int oldUserId, int newUserId) {
        synchronized (this) {
            Slog.w(TAG, ""User switch timeout: from "" + oldUserId + "" to "" + newUserId);
            sendContinueUserSwitchLocked(uss, oldUserId, newUserId);
        }
    }",0
"public static boolean jsFunction_isSelfSignupEnabledForTenant(Context cx,
        Scriptable thisObj, Object[] args, Function funObj) {

    	boolean status = false;
    	if (!isStringArray(args)) {
            return status;
        }

        String tenantDomain = args[0].toString();
        try {
	        UserRegistrationConfigDTO signupConfig =
	        		SelfSignUpUtil.getSignupConfiguration(tenantDomain);
            if (signupConfig != null) {
                status = signupConfig.isSignUpEnabled();
            }
        } catch (APIManagementException e) {
	       log.error(""error while loading configuration from registry"", e);
        }

		return status;

    }",0
"protected Map<String, Object> newOortHandshakeFields(String cometURL, String oortAliasURL) {
        Map<String, Object> fields = new HashMap<>(1);
        Map<String, Object> ext = new HashMap<>(1);
        fields.put(Message.EXT_FIELD, ext);
        Map<String, Object> oortExt = new HashMap<>(4);
        ext.put(EXT_OORT_FIELD, oortExt);
        oortExt.put(EXT_OORT_URL_FIELD, getURL());
        oortExt.put(EXT_OORT_ID_FIELD, getId());
        String b64Secret = encodeSecret(getSecret());
        oortExt.put(EXT_OORT_SECRET_FIELD, b64Secret);
        oortExt.put(EXT_COMET_URL_FIELD, cometURL);
        if (oortAliasURL != null) {
            oortExt.put(EXT_OORT_ALIAS_URL_FIELD, oortAliasURL);
        }
        return fields;
    }",0
"@Deprecated
    public XWikiDocument getDocument(String spaces, String fullname, XWikiContext context) throws XWikiException
    {
        int dotPosition = fullname.lastIndexOf('.');
        if (dotPosition != -1) {
            String spaceFromFullname = fullname.substring(0, dotPosition);
            String name = fullname.substring(dotPosition + 1);
            if (name.equals("""")) {
                name = getDefaultPage(context);
            }
            return getDocument(spaceFromFullname + ""."" + name, context);
        } else {
            return getDocument(spaces + ""."" + fullname, context);
        }
    }",0
"void registerTagObject(TagEndpoint tag) {
        synchronized (this) {
            mObjectMap.put(tag.getHandle(), tag);
        }
    }",0
"@Override
    public void startAddAccountSession(
            final IAccountManagerResponse response,
            final String accountType,
            final String authTokenType,
            final String[] requiredFeatures,
            final boolean expectActivityLaunch,
            final Bundle optionsIn) {
        Bundle.setDefusable(optionsIn, true);
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            Log.v(TAG,
                    ""startAddAccountSession: accountType "" + accountType
                    + "", response "" + response
                    + "", authTokenType "" + authTokenType
                    + "", requiredFeatures "" + Arrays.toString(requiredFeatures)
                    + "", expectActivityLaunch "" + expectActivityLaunch
                    + "", caller's uid "" + Binder.getCallingUid()
                    + "", pid "" + Binder.getCallingPid());
        }
        Preconditions.checkArgument(response != null, ""response cannot be null"");
        Preconditions.checkArgument(accountType != null, ""accountType cannot be null"");

        final int uid = Binder.getCallingUid();
        final int userId = UserHandle.getUserId(uid);
        if (!canUserModifyAccounts(userId, uid)) {
            try {
                response.onError(AccountManager.ERROR_CODE_USER_RESTRICTED,
                        ""User is not allowed to add an account!"");
            } catch (RemoteException re) {
            }
            showCantAddAccount(AccountManager.ERROR_CODE_USER_RESTRICTED, userId);
            return;
        }
        if (!canUserModifyAccountsForType(userId, accountType, uid)) {
            try {
                response.onError(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,
                        ""User cannot modify accounts of this type (policy)."");
            } catch (RemoteException re) {
            }
            showCantAddAccount(AccountManager.ERROR_CODE_MANAGEMENT_DISABLED_FOR_ACCOUNT_TYPE,
                    userId);
            return;
        }
        final int pid = Binder.getCallingPid();
        final Bundle options = (optionsIn == null) ? new Bundle() : optionsIn;
        options.putInt(AccountManager.KEY_CALLER_UID, uid);
        options.putInt(AccountManager.KEY_CALLER_PID, pid);

        // Check to see if the Password should be included to the caller.
        String callerPkg = options.getString(AccountManager.KEY_ANDROID_PACKAGE_NAME);
        boolean isPasswordForwardingAllowed = checkPermissionAndNote(
                callerPkg, uid, Manifest.permission.GET_PASSWORD);

        final long identityToken = clearCallingIdentity();
        try {
            UserAccounts accounts = getUserAccounts(userId);
            logRecordWithUid(accounts, AccountsDb.DEBUG_ACTION_CALLED_START_ACCOUNT_ADD,
                    AccountsDb.TABLE_ACCOUNTS, uid);
            new StartAccountSession(
                    accounts,
                    response,
                    accountType,
                    expectActivityLaunch,
                    null /* accountName */,
                    false /* authDetailsRequired */,
                    true /* updateLastAuthenticationTime */,
                    isPasswordForwardingAllowed) {
                @Override
                public void run() throws RemoteException {
                    mAuthenticator.startAddAccountSession(this, mAccountType, authTokenType,
                            requiredFeatures, options);
                    logAddAccountMetrics(callerPkg, accountType, requiredFeatures, authTokenType);
                }

                @Override
                protected String toDebugString(long now) {
                    String requiredFeaturesStr = TextUtils.join("","", requiredFeatures);
                    return super.toDebugString(now) + "", startAddAccountSession"" + "", accountType ""
                            + accountType + "", requiredFeatures ""
                            + (requiredFeatures != null ? requiredFeaturesStr : null);
                }
            }.bind();
        } finally {
            restoreCallingIdentity(identityToken);
        }
    }",0
"@NonNull ActiveAdmin getOrganizationOwnedProfileOwnerLocked(final CallerIdentity caller) {
        Preconditions.checkCallAuthorization(
                mOwners.isProfileOwnerOfOrganizationOwnedDevice(caller.getUserId()),
                ""Caller %s is not an admin of an org-owned device"",
                caller.getComponentName());
        final ActiveAdmin profileOwner = getProfileOwnerLocked(caller.getUserId());

        return profileOwner;
    }",0
"@Override
    public boolean setInstallLocation(int loc) {
        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.WRITE_SECURE_SETTINGS,
                null);
        if (getInstallLocation() == loc) {
            return true;
        }
        if (loc == PackageHelper.APP_INSTALL_AUTO || loc == PackageHelper.APP_INSTALL_INTERNAL
                || loc == PackageHelper.APP_INSTALL_EXTERNAL) {
            android.provider.Settings.Global.putInt(mContext.getContentResolver(),
                    android.provider.Settings.Global.DEFAULT_INSTALL_LOCATION, loc);
            return true;
        }
        return false;
   }",0
"@Override
        public void onBiometricAuthenticated(int userId, BiometricSourceType biometricSourceType,
                boolean isStrongBiometric) {
            if (mLockPatternUtils.isSecure(userId)) {
                mLockPatternUtils.getDevicePolicyManager().reportSuccessfulBiometricAttempt(
                        userId);
            }
        }",0
"@Override
    public void revokeUriPermission(IApplicationThread caller, String targetPackage, Uri uri,
            final int modeFlags, int userId) {
        enforceNotIsolatedCaller(""revokeUriPermission"");
        synchronized(this) {
            final ProcessRecord r = getRecordForAppLocked(caller);
            if (r == null) {
                throw new SecurityException(""Unable to find app for caller ""
                        + caller
                        + "" when revoking permission to uri "" + uri);
            }
            if (uri == null) {
                Slog.w(TAG, ""revokeUriPermission: null uri"");
                return;
            }

            if (!Intent.isAccessUriMode(modeFlags)) {
                return;
            }

            final String authority = uri.getAuthority();
            final ProviderInfo pi = getProviderInfoLocked(authority, userId,
                    MATCH_DIRECT_BOOT_AWARE | MATCH_DIRECT_BOOT_UNAWARE);
            if (pi == null) {
                Slog.w(TAG, ""No content provider found for permission revoke: ""
                        + uri.toSafeString());
                return;
            }

            revokeUriPermissionLocked(targetPackage, r.uid, new GrantUri(userId, uri, false),
                    modeFlags);
        }
    }",0
"@Override
    public void resizeTask(int taskId, Rect bounds) {
        enforceCallingPermission(android.Manifest.permission.MANAGE_ACTIVITY_STACKS,
                ""resizeTask()"");
        long ident = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                TaskRecord task = mStackSupervisor.anyTaskForIdLocked(taskId);
                if (task == null) {
                    Slog.w(TAG, ""resizeTask: taskId="" + taskId + "" not found"");
                    return;
                }
                mStackSupervisor.resizeTaskLocked(task, bounds);
            }
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }",0
"private void parseDiceSides(final Node diceSides) {
    if (diceSides == null) {
      data.setDiceSides(6);
    } else {
      data.setDiceSides(Integer.parseInt(((Element) diceSides).getAttribute(""value"")));
    }
  }",0
private static native @Nullable Configuration[] nativeGetSizeAndUiModeConfigurations(long ptr);,0
"protected void handleUserSwitchComplete(int userId) {
        mSwitchingUser = false;
        updateFingerprintListeningState();

        for (int i = 0; i < mCallbacks.size(); i++) {
            KeyguardUpdateMonitorCallback cb = mCallbacks.get(i).get();
            if (cb != null) {
                cb.onUserSwitchComplete(userId);
            }
        }
    }",0
"boolean isSurfaceShowing() {
        return mLastSurfaceShowing;
    }",0
"private void initHttpUtil() {
        httpUtilButton.addActionListener(e -> {
            String t;
            if (LANG == CHINESE) {
                t = ""Http工具"";
            } else {
                t = ""Repeater"";
            }
            JFrame frame = new JFrame(t);
            frame.setContentPane(new HttpUtilForm().httpUtilPanel);
            frame.setResizable(false);
            frame.pack();
            frame.setVisible(true);
        });
    }",0
"private void deleteNamespace(String namespace, TaskLogger jobLogger) {
		try {
			Commandline cmd = newKubeCtl();
			cmd.timeout(NAMESPACE_DELETION_TIMEOUT).addArgs(""delete"", ""namespace"", namespace);
			cmd.execute(new LineConsumer() {
	
				@Override
				public void consume(String line) {
					logger.debug(line);
				}
				
			}, new LineConsumer() {
	
				@Override
				public void consume(String line) {
					jobLogger.error(""Kubernetes: "" + line);
				}
				
			}).checkReturnCode();
		} catch (Exception e) {
			if (ExceptionUtils.find(e, TimeoutException.class) == null)
				throw ExceptionUtils.unchecked(e);
			else
				jobLogger.error(""Timed out deleting namespace"");
		}
	}",0
"@Override
    protected boolean wantOnSelectionChangedNotifications()
    {
      return true;
    }",0
"private String readStringInternal(boolean allowML) throws IOException {
    // callees make sure that (current=='""' || current=='\'')
    int exitCh = current;
    read();
    startCapture();
    while (current!=exitCh) {
      if (current=='\\') readEscape();
      else if (current<0x20) throw expected(""valid string character"");
      else read();
    }
    String string=endCapture();
    read();

    if (allowML && exitCh=='\'' && current=='\'' && string.length()==0) {
      // ''' indicates a multiline string
      read();
      return readMlString();
    } else return string;
  }",0
"public void unlinkDeathRecipient() {
        if (deathRecipient != null && thread != null) {
            thread.asBinder().unlinkToDeath(deathRecipient, 0);
        }
        deathRecipient = null;
    }",0
"private static void executeAs(final ServletRequest request, final ServletResponse response, final FilterChain chain, Subject subject) {
        try {
            Subject.doAs(subject, new PrivilegedExceptionAction<Object>() {
                @Override
                public Object run() throws Exception {
                    chain.doFilter(request, response);
                    return null;
                }
            });
        } catch (PrivilegedActionException e) {
            LOG.info(""Failed to invoke action "" + ((HttpServletRequest) request).getPathInfo() + "" due to:"", e);
        }
    }",0
"private void fillStatistics() {
        getRequest().setAttribute(""commCount"", new Comment().count());
        getRequest().setAttribute(""toDayCommCount"", new Comment().countToDayComment());
        getRequest().setAttribute(""clickCount"", new Log().sumClick());
        getRequest().setAttribute(""articleCount"", new Log().adminCount());
    }",0
"@Override
	public void setTextContent(String textContent) throws DOMException {
		doc.setTextContent(textContent);
	}",0
"public void setToken(@Nullable String token) {
		this.token = token;
	}",0
"@Override
    public void beginTableRow(Map<String, String> parameters)
    {
        getXHTMLWikiPrinter().printXMLStartElement(""tr"", parameters);
    }",0
"public FormValidation doCheckCustomWorkspace(@QueryParameter(value=""customWorkspace.directory"") String customWorkspace){
        	if(Util.fixEmptyAndTrim(customWorkspace)==null)
        		return FormValidation.error(Messages.AbstractProject_CustomWorkspaceEmpty());
        	else
        		return FormValidation.ok();
        }",0
"protected InternetResource createStaticResource(String path)
			throws ResourceNotFoundException, FacesException {
		FacesContext context = FacesContext.getCurrentInstance();
		if (null != context) {
			if (context.getExternalContext().getContext() instanceof ServletContext) {
				ServletContext servletContext = (ServletContext) context
						.getExternalContext().getContext();
				InputStream in = servletContext.getResourceAsStream(path);
				if (null != in) {
					InternetResourceBase res = new StaticResource(path);
					setRenderer(res, path);
					res.setLastModified(new Date(getStartTime()));
					addResource(path, res);
					try {
						in.close();
					} catch (IOException e) {
					}
					return res;
				}
			}
		}
		throw new ResourceNotFoundException(Messages.getMessage(
				Messages.STATIC_RESOURCE_NOT_FOUND_ERROR, path));
	}",0
"@Override
    public List<Service> getAllBrowserServices(long startTimestamp, long endTimestamp) throws IOException {
        StringBuilder sql = new StringBuilder();
        List<Object> condition = new ArrayList<>(5);
        sql.append(""select * from "").append(ServiceTraffic.INDEX_NAME).append("" where "");
        sql.append(ServiceTraffic.NODE_TYPE).append(""=?"");
        condition.add(NodeType.Browser.value());
        sql.append("" limit "").append(metadataQueryMaxSize);

        try (Connection connection = h2Client.getConnection()) {
            try (ResultSet resultSet = h2Client.executeQuery(
                connection, sql.toString(), condition.toArray(new Object[0]))) {
                return buildServices(resultSet);
            }
        } catch (SQLException e) {
            throw new IOException(e);
        }
    }",0
"@Test
  public void selectStreamTxException(TestContext context) {
    postgresClient().selectStream(null, ""SELECT 1"", context.asyncAssertFailure());
  }",0
"public String getPublicId() { 
        return fCurrentEntity != null ? fCurrentEntity.publicId : null; 
    }",0
"@Override
    public int addAppTask(IBinder activityToken, Intent intent,
            ActivityManager.TaskDescription description, Bitmap thumbnail) throws RemoteException {
        final int callingUid = Binder.getCallingUid();
        final long callingIdent = Binder.clearCallingIdentity();

        try {
            synchronized (this) {
                ActivityRecord r = ActivityRecord.isInStackLocked(activityToken);
                if (r == null) {
                    throw new IllegalArgumentException(""Activity does not exist; token=""
                            + activityToken);
                }
                ComponentName comp = intent.getComponent();
                if (comp == null) {
                    throw new IllegalArgumentException(""Intent "" + intent
                            + "" must specify explicit component"");
                }
                if (thumbnail.getWidth() != mThumbnailWidth
                        || thumbnail.getHeight() != mThumbnailHeight) {
                    throw new IllegalArgumentException(""Bad thumbnail size: got ""
                            + thumbnail.getWidth() + ""x"" + thumbnail.getHeight() + "", require ""
                            + mThumbnailWidth + ""x"" + mThumbnailHeight);
                }
                if (intent.getSelector() != null) {
                    intent.setSelector(null);
                }
                if (intent.getSourceBounds() != null) {
                    intent.setSourceBounds(null);
                }
                if ((intent.getFlags()&Intent.FLAG_ACTIVITY_NEW_DOCUMENT) != 0) {
                    if ((intent.getFlags()&Intent.FLAG_ACTIVITY_RETAIN_IN_RECENTS) == 0) {
                        // The caller has added this as an auto-remove task...  that makes no
                        // sense, so turn off auto-remove.
                        intent.addFlags(Intent.FLAG_ACTIVITY_RETAIN_IN_RECENTS);
                    }
                } else if ((intent.getFlags()&Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
                    // Must be a new task.
                    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                }
                if (!comp.equals(mLastAddedTaskComponent) || callingUid != mLastAddedTaskUid) {
                    mLastAddedTaskActivity = null;
                }
                ActivityInfo ainfo = mLastAddedTaskActivity;
                if (ainfo == null) {
                    ainfo = mLastAddedTaskActivity = AppGlobals.getPackageManager().getActivityInfo(
                            comp, 0, UserHandle.getUserId(callingUid));
                    if (ainfo.applicationInfo.uid != callingUid) {
                        throw new SecurityException(
                                ""Can't add task for another application: target uid=""
                                + ainfo.applicationInfo.uid + "", calling uid="" + callingUid);
                    }
                }

                TaskRecord task = new TaskRecord(this, mStackSupervisor.getNextTaskId(), ainfo,
                        intent, description);

                int trimIdx = trimRecentsForTaskLocked(task, false);
                if (trimIdx >= 0) {
                    // If this would have caused a trim, then we'll abort because that
                    // means it would be added at the end of the list but then just removed.
                    return INVALID_TASK_ID;
                }

                final int N = mRecentTasks.size();
                if (N >= (ActivityManager.getMaxRecentTasksStatic()-1)) {
                    final TaskRecord tr = mRecentTasks.remove(N - 1);
                    tr.removedFromRecents();
                }

                task.inRecents = true;
                mRecentTasks.add(task);
                r.task.stack.addTask(task, false, false);

                task.setLastThumbnail(thumbnail);
                task.freeLastThumbnail();

                return task.taskId;
            }
        } finally {
            Binder.restoreCallingIdentity(callingIdent);
        }
    }",0
"private static void addOpenUpgradableSecurityTypeIfNecessary(WifiConfiguration config) {
        if (!config.isSecurityType(WifiConfiguration.SECURITY_TYPE_OPEN)) return;
        if (config.isSecurityType(WifiConfiguration.SECURITY_TYPE_OWE)) return;

        Log.d(TAG, ""Add upgradable OWE configuration."");
        SecurityParams oweParams = SecurityParams.createSecurityParamsBySecurityType(
                WifiConfiguration.SECURITY_TYPE_OWE);
        oweParams.setIsAddedByAutoUpgrade(true);
        config.addSecurityParams(oweParams);
    }",0
"public static ComplexData convertToComplexData(HttpServletRequest request, String name) {
		MultipartHttpServletRequest mRequest = (MultipartHttpServletRequest) request;
		MultipartFile file = mRequest.getFile(name);
		if (file != null && file.getSize() > 0) {
			try {
				return new ComplexData(file.getOriginalFilename(), file.getInputStream());
			}
			catch (IOException e) {
				throw new IllegalArgumentException(e);
			}
		} else {
			return null;
		}
	}",0
"public String getDisplayTitle()
    {
        return this.doc.getRenderedTitle(getXWikiContext());
    }",0
"private static <T> void checkCompatibleConfigs(String type, T c1, T c2, ConfigChecker<T> checker) {
        if (!checker.check(c1, c2)) {
            throw new HazelcastException(format(""Incompatible "" + type + "" config :\n{0}\n vs \n{1}"", c1, c2));
        }
    }",0
"public List<String> getIncludedMacros(XWikiContext context)
    {
        return context.getWiki().getIncludedMacros(getSpace(), getContent(), context);
    }",0
"@Override
	public boolean supports(Type genericType) {
		if (genericType instanceof ParameterizedType) {
			ParameterizedType parameterizedType = (ParameterizedType) genericType;
			if (JAXBElement.class.equals(parameterizedType.getRawType()) &&
					parameterizedType.getActualTypeArguments().length == 1) {
				Type typeArgument = parameterizedType.getActualTypeArguments()[0];
				if (typeArgument instanceof Class) {
					Class<?> classArgument = (Class<?>) typeArgument;
					if (JdkVersion.getMajorJavaVersion() >= JdkVersion.JAVA_17 && classArgument.isArray()) {
						return classArgument.getComponentType().equals(Byte.TYPE);
					}
					else {
						return (isPrimitiveWrapper(classArgument) || isStandardClass(classArgument) ||
								supportsInternal(classArgument, false));
					}
				}
				else if (JdkVersion.getMajorJavaVersion() <= JdkVersion.JAVA_16 &&
						typeArgument instanceof GenericArrayType) {
					// see http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=5041784
					GenericArrayType arrayType = (GenericArrayType) typeArgument;
					return arrayType.getGenericComponentType().equals(Byte.TYPE);
				}
			}
		}
		else if (genericType instanceof Class) {
			Class<?> clazz = (Class<?>) genericType;
			return supportsInternal(clazz, this.checkForXmlRootElement);
		}
		return false;
	}",0
"@Override
    public DSpaceObject getAdminObject(Context context, Collection collection, int action) throws SQLException {
        DSpaceObject adminObject = null;
        Community community = null;
        List<Community> communities = collection.getCommunities();
        if (CollectionUtils.isNotEmpty(communities)) {
            community = communities.get(0);
        }

        switch (action) {
            case Constants.REMOVE:
                if (AuthorizeConfiguration.canCollectionAdminPerformItemDeletion()) {
                    adminObject = collection;
                } else if (AuthorizeConfiguration.canCommunityAdminPerformItemDeletion()) {
                    adminObject = community;
                }
                break;

            case Constants.DELETE:
                if (AuthorizeConfiguration.canCommunityAdminPerformSubelementDeletion()) {
                    adminObject = community;
                }
                break;
            default:
                adminObject = collection;
                break;
        }
        return adminObject;
    }",0
"public boolean isInjectingAccessibilityScript() {
        return mAccessibilityInjector.accessibilityIsAvailable();
    }",0
"void writeBroadcastsToProtoLocked(ProtoOutputStream proto) {
        if (mRegisteredReceivers.size() > 0) {
            Iterator it = mRegisteredReceivers.values().iterator();
            while (it.hasNext()) {
                ReceiverList r = (ReceiverList)it.next();
                r.writeToProto(proto, ActivityManagerServiceDumpBroadcastsProto.RECEIVER_LIST);
            }
        }
        mReceiverResolver.writeToProto(proto, ActivityManagerServiceDumpBroadcastsProto.RECEIVER_RESOLVER);
        for (BroadcastQueue q : mBroadcastQueues) {
            q.writeToProto(proto, ActivityManagerServiceDumpBroadcastsProto.BROADCAST_QUEUE);
        }
        for (int user=0; user<mStickyBroadcasts.size(); user++) {
            long token = proto.start(ActivityManagerServiceDumpBroadcastsProto.STICKY_BROADCASTS);
            proto.write(StickyBroadcastProto.USER, mStickyBroadcasts.keyAt(user));
            for (Map.Entry<String, ArrayList<Intent>> ent
                    : mStickyBroadcasts.valueAt(user).entrySet()) {
                long actionToken = proto.start(StickyBroadcastProto.ACTIONS);
                proto.write(StickyBroadcastProto.StickyAction.NAME, ent.getKey());
                for (Intent intent : ent.getValue()) {
                    intent.writeToProto(proto, StickyBroadcastProto.StickyAction.INTENTS,
                            false, true, true, false);
                }
                proto.end(actionToken);
            }
            proto.end(token);
        }

        long handlerToken = proto.start(ActivityManagerServiceDumpBroadcastsProto.HANDLER);
        proto.write(ActivityManagerServiceDumpBroadcastsProto.MainHandler.HANDLER, mHandler.toString());
        mHandler.getLooper().writeToProto(proto,
            ActivityManagerServiceDumpBroadcastsProto.MainHandler.LOOPER);
        proto.end(handlerToken);
    }",0
"@Override
    void switchUser(int userId) {
        super.switchUser(userId);

        if (showToCurrentUser()) {
            setPolicyVisibilityFlag(VISIBLE_FOR_USER);
        } else {
            if (DEBUG_VISIBILITY) Slog.w(TAG_WM, ""user changing, hiding "" + this
                    + "", attrs="" + mAttrs.type + "", belonging to "" + mOwnerUid);
            clearPolicyVisibilityFlag(VISIBLE_FOR_USER);
        }
    }",0
"public void removeContentProvider(IBinder connection, boolean stable) throws RemoteException;",0
"public FormValidation doCheckUrl(@QueryParameter String value) {
        if(value.startsWith(""http://localhost""))
            return FormValidation.warning(Messages.Mailer_Localhost_Error());
        return FormValidation.ok();
    }",0
"public HttpRequest queryEncoding(final String encoding) {
		this.queryEncoding = encoding;
		return this;
	}",0
"public ParceledListSlice<NotificationChannel> getNotificationChannelsBypassingDnd(String pkg,
            int uid) {
        try {
            return sINM.getNotificationChannelsBypassingDnd(pkg, uid);
        } catch (Exception e) {
            Log.w(TAG, ""Error calling NoMan"", e);
            return ParceledListSlice.emptyList();
        }
    }",0
"public boolean copyDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,
        String wikilocale, boolean resetHistory, boolean overwrite) throws XWikiException
    {
        // In order to copy the source document the user must have at least the right to view it.
        if (hasAccessLevel(""view"", getDefaultStringEntityReferenceSerializer().serialize(sourceDocumentReference))) {
            String targetDocStringRef = getDefaultStringEntityReferenceSerializer().serialize(targetDocumentReference);
            // To create the target document the user must have edit rights. If the target document exists and the user
            // wants to overwrite it then he needs delete right.
            // Note: We have to check if the target document exists before checking the delete right because delete
            // right is denied if not explicitly specified.
            if (hasAccessLevel(""edit"", targetDocStringRef)
                && (!overwrite || !exists(targetDocumentReference) || hasAccessLevel(""delete"", targetDocStringRef))) {
                // Reset creation data otherwise the required rights for page copy need to be reconsidered.
                return this.xwiki.copyDocument(sourceDocumentReference, targetDocumentReference, wikilocale,
                    resetHistory, overwrite, true, getXWikiContext());
            }
        }

        return false;
    }",0
"@POST
	@Operation(summary = ""Post attachment"", description = ""Upload the attachment of a message, as parameter."")
	@ApiResponse(responseCode = ""200"", description = ""Ok."")
	@ApiResponse(responseCode = ""404"", description = "" The identity or the portrait not found"")
	@Path(""posts/{messageKey}/attachments"")
	@Consumes(MediaType.MULTIPART_FORM_DATA)
	@Produces({MediaType.APPLICATION_XML, MediaType.APPLICATION_JSON})
	public Response replyToPostAttachment(@PathParam(""messageKey"") Long messageKey, @Context HttpServletRequest request) {
		InputStream in = null;
		MultipartReader partsReader = null;	
		try {
			partsReader = new MultipartReader(request);
			File tmpFile = partsReader.getFile();
			in = new FileInputStream(tmpFile);
			String filename = partsReader.getValue(""filename"");
			return attachToPost(messageKey, filename, in, request);
		} catch (FileNotFoundException e) {
			log.error("""", e);
			return Response.serverError().status(Status.INTERNAL_SERVER_ERROR).build();
		} finally {
			MultipartReader.closeQuietly(partsReader);
			IOUtils.closeQuietly(in);
		}
	}",0
"public Document getDocument(DocumentReference reference, String revision) throws XWikiException
    {
        try {
            if (reference != null && getContextualAuthorizationManager().hasAccess(Right.VIEW, reference)) {
                DocumentRevisionProvider revisionProvider = getDocumentRevisionProvider();
                revisionProvider.checkAccess(Right.VIEW, CurrentUserReference.INSTANCE, reference, revision);
                XWikiDocument documentRevision = revisionProvider.getRevision(reference, revision);

                if (documentRevision != null) {
                    return new Document(documentRevision, this.context);
                }
            }
        } catch (AuthorizationException e) {
            LOGGER.info(""Access denied for loading revision [{}] of document [{}]: [{}]"", revision, reference,
                ExceptionUtils.getRootCauseMessage(e));
        } catch (Exception e) {
            LOGGER.error(""Failed to access revision [{}] of document {}"", revision, reference, e);
        }

        return null;
    }",1
"Endpoint getEndpoint() {
        return endpoint;
    }",0
"public void setManagedProfileCallerIdAccessPolicy(@Nullable PackagePolicy policy) {
        throwIfParentInstance(""setManagedProfileCallerIdAccessPolicy"");
        if (mService != null) {
            try {
                mService.setManagedProfileCallerIdAccessPolicy(policy);
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
        }
    }",0
"public void grantUriPermissionFromOwner(IBinder owner, int fromUid, String targetPkg,
            Uri uri, int mode, int sourceUserId, int targetUserId) throws RemoteException;",0
"public void writeMessageBegin(TMessage message) throws TException {
    if (message == null) {
      throw new TException(""Can't write 'null' message"");
    }

    if (strictWrite_) {
      int version = VERSION_1 | message.type;
      writeI32(version);
      writeString(message.name);
      writeI32(message.seqid);
    } else {
      writeString(message.name);
      writeByte(message.type);
      writeI32(message.seqid);
    }
  }",0
"private void fixedIntToBytes(int n, byte[] buf, int off) {
    buf[off + 0] = (byte) ((n >> 24) & 0xff);
    buf[off + 1] = (byte) ((n >> 16) & 0xff);
    buf[off + 2] = (byte) ((n >> 8) & 0xff);
    buf[off + 3] = (byte) (n & 0xff);
  }",0
"@Override
        public int hashCode() {
            return (key == null ? 0 : key.hashCode()) ^ AsciiString.hashCode(value);
        }",0
"public TStruct readStructBegin(
      Map<Integer, com.facebook.thrift.meta_data.FieldMetaData> metaDataMap) throws TException {
    lastField_.push(lastFieldId_);
    lastFieldId_ = 0;
    return ANONYMOUS_STRUCT;
  }",0
"@Override
	public List<Admin> getAllAdminInfo() {
		List<Admin> adminList = new ArrayList<>();
		String sql = ""select * from admin_table"";
		try {
			ps = DbUtil.getConnection().prepareStatement(sql);
			ResultSet rs = ps.executeQuery();
			while (rs.next()) {
				Admin admin = new Admin();
				admin.setId(rs.getInt(""id""));
				admin.setAdminName(rs.getString(""admin_name""));
				admin.setPassword(rs.getString(""password""));
				adminList.add(admin);
			}
		} catch (ClassNotFoundException | SQLException e) {
			e.printStackTrace();
		}
		return adminList;
	}",0
"private Reader getReader(final XMLInputSource inputSource) {
        Reader reader = inputSource.getCharacterStream();
        if (reader == null) {
        	try {
				return new InputStreamReader(inputSource.getByteStream(), fJavaEncoding);
			}
        	catch (final UnsupportedEncodingException e) {
				// should not happen as this encoding is already used to parse the ""main"" source
			}
        }
        return reader;
	}",0
"@Override
        public void logout() {
            // ignore
        }",0
"private static void parseCSSRules(Element root, Map<String, Property> cssRules1, Map<String, AntiSamyPattern> commonRegularExpressions1) throws PolicyException {

        for (Element ele : getByTagName(root, ""property"")){

            String name = getAttributeValue(ele, ""name"");
            String description = getAttributeValue(ele, ""description"");


            List<Pattern> allowedRegexp3 = getAllowedRegexp3(commonRegularExpressions1, ele, name);

            List<String> allowedValue = new ArrayList<String>();
            for (Element literalNode : getGrandChildrenByTagName(ele, ""literal-list"", ""literal"")) {
                allowedValue.add(getAttributeValue(literalNode, ""value""));
            }

            List<String> shortHandRefs = new ArrayList<String>();
            for (Element shorthandNode : getGrandChildrenByTagName(ele, ""shorthand-list"", ""shorthand"")) {
                shortHandRefs.add(getAttributeValue(shorthandNode, ""name""));
            }

            String onInvalid = getAttributeValue(ele, ""onInvalid"");
            final String onInvalidStr;
            if (onInvalid != null && onInvalid.length() > 0) {
                onInvalidStr = onInvalid;
            } else {
                onInvalidStr = DEFAULT_ONINVALID;
            }
            Property property = new Property(name,allowedRegexp3, allowedValue, shortHandRefs, description, onInvalidStr );



            cssRules1.put(name.toLowerCase(), property);

        }
    }",0
"@Override
    public R getBuildByNumber(int n) {
        return builds.getByNumber(n);
    }",0
"public void attachFile(List<String> spaces, String page, String name, InputStream is, boolean failIfExists)
        throws Exception
    {
        AttachmentReference reference =
            new AttachmentReference(name, new DocumentReference(getCurrentWiki(), spaces, page));

        attachFile(reference, is, failIfExists);
    }",0
"private int countPendingUpdates(ArrayList<RestoreUpdateRecord> updates) {
            int pending = 0;
            final int N = updates.size();
            for (int i = 0; i < N; i++) {
                RestoreUpdateRecord r = updates.get(i);
                if (!r.notified) {
                    pending++;
                }
            }
            return pending;
        }",0
"@Override
        public ServletContext getServletContext() {
            return null;
        }",0
"protected String computeCurrentFolder() {

        String currentFolder = getSettings().getExplorerResource();
        if (currentFolder == null) {
            // set current folder to root folder
            try {
                currentFolder = getCms().getSitePath(getCms().readFolder(""/"", CmsResourceFilter.IGNORE_EXPIRATION));
            } catch (CmsException e) {
                // can usually be ignored
                if (LOG.isInfoEnabled()) {
                    LOG.info(e);
                }
                currentFolder = ""/"";
            }
        }
        if (!currentFolder.endsWith(""/"")) {
            // add folder separator to currentFolder
            currentFolder += ""/"";
        }
        return currentFolder;
    }",0
"public static InputSource resolveEntity(final String systemId, URL baseUrl) throws IOException, SAXException {
        InputSource source;

        // Can't resolve public id, but might be able to resolve relative
        // system id, since we have a base URI.
        if (systemId != null && baseUrl != null) {
            URL url;

            try {
                url = new URL(baseUrl, systemId);
                source = new InputSource(url.openStream());
                source.setSystemId(systemId);
                return source;
            } catch (MalformedURLException except) {
                try {
                    String absURL = URIUtils.resolveAsString(systemId, baseUrl.toString());
                    url = new URL(absURL);
                    source = new InputSource(url.openStream());
                    source.setSystemId(systemId);
                    return source;
                } catch (MalformedURLException ex2) {
                    // nothing to do
                }
            } catch (java.io.FileNotFoundException fnfe) {
                try {
                    String absURL = URIUtils.resolveAsString(systemId, baseUrl.toString());
                    url = new URL(absURL);
                    source = new InputSource(url.openStream());
                    source.setSystemId(systemId);
                    return source;
                } catch (MalformedURLException ex2) {
                    // nothing to do
                }
            }
            return null;
        }

        // No resolving.
        return null;
    }",0
"public byte[] getMetadata() throws IOException {
        PdfObject obj = getPdfObject(catalog.get(PdfName.METADATA));
        if (!(obj instanceof PRStream))
            return null;
        RandomAccessFileOrArray rf = getSafeFile();
        byte b[] = null;
        try {
            rf.reOpen();
            b = getStreamBytes((PRStream)obj, rf);
        }
        finally {
            try {
                rf.close();
            }
            catch (Exception e) {
                // empty on purpose
            }
        }
        return b;
    }",0
"public int getHoldability() throws SQLException {
    throw org.postgresql.Driver.notImplemented(this.getClass(), ""getHoldability()"");
  }",0
"private boolean checkAndHandleLinkedNetworkRoaming(String associatedBssid) {
        if (!mContext.getResources().getBoolean(R.bool.config_wifiEnableLinkedNetworkRoaming)) {
            return false;
        }

        ScanResult scanResult = mScanRequestProxy.getScanResult(associatedBssid);
        if (scanResult == null) {
            return false;
        }

        WifiConfiguration config = mWifiConfigManager
                .getSavedNetworkForScanResult(scanResult);
        if (config == null || !config.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_PSK)
                || mLastNetworkId == config.networkId) {
            return false;
        }

        mIsLinkedNetworkRoaming = true;
        setTargetBssid(config, associatedBssid);
        mTargetNetworkId = config.networkId;
        mTargetWifiConfiguration = config;
        mLastNetworkId = WifiConfiguration.INVALID_NETWORK_ID;
        sendNetworkChangeBroadcast(DetailedState.CONNECTING);
        mWifiInfo.setFrequency(scanResult.frequency);
        mWifiInfo.setBSSID(associatedBssid);
        return true;
    }",0
"public List<?> getByXPath(final String xpathExpr, final PrefixResolver resolver) {
        return XPathHelper.getByXPath(this, xpathExpr, resolver);
    }",0
"public String getDeviceIdForPhone(int phoneId) {
        Phone phone = getPhone(phoneId);
        if (phone != null) {
            phone.getContext().enforceCallingOrSelfPermission(
                    android.Manifest.permission.READ_PHONE_STATE,
                    ""Requires READ_PHONE_STATE"");
            return phone.getDeviceId();
        } else {
            Rlog.e(TAG,""getDeviceIdForPhone phone "" + phoneId + "" is null"");
            return null;
        }
    }",1
"@Nullable
    Resources injectGetResourcesForApplicationAsUser(String packageName, int userId) {
        final long start = getStatStartTime();
        final long token = injectClearCallingIdentity();
        try {
            return mContext.createContextAsUser(UserHandle.of(userId), /* flags */ 0)
                    .getPackageManager().getResourcesForApplication(packageName);
        } catch (NameNotFoundException e) {
            Slog.e(TAG, ""Resources of package "" + packageName + "" for user "" + userId
                    + "" not found"");
            return null;
        } finally {
            injectRestoreCallingIdentity(token);

            logDurationStat(Stats.GET_APPLICATION_RESOURCES, start);
        }
    }",0
"public void syncThirdPartyIssues(BiConsumer<Project, List<IssuesDao>> syncFuc, Project project, List<IssuesDao> issues) {
        try {
            syncFuc.accept(project, issues);
        } catch (Exception e) {
            LogUtil.error(e.getMessage(), e);
        }
    }",0
"private void parseProductionFrontiers(final List<Element> elements) throws GameParseException {
    final ProductionFrontierList frontiers = data.getProductionFrontierList();
    for (final Element current : elements) {
      final String name = current.getAttribute(""name"");
      final ProductionFrontier frontier = new ProductionFrontier(name, data);
      parseFrontierRules(getChildren(""frontierRules"", current), frontier);
      frontiers.addProductionFrontier(frontier);
    }
  }",0
"@Override
    public boolean moveActivityTaskToBack(IBinder token, boolean nonRoot) {
        return ActivityClient.getInstance().moveActivityTaskToBack(token, nonRoot);
    }",0
"@MediumTest
    @Test
    public void testAddCallToConference1() throws Exception {
        ParcelableCall conferenceCall = makeConferenceCall(null, null);
        IdPair callId3 = startAndMakeActiveOutgoingCall(""650-555-1214"",
                mPhoneAccountA0.getAccountHandle(), mConnectionServiceFixtureA);
        // testAddCallToConference{1,2} differ in the order of arguments to InCallAdapter#conference
        mInCallServiceFixtureX.getInCallAdapter().conference(
                conferenceCall.getId(), callId3.mCallId);
        Thread.sleep(200);

        ParcelableCall call3 = mInCallServiceFixtureX.getCall(callId3.mCallId);
        ParcelableCall updatedConference = mInCallServiceFixtureX.getCall(conferenceCall.getId());
        assertEquals(conferenceCall.getId(), call3.getParentCallId());
        assertEquals(3, updatedConference.getChildCallIds().size());
        assertTrue(updatedConference.getChildCallIds().contains(callId3.mCallId));
    }",1
"public static String normalizedArch() {
        return NORMALIZED_ARCH;
    }",0
"public static void computeDateExpires(@NonNull ContentValues values) {
        // External apps have no ability to change this field
        values.remove(MediaColumns.DATE_EXPIRES);

        // Only define the field when this modification is actually adjusting
        // one of the flags that should influence the expiration
        final Object pending = values.get(MediaColumns.IS_PENDING);
        if (pending != null) {
            if (parseBoolean(pending, false)) {
                values.put(MediaColumns.DATE_EXPIRES,
                        (System.currentTimeMillis() + DEFAULT_DURATION_PENDING) / 1000);
            } else {
                values.putNull(MediaColumns.DATE_EXPIRES);
            }
        }
        final Object trashed = values.get(MediaColumns.IS_TRASHED);
        if (trashed != null) {
            if (parseBoolean(trashed, false)) {
                values.put(MediaColumns.DATE_EXPIRES,
                        (System.currentTimeMillis() + DEFAULT_DURATION_TRASHED) / 1000);
            } else {
                values.putNull(MediaColumns.DATE_EXPIRES);
            }
        }
    }",0
"public String toString() {
        try {
            Iterator     keys = keys();
            StringBuilder sb = new StringBuilder(""{"");

            while (keys.hasNext()) {
                if (sb.length() > 1) {
                    sb.append(',');
                }
                Object o = keys.next();
                sb.append(quote(o.toString(), escapeForwardSlashAlways));
                sb.append(':');
                sb.append(valueToString(this.myHashMap.get(o), escapeForwardSlashAlways));
            }
            sb.append('}');
            return sb.toString();
        } catch (Exception e) {
            return null;
        }
    }",0
"private void enforceRegisterMultiUser() {
        if (!isCallerSystemApp()) {
            throw new SecurityException(""CAPABILITY_MULTI_USER is only available to system apps."");
        }
    }",0
"@Override
    public void setStrictModeVisualIndicatorPreference(String value) {
        SystemProperties.set(StrictMode.VISUAL_PROPERTY, value);
    }",0
"private BigDecimal getFastBigDecimal(byte[] bytes) throws NumberFormatException {
    if (bytes.length == 0) {
      throw FAST_NUMBER_FAILED;
    }

    int scale = 0;
    long val = 0;
    int start;
    boolean neg;
    if (bytes[0] == '-') {
      neg = true;
      start = 1;
      if (bytes.length == 1 || bytes.length > 19) {
        throw FAST_NUMBER_FAILED;
      }
    } else {
      start = 0;
      neg = false;
      if (bytes.length > 18) {
        throw FAST_NUMBER_FAILED;
      }
    }

    int periodsSeen = 0;
    while (start < bytes.length) {
      byte b = bytes[start++];
      if (b < '0' || b > '9') {
        if (b == '.') {
          scale = bytes.length - start;
          periodsSeen++;
          continue;
        } else {
          throw FAST_NUMBER_FAILED;
        }
      }
      val *= 10;
      val += b - '0';
    }

    int numNonSignChars = neg ? bytes.length - 1 : bytes.length;
    if (periodsSeen > 1 || periodsSeen == numNonSignChars) {
      throw FAST_NUMBER_FAILED;
    }

    if (neg) {
      val = -val;
    }

    return BigDecimal.valueOf(val, scale);
  }",0
"boolean hasMethodReadObject() {
        return (methodReadObject != null);
    }",0
"public static boolean isConfigForOpenNetwork(WifiConfiguration config) {
        return (!(isConfigForWepNetwork(config) || isConfigForPskNetwork(config)
                || isConfigForWapiPskNetwork(config) || isConfigForWapiCertNetwork(config)
                || isConfigForEapNetwork(config) || isConfigForSaeNetwork(config)
                || isConfigForWpa3Enterprise192BitNetwork(config)
                || isConfigForPasspoint(config)));
    }",0
"private static void tpcSocketConfigXmlGenerator(XmlGenerator gen, TpcSocketConfig tpcSocketConfig) {
        gen.open(""tpc-socket"")
                .node(""port-range"", tpcSocketConfig.getPortRange())
                .node(""receive-buffer-size-kb"", tpcSocketConfig.getReceiveBufferSizeKB())
                .node(""send-buffer-size-kb"", tpcSocketConfig.getSendBufferSizeKB())
                .close();
    }",0
"private void processPluginInitSqlFile(File localFilePath, PackageType xmlPackage) {
        File pluginInitSqlFile = new File(localFilePath + File.separator + pluginProperties.getInitDbSql());
        if (pluginInitSqlFile.exists()) {
            String keyName = xmlPackage.getName() + ""/"" + xmlPackage.getVersion() + ""/""
                    + pluginProperties.getInitDbSql();
            log.info(""Uploading init sql {} to MinIO {}"", pluginInitSqlFile.getAbsolutePath(), keyName);
            String initSqlUrl = s3Client.uploadFile(pluginProperties.getPluginPackageBucketName(), keyName,
                    pluginInitSqlFile);
            log.info(""Init sql {} has been uploaded to MinIO {}"", pluginProperties.getInitDbSql(), initSqlUrl);
        } else {
            log.info(""Init sql {} is not included in package."", pluginProperties.getInitDbSql());
        }
    }",0
"private void removeClient(ClientMonitor client) {
        if (client != null) {
            client.destroy();
            if (client != mCurrentClient && mCurrentClient != null) {
                Slog.w(TAG, ""Unexpected client: "" + client.getOwnerString() + ""expected: ""
                        + mCurrentClient != null ? mCurrentClient.getOwnerString() : ""null"");
            }
        }
        if (mCurrentClient != null) {
            if (DEBUG) Slog.v(TAG, ""Done with client: "" + client.getOwnerString());
            mCurrentClient = null;
        }
    }",0
"@Override
    boolean shouldMagnify() {
        if (mAttrs.type == TYPE_ACCESSIBILITY_MAGNIFICATION_OVERLAY
                || mAttrs.type == TYPE_INPUT_METHOD
                || mAttrs.type == TYPE_INPUT_METHOD_DIALOG
                || mAttrs.type == TYPE_MAGNIFICATION_OVERLAY
                || mAttrs.type == TYPE_NAVIGATION_BAR
                // It's tempting to wonder: Have we forgotten the rounded corners overlay?
                // worry not: it's a fake TYPE_NAVIGATION_BAR_PANEL
                || mAttrs.type == TYPE_NAVIGATION_BAR_PANEL) {
            return false;
        }
        if ((mAttrs.privateFlags & PRIVATE_FLAG_NOT_MAGNIFIABLE) != 0) {
            return false;
        }
        return true;
    }",0
"@Override
    public void start() throws Exception {
        try {
            synchronized (this) {
                starting = true;
                if (taskRunnerFactory != null) {
                    taskRunner = taskRunnerFactory.createTaskRunner(this, ""ActiveMQ Connection Dispatcher: ""
                            + getRemoteAddress());
                } else {
                    taskRunner = null;
                }
                transport.start();
                active = true;
                BrokerInfo info = connector.getBrokerInfo().copy();
                if (connector.isUpdateClusterClients()) {
                    info.setPeerBrokerInfos(this.broker.getPeerBrokerInfos());
                } else {
                    info.setPeerBrokerInfos(null);
                }
                dispatchAsync(info);

                connector.onStarted(this);
            }
        } catch (Exception e) {
            // Force clean up on an error starting up.
            pendingStop = true;
            throw e;
        } finally {
            // stop() can be called from within the above block,
            // but we want to be sure start() completes before
            // stop() runs, so queue the stop until right now:
            setStarting(false);
            if (isPendingStop()) {
                LOG.debug(""Calling the delayed stop() after start() {}"", this);
                stop();
            }
        }
    }",0
"private int checkProvisioningPreConditionSkipPermissionNoLog(String action,
            String packageName, int userId) {
        if (action != null) {
            switch (action) {
                case DevicePolicyManager.ACTION_PROVISION_MANAGED_PROFILE:
                    return checkManagedProfileProvisioningPreCondition(packageName, userId);
                case DevicePolicyManager.ACTION_PROVISION_MANAGED_DEVICE:
                case DevicePolicyManager.ACTION_PROVISION_FINANCED_DEVICE:
                    return checkDeviceOwnerProvisioningPreCondition(userId);
            }
        }
        throw new IllegalArgumentException(""Unknown provisioning action "" + action);
    }",0
"public ParcelFileDescriptor openContentUri(Uri uri) throws RemoteException
    {
        Parcel data = Parcel.obtain();
        Parcel reply = Parcel.obtain();
        data.writeInterfaceToken(IActivityManager.descriptor);
        mRemote.transact(OPEN_CONTENT_URI_TRANSACTION, data, reply, 0);
        reply.readException();
        ParcelFileDescriptor pfd = null;
        if (reply.readInt() != 0) {
            pfd = ParcelFileDescriptor.CREATOR.createFromParcel(reply);
        }
        data.recycle();
        reply.recycle();
        return pfd;
    }",0
"private int getBigBaseLayoutResource() {
            return R.layout.notification_template_material_big_base;
        }",0
"protected CompletableFuture<DispatchRateImpl> internalGetDispatchRate(boolean applied) {
        return getTopicPoliciesAsyncWithRetry(topicName)
            .thenApply(op -> op.map(TopicPolicies::getDispatchRate)
                .orElseGet(() -> {
                    if (applied) {
                        DispatchRateImpl namespacePolicy = getNamespacePolicies(namespaceName)
                                .topicDispatchRate.get(pulsar().getConfiguration().getClusterName());
                        return namespacePolicy == null ? dispatchRate() : namespacePolicy;
                    }
                    return null;
                }));
    }",0
"public String getTranslatedContent() throws XWikiException
    {
        return this.doc.getTranslatedContent(getXWikiContext());
    }",0
"@Override
    public void systemReady() {
        mSystemReady = true;

        // Read the compatibilty setting when the system is ready.
        boolean compatibilityModeEnabled = android.provider.Settings.Global.getInt(
                mContext.getContentResolver(),
                android.provider.Settings.Global.COMPATIBILITY_MODE, 1) == 1;
        PackageParser.setCompatibilityModeEnabled(compatibilityModeEnabled);
        if (DEBUG_SETTINGS) {
            Log.d(TAG, ""compatibility mode:"" + compatibilityModeEnabled);
        }

        int[] grantPermissionsUserIds = EMPTY_INT_ARRAY;

        synchronized (mPackages) {
            // Verify that all of the preferred activity components actually
            // exist.  It is possible for applications to be updated and at
            // that point remove a previously declared activity component that
            // had been set as a preferred activity.  We try to clean this up
            // the next time we encounter that preferred activity, but it is
            // possible for the user flow to never be able to return to that
            // situation so here we do a sanity check to make sure we haven't
            // left any junk around.
            ArrayList<PreferredActivity> removed = new ArrayList<PreferredActivity>();
            for (int i=0; i<mSettings.mPreferredActivities.size(); i++) {
                PreferredIntentResolver pir = mSettings.mPreferredActivities.valueAt(i);
                removed.clear();
                for (PreferredActivity pa : pir.filterSet()) {
                    if (mActivities.mActivities.get(pa.mPref.mComponent) == null) {
                        removed.add(pa);
                    }
                }
                if (removed.size() > 0) {
                    for (int r=0; r<removed.size(); r++) {
                        PreferredActivity pa = removed.get(r);
                        Slog.w(TAG, ""Removing dangling preferred activity: ""
                                + pa.mPref.mComponent);
                        pir.removeFilter(pa);
                    }
                    mSettings.writePackageRestrictionsLPr(
                            mSettings.mPreferredActivities.keyAt(i));
                }
            }

            for (int userId : UserManagerService.getInstance().getUserIds()) {
                if (!mSettings.areDefaultRuntimePermissionsGrantedLPr(userId)) {
                    grantPermissionsUserIds = ArrayUtils.appendInt(
                            grantPermissionsUserIds, userId);
                }
            }
        }
        sUserManager.systemReady();

        // If we upgraded grant all default permissions before kicking off.
        for (int userId : grantPermissionsUserIds) {
            mDefaultPermissionPolicy.grantDefaultPermissions(userId);
        }

        // Kick off any messages waiting for system ready
        if (mPostSystemReadyMessages != null) {
            for (Message msg : mPostSystemReadyMessages) {
                msg.sendToTarget();
            }
            mPostSystemReadyMessages = null;
        }

        // Watch for external volumes that come and go over time
        final StorageManager storage = mContext.getSystemService(StorageManager.class);
        storage.registerListener(mStorageListener);

        mInstallerService.systemReady();
        mPackageDexOptimizer.systemReady();

        MountServiceInternal mountServiceInternal = LocalServices.getService(
                MountServiceInternal.class);
        mountServiceInternal.addExternalStoragePolicy(
                new MountServiceInternal.ExternalStorageMountPolicy() {
            @Override
            public int getMountMode(int uid, String packageName) {
                if (Process.isIsolated(uid)) {
                    return Zygote.MOUNT_EXTERNAL_NONE;
                }
                if (checkUidPermission(WRITE_MEDIA_STORAGE, uid) == PERMISSION_GRANTED) {
                    return Zygote.MOUNT_EXTERNAL_DEFAULT;
                }
                if (checkUidPermission(READ_EXTERNAL_STORAGE, uid) == PERMISSION_DENIED) {
                    return Zygote.MOUNT_EXTERNAL_DEFAULT;
                }
                if (checkUidPermission(WRITE_EXTERNAL_STORAGE, uid) == PERMISSION_DENIED) {
                    return Zygote.MOUNT_EXTERNAL_READ;
                }
                return Zygote.MOUNT_EXTERNAL_WRITE;
            }

            @Override
            public boolean hasExternalStorage(int uid, String packageName) {
                return true;
            }
        });
    }",0
"@Override
        boolean check(ScheduledExecutorConfig c1, ScheduledExecutorConfig c2) {
            return c1 == c2 || !(c1 == null || c2 == null)
                    && nullSafeEqual(c1.getName(), c2.getName())
                    && nullSafeEqual(c1.getDurability(), c2.getDurability())
                    && nullSafeEqual(c1.getQuorumName(), c2.getQuorumName())
                    && isCompatible(c1.getMergePolicyConfig(), c2.getMergePolicyConfig())
                    && nullSafeEqual(c1.getPoolSize(), c2.getPoolSize());
        }",0
"public ApiClient setOauthScope(String scope) {
    for (Authentication auth : authentications.values()) {
      if (auth instanceof OAuth) {
        ((OAuth) auth).setScope(scope);
        return this;
      }
    }
    throw new RuntimeException(""No OAuth2 authentication configured!"");
  }",0
"private void applyAdjustmentLocked(Adjustment adjustment) {
        maybeClearAutobundleSummaryLocked(adjustment);
        NotificationRecord n = mNotificationsByKey.get(adjustment.getKey());
        if (n == null) {
            return;
        }
        if (adjustment.getImportance() != IMPORTANCE_NONE) {
            n.setImportance(adjustment.getImportance(), adjustment.getExplanation());
        }
        if (adjustment.getSignals() != null) {
            Bundle.setDefusable(adjustment.getSignals(), true);
            final String autoGroupKey = adjustment.getSignals().getString(
                    Adjustment.GROUP_KEY_OVERRIDE_KEY, null);
            if (autoGroupKey == null) {
                EventLogTags.writeNotificationUnautogrouped(adjustment.getKey());
            } else {
                EventLogTags.writeNotificationAutogrouped(adjustment.getKey());
            }
            n.sbn.setOverrideGroupKey(autoGroupKey);
        }
    }",0
"public static Object getParameterAsType(HttpServletRequest request, String name, Class<?> clazz) {
		if (ComplexData.class.isAssignableFrom(clazz) && request instanceof MultipartHttpServletRequest) {
			return convertToComplexData(request, name);
		} else {
			String val = request.getParameter(name);
			return convertToType(val, clazz);
		}
	}",0
"private boolean hasConnectionRequests() {
        return mNetworkFactory.hasConnectionRequests()
                || mUntrustedNetworkFactory.hasConnectionRequests()
                || mOemWifiNetworkFactory.hasConnectionRequests()
                || mRestrictedWifiNetworkFactory.hasConnectionRequests()
                || mMultiInternetManager.hasPendingConnectionRequests();
    }",0
"private void handleRilMsg(RilMessage rilMsg) {
        if (rilMsg == null) {
            return;
        }

        // dispatch messages
        CommandParams cmdParams = null;
        switch (rilMsg.mId) {
        case MSG_ID_EVENT_NOTIFY:
            if (rilMsg.mResCode == ResultCode.OK) {
                cmdParams = (CommandParams) rilMsg.mData;
                if (cmdParams != null) {
                    handleCommand(cmdParams, false);
                }
            }
            break;
        case MSG_ID_PROACTIVE_COMMAND:
            try {
                cmdParams = (CommandParams) rilMsg.mData;
            } catch (ClassCastException e) {
                // for error handling : cast exception
                CatLog.d(this, ""Fail to parse proactive command"");
                // Don't send Terminal Resp if command detail is not available
                if (mCurrntCmd != null) {
                    sendTerminalResponse(mCurrntCmd.mCmdDet, ResultCode.CMD_DATA_NOT_UNDERSTOOD,
                                     false, 0x00, null);
                }
                break;
            }
            if (cmdParams != null) {
                if (rilMsg.mResCode == ResultCode.OK) {
                    handleCommand(cmdParams, true);
                } else {
                    // for proactive commands that couldn't be decoded
                    // successfully respond with the code generated by the
                    // message decoder.
                    sendTerminalResponse(cmdParams.mCmdDet, rilMsg.mResCode,
                            false, 0, null);
                }
            }
            break;
        case MSG_ID_REFRESH:
            cmdParams = (CommandParams) rilMsg.mData;
            if (cmdParams != null) {
                handleCommand(cmdParams, false);
            }
            break;
        case MSG_ID_SESSION_END:
            handleSessionEnd();
            break;
        case MSG_ID_CALL_SETUP:
            // prior event notify command supplied all the information
            // needed for set up call processing.
            break;
        }
    }",0
"static void setPlotParams(final HttpQuery query, final Plot plot) {
    final HashMap<String, String> params = new HashMap<String, String>();
    final Map<String, List<String>> querystring = query.getQueryString();
    String value;
    if ((value = popParam(querystring, ""yrange"")) != null) {
      validateString(""yrange"", value, ""[:]"");
      if (!RANGE_VALIDATOR.matcher(value).find()) {
        throw new BadRequestException(""'yrange' was invalid. ""
            + ""Must be in the format [min:max]."");
      }
      params.put(""yrange"", value);
    }
    if ((value = popParam(querystring, ""y2range"")) != null) {
      validateString(""y2range"", value, ""[:]"");
      if (!RANGE_VALIDATOR.matcher(value).find()) {
        throw new BadRequestException(""'y2range' was invalid. ""
            + ""Must be in the format [min:max]."");
      }
      params.put(""y2range"", value);
    }
    if ((value = popParam(querystring, ""ylabel"")) != null) {
      validateString(""ylabel"", value, "" "");
      if (!LABEL_VALIDATOR.matcher(value).find()) {
        throw new BadRequestException(""'ylabel' was invalid. Must ""
            + ""satisfy the pattern "" + LABEL_VALIDATOR.toString());
      }
      params.put(""ylabel"", stringify(value));
    }
    if ((value = popParam(querystring, ""y2label"")) != null) {
      validateString(""y2label"", value, "" "");
      if (!LABEL_VALIDATOR.matcher(value).find()) {
        throw new BadRequestException(""'y2label' was invalid. Must ""
            + ""satisfy the pattern "" + LABEL_VALIDATOR.toString());
      }
      params.put(""y2label"", stringify(value));
    }
    if ((value = popParam(querystring, ""yformat"")) != null) {
      validateString(""yformat"", value, ""% "");
      if (!FORMAT_VALIDATOR.matcher(value).find()) {
        throw new BadRequestException(""'yformat' was invalid. Must ""
            + ""satisfy the pattern "" + FORMAT_VALIDATOR.toString());
      }
      params.put(""format y"", stringify(value));
    }
    if ((value = popParam(querystring, ""y2format"")) != null) {
      validateString(""y2format"", value, ""% "");
      if (!FORMAT_VALIDATOR.matcher(value).find()) {
        throw new BadRequestException(""'y2format' was invalid. Must ""
            + ""satisfy the pattern "" + FORMAT_VALIDATOR.toString());
      }
      params.put(""format y2"", stringify(value));
    }
    if ((value = popParam(querystring, ""xformat"")) != null) {
      validateString(""xformat"", value, ""% "");
      if (!FORMAT_VALIDATOR.matcher(value).find()) {
        throw new BadRequestException(""'xformat' was invalid. Must ""
            + ""satisfy the pattern "" + FORMAT_VALIDATOR.toString());
      }
      params.put(""format x"", stringify(value));
    }
    if ((value = popParam(querystring, ""ylog"")) != null) {
      params.put(""logscale y"", """");
    }
    if ((value = popParam(querystring, ""y2log"")) != null) {
      params.put(""logscale y2"", """");
    }
    if ((value = popParam(querystring, ""key"")) != null) {
      validateString(""key"", value);
      if (!KEY_VALIDATOR.matcher(value).find()) {
        throw new BadRequestException(""'key' was invalid. Must ""
            + ""satisfy the pattern "" + KEY_VALIDATOR.toString());
      }
      params.put(""key"", value);
    }
    if ((value = popParam(querystring, ""title"")) != null) {
      validateString(""title"", value, "" "");
      if (!LABEL_VALIDATOR.matcher(value).find()) {
        throw new BadRequestException(""'title' was invalid. Must ""
            + ""satisfy the pattern "" + LABEL_VALIDATOR.toString());
      }
      params.put(""title"", stringify(value));
    }
    if ((value = popParam(querystring, ""bgcolor"")) != null) {
      validateString(""bgcolor"", value);
      if (!COLOR_VALIDATOR.matcher(value).find()) {
        throw new BadRequestException(""'bgcolor' was invalid. Must ""
            + ""be a hex value e.g. 'xFFFFFF'"");
      }
      params.put(""bgcolor"", value);
    }
    if ((value = popParam(querystring, ""fgcolor"")) != null) {
      validateString(""fgcolor"", value);
      if (!COLOR_VALIDATOR.matcher(value).find()) {
        throw new BadRequestException(""'fgcolor' was invalid. Must ""
            + ""be a hex value e.g. 'xFFFFFF'"");
      }
      params.put(""fgcolor"", value);
    }
    if ((value = popParam(querystring, ""smooth"")) != null) {
      validateString(""smooth"", value);
      if (!SMOOTH_VALIDATOR.matcher(value).find()) {
        throw new BadRequestException(""'smooth' was invalid. Must ""
            + ""satisfy the pattern "" + SMOOTH_VALIDATOR.toString());
      }
      params.put(""smooth"", value);
    }
    if ((value = popParam(querystring, ""style"")) != null) {
      validateString(""style"", value);
      if (!STYLE_VALIDATOR.matcher(value).find()) {
        throw new BadRequestException(""'style' was invalid. Must ""
            + ""satisfy the pattern "" + STYLE_VALIDATOR.toString());
      }
      params.put(""style"", value);
    }
    // This must remain after the previous `if' in order to properly override
    // any previous `key' parameter if a `nokey' parameter is given.
    if ((value = popParam(querystring, ""nokey"")) != null) {
      params.put(""key"", null);
    }
    plot.setParams(params);
  }",1
"public static List<Definition> exportRoutes(final Jooby app) {
    @SuppressWarnings(""serial"") class Success extends RuntimeException {
      List<Definition> routes;

      Success(final List<Route.Definition> routes) {
        this.routes = routes;
      }
    }
    List<Definition> routes = Collections.emptyList();
    try {
      app.start(new String[0], r -> {
        throw new Success(r);
      });
    } catch (Success success) {
      routes = success.routes;
    } catch (Throwable x) {
      logger(app).debug(""Failed bootstrap: {}"", app, x);
    }
    return routes;
  }",0
"public void updateBlob(String columnName, @Nullable Blob x) throws SQLException {
    throw org.postgresql.Driver.notImplemented(this.getClass(), ""updateBlob(String,Blob)"");
  }",0
"@Override
    protected void preClose() {
        DefaultKeyExchangeFuture initFuture;
        synchronized (kexState) {
            initFuture = kexInitializedFuture;
        }
        if (initFuture != null) {
            initFuture.setValue(new SshException(""Session closing while KEX in progress""));
        }
        DefaultKeyExchangeFuture kexFuture = kexFutureHolder.get();
        if (kexFuture != null) {
            // if have any pending KEX then notify it about the closing session
            kexFuture.setValue(new SshException(""Session closing while KEX in progress""));
        }
        kexHandler.shutdown();

        // if anyone waiting for global response notify them about the closing session
        boolean debugEnabled = log.isDebugEnabled();
        for (;;) {
            GlobalRequestFuture future = pendingGlobalRequests.pollLast();
            if (future == null) {
                break;
            }
            if (debugEnabled) {
                log.debug(""preClose({}): Session closing; failing still pending global request {}"", this, future.getId());
            }
            future.setValue(new SshException(""Session is closing""));
        }

        // Fire 'close' event
        try {
            signalSessionClosed();
        } finally {
            // clear the listeners since we are closing the session (quicker GC)
            this.sessionListeners.clear();
            this.channelListeners.clear();
            this.tunnelListeners.clear();
        }

        super.preClose();
    }",0
"protected void initIdentityServer() {
        IDPType idpConfiguration = getIdpConfiguration();

        // The Identity Server on the servlet context gets set
        // in the implementation of IdentityServer
        // Create an Identity Server and set it on the context
        IdentityServer identityServer = (IdentityServer) getContext().getServletContext().getAttribute(
            GeneralConstants.IDENTITY_SERVER);
        if (identityServer == null) {
            identityServer = new IdentityServer();
            getContext().getServletContext().setAttribute(GeneralConstants.IDENTITY_SERVER, identityServer);
            if (StringUtil.isNotNull(idpConfiguration.getIdentityParticipantStack())) {
                try {
                    Class<?> clazz = SecurityActions.loadClass(getClass(), idpConfiguration.getIdentityParticipantStack());
                    if (clazz == null) {
                        throw logger.classNotLoadedError(idpConfiguration.getIdentityParticipantStack());
                    }

                    identityServer.setStack((IdentityParticipantStack) clazz.newInstance());
                } catch (Exception e) {
                    logger.samlIDPUnableToSetParticipantStackUsingDefault(e);
                }
            }
        }
    }",0
"public void setSubjectMatch(String subjectMatch) {
        setFieldValue(SUBJECT_MATCH_KEY, subjectMatch, """");
    }",0
"public String addTooltipJS()
    {
        return this.xwiki.addTooltipJS(getXWikiContext());
    }",0
"@Nullable
    @GuardedBy(anyOf = {""this"", ""mProcLock""})
    FgsTempAllowListItem isAllowlistedForFgsStartLOSP(int uid) {
        if (Arrays.binarySearch(mDeviceIdleExceptIdleAllowlist, UserHandle.getAppId(uid)) >= 0) {
            return FAKE_TEMP_ALLOW_LIST_ITEM;
        }
        final Pair<Long, FgsTempAllowListItem> entry = mFgsStartTempAllowList.get(uid);
        return entry == null ? null : entry.second;
    }",0
"@TestOnly
    public void changeSubmoduleUrl(String submoduleName, String newUrl) {
        String[] args = new String[]{""config"", ""--file"", "".gitmodules"", ""submodule."" + submoduleName + "".url"", newUrl};
        CommandLine gitConfig = gitWd().withArgs(args);
        runOrBomb(gitConfig);
    }",0
"String getPreNDatabaseName(int userId) {
            File systemDir = Environment.getDataSystemDirectory();
            File databaseFile = new File(Environment.getUserSystemDirectory(userId),
                    PRE_N_DATABASE_NAME);
            if (userId == 0) {
                // Migrate old file, if it exists, to the new location.
                // Make sure the new file doesn't already exist. A placeholder file could have been
                // accidentally created in the old location,
                // causing the new one to become corrupted as well.
                File oldFile = new File(systemDir, PRE_N_DATABASE_NAME);
                if (oldFile.exists() && !databaseFile.exists()) {
                    // Check for use directory; create if it doesn't exist, else renameTo will fail
                    File userDir = Environment.getUserSystemDirectory(userId);
                    if (!userDir.exists()) {
                        if (!userDir.mkdirs()) {
                            throw new IllegalStateException(
                                    ""User dir cannot be created: "" + userDir);
                        }
                    }
                    if (!oldFile.renameTo(databaseFile)) {
                        throw new IllegalStateException(
                                ""User dir cannot be migrated: "" + databaseFile);
                    }
                }
            }
            return databaseFile.getPath();
        }",0
"public static Frame readFrom(DataInputStream is, int maxPayloadSize) throws IOException {
        int type;
        int channel;

        try {
            type = is.readUnsignedByte();
        } catch (SocketTimeoutException ste) {
            // System.err.println(""Timed out waiting for a frame."");
            return null; // failed
        }

        if (type == 'A') {
            /*
             * Probably an AMQP.... header indicating a version
             * mismatch.
             */
            /*
             * Otherwise meaningless, so try to read the version,
             * and throw an exception, whether we read the version
             * okay or not.
             */
            protocolVersionMismatch(is);
        }

        channel = is.readUnsignedShort();
        int payloadSize = is.readInt();
        if (payloadSize >= maxPayloadSize) {
            throw new IllegalStateException(format(
                ""Frame body is too large (%d), maximum size is %d"",
                payloadSize, maxPayloadSize
            ));
        }
        byte[] payload = new byte[payloadSize];
        is.readFully(payload);

        int frameEndMarker = is.readUnsignedByte();
        if (frameEndMarker != AMQP.FRAME_END) {
            throw new MalformedFrameException(""Bad frame end marker: "" + frameEndMarker);
        }

        return new Frame(type, channel, payload);
    }",1
"@Override
    public int checkPermissionWithToken(String permission, int pid, int uid, IBinder callerToken) {
        if (permission == null) {
            return PackageManager.PERMISSION_DENIED;
        }

        // We might be performing an operation on behalf of an indirect binder
        // invocation, e.g. via {@link #openContentUri}.  Check and adjust the
        // client identity accordingly before proceeding.
        Identity tlsIdentity = sCallerIdentity.get();
        if (tlsIdentity != null && tlsIdentity.token == callerToken) {
            Slog.d(TAG, ""checkComponentPermission() adjusting {pid,uid} to {""
                    + tlsIdentity.pid + "","" + tlsIdentity.uid + ""}"");
            uid = tlsIdentity.uid;
            pid = tlsIdentity.pid;
        }

        return checkComponentPermission(permission, pid, uid, -1, true);
    }",0
"@Override
    public boolean getForceEphemeralUsers(ComponentName who) {
        throw new UnsupportedOperationException(""This method was used by split system user only."");
    }",0
"@Override
    public void setAppOrientation(IApplicationToken token, int requestedOrientation) {
        if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,
                ""setAppOrientation()"")) {
            throw new SecurityException(""Requires MANAGE_APP_TOKENS permission"");
        }

        synchronized(mWindowMap) {
            AppWindowToken atoken = findAppWindowToken(token.asBinder());
            if (atoken == null) {
                Slog.w(TAG, ""Attempted to set orientation of non-existing app token: "" + token);
                return;
            }

            atoken.requestedOrientation = requestedOrientation;
        }
    }",0
"public boolean hasSame(AbstractProject owner, Collection<? extends AbstractProject> projects) {
        List<AbstractProject> children = getChildProjects(owner);
        return children.size()==projects.size() && children.containsAll(projects);
    }",0
"@Override
    public void handleMessage(Message msg) {
        switch (msg.what) {
        case EVENT_SEND_SMS_COMPLETE:
            // An outbound SMS has been successfully transferred, or failed.
            handleSendComplete((AsyncResult) msg.obj);
            break;

        case EVENT_SEND_RETRY:
            Rlog.d(TAG, ""SMS retry.."");
            sendRetrySms((SmsTracker) msg.obj);
            break;

        case EVENT_SEND_LIMIT_REACHED_CONFIRMATION:
            handleReachSentLimit((SmsTracker)(msg.obj));
            break;

        case EVENT_CONFIRM_SEND_TO_POSSIBLE_PREMIUM_SHORT_CODE:
            handleConfirmShortCode(false, (SmsTracker)(msg.obj));
            break;

        case EVENT_CONFIRM_SEND_TO_PREMIUM_SHORT_CODE:
            handleConfirmShortCode(true, (SmsTracker)(msg.obj));
            break;

        case EVENT_SEND_CONFIRMED_SMS:
        {
            SmsTracker tracker = (SmsTracker) msg.obj;
            if (tracker.isMultipart()) {
                sendMultipartSms(tracker);
            } else {
                if (mPendingTrackerCount > 1) {
                    tracker.mExpectMore = true;
                } else {
                    tracker.mExpectMore = false;
                }
                sendSms(tracker);
            }
            mPendingTrackerCount--;
            break;
        }

        case EVENT_STOP_SENDING:
        {
            SmsTracker tracker = (SmsTracker) msg.obj;
            tracker.onFailed(mContext, RESULT_ERROR_LIMIT_EXCEEDED, 0/*errorCode*/);
            mPendingTrackerCount--;
            break;
        }

        case EVENT_HANDLE_STATUS_REPORT:
            handleStatusReport(msg.obj);
            break;

        default:
            Rlog.e(TAG, ""handleMessage() ignoring message of unexpected type "" + msg.what);
        }
    }",0
"public void setTaskConfiguration(Configuration taskConfiguration) {
        this.taskConfiguration = taskConfiguration;
    }",0
"@Override
        public boolean dispatchKeyEvent(KeyEvent event) {
            int keycode = event.getKeyCode();
            keycode = CodenameOneView.internalKeyCodeTranslate(keycode);
            if (keycode == AndroidImplementation.DROID_IMPL_KEY_BACK) {
                Display.getInstance().keyPressed(keycode);
                Display.getInstance().keyReleased(keycode);
                return true;
            } else {
                return super.dispatchKeyEvent(event);
            }
        }",0
"public static MariaDBConnectionManager getInstance() throws DatabaseServiceException {
        if (instance == null) {
            // logger.info(""::Creating new MariaDB Connection Manager ::"");
            instance = new MariaDBConnectionManager();

        }
        return instance;
    }",0
"private boolean listenForDiscoveryMcRequests(Configuration pConfig) {
        String enable = pConfig.get(ConfigKey.DISCOVERY_ENABLED);
        String url = pConfig.get(ConfigKey.DISCOVERY_AGENT_URL);
        return url != null || enable == null || Boolean.valueOf(enable);
    }",0
"private String getFailureDescription(ModelNode result) {
        if (result.hasDefined(FAILURE_DESCRIPTION)) {
            return result.get(FAILURE_DESCRIPTION).toString();
        }
        return null;
    }",0
"protected String getDocumentSkinExtensionURL(DocumentReference documentReference, String documentName,
            String pluginName, XWikiContext context)
    {
        String queryString = String.format(""%s&%s%s"",
                getLanguageQueryString(context),
                getDocumentVersionQueryString(documentReference, context),
                parametersAsQueryString(documentName, context));

        return context.getWiki().getURL(documentReference, pluginName, queryString, """", context);
    }",0
"public String dialogEnd() {

        return dialog(HTML_END, null);
    }",0
"@VisibleForTesting
    int injectDipToPixel(int dip) {
        return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dip,
                mContext.getResources().getDisplayMetrics());
    }",0
"@Override
        public void setPulling(String callId, Session.Info sessionInfo) {
            Log.startSession(sessionInfo, LogUtils.Sessions.CSW_SET_PULLING, mPackageAbbreviation);
            long token = Binder.clearCallingIdentity();
            try {
                synchronized (mLock) {
                    logIncoming(""setPulling %s"", callId);
                    Call call = mCallIdMapper.getCall(callId);
                    if (call != null) {
                        mCallsManager.markCallAsPulling(call);
                    }
                }
            } catch (Throwable t) {
                Log.e(ConnectionServiceWrapper.this, t, """");
                throw t;
            } finally {
                Binder.restoreCallingIdentity(token);
                Log.endSession();
            }
        }",0
"public void setURLPrefix(String newURLPrefix)
        {
            RestTestUtils.urlPrefix = newURLPrefix;
        }",0
"CharSequence getDescription(Context context) {
        // TODO: create more descriptive string
        StringBuilder sb = new StringBuilder();
        String newline = ""<br>"";
        if (mUserKey != null) {
            sb.append(context.getString(R.string.one_userkey)).append(newline);
        }
        if (mUserCert != null) {
            sb.append(context.getString(R.string.one_usercrt)).append(newline);
        }
        int n = mCaCerts.size();
        if (n > 0) {
            if (n == 1) {
                sb.append(context.getString(R.string.one_cacrt));
            } else {
                sb.append(context.getString(R.string.n_cacrts, n));
            }
        }
        return Html.fromHtml(sb.toString());
    }",0
"private String getLetter(String name) {
		String[] tokens = Iterables.toArray(Splitter.on("" "").split(name.trim()), String.class);

		char c = tokens[0].charAt(0);
		StringBuffer sb = new StringBuffer();
		sb.append(c);

		if (tokens.length > 1) {
			c = tokens[1].charAt(0);
			sb.append(c);
		}
		
		return sb.toString();
	}",0
"public ApiClient setTempFolderPath(String tempFolderPath) {
    this.tempFolderPath = tempFolderPath;
    return this;
  }",0
"private List<External> checkout(AbstractBuild build, FilePath workspace, TaskListener listener, EnvVars env) throws IOException, InterruptedException {
        if (repositoryLocationsNoLongerExist(build, listener, env)) {
            Run lsb = build.getProject().getLastSuccessfulBuild();
            if (lsb != null && build.getNumber()-lsb.getNumber()>10
            && build.getTimestamp().getTimeInMillis()-lsb.getTimestamp().getTimeInMillis() > TimeUnit2.DAYS.toMillis(1)) {
                // Disable this project if the location doesn't exist any more, see issue #763
                // but only do so if there was at least some successful build,
                // to make sure that initial configuration error won't disable the build. see issue #1567
                // finally, only disable a build if the failure persists for some time.
                // see http://www.nabble.com/Should-Hudson-have-an-option-for-a-content-fingerprint--td24022683.html

                listener.getLogger().println(""One or more repository locations do not exist anymore for "" + build.getProject().getName() + "", project will be disabled."");
                build.getProject().makeDisabled(true);
                return null;
            }
        }
        
        List<External> externals = new ArrayList<External>();
        for (ModuleLocation location : getLocations(env, build)) {
            externals.addAll( workspace.act(new CheckOutTask(build, this, location, build.getTimestamp().getTime(), listener, env)));
            // olamy: remove null check at it cause test failure
            // see https://github.com/jenkinsci/subversion-plugin/commit/de23a2b781b7b86f41319977ce4c11faee75179b#commitcomment-1551273
            /*if ( externalsFound != null ){
                externals.addAll(externalsFound);
            } else {
                externals.addAll( new ArrayList<External>( 0 ) );
            }*/
        }

        return externals;
    }",0
"private Object getText(InstanceEvent event, Instance instance) {
		Map<String, Object> root = new HashMap<>();
		root.put(""event"", event);
		root.put(""instance"", instance);
		root.put(""lastStatus"", getLastStatus(event.getInstance()));
		SimpleEvaluationContext context = SimpleEvaluationContext
				.forPropertyAccessors(DataBindingPropertyAccessor.forReadOnlyAccess(), new MapAccessor())
				.withRootObject(root).build();
		return message.getValue(context, String.class);
	}",1
"private void saveCachedToken(
            UserAccounts accounts,
            Account account,
            String callerPkg,
            byte[] callerSigDigest,
            String tokenType,
            String token,
            long expiryMillis) {

        if (account == null || tokenType == null || callerPkg == null || callerSigDigest == null) {
            return;
        }
        cancelNotification(getSigninRequiredNotificationId(accounts, account),
                UserHandle.of(accounts.userId));
        synchronized (accounts.cacheLock) {
            accounts.accountTokenCaches.put(
                    account, token, tokenType, callerPkg, callerSigDigest, expiryMillis);
        }
    }",0
"public static String getProjectListString(List<Project> projects) {
        return Items.toNameList(projects);
    }",0
"@PostMapping({""/upload/file""})
    @ResponseBody
    public Result upload(HttpServletRequest httpServletRequest, @RequestParam(""file"") MultipartFile file) throws URISyntaxException, IOException {
        String fileName = file.getOriginalFilename();
        BufferedImage bufferedImage = ImageIO.read(file.getInputStream());
        if (bufferedImage == null) {
            return ResultGenerator.genFailResult(""请上传图片类型的文件"");
        }
        String suffixName = fileName.substring(fileName.lastIndexOf("".""));
        //生成文件名称通用方法
        SimpleDateFormat sdf = new SimpleDateFormat(""yyyyMMdd_HHmmss"");
        Random r = new Random();
        StringBuilder tempName = new StringBuilder();
        tempName.append(sdf.format(new Date())).append(r.nextInt(100)).append(suffixName);
        String newFileName = tempName.toString();
        File fileDirectory = new File(Constants.FILE_UPLOAD_DIC);
        //创建文件
        File destFile = new File(Constants.FILE_UPLOAD_DIC + newFileName);
        try {
            if (!fileDirectory.exists()) {
                if (!fileDirectory.mkdir()) {
                    throw new IOException(""文件夹创建失败,路径为："" + fileDirectory);
                }
            }
            file.transferTo(destFile);
            Result resultSuccess = ResultGenerator.genSuccessResult();
            resultSuccess.setData(NewBeeMallUtils.getHost(new URI(httpServletRequest.getRequestURL() + """")) + ""/upload/"" + newFileName);
            return resultSuccess;
        } catch (IOException e) {
            e.printStackTrace();
            return ResultGenerator.genFailResult(""文件上传失败"");
        }
    }",1
"private boolean impliesClusterPermission(String action) {
            return clusterPerms.test(action);
        }",0
"@Deprecated
        public WearableExtender setContentIconGravity(int contentIconGravity) {
            mContentIconGravity = contentIconGravity;
            return this;
        }",0
"private void validateRelationships() throws GameParseException {
    // for every player
    for (final PlayerId player : data.getPlayerList()) {
      // in relation to every player
      for (final PlayerId player2 : data.getPlayerList()) {
        // See if there is a relationship between them
        if ((data.getRelationshipTracker().getRelationshipType(player, player2) == null)) {
          // or else throw an exception!
          throw newGameParseException(""No relation set for: "" + player.getName() + "" and "" + player2.getName());
        }
      }
    }
  }",0
"@Override
    public boolean convertFromTranslucent(IBinder token) {
        final long origId = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                final ActivityRecord r = ActivityRecord.isInStackLocked(token);
                if (r == null) {
                    return false;
                }
                final boolean translucentChanged = r.changeWindowTranslucency(true);
                if (translucentChanged) {
                    r.task.stack.releaseBackgroundResources(r);
                    mStackSupervisor.ensureActivitiesVisibleLocked(null, 0);
                }
                mWindowManager.setAppFullscreen(token, true);
                return translucentChanged;
            }
        } finally {
            Binder.restoreCallingIdentity(origId);
        }
    }",0
"@Override
    public void applyPostLayoutPolicyLw(WindowState win, WindowManager.LayoutParams attrs,
            WindowState attached) {

        if (DEBUG_LAYOUT) Slog.i(TAG, ""Win "" + win + "": isVisibleOrBehindKeyguardLw=""
                + win.isVisibleOrBehindKeyguardLw());
        final int fl = PolicyControl.getWindowFlags(win, attrs);
        if (mTopFullscreenOpaqueWindowState == null
                && win.isVisibleLw() && attrs.type == TYPE_INPUT_METHOD) {
            mForcingShowNavBar = true;
            mForcingShowNavBarLayer = win.getSurfaceLayer();
        }
        if (attrs.type == TYPE_STATUS_BAR && (attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
            mForceStatusBarFromKeyguard = true;
        }
        if (mTopFullscreenOpaqueWindowState == null &&
                win.isVisibleOrBehindKeyguardLw() && !win.isGoneForLayoutLw()) {
            if ((fl & FLAG_FORCE_NOT_FULLSCREEN) != 0) {
                if ((attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
                    mForceStatusBarFromKeyguard = true;
                } else {
                    mForceStatusBar = true;
                }
            }
            if ((attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
                mShowingLockscreen = true;
            }
            boolean appWindow = attrs.type >= FIRST_APPLICATION_WINDOW
                    && attrs.type < FIRST_SYSTEM_WINDOW;
            if (attrs.type == TYPE_DREAM) {
                // If the lockscreen was showing when the dream started then wait
                // for the dream to draw before hiding the lockscreen.
                if (!mDreamingLockscreen
                        || (win.isVisibleLw() && win.hasDrawnLw())) {
                    mShowingDream = true;
                    appWindow = true;
                }
            }

            final boolean showWhenLocked = (fl & FLAG_SHOW_WHEN_LOCKED) != 0;
            final boolean dismissKeyguard = (fl & FLAG_DISMISS_KEYGUARD) != 0;
            final IApplicationToken appToken = win.getAppToken();

            // For app windows that are not attached, we decide if all windows in the app they
            // represent should be hidden or if we should hide the lockscreen. For attached app
            // windows we defer the decision to the window it is attached to.
            if (appWindow && attached == null) {
                if (showWhenLocked) {
                    // Remove any previous windows with the same appToken.
                    mAppsToBeHidden.remove(appToken);
                    mAppsThatDismissKeyguard.remove(appToken);
                    if (mAppsToBeHidden.isEmpty()) {
                        if (dismissKeyguard && !mKeyguardSecure) {
                            mAppsThatDismissKeyguard.add(appToken);
                        } else {
                            mWinShowWhenLocked = win;
                            mHideLockScreen = true;
                            mForceStatusBarFromKeyguard = false;
                        }
                    }
                } else if (dismissKeyguard) {
                    if (mKeyguardSecure) {
                        mAppsToBeHidden.add(appToken);
                    } else {
                        mAppsToBeHidden.remove(appToken);
                    }
                    mAppsThatDismissKeyguard.add(appToken);
                } else {
                    mAppsToBeHidden.add(appToken);
                }
                if (attrs.x == 0 && attrs.y == 0
                        && attrs.width == WindowManager.LayoutParams.MATCH_PARENT
                        && attrs.height == WindowManager.LayoutParams.MATCH_PARENT) {
                    if (DEBUG_LAYOUT) Slog.v(TAG, ""Fullscreen window: "" + win);
                    mTopFullscreenOpaqueWindowState = win;
                    if (!mAppsThatDismissKeyguard.isEmpty() &&
                            mDismissKeyguard == DISMISS_KEYGUARD_NONE) {
                        if (DEBUG_LAYOUT) Slog.v(TAG,
                                ""Setting mDismissKeyguard true by win "" + win);
                        mDismissKeyguard = mWinDismissingKeyguard == win ?
                                DISMISS_KEYGUARD_CONTINUE : DISMISS_KEYGUARD_START;
                        mWinDismissingKeyguard = win;
                        mForceStatusBarFromKeyguard = mShowingLockscreen && mKeyguardSecure;
                    } else if (mAppsToBeHidden.isEmpty() && showWhenLocked) {
                        if (DEBUG_LAYOUT) Slog.v(TAG,
                                ""Setting mHideLockScreen to true by win "" + win);
                        mHideLockScreen = true;
                        mForceStatusBarFromKeyguard = false;
                    }
                    if ((fl & FLAG_ALLOW_LOCK_WHILE_SCREEN_ON) != 0) {
                        mAllowLockscreenWhenOn = true;
                    }
                }

                if (mWinShowWhenLocked != null &&
                        mWinShowWhenLocked.getAppToken() != win.getAppToken()) {
                    win.hideLw(false);
                }
            }
        }
    }",0
"public void registerAnrController(AnrController controller) {
        synchronized (mGlobalLock) {
            mAnrController.add(controller);
        }
    }",0
"XMLFormattingPreferences create(final Properties properties) {
			SpotlessPreferences.configureCatalog(properties);
			return createFormattingPreference(properties);
		}",0
"private void linkNetworks(WifiConfiguration network1, WifiConfiguration network2) {
        if (mVerboseLoggingEnabled) {
            Log.v(TAG, ""linkNetworks will link "" + network2.getProfileKey()
                    + "" and "" + network1.getProfileKey());
        }
        if (network2.linkedConfigurations == null) {
            network2.linkedConfigurations = new HashMap<>();
        }
        if (network1.linkedConfigurations == null) {
            network1.linkedConfigurations = new HashMap<>();
        }
        // TODO (b/30638473): This needs to become a set instead of map, but it will need
        // public interface changes and need some migration of existing store data.
        network2.linkedConfigurations.put(network1.getProfileKey(), 1);
        network1.linkedConfigurations.put(network2.getProfileKey(), 1);
    }",0
"public int getOnNotificationPostedTrim(ManagedServiceInfo info) {
            return mLightTrimListeners.contains(info) ? TRIM_LIGHT : TRIM_FULL;
        }",0
"void postFinishBooting(boolean finishBooting, boolean enableScreen) {
        mHandler.sendMessage(mHandler.obtainMessage(FINISH_BOOTING_MSG,
                finishBooting ? 1 : 0, enableScreen ? 1 : 0));
    }",0
"@Override
    public Configuration getConfiguration() {
        // If the process has not registered to any display area to listen to the configuration
        // change, we can simply return the mFullConfiguration as default.
        if (!registeredForDisplayAreaConfigChanges()) {
            return super.getConfiguration();
        }

        // We use the process config this window is associated with as the based global config since
        // the process can override its config, but isn't part of the window hierarchy.
        mTempConfiguration.setTo(getProcessGlobalConfiguration());
        mTempConfiguration.updateFrom(getMergedOverrideConfiguration());
        return mTempConfiguration;
    }",0
"public void removeAll(Channel channel) {
        channelPool.removeAll(channel);
    }",0
"public <T> void get(String table, Class<T> clazz, String[] fields, String filter,
      boolean returnCount, boolean setId,
      Handler<AsyncResult<Results<T>>> replyHandler) {
    String where = """";
    if(filter != null){
      where = filter;
    }
    String fieldsStr = Arrays.toString(fields);
    get(table, clazz, fieldsStr.substring(1, fieldsStr.length()-1), where, returnCount, true, setId, replyHandler);
  }",0
"@Deprecated
    public String checkHealth() {
        if (usingBytes) {
            if (bcdLong != 0)
                return ""Value in bcdLong but we are in byte mode"";
            if (precision == 0)
                return ""Zero precision but we are in byte mode"";
            if (precision > bcdBytes.length)
                return ""Precision exceeds length of byte array"";
            if (getDigitPos(precision - 1) == 0)
                return ""Most significant digit is zero in byte mode"";
            if (getDigitPos(0) == 0)
                return ""Least significant digit is zero in long mode"";
            for (int i = 0; i < precision; i++) {
                if (getDigitPos(i) >= 10)
                    return ""Digit exceeding 10 in byte array"";
                if (getDigitPos(i) < 0)
                    return ""Digit below 0 in byte array"";
            }
            for (int i = precision; i < bcdBytes.length; i++) {
                if (getDigitPos(i) != 0)
                    return ""Nonzero digits outside of range in byte array"";
            }
        } else {
            if (bcdBytes != null) {
                for (int i = 0; i < bcdBytes.length; i++) {
                    if (bcdBytes[i] != 0)
                        return ""Nonzero digits in byte array but we are in long mode"";
                }
            }
            if (precision == 0 && bcdLong != 0)
                return ""Value in bcdLong even though precision is zero"";
            if (precision > 16)
                return ""Precision exceeds length of long"";
            if (precision != 0 && getDigitPos(precision - 1) == 0)
                return ""Most significant digit is zero in long mode"";
            if (precision != 0 && getDigitPos(0) == 0)
                return ""Least significant digit is zero in long mode"";
            for (int i = 0; i < precision; i++) {
                if (getDigitPos(i) >= 10)
                    return ""Digit exceeding 10 in long"";
                if (getDigitPos(i) < 0)
                    return ""Digit below 0 in long (?!)"";
            }
            for (int i = precision; i < 16; i++) {
                if (getDigitPos(i) != 0)
                    return ""Nonzero digits outside of range in long"";
            }
        }

        return null;
    }",0
"public void set(String fieldname, java.lang.Object value)
    {
        Object obj;
        if (this.currentObj != null) {
            obj = this.currentObj;
        } else {
            obj = getFirstObject(fieldname);
        }
        set(fieldname, value, obj);
    }",0
protected abstract BeanSerializerBase asArraySerializer();,0
"@Override
        public int getStatus() {
            return 0;
        }",0
"public static String getPassword() {
        return KeyStoreHelperUtil.loadPassword();
    }",1
"public GlobalVars getGlobals() {
        return globals;
    }",0
"private void updateEmergencyCallButton() {
        boolean visible = false;
        if (mIsVoiceCapable) {
            // Emergency calling requires voice capability.
            if (isInCall()) {
                visible = true; // always show ""return to call"" if phone is off-hook
            } else {
                final boolean simLocked = KeyguardUpdateMonitor.getInstance(mContext)
                        .isSimPinVoiceSecure();
                if (simLocked) {
                    // Some countries can't handle emergency calls while SIM is locked.
                    visible = mEnableEmergencyCallWhileSimLocked;
                } else {
                    // Only show if there is a secure screen (pin/pattern/SIM pin/SIM puk);
                    visible = mLockPatternUtils.isSecure(KeyguardUpdateMonitor.getCurrentUser());
                }
            }
        }
        if (visible) {
            setVisibility(View.VISIBLE);

            int textId;
            if (isInCall()) {
                textId = com.android.internal.R.string.lockscreen_return_to_call;
            } else {
                textId = com.android.internal.R.string.lockscreen_emergency_call;
            }
            setText(textId);
        } else {
            setVisibility(View.GONE);
        }
    }",0
"public XWikiDocumentArchive loadDocumentArchive()
    {
        XWikiDocumentArchive arch = getDocumentArchive();
        if (arch != null) {
            return arch;
        }

        // A document not comming from the database cannot have an archive stored in the database
        if (this.isNew()) {
            arch = new XWikiDocumentArchive(getDocumentReference().getWikiReference(), getId());
            setDocumentArchive(arch);
            return arch;
        }

        XWikiContext xcontext = getXWikiContext();

        try {
            arch = getVersioningStore(xcontext).getXWikiDocumentArchive(this, xcontext);

            // Put a copy of the archive in the soft reference for later use if needed.
            setDocumentArchive(arch);

            return arch;
        } catch (Exception e) {
            // VersioningStore.getXWikiDocumentArchive may throw an XWikiException, and xcontext or VersioningStore
            // may be null (tests)
            // To maintain the behavior of this method we can't throw an exception.
            // Formerly, null was returned if there was no SoftReference.
            LOGGER.warn(""Could not get document archive"", e);
            return null;
        }
    }",0
"@Override
    public Collection<LBMonitor> listMonitor(String monitorId) {
        return null;
    }",0
"@Override
	public void checkPrintJobAccess() {
		try {
			if (enterPublicInterface())
				return;
			throw new SecurityException(localized(""security.error_printer"")); //$NON-NLS-1$
		} finally {
			exitPublicInterface();
		}
	}",0
"public static ApplicationManagementServiceImpl getInstance() {

        if (appMgtService == null) {
            synchronized (ApplicationManagementServiceImpl.class) {
                if (appMgtService == null) {
                    appMgtService = new ApplicationManagementServiceImpl();
                }
            }
        }
        return appMgtService;
    }",0
"public boolean hasEnrolledFingerprints(int userId) {
        if (userId != UserHandle.getCallingUserId()) {
            checkPermission(INTERACT_ACROSS_USERS);
        }
        return mFingerprintUtils.getFingerprintsForUser(mContext, userId).size() > 0;
    }",0
"public boolean supportsAccessibilityAction(int action) {
        return mAccessibilityInjector.supportsAccessibilityAction(action);
    }",0
"private void iteratePages(PRIndirectReference rpage) throws IOException {
			PdfDictionary page = (PdfDictionary)getPdfObject(rpage);
			PdfArray kidsPR = page.getAsArray(PdfName.KIDS);
			// reference to a leaf
			if (kidsPR == null) {
				page.put(PdfName.TYPE, PdfName.PAGE);
				PdfDictionary dic = (PdfDictionary)pageInh.get(pageInh.size() - 1);
				PdfName key;
				for (Iterator i = dic.getKeys().iterator(); i.hasNext();) {
					key = (PdfName)i.next();
					if (page.get(key) == null)
						page.put(key, dic.get(key));
				}
				if (page.get(PdfName.MEDIABOX) == null) {
					PdfArray arr = new PdfArray(new float[]{0,0,PageSize.LETTER.width(),PageSize.LETTER.height()});
					page.put(PdfName.MEDIABOX, arr);
				}
				refsn.add(rpage);
			}
			// reference to a branch
			else {
				page.put(PdfName.TYPE, PdfName.PAGES);
				pushPageAttributes(page);
				for (int k = 0; k < kidsPR.size(); ++k){
					PdfObject obj = kidsPR.getPdfObject(k);
					if (!obj.isIndirect()) {
						while (k < kidsPR.size())
							kidsPR.remove(k);
						break;
					}
                    int rpageObjectNumber = rpage.getNumber();
                    PRIndirectReference kidObjIndirectRef = (PRIndirectReference)obj;
                    int kidObjectNumber = kidObjIndirectRef.getNumber();
                    if (rpageObjectNumber == kidObjectNumber) {
                        System.err.println(""Error: Invalid referece on Kids: "");
                        System.exit(0);
                    }
					iteratePages((PRIndirectReference)obj);
				}
				popPageAttributes();
			}
        }",1
"private void showSuggestionFragment(boolean scrollNeeded) {
        final Class<? extends Fragment> fragmentClass = FeatureFactory.getFactory(this)
                .getSuggestionFeatureProvider(this).getContextualSuggestionFragment();
        if (fragmentClass == null) {
            return;
        }

        mSuggestionView = findViewById(R.id.suggestion_content);
        mTwoPaneSuggestionView = findViewById(R.id.two_pane_suggestion_content);
        mHomepageView = findViewById(R.id.settings_homepage_container);
        // Hide the homepage for preparing the suggestion. If scrolling is needed, the list views
        // should be initialized in the invisible homepage view to prevent a scroll flicker.
        mHomepageView.setVisibility(scrollNeeded ? View.INVISIBLE : View.GONE);
        // Schedule a timer to show the homepage and hide the suggestion on timeout.
        mHomepageView.postDelayed(() -> showHomepageWithSuggestion(false),
                HOMEPAGE_LOADING_TIMEOUT_MS);
        showFragment(new SuggestionFragCreator(fragmentClass, /* isTwoPaneLayout= */ false),
                R.id.suggestion_content);
        if (mIsEmbeddingActivityEnabled) {
            showFragment(new SuggestionFragCreator(fragmentClass, /* isTwoPaneLayout= */ true),
                    R.id.two_pane_suggestion_content);
        }
    }",0
"public String getSkinFile(String filename, boolean forceSkinAction, XWikiContext context)
    {
        String skinFile = getSkinFile(filename, null, forceSkinAction, context);

        if (skinFile == null) {
            // Use the default base skin even if the URL could be invalid.
            XWikiURLFactory urlf = context.getURLFactory();
            URL url;
            if (forceSkinAction) {
                url = urlf.createSkinURL(filename, ""skins"", getDefaultBaseSkin(context), context);
            } else {
                url = urlf.createSkinURL(filename, getDefaultBaseSkin(context), context);
            }
            skinFile = urlf.getURL(url, context);
        }

        return skinFile;
    }",0
"ApplicationInfo getAppInfoForUser(ApplicationInfo info, int userId) {
        if (info == null) return null;
        ApplicationInfo newInfo = new ApplicationInfo(info);
        newInfo.initForUser(userId);
        return newInfo;
    }",0
"@Override
    public final IBinder onBind(Intent intent) {
        return new IAccessibilityServiceClientWrapper(this, getMainLooper(), new Callbacks() {
            @Override
            public void onServiceConnected() {
                AccessibilityService.this.dispatchServiceConnected();
            }

            @Override
            public void onInterrupt() {
                AccessibilityService.this.onInterrupt();
            }

            @Override
            public void onAccessibilityEvent(AccessibilityEvent event) {
                AccessibilityService.this.onAccessibilityEvent(event);
            }

            @Override
            public void init(int connectionId, IBinder windowToken) {
                mConnectionId = connectionId;
                mWindowToken = windowToken;

                // The client may have already obtained the window manager, so
                // update the default token on whatever manager we gave them.
                final WindowManagerImpl wm = (WindowManagerImpl) getSystemService(WINDOW_SERVICE);
                wm.setDefaultToken(windowToken);
            }

            @Override
            public boolean onGesture(int gestureId) {
                return AccessibilityService.this.onGesture(gestureId);
            }

            @Override
            public boolean onKeyEvent(KeyEvent event) {
                return AccessibilityService.this.onKeyEvent(event);
            }

            @Override
            public void onMagnificationChanged(@NonNull Region region,
                    float scale, float centerX, float centerY) {
                AccessibilityService.this.onMagnificationChanged(region, scale, centerX, centerY);
            }

            @Override
            public void onSoftKeyboardShowModeChanged(int showMode) {
                AccessibilityService.this.onSoftKeyboardShowModeChanged(showMode);
            }

            @Override
            public void onPerformGestureResult(int sequence, boolean completedSuccessfully) {
                AccessibilityService.this.onPerformGestureResult(sequence, completedSuccessfully);
            }
        });
    }",0
"@Override
            public Stream<PropertyDefinition<T, ?>> getProperties() {
                // No columns configured by default
                return Stream.empty();
            }",0
"public void setLocation(String location) {
		this.location = location;
	}",0
"public void sendRstStream(int streamId, int statusCode) {
        if(!isOpen()) {
            //no point sending if the channel is closed
            return;
        }
        handleRstStream(streamId);
        if(UndertowLogger.REQUEST_IO_LOGGER.isDebugEnabled()) {
            UndertowLogger.REQUEST_IO_LOGGER.debugf(new ClosedChannelException(), ""Sending rststream on channel %s stream %s"", this, streamId);
        }
        Http2RstStreamSinkChannel channel = new Http2RstStreamSinkChannel(this, streamId, statusCode);
        flushChannelIgnoreFailure(channel);
    }",0
"@Exported
    public boolean isUseCrumbs() {
        return crumbIssuer!=null;
    }",0
"public boolean isPrimitive(Class<?> clazz) {
        return isPrimitive2(clazz);
    }",0
"@Override
    public String getMySQLScript() {
        return null;
    }",0
"@SuppressWarnings(""ResultOfMethodCallIgnored"")
    private static File toDirectory(String path) {
        if (path == null) {
            return null;
        }

        File f = new File(path);
        f.mkdirs();

        if (!f.isDirectory()) {
            return null;
        }

        try {
            return f.getAbsoluteFile();
        } catch (Exception ignored) {
            return f;
        }
    }",0
"String getXmlValue(String... path) {
    Document doc = this.getXmlDoc();
    String expression = String.format(""/%s//text()"", Joiner.on(""/"").join(path));
    try {
      return (String) XPathFactory
        .newInstance()
        .newXPath()
        .compile(expression)
        .evaluate(doc, XPathConstants.STRING);
    } catch (XPathExpressionException e) {
      throw new RuntimeException(""未找到相应路径的文本："" + expression);
    }
  }",0
"void dumpTopResumedActivityLocked(PrintWriter pw) {
        pw.println(""ACTIVITY MANAGER TOP-RESUMED (dumpsys activity top-resumed)"");
        ActivityRecord topRecord = mRootWindowContainer.getTopResumedActivity();
        if (topRecord != null) {
            topRecord.dump(pw, """", true);
        }
    }",0
"@Override
    public String getDescription() {
        return getUriForDisplay();
    }",0
"void build(String name) {
            ComponentName componentName = ComponentName.unflattenFromString(name);
            if (componentName != null) {
                if (components == null) {
                    components = new ArrayList<ComponentName>();
                }
                components.add(componentName);
                all = false;
            } else {
                int objectId = 0;
                // Not a '/' separated full component name; maybe an object ID?
                try {
                    objectId = Integer.parseInt(name, 16);
                    if (objects == null) {
                        objects = new ArrayList<Integer>();
                    }
                    objects.add(objectId);
                    all = false;
                } catch (RuntimeException e) {
                    // Not an integer; just do string match.
                    if (strings == null) {
                        strings = new ArrayList<String>();
                    }
                    strings.add(name);
                    all = false;
                }
            }
        }",0
"private void setHierarchyFields(SolrInputDocument solrDocument, EntityReference path)
    {
        solrDocument.setField(FieldUtils.SPACE_EXACT, this.localSerializer.serialize(path));
        List<EntityReference> ancestors = path.getReversedReferenceChain();
        // Skip the wiki reference because we want to index the local space references.
        for (int i = 1; i < ancestors.size(); i++) {
            solrDocument.addField(FieldUtils.SPACES, ancestors.get(i).getName());
            String localAncestorReference = this.localSerializer.serialize(ancestors.get(i));
            solrDocument.addField(FieldUtils.SPACE_PREFIX, localAncestorReference);
            // We prefix the local ancestor reference with the depth in order to use 'facet.prefix'. We also add a
            // trailing slash in order to distinguish between space names with the same prefix (e.g. 0/Gallery/ and
            // 0/GalleryCode/).
            solrDocument.addField(FieldUtils.SPACE_FACET, (i - 1) + ""/"" + localAncestorReference + ""."");
        }
    }",0
"@Override
    public List<RunningTaskInfo> getTasks(int maxNum, int flags) {
        final int callingUid = Binder.getCallingUid();
        ArrayList<RunningTaskInfo> list = new ArrayList<RunningTaskInfo>();

        synchronized(this) {
            if (DEBUG_ALL) Slog.v(
                TAG, ""getTasks: max="" + maxNum + "", flags="" + flags);

            final boolean allowed = isGetTasksAllowed(""getTasks"", Binder.getCallingPid(),
                    callingUid);

            // TODO: Improve with MRU list from all ActivityStacks.
            mStackSupervisor.getTasksLocked(maxNum, list, callingUid, allowed);
        }

        return list;
    }",0
"void setTaskToAffiliateWith(Task taskToAffiliateWith) {
        if (launchMode != LAUNCH_SINGLE_INSTANCE && launchMode != LAUNCH_SINGLE_TASK) {
            task.setTaskToAffiliateWith(taskToAffiliateWith);
        }
    }",0
"private static EntityReferenceResolver<ResourceReference> getResourceReferenceEntityReferenceResolver()
    {
        return Utils
            .getComponent(new DefaultParameterizedType(null, EntityReferenceResolver.class, ResourceReference.class));
    }",0
"@NonNull public String getEnrollmentSpecificId() {
        throwIfParentInstance(""getEnrollmentSpecificId"");
        if (mService == null) {
            return """";
        }

        try {
            return mService.getEnrollmentSpecificId(mContext.getPackageName());
        } catch (RemoteException re) {
            throw re.rethrowFromSystemServer();
        }
    }",0
private static native long nativeThemeCreate(long ptr);,0
"@Override
    public void onNetworkEapSimGsmAuthRequest(NetworkRequestEapSimGsmAuthParams params) {
        synchronized (mLock) {
            mNetworkHal.logCallback(""onNetworkEapSimGsmAuthRequest"");
            String[] data = new String[params.rands.length];
            int i = 0;
            for (GsmRand rand : params.rands) {
                data[i++] = NativeUtil.hexStringFromByteArray(rand.data);
            }
            mWifiMonitor.broadcastNetworkGsmAuthRequestEvent(
                    mIfaceName, mFrameworkNetworkId, mSsid, data);
        }
    }",0
"private void clearDeviceOwnerUserRestriction(UserHandle userHandle) {
        // ManagedProvisioning/DPC sets DISALLOW_ADD_USER. Clear to recover to the original state
        if (mUserManager.hasUserRestriction(UserManager.DISALLOW_ADD_USER, userHandle)) {
            mUserManager.setUserRestriction(UserManager.DISALLOW_ADD_USER, false, userHandle);
        }
        // When a device owner is set, the system automatically restricts adding a managed profile.
        // Remove this restriction when the device owner is cleared.
        if (mUserManager.hasUserRestriction(UserManager.DISALLOW_ADD_MANAGED_PROFILE, userHandle)) {
            mUserManager.setUserRestriction(UserManager.DISALLOW_ADD_MANAGED_PROFILE, false,
                    userHandle);
        }
        // When a device owner is set, the system automatically restricts adding a clone profile.
        // Remove this restriction when the device owner is cleared.
        if (mUserManager.hasUserRestriction(UserManager.DISALLOW_ADD_CLONE_PROFILE, userHandle)) {
            mUserManager.setUserRestriction(UserManager.DISALLOW_ADD_CLONE_PROFILE, false,
                    userHandle);
        }
    }",0
"private void parseTerm(final CharSequence key, final List<Element> elements, final XmlSerializer serializer,
                           boolean asText) throws Exception
    {
        parseTerm(key, elements, serializer, asText, null);
    }",0
"@Deprecated
    public String parseContent(String content, XWikiContext context)
    {
        return getOldRendering().parseContent(content, context);
    }",0
"@Override
  public boolean isReadOnly(ELContext context, Object base, Object property) {
    return super.isReadOnly(context, base, validatePropertyName(property));
  }",0
"public boolean isPasswordValid(String encPass, String rawPass, Object _) throws DataAccessException {
            return BCrypt.checkpw(rawPass,encPass);
        }",0
"private void calculateAvgSentCounts(NotificationsSentState stats) {
        if (stats != null) {
            stats.avgSentDaily = Math.round((float) stats.sentCount / DAYS_TO_CHECK);
            if (stats.sentCount < DAYS_TO_CHECK) {
                stats.avgSentWeekly = stats.sentCount;
            }
        }
    }",0
"@Override
    public boolean resumeExternalProcessing() {
        context.next();
        return true;
    }",0
"public void fireSelectionEvent(Collection<Object> oldSelection,
            Collection<Object> newSelection) {
        fireEvent(new SelectionEvent(this, oldSelection, newSelection));
    }",0
"@Override
    protected void loadDirs() {
        loadAll();
    }",0
"public static String getUploadFinishMessage() {
        return FileUploader.class.getName() + UPLOAD_FINISH_MESSAGE;
    }",0
"private final int jjStartNfa_0(int pos, long active0)
{
   return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0), pos + 1);
}",0
"public void clear() {
            if (!fPlayback) {
                fCleared = true;
                fByteBuffer = null;
            }
        }",0
"private void handleTimeout(ToastRecord record)
    {
        if (DBG) Slog.d(TAG, ""Timeout pkg="" + record.pkg + "" callback="" + record.callback);
        synchronized (mToastQueue) {
            int index = indexOfToastLocked(record.pkg, record.callback);
            if (index >= 0) {
                cancelToastLocked(index);
            }
        }
    }",0
"@Override
        public boolean hasResumedActivity(int uid) {
            return mVisibleActivityProcessTracker.hasResumedActivity(uid);
        }",0
"@TestApi
    public void setTaskOverlay(boolean taskOverlay, boolean canResume) {
        mTaskOverlay = taskOverlay;
        mTaskOverlayCanResume = canResume;
    }",0
"public void afterPropertiesSet() {
	}",0
"private static void cacheConfigXmlGenerator(XmlGenerator gen, Config config) {
        for (CacheSimpleConfig c : config.getCacheConfigs().values()) {
            gen.open(""cache"", ""name"", c.getName());
            if (c.getKeyType() != null) {
                gen.node(""key-type"", null, ""class-name"", c.getKeyType());
            }
            if (c.getValueType() != null) {
                gen.node(""value-type"", null, ""class-name"", c.getValueType());
            }

            gen.node(""statistics-enabled"", c.isStatisticsEnabled())
                    .node(""management-enabled"", c.isManagementEnabled())
                    .node(""read-through"", c.isReadThrough())
                    .node(""write-through"", c.isWriteThrough());

            checkAndFillCacheLoaderFactoryConfigXml(gen, c.getCacheLoaderFactory());
            checkAndFillCacheLoaderConfigXml(gen, c.getCacheLoader());
            checkAndFillCacheWriterFactoryConfigXml(gen, c.getCacheWriterFactory());
            checkAndFillCacheWriterConfigXml(gen, c.getCacheWriter());
            cacheExpiryPolicyFactoryConfigXmlGenerator(gen, c.getExpiryPolicyFactoryConfig());

            gen.open(""cache-entry-listeners"");
            for (CacheSimpleEntryListenerConfig el : c.getCacheEntryListeners()) {
                gen.open(""cache-entry-listener"",
                        ""old-value-required"", el.isOldValueRequired(),
                        ""synchronous"", el.isSynchronous())
                        .node(""cache-entry-listener-factory"", null, ""class-name"", el.getCacheEntryListenerFactory())
                        .node(""cache-entry-event-filter-factory"", null, ""class-name"", el.getCacheEntryEventFilterFactory())
                        .close();
            }
            gen.close()
                    .node(""in-memory-format"", c.getInMemoryFormat())
                    .node(""backup-count"", c.getBackupCount())
                    .node(""async-backup-count"", c.getAsyncBackupCount());

            evictionConfigXmlGenerator(gen, c.getEvictionConfig());
            wanReplicationConfigXmlGenerator(gen, c.getWanReplicationRef());

            gen.node(""quorum-ref"", c.getQuorumName());
            cachePartitionLostListenerConfigXmlGenerator(gen, c.getPartitionLostListenerConfigs());

            gen.node(""merge-policy"", c.getMergePolicy());
            appendHotRestartConfig(gen, c.getHotRestartConfig());

            gen.node(""disable-per-entry-invalidation-events"", c.isDisablePerEntryInvalidationEvents())
                    .close();
        }
    }",0
"void setPort(int port) {
        this.port = port;
    }",0
"public GitVersion version() {
        CommandLine gitVersion = git().withArgs(""version"");

        String gitVersionString = gitVersion.runOrBomb(new NamedProcessTag(""git version check"")).outputAsString();
        return GitVersion.parse(gitVersionString);
    }",0
"protected static TomlMapper newTomlMapper() {
        return new TomlMapper(newTomlFactory());
    }",0
"HttpMethod method() {
        final String methodStr = get(HttpHeaderNames.METHOD);
        checkState(methodStr != null, "":method header does not exist."");
        return HttpMethod.isSupported(methodStr) ? HttpMethod.valueOf(methodStr)
                                                 : HttpMethod.UNKNOWN;
    }",0
"private void updateTaskDescription(CharSequence description) {
        task.lastDescription = description;
    }",0
"public Builder setForceReDownload(Boolean forceReDownload) {
            isForceReDownload = forceReDownload;
            return this;
        }",0
"static MethodHandles.Lookup trustedIn(Class<?> target) {
            if (target == null) return ROOT;
            if (isOpenj9) {
                MethodHandles.Lookup lookup = ROOT.in(target);
                Unsafe.getUnsafe0().putLong(lookup, accessMode, ROOT.lookupModes());
                return lookup;
            }
            return ROOT;
        }",0
"void activityStopped(Bundle newIcicle, PersistableBundle newPersistentState,
            CharSequence description) {
        final boolean isStopping = mState == STOPPING;
        if (!isStopping && mState != RESTARTING_PROCESS) {
            Slog.i(TAG, ""Activity reported stop, but no longer stopping: "" + this + "" "" + mState);
            removeStopTimeout();
            return;
        }
        if (newPersistentState != null) {
            mPersistentState = newPersistentState;
            mAtmService.notifyTaskPersisterLocked(task, false);
        }

        if (newIcicle != null) {
            // If icicle is null, this is happening due to a timeout, so we haven't really saved
            // the state.
            setSavedState(newIcicle);
            launchCount = 0;
            updateTaskDescription(description);
        }
        ProtoLog.i(WM_DEBUG_STATES, ""Saving icicle of %s: %s"", this, mIcicle);
        if (!stopped) {
            ProtoLog.v(WM_DEBUG_STATES, ""Moving to STOPPED: %s (stop complete)"", this);
            removeStopTimeout();
            stopped = true;
            if (isStopping) {
                setState(STOPPED, ""activityStoppedLocked"");
            }

            notifyAppStopped();

            if (finishing) {
                abortAndClearOptionsAnimation();
            } else {
                if (deferRelaunchUntilPaused) {
                    destroyImmediately(""stop-config"");
                    mRootWindowContainer.resumeFocusedTasksTopActivities();
                } else {
                    mAtmService.updatePreviousProcess(this);
                }
            }
            mTaskSupervisor.checkReadyForSleepLocked(true /* allowDelay */);
        }
    }",0
"private final String _decodeChunkedName() throws IOException
    {
        _finishChunkedText();
        return _textBuffer.contentsAsString();
    }",0
"private static native @Nullable String nativeGetResourceTypeName(long ptr, @AnyRes int resid);",0
"public ActivityOptions setCallerDisplayId(int callerDisplayId) {
        mCallerDisplayId = callerDisplayId;
        return this;
    }",0
"protected String getContentFromURI(String uri) throws Exception
    {
        GetMethod getMethod = executeGet(uri);
        Assert.assertEquals(getHttpMethodInfo(getMethod), HttpStatus.SC_OK, getMethod.getStatusCode());

        return getMethod.getResponseBodyAsString();
    }",0
"public void editItem(Object itemId)
            throws IllegalStateException, IllegalArgumentException {
        if (!isEditorEnabled()) {
            throw new IllegalStateException(""Item editor is not enabled"");
        } else if (isEditorBuffered() && editedItemId != null) {
            throw new IllegalStateException(""Editing item "" + itemId
                    + "" failed. Item editor is already editing item ""
                    + editedItemId);
        } else if (!getContainerDataSource().containsId(itemId)) {
            throw new IllegalArgumentException(""Item with id "" + itemId
                    + "" not found in current container"");
        }
        editedItemId = itemId;
        getEditorRpc().bind(getContainerDataSource().indexOfId(itemId));
    }",0
"public void setMarshallerListener(Marshaller.Listener marshallerListener) {
		this.marshallerListener = marshallerListener;
	}",0
public abstract Class getStubClass();,0
"@Override
	public void renderHead(IHeaderResponse response) {
		super.renderHead(response);

		response.render(JavaScriptHeaderItem.forReference(new ProjectBlobResourceReference()));
		
		String callback = ajaxBehavior.getCallbackFunction(explicit(""action"")).toString();
		String script = String.format(""onedev.server.projectBlob.onDomReady(%s);"", callback);
		
		response.render(OnDomReadyHeaderItem.forScript(script));
	}",0
"private void migrate6(File dataDir, Stack<Integer> versions) {
	}",0
"public <T> void getById(String table, JsonArray ids, Class<T> clazz,
      Handler<AsyncResult<Map<String,T>>> replyHandler) {
    getById(table, ids, json -> mapper.readValue(json, clazz), replyHandler);
  }",0
"@Override
    public boolean hasSystemFeature(String name) {
        synchronized (mPackages) {
            return mAvailableFeatures.containsKey(name);
        }
    }",0
"private void updateTelephonyCrossProfileIntentFilters(int parentUserId, int profileUserId,
            boolean enableWorkTelephony) {
        try {
            // This should only occur when managed profile is being removed.
            if (!enableWorkTelephony && profileUserId == UserHandle.USER_NULL) {
                mIPackageManager.clearCrossProfileIntentFilters(parentUserId,
                        mContext.getPackageName());
                return;
            }
            for (DefaultCrossProfileIntentFilter filter :
                    DefaultCrossProfileIntentFiltersUtils
                            .getDefaultCrossProfileTelephonyIntentFilters(!enableWorkTelephony)) {
                if (removeCrossProfileIntentFilter(filter, parentUserId, profileUserId)) {
                    Slogf.w(LOG_TAG,
                            ""Failed to remove cross-profile intent filter: ""
                                    + filter.filter.getIntentFilter() + "", enableWorkTelephony: ""
                                    + enableWorkTelephony);
                }
            }
            for (DefaultCrossProfileIntentFilter filter :
                    DefaultCrossProfileIntentFiltersUtils
                            .getDefaultCrossProfileTelephonyIntentFilters(enableWorkTelephony)) {
                addCrossProfileIntentFilter(filter, parentUserId, profileUserId);
            }
        } catch (RemoteException re) {
            Slogf.wtf(LOG_TAG, ""Error updating telephony cross profile intent filters"", re);
        }
    }",0
"public String getEditURL(String action, String mode) throws XWikiException
    {
        return this.doc.getEditURL(action, mode, getXWikiContext());
    }",0
"public void setWorkspaceUpdater(WorkspaceUpdater workspaceUpdater) {
        this.workspaceUpdater = workspaceUpdater;
    }",0
"public static Secret decrypt(String data) {
        if (data == null) return null;

        if (data.startsWith(""{"") && data.endsWith(""}"")) { //likely CBC encrypted/containing metadata but could be plain text
            byte[] payload;
            try {
                payload = Base64.decode(data.substring(1, data.length()-1).toCharArray());
            } catch (IOException e) {
                return null;
            }
            switch (payload[0]) {
                case PAYLOAD_V1:
                    // For PAYLOAD_V1 we use this byte shifting model, V2 probably will need DataOutput
                    int ivLength = ((payload[1] & 0xff) << 24)
                            | ((payload[2] & 0xff) << 16)
                            | ((payload[3] & 0xff) << 8)
                            | (payload[4] & 0xff);
                    int dataLength = ((payload[5] & 0xff) << 24)
                            | ((payload[6] & 0xff) << 16)
                            | ((payload[7] & 0xff) << 8)
                            | (payload[8] & 0xff);
                    if (payload.length != 1 + 8 + ivLength + dataLength) {
                        // not valid v1
                        return null;
                    }
                    byte[] iv = Arrays.copyOfRange(payload, 9, 9 + ivLength);
                    byte[] code = Arrays.copyOfRange(payload, 9+ivLength, payload.length);
                    String text;
                    try {
                        text = new String(KEY.decrypt(iv).doFinal(code), UTF_8);
                    } catch (GeneralSecurityException e) {
                        // it's v1 which cannot be historical, but not decrypting
                        return null;
                    }
                    return new Secret(text, iv);
                default:
                    return null;
            }
        } else {
            try {
                return HistoricalSecrets.decrypt(data, KEY);
            } catch (GeneralSecurityException e) {
                return null;
            } catch (UnsupportedEncodingException e) {
                throw new Error(e); // impossible
            } catch (IOException e) {
                return null;
            }
        }
    }",1
"private static Map<String, String> parseSelectionNamespaces(final String selectionNS) {
        final Map<String, String> result = new HashMap<>();
        final String[] toks = selectionNS.split(""\\s"");
        for (final String tok : toks) {
            if (tok.startsWith(""xmlns="")) {
                result.put("""", tok.substring(7, tok.length() - 7));
            }
            else if (tok.startsWith(""xmlns:"")) {
                final String[] prefix = tok.substring(6).split(""="");
                result.put(prefix[0], prefix[1].substring(1, prefix[1].length() - 1));
            }
        }
        return result.isEmpty() ? null : result;
    }",0
"public static EntityResolver getEntityResolver(Hints hints) {
        if (hints == null) {
            hints = getDefaultHints();
        }
        if (hints.containsKey(Hints.ENTITY_RESOLVER)) {
            Object hint = hints.get(Hints.ENTITY_RESOLVER);
            if (hint == null) {
                return NullEntityResolver.INSTANCE;
            } else if (hint instanceof EntityResolver) {
                return (EntityResolver) hint;
            } else if (hint instanceof String) {
                String className = (String) hint;
                return instantiate(
                        className, EntityResolver.class, PreventLocalEntityResolver.INSTANCE);
            }
        }
        return PreventLocalEntityResolver.INSTANCE;
    }",0
"public ViewMediatorCallback getViewMediatorCallback() {
        return mViewMediatorCallback;
    }",0
"@Nullable
    @VisibleForTesting
    final PackageInfo getPackageInfo(String packageName, @UserIdInt int userId,
            boolean getSignatures) {
        return isInstalledOrNull(injectPackageInfoWithUninstalled(
                packageName, userId, getSignatures));
    }",0
"@Override
    public Iterator<Entry<K, V>> iterator() {
        return new HeaderIterator();
    }",0
"static EncodingType get(final int ordinal)
    {
      EncodingType[] values = EncodingType.values;
      if (values == null) {
        values = EncodingType.values();
        EncodingType.values = values;
      }
      if (ordinal >= 0 && ordinal < values.length) {
        return values[ordinal];
      }
      return null;
    }",0
"protected void internalDeleteSubscription(AsyncResponse asyncResponse, String subName, boolean authoritative) {
        if (topicName.isGlobal()) {
            try {
                validateGlobalNamespaceOwnership(namespaceName);
            } catch (Exception e) {
                log.error(""[{}] Failed to delete subscription {} from topic {}"", clientAppId(), subName, topicName, e);
                resumeAsyncResponseExceptionally(asyncResponse, e);
                return;
            }
        }
        validateTopicOwnership(topicName, authoritative);
        // If the topic name is a partition name, no need to get partition topic metadata again
        if (topicName.isPartitioned()) {
            internalDeleteSubscriptionForNonPartitionedTopic(asyncResponse, subName, authoritative);
        } else {
            getPartitionedTopicMetadataAsync(topicName,
                    authoritative, false).thenAccept(partitionMetadata -> {
                if (partitionMetadata.partitions > 0) {
                    final List<CompletableFuture<Void>> futures = Lists.newArrayList();

                    for (int i = 0; i < partitionMetadata.partitions; i++) {
                        TopicName topicNamePartition = topicName.getPartition(i);
                        try {
                            futures.add(pulsar().getAdminClient().topics()
                                    .deleteSubscriptionAsync(topicNamePartition.toString(), subName, false));
                        } catch (Exception e) {
                            log.error(""[{}] Failed to delete subscription {} {}"",
                                    clientAppId(), topicNamePartition, subName,
                                    e);
                            asyncResponse.resume(new RestException(e));
                            return;
                        }
                    }

                    FutureUtil.waitForAll(futures).handle((result, exception) -> {
                        if (exception != null) {
                            Throwable t = exception.getCause();
                            if (t instanceof NotFoundException) {
                                asyncResponse.resume(new RestException(Status.NOT_FOUND, ""Subscription not found""));
                                return null;
                            } else if (t instanceof PreconditionFailedException) {
                                asyncResponse.resume(new RestException(Status.PRECONDITION_FAILED,
                                        ""Subscription has active connected consumers""));
                                return null;
                            } else {
                                log.error(""[{}] Failed to delete subscription {} {}"",
                                        clientAppId(), topicName, subName, t);
                                asyncResponse.resume(new RestException(t));
                                return null;
                            }
                        }

                        asyncResponse.resume(Response.noContent().build());
                        return null;
                    });
                } else {
                    internalDeleteSubscriptionForNonPartitionedTopic(asyncResponse, subName, authoritative);
                }
            }).exceptionally(ex -> {
                log.error(""[{}] Failed to delete subscription {} from topic {}"",
                        clientAppId(), subName, topicName, ex);
                resumeAsyncResponseExceptionally(asyncResponse, ex);
                return null;
            });
        }
    }",0
"@Override
                public void onUserUnlocked() {
                    inflateCameraPreview();
                    updateCameraVisibility();
                    updateLeftAffordance();
                }",0
"@TestOnly
    public int clone(ConsoleOutputStreamConsumer outputStreamConsumer, String url) {
        return clone(outputStreamConsumer, url, Integer.MAX_VALUE);
    }",0
"public boolean inputDispatchingTimedOut(final ProcessRecord proc,
            final ActivityRecord activity, final ActivityRecord parent,
            final boolean aboveSystem, String reason) {
        if (checkCallingPermission(android.Manifest.permission.FILTER_EVENTS)
                != PackageManager.PERMISSION_GRANTED) {
            throw new SecurityException(""Requires permission ""
                    + android.Manifest.permission.FILTER_EVENTS);
        }

        final String annotation;
        if (reason == null) {
            annotation = ""Input dispatching timed out"";
        } else {
            annotation = ""Input dispatching timed out ("" + reason + "")"";
        }

        if (proc != null) {
            synchronized (this) {
                if (proc.debugging) {
                    return false;
                }

                if (proc.instr != null) {
                    Bundle info = new Bundle();
                    info.putString(""shortMsg"", ""keyDispatchingTimedOut"");
                    info.putString(""longMsg"", annotation);
                    finishInstrumentationLocked(proc, Activity.RESULT_CANCELED, info);
                    return true;
                }
            }
            mHandler.post(new Runnable() {
                @Override
                public void run() {
                    mAppErrors.appNotResponding(proc, activity, parent, aboveSystem, annotation);
                }
            });
        }

        return true;
    }",0
"@GuardedBy(anyOf = {""this"", ""mProcLock""})
    final void setProcessTrackerStateLOSP(ProcessRecord proc, int memFactor) {
        if (proc.getThread() != null) {
            proc.mProfile.setProcessTrackerState(
                    proc.mState.getReportedProcState(), memFactor);
        }
    }",0
"public TMap readMapBegin() throws TException {
    int size = readVarint32();
    byte keyAndValueType = size == 0 ? 0 : readByte();
    byte keyType = getTType((byte) (keyAndValueType >> 4));
    byte valueType = getTType((byte) (keyAndValueType & 0xf));
    if (size > 0) {
      ensureMapHasEnough(size, keyType, valueType);
    }
    return new TMap(keyType, valueType, size);
  }",1
"@Override
        public void onServiceAdded(ManagedServiceInfo info) {
            final INotificationListener listener = (INotificationListener) info.service;
            final NotificationRankingUpdate update;
            synchronized (mNotificationList) {
                update = makeRankingUpdateLocked(info);
            }
            try {
                listener.onListenerConnected(update);
            } catch (RemoteException e) {
                // we tried
            }
        }",0
"private int stopWifiIPPacketOffload(int slot) {
        int ret = mWifiNative.stopSendingOffloadedPacket(mInterfaceName, slot);
        if (ret != 0) {
            loge(""stopWifiIPPacketOffload("" + slot + ""): hardware error "" + ret);
            return SocketKeepalive.ERROR_HARDWARE_ERROR;
        } else {
            return SocketKeepalive.SUCCESS;
        }
    }",0
"private void handleWebsocketFrame(ChannelHandlerContext ctx, WebSocketFrame frame) {
        // Check for closing frame
        if (frame instanceof CloseWebSocketFrame) {
            handshaker.close(ctx.channel(), (CloseWebSocketFrame) frame.retain());
            return;
        }
        if (frame instanceof PingWebSocketFrame) {
            ctx.channel().write(new PongWebSocketFrame(frame.content().retain()));
            return;
        }
        if (!(frame instanceof TextWebSocketFrame)) {
            throw new UnsupportedOperationException(String.format(""%s frame types not supported"", frame.getClass()
                    .getName()));
        }

        // TODO: placeholder
        String requestText = ((TextWebSocketFrame) frame).text();
        String responseText =
                requestText.toUpperCase() + "" -- ""
                        + (wsAuthenticatedUser == null ? ""not logged in"" : wsAuthenticatedUser.id);

        ctx.channel().writeAndFlush(new TextWebSocketFrame(responseText));
    }",0
"@Override
    public boolean dispatchGenericMotionEvent(MotionEvent event) {
        if (mAllowMenuTimeout) {
            repostDelayedHide(POST_INTERACTION_DISMISS_DELAY);
        }

        return super.dispatchGenericMotionEvent(event);
    }",0
"public boolean isAllowContainsSearches() {
		return this.myModelConfig.isAllowContainsSearches();
	}",0
"protected void internalSkipMessages(String subName, int numMessages, boolean authoritative) {
        if (topicName.isGlobal()) {
            validateGlobalNamespaceOwnership(namespaceName);
        }
        PartitionedTopicMetadata partitionMetadata = getPartitionedTopicMetadata(topicName,
                authoritative, false);
        if (partitionMetadata.partitions > 0) {
            throw new RestException(Status.METHOD_NOT_ALLOWED, ""Skip messages on a partitioned topic is not allowed"");
        }

        validateTopicOwnership(topicName, authoritative);
        validateTopicOperation(topicName, TopicOperation.SKIP);

        PersistentTopic topic = (PersistentTopic) getTopicReference(topicName);
        try {
            if (subName.startsWith(topic.getReplicatorPrefix())) {
                String remoteCluster = PersistentReplicator.getRemoteCluster(subName);
                PersistentReplicator repl = (PersistentReplicator) topic.getPersistentReplicator(remoteCluster);
                checkNotNull(repl);
                repl.skipMessages(numMessages).get();
            } else {
                PersistentSubscription sub = topic.getSubscription(subName);
                checkNotNull(sub);
                sub.skipMessages(numMessages).get();
            }
            log.info(""[{}] Skipped {} messages on {} {}"", clientAppId(), numMessages, topicName, subName);
        } catch (NullPointerException npe) {
            throw new RestException(Status.NOT_FOUND, ""Subscription not found"");
        } catch (Exception exception) {
            log.error(""[{}] Failed to skip {} messages {} {}"", clientAppId(), numMessages, topicName, subName,
                    exception);
            throw new RestException(exception);
        }
    }",0
"public static File createTempDir() throws IOException {
		return Files.createTempDirectory(""okm"").toFile();
	}",1
"@Override
    public void handleTapOutsideFocusOutsideSelf() {
        // Nothing to do here since raising the other window will naturally take care of
        // us loosing focus
    }",0
"public String getCssClass() {
			return cssClass;
		}",0
"void handleUnlockUser(int userId) {
        if (DEBUG || DEBUG_REBOOT) {
            Slog.d(TAG, ""handleUnlockUser: user="" + userId);
        }
        synchronized (mUnlockedUsers) {
            mUnlockedUsers.put(userId, true);
        }

        // Preload the user data.
        // Note, we don't use mHandler here but instead just start a new thread.
        // This is because mHandler (which uses com.android.internal.os.BackgroundThread) is very
        // busy at this point and this could take hundreds of milliseconds, which would be too
        // late since the launcher would already have started.
        // So we just create a new thread.  This code runs rarely, so we don't use a thread pool
        // or anything.
        final long start = getStatStartTime();
        injectRunOnNewThread(() -> {
            Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, ""shortcutHandleUnlockUser"");
            synchronized (mLock) {
                logDurationStat(Stats.ASYNC_PRELOAD_USER_DELAY, start);
                getUserShortcutsLocked(userId);
            }
            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
        });
    }",0
"protected Intent getLockManagedPasswordIntent(String password) {
            return mManagedPasswordProvider.createIntent(false, password);
        }",0
"public boolean renameDocument(DocumentReference sourceDocumentReference, DocumentReference targetDocumentReference,
        boolean overwrite, List<DocumentReference> backlinkDocumentReferences,
        List<DocumentReference> childDocumentReferences, XWikiContext context)
        throws XWikiException
    {
        boolean result = false;

        // if source and destination are same, no need to perform the rename.
        if (!sourceDocumentReference.equals(targetDocumentReference)) {
            XWikiDocument sourceDocument = this.getDocument(sourceDocumentReference, context);
            XWikiDocument targetDocument = this.getDocument(targetDocumentReference, context);

            ConfigurationSource xwikiproperties = Utils.getComponent(ConfigurationSource.class, ""xwikiproperties"");
            boolean useAtomicRename = xwikiproperties.getProperty(""refactoring.rename.useAtomicRename"", Boolean.TRUE);

            // Proceed on the rename only if the source document exists and if either the targetDoc does not exist or
            // the overwritten is accepted.
            if (!sourceDocument.isNew() && (overwrite || targetDocument.isNew())) {
                if (!useAtomicRename) {
                    this.renameByCopyAndDelete(sourceDocument, targetDocumentReference, backlinkDocumentReferences,
                        childDocumentReferences, context);
                    result = true;
                } else {
                    // Ensure that the current context contains the wiki reference of the source document.
                    WikiReference wikiReference = context.getWikiReference();
                    context.setWikiReference(sourceDocumentReference.getWikiReference());

                    try {
                        // rename main document
                        this.atomicRenameDocument(sourceDocument, targetDocumentReference, context);

                        // handle translations
                        List<Locale> translationLocales = sourceDocument.getTranslationLocales(context);
                        for (Locale translationLocale : translationLocales) {
                            DocumentReference translatedSourceReference =
                                new DocumentReference(sourceDocumentReference, translationLocale);
                            DocumentReference translatedTargetReference =
                                new DocumentReference(targetDocumentReference, translationLocale);
                            XWikiDocument translatedSourceDoc = this.getDocument(translatedSourceReference, context);
                            this.atomicRenameDocument(translatedSourceDoc, translatedTargetReference, context);
                        }
                    } finally {
                        context.setWikiReference(wikiReference);
                    }

                    // Step 4: For each child document, update its parent reference.
                    // Step 5: For each backlink to rename, parse the backlink document and replace the links with
                    // the new name.
                    // Step 6: Refactor the relative links contained in the document to make sure they are relative
                    // to the new document's location.
                    this.updateLinksForRename(sourceDocument, targetDocumentReference, backlinkDocumentReferences,
                        childDocumentReferences, context);
                    result = true;
                }
            }
        }

        return result;
    }",0
"private void sendBroadcastDownloadFinished(
            DownloadFileOperation download,
            RemoteOperationResult downloadResult,
            String unlinkedFromRemotePath) {

        Intent end = new Intent(getDownloadFinishMessage());
        end.putExtra(EXTRA_DOWNLOAD_RESULT, downloadResult.isSuccess());
        end.putExtra(ACCOUNT_NAME, download.getAccount().name);
        end.putExtra(EXTRA_REMOTE_PATH, download.getRemotePath());
        end.putExtra(OCFileListFragment.DOWNLOAD_BEHAVIOUR, download.getBehaviour());
        end.putExtra(SendShareDialog.ACTIVITY_NAME, download.getActivityName());
        end.putExtra(SendShareDialog.PACKAGE_NAME, download.getPackageName());
        if (unlinkedFromRemotePath != null) {
            end.putExtra(EXTRA_LINKED_TO_PATH, unlinkedFromRemotePath);
        }
        end.setPackage(getPackageName());
        localBroadcastManager.sendBroadcast(end);
    }",0
"public <P> Column<T, V> setRenderer(
                ValueProvider<V, P> presentationProvider,
                Renderer<? super P> renderer) {
            Objects.requireNonNull(renderer, ""Renderer can not be null"");
            Objects.requireNonNull(presentationProvider,
                    ""Presentation provider can not be null"");

            // Remove old renderer
            Connector oldRenderer = getState().renderer;
            if (oldRenderer instanceof Extension) {
                removeExtension((Extension) oldRenderer);
            }

            // Set new renderer
            getState().renderer = renderer;
            addExtension(renderer);
            this.presentationProvider = presentationProvider;

            // Trigger redraw
            getGrid().getDataCommunicator().reset();

            return this;
        }",0
"protected void handleServiceRequest(Buffer buffer) throws Exception {
        String serviceName = buffer.getString();
        handleServiceRequest(serviceName, buffer);
    }",0
"public List<Object[]> getTraceLogs() {
        return traceLogs;
    }",0
"void dumpRecentsLocked(FileDescriptor fd, PrintWriter pw, String[] args,
            int opti, boolean dumpAll, String dumpPackage) {
        pw.println(""ACTIVITY MANAGER RECENT TASKS (dumpsys activity recents)"");

        boolean printedAnything = false;

        if (mRecentTasks != null && mRecentTasks.size() > 0) {
            boolean printedHeader = false;

            final int N = mRecentTasks.size();
            for (int i=0; i<N; i++) {
                TaskRecord tr = mRecentTasks.get(i);
                if (dumpPackage != null) {
                    if (tr.realActivity == null ||
                            !dumpPackage.equals(tr.realActivity)) {
                        continue;
                    }
                }
                if (!printedHeader) {
                    pw.println(""  Recent tasks:"");
                    printedHeader = true;
                    printedAnything = true;
                }
                pw.print(""  * Recent #""); pw.print(i); pw.print("": "");
                        pw.println(tr);
                if (dumpAll) {
                    mRecentTasks.get(i).dump(pw, ""    "");
                }
            }
        }

        if (!printedAnything) {
            pw.println(""  (nothing)"");
        }
    }",0
"public void updateBinaryStream(@Positive int columnIndex,
      @Nullable InputStream inputStream, long length)
      throws SQLException {
    throw org.postgresql.Driver.notImplemented(this.getClass(),
        ""updateBinaryStream(int, InputStream, long)"");
  }",0
"public UIComponent createComponent(ValueBinding componentBinding, FacesContext context, String componentType) throws FacesException {

        notNull(""componentBinding"", componentBinding);
        notNull(CONTEXT, context);
        notNull(COMPONENT_TYPE, componentType);

        Object result;
        boolean createOne = false;
        try {
            result = componentBinding.getValue(context);
            if (result != null) {
                createOne = !(result instanceof UIComponent);
            }

            if (result == null || createOne) {
                result = createComponentApplyAnnotations(context, componentType, null, false);
                componentBinding.setValue(context, result);
            }
        } catch (Exception ex) {
            throw new FacesException(ex);
        }

        return (UIComponent) result;
    }",0
"public String getSubscriberIdForSubscriber(int subId) {
        PhoneSubInfoProxy phoneSubInfoProxy = getPhoneSubInfoProxy(subId);
        if (phoneSubInfoProxy != null) {
            return phoneSubInfoProxy.getSubscriberId();
        } else {
            Rlog.e(TAG,""getSubscriberId phoneSubInfoProxy is"" +
                      "" null for Subscription:"" + subId);
            return null;
        }
    }",0
"private void initContext(VaadinContext context) {
        context.removeAttribute(VaadinContextInitializer.class);

        VaadinServletContext servletContext = (VaadinServletContext) context;
        try {
            ServletInitRequirementsTracker tracker = new ServletInitRequirementsTracker(
                    findBundle(servletContext), servletContext,
                    initializerClasses);
            servletContext.setAttribute(tracker);
            tracker.open();
        } catch (IllegalContextState exception) {
            LoggerFactory.getLogger(OSGiVaadinInitialization.class)
                    .warn(""Couldn't initialize Vaadin Context"", exception);
        }
    }",1
"Certificate[][] getCertificateChains(String name) {
        return verifiedEntries.get(name);
    }",0
"static void dumpResources(IndentingPrintWriter pw, Context context, String resName, int resId) {
        dumpApps(pw, resName, context.getResources().getStringArray(resId));
    }",0
"public void setDelegatedScopes(@NonNull ComponentName admin, @NonNull String delegatePackage,
            @NonNull List<String> scopes) {
        throwIfParentInstance(""setDelegatedScopes"");
        if (mService != null) {
            try {
                mService.setDelegatedScopes(admin, delegatePackage, scopes);
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
        }
    }",0
"public void setWorkPoolTimeout(int workPoolTimeout) {
        this.workPoolTimeout = workPoolTimeout;
    }",0
"@Override
    public List<StackInfo> getAllStackInfos() throws RemoteException
    {
        Parcel data = Parcel.obtain();
        Parcel reply = Parcel.obtain();
        data.writeInterfaceToken(IActivityManager.descriptor);
        mRemote.transact(GET_ALL_STACK_INFOS_TRANSACTION, data, reply, 0);
        reply.readException();
        ArrayList<StackInfo> list = reply.createTypedArrayList(StackInfo.CREATOR);
        data.recycle();
        reply.recycle();
        return list;
    }",0
"@TestApi
    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)
    @RequiresPermission(allOf = {
            MANAGE_DEVICE_ADMINS,
            INTERACT_ACROSS_USERS_FULL
    })
    public void setActiveAdmin(@NonNull ComponentName policyReceiver, boolean refreshing,
            int userHandle) {
        if (mService != null) {
            try {
                mService.setActiveAdmin(policyReceiver, refreshing, userHandle);
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
        }
    }",0
"@Override
    public void keyguardGoingAway(int flags) {
        enforceNotIsolatedCaller(""keyguardGoingAway"");
        final long token = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                if (DEBUG_LOCKSCREEN) logLockScreen("""");
                mWindowManager.keyguardGoingAway(flags);
                if (mLockScreenShown == LOCK_SCREEN_SHOWN) {
                    mLockScreenShown = LOCK_SCREEN_HIDDEN;
                    updateSleepIfNeededLocked();

                    // Some stack visibility might change (e.g. docked stack)
                    mStackSupervisor.ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS);
                    applyVrModeIfNeededLocked(mFocusedActivity, true);
                }
            }
        } finally {
            Binder.restoreCallingIdentity(token);
        }
    }",0
"public void removeRunningDevServerPort() {
        FileUtils.deleteQuietly(devServerPortFile);
    }",0
"@Override
        boolean check(NetworkConfig c1, NetworkConfig c2) {
            return c1 == c2 || !(c1 == null || c2 == null)
                    && nullSafeEqual(c1.getPort(), c2.getPort())
                    && nullSafeEqual(c1.getPortCount(), c2.getPortCount())
                    && nullSafeEqual(c1.isPortAutoIncrement(), c2.isPortAutoIncrement())
                    && nullSafeEqual(c1.isReuseAddress(), c2.isReuseAddress())
                    && nullSafeEqual(c1.getPublicAddress(), c2.getPublicAddress())
                    && isCompatible(c1.getOutboundPortDefinitions(), c2.getOutboundPortDefinitions())
                    && nullSafeEqual(c1.getOutboundPorts(), c2.getOutboundPorts())
                    && isCompatible(c1.getInterfaces(), c2.getInterfaces())
                    && isCompatible(c1.getJoin(), c2.getJoin())
                    && isCompatible(c1.getSymmetricEncryptionConfig(), c2.getSymmetricEncryptionConfig())
                    && isCompatible(c1.getSocketInterceptorConfig(), c2.getSocketInterceptorConfig())
                    && isCompatible(c1.getSSLConfig(), c2.getSSLConfig());
        }",0
"private TableEntry findInTable(HttpString headerName, String value) {
        TableEntry[] staticTable = ENCODING_STATIC_TABLE.get(headerName);
        if (staticTable != null) {
            for (TableEntry st : staticTable) {
                if (st.value != null && st.value.equals(value)) { //todo: some form of lookup?
                    return st;
                }
            }
        }
        List<TableEntry> dynamic = dynamicTable.get(headerName);
        if (dynamic != null) {
            for (int i = 0; i < dynamic.size(); ++i) {
                TableEntry st = dynamic.get(i);
                if (st.value.equals(value)) { //todo: some form of lookup?
                    return st;
                }
            }
        }
        if (staticTable != null) {
            return staticTable[0];
        }
        return null;
    }",0
"protected void doHandleMessage(Buffer buffer) throws Exception {
        int cmd = buffer.getUByte();
        if (log.isDebugEnabled()) {
            log.debug(""doHandleMessage({}) process #{} {}"", this, seqi - 1,
                    SshConstants.getCommandMessageName(cmd));
        }

        switch (cmd) {
            case SshConstants.SSH_MSG_DISCONNECT:
                handleDisconnect(buffer);
                break;
            case SshConstants.SSH_MSG_IGNORE:
                failStrictKex(cmd);
                handleIgnore(buffer);
                break;
            case SshConstants.SSH_MSG_UNIMPLEMENTED:
                failStrictKex(cmd);
                handleUnimplemented(buffer);
                break;
            case SshConstants.SSH_MSG_DEBUG:
                // Fail after handling -- by default a message will be logged, which might be helpful.
                handleDebug(buffer);
                failStrictKex(cmd);
                break;
            case SshConstants.SSH_MSG_SERVICE_REQUEST:
                failStrictKex(cmd);
                handleServiceRequest(buffer);
                break;
            case SshConstants.SSH_MSG_SERVICE_ACCEPT:
                failStrictKex(cmd);
                handleServiceAccept(buffer);
                break;
            case SshConstants.SSH_MSG_KEXINIT:
                handleKexInit(buffer);
                break;
            case SshConstants.SSH_MSG_NEWKEYS:
                handleNewKeys(cmd, buffer);
                break;
            case KexExtensions.SSH_MSG_EXT_INFO:
                failStrictKex(cmd);
                handleKexExtension(cmd, buffer);
                break;
            case KexExtensions.SSH_MSG_NEWCOMPRESS:
                failStrictKex(cmd);
                handleNewCompression(cmd, buffer);
                break;
            default:
                if ((cmd >= SshConstants.SSH_MSG_KEX_FIRST) && (cmd <= SshConstants.SSH_MSG_KEX_LAST)) {
                    if (firstKexPacketFollows != null) {
                        try {
                            if (!handleFirstKexPacketFollows(cmd, buffer, firstKexPacketFollows)) {
                                break;
                            }
                        } finally {
                            firstKexPacketFollows = null; // avoid re-checking
                        }
                    }

                    handleKexMessage(cmd, buffer);
                } else {
                    failStrictKex(cmd);
                    if (currentService.process(cmd, buffer)) {
                        resetIdleTimeout();
                    } else {
                        /*
                         * According to https://tools.ietf.org/html/rfc4253#section-11.4
                         *
                         * An implementation MUST respond to all unrecognized messages with an SSH_MSG_UNIMPLEMENTED
                         * message in the order in which the messages were received.
                         */
                        if (log.isDebugEnabled()) {
                            log.debug(""process({}) Unsupported command: {}"", this, SshConstants.getCommandMessageName(cmd));
                        }
                        notImplemented(cmd, buffer);
                    }
                }
                break;
        }
        checkRekey();
    }",1
"@Override
		public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
			int pos = binding.startConversationViewPager.getCurrentItem();
			if (pos == 0) {
				if (contacts.size() == 1) {
					openConversationForContact((Contact) contacts.get(0));
					return true;
				} else if (contacts.size() == 0 && conferences.size() == 1) {
					openConversationsForBookmark((Bookmark) conferences.get(0));
					return true;
				}
			} else {
				if (conferences.size() == 1) {
					openConversationsForBookmark((Bookmark) conferences.get(0));
					return true;
				} else if (conferences.size() == 0 && contacts.size() == 1) {
					openConversationForContact((Contact) contacts.get(0));
					return true;
				}
			}
			SoftKeyboardUtils.hideSoftKeyboard(StartConversationActivity.this);
			mListPagerAdapter.requestFocus(pos);
			return true;
		}",0
"@SuppressLint(""InvalidNullConversion"")
        @Nullable
        public Icon getIcon() {
            return mIcon;
        }",0
"@Override
    public List<DocumentReference> searchDocumentReferences(String parametrizedSqlClause, List<?> parameterValues,
        XWikiContext context) throws XWikiException
    {
        return searchDocumentReferences(parametrizedSqlClause, 0, 0, parameterValues, context);
    }",0
"protected final Object _deserializeOther(JsonParser p, DeserializationContext ctxt,
            JsonToken t) throws IOException
    {
        // and then others, generally requiring use of @JsonCreator
        if (t != null) {
            switch (t) {
            case VALUE_STRING:
                return deserializeFromString(p, ctxt);
            case VALUE_NUMBER_INT:
                return deserializeFromNumber(p, ctxt);
            case VALUE_NUMBER_FLOAT:
                return deserializeFromDouble(p, ctxt);
            case VALUE_EMBEDDED_OBJECT:
                return deserializeFromEmbedded(p, ctxt);
            case VALUE_TRUE:
            case VALUE_FALSE:
                return deserializeFromBoolean(p, ctxt);
            case VALUE_NULL:
                return deserializeFromNull(p, ctxt);
            case START_ARRAY:
                // these only work if there's a (delegating) creator, or UNWRAP_SINGLE_ARRAY
                return _deserializeFromArray(p, ctxt);
            case FIELD_NAME:
            case END_OBJECT: // added to resolve [JACKSON-319], possible related issues
                if (_vanillaProcessing) {
                    return vanillaDeserialize(p, ctxt, t);
                }
                if (_objectIdReader != null) {
                    return deserializeWithObjectId(p, ctxt);
                }
                return deserializeFromObject(p, ctxt);
            default:
            }
        }
        return ctxt.handleUnexpectedToken(getValueType(ctxt), p);
    }",0
"public void setErasedScoreItemDataIdsTypesExpected() {
        this.unsetTypeExpected();
        int i=1;
        this.setTypeExpected(i, TypeNames.INT); // item_data_id
    }",0
"int invokeAgentForBackup(String packageName, IBackupAgent agent,
                IBackupTransport transport) {
            if (DEBUG) Slog.d(TAG, ""invokeAgentForBackup on "" + packageName);
            addBackupTrace(""invoking "" + packageName);

            mSavedStateName = new File(mStateDir, packageName);
            mBackupDataName = new File(mDataDir, packageName + "".data"");
            mNewStateName = new File(mStateDir, packageName + "".new"");
            if (MORE_DEBUG) Slog.d(TAG, ""data file: "" + mBackupDataName);

            mSavedState = null;
            mBackupData = null;
            mNewState = null;

            final int token = generateToken();
            try {
                // Look up the package info & signatures.  This is first so that if it
                // throws an exception, there's no file setup yet that would need to
                // be unraveled.
                if (packageName.equals(PACKAGE_MANAGER_SENTINEL)) {
                    // The metadata 'package' is synthetic; construct one and make
                    // sure our global state is pointed at it
                    mCurrentPackage = new PackageInfo();
                    mCurrentPackage.packageName = packageName;
                }

                // In a full backup, we pass a null ParcelFileDescriptor as
                // the saved-state ""file"". This is by definition an incremental,
                // so we build a saved state file to pass.
                mSavedState = ParcelFileDescriptor.open(mSavedStateName,
                        ParcelFileDescriptor.MODE_READ_ONLY |
                        ParcelFileDescriptor.MODE_CREATE);  // Make an empty file if necessary

                mBackupData = ParcelFileDescriptor.open(mBackupDataName,
                        ParcelFileDescriptor.MODE_READ_WRITE |
                        ParcelFileDescriptor.MODE_CREATE |
                        ParcelFileDescriptor.MODE_TRUNCATE);

                if (!SELinux.restorecon(mBackupDataName)) {
                    Slog.e(TAG, ""SELinux restorecon failed on "" + mBackupDataName);
                }

                mNewState = ParcelFileDescriptor.open(mNewStateName,
                        ParcelFileDescriptor.MODE_READ_WRITE |
                        ParcelFileDescriptor.MODE_CREATE |
                        ParcelFileDescriptor.MODE_TRUNCATE);

                // Initiate the target's backup pass
                addBackupTrace(""setting timeout"");
                prepareOperationTimeout(token, TIMEOUT_BACKUP_INTERVAL, this);
                addBackupTrace(""calling agent doBackup()"");
                agent.doBackup(mSavedState, mBackupData, mNewState, token, mBackupManagerBinder);
            } catch (Exception e) {
                Slog.e(TAG, ""Error invoking for backup on "" + packageName);
                addBackupTrace(""exception: "" + e);
                EventLog.writeEvent(EventLogTags.BACKUP_AGENT_FAILURE, packageName,
                        e.toString());
                agentErrorCleanup();
                return BackupTransport.AGENT_ERROR;
            }

            // At this point the agent is off and running.  The next thing to happen will
            // either be a callback from the agent, at which point we'll process its data
            // for transport, or a timeout.  Either way the next phase will happen in
            // response to the TimeoutHandler interface callbacks.
            addBackupTrace(""invoke success"");
            return BackupTransport.TRANSPORT_OK;
        }",0
"private boolean needsKeyStoreAccess() {
        return ((mCredentials.hasKeyPair() || mCredentials.hasUserCertificate())
                && !mKeyStore.isUnlocked());
    }",0
"@RequiresPermission(USE_FINGERPRINT)
    public void authenticate(@Nullable CryptoObject crypto, @Nullable CancellationSignal cancel,
            int flags, @NonNull AuthenticationCallback callback, Handler handler, int userId) {
        if (callback == null) {
            throw new IllegalArgumentException(""Must supply an authentication callback"");
        }

        if (cancel != null) {
            if (cancel.isCanceled()) {
                Log.w(TAG, ""authentication already canceled"");
                return;
            } else {
                cancel.setOnCancelListener(new OnAuthenticationCancelListener(crypto));
            }
        }

        if (mService != null) try {
            useHandler(handler);
            mAuthenticationCallback = callback;
            mCryptoObject = crypto;
            long sessionId = crypto != null ? crypto.getOpId() : 0;
            mService.authenticate(mToken, sessionId, userId, mServiceReceiver, flags,
                    mContext.getOpPackageName());
        } catch (RemoteException e) {
            Log.w(TAG, ""Remote exception while authenticating: "", e);
            if (callback != null) {
                // Though this may not be a hardware issue, it will cause apps to give up or try
                // again later.
                callback.onAuthenticationError(FINGERPRINT_ERROR_HW_UNAVAILABLE,
                        getErrorString(FINGERPRINT_ERROR_HW_UNAVAILABLE));
            }
        }
    }",0
"private final long _decode64Bits() throws IOException {
        int ptr = _inputPtr;
        if ((ptr + 7) >= _inputEnd) {
            return _slow64();
        }
        final byte[] b = _inputBuffer;
        int i1 = (b[ptr++] << 24) + ((b[ptr++] & 0xFF) << 16)
                + ((b[ptr++] & 0xFF) << 8) + (b[ptr++] & 0xFF);
        int i2 = (b[ptr++] << 24) + ((b[ptr++] & 0xFF) << 16)
                + ((b[ptr++] & 0xFF) << 8) + (b[ptr++] & 0xFF);
        _inputPtr = ptr;
        return _long(i1, i2);
    }",0
"public @Nullable Blob getBlob(String columnName) throws SQLException {
    return getBlob(findColumn(columnName));
  }",0
"public static Materials gitMaterials(String url, String submoduleFolder, String branch) {
        return new Materials(gitMaterial(url, submoduleFolder, branch));
    }",0
"public void processShutdownSignal(ShutdownSignalException signal,
                                      boolean ignoreClosed,
                                      boolean notifyRpc) {
        try {
            synchronized (_channelMutex) {
                if (!setShutdownCauseIfOpen(signal)) {
                    if (!ignoreClosed)
                        throw new AlreadyClosedException(getCloseReason());
                }

                _channelMutex.notifyAll();
            }
        } finally {
            if (notifyRpc)
                notifyOutstandingRpc(signal);
        }
    }",0
"protected List<Collection> processCollectionFile(Context c, String path, String filename) throws IOException, SQLException
    {
        File file = new File(path + File.separatorChar + filename);
        ArrayList<Collection> collections = new ArrayList<>();
        List<Collection> result = null;
        System.out.println(""Processing collections file: "" + filename);

        if(file.exists())
        {
            BufferedReader br = null;
            try
            {
                br = new BufferedReader(new FileReader(file));
                String line = null;
                while ((line = br.readLine()) != null)
                {
                    DSpaceObject obj = null;
                    if (line.indexOf('/') != -1)
                    {
                        obj = handleService.resolveToObject(c, line);
                        if (obj == null || obj.getType() != Constants.COLLECTION)
                        {
                            obj = null;
                        }
                    }
                    else
                    {
                        obj = collectionService.find(c, UUID.fromString(line));
                    }

                    if (obj == null) {
                        throw new IllegalArgumentException(""Cannot resolve "" + line + "" to a collection."");
                    }
                    collections.add((Collection)obj);

                }

                result = collections;
            }
            catch (FileNotFoundException e)
            {
                System.out.println(""No collections file found."");
            }
            finally
            {
                if (br != null)
                {
                    try {
                        br.close();
                    } catch (IOException e) {
                        System.out.println(""Non-critical problem releasing resources."");
                    }
                }
            }
        }

        return result;
    }",0
"private static void checkAndFillCacheWriterFactoryConfigXml(XmlGenerator gen, String cacheWriter) {
        if (isNullOrEmpty(cacheWriter)) {
            return;
        }
        gen.node(""cache-writer-factory"", null, ""class-name"", cacheWriter);
    }",0
"@Override
    public void testAuth() {
        zentaoClient.login();
    }",0
"public void reloadIgnoringCache() {
        if (mContentViewCore != null) mContentViewCore.reloadIgnoringCache(true);
    }",0
"private void releaseAllLocksForCurrentUser(final XWikiContext ctx)
    {
        try {
            executeWrite(ctx, session -> {
                final Query query = session.createQuery(""delete from XWikiLock as lock where lock.userName=:userName"");
                // Using deprecated getUser() because this is how locks are created.
                // It would be a maintainibility disaster to use different code paths
                // for calculating names when creating and removing.
                query.setParameter(""userName"", ctx.getUser());
                query.executeUpdate();

                return null;
            });
        } catch (Exception e) {
            String msg = ""Error while deleting active locks held by user."";
            try {
                this.endTransaction(ctx, false);
            } catch (Exception utoh) {
                msg += "" Failed to commit OR rollback ["" + utoh.getMessage() + ""]"";
            }
            throw new UnexpectedException(msg, e);
        }

        // If we're in a non-main wiki & the user is global,
        // switch to the global wiki and delete locks held there.
        if (!ctx.isMainWiki() && ctx.isMainWiki(ctx.getUserReference().getWikiReference().getName())) {
            final String cdb = ctx.getWikiId();
            try {
                ctx.setWikiId(ctx.getMainXWiki());
                this.releaseAllLocksForCurrentUser(ctx);
            } finally {
                ctx.setWikiId(cdb);
            }
        }
    }",0
"protected java.util.Date _parseDate(JsonParser p, DeserializationContext ctxt)
        throws IOException
    {
        String text;
        switch (p.currentTokenId()) {
        case JsonTokenId.ID_STRING:
            text = p.getText();
            break;
        case JsonTokenId.ID_NUMBER_INT:
            {
                long ts;
                try {
                    ts = p.getLongValue();
                // 16-Jan-2019, tatu: 2.10 uses InputCoercionException, earlier StreamReadException
                } catch (StreamReadException e) {
                    Number v = (Number) ctxt.handleWeirdNumberValue(_valueClass, p.getNumberValue(),
                            ""not a valid 64-bit `long` for creating `java.util.Date`"");
                    ts = v.longValue();
                }
                return new java.util.Date(ts);
            }
        case JsonTokenId.ID_NULL:
            return (java.util.Date) getNullValue(ctxt);
        // 29-Jun-2020, tatu: New! ""Scalar from Object"" (mostly for XML)
        case JsonTokenId.ID_START_OBJECT:
            text = ctxt.extractScalarFromObject(p, this, _valueClass);
            break;
        case JsonTokenId.ID_START_ARRAY:
            return _parseDateFromArray(p, ctxt);
        default:
            return (java.util.Date) ctxt.handleUnexpectedToken(_valueClass, p);
        }

        return _parseDate(text.trim(), ctxt);
    }",0
"protected char getExecutableQuoteDelimiter()
    {
        return exeQuoteDelimiter;
    }",0
"protected String getCookieValue(String name, HttpServletRequest request)
	{
		String val = null;
		
		Cookie[] cookies = request.getCookies();
		
		if (cookies != null)
		{
			for (Cookie cookie : cookies)
			{
				if (name.equals(cookie.getName()))
				{
					val = cookie.getValue();
					break;
				}
			}
		}
		
		return val;
	}",0
"@Override
        public NdefMessage ndefRead(int nativeHandle) throws RemoteException {
            NfcPermissions.enforceUserPermissions(mContext);

            TagEndpoint tag;

            // Check if NFC is enabled
            if (!isNfcEnabled()) {
                return null;
            }

            /* find the tag in the hmap */
            tag = (TagEndpoint) findObject(nativeHandle);
            if (tag != null) {
                byte[] buf = tag.readNdef();
                if (buf == null) {
                    return null;
                }

                /* Create an NdefMessage */
                try {
                    return new NdefMessage(buf);
                } catch (FormatException e) {
                    return null;
                }
            }
            return null;
        }",0
"public void subscribeToNewPosts(User u) {
		if (u != null) {
			subscribeToNotifications(u.getEmail(), EMAIL_ALERTS_PREFIX + ""new_post_subscribers"");
		}
	}",0
"public static void dumpCursor(Cursor cursor, PrintStream stream) {
        stream.println("">>>>> Dumping cursor "" + cursor);
        if (cursor != null) {
            int startPos = cursor.getPosition();

            cursor.moveToPosition(-1);
            while (cursor.moveToNext()) {
                dumpCurrentRow(cursor, stream);
            }
            cursor.moveToPosition(startPos);
        }
        stream.println(""<<<<<"");
    }",0
"public ArtemisSecurityConfigurationBuilder withAllowLocalPortsAbove(OptionalInt allowLocalPortsAbove) {
		this.allowLocalPortsAbove = Objects.requireNonNull(allowLocalPortsAbove);
		return this;
	}",0
"public String asXml() {
        Charset charsetName = null;
        final HtmlPage htmlPage = getHtmlPageOrNull();
        if (htmlPage != null) {
            charsetName = htmlPage.getCharset();
        }

        final StringWriter stringWriter = new StringWriter();
        try (PrintWriter printWriter = new PrintWriter(stringWriter)) {
            if (charsetName != null && this instanceof HtmlHtml) {
                printWriter.print(""<?xml version=\""1.0\"" encoding=\"""");
                printWriter.print(charsetName);
                printWriter.print(""\""?>\r\n"");
            }
            printXml("""", printWriter);
            return stringWriter.toString();
        }
    }",0
"protected String getHomeOperatorNumeric() {
        String numeric = ((TelephonyManager) mPhone.getContext().
                getSystemService(Context.TELEPHONY_SERVICE)).
                getSimOperatorNumericForPhone(mPhoneBase.getPhoneId());
        if (TextUtils.isEmpty(numeric)) {
            numeric = SystemProperties.get(CDMAPhone.PROPERTY_CDMA_HOME_OPERATOR_NUMERIC, """");
        }
        return numeric;
    }",0
"@Deprecated
    public void rename(DocumentReference newDocumentReference, List<DocumentReference> backlinkDocumentReferences,
        XWikiContext context) throws XWikiException
    {
        rename(newDocumentReference, backlinkDocumentReferences, getChildrenReferences(context), context);
    }",0
"void dumpInstalledPackagesConfig(PrintWriter pw) {
        mPackageConfigPersister.dump(pw, getCurrentUserId());
    }",0
"private MergeConflictDecisionsManager getConflictDecisionsManager()
    {
        if (this.conflictDecisionsManager == null) {
            this.conflictDecisionsManager = Utils.getComponent(MergeConflictDecisionsManager.class);
        }

        return this.conflictDecisionsManager;
    }",0
"public void addImmutableType(final Class type, final boolean isReferenceable) {
        if (immutableTypesMapper == null) {
            throw new com.thoughtworks.xstream.InitializationException(""No ""
                + ImmutableTypesMapper.class.getName()
                + "" available"");
        }
        immutableTypesMapper.addImmutableType(type, isReferenceable);
    }",0
"@Override
    public int getGlobalPrivateDnsMode(@NonNull ComponentName who) {
        if (!mHasFeature) {
            return PRIVATE_DNS_MODE_UNKNOWN;
        }
        Objects.requireNonNull(who, ""ComponentName is null"");
        final CallerIdentity caller = getCallerIdentity(who);
        Preconditions.checkCallAuthorization(isDefaultDeviceOwner(caller));

        final int currentMode = ConnectivitySettingsManager.getPrivateDnsMode(mContext);
        switch (currentMode) {
            case ConnectivitySettingsManager.PRIVATE_DNS_MODE_OFF:
                return PRIVATE_DNS_MODE_OFF;
            case ConnectivitySettingsManager.PRIVATE_DNS_MODE_OPPORTUNISTIC:
                return PRIVATE_DNS_MODE_OPPORTUNISTIC;
            case ConnectivitySettingsManager.PRIVATE_DNS_MODE_PROVIDER_HOSTNAME:
                return PRIVATE_DNS_MODE_PROVIDER_HOSTNAME;
        }

        return PRIVATE_DNS_MODE_UNKNOWN;
    }",0
"void settingsSecurePutString(String name, String value) {
            Settings.Secure.putString(mContext.getContentResolver(), name, value);
        }",0
"private static String getResource(String pathin) throws ContentError {
	   String path = pathin;
      String sret = null;

      try {
         if (path.startsWith(rootPath)) {
            path = path.substring(rootPath.length()+1, path.length());

         //   E.info(""seeking stream rel to root class "" + path + "" "" + rootClass.getName());
            InputStream fis = rootClass.getResourceAsStream(path);
            sret = readInputStream(fis);

         } else {
            E.warning(""reading foreign resource from class path?"");
            InputStream fis = ClassLoader.getSystemResourceAsStream(path);
            sret = readInputStream(fis);
         }

      } catch (Exception ex) {
        throw new ContentError(""ResourceAccess - cant get "" + path + "" "" + ex);
        
      }
      return sret;
   }",0
"private static void countDownLatchXmlGenerator(XmlGenerator gen, Config config) {
        for (CountDownLatchConfig lc : config.getCountDownLatchConfigs().values()) {
            gen.open(""count-down-latch"", ""name"", lc.getName())
                    .node(""quorum-ref"", lc.getQuorumName())
                    .close();
        }
    }",0
"public void setRevocationReason(Integer revocationReason) {
        this.revocationReason = revocationReason;
    }",0
"@Override
    boolean handleCompleteDeferredRemoval() {
        if (mRemoveOnExit && !isSelfAnimating(0 /* flags */, ANIMATION_TYPE_WINDOW_ANIMATION)) {
            mRemoveOnExit = false;
            removeImmediately();
        }
        return super.handleCompleteDeferredRemoval();
    }",0
"public void scalePDFImage(Document document, Image image) {
        float scaler = ((document.getPageSize().getWidth() - document.leftMargin()
                - document.rightMargin()) / image.getWidth()) * 100;

        image.scalePercent(scaler);
    }",0
"@Override
    public int getMtePolicy(String callerPackageName) {
        final CallerIdentity caller = getCallerIdentity(callerPackageName);
        if (isPermissionCheckFlagEnabled()) {
            enforcePermission(MANAGE_DEVICE_POLICY_MTE, caller.getPackageName(),
                    UserHandle.USER_ALL);
        } else {
            Preconditions.checkCallAuthorization(
                    isDefaultDeviceOwner(caller)
                            || isProfileOwnerOfOrganizationOwnedDevice(caller)
                            || isSystemUid(caller));
        }
        synchronized (getLockObject()) {
            // TODO(b/261999445): Remove
            ActiveAdmin admin;
            if (isHeadlessFlagEnabled()) {
                admin =
                        getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked();
            } else {
                admin =
                        getDeviceOwnerOrProfileOwnerOfOrganizationOwnedDeviceLocked(
                                UserHandle.USER_SYSTEM);
            }
            return admin != null
                    ? admin.mtePolicy
                    : DevicePolicyManager.MTE_NOT_CONTROLLED_BY_POLICY;
        }
    }",0
"@GuardedBy(""this"")
    void finishRunningVoiceLocked() {
        if (mRunningVoice != null) {
            mRunningVoice = null;
            mVoiceWakeLock.release();
            updateSleepIfNeededLocked();
        }
    }",0
"boolean canSeeAnyPinnedShortcut(@NonNull String callingPackage, int userId,
            int callingPid, int callingUid) {
        if (injectHasAccessShortcutsPermission(callingPid, callingUid)) {
            return true;
        }
        synchronized (mNonPersistentUsersLock) {
            return getNonPersistentUserLocked(userId).hasHostPackage(callingPackage);
        }
    }",0
"@Override
	protected Identifier getRelatedIdentifier(Contentlet contentlet, String relationshipType) throws DotDataException {
	    String tableName;
        try {
            //tableName = ((Inode) Identifier.class.newInstance()).getType();
            tableName = ""identifier"";
        } catch (Exception e) {
            throw new DotDataException(""Unable to instantiate identifier"",e);
        }
        HibernateUtil dh = new HibernateUtil(Identifier.class);

        String sql = ""SELECT {"" + tableName + "".*} from "" + tableName + "" "" + tableName + "", tree tree, inode ""
        + tableName + ""_1_ where tree.parent = ? and ""+ tableName+""_1_.type ='""+tableName+""' and tree.child = "" + tableName + "".id and "" + tableName
        + ""_1_.inode = "" + tableName + "".id and tree.relation_type = ?"";

        Logger.debug(this, ""HibernateUtilSQL:getChildOfClassByRelationType\n "" + sql + ""\n"");

        dh.setSQLQuery(sql);

        Logger.debug(this, ""contentlet inode:  "" + contentlet.getInode() + ""\n"");

        dh.setParam(contentlet.getInode());
        dh.setParam(relationshipType);

        return (Identifier)dh.load();
	}",0
"void getBounds(Point bounds) {
            mDisplay.getDisplayInfo(mDisplayInfo);
            bounds.x = mDisplayInfo.appWidth;
            bounds.y = mDisplayInfo.appHeight;
        }",0
"public static String computeDefaultTlsProtocol(String[] supportedProtocols) {
        if(supportedProtocols != null) {
            for (String supportedProtocol : supportedProtocols) {
                if(PREFERRED_TLS_PROTOCOL.equalsIgnoreCase(supportedProtocol)) {
                    return supportedProtocol;
                }
            }
        }
        return FALLBACK_TLS_PROTOCOL;
    }",0
"private void onDocumentEvent(XWikiDocument document)
    {
        boolean remove = false;
        if (document.getObject(getExtensionClassName()) != null) {
            // new or already existing object
            if (document.getObject(getExtensionClassName(), USE_FIELDNAME, ""always"", false) != null) {
                if (getAuthorizationManager().hasAccess(Right.PROGRAM,
                    document.getAuthorReference(), document.getDocumentReference())) {
                    getAlwaysUsedExtensions().add(document.getDocumentReference());

                    return;
                } else {
                    // in case the extension lost its programming rights upon this save.
                    remove = true;
                }
            } else {
                // remove if exists but use onDemand
                remove = true;
            }
        } else if (document.getOriginalDocument().getObject(getExtensionClassName()) != null) {
            // object removed
            remove = true;
        }

        if (remove) {
            getAlwaysUsedExtensions().remove(document.getDocumentReference());
        }
    }",1
"public String toQueryString(Object... queryParameters)
    {
        return toQueryString(toQueryParameters(queryParameters));
    }",0
"protected void onCancelButtonSubmit(final AjaxRequestTarget target)
  {
  }",0
"int getCount() {
      return count;
    }",0
"private void internalRemoveColumn(Object propertyId) {
        setEditorField(propertyId, null);
        header.removeColumn(propertyId);
        footer.removeColumn(propertyId);
        Column column = columns.remove(propertyId);
        getState().columnOrder.remove(columnKeys.key(propertyId));
        getState().columns.remove(column.getState());
        removeExtension(column.getRenderer());
    }",0
"private static boolean useSipForPstnCalls(Context context) {
        final SipSharedPreferences sipSharedPreferences = new SipSharedPreferences(context);
        return sipSharedPreferences.getSipCallOption().equals(Settings.System.SIP_ALWAYS);
    }",0
"public int validateUser(boolean withConfirmEmail, XWikiContext context) throws XWikiException
    {
        try {
            XWikiRequest request = context.getRequest();
            // Get the user document
            String username = convertUsername(request.getParameter(""xwikiname""), context);
            if (username.indexOf('.') == -1) {
                username = ""XWiki."" + username;
            }
            XWikiDocument userDocument = getDocument(username, context);

            // Get the stored validation key
            BaseObject userObject = userDocument.getObject(""XWiki.XWikiUsers"", 0);
            String storedKey = userObject.getStringValue(""validkey"");

            // Get the validation key from the URL
            String validationKey = request.getParameter(""validkey"");
            PropertyInterface validationKeyClass = getClass(""XWiki.XWikiUsers"", context).get(""validkey"");
            if (validationKeyClass instanceof PasswordClass) {
                validationKey = ((PasswordClass) validationKeyClass).getEquivalentPassword(storedKey, validationKey);
            }

            // Compare the two keys
            if ((!storedKey.equals("""") && (storedKey.equals(validationKey)))) {
                // Ensure to remove the validation key value, so it cannot be used afterwards to enable back
                // a disabled user.
                userObject.setStringValue(""validkey"", """");
                saveDocument(userDocument, context);

                XWikiUser xWikiUser = new XWikiUser(userDocument.getDocumentReference());
                xWikiUser.setDisabled(false, context);
                xWikiUser.setEmailChecked(true, context);

                if (withConfirmEmail) {
                    String email = userObject.getStringValue(""email"");
                    String password = userObject.getStringValue(""password"");
                    sendValidationEmail(username, password, email, request.getParameter(""validkey""),
                        ""confirmation_email_content"", context);
                }

                return 0;
            } else {
                return -1;
            }
        } catch (Exception e) {
            LOGGER.error(e.getMessage(), e);

            throw new XWikiException(XWikiException.MODULE_XWIKI_APP, XWikiException.ERROR_XWIKI_APP_VALIDATE_USER,
                ""Exception while validating user"", e, null);
        }
    }",1
"private boolean isDeviceAB() {
        return ""true"".equalsIgnoreCase(android.os.SystemProperties
                .get(AB_DEVICE_KEY, """"));
    }",0
"boolean supportsMultiWindowInDisplayArea(@Nullable TaskDisplayArea tda) {
        if (isActivityTypeHome()) {
            return false;
        }
        if (!mAtmService.mSupportsMultiWindow) {
            return false;
        }
        if (tda == null) {
            return false;
        }

        if (!isResizeable() && !tda.supportsNonResizableMultiWindow()) {
            // Not support non-resizable in multi window.
            return false;
        }

        final ActivityInfo.WindowLayout windowLayout = info.windowLayout;
        return windowLayout == null
                || tda.supportsActivityMinWidthHeightMultiWindow(windowLayout.minWidth,
                windowLayout.minHeight, info);
    }",0
"public static void copy(InputStream in, OutputStream out) throws IOException
	{
		copy(in, out, IO_BUFFER_SIZE);
	}",0
"protected synchronized FrameHandlerFactory createFrameHandlerFactory() throws IOException {
        if(nio) {
            if(this.frameHandlerFactory == null) {
                if(this.nioParams.getNioExecutor() == null && this.nioParams.getThreadFactory() == null) {
                    this.nioParams.setThreadFactory(getThreadFactory());
                }
                this.frameHandlerFactory = new SocketChannelFrameHandlerFactory(
                    connectionTimeout, nioParams, isSSL(), sslContextFactory,
                    this.maxInboundMessageBodySize);
            }
            return this.frameHandlerFactory;
        } else {
            return new SocketFrameHandlerFactory(connectionTimeout, socketFactory,
                socketConf, isSSL(), this.shutdownExecutor, sslContextFactory,
                this.maxInboundMessageBodySize);
        }

    }",1
"@Override
    public XMLBuilder2 namespace(String namespaceURI) {
        this.namespace(null, namespaceURI);
        return this;
    }",0
"void setTurnScreenOn(boolean turnScreenOn) {
        mTurnScreenOn = turnScreenOn;
    }",0
"public static String prettyPrintXML(final String xml) {
        final Reader reader = new StringReader(xml);
        final Writer writer = new StringWriter(1000);

        prettyPrintXML(reader, writer);

        return writer.toString();
    }",0
"public OHttpNetworkCommandManager getCommandManager() {
    return cmdManager;
  }",0
"public long readI64() throws TException {
    byte[] buf = buffer;
    int off = 0;

    if (trans_.getBytesRemainingInBuffer() >= 8) {
      buf = trans_.getBuffer();
      off = trans_.getBufferPosition();
      trans_.consumeBuffer(8);
    } else {
      readAll(buffer, 0, 8);
    }

    return ((long) (buf[off] & 0xff) << 56)
        | ((long) (buf[off + 1] & 0xff) << 48)
        | ((long) (buf[off + 2] & 0xff) << 40)
        | ((long) (buf[off + 3] & 0xff) << 32)
        | ((long) (buf[off + 4] & 0xff) << 24)
        | ((long) (buf[off + 5] & 0xff) << 16)
        | ((long) (buf[off + 6] & 0xff) << 8)
        | ((long) (buf[off + 7] & 0xff));
  }",0
"private void enforceRestrictedSystemSettingsMutationForCallingPackage(int operation,
            String name, int userId) {
        // System/root/shell can mutate whatever secure settings they want.
        final int callingUid = Binder.getCallingUid();
        final int appId = UserHandle.getAppId(callingUid);
        if (appId == android.os.Process.SYSTEM_UID
                || appId == Process.SHELL_UID
                || appId == Process.ROOT_UID) {
            return;
        }

        switch (operation) {
            case MUTATION_OPERATION_INSERT:
                // Insert updates.
            case MUTATION_OPERATION_UPDATE: {
                if (Settings.System.PUBLIC_SETTINGS.contains(name)) {
                    return;
                }

                // The calling package is already verified.
                PackageInfo packageInfo = getCallingPackageInfoOrThrow(userId);

                // Privileged apps can do whatever they want.
                if ((packageInfo.applicationInfo.privateFlags
                        & ApplicationInfo.PRIVATE_FLAG_PRIVILEGED) != 0) {
                    return;
                }

                warnOrThrowForUndesiredSecureSettingsMutationForTargetSdk(
                        packageInfo.applicationInfo.targetSdkVersion, name);
            } break;

            case MUTATION_OPERATION_DELETE: {
                if (Settings.System.PUBLIC_SETTINGS.contains(name)
                        || Settings.System.PRIVATE_SETTINGS.contains(name)) {
                    throw new IllegalArgumentException(""You cannot delete system defined""
                            + "" secure settings."");
                }

                // The calling package is already verified.
                PackageInfo packageInfo = getCallingPackageInfoOrThrow(userId);

                // Privileged apps can do whatever they want.
                if ((packageInfo.applicationInfo.privateFlags &
                        ApplicationInfo.PRIVATE_FLAG_PRIVILEGED) != 0) {
                    return;
                }

                warnOrThrowForUndesiredSecureSettingsMutationForTargetSdk(
                        packageInfo.applicationInfo.targetSdkVersion, name);
            } break;
        }
    }",0
"int getMaxAppShortcuts() {
        return mMaxShortcutsPerApp;
    }",0
"@Override
        public StreamConnection upgradeChannel() {
            return null;
        }",0
"boolean isRootOfTask() {
        if (task == null) {
            return false;
        }
        final ActivityRecord rootActivity = task.getRootActivity(true);
        return this == rootActivity;
    }",0
"@Nullable
	public String getUsername() {
		return username;
	}",0
"private DeviceAdminInfo findAdmin(final ComponentName adminName, final int userHandle,
            boolean throwForMissingPermission) {
        final ActivityInfo ai = mInjector.binderWithCleanCallingIdentity(() -> {
            try {
                return mIPackageManager.getReceiverInfo(adminName,
                        GET_META_DATA
                        | PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS
                        | PackageManager.MATCH_DIRECT_BOOT_AWARE
                        | PackageManager.MATCH_DIRECT_BOOT_UNAWARE, userHandle);
            } catch (RemoteException e) {
                // shouldn't happen.
                Slogf.wtf(LOG_TAG, ""Error getting receiver info"", e);
                return null;
            }
        });
        if (ai == null) {
            throw new IllegalArgumentException(""Unknown admin: "" + adminName);
        }

        if (!permission.BIND_DEVICE_ADMIN.equals(ai.permission)) {
            final String message = ""DeviceAdminReceiver "" + adminName + "" must be protected with ""
                    + permission.BIND_DEVICE_ADMIN;
            Slogf.w(LOG_TAG, message);
            if (throwForMissingPermission &&
                    ai.applicationInfo.targetSdkVersion > Build.VERSION_CODES.M) {
                throw new IllegalArgumentException(message);
            }
        }

        try {
            return new DeviceAdminInfo(mContext, ai);
        } catch (XmlPullParserException | IOException e) {
            Slogf.w(LOG_TAG, ""Bad device admin requested for user="" + userHandle + "": "" + adminName,
                    e);
            return null;
        }
    }",0
"public Codec getCodec() {
      return codec;
   }",0
"public final void increaseWidthTo(int wid) {
        if (wid < mWidth) {
            throw new RuntimeException(""attempted to reduce Layout width"");
        }

        mWidth = wid;
    }",0
"@Override
    public Repository getRepository(Project project) {
    	Repository repository = repositoryCache.get(project.getId());
    	if (repository == null) {
    		synchronized (repositoryCache) {
    			repository = repositoryCache.get(project.getId());
    			if (repository == null) {
    				try {
						repository = new FileRepository(project.getGitDir());
					} catch (IOException e) {
						throw new RuntimeException(e);
					}
    				repositoryCache.put(project.getId(), repository);
    			}
    		}
    	}
    	return repository;
    }",0
"@Override
	public short compareDocumentPosition(Node other) throws DOMException {
		return doc.compareDocumentPosition(other);
	}",0
"public CmsContent updateComments(short siteId, Serializable id, int comments) {
        CmsContent entity = getEntity(id);
        if (null != entity && siteId == entity.getSiteId()) {
            entity.setComments(entity.getComments() + comments);
        }
        return entity;
    }",0
"@Test
    public void testDeserializationWithTypeInfo02() throws Exception
    {
        Instant date = Instant.ofEpochSecond(123456789L, 0);
        ObjectMapper m = newMapper()
                .enable(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS)
                .addMixIn(Temporal.class, MockObjectConfiguration.class);
        Temporal value = m.readValue(
                ""[\"""" + Instant.class.getName() + ""\"",123456789]"", Temporal.class
                );
        assertTrue(""The value should be an Instant."", value instanceof Instant);
        assertEquals(""The value is not correct."", date, value);
    }",0
"protected boolean isUserUnlockedL(@UserIdInt int userId) {
        // First, check the local copy.
        synchronized (mUnlockedUsers) {
            if (mUnlockedUsers.get(userId)) {
                return true;
            }
        }

        // If the local copy says the user is locked, check with AM for the actual state, since
        // the user might just have been unlocked.
        // Note we just don't use isUserUnlockingOrUnlocked() here, because it'll return false
        // when the user is STOPPING, which we still want to consider as ""unlocked"".
        return mUserManagerInternal.isUserUnlockingOrUnlocked(userId);
    }",0
"@Override
    public int getBaseDisplayDensity(int displayId) {
        synchronized (mWindowMap) {
            final DisplayContent displayContent = getDisplayContentLocked(displayId);
            if (displayContent != null && displayContent.hasAccess(Binder.getCallingUid())) {
                synchronized(displayContent.mDisplaySizeLock) {
                    return displayContent.mBaseDisplayDensity;
                }
            }
        }
        return -1;
    }",0
"public void addWindowChangeListener(WindowChangeListener listener) {
        synchronized(mWindowMap) {
            mWindowChangeListeners.add(listener);
        }
    }",0
"public IFingerprintDaemon getFingerprintDaemon() {
        if (mDaemon == null) {
            mDaemon = IFingerprintDaemon.Stub.asInterface(ServiceManager.getService(FINGERPRINTD));
            if (mDaemon != null) {
                try {
                    mDaemon.asBinder().linkToDeath(this, 0);
                    mDaemon.init(mDaemonCallback);
                    mHalDeviceId = mDaemon.openHal();
                    if (mHalDeviceId != 0) {
                        updateActiveGroup(ActivityManager.getCurrentUser(), null);
                    } else {
                        Slog.w(TAG, ""Failed to open Fingerprint HAL!"");
                        mDaemon = null;
                    }
                } catch (RemoteException e) {
                    Slog.e(TAG, ""Failed to open fingeprintd HAL"", e);
                    mDaemon = null; // try again later!
                }
            } else {
                Slog.w(TAG, ""fingerprint service not available"");
            }
        }
        return mDaemon;
    }",0
"public void setContent(String content)
    {
        if (content == null) {
            content = """";
        }

        boolean notEqual = !content.equals(this.content);

        this.content = content;

        if (notEqual) {
            // invalidate parsed xdom
            this.xdomCache = null;
            setContentDirty(true);
            setWikiNode(null);
        }
    }",0
"@Nullable PersistableBundle getPersistentSavedState() {
        return mPersistentState;
    }",0
"@Override
        protected int getOutputSizeForFinal(int inputLen) {
            return bufCount + inputLen
                    + (isEncrypting() ? NativeCrypto.EVP_AEAD_max_overhead(evpAead) : 0);
        }",0
"public void setBean(Object bean) {
            _bean = bean;
        }",0
"private int runResetPermissions() {
        try {
            mPm.resetRuntimePermissions();
            return 0;
        } catch (RemoteException e) {
            System.err.println(e.toString());
            System.err.println(PM_NOT_RUNNING_ERR);
            return 1;
        } catch (IllegalArgumentException e) {
            System.err.println(""Bad argument: "" + e.toString());
            showUsage();
            return 1;
        } catch (SecurityException e) {
            System.err.println(""Operation not allowed: "" + e.toString());
            return 1;
        }
    }",0
"private void checkClockOutOfSync() {
            try {
                SVNDirEntry dir = clientManager.createRepository(location.getSVNURL(), true).info(""/"", -1);
                if (dir != null) {// I don't think this can ever be null, but be defensive
                    if (dir.getDate() != null && dir.getDate().after(new Date())) // see http://www.nabble.com/NullPointerException-in-SVN-Checkout-Update-td21609781.html that reported this being null.
                    {
                        listener.getLogger().println(Messages.SubversionSCM_ClockOutOfSync());
                    }
                }
            } catch (SVNAuthenticationException e) {
                // if we don't have access to '/', ignore. error
                LOGGER.log(Level.FINE,""Failed to estimate the remote time stamp"",e);
            } catch (SVNException e) {
                LOGGER.log(Level.INFO,""Failed to estimate the remote time stamp"",e);
            }
        }",0
"public static String shortClassName(Object ov) {
      String cnm = ov.getClass().getName();
      cnm = cnm.substring(cnm.lastIndexOf(""."") + 1, cnm.length());
      return cnm;
   }",0
"public void setValidationScript(String validationScript)
    {
        this.validationScript = validationScript;

        setMetaDataDirty(true);
    }",0
"@Deprecated
    public void addToZip(ZipOutputStream zos, XWikiContext context) throws XWikiException, IOException
    {
        addToZip(zos, true, context);
    }",0
"@Override
    protected boolean isPanelVisibleBecauseOfHeadsUp() {
        return mHeadsUpManager.hasPinnedHeadsUp() || mHeadsUpAnimatingAway;
    }",0
"private void saveProjectBuildGradle() throws IOException {
		TemplateFile tmpl = TemplateFile.fromResources(""/export/build.gradle.tmpl"");
		tmpl.save(new File(projectDir, ""build.gradle""));
	}",0
"void commitVisibility(boolean visible, boolean performLayout) {
        commitVisibility(visible, performLayout, false /* fromTransition */);
    }",0
"public List<Integer> getSearchPreFetchThresholds() {
		return mySearchPreFetchThresholds;
	}",0
"public List<Cliente> buscarFuncionarioEmail(String email) throws SQLException, ClassNotFoundException {
        Connection con = null;
        PreparedStatement stmt = null;
        ResultSet rs = null;

        try {
            con = ConnectionFactory.getConnection();
            email = ""%""+email+""%"";
            stmt = con.prepareStatement(stmtBuscarEmailFuncionario);
            stmt.setString(1,email);
            rs = stmt.executeQuery();
            return montaListaClientes(rs);
        } catch (SQLException e) {
            throw new RuntimeException(e);
        } finally {
            try {
                rs.close();
            } catch (Exception ex) {
                System.out.println(""Erro ao fechar result set.Erro: "" + ex.getMessage());
            }
            try {
                stmt.close();
            } catch (SQLException ex) {
                System.out.println(""Erro ao fechar statement. Ex = "" + ex.getMessage());
            }
            try {
                con.close();
            } catch (SQLException ex) {
                System.out.println(""Erro ao fechar a conexao. Ex = "" + ex.getMessage());
            }
        }
    }",1
"private IBillingSupport getBillingSupport() {
        if (billingSupport == null) {
            billingSupport = createBillingSupport();
        }
        return billingSupport;
    }",0
"private void removePackageFromSetLocked(final HashSet<String> set,
            final String packageName) {
        if (set.contains(packageName)) {
            // Found it.  Remove this one package from the bookkeeping, and
            // if it's the last participating app under this uid we drop the
            // (now-empty) set as well.
            // Note that we deliberately leave it 'known' in the ""ever backed up""
            // bookkeeping so that its current-dataset data will be retrieved
            // if the app is subsequently reinstalled
            if (MORE_DEBUG) Slog.v(TAG, ""  removing participant "" + packageName);
            set.remove(packageName);
            mPendingBackups.remove(packageName);
        }
    }",0
"public XmlResourceParser newParser(@AnyRes int resId) {
        synchronized (this) {
            if (mNative != 0) {
                return new Parser(nativeCreateParseState(mNative, resId), this);
            }
            return null;
        }
    }",0
"final void performAppGcsLocked() {
        final int N = mProcessesToGc.size();
        if (N <= 0) {
            return;
        }
        if (canGcNowLocked()) {
            while (mProcessesToGc.size() > 0) {
                ProcessRecord proc = mProcessesToGc.remove(0);
                if (proc.curRawAdj > ProcessList.PERCEPTIBLE_APP_ADJ || proc.reportLowMemory) {
                    if ((proc.lastRequestedGc+GC_MIN_INTERVAL)
                            <= SystemClock.uptimeMillis()) {
                        // To avoid spamming the system, we will GC processes one
                        // at a time, waiting a few seconds between each.
                        performAppGcLocked(proc);
                        scheduleAppGcsLocked();
                        return;
                    } else {
                        // It hasn't been long enough since we last GCed this
                        // process...  put it in the list to wait for its time.
                        addProcessToGcListLocked(proc);
                        break;
                    }
                }
            }

            scheduleAppGcsLocked();
        }
    }",0
"public List<Pair> parameterToPairs(String collectionFormat, String name, Object value){
    List<Pair> params = new ArrayList<Pair>();

    // preconditions
    if (name == null || name.isEmpty() || value == null) return params;

    Collection valueCollection;
    if (value instanceof Collection) {
      valueCollection = (Collection) value;
    } else {
      params.add(new Pair(name, parameterToString(value)));
      return params;
    }

    if (valueCollection.isEmpty()){
      return params;
    }

    // get the collection format (default: csv)
    String format = (collectionFormat == null || collectionFormat.isEmpty() ? ""csv"" : collectionFormat);

    // create the params based on the collection format
    if (""multi"".equals(format)) {
      for (Object item : valueCollection) {
        params.add(new Pair(name, parameterToString(item)));
      }

      return params;
    }

    String delimiter = "","";

    if (""csv"".equals(format)) {
      delimiter = "","";
    } else if (""ssv"".equals(format)) {
      delimiter = "" "";
    } else if (""tsv"".equals(format)) {
      delimiter = ""\t"";
    } else if (""pipes"".equals(format)) {
      delimiter = ""|"";
    }

    StringBuilder sb = new StringBuilder() ;
    for (Object item : valueCollection) {
      sb.append(delimiter);
      sb.append(parameterToString(item));
    }

    params.add(new Pair(name, sb.substring(1)));

    return params;
  }",0
"public static Jiffle.RuntimeModel get(Class<? extends JiffleRuntime> clazz) {
            for (Jiffle.RuntimeModel t : Jiffle.RuntimeModel.values()) {
                if (t.runtimeClass.isAssignableFrom(clazz)) {
                    return t;
                }
            }
            
            return null;
        }",0
"@Override
        public PauseRequest pauseAsync() {
            final PauseRequest out = new PauseRequest();
            out.ready(new SuccessCallback<AsyncMedia>() {
                @Override
                public void onSucess(AsyncMedia value) {
                    if (out == pendingPauseRequest) {
                        pendingPauseRequest = null;
                    }
                }
            }).except(new SuccessCallback<Throwable>() {
                @Override
                public void onSucess(Throwable value) {
                    if (out == pendingPauseRequest) {
                        pendingPauseRequest = null;
                    }
                }
            });
            ;
            if (pendingPauseRequest != null) {
                pendingPauseRequest.ready(new SuccessCallback<AsyncMedia>() {
                    @Override
                    public void onSucess(AsyncMedia value) {
                        if (!out.isDone()) {
                            out.complete(value);
                        }
                    }
                }).except(new SuccessCallback<Throwable>() {
                    @Override
                    public void onSucess(Throwable value) {
                        if (!out.isDone()) {
                            out.error(value);
                        }
                    }
                });
                return out;
            } else {
                pendingPauseRequest = out;
            }
            
            ActionListener<MediaStateChangeEvent> onStateChange = new ActionListener<MediaStateChangeEvent>() {
                @Override
                public void actionPerformed(MediaStateChangeEvent evt) {
                    stateChangeListeners.removeListener(this);
                    if (!out.isDone()) {
                        if (evt.getNewState() == State.Paused) {
                            out.complete(Video.this);
                        }
                    }
                    
                }
                
            };
            
            stateChangeListeners.addListener(onStateChange);
            play();
            
            return out;
        }",0
"boolean super_awakenScrollBars(int startDelay, boolean invalidate);",0
"protected RemoteViews getStandardView(int layoutId, StandardTemplateParams p,
                TemplateBindResult result) {
            checkBuilder();

            if (mBigContentTitle != null) {
                p.title = mBigContentTitle;
            }

            return mBuilder.applyStandardTemplateWithActions(layoutId, p, result);
        }",0
"void setServiceRestartBackoffEnabled(@NonNull String packageName, boolean enable,
            @NonNull String reason) {
        synchronized (this) {
            mServices.setServiceRestartBackoffEnabledLocked(packageName, enable, reason);
        }
    }",0
"public void pause() {
        this.paused = true;

        if (singleDownloadRunnable != null) singleDownloadRunnable.pause();
        @SuppressWarnings(""unchecked"") ArrayList<DownloadRunnable> pauseList =
                (ArrayList<DownloadRunnable>) downloadRunnableList.clone();
        for (DownloadRunnable runnable : pauseList) {
            if (runnable != null) {
                runnable.pause();
                // if runnable is null, then that one must be completed and removed
            }
        }
    }",0
"@Override
        public int getCurrentTtyMode(String callingPackage, String callingFeatureId) {
            try {
                Log.startSession(""TSI.gCTM"", Log.getPackageAbbreviation(callingPackage));
                if (!canReadPhoneState(callingPackage, callingFeatureId, ""getCurrentTtyMode"")) {
                    return TelecomManager.TTY_MODE_OFF;
                }

                synchronized (mLock) {
                    return mCallsManager.getCurrentTtyMode();
                }
            } finally {
                Log.endSession();
            }
        }",0
"@JsonProperty(""PrettyPrint"")
    public String getPrettyPrint() {
        return prettyPrint;
    }",0
"void onServiceConnected() {
            synchronized(mLock) {
                if (mListeners != null && !mListeners.isEmpty()) {
                    setSoftKeyboardCallbackEnabled(true);
                }
            }
        }",0
"private List<Call> unmarshalCalls(Element env) throws Exception
  {
    try 
    {
      List<Call> calls = new ArrayList<Call>();

      List<Element> callElements = env.element(""body"").elements(""call"");

      for (Element e : callElements) 
      {
        Call call = new Call(e.attributeValue(""id""),
                             e.attributeValue(""component""),
                             e.attributeValue(""method""));

        // First reconstruct all the references
        Element refsNode = e.element(""refs"");

        Iterator iter = refsNode.elementIterator(""ref"");
        while (iter.hasNext())
        {
          call.getContext().createWrapperFromElement((Element) iter.next());
        }

        // Now unmarshal the ref values
        for (Wrapper w : call.getContext().getInRefs().values())
        {
          w.unmarshal();
        }

        Element paramsNode = e.element(""params"");

        // Then process the param values
        iter = paramsNode.elementIterator(""param"");
        while (iter.hasNext()) 
        {
          Element param = (Element) iter.next();

          call.addParameter(call.getContext().createWrapperFromElement(
            (Element) param.elementIterator().next()));
        }

        calls.add(call);
      }

      return calls;
    }
    catch (Exception ex) 
    {
      log.error(""Error unmarshalling calls from request"", ex);
      throw ex;
    }
  }",0
"public static boolean isObbOrChildRelativePath(@Nullable String path) {
        if (path == null) return false;
        final Matcher m = PATTERN_OBB_OR_CHILD_RELATIVE_PATH.matcher(path);
        return m.matches();
    }",0
"private boolean isCompatSignatureUpdateNeeded(PackageParser.Package scannedPkg) {
        final VersionInfo ver = getSettingsVersionForPackage(scannedPkg);
        return ver.databaseVersion < DatabaseVersion.SIGNATURE_END_ENTITY;
    }",0
"public boolean isEncrypted() {
		if (newMhd != null) {
			return newMhd.isEncrypted();
		} else {
			throw new NullPointerException(""mainheader is null"");
		}
	}",0
"public void clearAndReadState() {
        synchronized (mAuthorities) {
            mAuthorities.clear();
            mAccounts.clear();
            mServices.clear();
            mPendingOperations.clear();
            mSyncStatus.clear();
            mSyncHistory.clear();

            readAccountInfoLocked();
            readStatusLocked();
            readPendingOperationsLocked();
            readStatisticsLocked();
            readAndDeleteLegacyAccountInfoLocked();
            writeAccountInfoLocked();
            writeStatusLocked();
            writePendingOperationsLocked();
            writeStatisticsLocked();
        }
    }",0
"@Override
        public boolean disableNdefPush() throws RemoteException {
            NfcPermissions.enforceAdminPermissions(mContext);
            synchronized (NfcService.this) {
                if (!mIsNdefPushEnabled) {
                    return true;
                }
                Log.i(TAG, ""disabling NDEF Push"");
                mPrefsEditor.putBoolean(PREF_NDEF_PUSH_ON, false);
                mPrefsEditor.apply();
                mIsNdefPushEnabled = false;
                setBeamShareActivityState(false);
                if (isNfcEnabled()) {
                    mP2pLinkManager.enableDisable(false, true);
                }
            }
            return true;
        }",0
public boolean isBackgroundVisibleBehind(IBinder token) throws RemoteException;,0
"@Override
    public void onMessageReceived(@NotNull MessageReceivedEvent event) {
        super.onMessageReceived(event);

        if (event.isFromGuild() && (event.isFromType(ChannelType.TEXT) || event.isFromType(ChannelType.VOICE)) && event.getMember() != null) {
            if (ModerationUtil.shouldModerate(event.getGuild().getId())) {
                if (ModerationUtil.checkMessage(event.getGuild().getId(), event.getMessage().getContentRaw())) {
                    Main.getInstance().getCommandManager().deleteMessage(event.getMessage(), null);
                    Main.getInstance().getCommandManager().sendMessage(""Your message contains blacklisted words!"", event.getChannel(), null);
                    return;
                } /* else if (!event.getMessage().getAttachments().isEmpty()) {
                    for (Message.Attachment attachment : event.getMessage().getAttachments()) {
                        if (attachment.isImage()) {
                            if (ModerationUtil.checkImage(event.getGuild().getId(), attachment.getUrl())) {
                                Main.getInstance().getCommandManager().deleteMessage(event.getMessage(), null);
                                Main.getInstance().getCommandManager().sendMessage(""The Image contained blacklisted words!"", event.getChannel(), null);
                                return;
                            }
                        }
                    }
                } else {
                    String messageContent = event.getMessage().getContentRaw();
                    String extractedUrl = ModerationUtil.extractUrl(messageContent);

                    if (extractedUrl != null &&!extractedUrl.isEmpty()) {
                        if (ModerationUtil.checkImage(event.getGuild().getId(), extractedUrl)) {
                            Main.getInstance().getCommandManager().deleteMessage(event.getMessage(), null);
                            Main.getInstance().getCommandManager().sendMessage(""The Image contained blacklisted words!"", event.getChannel(), null);
                            return;
                        }
                    }
                } */
            }

            if (event.getAuthor().isBot()) return;

            if (!ArrayUtil.messageIDwithMessage.containsKey(event.getMessageId())) {
                ArrayUtil.messageIDwithMessage.put(event.getMessageId(), event.getMessage());
            }

            if (!ArrayUtil.messageIDwithUser.containsKey(event.getMessageId())) {
                ArrayUtil.messageIDwithUser.put(event.getMessageId(), event.getAuthor());
            }


            if (!Main.getInstance().getCommandManager().perform(event.getMember(), event.getGuild(), event.getMessage().getContentRaw(), event.getMessage(), event.getChannel(), null)) {

                if (!event.getMessage().getMentions().getUsers().isEmpty() && event.getMessage().getMentions().getUsers().contains(event.getJDA().getSelfUser())) {
                    event.getChannel().sendMessage(""Usage "" + Main.getInstance().getSqlConnector().getSqlWorker().getSetting(event.getGuild().getId(), ""chatprefix"").getStringValue() + ""help"").queue();
                }

                if (!ArrayUtil.timeout.contains(event.getMember())) {

                    ChatUserLevel userLevel = Main.getInstance().getSqlConnector().getSqlWorker().getChatLevelData(event.getGuild().getId(), event.getMember().getId());
                    ChatUserLevel oldUserLevel = (ChatUserLevel) SQLUtil.cloneEntity(ChatUserLevel.class, userLevel);
                    userLevel.setUser(event.getMember().getUser());

                    if (userLevel.addExperience(RandomUtils.random.nextInt(15, 26)) && Main.getInstance().getSqlConnector().getSqlWorker().getSetting(event.getGuild().getId(), ""level_message"").getBooleanValue()) {
                        Main.getInstance().getCommandManager().sendMessage(""You just leveled up to Chat Level "" + userLevel.getLevel() + "" "" + event.getMember().getAsMention() + "" !"", event.getChannel());
                    }

                    Main.getInstance().getSqlConnector().getSqlWorker().addChatLevelData(event.getGuild().getId(), oldUserLevel, userLevel);

                    ArrayUtil.timeout.add(event.getMember());

                    ThreadUtil.createNewThread(x -> ArrayUtil.timeout.remove(event.getMember()), null, Duration.ofSeconds(30), false, false);
                }

                AutoRoleHandler.handleChatLevelReward(event.getGuild(), event.getMember());
            }
        }
    }",0
"public List<Cause> getUpstreamCauses() {
            return upstreamCauses;
        }",0
"void packageShortcutsChanged(
            @NonNull final ShortcutPackage sp,
            @Nullable final List<ShortcutInfo> changedShortcuts,
            @Nullable final List<ShortcutInfo> removedShortcuts) {
        Objects.requireNonNull(sp);
        final String packageName = sp.getPackageName();
        final int userId = sp.getPackageUserId();
        if (DEBUG) {
            Slog.d(TAG, String.format(
                    ""Shortcut changes: package=%s, user=%d"", packageName, userId));
        }
        injectPostToHandlerDebounced(sp, notifyListenerRunnable(packageName, userId));
        notifyShortcutChangeCallbacks(packageName, userId, changedShortcuts, removedShortcuts);
        sp.scheduleSave();
    }",0
"void addPathParam(String name, String value, boolean encoded) {
    if (relativeUrl == null) {
      // The relative URL is cleared when the first query parameter is set.
      throw new AssertionError();
    }
    String replacement = canonicalizeForPath(value, encoded);
    String newRelativeUrl = relativeUrl.replace(""{"" + name + ""}"", replacement);
    if (PATH_TRAVERSAL.matcher(newRelativeUrl).matches()) {
      throw new IllegalArgumentException(
          ""@Path parameters shouldn't perform path traversal ('.' or '..'): "" + value);
    }
    relativeUrl = newRelativeUrl;
  }",1
"public ZentaoConfig setUserConfig() {
        return setUserConfig(getUserPlatInfo(this.workspaceId));
    }",0
"public void setCheckForXmlRootElement(boolean checkForXmlRootElement) {
		this.checkForXmlRootElement = checkForXmlRootElement;
	}",0
"@Override
    public final int startActivity(IApplicationThread caller, String callingPackage,
            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,
            int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) {
        return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,
                resultWho, requestCode, startFlags, profilerInfo, bOptions,
                UserHandle.getCallingUserId());
    }",0
"@Override
    public String getDefaultBrowserPackageName(int userId) {
        synchronized (mPackages) {
            return mSettings.getDefaultBrowserPackageNameLPw(userId);
        }
    }",0
"public void sendPasswordResetEmail(String email, String token, HttpServletRequest req) {
		if (email != null && token != null) {
			Map<String, Object> model = new HashMap<String, Object>();
			Map<String, String> lang = getLang(req);
			String url = CONF.serverUrl() + CONF.serverContextPath() + SIGNINLINK + ""/iforgot?email="" + email + ""&token="" + token;
			String subject = lang.get(""iforgot.title"");
			String body1 = lang.get(""notification.iforgot.body1"") + ""<br><br>"";
			String body2 = Utils.formatMessage(""<b><a href=\""{0}\"">"" + lang.get(""notification.iforgot.body2"") +
					""</a></b><br><br>"", url);
			String body3 = getDefaultEmailSignature(lang.get(""notification.signature"") + ""<br><br>"");

			model.put(""subject"", escapeHtml(subject));
			model.put(""logourl"", getSmallLogoUrl());
			model.put(""heading"", lang.get(""hello""));
			model.put(""body"", body1 + body2 + body3);
			emailer.sendEmail(Arrays.asList(email), subject, compileEmailTemplate(model));
		}
	}",0
"@Override
    public void setForcedDisplayScalingMode(int displayId, int mode) {
        if (mContext.checkCallingOrSelfPermission(
                android.Manifest.permission.WRITE_SECURE_SETTINGS) !=
                PackageManager.PERMISSION_GRANTED) {
            throw new SecurityException(""Must hold permission "" +
                    android.Manifest.permission.WRITE_SECURE_SETTINGS);
        }
        if (displayId != Display.DEFAULT_DISPLAY) {
            throw new IllegalArgumentException(""Can only set the default display"");
        }
        final long ident = Binder.clearCallingIdentity();
        try {
            synchronized(mWindowMap) {
                final DisplayContent displayContent = getDisplayContentLocked(displayId);
                if (displayContent != null) {
                    if (mode < 0 || mode > 1) {
                        mode = 0;
                    }
                    setForcedDisplayScalingModeLocked(displayContent, mode);
                    Settings.Global.putInt(mContext.getContentResolver(),
                            Settings.Global.DISPLAY_SCALING_FORCE, mode);
                }
            }
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }",0
"@Test(expected = DateTimeException.class)
    public void testDeserializationAsFloatEdgeCase05() throws Exception
    {
        // 1ns beyond the lower-bound of Instant.
        String input = (Instant.MIN.getEpochSecond() - 1) + "".0"";
        MAPPER.readValue(input, Instant.class);
    }",0
"public void setUserId(long userId) {
        this.userId = userId;
    }",0
"private boolean shouldStartChangeTransition(
            @Nullable TaskFragment newParent, @Nullable TaskFragment oldParent) {
        if (newParent == null || oldParent == null || !canStartChangeTransition()) {
            return false;
        }

        // Transition change for the activity moving into a TaskFragment of different bounds.
        return newParent.isOrganizedTaskFragment()
                && !newParent.getBounds().equals(oldParent.getBounds());
    }",0
"@Transactional
    public void update(DatabaseTypeUpdateRequest request) {
        databaseTypeDao.selectOptionalById(request.getId()).ifPresent(data -> {
            if (DatabaseTypes.has(data.getDatabaseType())) {
                throw DomainErrors.MUST_NOT_MODIFY_SYSTEM_DEFAULT_DATABASE_TYPE.exception();
            }
            driverResources.validateJar(request.getJdbcDriverFileUrl(), request.getJdbcDriverClassName());
            DatabaseTypePojo pojo = databaseTypePojoConverter.of(request);
            try {
                databaseTypeDao.updateById(pojo);
            } catch (DuplicateKeyException e) {
                throw DomainErrors.DATABASE_TYPE_NAME_DUPLICATE.exception();
            }

            // 名称修改，下载地址修改需要删除原有的 driver
            if (!Objects.equals(request.getDatabaseType(), data.getDatabaseType())
                    || !Objects.equals(request.getJdbcDriverFileUrl(), data.getJdbcDriverFileUrl())) {
                driverResources.deleteByDatabaseType(data.getDatabaseType());
            }
        });

    }",1
"@Override
    public boolean getAlreadyTrustPublisher() {
        boolean allPublishersTrusted = appVerifier.hasAlreadyTrustedPublisher(
                certs, jarSignableEntries);
        LOG.debug(""App already has trusted publisher: {}"", allPublishersTrusted);
        return allPublishersTrusted;
    }",0
"@Override
    public boolean isCallbackOrderingPrereq(OFType type, String name) {
        return (type.equals(OFType.PACKET_IN) && 
                (name.equals(""topology"") || 
                 name.equals(""devicemanager"") ||
                 name.equals(""virtualizer"")));
    }",0
"public String getXMLContent() throws XWikiException
    {
        String xml = this.doc.getXMLContent(getXWikiContext());
        return getXWikiContext().getUtil().substitute(""s/<email>.*?<\\/email>/<email>********<\\/email>/goi"",
            getXWikiContext().getUtil().substitute(""s/<password>.*?<\\/password>/<password>********<\\/password>/goi"",
                xml));
    }",0
"private boolean isUnlockMethodSecure(String unlockMethod) {
            return !(ScreenLockType.SWIPE.preferenceKey.equals(unlockMethod) ||
                    ScreenLockType.NONE.preferenceKey.equals(unlockMethod));
        }",0
public ParcelFileDescriptor openContentUri(Uri uri) throws RemoteException;,0
"public String getUserName(String user)
    {
        return this.xwiki.getUserName(user, null, getXWikiContext());
    }",0
"private void sendMessage(String iface, Message message) {
        SparseArray<Set<Handler>> ifaceHandlers = mHandlerMap.get(iface);
        if (iface != null && ifaceHandlers != null) {
            if (isMonitoring(iface)) {
                Set<Handler> ifaceWhatHandlers = ifaceHandlers.get(message.what);
                if (ifaceWhatHandlers != null) {
                    for (Handler handler : ifaceWhatHandlers) {
                        if (handler != null) {
                            sendMessage(iface, handler, Message.obtain(message));
                        }
                    }
                }
            } else {
                if (mVerboseLoggingEnabled) {
                    Log.d(TAG, ""Dropping event because ("" + iface + "") is stopped"");
                }
            }
        } else {
            if (mVerboseLoggingEnabled) {
                Log.d(TAG, ""Sending to all monitors because there's no matching iface"");
            }
            for (Map.Entry<String, SparseArray<Set<Handler>>> entry : mHandlerMap.entrySet()) {
                iface = entry.getKey();
                if (isMonitoring(iface)) {
                    Set<Handler> ifaceWhatHandlers = entry.getValue().get(message.what);
                    if (ifaceWhatHandlers == null) continue;
                    for (Handler handler : ifaceWhatHandlers) {
                        if (handler != null) {
                            sendMessage(iface, handler, Message.obtain(message));
                        }
                    }
                }
            }
        }

        message.recycle();
    }",0
"private void keepTimeComponentOfEncounterIfDateComponentHasNotChanged(Date previousEncounterDate,
	        Encounter formEncounter) {
		
		if (previousEncounterDate != null
		        && new DateMidnight(previousEncounterDate).equals(new DateMidnight(formEncounter.getEncounterDatetime()))) {
			formEncounter.setEncounterDatetime(previousEncounterDate);
		}
		
	}",0
"protected String buildCountStatement(String sql) {
        return ""select count(1) total from (select 1 "" + sql + "" )"";
    }",0
"@Deprecated
    public boolean exists(String fullname, XWikiContext context)
    {
        return exists(getCurrentMixedDocumentReferenceResolver().resolve(fullname), context);
    }",0
"private static void killProcessGroup(int uid, int pid) {
        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, ""killProcessGroup"");
        Process.killProcessGroup(uid, pid);
        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
    }",0
"protected XWikiDocument getDoc()
    {
        if (this.initialDoc == this.doc) {
            this.doc = this.initialDoc.clone();
        }

        return this.doc;
    }",0
"@Override
    public int getRequestedOrientation(IBinder token) {
        synchronized (this) {
            ActivityRecord r = ActivityRecord.isInStackLocked(token);
            if (r == null) {
                return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
            }
            return r.getRequestedOrientation();
        }
    }",0
"public void findAll(@NonNull List<ShortcutInfo> result,
            @Nullable Predicate<ShortcutInfo> filter, int cloneFlag) {
        findAll(result, filter, cloneFlag, null, 0, /*getPinnedByAnyLauncher=*/ false);
    }",0
"public void removeDatatransferProgressListener(
            OnDatatransferProgressListener listener,
            User user,
            OCFile file
        ) {
            if (user == null || file == null || listener == null) {
                return;
            }

            String targetKey = buildRemoteName(user.getAccountName(), file.getRemotePath());
            if (mBoundListeners.get(targetKey) == listener) {
                mBoundListeners.remove(targetKey);
            }
        }",0
"public void addEnvironment( String name, String value )
    {
        //envVars.add( name + ""="" + value );
        envVars.put( name, value );
    }",0
"protected String getPrimaryColor() {
        Color p = Color.valueOf(getDefaultColor(""primary""));
        String primary = p.color;
        if (""custom"".equals(getPropertyString(""primaryColor""))) {
            primary = getPropertyString(""customPrimary"");
        } else if (!getPropertyString(""primaryColor"").isEmpty()) {
            p = Color.valueOf(getPropertyString(""primaryColor""));
            if (p != null) {
                primary = p.color;
            }
        }
        return primary;
    }",0
"@Override
    public boolean isAutoUpdate() {
        return autoUpdate;
    }",0
"public Optional<String> getDatabase() {
        return hasPreferredDatabase() ? Optional.of(this.config.getDatabase()) : Optional.empty();
    }",0
"private void handleCreateConferenceComplete(
            String callId,
            ConnectionRequest request,
            ParcelableConference conference) {
        // TODO: Note we are not using parameter ""request"", which is a side effect of our tacit
        // assumption that we have at most one outgoing conference attempt per ConnectionService.
        // This may not continue to be the case.
        if (conference.getState() == Connection.STATE_DISCONNECTED) {
            // A conference that begins in the DISCONNECTED state is an indication of
            // failure to connect; we handle all failures uniformly
            removeCall(callId, conference.getDisconnectCause());
        } else {
            // Successful connection
            if (mPendingResponses.containsKey(callId)) {
                mPendingResponses.remove(callId)
                        .handleCreateConferenceSuccess(mCallIdMapper, conference);
            }
        }
    }",0
"public VirtualHostBuilder virtualHost(String hostnamePattern) {
        final VirtualHostBuilder virtualHostBuilder =
                new VirtualHostBuilder(this, false).hostnamePattern(hostnamePattern);
        virtualHostBuilders.add(virtualHostBuilder);
        return virtualHostBuilder;
    }",0
"private byte[] getLengthPrefix(byte[] data) {
            return ByteBuffer.allocate(4).putInt(data.length).array();
        }",0
"@Dimension(unit = DP)
        public int getDesiredHeight() {
            return mDesiredHeight;
        }",0
"void grantUriPermissionFromIntentLocked(int callingUid,
            String targetPkg, Intent intent, UriPermissionOwner owner, int targetUserId) {
        NeededUriGrants needed = checkGrantUriPermissionFromIntentLocked(callingUid, targetPkg,
                intent, intent != null ? intent.getFlags() : 0, null, targetUserId);
        if (needed == null) {
            return;
        }

        grantUriPermissionUncheckedFromIntentLocked(needed, owner);
    }",0
"@Override
  public long getSize(T t, Class<?> type, Type genericType,
      Annotation[] annotations,
      MediaType mediaType) {
    return -1;
  }",0
"public static String generateAssertionHandle() {
        if (random == null) {
            return null;
        }
        byte bytes[] = new byte[SAMLConstants.ID_LENGTH];
        random.nextBytes(bytes);
        String id = null;
        try {
            id = SystemConfigurationUtil.getServerID(
                SAMLServiceManager.getServerProtocol(),
                SAMLServiceManager.getServerHost(),
                Integer.parseInt(SAMLServiceManager.getServerPort()),
                SAMLServiceManager.getServerURI());
        } catch (Exception ex) {
            if (SAMLUtils.debug.messageEnabled()) {
                SAMLUtils.debug.message(""SAMLUtil:generateAssertionHandle: ""
                + ""exception obtain serverID:"", ex);
            }
        }
        if (id != null) {
            byte idBytes[] = stringToByteArray(id);
            // TODO: should we check if idBytes.length == 2 ?
            if (idBytes.length < bytes.length) {
                for (int i = 1; i <= idBytes.length; i++) {
                    bytes[bytes.length - i] = idBytes[idBytes.length - i];
                }
            }
        }
        return byteArrayToString(bytes);
    }",0
"public void setNotValidBefore(Date notValidBefore) {
        this.notValidBefore = notValidBefore;
    }",0
"private Bitmap getProfileBadge() {
            Drawable badge = getProfileBadgeDrawable();
            if (badge == null) {
                return null;
            }
            final int size = mContext.getResources().getDimensionPixelSize(
                    R.dimen.notification_badge_size);
            Bitmap bitmap = Bitmap.createBitmap(size, size, Bitmap.Config.ARGB_8888);
            Canvas canvas = new Canvas(bitmap);
            badge.setBounds(0, 0, size, size);
            badge.draw(canvas);
            return bitmap;
        }",0
"public static SetupEncryptionDialogFragment newInstance(User user, int position) {
        SetupEncryptionDialogFragment fragment = new SetupEncryptionDialogFragment();
        Bundle args = new Bundle();
        args.putParcelable(ARG_USER, user);
        args.putInt(ARG_POSITION, position);
        fragment.setArguments(args);
        return fragment;
    }",0
"@Test
  public void testParsePercentile() {
    final String s = ""percentile[0.98,0.95,0.99]"";
    final String ss = ""percentile [0.98,0.95,0.99]"";
    final String sss = ""percentile[ 0.98,0.95,0.99]"";
    final String ssss = ""percentile[0.98,0.95,0.99 ]"";
    final String sssss = ""percentile[ 0.98, 0.95,0.99]"";
    List<String> strs = new ArrayList<String>();
    strs.add(sssss);
    strs.add(ssss);
    strs.add(sss);
    strs.add(ss);
    strs.add(s);

    for (String str : strs) {
      List<Float> fs = QueryRpc.parsePercentiles(str);
      assertEquals(3, fs.size());
      assertEquals(0.98, fs.get(0), 0.0001);
      assertEquals(0.95, fs.get(1), 0.0001);
      assertEquals(0.99, fs.get(2), 0.0001);
    }
  }",0
"public void setOCFormDataAuditsTypesExpected() {
        this.unsetTypeExpected();
        int i = 1;
        this.setTypeExpected(i, TypeNames.INT); // event_crf_id
        ++i;
        this.setTypeExpected(i, TypeNames.INT); // audit_id
        ++i;
        this.setTypeExpected(i, TypeNames.STRING); // name
        ++i;
        this.setTypeExpected(i, TypeNames.INT); // user_id
        ++i;
        this.setTypeExpected(i, TypeNames.TIMESTAMP); // audit_date
        ++i;
        this.setTypeExpected(i, TypeNames.STRING); // reason_for_change
        ++i;
        this.setTypeExpected(i, TypeNames.STRING); // old_value
        ++i;
        this.setTypeExpected(i, TypeNames.STRING); // new_value
        ++i;
        this.setTypeExpected(i, TypeNames.INT); // audit_log_event_type_id
    }",0
"private void handleResetThrottling() throws CommandException {
            synchronized (mLock) {
                parseOptionsLocked(/* takeUser =*/ true);

                Slog.i(TAG, ""cmd: handleResetThrottling: user="" + mUserId);

                resetThrottlingInner(mUserId);
            }
        }",0
"@Override
    void startSelected(int which, boolean always, boolean filtered) {
        super.startSelected(which, always, filtered);

        if (mChooserListAdapter != null) {
            // Log the index of which type of target the user picked.
            // Lower values mean the ranking was better.
            int cat = 0;
            int value = which;
            switch (mChooserListAdapter.getPositionTargetType(which)) {
                case ChooserListAdapter.TARGET_CALLER:
                    cat = MetricsLogger.ACTION_ACTIVITY_CHOOSER_PICKED_APP_TARGET;
                    break;
                case ChooserListAdapter.TARGET_SERVICE:
                    cat = MetricsLogger.ACTION_ACTIVITY_CHOOSER_PICKED_SERVICE_TARGET;
                    value -= mChooserListAdapter.getCallerTargetCount();
                    break;
                case ChooserListAdapter.TARGET_STANDARD:
                    cat = MetricsLogger.ACTION_ACTIVITY_CHOOSER_PICKED_STANDARD_TARGET;
                    value -= mChooserListAdapter.getCallerTargetCount()
                            + mChooserListAdapter.getServiceTargetCount();
                    break;
            }

            if (cat != 0) {
                MetricsLogger.action(this, cat, value);
            }
        }
    }",0
"public void attachStack(int stackId, int displayId) {
        final long origId = Binder.clearCallingIdentity();
        try {
            synchronized (mWindowMap) {
                final DisplayContent displayContent = mDisplayContents.get(displayId);
                if (displayContent != null) {
                    TaskStack stack = mStackIdToStack.get(stackId);
                    if (stack == null) {
                        if (DEBUG_STACK) Slog.d(TAG, ""attachStack: stackId="" + stackId);
                        stack = new TaskStack(this, stackId);
                        mStackIdToStack.put(stackId, stack);
                    }
                    stack.attachDisplayContent(displayContent);
                    displayContent.attachStack(stack);
                    moveStackWindowsLocked(displayContent);
                    final WindowList windows = displayContent.getWindowList();
                    for (int winNdx = windows.size() - 1; winNdx >= 0; --winNdx) {
                        windows.get(winNdx).reportResized();
                    }
                }
            }
        } finally {
            Binder.restoreCallingIdentity(origId);
        }
    }",0
"private SecretKey buildCharArrayKey(String algorithm, char[] pwArray, byte[] salt, int rounds) {
        try {
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(algorithm);
            KeySpec ks = new PBEKeySpec(pwArray, salt, rounds, PBKDF2_KEY_SIZE);
            return keyFactory.generateSecret(ks);
        } catch (InvalidKeySpecException e) {
            Slog.e(TAG, ""Invalid key spec for PBKDF2!"");
        } catch (NoSuchAlgorithmException e) {
            Slog.e(TAG, ""PBKDF2 unavailable!"");
        }
        return null;
    }",0
"@Override
    public <T> T get(String key, Class<T> type) {
        ClusterConfig config = findClusterConfig(key);

        if (config == null) {
            LOG.debug(""Couldn't find cluster config of type {}"", key);
            return null;
        }

        T result = extractPayload(config.payload(), type);
        if (result == null) {
            LOG.error(""Couldn't extract payload from cluster config (type: {})"", key);
        }

        return result;
    }",0
void onIsConferencedChanged(Call call);,0
"@Override
        public String getRemoteUser() {
            return null;
        }",0
"@Deprecated
        public Builder setPriority(@Priority int pri) {
            mN.priority = pri;
            return this;
        }",0
"@Override
  public Route.Definition delete(final String path,
      final Route.ZeroArgHandler handler) {
    return appendDefinition(DELETE, path, handler);
  }",0
"public void deleteAttachement(EntityReference reference) throws Exception
        {
            assertStatusCodes(executeDelete(AttachmentResource.class, toElements(reference)), true, STATUS_NO_CONTENT);
        }",0
"private int getFalsingThreshold() {
        float factor = mStatusBar.isWakeUpComingFromTouch() ? 1.5f : 1.0f;
        return (int) (mQsFalsingThreshold * factor);
    }",0
"public List<WifiScanner.ScanSettings.HiddenNetwork> retrieveHiddenNetworkList(
            boolean autoJoinOnly) {
        List<WifiScanner.ScanSettings.HiddenNetwork> hiddenList = new ArrayList<>();
        List<WifiConfiguration> networks = getConfiguredNetworks();
        // Remove any non hidden networks.
        networks.removeIf(config -> !config.hiddenSSID);
        networks.sort(mScanListComparator);
        // The most frequently connected network has the highest priority now.
        for (WifiConfiguration config : networks) {
            if (!autoJoinOnly || config.allowAutojoin) {
                hiddenList.add(new WifiScanner.ScanSettings.HiddenNetwork(config.SSID));
            }
        }
        return hiddenList;
    }",0
"@Override
        public void run() {
            try {
                switch (mAction) {
                    case ACTION_FAVORITE:
                        mChannelToUpdate.setImportantConversation(true);
                        if (mChannelToUpdate.isImportantConversation()) {
                            mChannelToUpdate.setAllowBubbles(true);
                            if (mAppBubble == BUBBLE_PREFERENCE_NONE) {
                                mINotificationManager.setBubblesAllowed(mAppPkg, mAppUid,
                                        BUBBLE_PREFERENCE_SELECTED);
                            }
                            if (mBubblesManagerOptional.isPresent()) {
                                post(() -> mBubblesManagerOptional.get()
                                        .onUserSetImportantConversation(mEntry));
                            }
                        }
                        mChannelToUpdate.setImportance(Math.max(
                                mChannelToUpdate.getOriginalImportance(), IMPORTANCE_DEFAULT));
                        break;
                    case ACTION_DEFAULT:
                        mChannelToUpdate.setImportance(Math.max(
                                mChannelToUpdate.getOriginalImportance(), IMPORTANCE_DEFAULT));
                        if (mChannelToUpdate.isImportantConversation()) {
                            mChannelToUpdate.setImportantConversation(false);
                            mChannelToUpdate.setAllowBubbles(false);
                        }
                        break;
                    case ACTION_MUTE:
                        if (mChannelToUpdate.getImportance() == IMPORTANCE_UNSPECIFIED
                                || mChannelToUpdate.getImportance() >= IMPORTANCE_DEFAULT) {
                            mChannelToUpdate.setImportance(IMPORTANCE_LOW);
                        }
                        if (mChannelToUpdate.isImportantConversation()) {
                            mChannelToUpdate.setImportantConversation(false);
                            mChannelToUpdate.setAllowBubbles(false);
                        }
                        break;
                }

                mINotificationManager.updateNotificationChannelForPackage(
                            mAppPkg, mAppUid, mChannelToUpdate);
            } catch (RemoteException e) {
                Log.e(TAG, ""Unable to update notification channel"", e);
            }
        }",0
"public void noteWakeupAlarm(IIntentSender sender, int sourceUid, String sourcePkg, String tag)
            throws RemoteException {
        Parcel data = Parcel.obtain();
        data.writeInterfaceToken(IActivityManager.descriptor);
        data.writeStrongBinder(sender.asBinder());
        data.writeInt(sourceUid);
        data.writeString(sourcePkg);
        data.writeString(tag);
        mRemote.transact(NOTE_WAKEUP_ALARM_TRANSACTION, data, null, 0);
        data.recycle();
    }",0
"private void evictThis() {
    try {
      if (Utils.isNullOrEmpty(getNamespace())) {
        throw new KubernetesClientException(""Namespace not specified, but operation requires it."");
      }
      if (Utils.isNullOrEmpty(getName())) {
        throw new KubernetesClientException(""Name not specified, but operation requires it."");
      }
      handleEvict(getResourceUrl(), getNamespace(), getName());
    } catch (Exception e) {
      throw KubernetesClientException.launderThrowable(forOperationType(""evict""), e);
    }
  }",0
"@Override
    public void setSecurityLoggingEnabled(ComponentName admin, String packageName,
            boolean enabled) {
        if (!mHasFeature) {
            return;
        }
        final CallerIdentity caller = getCallerIdentity(admin, packageName);

        synchronized (getLockObject()) {
            if (admin != null) {
                Preconditions.checkCallAuthorization(
                        isProfileOwnerOfOrganizationOwnedDevice(caller)
                        || isDefaultDeviceOwner(caller));
            } else {
                // A delegate app passes a null admin component, which is expected
                Preconditions.checkCallAuthorization(
                        isCallerDelegate(caller, DELEGATION_SECURITY_LOGGING));
            }

            if (enabled == mInjector.securityLogGetLoggingEnabledProperty()) {
                return;
            }
            mInjector.securityLogSetLoggingEnabledProperty(enabled);
            if (enabled) {
                mSecurityLogMonitor.start(getSecurityLoggingEnabledUser());
                maybePauseDeviceWideLoggingLocked();
            } else {
                mSecurityLogMonitor.stop();
            }
        }
        DevicePolicyEventLogger
                .createEvent(DevicePolicyEnums.SET_SECURITY_LOGGING_ENABLED)
                .setAdmin(admin)
                .setBoolean(enabled)
                .write();
    }",0
"private boolean isResetPasswordTokenActiveForUserLocked(int userHandle) {
        DevicePolicyData policy = getUserData(userHandle);
        if (policy.mPasswordTokenHandle != 0) {
            return mInjector.binderWithCleanCallingIdentity(() ->
                    mLockPatternUtils.isEscrowTokenActive(policy.mPasswordTokenHandle, userHandle));
        }
        return false;
    }",0
"@Override
    public boolean getAutoTimeEnabled(ComponentName who) {
        if (!mHasFeature) {
            return false;
        }
        Objects.requireNonNull(who, ""ComponentName is null"");

        final CallerIdentity caller = getCallerIdentity(who);
        Preconditions.checkCallAuthorization(isProfileOwnerOnUser0(caller)
                || isProfileOwnerOfOrganizationOwnedDevice(caller) || isDefaultDeviceOwner(caller));

        return mInjector.settingsGlobalGetInt(Global.AUTO_TIME, 0) > 0;
    }",0
"private void startClockAnimation(int y) {
        if (mClockAnimationTarget == y) {
            return;
        }
        mClockAnimationTarget = y;
        getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {
            @Override
            public boolean onPreDraw() {
                getViewTreeObserver().removeOnPreDrawListener(this);
                if (mClockAnimator != null) {
                    mClockAnimator.removeAllListeners();
                    mClockAnimator.cancel();
                }
                mClockAnimator = ObjectAnimator
                        .ofFloat(mKeyguardStatusView, View.Y, mClockAnimationTarget);
                mClockAnimator.setInterpolator(Interpolators.FAST_OUT_SLOW_IN);
                mClockAnimator.setDuration(StackStateAnimator.ANIMATION_DURATION_STANDARD);
                mClockAnimator.addListener(new AnimatorListenerAdapter() {
                    @Override
                    public void onAnimationEnd(Animator animation) {
                        mClockAnimator = null;
                        mClockAnimationTarget = -1;
                    }
                });
                mClockAnimator.start();
                return true;
            }
        });
    }",0
"@SuppressWarnings(""unused"")
    @CalledByNative
    private void onRenderProcessChange() {
        attachImeAdapter();
    }",0
"@Override
    public XMLBuilder2 stripWhitespaceOnlyTextNodes()
    {
        try {
            super.stripWhitespaceOnlyTextNodesImpl();
            return this;
        } catch (XPathExpressionException e) {
            throw wrapExceptionAsRuntimeException(e);
        }
    }",0
"public AwTestContainerView createDetachedAwTestContainerView(
            final AwContentsClient awContentsClient, boolean supportsLegacyQuirks) {
        final TestDependencyFactory testDependencyFactory = createTestDependencyFactory();

        boolean allowHardwareAcceleration = isHardwareAcceleratedTest();
        final AwTestContainerView testContainerView =
                testDependencyFactory.createAwTestContainerView(getActivity(),
                        allowHardwareAcceleration);

        AwSettings awSettings = testDependencyFactory.createAwSettings(getActivity(),
                supportsLegacyQuirks);
        testContainerView.initialize(new AwContents(mBrowserContext, testContainerView,
                testContainerView.getContext(), testContainerView.getInternalAccessDelegate(),
                testContainerView.getNativeDrawGLFunctorFactory(), awContentsClient, awSettings,
                testDependencyFactory));
        return testContainerView;
    }",0
"public boolean getRevocationReasonInUse() {
        return revocationReasonInUse;
    }",0
"@Test(description = ""Test pullCount of a package from central"", dependsOnMethods = ""testPull"", enabled = false)
    public void testPullCount() throws IOException {
        String url = RepoUtils.getRemoteRepoURL() + ""/modules/info/"" + orgName + ""/"" + moduleName + ""/*/"";
        HttpsURLConnection conn = createHttpsUrlConnection(convertToUrl(url), """", 0, """", """");
        conn.setInstanceFollowRedirects(false);
        setRequestMethod(conn, Utils.RequestMethod.GET);

        int statusCode = conn.getResponseCode();
        if (statusCode == 200) {
            try (BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream(),
                    Charset.defaultCharset()))) {
                StringBuilder result = new StringBuilder();
                String line;
                while ((line = reader.readLine()) != null) {
                    result.append(line);
                }
                Object payload = JSONParser.parse(result.toString());
                if (payload instanceof MapValue) {
                    long pullCount = ((MapValue) payload).getIntValue(""totalPullCount"");
                    Assert.assertEquals(pullCount, totalPullCount);
                } else {
                    Assert.fail(""error: invalid response received"");
                }
            }
        } else {
            Assert.fail(""error: could not connect to remote repository to find the latest version of module"");
        }
    }",1
"@Override
    protected void doPost(final HttpServletRequest request, final HttpServletResponse response) throws IOException {
        final HttpSession session = request.getSession();
        final Cookie csrfCookie = CookieUtils.getCookie(request, ""csrf"");
        if (csrfCookie == null || !csrfCookie.getValue().equals(request.getParameter(""csrf""))) {
            session.setAttribute(""errorMessage"", LocaleUtils.getLocalizedString(""global.csrf.failed""));
        } else {
            final WebManager webManager = new WebManager();
            webManager.init(request, response, session, session.getServletContext());
            final String action = ParamUtils.getStringParameter(request, ""action"", """");
            switch (action) {
                case ""delete"":
                    deleteProperty(request, response, session);
                    break;
                case ""cancel"":
                    session.setAttribute(""warningMessage"", LocaleUtils.getLocalizedString(""system.cache-details.cancelled""));
                    break;
                default:
                    session.setAttribute(""warningMessage"", LocaleUtils.getLocalizedString(""global.request-error-no-such-action"", Collections.singletonList(action)));
                    break;
            }
        }
        response.sendRedirect(request.getRequestURI() + ListPager.getQueryString(request, '?', SEARCH_FIELDS));
    }",0
"@Override
    public List<String> getKeepUninstalledPackages(ComponentName who, String callerPackage) {
        if (!mHasFeature) {
            return null;
        }
        final CallerIdentity caller = getCallerIdentity(who, callerPackage);
        Preconditions.checkCallAuthorization((caller.hasAdminComponent()
                &&  isDefaultDeviceOwner(caller))
                || (caller.hasPackage()
                && isCallerDelegate(caller, DELEGATION_KEEP_UNINSTALLED_PACKAGES)));

        synchronized (getLockObject()) {
            return getKeepUninstalledPackagesLocked();
        }
    }",0
"public Hover doHover(DOMDocument xmlDocument, Position position, XMLHoverSettings settings) {
		return doHover(xmlDocument, position, settings, NULL_CHECKER);
	}",0
"public void unbindBackupAgent(ApplicationInfo app) throws RemoteException {
        Parcel data = Parcel.obtain();
        Parcel reply = Parcel.obtain();
        data.writeInterfaceToken(IActivityManager.descriptor);
        app.writeToParcel(data, 0);
        mRemote.transact(UNBIND_BACKUP_AGENT_TRANSACTION, data, reply, 0);
        reply.readException();
        reply.recycle();
        data.recycle();
    }",0
"@VisibleForTesting
    void setHandler(Handler handler) {
        mHandler = handler;
    }",0
"@Override
    public int movePrimaryStorage(String volumeUuid) throws RemoteException {
        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.MOVE_PACKAGE, null);

        final int realMoveId = mNextMoveId.getAndIncrement();
        final Bundle extras = new Bundle();
        extras.putString(VolumeRecord.EXTRA_FS_UUID, volumeUuid);
        mMoveCallbacks.notifyCreated(realMoveId, extras);

        final IPackageMoveObserver callback = new IPackageMoveObserver.Stub() {
            @Override
            public void onCreated(int moveId, Bundle extras) {
                // Ignored
            }

            @Override
            public void onStatusChanged(int moveId, int status, long estMillis) {
                mMoveCallbacks.notifyStatusChanged(realMoveId, status, estMillis);
            }
        };

        final StorageManager storage = mContext.getSystemService(StorageManager.class);
        storage.setPrimaryStorageUuid(volumeUuid, callback);
        return realMoveId;
    }",0
"private static void fullNavBar(HttpServletRequest request, String suffix, BaseDataInitVO baseDataInitVO) {
        List<LogNav> logNavList = baseDataInitVO.getLogNavs();
        for (LogNav logNav : logNavList) {
            String url = logNav.get(""url"").toString();
            if (""/"".equals(url) && (""/all-1"".equals(request.getRequestURI()) || (Constants.getArticleUri() + ""all-1"").equals(request.getRequestURI()))) {
                logNav.put(""current"", true);
                continue;
            } else if (url.startsWith(""/"")) {
                if (suffix.length() > 0 && url.length() == 1) {
                    url = """";
                } else {
                    url = url.substring(1);
                }
                if (url.startsWith(""/"" + Constants.getArticleUri())) {
                    url += suffix;
                }
                url = WebTools.getHomeUrlWithHost(request) + url;
                logNav.put(""url"", url);
            }
            logNav.put(""current"", ignoreScheme(request.getRequestURL().toString()).equals(ignoreScheme(url)));
        }
    }",0
"private boolean isFilsSha384Supported() {
        return (getSupportedFeatures() & WIFI_FEATURE_FILS_SHA384) != 0;
    }",0
"public void moveTaskToStack(int taskId, int stackId, boolean toTop) throws RemoteException;",0
"public boolean isDebugging() {
    return debugging;
  }",0
"@Test
  public void save3(TestContext context) {
    postgresClient = createFoo(context);
    postgresClient.save(FOO, xPojo, context.asyncAssertSuccess(save -> {
      String id = save;
      postgresClient.getById(FOO, id, context.asyncAssertSuccess(get -> {
        context.assertEquals(""x"", get.getString(""key""));
      }));
    }));
  }",0
"public static boolean isEmpty(String value) {

        return (value == null) || (value.length() == 0);
    }",0
"public Property<?> getProperty() {
            return getItem().getItemProperty(propertyId);
        }",0
"void unbindPaymentServiceLocked() {
        if (mPaymentServiceBound) {
            mContext.unbindService(mPaymentConnection);
            mPaymentServiceBound = false;
            mPaymentService = null;
            mPaymentServiceName = null;
            mPaymentServiceUserId = -1;
        }
    }",0
"@TestApi
    @RequiresPermission(android.Manifest.permission.MANAGE_PROFILE_AND_DEVICE_OWNERS)
    public boolean setDeviceOwner(@NonNull ComponentName who, @UserIdInt int userId) {
        if (mService != null) {
            try {
                return mService.setDeviceOwner(who, userId,
                        /* setProfileOwnerOnCurrentUserIfNecessary= */ true);
            } catch (RemoteException re) {
                throw re.rethrowFromSystemServer();
            }
        }
        return false;
    }",0
"private String getPackageNameForUid(int uid) {
        String[] packageNames = mPackageManager.getPackagesForUid(uid);
        if (ArrayUtils.isEmpty(packageNames)) {
            return null;
        }
        String packageName = packageNames[0];
        if (packageNames.length == 1) {
            return packageName;
        }
        // Due to visibility changes we want to use package with oldest target SDK
        int oldestVersion = Integer.MAX_VALUE;
        for (String name : packageNames) {
            try {
                ApplicationInfo applicationInfo = mPackageManager.getApplicationInfo(name, 0);
                if (applicationInfo != null) {
                    int version = applicationInfo.targetSdkVersion;
                    if (version < oldestVersion) {
                        oldestVersion = version;
                        packageName = name;
                    }
                }
            } catch (NameNotFoundException e) {
                // skip
            }
        }
        return packageName;
    }",0
"private void repairForLegacyLibrary(Document doc, Element root) {
		Element legacyElt = null;
		String legacyLabel = null;
		for (Element libElt : XmlIterator.forChildElements(root, ""lib"")) {
			String desc = libElt.getAttribute(""desc"");
			String label = libElt.getAttribute(""name"");
			if (desc != null && desc.equals(""#Legacy"")) {
				legacyElt = libElt;
				legacyLabel = label;
			}
		}

		if (legacyElt != null) {
			root.removeChild(legacyElt);

			ArrayList<Element> toRemove = new ArrayList<Element>();
			findLibraryUses(toRemove, legacyLabel,
					XmlIterator.forDescendantElements(root, ""comp""));
			boolean componentsRemoved = !toRemove.isEmpty();
			findLibraryUses(toRemove, legacyLabel,
					XmlIterator.forDescendantElements(root, ""tool""));
			for (Element elt : toRemove) {
				elt.getParentNode().removeChild(elt);
			}
			if (componentsRemoved) {
				String error = ""Some components have been deleted;""
						+ "" the Legacy library is no longer supported."";
				Element elt = doc.createElement(""message"");
				elt.setAttribute(""value"", error);
				root.appendChild(elt);
			}
		}
	}",0
"protected final void _verifyNullForPrimitive(DeserializationContext ctxt) throws JsonMappingException
    {
        if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)) {
            ctxt.reportInputMismatch(this,
""Cannot coerce `null` to %s (disable `DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES` to allow)"",
                    _coercedTypeDesc());
        }
    }",0
"public int getNumExecutors() {
        return numExecutors;
    }",0
"@Nullable
        public String getIdAttribute() {
            final int id = nativeGetIdAttribute(mParseState);
            if (id == ERROR_NULL_DOCUMENT) {
                throw new NullPointerException(""Null document"");
            }
            return id >= 0 ? getSequenceString(mStrings.getSequence(id)) : null;
        }",0
"public X509Certificate getCaCertificate() {
        return mCaCert;
    }",0
"public List<XWikiAttachment> getAttachmentList()
    {
        return this.attachmentList;
    }",0
"public ServerBuilder tlsSelfSigned() {
        virtualHostTemplate.tlsSelfSigned();
        return this;
    }",0
"public String getExecutable()
    {
        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )
        {
            return super.getExecutable();
        }

        return quoteOneItem( super.getExecutable(), true );
    }",1
"public void execute(String sql, List<JsonArray> params, Handler<AsyncResult<List<UpdateResult>>> replyHandler) {
    startTx(transaction -> {
      if (transaction.failed()) {
        replyHandler.handle(Future.failedFuture(transaction.cause()));
        return;
      }
      execute(transaction, sql, params, result -> {
        if (result.failed()) {
          rollbackTx(transaction, rollback -> replyHandler.handle(result));
          return;
        }
        endTx(transaction, end -> {
          if (end.failed()) {
            replyHandler.handle(Future.failedFuture(end.cause()));
            return;
          }
          replyHandler.handle(result);
        });
      });
    });
  }",0
"private final int jjStartNfa_1(int pos, long active0)
{
   return jjMoveNfa_1(jjStopStringLiteralDfa_1(pos, active0), pos + 1);
}",0
"public Map<String, String> getServerVariables() {
    return serverVariables;
  }",0
"protected UiccCardApplication getUiccCardApplication() {
            return  mUiccController.getUiccCardApplication(mPhone.getPhoneId(),
                    UiccController.APP_FAM_3GPP2);
    }",0
"public final void setProxyGrantingTicketStorage(final ProxyGrantingTicketStorage proxyGrantingTicketStorage) {
        this.proxyGrantingTicketStorage = proxyGrantingTicketStorage;
    }",0
"protected void engineUpdate(
        byte    b)
        throws SignatureException
    {
        digest.update(b);
    }",0
"@Override
                public Integer recompute(PermissionQuery query) {
                    return checkPermissionUncached(query.permission, query.pid, query.uid);
                }",0
"private PendingAssistExtras enqueueAssistContext(int requestType, Intent intent, String hint,
            IResultReceiver receiver, Bundle receiverExtras, IBinder activityToken,
            boolean focused, boolean newSessionId, int userHandle, Bundle args, long timeout) {
        enforceCallingPermission(android.Manifest.permission.GET_TOP_ACTIVITY_INFO,
                ""enqueueAssistContext()"");
        synchronized (this) {
            ActivityRecord activity = getFocusedStack().topActivity();
            if (activity == null) {
                Slog.w(TAG, ""getAssistContextExtras failed: no top activity"");
                return null;
            }
            if (activity.app == null || activity.app.thread == null) {
                Slog.w(TAG, ""getAssistContextExtras failed: no process for "" + activity);
                return null;
            }
            if (focused) {
                if (activityToken != null) {
                    ActivityRecord caller = ActivityRecord.forTokenLocked(activityToken);
                    if (activity != caller) {
                        Slog.w(TAG, ""enqueueAssistContext failed: caller "" + caller
                                + "" is not current top "" + activity);
                        return null;
                    }
                }
            } else {
                activity = ActivityRecord.forTokenLocked(activityToken);
                if (activity == null) {
                    Slog.w(TAG, ""enqueueAssistContext failed: activity for token="" + activityToken
                            + "" couldn't be found"");
                    return null;
                }
            }

            PendingAssistExtras pae;
            Bundle extras = new Bundle();
            if (args != null) {
                extras.putAll(args);
            }
            extras.putString(Intent.EXTRA_ASSIST_PACKAGE, activity.packageName);
            extras.putInt(Intent.EXTRA_ASSIST_UID, activity.app.uid);
            pae = new PendingAssistExtras(activity, extras, intent, hint, receiver, receiverExtras,
                    userHandle);
            // Increment the sessionId if necessary
            if (newSessionId) {
                mViSessionId++;
            }
            try {
                activity.app.thread.requestAssistContextExtras(activity.appToken, pae,
                        requestType, mViSessionId);
                mPendingAssistExtras.add(pae);
                mUiHandler.postDelayed(pae, timeout);
            } catch (RemoteException e) {
                Slog.w(TAG, ""getAssistContextExtras failed: crash calling "" + activity);
                return null;
            }
            return pae;
        }
    }",0
"protected String getPlatformConfig(String platform) {
        IntegrationRequest request = new IntegrationRequest();
        if (StringUtils.isBlank(workspaceId)) {
            MSException.throwException(""workspace id is null"");
        }
        request.setWorkspaceId(workspaceId);
        request.setPlatform(platform);

        ServiceIntegration integration = baseIntegrationService.get(request);
        return integration.getConfiguration();
    }",0
"public void handleUserStop(int userId) {
        if (mVerboseLoggingEnabled) {
            Log.v(TAG, ""Handling user stop for "" + userId);
        }
        if (userId == mCurrentUserId
                && mUserManager.isUserUnlockingOrUnlocked(UserHandle.of(mCurrentUserId))) {
            saveToStore(true);
            clearInternalDataForUser(mCurrentUserId);
        }
    }",0
"@UnsupportedAppUsage
    public static int cursorPickFillWindowStartPosition(
            int cursorPosition, int cursorWindowCapacity) {
        return Math.max(cursorPosition - cursorWindowCapacity / 3, 0);
    }",0
"@Override
        public void setQueueTitle(CharSequence title) throws RemoteException {
            mQueueTitle = title;
            mHandler.post(MessageHandler.MSG_UPDATE_QUEUE_TITLE);
        }",0
"public boolean bindBackupAgent(String packageName, int backupMode, int userId) {
        if (DEBUG_BACKUP) Slog.v(TAG, ""bindBackupAgent: app="" + packageName + "" mode="" + backupMode);
        enforceCallingPermission(""android.permission.CONFIRM_FULL_BACKUP"", ""bindBackupAgent"");

        IPackageManager pm = AppGlobals.getPackageManager();
        ApplicationInfo app = null;
        try {
            app = pm.getApplicationInfo(packageName, 0, userId);
        } catch (RemoteException e) {
            // can't happen; package manager is process-local
        }
        if (app == null) {
            Slog.w(TAG, ""Unable to bind backup agent for "" + packageName);
            return false;
        }

        synchronized(this) {
            // !!! TODO: currently no check here that we're already bound
            BatteryStatsImpl.Uid.Pkg.Serv ss = null;
            BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics();
            synchronized (stats) {
                ss = stats.getServiceStatsLocked(app.uid, app.packageName, app.name);
            }

            // Backup agent is now in use, its package can't be stopped.
            try {
                AppGlobals.getPackageManager().setPackageStoppedState(
                        app.packageName, false, UserHandle.getUserId(app.uid));
            } catch (RemoteException e) {
            } catch (IllegalArgumentException e) {
                Slog.w(TAG, ""Failed trying to unstop package ""
                        + app.packageName + "": "" + e);
            }

            BackupRecord r = new BackupRecord(ss, app, backupMode);
            ComponentName hostingName = (backupMode == IApplicationThread.BACKUP_MODE_INCREMENTAL)
                    ? new ComponentName(app.packageName, app.backupAgentName)
                    : new ComponentName(""android"", ""FullBackupAgent"");
            // startProcessLocked() returns existing proc's record if it's already running
            ProcessRecord proc = startProcessLocked(app.processName, app,
                    false, 0, ""backup"", hostingName, false, false, false);
            if (proc == null) {
                Slog.e(TAG, ""Unable to start backup agent process "" + r);
                return false;
            }

            r.app = proc;
            mBackupTarget = r;
            mBackupAppName = app.packageName;

            // Try not to kill the process during backup
            updateOomAdjLocked(proc);

            // If the process is already attached, schedule the creation of the backup agent now.
            // If it is not yet live, this will be done when it attaches to the framework.
            if (proc.thread != null) {
                if (DEBUG_BACKUP) Slog.v(TAG_BACKUP, ""Agent proc already running: "" + proc);
                try {
                    proc.thread.scheduleCreateBackupAgent(app,
                            compatibilityInfoForPackageLocked(app), backupMode);
                } catch (RemoteException e) {
                    // Will time out on the backup manager side
                }
            } else {
                if (DEBUG_BACKUP) Slog.v(TAG_BACKUP, ""Agent proc not running, waiting for attach"");
            }
            // Invariants: at this point, the target app process exists and the application
            // is either already running or in the process of coming up.  mBackupTarget and
            // mBackupAppName describe the app, so that when it binds back to the AM we
            // know that it's scheduled for a backup-agent operation.
        }

        return true;
    }",1
"private void writeRow(Element container, T item, DesignContext context) {
        Element tableRow = container.appendElement(""tr"");
        tableRow.attr(""item"", serializeDeclarativeRepresentation(item));
        if (getSelectionModel().isSelected(item)) {
            tableRow.attr(""selected"", true);
        }
        for (Column<T, ?> column : getColumns()) {
            Object value = column.valueProvider.apply(item);
            tableRow.appendElement(""td"")
                    .append(Optional.ofNullable(value).map(Object::toString)
                            .map(DesignFormatter::encodeForTextNode)
                            .orElse(""""));
        }
    }",0
"protected abstract void writeBody(ObjectOutput out, ByteArrayOutputStream bout) throws IOException;",0
"void sendUserSwitchBroadcastsLocked(int oldUserId, int newUserId) {
        long ident = Binder.clearCallingIdentity();
        try {
            Intent intent;
            if (oldUserId >= 0) {
                // Send USER_BACKGROUND broadcast to all profiles of the outgoing user
                List<UserInfo> profiles = mUserManager.getProfiles(oldUserId, false);
                int count = profiles.size();
                for (int i = 0; i < count; i++) {
                    int profileUserId = profiles.get(i).id;
                    intent = new Intent(Intent.ACTION_USER_BACKGROUND);
                    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY
                            | Intent.FLAG_RECEIVER_FOREGROUND);
                    intent.putExtra(Intent.EXTRA_USER_HANDLE, profileUserId);
                    broadcastIntentLocked(null, null, intent,
                            null, null, 0, null, null, null, AppOpsManager.OP_NONE,
                            false, false, MY_PID, Process.SYSTEM_UID, profileUserId);
                }
            }
            if (newUserId >= 0) {
                // Send USER_FOREGROUND broadcast to all profiles of the incoming user
                List<UserInfo> profiles = mUserManager.getProfiles(newUserId, false);
                int count = profiles.size();
                for (int i = 0; i < count; i++) {
                    int profileUserId = profiles.get(i).id;
                    intent = new Intent(Intent.ACTION_USER_FOREGROUND);
                    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY
                            | Intent.FLAG_RECEIVER_FOREGROUND);
                    intent.putExtra(Intent.EXTRA_USER_HANDLE, profileUserId);
                    broadcastIntentLocked(null, null, intent,
                            null, null, 0, null, null, null, AppOpsManager.OP_NONE,
                            false, false, MY_PID, Process.SYSTEM_UID, profileUserId);
                }
                intent = new Intent(Intent.ACTION_USER_SWITCHED);
                intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY
                        | Intent.FLAG_RECEIVER_FOREGROUND);
                intent.putExtra(Intent.EXTRA_USER_HANDLE, newUserId);
                broadcastIntentLocked(null, null, intent,
                        null, null, 0, null, null,
                        android.Manifest.permission.MANAGE_USERS, AppOpsManager.OP_NONE,
                        false, false, MY_PID, Process.SYSTEM_UID, UserHandle.USER_ALL);
            }
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }",0
"@Override
    public void stopAppSwitches() {
        mAmInternal.enforceCallingPermission(STOP_APP_SWITCHES, ""stopAppSwitches"");
        synchronized (mGlobalLock) {
            mAppSwitchesState = APP_SWITCH_DISALLOW;
            mLastStopAppSwitchesTime = SystemClock.uptimeMillis();
            mH.removeMessages(H.RESUME_FG_APP_SWITCH_MSG);
            mH.sendEmptyMessageDelayed(H.RESUME_FG_APP_SWITCH_MSG, RESUME_FG_APP_SWITCH_MS);
        }
    }",0
"@Override
    public void release() {
        
        released = true;
        ajaxRequest = null;
        renderAll = null;
        partialResponseWriter = null;
        executeIds = null;
        renderIds = null;
        evalScripts = null;
        ctx = null;
        partialRequest = null;

    }",0
"@Override
    public void addPackageDependency(String packageName) {
        synchronized (this) {
            int callingPid = Binder.getCallingPid();
            if (callingPid == Process.myPid()) {
                //  Yeah, um, no.
                return;
            }
            ProcessRecord proc;
            synchronized (mPidsSelfLocked) {
                proc = mPidsSelfLocked.get(Binder.getCallingPid());
            }
            if (proc != null) {
                if (proc.pkgDeps == null) {
                    proc.pkgDeps = new ArraySet<String>(1);
                }
                proc.pkgDeps.add(packageName);
            }
        }
    }",0
"private boolean hasIncompatibleAccounts(int userId) {
        return mHasIncompatibleAccounts == null ? true
                : mHasIncompatibleAccounts.getOrDefault(userId, /* default= */ false);
    }",0
"@Override
    public void beginWikiDocumentLocale(Locale locale, FilterEventParameters parameters) throws FilterException
    {
        this.currentLocale = locale;
        this.currentLocaleParameters = parameters;

        begin(parameters);
    }",0
"@GuardedBy(""this"")
    void grantUriPermissionFromIntentLocked(int callingUid,
            String targetPkg, Intent intent, UriPermissionOwner owner, int targetUserId) {
        NeededUriGrants needed = checkGrantUriPermissionFromIntentLocked(callingUid, targetPkg,
                intent, intent != null ? intent.getFlags() : 0, null, targetUserId);
        if (needed == null) {
            return;
        }

        grantUriPermissionUncheckedFromIntentLocked(needed, owner);
    }",0
"public List<WifiConfiguration> getWifiConfigsForPasspointProfiles(List<String> idList) {
        if (mProviders.isEmpty()) {
            return Collections.emptyList();
        }
        List<WifiConfiguration> configs = new ArrayList<>();
        Set<String> uniqueIdSet = new HashSet<>();
        uniqueIdSet.addAll(idList);
        for (String uniqueId : uniqueIdSet) {
            PasspointProvider provider = mProviders.get(uniqueId);
            if (provider == null) {
                continue;
            }
            WifiConfiguration config = provider.getWifiConfig();
            config = mWifiConfigManager.getConfiguredNetwork(config.getProfileKey());
            if (config == null) {
                continue;
            }
            // If the Passpoint configuration is from a suggestion, check if the app shares this
            // suggestion with the user.
            if (provider.isFromSuggestion()
                    && !mWifiInjector.getWifiNetworkSuggestionsManager()
                    .isPasspointSuggestionSharedWithUser(config)) {
                continue;
            }
            if (mWifiConfigManager.shouldUseNonPersistentRandomization(config)) {
                config.setRandomizedMacAddress(MacAddress.fromString(DEFAULT_MAC_ADDRESS));
            } else {
                MacAddress result = mMacAddressUtil.calculatePersistentMac(config.getNetworkKey(),
                        mMacAddressUtil.obtainMacRandHashFunction(Process.WIFI_UID));
                if (result != null) {
                    config.setRandomizedMacAddress(result);
                }
            }
            configs.add(config);
        }
        return configs;
    }",0
"@Override
    public boolean onTransact(int code, Parcel data, Parcel reply, int flags)
            throws RemoteException {
        try {
            return super.onTransact(code, data, reply, flags);
        } catch (RuntimeException e) {
            // The content service only throws security exceptions, so let's
            // log all others.
            if (!(e instanceof SecurityException)) {
                Slog.wtf(TAG, ""Content Service Crash"", e);
            }
            throw e;
        }
    }",0
"@Deprecated
    public BaseClass getSheetClass(XWikiContext context) throws XWikiException
    {
        return getMandatoryClass(context, new DocumentReference(context.getWikiId(), SYSTEM_SPACE, ""SheetClass""));
    }",0
"protected void setArgumentEscapePattern(String argumentEscapePattern)
    {
        this.argumentEscapePattern = argumentEscapePattern;
    }",0
"public void engineInit(
        int opmode,
        Key key,
        SecureRandom random)
        throws InvalidKeyException
    {
        try
        {
            engineInit(opmode, key, (AlgorithmParameterSpec)null, random);
        }
        catch (InvalidAlgorithmParameterException e)
        {
            throw new IllegalArgumentException(""cannot handle supplied parameter spec: "" + e.getMessage());
        }

    }",0
"public String displayDocument(Syntax targetSyntax) throws XWikiException
    {
        return this.doc.displayDocument(targetSyntax, getXWikiContext());
    }",0
"public static String getJwtTokenFromAuthorizationHeaderValue(final String value) {
    if (value != null) {
      final String bearerSchemaName = ""Bearer "";
      if (value.startsWith(bearerSchemaName)) {
        return value.substring(bearerSchemaName.length());
      }
    }
    return null;
  }",0
"public static void setBeginningOfStep(HttpServletRequest request,
            boolean beginningOfStep)
    {
        request.setAttribute(""step.start"", Boolean.valueOf(beginningOfStep));
    }",0
"private void transferActiveAdminUncheckedLocked(ComponentName incomingReceiver,
            ComponentName outgoingReceiver, int userHandle) {
        final DevicePolicyData policy = getUserData(userHandle);
        if (!policy.mAdminMap.containsKey(outgoingReceiver)
                && policy.mAdminMap.containsKey(incomingReceiver)) {
            // Nothing to transfer - the incoming receiver is already the active admin.
            return;
        }
        final DeviceAdminInfo incomingDeviceInfo = findAdmin(incomingReceiver, userHandle,
            /* throwForMissingPermission= */ true);
        final ActiveAdmin adminToTransfer = policy.mAdminMap.get(outgoingReceiver);
        final int oldAdminUid = adminToTransfer.getUid();

        if (isPolicyEngineForFinanceFlagEnabled() || isPermissionCheckFlagEnabled()) {
            EnforcingAdmin oldAdmin =
                    EnforcingAdmin.createEnterpriseEnforcingAdmin(
                            outgoingReceiver, userHandle, adminToTransfer);
            EnforcingAdmin newAdmin =
                    EnforcingAdmin.createEnterpriseEnforcingAdmin(
                            incomingReceiver, userHandle, adminToTransfer);

            mDevicePolicyEngine.transferPolicies(oldAdmin, newAdmin);
        }

        adminToTransfer.transfer(incomingDeviceInfo);
        policy.mAdminMap.remove(outgoingReceiver);
        policy.mAdminMap.put(incomingReceiver, adminToTransfer);
        if (policy.mPasswordOwner == oldAdminUid) {
            policy.mPasswordOwner = adminToTransfer.getUid();
        }

        saveSettingsLocked(userHandle);
        sendAdminCommandLocked(adminToTransfer, DeviceAdminReceiver.ACTION_DEVICE_ADMIN_ENABLED,
                null, null);
    }",0
"@Deprecated
        public boolean getHintShowBackgroundOnly() {
            return (mFlags & FLAG_HINT_SHOW_BACKGROUND_ONLY) != 0;
        }",0
"private void writeUserLocked(UserInfo userInfo) {
        FileOutputStream fos = null;
        AtomicFile userFile = new AtomicFile(new File(mUsersDir, userInfo.id + XML_SUFFIX));
        try {
            fos = userFile.startWrite();
            final BufferedOutputStream bos = new BufferedOutputStream(fos);

            // XmlSerializer serializer = XmlUtils.serializerInstance();
            final XmlSerializer serializer = new FastXmlSerializer();
            serializer.setOutput(bos, StandardCharsets.UTF_8.name());
            serializer.startDocument(null, true);
            serializer.setFeature(""http://xmlpull.org/v1/doc/features.html#indent-output"", true);

            serializer.startTag(null, TAG_USER);
            serializer.attribute(null, ATTR_ID, Integer.toString(userInfo.id));
            serializer.attribute(null, ATTR_SERIAL_NO, Integer.toString(userInfo.serialNumber));
            serializer.attribute(null, ATTR_FLAGS, Integer.toString(userInfo.flags));
            serializer.attribute(null, ATTR_CREATION_TIME, Long.toString(userInfo.creationTime));
            serializer.attribute(null, ATTR_LAST_LOGGED_IN_TIME,
                    Long.toString(userInfo.lastLoggedInTime));
            if (userInfo.iconPath != null) {
                serializer.attribute(null,  ATTR_ICON_PATH, userInfo.iconPath);
            }
            if (userInfo.partial) {
                serializer.attribute(null, ATTR_PARTIAL, ""true"");
            }
            if (userInfo.guestToRemove) {
                serializer.attribute(null, ATTR_GUEST_TO_REMOVE, ""true"");
            }
            if (userInfo.profileGroupId != UserInfo.NO_PROFILE_GROUP_ID) {
                serializer.attribute(null, ATTR_PROFILE_GROUP_ID,
                        Integer.toString(userInfo.profileGroupId));
            }

            serializer.startTag(null, TAG_NAME);
            serializer.text(userInfo.name);
            serializer.endTag(null, TAG_NAME);
            Bundle restrictions = mUserRestrictions.get(userInfo.id);
            if (restrictions != null) {
                writeRestrictionsLocked(serializer, restrictions);
            }
            serializer.endTag(null, TAG_USER);

            serializer.endDocument();
            userFile.finishWrite(fos);
        } catch (Exception ioe) {
            Slog.e(LOG_TAG, ""Error writing user info "" + userInfo.id + ""\n"" + ioe);
            userFile.failWrite(fos);
        }
    }",0
"private void bindActions() {

        // TODO: b/152050825
        /*
        Button home = findViewById(R.id.home);
        home.setOnClickListener(mOnHomeClick);
        home.setVisibility(mShortcutInfo != null
                && mShortcutManager.isRequestPinShortcutSupported()
                ? VISIBLE : GONE);

        Button snooze = findViewById(R.id.snooze);
        snooze.setOnClickListener(mOnSnoozeClick);
        */

        if (mAppBubble == BUBBLE_PREFERENCE_ALL) {
            ((TextView) findViewById(R.id.default_summary)).setText(getResources().getString(
                    R.string.notification_channel_summary_default_with_bubbles, mAppName));
        }

        findViewById(R.id.priority).setOnClickListener(mOnFavoriteClick);
        findViewById(R.id.default_behavior).setOnClickListener(mOnDefaultClick);
        findViewById(R.id.silence).setOnClickListener(mOnMuteClick);

        final View settingsButton = findViewById(R.id.info);
        settingsButton.setOnClickListener(getSettingsOnClickListener());
        settingsButton.setVisibility(settingsButton.hasOnClickListeners() ? VISIBLE : GONE);

        updateToggleActions(mSelectedAction == -1 ? getPriority() : mSelectedAction,
                false);
    }",0
"private void updateDialerAndSmsManagedShortcutsOverrideCache() {
        ArrayMap<String, String> shortcutOverrides = new ArrayMap<>();
        int managedUserId = getManagedUserId();
        List<String> dialerRoleHolders = mRoleManager.getRoleHoldersAsUser(RoleManager.ROLE_DIALER,
                UserHandle.of(managedUserId));
        List<String> smsRoleHolders = mRoleManager.getRoleHoldersAsUser(RoleManager.ROLE_SMS,
                UserHandle.of(managedUserId));

        String dialerPackageToOverride = getOemDefaultDialerPackage();
        String smsPackageToOverride = getOemDefaultSmsPackage();

        // To get the default app, we can get all the role holders and get the first element.
        if (dialerPackageToOverride != null) {
            shortcutOverrides.put(dialerPackageToOverride,
                    dialerRoleHolders.isEmpty() ? dialerPackageToOverride
                            : dialerRoleHolders.get(0));
        }
        if (smsPackageToOverride != null) {
            shortcutOverrides.put(smsPackageToOverride,
                    smsRoleHolders.isEmpty() ? smsPackageToOverride : smsRoleHolders.get(0));
        }

        mPolicyCache.setLauncherShortcutOverrides(shortcutOverrides);
    }",0
"@Override
    public Media createMediaRecorder(MediaRecorderBuilder builder) throws IOException {
        return createMediaRecorder(builder.getPath(), builder.getMimeType(), builder.getSamplingRate(), builder.getBitRate(), builder.getAudioChannels(), 0, builder.isRedirectToAudioBuffer());
    }",0
"private void reloadHighlightMenuKey() {
        mMainFragment.getArguments().putString(SettingsActivity.EXTRA_FRAGMENT_ARG_KEY,
                getHighlightMenuKey());
        mMainFragment.reloadHighlightMenuKey();
    }",0
"public static String processFile(File file) throws IOException
	{
		Deflater deflater = new Deflater(Deflater.BEST_COMPRESSION, true);
		byte[] inBytes = readInputStream(new FileInputStream(file)).getBytes(""UTF-8"");
		deflater.setInput(inBytes);

		ByteArrayOutputStream outputStream = new ByteArrayOutputStream(
				inBytes.length);
		deflater.finish();
		byte[] buffer = new byte[IO_BUFFER_SIZE];

		while (!deflater.finished())
		{
			int count = deflater.deflate(buffer); // returns the generated code... index  
			outputStream.write(buffer, 0, count);
		}

		outputStream.close();

		return Base64.getEncoder().encodeToString(outputStream.toByteArray());
	}",1
"@LargeTest
    @Test
    public void testOutgoingVideoCallAnsweredAsAudio() throws Exception {
        IdPair ids = startOutgoingPhoneCall(""650-555-1212"", mPhoneAccountA0.getAccountHandle(),
                mConnectionServiceFixtureA, Process.myUserHandle(),
                VideoProfile.STATE_BIDIRECTIONAL, null);
        com.android.server.telecom.Call call = mTelecomSystem.getCallsManager().getCalls()
                .iterator().next();

        mConnectionServiceFixtureA.mConnectionById.get(ids.mConnectionId).videoState
                = VideoProfile.STATE_AUDIO_ONLY;
        mConnectionServiceFixtureA.sendSetVideoState(ids.mConnectionId);
        mConnectionServiceFixtureA.sendSetActive(ids.mConnectionId);

        assertFalse(VideoProfile.isVideo(call.getVideoStateHistory()));
    }",1
"@Override
    protected PollingResult compareRemoteRevisionWith(AbstractProject<?,?> project, Launcher launcher, FilePath workspace, final TaskListener listener, SCMRevisionState _baseline) throws IOException, InterruptedException {
        final SVNRevisionState baseline;
        if (_baseline instanceof SVNRevisionState) {
            baseline = (SVNRevisionState)_baseline;
        }
        else if (project.getLastBuild()!=null) {
            baseline = (SVNRevisionState)calcRevisionsFromBuild(project.getLastBuild(), launcher, listener);
        }
        else {
            baseline = new SVNRevisionState(null);
        }
        
        if (project.getLastBuild() == null) {
            listener.getLogger().println(Messages.SubversionSCM_pollChanges_noBuilds());
            return BUILD_NOW;
        }

        AbstractBuild<?,?> lastCompletedBuild = project.getLastCompletedBuild();

        if (lastCompletedBuild!=null) {
            EnvVars env = lastCompletedBuild.getEnvironment(listener);
            EnvVarsUtils.overrideAll(env, lastCompletedBuild.getBuildVariables());
            if (repositoryLocationsNoLongerExist(lastCompletedBuild, listener, env)) {
                // Disable this project, see HUDSON-763
                listener.getLogger().println(
                        Messages.SubversionSCM_pollChanges_locationsNoLongerExist(project));
                project.makeDisabled(true);
                return NO_CHANGES;
            }

            // are the locations checked out in the workspace consistent with the current configuration?
            for (ModuleLocation loc : getLocations(env, lastCompletedBuild)) {
                // baseline.revisions has URIdecoded URL
                String url;
                try { 
                    url = loc.getSVNURL().toDecodedString();
                } catch (SVNException ex) {
                    ex.printStackTrace(listener.error(Messages.SubversionSCM_pollChanges_exception(loc.getURL())));
                    return BUILD_NOW;
                }
                if (!baseline.revisions.containsKey(url)) {
                    listener.getLogger().println(
                            Messages.SubversionSCM_pollChanges_locationNotInWorkspace(url));
                    return BUILD_NOW;
                }
            }
        }

        // determine where to perform polling. prefer the node where the build happened,
        // in case a cluster is non-uniform. see http://www.nabble.com/svn-connection-from-slave-only-td24970587.html
        VirtualChannel ch=null;
        Node n = null;
        if (!isPollFromMaster()) {
            n = lastCompletedBuild!=null ? lastCompletedBuild.getBuiltOn() : null;
            if (n!=null) {
                Computer c = n.toComputer();
                if (c!=null)    ch = c.getChannel();
            }
        }
        if (ch==null)   ch= MasterComputer.localChannel;
 
        final String nodeName = n!=null ? n.getNodeName() : ""master"";

        final SVNLogHandler logHandler = new SVNLogHandler(createSVNLogFilter(), listener);

        final ISVNAuthenticationProvider authProvider = getDescriptor().createAuthenticationProvider(project);

        // figure out the remote revisions
        return ch.call(new CompareAgainstBaselineCallable(baseline, logHandler, project.getName(), listener, authProvider, nodeName));
    }",0
"@GuardedBy(""this"")
    void handleProcessStartOrKillTimeoutLocked(ProcessRecord app, boolean isKillTimeout) {
        final int pid = app.getPid();
        boolean gone = isKillTimeout || removePidIfNoThreadLocked(app);

        if (gone) {
            if (isKillTimeout) {
                // It's still alive... maybe blocked at uninterruptible sleep ?
                final ProcessRecord successor = app.mSuccessor;
                if (successor == null) {
                    // There might be a race, nothing to do here.
                    return;
                }
                Slog.wtf(TAG, app.toString() + "" "" + app.getDyingPid()
                        + "" refused to die while trying to launch "" + successor
                        + "", cancelling the process start"");

                // It doesn't make sense to proceed with launching the new instance while the old
                // instance is still alive, abort the launch.
                app.mSuccessorStartRunnable = null;
                app.mSuccessor = null;
                successor.mPredecessor = null;

                // We're going to cleanup the successor process record, which wasn't started at all.
                app = successor;
            } else {
                final String msg = ""Process "" + app + "" failed to attach"";
                Slog.w(TAG, msg);
                EventLogTags.writeAmProcessStartTimeout(app.userId, pid, app.uid, app.processName);
                if (app.getActiveInstrumentation() != null) {
                    final Bundle info = new Bundle();
                    info.putString(""shortMsg"", ""failed to attach"");
                    info.putString(""longMsg"", msg);
                    finishInstrumentationLocked(app, Activity.RESULT_CANCELED, info);
                }
            }
            synchronized (mProcLock) {
                mProcessList.removeProcessNameLocked(app.processName, app.uid);
                mAtmInternal.clearHeavyWeightProcessIfEquals(app.getWindowProcessController());
                // Take care of any launching providers waiting for this process.
                mCpHelper.cleanupAppInLaunchingProvidersLocked(app, true);
                // Take care of any services that are waiting for the process.
                mServices.processStartTimedOutLocked(app);
                if (!isKillTimeout) {
                    mBatteryStatsService.noteProcessFinish(app.processName, app.info.uid);
                    app.killLocked(""start timeout"",
                            ApplicationExitInfo.REASON_INITIALIZATION_FAILURE, true);
                    removeLruProcessLocked(app);
                }
                if (app.isolated) {
                    mBatteryStatsService.removeIsolatedUid(app.uid, app.info.uid);
                    mProcessList.mAppExitInfoTracker.mIsolatedUidRecords.removeIsolatedUid(
                            app.uid, app.info.uid);
                    getPackageManagerInternal().removeIsolatedUid(app.uid);
                }
            }
            final BackupRecord backupTarget = mBackupTargets.get(app.userId);
            if (!isKillTimeout && backupTarget != null && backupTarget.app.getPid() == pid) {
                Slog.w(TAG, ""Unattached app died before backup, skipping"");
                final int userId = app.userId;
                final String packageName = app.info.packageName;
                mHandler.post(new Runnable() {
                @Override
                    public void run(){
                        try {
                            IBackupManager bm = IBackupManager.Stub.asInterface(
                                    ServiceManager.getService(Context.BACKUP_SERVICE));
                            bm.agentDisconnectedForUser(userId, packageName);
                        } catch (RemoteException e) {
                            // Can't happen; the backup manager is local
                        }
                    }
                });
            }
            if (!isKillTimeout) {
                if (isPendingBroadcastProcessLocked(pid)) {
                    Slog.w(TAG, ""Unattached app died before broadcast acknowledged, skipping"");
                    skipPendingBroadcastLocked(pid);
                }
            } else {
                if (isPendingBroadcastProcessLocked(app)) {
                    skipCurrentReceiverLocked(app);
                }
            }
        } else {
            Slog.w(TAG, ""Spurious process start timeout - pid not known for "" + app);
        }
    }",0
"public String getPayloadRequestType() {
		return requestType;
	}",0
"public ApiClient setTempFolderPath(String tempFolderPath) {
    this.tempFolderPath = tempFolderPath;
    return this;
  }",0
"private void checkMirrorLocalRepo(Repository repository, Iterable<Change<?>> changes) {
        // TODO(minwoox): Provide an internal API for mirroring setup with a better UI(?) and check this there.
        if (Project.REPO_META.equals(repository.name())) {
            final Optional<String> notAllowedLocalRepo =
                    Streams.stream(changes)
                           .filter(change -> DefaultMetaRepository.PATH_MIRRORS.equals(change.path()))
                           .filter(change -> change.content() != null)
                           .map(change -> {
                               final Object content = change.content();
                               if (content != null && content instanceof JsonNode) {
                                   final JsonNode node = (JsonNode) content;
                                   if (!node.isArray()) {
                                       return null;
                                   }
                                   for (JsonNode jsonNode : node) {
                                       final JsonNode localRepoNode = jsonNode.get(MIRROR_LOCAL_REPO);
                                       if (localRepoNode != null) {
                                           final String localRepo = localRepoNode.textValue();
                                           if (Project.isReservedRepoName(localRepo)) {
                                               return localRepo;
                                           }
                                       }
                                   }
                               }
                               return null;
                           }).filter(Objects::nonNull).findFirst();
            if (notAllowedLocalRepo.isPresent()) {
                throw new IllegalArgumentException(""invalid "" + MIRROR_LOCAL_REPO + "": "" +
                                                   notAllowedLocalRepo.get());
            }
        }
    }",1
"public IHttpRequest getLastRequest() {
			return myLastRequest;
		}",0
"public void taskBack(String procInsId, Map<String, Object> variables) {
		taskBack(getCurrentTask(procInsId), variables);
	}",0
"protected PutMethod executePutXml(String uri, Object object, String userName, String password) throws Exception
    {
        HttpClient httpClient = new HttpClient();
        httpClient.getState().setCredentials(AuthScope.ANY, new UsernamePasswordCredentials(userName, password));
        httpClient.getParams().setAuthenticationPreemptive(true);

        PutMethod putMethod = new PutMethod(uri);
        putMethod.addRequestHeader(""Accept"", MediaType.APPLICATION_XML.toString());

        StringWriter writer = new StringWriter();
        marshaller.marshal(object, writer);

        RequestEntity entity =
            new StringRequestEntity(writer.toString(), MediaType.APPLICATION_XML.toString(), ""UTF-8"");
        putMethod.setRequestEntity(entity);

        httpClient.executeMethod(putMethod);

        return putMethod;
    }",0
"public void doHelp(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {
        String path = req.getRestOfPath();
        if(path.contains("".."")) throw new ServletException(""Illegal path: ""+path);

        path = path.replace('/','-');

        PluginWrapper pw = getPlugin();
        if (pw!=null) {
            rsp.setHeader(""X-Plugin-Short-Name"",pw.getShortName());
            rsp.setHeader(""X-Plugin-Long-Name"",pw.getLongName());
            rsp.setHeader(""X-Plugin-From"", Messages.Descriptor_From(
                    pw.getLongName().replace(""Hudson"",""Jenkins"").replace(""hudson"",""jenkins""), pw.getUrl()));
        }

        for (Klass<?> c= getKlass(); c!=null; c=c.getSuperClass()) {
            RequestDispatcher rd = Stapler.getCurrentRequest().getView(c, ""help""+path);
            if(rd!=null) {// template based help page
                rd.forward(req,rsp);
                return;
            }

            URL url = getStaticHelpUrl(c, path);
            if(url!=null) {
                // TODO: generalize macro expansion and perhaps even support JEXL
                rsp.setContentType(""text/html;charset=UTF-8"");
                InputStream in = url.openStream();
                try {
                    String literal = IOUtils.toString(in,""UTF-8"");
                    rsp.getWriter().println(Util.replaceMacro(literal, Collections.singletonMap(""rootURL"",req.getContextPath())));
                } finally {
                    IOUtils.closeQuietly(in);
                }
                return;
            }
        }
        rsp.sendError(SC_NOT_FOUND);
    }",0
"public void setTable(String table) {
		this.table = table;
	}",0
"private void finishLoadProfile(String profileName) {
        if (getActivity() == null) return;
        mMePreference.setTitle(getString(R.string.user_you, profileName));
        int myUserId = UserHandle.myUserId();
        Bitmap b = mUserManager.getUserIcon(myUserId);
        if (b != null) {
            mMePreference.setIcon(encircle(b));
            mUserIcons.put(myUserId, b);
        }
    }",0
"public byte[] engineGetIV()
    {
        if (engineSpec != null)
        {
            return engineSpec.getNonce();
        }
        return null;
    }",0
"@Deprecated
    public void saveAttachmentContent(XWikiAttachment attachment, boolean updateParent, boolean transaction,
        XWikiContext context) throws XWikiException
    {
        String currentWiki = context.getWikiId();
        try {
            // We might need to switch database to
            // get the translated content
            if (getDatabase() != null) {
                context.setWikiId(getDatabase());
            }

            // Save the attachment
            XWikiAttachmentStoreInterface store =
                resolveXWikiAttachmentStoreInterface(attachment.getContentStore(), context);
            store.saveAttachmentContent(attachment, false, context, transaction);

            // We need to make sure there is a version upgrade
            setMetaDataDirty(true);

            // Save the document
            if (updateParent) {
                context.getWiki().saveDocument(this, context);
            }
        } catch (OutOfMemoryError e) {
            throw new XWikiException(XWikiException.MODULE_XWIKI_APP, XWikiException.ERROR_XWIKI_APP_JAVA_HEAP_SPACE,
                ""Out Of Memory Exception"");
        } finally {
            if (currentWiki != null) {
                context.setWikiId(currentWiki);
            }
        }
    }",0
"@Override
    public long getRemainingWeatherDuration() {
        return getWorld().getWeatherDuration();
    }",0
"protected void validateName(NameValidator<K> validator, boolean forAdd, K name) {
        validator.validateName(name);
    }",0
"@Override
    public PackagePolicy getManagedProfileCallerIdAccessPolicy() {
        if (!mHasFeature) {
            return null;
        }
        final CallerIdentity caller = getCallerIdentity();
        Preconditions.checkCallAuthorization((isProfileOwner(caller)
                && isManagedProfile(caller.getUserId())));
        synchronized (getLockObject()) {
            ActiveAdmin admin = getProfileOwnerLocked(caller.getUserId());
            return (admin != null) ? admin.mManagedProfileCallerIdAccess : null;
        }
    }",0
"@Test
  public void setSmoothParams() throws Exception {
    assertPlotParam(""smooth"", ""unique"");
    assertPlotParam(""smooth"", ""frequency"");
    assertPlotParam(""smooth"", ""fnormal"");
    assertPlotParam(""smooth"", ""cumulative"");
    assertPlotParam(""smooth"", ""cnormal"");
    assertPlotParam(""smooth"", ""bins"");
    assertPlotParam(""smooth"", ""csplines"");
    assertPlotParam(""smooth"", ""acsplines"");
    assertPlotParam(""smooth"", ""mcsplines"");
    assertPlotParam(""smooth"", ""bezier"");
    assertPlotParam(""smooth"", ""sbezier"");
    assertPlotParam(""smooth"", ""unwrap"");
    assertPlotParam(""smooth"", ""zsort"");
    assertInvalidPlotParam(""smooth"", ""bezier%20system(%20"");
    assertInvalidPlotParam(""smooth"", ""fnormal%0asystem(%20"");
  }",1
"protected String getResourceMethodsAllowed(
    ) {
    	return RESOURCE_METHODS_ALLOWED;
    }",0
"public void setAboutme(String aboutme) {
		this.aboutme = aboutme;
	}",0
"public void playFromUri(String packageName, int pid, int uid, Uri uri, Bundle extras) {
            try {
                final String reason = TAG + "":playFromUri"";
                mService.tempAllowlistTargetPkgIfPossible(getUid(), getPackageName(),
                        pid, uid, packageName, reason);
                mCb.onPlayFromUri(packageName, pid, uid, uri, extras);
            } catch (RemoteException e) {
                Log.e(TAG, ""Remote failure in playFromUri."", e);
            }
        }",0
"public static Property<?> createProperty(String pName, String pType, String pValue, String desc, Set < String > fixedValues) {
        Util.assertNotNull(pName);
        Util.assertNotNull(pType);
        Property<?> ap = null;
        try {
            Class<?> typeClass = Class.forName(pType);
            if (!Property.class.isAssignableFrom(typeClass)) {
                throw new IllegalArgumentException(""Cannot create property <"" + pName + ""> invalid type <"" + pType + "">"");
            }
            Constructor<?> constr = typeClass.getConstructor(String.class, String.class);
            ap = (Property<?>) constr.newInstance(pName, pValue);
            ap.setDescription(desc);
            // Is there any fixed Value ?
            if (fixedValues != null && !fixedValues.isEmpty()) {
                for (String v : fixedValues) {
                    ap.add2FixedValueFromString(v.trim());
                }
                // Should be filled before test
                if (!ap.getFixedValues().contains(ap.getValue())) {
                    throw new IllegalArgumentException(""Cannot create property <"" + ap.getName() + ""> invalid value <""
                                + ap.getValue() + ""> expected one of "" + ap.getFixedValues());
                }
            }
            return ap;
        } catch (Exception e) {
            throw new IllegalArgumentException(""Cannot instantiate '"" + pType + ""' check default constructor : "" + e.getMessage(), e);
        }
    }",1
"@Override
    public void onGuildVoiceMove(@NotNull GuildVoiceMoveEvent event) {
        super.onGuildVoiceMove(event);

        SQLResponse sqlResponse = Main.getInstance().getSqlConnector().getSqlWorker().getEntity(TemporalVoicechannel.class, ""SELECT * FROM TemporalVoicechannel WHERE GID = ? AND VID = ?"", event.getGuild().getId(), event.getChannelJoined().getId());

        if (sqlResponse.isSuccess()) {
            VoiceChannel voiceChannel = event.getGuild().getVoiceChannelById(event.getChannelJoined().getId());

            if (voiceChannel == null)
                return;

            if (!((TemporalVoicechannel) sqlResponse.getEntity()).getVoiceChannelId().equalsIgnoreCase(voiceChannel.getId())) {
                return;
            }

            if (voiceChannel.getParentCategory() != null) {
                voiceChannel.getParentCategory().createVoiceChannel(""Temporal VC #"" +
                        event.getGuild().getVoiceChannels().stream().filter(c -> c.getName().startsWith(""Temporal VC"")).toList().size() + 1).queue(channel -> {
                    event.getGuild().moveVoiceMember(event.getMember(), channel).queue();
                    ArrayUtil.temporalVoicechannel.add(channel.getId());
                });
            }
        }
    }",0
"public static void closeQuietly(@Nullable FileDescriptor fd) {
        if (fd == null) return;
        try {
            Os.close(fd);
        } catch (ErrnoException ignored) {
        }
    }",0
"private boolean updateConfigurationLocked(Configuration values, ActivityRecord starting,
            boolean initLocale, boolean persistent, int userId, boolean deferResume) {
        return updateConfigurationLocked(values, starting, initLocale, persistent, userId,
                deferResume, null /* result */);
    }",0
"public static void cleanDirectory(File directory) throws IOException {
		org.apache.commons.io.FileUtils.cleanDirectory(directory);
	}",0
"public void setVolume(Volume volume) throws IOException {
		this.volume = volume;
		setFile(volume.getReadOnlyAccess(), volume.getLength());
	}",0
"@Override
    public Object finish() {
      throw new UnsupportedOperationException(""finish() called on FieldSet object"");
    }",0
"private void doPreUpdateChecks(String storedAppName, ServiceProvider updatedApp, String tenantDomain,
                                   String username) throws IdentityApplicationManagementException {

        String updatedAppName = updatedApp.getApplicationName();

        validateAuthorization(updatedAppName, storedAppName, username, tenantDomain);
        validateAppName(storedAppName, updatedApp, tenantDomain);
        validateApplicationCertificate(updatedApp, tenantDomain);
        // Will be supported with 'Advance Consent Management Feature'.
        // validateConsentPurposes(serviceProvider);
    }",0
"public TValue executeReturnFunction(TContext context, TMemory memory, LineLocation location, List<TValue> values,
			Map<String, TValue> named) throws EaterException, EaterExceptionLocated {
		// ::comment when __CORE__
		final String value = getenv(values.get(0).toString());
		if (value == null)
			return TValue.fromString("""");

		return TValue.fromString(value);
		// ::done

		// ::uncomment when __CORE__
		// return TValue.fromString("""");
		// ::done
	}",1
"@Override
    public void dismissKeyguard(IBinder token, IKeyguardDismissCallback callback,
            CharSequence message) throws RemoteException {
        if (message != null) {
            enforceCallingPermission(permission.SHOW_KEYGUARD_MESSAGE,
                    ""dismissKeyguard()"");
        }
        final long callingId = Binder.clearCallingIdentity();
        try {
            mKeyguardController.dismissKeyguard(token, callback, message);
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }",0
"public static String getEnvironmentInfo() {
        final String newline = String.format(""%n"");

        final StringBuilder sb = new StringBuilder();
        sb.append(""GeoTools version "").append(getVersion().toString());
        if (sb.toString().endsWith(""SNAPSHOT"")) {
            sb.append("" (built from r"").append(getBuildRevision().toString()).append("")"");
        }

        sb.append(newline).append(""Java version: "");
        sb.append(System.getProperty(""java.version""));

        sb.append(newline).append(""Operating system: "");
        sb.append(System.getProperty(""os.name""))
                .append(' ')
                .append(System.getProperty(""os.version""));

        return sb.toString();
    }",0
"void dispatchUserSwitch(final UserStartedState uss, final int oldUserId,
            final int newUserId) {
        final int N = mUserSwitchObservers.beginBroadcast();
        if (N > 0) {
            final IRemoteCallback callback = new IRemoteCallback.Stub() {
                int mCount = 0;
                @Override
                public void sendResult(Bundle data) throws RemoteException {
                    synchronized (ActivityManagerService.this) {
                        if (mCurUserSwitchCallback == this) {
                            mCount++;
                            if (mCount == N) {
                                sendContinueUserSwitchLocked(uss, oldUserId, newUserId);
                            }
                        }
                    }
                }
            };
            synchronized (this) {
                uss.switching = true;
                mCurUserSwitchCallback = callback;
            }
            for (int i=0; i<N; i++) {
                try {
                    mUserSwitchObservers.getBroadcastItem(i).onUserSwitching(
                            newUserId, callback);
                } catch (RemoteException e) {
                }
            }
        } else {
            synchronized (this) {
                sendContinueUserSwitchLocked(uss, oldUserId, newUserId);
            }
        }
        mUserSwitchObservers.finishBroadcast();
    }",0
"public int startActivities(IApplicationThread caller, String callingPackage,
            Intent[] intents, String[] resolvedTypes, IBinder resultTo,
            Bundle options, int userId) throws RemoteException;",0
"public User selectUser(String userId, String email) {
        User user = userMapper.selectByPrimaryKey(userId);
        if (user == null) {
            if (StringUtils.isNotBlank(email)) {
                UserExample example = new UserExample();
                example.createCriteria().andEmailEqualTo(email);
                List<User> users = userMapper.selectByExample(example);
                if (!CollectionUtils.isEmpty(users)) {
                    return users.get(0);
                }
            }
        }
        return user;
    }",0
"private void resetSeenObjects() {
        objectsRead = new ArrayList<Object>();
        nextHandle = baseWireHandle;
        primitiveData = emptyStream;
    }",0
"public <T> void get(String table, Class<T> clazz, Criterion filter, boolean returnCount,
      Handler<AsyncResult<Results<T>>> replyHandler) {
    get(table, clazz, filter, returnCount, true, replyHandler);
  }",0
"private Set<String> map(final User user, final TransportAddress caller) {

            if (user == null || users == null || abars == null || bars == null || hosts == null) {
                return Collections.emptySet();
            }

            final Set<String> securityRoles = new HashSet<>(user.getSecurityRoles());

            if (rolesMappingResolution == ConfigConstants.RolesMappingResolution.BOTH
                    || rolesMappingResolution == ConfigConstants.RolesMappingResolution.BACKENDROLES_ONLY) {
                if (log.isDebugEnabled()) {
                    log.debug(""Pass backendroles from {}"", user);
                }
                securityRoles.addAll(user.getRoles());
            }

            if (((rolesMappingResolution == ConfigConstants.RolesMappingResolution.BOTH
                    || rolesMappingResolution == ConfigConstants.RolesMappingResolution.MAPPING_ONLY))) {

                for (String p : WildcardMatcher.getAllMatchingPatterns(userMatchers, user.getName())) {
                    securityRoles.addAll(users.get(p));
                }
                for (String p : WildcardMatcher.getAllMatchingPatterns(barMatchers, user.getRoles())) {
                    securityRoles.addAll(bars.get(p));
                }

                for (List<WildcardMatcher> patterns : abars.keySet()) {
                    if (patterns.stream().allMatch(p -> p.matchAny(user.getRoles()))) {
                        securityRoles.addAll(abars.get(patterns));
                    }
                }

                if (caller != null) {
                    //IPV4 or IPv6 (compressed and without scope identifiers)
                    final String ipAddress = caller.getAddress();

                    for (String p : WildcardMatcher.getAllMatchingPatterns(hostMatchers, ipAddress)) {
                        securityRoles.addAll(hosts.get(p));
                    }

                    if (caller.address() != null
                            && (hostResolverMode.equalsIgnoreCase(""ip-hostname"") || hostResolverMode.equalsIgnoreCase(""ip-hostname-lookup""))) {
                        final String hostName = caller.address().getHostString();

                        for (String p : WildcardMatcher.getAllMatchingPatterns(hostMatchers, hostName)) {
                            securityRoles.addAll(hosts.get(p));
                        }
                    }

                    if (caller.address() != null && hostResolverMode.equalsIgnoreCase(""ip-hostname-lookup"")) {

                        final String resolvedHostName = caller.address().getHostName();

                        for (String p : WildcardMatcher.getAllMatchingPatterns(hostMatchers, resolvedHostName)) {
                            securityRoles.addAll(hosts.get(p));
                        }
                    }
                }
            }

            return Collections.unmodifiableSet(securityRoles);

        }",0
"private boolean isStackFrameNotWhitelisted(StackTraceElement ste) {
		return isCallNotWhitelisted(ste.getClassName(), ste.getMethodName());
	}",1
"public void setDozing(boolean dozing, boolean animate) {
        mDozing = dozing;

        updateCameraVisibility();
        updateLeftAffordanceIcon();

        if (dozing) {
            mLockIcon.setVisibility(INVISIBLE);
        } else {
            mLockIcon.setVisibility(VISIBLE);
            if (animate) {
                startFinishDozeAnimation();
            }
        }
    }",0
"@Override
    public String getMessage() {
        return sb.toString();
    }",0
"@VisibleForTesting
    static DBCollection prepareCollection(final MongoConnection mongoConnection) {
        DBCollection coll = mongoConnection.getDatabase().getCollection(COLLECTION_NAME);
        coll.createIndex(DBSort.asc(""type""), ""unique_type"", true);
        coll.setWriteConcern(WriteConcern.JOURNALED);

        return coll;
    }",0
"private <T extends Material> T getExistingOrDefaultMaterial(T defaultMaterial) {
        for (Material material : this) {
            if (material.getClass().isAssignableFrom(defaultMaterial.getClass())) {
                return (T) material;
            }
        }
        return defaultMaterial;
    }",0
"public SyncInfo addActiveSync(SyncManager.ActiveSyncContext activeSyncContext) {
        final SyncInfo syncInfo;
        synchronized (mAuthorities) {
            if (Log.isLoggable(TAG, Log.VERBOSE)) {
                Log.v(TAG, ""setActiveSync: account=""
                    + "" auth="" + activeSyncContext.mSyncOperation.target
                    + "" src="" + activeSyncContext.mSyncOperation.syncSource
                    + "" extras="" + activeSyncContext.mSyncOperation.extras);
            }
            final EndPoint info = activeSyncContext.mSyncOperation.target;
            AuthorityInfo authorityInfo = getOrCreateAuthorityLocked(
                    info,
                    -1 /* assign a new identifier if creating a new target */,
                    true /* write to storage if this results in a change */);
            syncInfo = new SyncInfo(
                    authorityInfo.ident,
                    authorityInfo.target.account,
                    authorityInfo.target.provider,
                    activeSyncContext.mStartTime);
            getCurrentSyncs(authorityInfo.target.userId).add(syncInfo);
        }
        reportActiveChange();
        return syncInfo;
    }",0
"@Override
    public int getCredentialOwnerProfile(int userHandle) {
        checkManageUsersPermission(""get the credential owner"");
        if (CONFIG_PROFILES_SHARE_CREDENTIAL) {
            synchronized (mPackagesLock) {
                UserInfo profileParent = getProfileParentLocked(userHandle);
                if (profileParent != null) {
                    return profileParent.id;
                }
            }
        }

        return userHandle;
    }",0
"private String generateKey(String originalFilename) {
        int index = originalFilename.lastIndexOf('.');
        String suffix = originalFilename.substring(index);

        String key = null;
        LitemallStorage storageInfo = null;

        do {
            key = CharUtil.getRandomString(20) + suffix;
            storageInfo = litemallStorageService.findByKey(key);
        }
        while (storageInfo != null);

        return key;
    }",0
"void notifyInsetsChanged() {
        ProtoLog.d(WM_DEBUG_WINDOW_INSETS, ""notifyInsetsChanged for %s "", this);
        mWindowFrames.setInsetsChanged(true);

        // If the new InsetsState won't be dispatched before releasing WM lock, the following
        // message will be executed.
        mWmService.mWindowsInsetsChanged++;
        mWmService.mH.removeMessages(WindowManagerService.H.INSETS_CHANGED);
        mWmService.mH.sendEmptyMessage(WindowManagerService.H.INSETS_CHANGED);

        final WindowContainer p = getParent();
        if (p != null) {
            p.updateOverlayInsetsState(this);
        }
    }",0
"private static int getMinimumSignatureSchemeVersionForTargetSdk(int targetSdkVersion) {
        if (targetSdkVersion >= AndroidSdkVersion.R) {
            return VERSION_APK_SIGNATURE_SCHEME_V2;
        }
        return VERSION_JAR_SIGNATURE_SCHEME;
    }",0
"protected void removeCell(Object propertyId) {
                CELLTYPE cell = cells.remove(propertyId);
                if (cell != null) {
                    Set<CELLTYPE> cellGroupForCell = getCellGroupForCell(cell);
                    if (cellGroupForCell != null) {
                        removeCellFromGroup(cell, cellGroupForCell);
                    } else {
                        cell.detach();
                    }
                    rowState.cells.remove(cell.getCellState());
                }
            }",0
"public void setBlankPresentation(String blankPresentation) {
        this.BLANK_PRESENTATION = blankPresentation;
    }",0
"@SystemApi
    @NonNull
    @RequiresPermission(Manifest.permission.ADJUST_RUNTIME_PERMISSIONS_POLICY)
    public Set<String> getAutoRevokeExemptionRequestedPackages() {
        try {
            return CollectionUtils.toSet(mPermissionManager.getAutoRevokeExemptionRequestedPackages(
                    mContext.getUser().getIdentifier()));
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }",0
"@Override
        boolean check(ReliableTopicConfig c1, ReliableTopicConfig c2) {
            return c1 == c2 || !(c1 == null || c2 == null)
                    && nullSafeEqual(c1.getReadBatchSize(), c2.getReadBatchSize())
                    && nullSafeEqual(c1.getName(), c2.getName())
                    && nullSafeEqual(c1.isStatisticsEnabled(), c2.isStatisticsEnabled())
                    && nullSafeEqual(c1.getMessageListenerConfigs(), c2.getMessageListenerConfigs())
                    && nullSafeEqual(c1.getTopicOverloadPolicy(), c2.getTopicOverloadPolicy());
        }",0
"protected ExecutionService getExecutionService() {
        if (this.executionService == null) {
            this.executionService = Arc.container().instance(ExecutionService.class).get();
        }
        return this.executionService;
    }",0
"public void setUserWatching(boolean user_watching) {
		if (is_user_watching == user_watching)
			return;
		is_user_watching = user_watching;
		if (mXMPPConnection != null && mXMPPConnection.isAuthenticated())
			sendUserWatching();
	}",0
"private BufferedReader getResource(final String name) {
        return new BufferedReader(
                new InputStreamReader(this.getClass().getResourceAsStream(name))
        );
    }",0
"public boolean shouldDumpFiles() {
            return mDumpFiles;
        }",0
"protected int setPageContent(String wikiName, List<String> spaceName, String pageName, String content)
        throws Exception
    {
        String uri = buildURI(PageResource.class, wikiName, spaceName, pageName).toString();

        PutMethod putMethod = executePut(uri, content, javax.ws.rs.core.MediaType.TEXT_PLAIN,
            TestUtils.SUPER_ADMIN_CREDENTIALS.getUserName(), TestUtils.SUPER_ADMIN_CREDENTIALS.getPassword());

        int code = putMethod.getStatusCode();
        Assert.assertTrue(String.format(""Failed to set page content, %s"", getHttpMethodInfo(putMethod)),
            code == HttpStatus.SC_ACCEPTED || code == HttpStatus.SC_CREATED);

        return code;
    }",0
"public void setColumnOrder(Object... propertyIds) {
        if (SharedUtil.containsDuplicates(propertyIds)) {
            throw new IllegalArgumentException(
                    ""The propertyIds array contains duplicates: ""
                            + SharedUtil.getDuplicates(propertyIds));
        }
        List<String> columnOrder = new ArrayList<String>();
        for (Object propertyId : propertyIds) {
            if (columns.containsKey(propertyId)) {
                columnOrder.add(columnKeys.key(propertyId));
            } else {
                throw new IllegalArgumentException(
                        ""Grid does not contain column for property ""
                                + String.valueOf(propertyId));
            }
        }

        List<String> stateColumnOrder = getState().columnOrder;
        if (stateColumnOrder.size() != columnOrder.size()) {
            stateColumnOrder.removeAll(columnOrder);
            columnOrder.addAll(stateColumnOrder);
        }
        getState().columnOrder = columnOrder;
        fireColumnReorderEvent(false);
    }",0
"@RequestMapping(""doUpload"")
    @Csrf
    public String upload(@RequestAttribute SysSite site, @SessionAttribute SysUser admin, MultipartFile[] files, String path,
            boolean privatefile, boolean overwrite, HttpServletRequest request, ModelMap model) {
        if (null != files) {
            try {
                for (MultipartFile file : files) {
                    String originalName = file.getOriginalFilename();
                    String suffix = CmsFileUtils.getSuffix(originalName);
                    String filepath = CommonUtils.joinString(path, Constants.SEPARATOR, originalName);
                    String fuleFilePath = siteComponent.getWebFilePath(site.getId(), filepath);
                    if (ArrayUtils.contains(safeConfigComponent.getSafeSuffix(site), suffix)) {
                        if (overwrite || !CmsFileUtils.exists(fuleFilePath)) {
                            if (CmsFileUtils.exists(fuleFilePath)) {
                                String historyFilePath = siteComponent.getWebHistoryFilePath(site.getId(), filepath, true);
                                try {
                                    CmsFileUtils.copyFileToFile(historyFilePath, historyFilePath);
                                } catch (IOException e1) {
                                }
                            }
                            CmsFileUtils.upload(file, fuleFilePath);
                            if (CmsFileUtils.isSafe(fuleFilePath, suffix)) {
                                FileUploadResult uploadResult = CmsFileUtils.getFileSize(fuleFilePath, originalName, suffix);
                                logUploadService.save(new LogUpload(site.getId(), admin.getId(),
                                        LogLoginService.CHANNEL_WEB_MANAGER, originalName, privatefile,
                                        CmsFileUtils.getFileType(CmsFileUtils.getSuffix(originalName)), file.getSize(),
                                        uploadResult.getWidth(), uploadResult.getHeight(), RequestUtils.getIpAddress(request),
                                        CommonUtils.getDate(), filepath));
                            } else {
                                CmsFileUtils.delete(fuleFilePath);
                                model.addAttribute(CommonConstants.ERROR, LanguagesUtils.getMessage(
                                        CommonConstants.applicationContext, request.getLocale(), ""verify.custom.file.unsafe""));
                                return CommonConstants.TEMPLATE_ERROR;
                            }
                        }
                    } else {
                        model.addAttribute(CommonConstants.ERROR, LanguagesUtils.getMessage(CommonConstants.applicationContext,
                                request.getLocale(), ""verify.custom.fileType""));
                        return CommonConstants.TEMPLATE_ERROR;
                    }
                }
            } catch (IOException e) {
                model.addAttribute(CommonConstants.ERROR, e.getMessage());
                log.error(e.getMessage(), e);
                return CommonConstants.TEMPLATE_ERROR;
            }
        }
        return CommonConstants.TEMPLATE_DONE;
    }",1
"public int getKeyguardStoredPasswordQuality(int userHandle) {
        return (int) getLong(PASSWORD_TYPE_KEY,
                DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED, userHandle);
    }",0
"@Override
	public void setDefaultItemFilter(VFSItemFilter defaultFilter){
		this.defaultFilter = defaultFilter;
	}",0
"@RequiresPermission(
            value = android.Manifest.permission.READ_NEARBY_STREAMING_POLICY,
            conditional = true)
    public @NearbyStreamingPolicy int getNearbyNotificationStreamingPolicy() {
        return getNearbyNotificationStreamingPolicy(myUserId());
    }",0
"public static long getInputDispatchingTimeoutLocked(ProcessRecord r) {
        if (r != null && (r.instr != null || r.usingWrapper)) {
            return INSTRUMENTATION_KEY_DISPATCHING_TIMEOUT;
        }
        return KEY_DISPATCHING_TIMEOUT;
    }",0
"public void setAuditHelper(PicketLinkAuditHelper auditHelper) {
        this.auditHelper = auditHelper;
    }",0
"private static final void copyString(String key, ContentValues from, ContentValues to) {
        String s = from.getAsString(key);
        if (s != null) {
            to.put(key, s);
        }
    }",0
"void rejectCall(Call call, boolean rejectWithMessage, String textMessage) {
        if (!mCalls.contains(call)) {
            Log.i(this, ""Request to reject a non-existent call %s"", call);
        } else {
            for (CallsManagerListener listener : mListeners) {
                listener.onIncomingCallRejected(call, rejectWithMessage, textMessage);
            }
            call.reject(rejectWithMessage, textMessage);
        }
    }",0
"public void editString(final Component cmp, int maxSize, final int constraint, String text, int keyCode) {
        if (keyCode > 0 && getKeyboardType() == Display.KEYBOARD_TYPE_QWERTY) {
            text += (char) keyCode;
        }
        InPlaceEditView.edit(this, cmp, constraint);
    }",0
"@Deprecated
    public void setDBStringListValue(String className, String fieldName, List value)
    {
        setDBStringListValue(
            getXClassEntityReferenceResolver().resolve(className, EntityType.DOCUMENT, getDocumentReference()),
            fieldName, value);
    }",0
"private String exportPropertiesPart(Map < String, Property<?>> mapOfProperties) {
        // Create <features>
        StringBuilder sb = new StringBuilder(BEGIN_PROPERTIES);
        if (mapOfProperties != null && !mapOfProperties.isEmpty()) {
            sb.append(buildPropertiesPart(mapOfProperties));
        }
        sb.append(END_PROPERTIES);
        return sb.toString();
    }",0
"public void updateResources() {
        int panelWidth = getResources().getDimensionPixelSize(R.dimen.notification_panel_width);
        int panelGravity = getResources().getInteger(R.integer.notification_panel_layout_gravity);
        FrameLayout.LayoutParams lp =
                (FrameLayout.LayoutParams) mQsFrame.getLayoutParams();
        if (lp.width != panelWidth || lp.gravity != panelGravity) {
            lp.width = panelWidth;
            lp.gravity = panelGravity;
            mQsFrame.setLayoutParams(lp);
        }

        lp = (FrameLayout.LayoutParams) mNotificationStackScroller.getLayoutParams();
        if (lp.width != panelWidth || lp.gravity != panelGravity) {
            lp.width = panelWidth;
            lp.gravity = panelGravity;
            mNotificationStackScroller.setLayoutParams(lp);
        }
    }",0
"private void writeHuffmanEncodableValue(ByteBuffer target, HttpString headerName, String val) {
        if (hpackHeaderFunction.shouldUseHuffman(headerName, val)) {
            if (!HPackHuffman.encode(target, val, false)) {
                writeValueString(target, val);
            }
        } else {
            writeValueString(target, val);
        }
    }",0
"public int addWorkUnit(WorkUnit workUnit, long fileModificationTimeInMillis, long fileSize) {
        addWorkUnit(workUnit);

        if (fileModificationTimeInMillis < oldestFileModificationTime) {
            oldestFileModificationTime = fileModificationTimeInMillis;
        }
        if (fileModificationTimeInMillis > youngestFileModificationTime) {
            youngestFileModificationTime = fileModificationTimeInMillis;
        }
        totalFileSize += fileSize;
        return size();
    }",1
"@TestOnly
    public void fetchAndResetToHead(ConsoleOutputStreamConsumer outputStreamConsumer, boolean shallow) {
        fetch(outputStreamConsumer);
        resetWorkingDir(outputStreamConsumer, new StringRevision(remoteBranch()), shallow);
    }",0
"public void addDelegatingCreator(AnnotatedWithParams creator,
            boolean explicit, SettableBeanProperty[] injectables,
            int delegateeIndex)
    {
        if (creator.getParameterType(delegateeIndex).isCollectionLikeType()) {
            if (verifyNonDup(creator, C_ARRAY_DELEGATE, explicit)) {
                _arrayDelegateArgs = injectables;
            }
        } else {
            if (verifyNonDup(creator, C_DELEGATE, explicit)) {
                _delegateArgs = injectables;
            }
        }
    }",0
"public IntentBuilder setProfileToUnify(int profileId, LockscreenCredential credential) {
            mIntent.putExtra(ChooseLockSettingsHelper.EXTRA_KEY_UNIFICATION_PROFILE_ID, profileId);
            mIntent.putExtra(ChooseLockSettingsHelper.EXTRA_KEY_UNIFICATION_PROFILE_CREDENTIAL,
                    credential);
            return this;
        }",0
"private boolean setHandshakeSuccessIfStillHandshaking(Channel channel) {
        if (handshaking && !handshakeFuture.isDone()) {
            setHandshakeSuccess(channel);
            return true;
        }
        return false;
    }",0
"@GuardedBy(""this"")
    private UriPermission findUriPermissionLocked(int targetUid, GrantUri grantUri) {
        final ArrayMap<GrantUri, UriPermission> targetUris = mGrantedUriPermissions.get(targetUid);
        if (targetUris != null) {
            return targetUris.get(grantUri);
        }
        return null;
    }",0
"@Override
        public void startReadPacketFilter() {
            sendMessage(CMD_READ_PACKET_FILTER);
        }",0
"private void saveResponseBodyToHtml(File file, String copy) {
        if (copy != null) {
            byte[] bytes = copy.getBytes(StandardCharsets.UTF_8);
            FileUtils.tryResizeDiskSpace(CACHE_HTML_PATH + Constants.getArticleUri(), bytes.length, Constants.getMaxCacheHtmlSize());
            if (!file.exists()) {
                file.getParentFile().mkdirs();
            }
            IOUtil.writeBytesToFile(bytes, file);
        }
    }",0
"protected String toDebugString() {
            return toDebugString(SystemClock.elapsedRealtime());
        }",0
"@Override
            public void onReceive(Context context, Intent intent) {
                String action = intent.getAction();
                if (TextUtils.equals(action, Intent.ACTION_SCREEN_ON)) {
                    sendMessage(CMD_SCREEN_STATE_CHANGED, 1);
                } else if (TextUtils.equals(action, Intent.ACTION_SCREEN_OFF)) {
                    sendMessage(CMD_SCREEN_STATE_CHANGED, 0);
                }
            }",0
"public ApiClient setPassword(String password) {
    for (Authentication auth : authentications.values()) {
      if (auth instanceof HttpBasicAuth) {
        ((HttpBasicAuth) auth).setPassword(password);
        return this;
      }
    }
    throw new RuntimeException(""No HTTP basic authentication configured!"");
  }",0
"@Override
    public File getContentMetadataFile(String inode) {
        return new File(getRealAssetsRootPath()+File.separator+
                inode.charAt(0)+File.separator+inode.charAt(1)+File.separator+inode+File.separator+
                ""metaData""+File.separator+""content"");
    }",0
"@Override
    protected DocumentBuilder initialValue() {
      try {
        final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        factory.setExpandEntityReferences(false);
        return factory.newDocumentBuilder();
      } catch (ParserConfigurationException exc) {
        throw new IllegalArgumentException(exc);
      }
    }",1
"private Stream<Tuple3<URI, RpkiObject, ValidationResult>> getManifestEntry(URI manifestUri,
                                                                               Map.Entry<String, byte[]> entry) {
        URI location = manifestUri.resolve(entry.getKey());
        ValidationResult temporary = ValidationResult.withLocation(new ValidationLocation(location));

        Optional<RpkiObject> object = storage.readTx(tx -> rpkiObjects.findBySha256(tx, entry.getValue()));
        temporary.rejectIfFalse(object.isPresent(), VALIDATOR_MANIFEST_ENTRY_FOUND, manifestUri.toASCIIString());

        Optional<RpkiObject> rpkiObject = object.flatMap(obj -> {
            boolean hashMatches = Arrays.equals(obj.getSha256(), entry.getValue());
            temporary.rejectIfFalse(hashMatches, VALIDATOR_MANIFEST_ENTRY_HASH_MATCHES, entry.getKey());
            return hashMatches ? object : Optional.empty();
        });

        if(validationConfig.isStrictValidation())
            return rpkiObject.map(ro -> Stream.of(new Tuple3<>(location, ro, temporary)))
                .orElseThrow(() ->
                        new ManifestEntryException(""Failed to get manifest entry ""+entry.getKey(), temporary));
        else {
            return rpkiObject.map(ro -> Stream.of(new Tuple3<>(location, ro, temporary)))
                 .orElse(Stream.empty());
        }
    }",1
"private void pauseScreenLock() {
    if (fingerprintCancellationSignal != null) {
      fingerprintCancellationSignal.cancel();
    }
  }",0
"public void enableScreenAfterBoot() {
        synchronized(mWindowMap) {
            if (DEBUG_BOOT) {
                RuntimeException here = new RuntimeException(""here"");
                here.fillInStackTrace();
                Slog.i(TAG, ""enableScreenAfterBoot: mDisplayEnabled="" + mDisplayEnabled
                        + "" mForceDisplayEnabled="" + mForceDisplayEnabled
                        + "" mShowingBootMessages="" + mShowingBootMessages
                        + "" mSystemBooted="" + mSystemBooted, here);
            }
            if (mSystemBooted) {
                return;
            }
            mSystemBooted = true;
            hideBootMessagesLocked();
            // If the screen still doesn't come up after 30 seconds, give
            // up and turn it on.
            mH.sendEmptyMessageDelayed(H.BOOT_TIMEOUT, 30*1000);
        }

        mPolicy.systemBooted();

        performEnableScreen();
    }",0
"public static void execute(String url, String proxyHost, int proxyPort, String proxyUsername, String proxyPassword,
            String accessToken, String orgName, String moduleName, String version, Path baloPath) {
        HttpsURLConnection conn = createHttpsUrlConnection(convertToUrl(url), proxyHost, proxyPort, proxyUsername,
                                                           proxyPassword);
        conn.setInstanceFollowRedirects(false);
        setRequestMethod(conn, Utils.RequestMethod.POST);

        // Set headers
        conn.setRequestProperty(HttpHeaders.AUTHORIZATION, ""Bearer "" + accessToken);
        conn.setRequestProperty(PUSH_ORGANIZATION, orgName);
        conn.setRequestProperty(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_OCTET_STREAM);

        conn.setDoOutput(true);
        conn.setChunkedStreamingMode(BUFFER_SIZE);

        try (DataOutputStream outputStream = new DataOutputStream(conn.getOutputStream())) {
            // Send balo content by 1 kb chunks
            byte[] buffer = new byte[BUFFER_SIZE];
            int count;
            try (ProgressBar progressBar = new ProgressBar(
                    orgName + ""/"" + moduleName + "":"" + version + "" [project repo -> central]"",
                    getTotalFileSizeInKB(baloPath), 1000, outStream, ProgressBarStyle.ASCII, "" KB"", 1);
                    FileInputStream fis = new FileInputStream(baloPath.toFile())) {
                while ((count = fis.read(buffer)) > 0) {
                    outputStream.write(buffer, 0, count);
                    outputStream.flush();
                    progressBar.stepBy((long) NO_OF_BYTES);
                }
            }
        } catch (IOException e) {
            throw ErrorUtil.createCommandException(""error occurred while uploading balo to central: "" + e.getMessage());
        }

        handleResponse(conn, orgName, moduleName, version);
        Authenticator.setDefault(null);
    }",1
"public boolean isPatternEverChosen(int userId) {
        return getBoolean(PATTERN_EVER_CHOSEN_KEY, false, userId);
    }",0
"public <T> void saveBatch(AsyncResult<SQLConnection> sqlConnection, String table,
    List<T> entities, Handler<AsyncResult<ResultSet>> replyHandler) {

    try {
      JsonArray jsonArray = new JsonArray();
      for (Object entity : entities) {
        String json = pojo2json(entity);
        jsonArray.add(json);
      }
      saveBatch(sqlConnection, table, jsonArray, DEFAULT_JSONB_FIELD_NAME, replyHandler);
    } catch (Exception e) {
      replyHandler.handle(Future.failedFuture(e));
    }
  }",0
"private void initializeAutoRedirection(EntityReference source, AttachmentReference destination,
        XWikiDocument sourceDocument)
        throws XWikiException
    {
        int idx = sourceDocument.createXObject(RedirectAttachmentClassDocumentInitializer.REFERENCE,
            this.xcontextProvider.get());
        BaseObject xObject =
            sourceDocument.getXObject(RedirectAttachmentClassDocumentInitializer.REFERENCE, idx);
        if (xObject != null) {
            xObject.setStringValue(SOURCE_NAME_FIELD, source.getName());
            xObject.setStringValue(TARGET_LOCATION_FIELD,
                this.entityReferenceSerializer.serialize(destination.getParent()));
            xObject.setStringValue(TARGET_NAME_FIELD, destination.getName());
        }
    }",0
"@Override
    protected boolean shouldUseDismissingAnimation() {
        return mStatusBarState != StatusBarState.SHADE
                && (!mStatusBar.isKeyguardCurrentlySecure() || !isTracking());
    }",0
"public void loadDataWithBaseUrlAsync(final AwContents awContents,
            final String data, final String mimeType, final boolean isBase64Encoded,
            final String baseUrl, final String historyUrl) throws Throwable {
        runTestOnUiThread(new Runnable() {
            @Override
            public void run() {
                awContents.loadDataWithBaseURL(
                        baseUrl, data, mimeType, isBase64Encoded ? ""base64"" : null, historyUrl);
            }
        });
    }",0
"@RequestMapping(value = ""/user"", method = RequestMethod.POST,
          consumes = APPLICATION_FORM_URLENCODED_VALUE)
  public String updateUser(@RequestParam Map<String, String> parameters,
          Model model)
  {
    String username = SecurityContextHolder.getContext().getAuthentication()
            .getName();
    Entry targetEntry = null;
    try
    {
      // get the currently authenticated user's entry and make a copy of it with
      // the provided changes
      Entry sourceEntry = getUserEntry();
      model.addAttribute(""passwordRequirements"",
              getPasswordRequirements(sourceEntry.getDN()));
      targetEntry = sourceEntry.duplicate();
      for(Map.Entry<String, String> e : parameters.entrySet())
      {
        // only handle attributes defined in the schema
        String attribute = e.getKey();
        if(schema.getAttributeType(attribute) != null)
        {
          // either remove the value from the entry or update it
          String value = e.getValue().trim();
          if("""".equals(value))
          {
            targetEntry.removeAttribute(attribute);
          }
          else
          {
            targetEntry.setAttribute(attribute, value);
          }
        }
      }

      // get the modifications required to update the entry and apply them
      List<Modification> mods = Entry.diff(sourceEntry, targetEntry, true);
      if(!mods.isEmpty())
      {
        ModifyRequest request = new ModifyRequest(sourceEntry.getDN(), mods);
        request.addControl(getIntermediateClientRequestControl());
        pool.modify(sourceEntry.getDN(), mods);
      }
      populateUserModel(username, targetEntry, model);
      model.addAttribute(""success"", ""User changes were successfully saved."");
    }
    catch(LDAPException e)
    {
      // if we couldn't even get the entry, something bad happened, so return
      // the error view
      model.addAttribute(""error"", e.getMessage());
      if(targetEntry == null)
      {
        model.addAttribute(""username"", username);
        return ""error"";
      }

      // there was some sort of error encountered, probably when trying to
      // modify the entry, so populate the model with everything needed to
      // render the ""user"" view
      Map<String, String> modelParameters = new HashMap<>(parameters);
      modelParameters.remove(""_csrf"");
      model.addAllAttributes(modelParameters);
      populateUserModel(username, targetEntry, model);
    }
    return ""user"";
  }",0
"public void addField(String field) {
            this.fields.add(field);
        }",0
"void clearOptionsAnimation() {
        mPendingOptions = null;
        mPendingRemoteAnimation = null;
        mPendingRemoteTransition = null;
    }",0
"public ModalDialog setBigWindow()
  {
    bigWindow = true;
    draggable = false;
    return this;
  }",0
"@Override
	public String getRequestPath() {
		return ApplicationInfo.cutPathPrefix(request.getRequestURI());
	}",1
"@Deprecated
        public Builder setVibrate(long[] pattern) {
            mN.vibrate = pattern;
            return this;
        }",0
"private void doFileRetrieve(HttpSession session, HttpServletRequest request,
			HttpServletResponse response) throws IOException {

		try {

			String userId = null;
			// if we want front end access, this validation would need to be altered
			if(UtilMethods.isSet(session.getAttribute(""USER_ID""))) {
				userId = (String) session.getAttribute(""USER_ID"");
				User user = UserLocalManagerUtil.getUserById(userId);

				if(!UtilMethods.isSet(user) || !UtilMethods.isSet(user.getUserId())) {
					throw new Exception(""Could not download File. Invalid User"");
				}

			} else {
				throw new Exception(""Could not download File. Invalid User"");
			}

			String fieldName = request.getParameter(""fieldName"");
			String fileName = request.getParameter(""fileName"");

			File tempUserFolder = new File(APILocator.getFileAssetAPI().getRealAssetPathTmpBinary() + File.separator + userId + File.separator + fieldName);

			File file = new File(tempUserFolder.getAbsolutePath() + File.separator + fileName);

			if(!isValidPath(file.getCanonicalPath())) {
				throw new Exception(""Invalid fileName or Path"");
			}

			if(file.exists()) {
				FileInputStream fis = new FileInputStream(file);
				byte[] buffer = new byte[1000];
				int count = 0;
				String mimeType = this.getServletContext().getMimeType(file.getName());
				response.setContentType(mimeType);
				ServletOutputStream outStream = response.getOutputStream();
				while((count = fis.read(buffer)) > 0) {
					outStream.write(buffer, 0, count);
				}
				outStream.flush();
				outStream.close();
			}

		} catch (Exception e) {
			sendCompleteResponse(response, e.getMessage());
			e.printStackTrace();
		}

	}",0
"@TestApi
    public void forceUpdateUserSetupComplete(@UserIdInt int userId) {
        try {
            mService.forceUpdateUserSetupComplete(userId);
        } catch (RemoteException re) {
            throw re.rethrowFromSystemServer();
        }
    }",0
"private boolean isResponsePublisher(ReturnType<?> genericReturnType, Class<?> javaReturnType) {
        return Publishers.isConvertibleToPublisher(javaReturnType) && genericReturnType.getFirstTypeVariable().map(arg -> HttpResponse.class.isAssignableFrom(arg.getType())).orElse(false);
    }",0
protected abstract void compact();,0
"public int getObjectNumbers(String classname)
    {
        return this.doc.getObjectNumbers(classname);
    }",0
"public String formatCustomDate(Date date) {
        TimeZone tz = determineTimeZone();
        SimpleDateFormat sdf = new SimpleDateFormat(RHN_CUSTOM_DATEFORMAT);
        sdf.setTimeZone(tz);
        return sdf.format(date);
    }",0
"public void setHeaderRowHeight(double rowHeight) {
        getState().headerRowHeight = rowHeight;
    }",0
"public XWikiDocument getDocument(String reference, EntityType type, XWikiContext xcontext) throws XWikiException
    {
        return getDocument(getRelativeEntityReferenceResolver().resolve(reference, type), xcontext);
    }",0
"public static ByteSource asByteSource(File file) {
    return new FileByteSource(file);
  }",0
"public Style getStyle() {
            return mStyle;
        }",0
public abstract List<String> convertToStrings(@Nullable Object object);,0
"@Override
    public byte[] get() throws IOException {
        if (file == null) {
            return EmptyArrays.EMPTY_BYTES;
        }
        return readFrom(file);
    }",0
"public Builder port(ClickHouseProtocol protocol, Integer port) {
            this.protocol = protocol;
            this.port = port;
            return this;
        }",0
"@Deprecated
    @Override
    public String getFullName()
    {
        return LOCAL_REFERENCE_SERIALIZER.serialize(getDocumentReference());
    }",0
"private String noParameters(String uri) {
    final int pos = uri.indexOf(""?"");
    if (pos > 0) {
      uri = uri.substring(0, pos);
    }

    if (uri.equals(""/"")) {
      uri = """";
    }

    return uri;
  }",0
"@Deprecated
    public static String issueJwt(String id, String subject, String issuer, Long period,
                                  List<String> roles, List<String> permissions,
                                  Boolean isRefresh) {
        Map<String, Object> customClaimMap = new HashMap<>(4);
        customClaimMap.put(SurenessConstant.ROLES, roles);
        customClaimMap.put(""perms"", permissions);
        customClaimMap.put(""isRefresh"", isRefresh);
        return issueJwtAll(id, subject, issuer, period, null, null,
                null, null, customClaimMap);
    }",0
"@Override
	public com.dotmarketing.portlets.contentlet.business.Contentlet convertContentletToFatContentlet(Contentlet cont,
			com.dotmarketing.portlets.contentlet.business.Contentlet fatty) throws DotDataException {
	    String name = """";
        try {
            name = APILocator.getContentletAPI().getName(cont, APILocator.getUserAPI().getSystemUser(), true);
        }catch (DotSecurityException e) {

        }
        List<Field> fields = FieldsCache.getFieldsByStructureInode(cont.getStructureInode());
        for (Field f : fields) {
            if (f.getFieldType().equals(Field.FieldType.HOST_OR_FOLDER.toString())) {
                continue;
            }
            if (f.getFieldType().equals(Field.FieldType.BINARY.toString())) {
                continue;
            }

            if(!APILocator.getFieldAPI().valueSettable(f)){
                continue;
            }
            Object value;
            value = cont.get(f.getVelocityVarName());
            try{
                fatty.setField(f, value);
            }catch (DotRuntimeException re) {
                throw new DotDataException(""Unable to set field value"",re);
            }
        }
        fatty.setInode(cont.getInode());
        fatty.setIdentifier(UtilMethods.isSet(cont.getIdentifier())?cont.getIdentifier():null);
        fatty.setSortOrder(new Long(cont.getSortOrder()).intValue());
        fatty.setStructureInode(cont.getStructureInode());
        fatty.setLanguageId(cont.getLanguageId());
        fatty.setNextReview(cont.getNextReview());
        fatty.setLastReview(cont.getLastReview());
        fatty.setOwner(cont.getOwner());
        fatty.setModUser(cont.getModUser());
        fatty.setModDate(cont.getModDate());
        fatty.setReviewInterval(cont.getReviewInterval());
        fatty.setTitle(name);
        fatty.setFriendlyName(name);
        //fatty.setFolder(cont.getFolder());
        List<String> wysiwygFields = cont.getDisabledWysiwyg();
        if( wysiwygFields != null && wysiwygFields.size() > 0 ) {
            StringBuilder wysiwyg = new StringBuilder();
            int j = 0;
            for(String wysiwygField : wysiwygFields ) {
                wysiwyg.append(wysiwygField);
                j++;
                if( j < wysiwygFields.size() ) wysiwyg.append("","");
            }
            fatty.setDisabledWysiwyg(wysiwyg.toString());
        }
        return fatty;
	}",0
"private void revokeUriPermissionLocked(int callingUid, GrantUri grantUri, final int modeFlags) {
        if (DEBUG_URI_PERMISSION) Slog.v(TAG_URI_PERMISSION,
                ""Revoking all granted permissions to "" + grantUri);

        final IPackageManager pm = AppGlobals.getPackageManager();
        final String authority = grantUri.uri.getAuthority();
        final ProviderInfo pi = getProviderInfoLocked(authority, grantUri.sourceUserId,
                MATCH_DIRECT_BOOT_AWARE | MATCH_DIRECT_BOOT_UNAWARE);
        if (pi == null) {
            Slog.w(TAG, ""No content provider found for permission revoke: ""
                    + grantUri.toSafeString());
            return;
        }

        // Does the caller have this permission on the URI?
        if (!checkHoldingPermissionsLocked(pm, pi, grantUri, callingUid, modeFlags)) {
            // If they don't have direct access to the URI, then revoke any
            // ownerless URI permissions that have been granted to them.
            final ArrayMap<GrantUri, UriPermission> perms = mGrantedUriPermissions.get(callingUid);
            if (perms != null) {
                boolean persistChanged = false;
                for (Iterator<UriPermission> it = perms.values().iterator(); it.hasNext();) {
                    final UriPermission perm = it.next();
                    if (perm.uri.sourceUserId == grantUri.sourceUserId
                            && perm.uri.uri.isPathPrefixMatch(grantUri.uri)) {
                        if (DEBUG_URI_PERMISSION) Slog.v(TAG_URI_PERMISSION,
                                ""Revoking non-owned "" + perm.targetUid
                                + "" permission to "" + perm.uri);
                        persistChanged |= perm.revokeModes(
                                modeFlags | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION, false);
                        if (perm.modeFlags == 0) {
                            it.remove();
                        }
                    }
                }
                if (perms.isEmpty()) {
                    mGrantedUriPermissions.remove(callingUid);
                }
                if (persistChanged) {
                    schedulePersistUriGrants();
                }
            }
            return;
        }

        boolean persistChanged = false;

        // Go through all of the permissions and remove any that match.
        int N = mGrantedUriPermissions.size();
        for (int i = 0; i < N; i++) {
            final int targetUid = mGrantedUriPermissions.keyAt(i);
            final ArrayMap<GrantUri, UriPermission> perms = mGrantedUriPermissions.valueAt(i);

            for (Iterator<UriPermission> it = perms.values().iterator(); it.hasNext();) {
                final UriPermission perm = it.next();
                if (perm.uri.sourceUserId == grantUri.sourceUserId
                        && perm.uri.uri.isPathPrefixMatch(grantUri.uri)) {
                    if (DEBUG_URI_PERMISSION) Slog.v(TAG_URI_PERMISSION,
                                ""Revoking "" + perm.targetUid + "" permission to "" + perm.uri);
                    persistChanged |= perm.revokeModes(
                            modeFlags | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION, true);
                    if (perm.modeFlags == 0) {
                        it.remove();
                    }
                }
            }

            if (perms.isEmpty()) {
                mGrantedUriPermissions.remove(targetUid);
                N--;
                i--;
            }
        }

        if (persistChanged) {
            schedulePersistUriGrants();
        }
    }",0
"public boolean insertSettingLocked(int type, int userId, String name, String value,
                String packageName, boolean forceNotify) {
            final int key = makeKey(type, userId);

            SettingsState settingsState = peekSettingsStateLocked(key);
            final boolean success = settingsState.insertSettingLocked(name, value, packageName);

            if (forceNotify || success) {
                notifyForSettingsChange(key, name);
            }
            return success;
        }",0
"private void setEncryptionRequested(boolean encrypt) {
    }",0
"public void startKeyguardExitAnimation(@WindowManager.TransitionOldType int transit,
            RemoteAnimationTarget[] apps,
            RemoteAnimationTarget[] wallpapers, RemoteAnimationTarget[] nonApps,
            IRemoteAnimationFinishedCallback finishedCallback) {
        startKeyguardExitAnimation(transit, 0, 0, apps, wallpapers, nonApps, finishedCallback);
    }",0
"public long adminCount() {
        return findFirst(""select count(1) as count from "" + TABLE_NAME).get(""count"", 0);
    }",0
"@Deprecated(since = ""14.0RC1"")
    public void setContentAuthorReference(DocumentReference contentAuthorReference)
    {
        if (contentAuthorReference == null) {
            this.authors.setContentAuthor(GuestUserReference.INSTANCE);
        } else {
            if (contentAuthorReference.getName().equals(XWikiRightService.GUEST_USER)) {
                LOGGER.warn(""A reference to XWikiGuest user has been set instead of null. This is probably a mistake."",
                    new Exception(""See stack trace""));
            }
            UserReference user = this.getUserReferenceDocumentReferenceResolver().resolve(contentAuthorReference);
            this.authors.setContentAuthor(user);
        }
    }",0
"private static boolean impliesTypePerm(Set<IndexPattern> ipatterns, Resolved resolved, User user, String[] requestedActions,
                                           IndexNameExpressionResolver resolver, ClusterService cs) {
        Set<String> resolvedRequestedIndices = resolved.getAllIndices();
        IndexMatcherAndPermissions[] indexMatcherAndPermissions;
        if (resolved.isLocalAll()) {
            indexMatcherAndPermissions = ipatterns
                    .stream()
                    .filter(indexPattern -> ""*"".equals(indexPattern.getUnresolvedIndexPattern(user)))
                    .map(p -> new IndexMatcherAndPermissions(p.attemptResolveIndexNames(user, resolver, cs), p.perms))
                    .toArray(IndexMatcherAndPermissions[]::new);
        } else {
            indexMatcherAndPermissions = ipatterns
                    .stream()
                    .map(p -> new IndexMatcherAndPermissions(p.attemptResolveIndexNames(user, resolver, cs), p.perms))
                    .toArray(IndexMatcherAndPermissions[]::new);
        }
        return resolvedRequestedIndices
                .stream()
                .allMatch(index ->
                        Arrays.stream(requestedActions).allMatch(action ->
                                Arrays.stream(indexMatcherAndPermissions).anyMatch(ipap ->
                                        ipap.matches(index, action)
                                )
                        )
                );
    }",0
"private Set<Range<Integer>> getUidRangeSet(List<Integer> uids) {
        Collections.sort(uids);
        Set<Range<Integer>> uidRanges = new ArraySet<>();
        int start = 0;
        int next = 0;
        for (int i : uids) {
            if (start == next) {
                start = i;
                next = start + 1;
            } else if (i == next) {
                next++;
            } else {
                uidRanges.add(new Range<>(start, next - 1));
                start = i;
                next = start + 1;
            }
        }
        uidRanges.add(new Range<>(start, next - 1));
        return uidRanges;
    }",0
"protected void addHelpFileRedirect(String fieldName, Class<? extends Describable> owner, String fieldNameToRedirectTo) {
        helpRedirect.put(fieldName,
            Jenkins.getInstance().getDescriptor(owner).getHelpFile(fieldNameToRedirectTo));
    }",0
"private void updateSpeedBumpIndex() {
        int speedBumpIndex = 0;
        int currentIndex = 0;
        final int N = mStackScroller.getChildCount();
        for (int i = 0; i < N; i++) {
            View view = mStackScroller.getChildAt(i);
            if (view.getVisibility() == View.GONE || !(view instanceof ExpandableNotificationRow)) {
                continue;
            }
            ExpandableNotificationRow row = (ExpandableNotificationRow) view;
            currentIndex++;
            if (!mNotificationData.isAmbient(row.getStatusBarNotification().getKey())) {
                speedBumpIndex = currentIndex;
            }
        }
        boolean noAmbient = speedBumpIndex == N;
        mStackScroller.updateSpeedBumpIndex(speedBumpIndex, noAmbient);
    }",0
"private static void addExtraKexAlgorithms(CryptoWishList cwl) {
		String[] oldKexAlgorithms = cwl.kexAlgorithms;
		List<String> kexAlgorithms = new ArrayList<>(oldKexAlgorithms.length + 2);
		for (String algo : oldKexAlgorithms)
		{
			if (!algo.equals(EXT_INFO_C) && !algo.equals(KEX_STRICT_C_OPENSSH))
				kexAlgorithms.add(algo);
		}
		kexAlgorithms.add(EXT_INFO_C);
		kexAlgorithms.add(KEX_STRICT_C_OPENSSH);
		cwl.kexAlgorithms = kexAlgorithms.toArray(new String[0]);
	}",1
"protected void storeSession(VaadinSession session,
            WrappedSession wrappedSession) {
        assert VaadinSession.hasLock(this, wrappedSession);
        writeToHttpSession(wrappedSession, session);
        wrappedSession.setAttribute(getCsrfTokenAttributeName(),
                session.getCsrfToken());
        session.refreshTransients(wrappedSession, this);
    }",0
"@Override
        public GateKeeperResponse[] newArray(int size) {
            return new GateKeeperResponse[size];
        }",0
"public void checkThirdProjectExist(Project project) {
        IssuesRequest issuesRequest = new IssuesRequest();
        if (StringUtils.isBlank(project.getId())) {
            MSException.throwException(""project ID cannot be empty"");
        }
        issuesRequest.setProjectId(project.getId());
        issuesRequest.setWorkspaceId(project.getWorkspaceId());
        if (StringUtils.equalsIgnoreCase(project.getPlatform(), IssuesManagePlatform.Tapd.name())) {
            TapdPlatform tapd = new TapdPlatform(issuesRequest);
            this.doCheckThirdProjectExist(tapd, project.getTapdId());
        } else if (StringUtils.equalsIgnoreCase(project.getPlatform(), IssuesManagePlatform.Zentao.name())) {
            ZentaoPlatform zentao = new ZentaoPlatform(issuesRequest);
            this.doCheckThirdProjectExist(zentao, project.getZentaoId());
        }
    }",0
"private void requestSync(Account account, int userId, int reason, String authority,
            Bundle extras) {
        // If this is happening in the system process, then call the syncrequest listener
        // to make a request back to the SyncManager directly.
        // If this is probably a test instance, then call back through the ContentResolver
        // which will know which userId to apply based on the Binder id.
        if (android.os.Process.myUid() == android.os.Process.SYSTEM_UID
                && mSyncRequestListener != null) {
            mSyncRequestListener.onSyncRequest(
                new EndPoint(account, authority, userId),
                reason,
                extras);
        } else {
            ContentResolver.requestSync(account, authority, extras);
        }
    }",0
"protected IBaseResource addCommonParams(HttpServletRequest theServletRequest, final HomeRequest theRequest, final ModelMap theModel) {
		final String serverId = theRequest.getServerIdWithDefault(myConfig);
		final String serverBase = theRequest.getServerBase(theServletRequest, myConfig);
		final String serverName = theRequest.getServerName(myConfig);
		final String apiKey = theRequest.getApiKey(theServletRequest, myConfig);
		theModel.put(""serverId"", sanitizeInput(serverId));
		theModel.put(""base"", sanitizeInput(serverBase));
		theModel.put(""baseName"", sanitizeInput(serverName));
		theModel.put(""apiKey"", sanitizeInput(apiKey));
		theModel.put(""resourceName"", sanitizeInput(defaultString(theRequest.getResource())));
		theModel.put(""encoding"", sanitizeInput(theRequest.getEncoding()));
		theModel.put(""pretty"", sanitizeInput(theRequest.getPretty()));
		theModel.put(""_summary"", sanitizeInput(theRequest.get_summary()));
		theModel.put(""serverEntries"", myConfig.getIdToServerName());

		return loadAndAddConf(theServletRequest, theRequest, theModel);
	}",1
"private void fireCompletionHandlers() {
            if (completionHandlers != null && !completionHandlers.isEmpty()) {
                Display.getInstance().callSerially(new Runnable() {
                    public void run() {
                        if (completionHandlers != null && !completionHandlers.isEmpty()) {
                            ArrayList<Runnable> toRun;
                            synchronized(Video.this) {
                                toRun = new ArrayList<Runnable>(completionHandlers);
                            }
                            for (Runnable r : toRun) {
                                r.run();
                            }
                        }
                    }
                });
            }
        }",0
"private void updateResizingWindows(final WindowState w) {
        final WindowStateAnimator winAnimator = w.mWinAnimator;
        if (w.mHasSurface && w.mLayoutSeq == mLayoutSeq) {
            w.setInsetsChanged();
            boolean configChanged = w.isConfigChanged();
            if (DEBUG_CONFIGURATION && configChanged) {
                Slog.v(TAG, ""Win "" + w + "" config changed: ""
                        + mCurConfiguration);
            }
            if (localLOGV) Slog.v(TAG, ""Resizing "" + w
                    + "": configChanged="" + configChanged
                    + "" last="" + w.mLastFrame + "" frame="" + w.mFrame);
            w.mLastFrame.set(w.mFrame);
            if (w.mContentInsetsChanged
                    || w.mVisibleInsetsChanged
                    || winAnimator.mSurfaceResized
                    || w.mOutsetsChanged
                    || configChanged) {
                if (DEBUG_RESIZE || DEBUG_ORIENTATION) {
                    Slog.v(TAG, ""Resize reasons for w="" + w + "": ""
                            + "" contentInsetsChanged="" + w.mContentInsetsChanged
                            + "" "" + w.mContentInsets.toShortString()
                            + "" visibleInsetsChanged="" + w.mVisibleInsetsChanged
                            + "" "" + w.mVisibleInsets.toShortString()
                            + "" stableInsetsChanged="" + w.mStableInsetsChanged
                            + "" "" + w.mStableInsets.toShortString()
                            + "" outsetsChanged="" + w.mOutsetsChanged
                            + "" "" + w.mOutsets.toShortString()
                            + "" surfaceResized="" + winAnimator.mSurfaceResized
                            + "" configChanged="" + configChanged);
                }

                w.mLastOverscanInsets.set(w.mOverscanInsets);
                w.mLastContentInsets.set(w.mContentInsets);
                w.mLastVisibleInsets.set(w.mVisibleInsets);
                w.mLastStableInsets.set(w.mStableInsets);
                w.mLastOutsets.set(w.mOutsets);
                makeWindowFreezingScreenIfNeededLocked(w);
                // If the orientation is changing, then we need to
                // hold off on unfreezing the display until this
                // window has been redrawn; to do that, we need
                // to go through the process of getting informed
                // by the application when it has finished drawing.
                if (w.mOrientationChanging) {
                    if (DEBUG_SURFACE_TRACE || DEBUG_ANIM || DEBUG_ORIENTATION) Slog.v(TAG,
                            ""Orientation start waiting for draw mDrawState=DRAW_PENDING in ""
                            + w + "", surface "" + winAnimator.mSurfaceControl);
                    winAnimator.mDrawState = WindowStateAnimator.DRAW_PENDING;
                    if (w.mAppToken != null) {
                        w.mAppToken.allDrawn = false;
                        w.mAppToken.deferClearAllDrawn = false;
                    }
                }
                if (!mResizingWindows.contains(w)) {
                    if (DEBUG_RESIZE || DEBUG_ORIENTATION) Slog.v(TAG,
                            ""Resizing window "" + w + "" to "" + winAnimator.mSurfaceW
                            + ""x"" + winAnimator.mSurfaceH);
                    mResizingWindows.add(w);
                }
            } else if (w.mOrientationChanging) {
                if (w.isDrawnLw()) {
                    if (DEBUG_ORIENTATION) Slog.v(TAG,
                            ""Orientation not waiting for draw in ""
                            + w + "", surface "" + winAnimator.mSurfaceControl);
                    w.mOrientationChanging = false;
                    w.mLastFreezeDuration = (int)(SystemClock.elapsedRealtime()
                            - mDisplayFreezeTime);
                }
            }
        }
    }",0
"@Deprecated
  String compact();",1
"private void restoreSelectionPopupsIfNecessary() {
        if (mHasSelection && mActionMode == null) showSelectActionBar();
    }",0
"public static User validateTok(String email, String suppliedToken, TokenType tokType) throws Exception {
        if (email.isEmpty() || email.equals(""null"") || email.indexOf('@') < 0) {
            throw new AppException(""Invalid email address"");
        }
        if (suppliedToken == null || suppliedToken.isEmpty()) {
            throw new AppException(""Invalid token"");
        }

        // Look up user with this email addr
        User user = User.findByEmail(email);
        if (user == null) {
            throw new AppException(""User account does not exist"");
        }

        switch (tokType) {

        case SESSION:
            if (user.sessionTok == null || user.sessionTok.hasExpired() || !user.sessionTok.token.equals(suppliedToken)) {
                // Clear token if there is a mismatch, this will prevent users that manage to crack the cookie
                // encryption key from doing much, because they would also have to guess the token to log in.
                // Each attempt to guess the auth token will log them out and require them to log in successfully
                // to generate a new token. The account cannot be accessed using any old session-in-client cookie,
                // because there is no auth token on the server until the next successful login.
                user.clearSessionTok();
            } else {
                // User exists and token is valid; return user
                return user;
            }
            break;

        case EMAIL_VERIF:
            if (user.emailValidationTok == null || user.emailValidationTok.hasExpired()
                    || !user.emailValidationTok.token.equals(suppliedToken)) {
                // Clear token if there is a mismatch, this means that if a user uses an old email validation link,
                // it will invalidate the most recent link.
                user.clearEmailValidationTok();
            } else {
                // User exists and token is valid; return user
                return user;
            }
            break;

        case PW_RESET:
            if (user.passwordResetTok == null || user.passwordResetTok.hasExpired()
                    || !user.passwordResetTok.token.equals(suppliedToken)) {
                // Clear token if there is a mismatch, this means that if a user uses an old password reset link,
                // it will invalidate the most recent link.
                user.clearPasswordResetTok();
            } else {
                // User exists and token is valid; return user
                return user;
            }
            break;

        default:
            break;
        }
        throw new AppException(""Token has expired or does not match"");
    }",0
"public void clear() {
            mUidMap.clear();
        }",0
"private static int maxDiffCategory(int category) {
        if (category == 0 || category == 1) return 1;
        else if (category == 2) return 10;
        return 0;
    }",0
"private void attachStartingSurfaceToAssociatedTask() {
        // Associate the configuration of starting window with the task.
        overrideConfigurationPropagation(mStartingWindow, mStartingData.mAssociatedTask);
        getSyncTransaction().reparent(mStartingWindow.mSurfaceControl,
                mStartingData.mAssociatedTask.mSurfaceControl);
    }",0
"@Override
        public void disconnectActivityFromServices(Object connectionHolder) {
            // 'connectionHolder' is an untyped ActivityServiceConnectionsHolder
            final ActivityServiceConnectionsHolder holder =
                    (ActivityServiceConnectionsHolder) connectionHolder;
            synchronized (ActivityManagerService.this) {
                synchronized (mProcLock) {
                    holder.forEachConnection(cr -> mServices.removeConnectionLocked(
                            (ConnectionRecord) cr, null /* skipApp */, holder /* skipAct */,
                            false /* enqueueOomAdj */));
                }
            }
        }",0
"private final ActivityRecord resumedAppLocked() {
        ActivityRecord act = mStackSupervisor.getResumedActivityLocked();
        String pkg;
        int uid;
        if (act != null) {
            pkg = act.packageName;
            uid = act.info.applicationInfo.uid;
        } else {
            pkg = null;
            uid = -1;
        }
        // Has the UID or resumed package name changed?
        if (uid != mCurResumedUid || (pkg != mCurResumedPackage
                && (pkg == null || !pkg.equals(mCurResumedPackage)))) {
            if (mCurResumedPackage != null) {
                mBatteryStatsService.noteEvent(BatteryStats.HistoryItem.EVENT_TOP_FINISH,
                        mCurResumedPackage, mCurResumedUid);
            }
            mCurResumedPackage = pkg;
            mCurResumedUid = uid;
            if (mCurResumedPackage != null) {
                mBatteryStatsService.noteEvent(BatteryStats.HistoryItem.EVENT_TOP_START,
                        mCurResumedPackage, mCurResumedUid);
            }
        }
        return act;
    }",0
"@Test
  public void saveBatchJsonFail(TestContext context) {
    JsonArray array = new JsonArray()
        .add(""{ \""x\"" : \""a\"" }"")
        .add(""{ \""y\"" : \""'\"" }"");
    createFoo(context).saveBatch(BAR, array, context.asyncAssertFailure());
  }",0
"public Map<String, String> toMap() {
    if (StringUtils.isBlank(this.xmlString)) {
      throw new RuntimeException(""xml数据有问题，请核实！"");
    }

    Map<String, String> result = Maps.newHashMap();
    Document doc = this.getXmlDoc();

    try {
      NodeList list = (NodeList) XPathFactory.newInstance().newXPath()
        .compile(""/xml/*"")
        .evaluate(doc, XPathConstants.NODESET);
      int len = list.getLength();
      for (int i = 0; i < len; i++) {
        result.put(list.item(i).getNodeName(), list.item(i).getTextContent());
      }
    } catch (XPathExpressionException e) {
      throw new RuntimeException(""非法的xml文本内容："" + xmlString);
    }

    return result;
  }",0
"@Override
    public String getString() {
        if (currentEvent == Event.KEY_NAME || currentEvent == Event.VALUE_STRING
                || currentEvent == Event.VALUE_NUMBER) {
            return tokenizer.getValue();
        }
        throw new IllegalStateException(
                JsonMessages.PARSER_GETSTRING_ERR(currentEvent));
    }",0
"@Override
    public void onNewLine()
    {
        getXHTMLWikiPrinter().printXMLElement(""br"");
    }",0
"@Override
  protected Logger logger() {
    return LOG;
  }",0
"public boolean hyperlinkMatchesCurrentPage(String href) throws UnsupportedEncodingException {
        String url = Stapler.getCurrentRequest().getRequestURL().toString();
        if (href == null || href.length() <= 1) return ""."".equals(href) && url.endsWith(""/"");
        url = URLDecoder.decode(url,""UTF-8"");
        href = URLDecoder.decode(href,""UTF-8"");
        if (url.endsWith(""/"")) url = url.substring(0, url.length() - 1);
        if (href.endsWith(""/"")) href = href.substring(0, href.length() - 1);

        return url.endsWith(href);
    }",0
"static XmlSchema createSchemaInstance(ThreadContext context, RubyClass klazz, Source source, IRubyObject parseOptions) {
        Ruby runtime = context.getRuntime();
        XmlRelaxng xmlRelaxng = (XmlRelaxng) NokogiriService.XML_RELAXNG_ALLOCATOR.allocate(runtime, klazz);

        if (parseOptions == null) {
            parseOptions = defaultParseOptions(context.getRuntime());
        }

        xmlRelaxng.setInstanceVariable(""@errors"", runtime.newEmptyArray());
        xmlRelaxng.setInstanceVariable(""@parse_options"", parseOptions);

        try {
            Schema schema = xmlRelaxng.getSchema(source, context);
            xmlRelaxng.setVerifier(schema.newVerifier());
            return xmlRelaxng;
        } catch (VerifierConfigurationException ex) {
            throw context.getRuntime().newRuntimeError(""Could not parse document: "" + ex.getMessage());
        }
    }",1
"void dumpDebug(ProtoOutputStream proto) {
        if (mPaymentServiceBound) {
            mPaymentServiceName.dumpDebug(proto, HostEmulationManagerProto.PAYMENT_SERVICE_NAME);
        }
        if (mServiceBound) {
            mServiceName.dumpDebug(proto, HostEmulationManagerProto.SERVICE_NAME);
        }
    }",0
"private void reportStartInstrumentationFailureLocked(IInstrumentationWatcher watcher,
            ComponentName cn, String report) {
        Slog.w(TAG, report);
        if (watcher != null) {
            Bundle results = new Bundle();
            results.putString(Instrumentation.REPORT_KEY_IDENTIFIER, ""ActivityManagerService"");
            results.putString(""Error"", report);
            mInstrumentationReporter.reportStatus(watcher, cn, -1, results);
        }
    }",0
"public Stage saveBuildingStage(Stage stage) {
        for (JobInstance jobInstance : stage.getJobInstances()) {
            JobInstanceMother.setBuildingState(jobInstance);
            jobInstance.setAgentUuid(AGENT_UUID);
            jobInstanceDao.updateAssignedInfo(jobInstance);
        }
        return stage;
    }",0
"@FinishRequest int finishIfPossible(String reason, boolean oomAdj) {
        return finishIfPossible(Activity.RESULT_CANCELED,
                null /* resultData */, null /* resultGrants */, reason, oomAdj);
    }",0
"@Beta
    @Deprecated
    public Builder setCredentialStore(CredentialStore credentialStore) {
      Preconditions.checkArgument(credentialDataStore == null);
      this.credentialStore = credentialStore;
      return this;
    }",0
"public static String registerServlet(PluginManager pluginManager,
            Plugin plugin, GenericServlet servlet, String relativeUrl)
            throws ServletException {

        String pluginName = pluginManager.getPluginPath(plugin).getFileName().toString();
        PluginServlet.pluginManager = pluginManager;
        if (servlet == null) {
            throw new ServletException(""Servlet is missing"");
        }
        String pluginServletUrl = pluginName + relativeUrl;
        servlets.put((pluginName + relativeUrl).toLowerCase(), servlet);
        return PLUGINS_WEBROOT + pluginServletUrl;
        
    }",0
"@PostConstruct
    public void ensureEncrypted() {
        this.userName = StringUtils.stripToNull(this.userName);
        setPasswordIfNotBlank(password);
    }",0
"@Override
    public KeyguardAffordanceView getCenterIcon() {
        return mKeyguardBottomArea.getLockIcon();
    }",0
"private void maybeLogStart() {
        if (!SecurityLog.isLoggingEnabled()) {
            return;
        }
        final String verifiedBootState =
                mInjector.systemPropertiesGet(""ro.boot.verifiedbootstate"");
        final String verityMode = mInjector.systemPropertiesGet(""ro.boot.veritymode"");
        SecurityLog.writeEvent(SecurityLog.TAG_OS_STARTUP, verifiedBootState, verityMode);
    }",0
"private JsonValue readString() throws IOException {
    return new JsonString(readStringInternal());
  }",0
"public Iterator keys() {
        return dataHolder != null ? dataHolder.keys() : Collections.EMPTY_MAP.keySet().iterator();
    }",0
"public EnvPredicate on(final String env, final Consumer<Config> callback) {
    requireNonNull(env, ""Env is required."");
    return on(envpredicate(env), callback);
  }",0
"private static void appendLoginModules(XmlGenerator gen, String tag, List<LoginModuleConfig> loginModuleConfigs) {
        gen.open(tag);
        for (LoginModuleConfig lm : loginModuleConfigs) {
            List<String> attrs = new ArrayList<>();
            attrs.add(""class-name"");
            attrs.add(lm.getClassName());

            if (lm.getUsage() != null) {
                attrs.add(""usage"");
                attrs.add(lm.getUsage().name());
            }
            gen.open(""login-module"", attrs.toArray())
                    .appendProperties(lm.getProperties())
                    .close();
        }
        gen.close();
    }",0
"public void finishSubActivity(IBinder token, String resultWho, int requestCode) throws RemoteException;",0
"public List<Path> getImsmanifestFiles() {
			return imsmanifestFiles;
		}",0
"final static private InputStream wrapPrefixRemovingInputStream(InputStream inputStream)
            throws XMLStreamException, IOException {
        PushbackInputStream pis = new PushbackInputStream(inputStream);
        int b;
        int count = 0;
        while (count < 100 && (b = pis.read()) >= 0) {
            if (++count > 100) {
                throw new XMLStreamException(
                    ""File starts with too much non-XML content to skip over"");
            } else if (b == '<') {
                pis.unread(b);
                break;
            }
        }
        return pis;
    }",0
"public ApiClient setServerVariables(Map<String, String> serverVariables) {
    this.serverVariables = serverVariables;
    updateBasePath();
    return this;
  }",0
"public String getHost() {
        return host;
    }",0
"public ApiClient setOauthCredentials(String clientId, String clientSecret) {
    for (Authentication auth : authentications.values()) {
      if (auth instanceof OAuth) {
        ((OAuth) auth).setCredentials(clientId, clientSecret, isDebugging());
        return this;
      }
    }
    throw new RuntimeException(""No OAuth2 authentication configured!"");
  }",0
"@VisibleForTesting
    ComponentName injectChooserActivity() {
        if (mChooserActivity == null) {
            mChooserActivity = ComponentName.unflattenFromString(
                    mContext.getResources().getString(R.string.config_chooserActivity));
        }
        return mChooserActivity;
    }",0
"private void applyCachedPacketFilter() {
        // If packet filter is supported on both connections, ignore since we would have already
        // applied the filter.
        if (mContext.getResources().getBoolean(R.bool.config_wifiEnableApfOnNonPrimarySta)) return;
        if (mCachedPacketFilter == null) {
            Log.w(TAG, ""No cached packet filter to apply"");
            return;
        }
        Log.i(TAG, ""Applying cached packet filter"");
        mWifiNative.installPacketFilter(mInterfaceName, mCachedPacketFilter);
    }",0
"private String extractLabel(JsonNode node) {
        if (node != null && node.has(LABEL)) {
            return node.get(LABEL).asText();
        }
        return null;
    }",0
"public void enableHostnameVerification() {
        enableHostnameVerificationForNio();
        enableHostnameVerificationForBlockingIo();
    }",0
"public WebContents getWebContents() {
        return mWebContents;
    }",0
"public static List<Node> getNodes(Node node, Pattern... nodePath) {
    List<Node> res = new ArrayList<>();
    getMatchingNodes(node, nodePath, 0, res);
    return res;
  }",0
"public static long maxDirectMemory() {
        return DIRECT_MEMORY_LIMIT;
    }",0
"private void updateLockscreenNotificationSetting() {
        final boolean show = Settings.Secure.getIntForUser(mContext.getContentResolver(),
                Settings.Secure.LOCK_SCREEN_SHOW_NOTIFICATIONS,
                1,
                mCurrentUserId) != 0;
        final int dpmFlags = mDevicePolicyManager.getKeyguardDisabledFeatures(
                null /* admin */, mCurrentUserId);
        final boolean allowedByDpm = (dpmFlags
                & DevicePolicyManager.KEYGUARD_DISABLE_SECURE_NOTIFICATIONS) == 0;

        setShowLockscreenNotifications(show && allowedByDpm);

        if (ENABLE_LOCK_SCREEN_ALLOW_REMOTE_INPUT) {
            final boolean remoteInput = Settings.Secure.getIntForUser(mContext.getContentResolver(),
                    Settings.Secure.LOCK_SCREEN_ALLOW_REMOTE_INPUT,
                    0,
                    mCurrentUserId) != 0;
            final boolean remoteInputDpm =
                    (dpmFlags & DevicePolicyManager.KEYGUARD_DISABLE_REMOTE_INPUT) == 0;

            setLockScreenAllowRemoteInput(remoteInput && remoteInputDpm);
        } else {
            setLockScreenAllowRemoteInput(false);
        }
    }",0
"@Override
    public ParceledListSlice<ActivityManager.RecentTaskInfo> getRecentTasks(int maxNum, int flags,
            int userId) {
        return mActivityTaskManager.getRecentTasks(maxNum, flags, userId);
    }",0
"protected String getImages(String input) {
        String result = """";
        String regex = ""(\\!\\[.*?\\]\\((.*?)\\))"";
        if (StringUtils.isBlank(input)) {
            return result;
        }
        Matcher matcher = Pattern.compile(regex).matcher(input);
        while (matcher.find()) {
            result += matcher.group();
        }
        return result;
    }",0
private native int readEnergyInfo();,0
"@Override
    public void addSharedAccountsFromParentUser(int parentUserId, int userId,
            String opPackageName) {
        checkManageOrCreateUsersPermission(""addSharedAccountsFromParentUser"");
        Account[] accounts = getAccountsAsUser(null, parentUserId, opPackageName);
        for (Account account : accounts) {
            addSharedAccountAsUser(account, userId);
        }
    }",0
"public static void readExceptionWithFileNotFoundExceptionFromParcel(
            Parcel reply) throws FileNotFoundException {
        int code = reply.readExceptionCode();
        if (code == 0) return;
        String msg = reply.readString();
        if (code == 1) {
            throw new FileNotFoundException(msg);
        } else {
            DatabaseUtils.readExceptionFromParcel(reply, msg, code);
        }
    }",0
"private static boolean isCompatibleLoginModule(List<LoginModuleConfig> c1, List<LoginModuleConfig> c2) {
            if (c1 == c2) {
                return true;
            }
            if (c1 == null || c2 == null || c1.size() != c2.size()) {
                return false;
            }

            Map<String, LoginModuleConfig> config1 = new HashMap<String, LoginModuleConfig>();
            Map<String, LoginModuleConfig> config2 = new HashMap<String, LoginModuleConfig>();

            for (LoginModuleConfig loginModuleConfig : c1) {
                config1.put(loginModuleConfig.getClassName(), loginModuleConfig);
            }
            for (LoginModuleConfig loginModuleConfig : c2) {
                config2.put(loginModuleConfig.getClassName(), loginModuleConfig);
            }

            if (!config1.keySet().equals(config2.keySet())) {
                return false;
            }

            for (LoginModuleConfig a : c1) {
                LoginModuleConfig b = config2.get(a.getClassName());

                if (!(a == b || (nullSafeEqual(a.getProperties(), b.getProperties())
                        && nullSafeEqual(a.getUsage(), b.getUsage())))) {
                    return false;
                }
            }

            return true;
        }",0
"private void setRoot(String webRoot) {
    Objects.requireNonNull(webRoot);
    if (!allowRootFileSystemAccess) {
      for (File root : File.listRoots()) {
        if (webRoot.startsWith(root.getAbsolutePath())) {
          throw new IllegalArgumentException(""root cannot start with '"" + root.getAbsolutePath() + ""'"");
        }
      }
    }
    this.webRoot = webRoot;
  }",0
"public JSONArray put(int index, double value) throws JSONException {
        put(index, new Double(value));
        return this;
    }",0
"@VisibleForTesting
    public boolean hasSelection() {
        return mHasSelection;
    }",0
"@Override
        public Intent createLaunchEmergencyDialerIntent(String number) {
            String packageName = mContext.getApplicationContext().getString(
                    com.android.internal.R.string.config_emergency_dialer_package);
            Intent intent = new Intent(Intent.ACTION_DIAL_EMERGENCY)
                    .setPackage(packageName);
            ResolveInfo resolveInfo = mPackageManager.resolveActivity(intent, 0 /* flags*/);
            if (resolveInfo == null) {
                // No matching activity from config, fallback to default platform implementation
                intent.setPackage(null);
            }
            if (!TextUtils.isEmpty(number) && TextUtils.isDigitsOnly(number)) {
                intent.setData(Uri.parse(""tel:"" + number));
            }
            return intent;
        }",0
"@Pure
  @Override
  public int getInt(@Positive int columnIndex) throws SQLException {
    connection.getLogger().log(Level.FINEST, ""  getInt columnIndex: {0}"", columnIndex);
    byte[] value = getRawValue(columnIndex);
    if (value == null) {
      return 0; // SQL NULL
    }

    if (isBinary(columnIndex)) {
      int col = columnIndex - 1;
      int oid = fields[col].getOID();
      if (oid == Oid.INT4) {
        return ByteConverter.int4(value, 0);
      }
      return (int) readLongValue(value, oid, Integer.MIN_VALUE, Integer.MAX_VALUE, ""int"");
    }

    Encoding encoding = connection.getEncoding();
    if (encoding.hasAsciiNumbers()) {
      try {
        return getFastInt(value);
      } catch (NumberFormatException ignored) {
      }
    }
    return toInt(getFixedString(columnIndex));
  }",0
"@Override
        public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {
            Certificate[] peer = getPeerCertificates();
            // No need for null or length > 0 is needed as this is done in getPeerCertificates()
            // already.
            return ((java.security.cert.X509Certificate) peer[0]).getSubjectX500Principal();
        }",0
"private static final void enforceSystemOrRoot(String message) {
        final int uid = Binder.getCallingUid();
        if (uid != Process.SYSTEM_UID && uid != 0) {
            throw new SecurityException(message);
        }
    }",0
"@Override
    public XMLBuilder2 instruction(String target, String data) {
        super.instructionImpl(target, data);
        return this;
    }",0
"public static void dumpCurrentRow(Cursor cursor) {
        dumpCurrentRow(cursor, System.out);
    }",0
"public void scrollToStart() {
        getRpcProxy(GridClientRpc.class).scrollToStart();
    }",0
"private void onWindowsDrawn(long timestampNs) {
        final TransitionInfoSnapshot info = mTaskSupervisor
                .getActivityMetricsLogger().notifyWindowsDrawn(this, timestampNs);
        final boolean validInfo = info != null;
        final int windowsDrawnDelayMs = validInfo ? info.windowsDrawnDelayMs : INVALID_DELAY;
        final @WaitResult.LaunchState int launchState =
                validInfo ? info.getLaunchState() : WaitResult.LAUNCH_STATE_UNKNOWN;
        // The activity may have been requested to be invisible (another activity has been launched)
        // so there is no valid info. But if it is the current top activity (e.g. sleeping), the
        // invalid state is still reported to make sure the waiting result is notified.
        if (validInfo || this == getDisplayArea().topRunningActivity()) {
            mTaskSupervisor.reportActivityLaunched(false /* timeout */, this,
                    windowsDrawnDelayMs, launchState);
        }
        finishLaunchTickingLocked();
        if (task != null) {
            task.setHasBeenVisible(true);
        }
        // Clear indicated launch root task because there's no trampoline activity to expect after
        // the windows are drawn.
        mLaunchRootTask = null;
    }",0
"public boolean isScaledImageDrawingSupported() {
        return true;
    }",0
"private List<DeletedDocument> wrapDeletedDocuments(XWikiDeletedDocument[] deletedDocuments)
    {
        if (deletedDocuments == null || deletedDocuments.length == 0) {
            return Collections.emptyList();
        }

        List<DeletedDocument> result = new ArrayList<>(deletedDocuments.length);
        for (XWikiDeletedDocument deletedDocument : deletedDocuments) {
            result.add(new DeletedDocument(deletedDocument, this.context));
        }

        return result;
    }",0
"public List<String> getDevelopmentFolderNames() {
		return developmentFolderNames;
	}",0
"public void startBackgroundFetchService() {
        LocalNotification n = new LocalNotification();
        n.setId(BACKGROUND_FETCH_NOTIFICATION_ID);
        cancelLocalNotification(BACKGROUND_FETCH_NOTIFICATION_ID);
        // We schedule a local notification
        // First callback will be at the repeat interval
        // We don't specify a repeat interval because the scheduleLocalNotification will 
        // set that for us using the getPreferredBackgroundFetchInterval method.
        scheduleLocalNotification(n, System.currentTimeMillis() + getPreferredBackgroundFetchInterval() * 1000, 0);
    }",0
"protected void fillSerializers(final Node node, SerializationConfig serializationConfig) {
        for (Node child : childElements(node)) {
            final String name = cleanNodeName(child);
            final String value = getTextContent(child);
            if (""serializer"".equals(name)) {
                SerializerConfig serializerConfig = new SerializerConfig();
                final String typeClassName = getAttribute(child, ""type-class"");
                final String className = getAttribute(child, ""class-name"");
                serializerConfig.setTypeClassName(typeClassName);
                serializerConfig.setClassName(className);
                serializationConfig.addSerializerConfig(serializerConfig);
            } else if (""global-serializer"".equals(name)) {
                GlobalSerializerConfig globalSerializerConfig = new GlobalSerializerConfig();
                globalSerializerConfig.setClassName(value);
                String attrValue = getAttribute(child, ""override-java-serialization"");
                boolean overrideJavaSerialization = attrValue != null && getBooleanValue(attrValue.trim());
                globalSerializerConfig.setOverrideJavaSerialization(overrideJavaSerialization);
                serializationConfig.setGlobalSerializerConfig(globalSerializerConfig);
            }
        }
    }",0
"@GET
    @Path(""{configClass}"")
    @ApiOperation(value = ""Get configuration settings from database"")
    @Timed
    @RequiresPermissions(RestPermissions.CLUSTER_CONFIG_ENTRY_READ)
    public Object read(@ApiParam(name = ""configClass"", value = ""The name of the cluster configuration class"", required = true)
                       @PathParam(""configClass"") @NotBlank String configClass) {
        final Class<?> cls = classFromName(configClass);
        if (cls == null) {
            String error = createNoClassMsg(configClass);
            throw new NotFoundException(error);
        }

        return clusterConfigService.get(cls);
    }",0
"@Override
    public String getNumberParameterSQL(Number param) {
        return param.toString();
    }",0
public void setProcessLimit(int max) throws RemoteException;,0
"protected PutMethod executePut(String uri, String string, String mediaType) throws Exception
    {
        HttpClient httpClient = new HttpClient();

        PutMethod putMethod = new PutMethod(uri);
        RequestEntity entity = new StringRequestEntity(string, mediaType, ""UTF-8"");
        putMethod.setRequestEntity(entity);

        httpClient.executeMethod(putMethod);

        return putMethod;
    }",0
"protected final synchronized <T extends Describable<T>>
    void removeFromList(Descriptor<T> item, List<T> collection) throws IOException {
        for( int i=0; i< collection.size(); i++ ) {
            if(collection.get(i).getDescriptor()==item) {
                // found it
                collection.remove(i);
                save();
                updateTransientActions();
                return;
            }
        }
    }",0
"@Override
    public List<Collection> findCollectionsWithSubmit(String q, Context context, Community community,
        int offset, int limit) throws SQLException, SearchServiceException {

        List<Collection> collections = new ArrayList<>();
        DiscoverQuery discoverQuery = new DiscoverQuery();
        discoverQuery.setDSpaceObjectFilter(IndexableCollection.TYPE);
        discoverQuery.setStart(offset);
        discoverQuery.setMaxResults(limit);
        DiscoverResult resp = retrieveCollectionsWithSubmit(context, discoverQuery, null, community, q);
        for (IndexableObject solrCollections : resp.getIndexableObjects()) {
            Collection c = ((IndexableCollection) solrCollections).getIndexedObject();
            collections.add(c);
        }
        return collections;
    }",0
"@Override
    public void setSourceFile(final File sourceFile) {
        this.sourceFile = sourceFile;
    }",0
"public static boolean isDataOrObbRelativePath(@Nullable String path) {
        if (path == null) return false;
        final Matcher m = PATTERN_DATA_OR_OBB_RELATIVE_PATH.matcher(path);
        return m.matches();
    }",0
"@GuardedBy(""this"")
    private boolean handleProcessStartedLocked(ProcessRecord pending,
            ProcessStartResult startResult, long expectedStartSeq) {
        // Indicates that this process start has been taken care of.
        if (mPendingStarts.get(expectedStartSeq) == null) {
            if (pending.pid == startResult.pid) {
                pending.usingWrapper = startResult.usingWrapper;
                // TODO: Update already existing clients of usingWrapper
            }
            return false;
        }
        return handleProcessStartedLocked(pending, startResult.pid, startResult.usingWrapper,
                expectedStartSeq, false);
    }",0
"@Override
    public int getKeyboardType() {
        if (Display.getInstance().getDefaultVirtualKeyboard().isVirtualKeyboardShowing()) {
            return Display.KEYBOARD_TYPE_VIRTUAL;
        }
        /**
         * can we detect this? but even if we could i think it is best to have
         * this fixed to qwerty. we pass unicode values to Codename One in any
         * case. check AndroidView.onKeyUpDown() method. and read comment below.
         */
        return Display.KEYBOARD_TYPE_QWERTY;
        /**
         * some info from the MIDP docs about keycodes:
         *
         * ""Applications receive keystroke events in which the individual keys
         * are named within a space of key codes. Every key for which events are
         * reported to MIDP applications is assigned a key code. The key code
         * values are unique for each hardware key unless two keys are obvious
         * synonyms for each other. MIDP defines the following key codes:
         * KEY_NUM0, KEY_NUM1, KEY_NUM2, KEY_NUM3, KEY_NUM4, KEY_NUM5, KEY_NUM6,
         * KEY_NUM7, KEY_NUM8, KEY_NUM9, KEY_STAR, and KEY_POUND. (These key
         * codes correspond to keys on a ITU-T standard telephone keypad.) Other
         * keys may be present on the keyboard, and they will generally have key
         * codes distinct from those list above. In order to guarantee
         * portability, applications should use only the standard key codes.
         *
         * The standard key codes values are equal to the Unicode encoding for
         * the character that represents the key. If the device includes any
         * other keys that have an obvious correspondence to a Unicode
         * character, their key code values should equal the Unicode encoding
         * for that character. For keys that have no corresponding Unicode
         * character, the implementation must use negative values. Zero is
         * defined to be an invalid key code.""
         *
         * Because the MIDP implementation is our reference and that
         * implementation does not interpret the given keycodes we behave alike
         * and pass on the unicode values.
         */
    }",0
"int getPhonebookAccessPermission(BluetoothDevice device) {
        enforceCallingOrSelfPermission(BLUETOOTH_PERM, ""Need BLUETOOTH permission"");
        SharedPreferences pref = getSharedPreferences(PHONEBOOK_ACCESS_PERMISSION_PREFERENCE_FILE,
                Context.MODE_PRIVATE);
        if (!pref.contains(device.getAddress())) {
            return BluetoothDevice.ACCESS_UNKNOWN;
        }
        return pref.getBoolean(device.getAddress(), false)
                ? BluetoothDevice.ACCESS_ALLOWED : BluetoothDevice.ACCESS_REJECTED;
    }",0
"private static int getHorizontalCenterOffset(int viewportW, int contentW) {
        return (int) ((viewportW - contentW + 1) * 0.5f);
    }",0
"protected void updateQsExpansion() {
        if (mQs == null) return;
        mQs.setQsExpansion(getQsExpansionFraction(), getHeaderTranslation());
    }",0
"public static void initLibraries(HashMap<String, String[]> libraries)
	{
		libraries.put(""mockup"",
				new String[] { SHAPES_PATH + ""/mockup/mxMockupButtons.js"" });
		libraries.put(""arrows2"", new String[] { SHAPES_PATH + ""/mxArrows.js"" });
		libraries.put(""bpmn"",
				new String[] { SHAPES_PATH + ""/bpmn/mxBpmnShape2.js"",
						STENCIL_PATH + ""/bpmn.xml"" });
		libraries.put(""er"", new String[] { SHAPES_PATH + ""/er/mxER.js"" });
		libraries.put(""ios"",
				new String[] { SHAPES_PATH + ""/mockup/mxMockupiOS.js"" });
		libraries.put(""rackGeneral"",
				new String[] { SHAPES_PATH + ""/rack/mxRack.js"",
						STENCIL_PATH + ""/rack/general.xml"" });
		libraries.put(""rackF5"", new String[] { STENCIL_PATH + ""/rack/f5.xml"" });
		libraries.put(""lean_mapping"",
				new String[] { SHAPES_PATH + ""/mxLeanMap.js"",
						STENCIL_PATH + ""/lean_mapping.xml"" });
		libraries.put(""basic"", new String[] { SHAPES_PATH + ""/mxBasic.js"",
				STENCIL_PATH + ""/basic.xml"" });
		libraries.put(""ios7icons"",
				new String[] { STENCIL_PATH + ""/ios7/icons.xml"" });
		libraries.put(""ios7ui"",
				new String[] { SHAPES_PATH + ""/ios7/mxIOS7Ui.js"",
						STENCIL_PATH + ""/ios7/misc.xml"" });
		libraries.put(""android"", new String[] { SHAPES_PATH + ""/mxAndroid.js"",
				STENCIL_PATH + ""electrical/transmission"" });
		libraries.put(""electrical/transmission"",
				new String[] { SHAPES_PATH + ""/mxElectrical.js"",
						STENCIL_PATH + ""/electrical/transmission.xml"" });
		libraries.put(""mockup/buttons"",
				new String[] { SHAPES_PATH + ""/mockup/mxMockupButtons.js"" });
		libraries.put(""mockup/containers"",
				new String[] { SHAPES_PATH + ""/mockup/mxMockupContainers.js"" });
		libraries.put(""mockup/forms"",
				new String[] { SHAPES_PATH + ""/mockup/mxMockupForms.js"" });
		libraries.put(""mockup/graphics"",
				new String[] { SHAPES_PATH + ""/mockup/mxMockupGraphics.js"",
						STENCIL_PATH + ""/mockup/misc.xml"" });
		libraries.put(""mockup/markup"",
				new String[] { SHAPES_PATH + ""/mockup/mxMockupMarkup.js"" });
		libraries.put(""mockup/misc"",
				new String[] { SHAPES_PATH + ""/mockup/mxMockupMisc.js"",
						STENCIL_PATH + ""/mockup/misc.xml"" });
		libraries.put(""mockup/navigation"",
				new String[] { SHAPES_PATH + ""/mockup/mxMockupNavigation.js"",
						STENCIL_PATH + ""/mockup/misc.xml"" });
		libraries.put(""mockup/text"",
				new String[] { SHAPES_PATH + ""/mockup/mxMockupText.js"" });
		libraries.put(""floorplan"",
				new String[] { SHAPES_PATH + ""/mxFloorplan.js"",
						STENCIL_PATH + ""/floorplan.xml"" });
		libraries.put(""bootstrap"",
				new String[] { SHAPES_PATH + ""/mxBootstrap.js"",
						STENCIL_PATH + ""/bootstrap.xml"" });
		libraries.put(""gmdl"", new String[] { SHAPES_PATH + ""/mxGmdl.js"",
				STENCIL_PATH + ""/gmdl.xml"" });
		libraries.put(""cabinets"", new String[] { SHAPES_PATH + ""/mxCabinets.js"",
				STENCIL_PATH + ""/cabinets.xml"" });
		libraries.put(""archimate"",
				new String[] { SHAPES_PATH + ""/mxArchiMate.js"" });
		libraries.put(""archimate3"",
				new String[] { SHAPES_PATH + ""/mxArchiMate3.js"" });
		libraries.put(""sysml"", new String[] { SHAPES_PATH + ""/mxSysML.js"" });
		libraries.put(""eip"", new String[] { SHAPES_PATH + ""/mxEip.js"",
				STENCIL_PATH + ""/eip.xml"" });
		libraries.put(""networks"", new String[] { SHAPES_PATH + ""/mxNetworks.js"",
				STENCIL_PATH + ""/networks.xml"" });
		libraries.put(""aws3d"", new String[] { SHAPES_PATH + ""/mxAWS3D.js"",
				STENCIL_PATH + ""/aws3d.xml"" });
		libraries.put(""pid2inst"",
				new String[] { SHAPES_PATH + ""/pid2/mxPidInstruments.js"" });
		libraries.put(""pid2misc"",
				new String[] { SHAPES_PATH + ""/pid2/mxPidMisc.js"",
						STENCIL_PATH + ""/pid/misc.xml"" });
		libraries.put(""pid2valves"",
				new String[] { SHAPES_PATH + ""/pid2/mxPidValves.js"" });
		libraries.put(""pidFlowSensors"",
				new String[] { STENCIL_PATH + ""/pid/flow_sensors.xml"" });
	}",0
"protected long maxJsonChars() {
    return config.getMemorySize(""play.http.parser.maxMemoryBuffer"").toBytes();
  }",0
"public String getDeregisterActivitySubtitle() {
		return deregisterActivitySubtitle.getExpressionString();
	}",0
"@Override
    protected void onSaveInstanceState(Bundle outStates) {
        super.onSaveInstanceState(outStates);
        mCredentials.onSaveStates(outStates);
        if (mNextAction != null) {
            outStates.putSerializable(NEXT_ACTION_KEY, mNextAction);
        }
    }",0
"private void checkPartialSigningWithUser() {
        if (signing == SigningState.FULL && JNLPRuntime.isVerifying()) {
            signing = SigningState.PARTIAL;
            try {
                securityDelegate.promptUserOnPartialSigning();
            } catch (LaunchException e) {
                throw new RuntimeException(""The signed applet required loading of unsigned code from the codebase, ""
                        + ""which the user refused"", e);
            }
        }
    }",0
"@Override
    public void onCompleted(DownloadRunnable doneRunnable, long startOffset, long endOffset) {
        if (paused) {
            if (FileDownloadLog.NEED_LOG) {
                FileDownloadLog.d(this, ""the task[%d] has already been paused, so pass the""
                        + "" completed callback"", model.getId());
            }
            return;
        }

        final int doneConnectionIndex = doneRunnable.connectionIndex;
        if (FileDownloadLog.NEED_LOG) {
            FileDownloadLog.d(this, ""the connection has been completed(%d): [%d, %d)  %d"",
                    doneConnectionIndex, startOffset, endOffset, model.getTotal());
        }

        if (isSingleConnection) {
            if (startOffset != 0 && endOffset != model.getTotal()) {
                FileDownloadLog.e(this, ""the single task not completed corrected(%d, %d != %d) ""
                        + ""for task(%d)"", startOffset, endOffset, model.getTotal(), model.getId());
            }
        } else {
            synchronized (downloadRunnableList) {
                downloadRunnableList.remove(doneRunnable);
            }
        }
    }",0
"public void onOverdrawBottomHeightChanged(int overdrawHeightPix) {
    }",0
"@Override
                public int compare(WindowState w1, WindowState w2) {
                    final int layer1 = w1.mSubLayer;
                    final int layer2 = w2.mSubLayer;
                    if (layer1 < layer2 || (layer1 == layer2 && layer2 < 0 )) {
                        // We insert the child window into the list ordered by
                        // the sub-layer.  For same sub-layers, the negative one
                        // should go below others; the positive one should go
                        // above others.
                        return -1;
                    }
                    return 1;
                }",0
"public int getReadTimeout() {
    return readTimeout;
  }",0
"public void setFaweExceptionArray(final boolean[] faweExceptionReasonsUsed) {
        this.faweExceptionReasonsUsed = faweExceptionReasonsUsed;
    }",0
"public static boolean isConfigForPasspoint(WifiConfiguration config) {
        return config.isSecurityType(WifiConfiguration.SECURITY_TYPE_PASSPOINT_R1_R2)
                || config.isSecurityType(WifiConfiguration.SECURITY_TYPE_PASSPOINT_R3);
    }",0
"protected Object[] getArgumentsForConstraint(
      String objectName, String field, ConstraintViolation<Object> violation) {
    Annotation annotation = violation.getConstraintDescriptor().getAnnotation();
    if (annotation instanceof Constraints.ValidateWith) {
      Constraints.ValidateWith validateWithAnnotation = (Constraints.ValidateWith) annotation;
      if (violation.getMessage().equals(Constraints.ValidateWithValidator.defaultMessage)) {
        Constraints.ValidateWithValidator validateWithValidator =
            new Constraints.ValidateWithValidator();
        validateWithValidator.initialize(validateWithAnnotation);
        Tuple<String, Object[]> errorMessageKey = validateWithValidator.getErrorMessageKey();
        if (errorMessageKey != null && errorMessageKey._2 != null) {
          return errorMessageKey._2;
        } else {
          return new Object[0];
        }
      } else {
        return new Object[0];
      }
    }
    List<Object> arguments = new LinkedList<>();
    String[] codes = new String[] {objectName + Errors.NESTED_PATH_SEPARATOR + field, field};
    arguments.add(new DefaultMessageSourceResolvable(codes, field));
    // Using a TreeMap for alphabetical ordering of attribute names
    Map<String, Object> attributesToExpose = new TreeMap<>();
    violation
        .getConstraintDescriptor()
        .getAttributes()
        .forEach(
            (attributeName, attributeValue) -> {
              if (!internalAnnotationAttributes.contains(attributeName)) {
                attributesToExpose.put(attributeName, attributeValue);
              }
            });
    arguments.addAll(attributesToExpose.values());
    return arguments.toArray(new Object[arguments.size()]);
  }",0
"private void handleKickedFromMUC(String room, boolean banned, String actor, String reason) {
		mucLastPong.remove(room);
		ContentValues cvR = new ContentValues();
		String message;
		if (actor != null && actor.length() > 0)
			message = mService.getString(banned ? R.string.muc_banned_by : R.string.muc_kicked_by,
					actor, reason);
		else
			message = mService.getString(banned ? R.string.muc_banned : R.string.muc_kicked,
					reason);
		cvR.put(RosterProvider.RosterConstants.STATUS_MESSAGE, message);
		cvR.put(RosterProvider.RosterConstants.STATUS_MODE, StatusMode.offline.ordinal());
		upsertRoster(cvR, room);
	}",0
"void updateCameraCompatStateFromUser(@CameraCompatControlState int state) {
        if (!isCameraCompatControlEnabled()) {
            // Feature is disabled by config_isCameraCompatControlForStretchedIssuesEnabled.
            return;
        }
        if (state == TaskInfo.CAMERA_COMPAT_CONTROL_HIDDEN) {
            Slog.w(TAG, ""Unexpected hidden state in updateCameraCompatState"");
            return;
        }
        boolean changed = setCameraCompatControlState(state);
        mCameraCompatControlClickedByUser = true;
        if (!changed) {
            return;
        }
        mTaskSupervisor.getActivityMetricsLogger().logCameraCompatControlClickedEventReported(
                state, info.applicationInfo.uid);
        if (state == TaskInfo.CAMERA_COMPAT_CONTROL_DISMISSED) {
            mCompatCameraControlCallback = null;
            return;
        }
        if (mCompatCameraControlCallback == null) {
            Slog.w(TAG, ""Callback for a camera compat control is null"");
            return;
        }
        try {
            if (state == TaskInfo.CAMERA_COMPAT_CONTROL_TREATMENT_APPLIED) {
                mCompatCameraControlCallback.applyCameraCompatTreatment();
            } else {
                mCompatCameraControlCallback.revertCameraCompatTreatment();
            }
        } catch (RemoteException e) {
            Slog.e(TAG, ""Unable to apply or revert camera compat treatment"", e);
        }
    }",0
"@Override
    public void executeAppTransition() {
        if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,
                ""executeAppTransition()"")) {
            throw new SecurityException(""Requires MANAGE_APP_TOKENS permission"");
        }

        synchronized(mWindowMap) {
            if (DEBUG_APP_TRANSITIONS) Slog.w(TAG, ""Execute app transition: "" + mAppTransition
                    + "" Callers="" + Debug.getCallers(5));
            if (mAppTransition.isTransitionSet()) {
                mAppTransition.setReady();
                final long origId = Binder.clearCallingIdentity();
                try {
                    performLayoutAndPlaceSurfacesLocked();
                } finally {
                    Binder.restoreCallingIdentity(origId);
                }
            }
        }
    }",0
"@Override
    public Collection<String> getHeaderNames()
    {
        return this.response.getHeaderNames();
    }",0
"@Override
	public IPage<SysUser> getUserByRoleId(Page<SysUser> page, String roleId, String username) {
		return userMapper.getUserByRoleId(page,roleId,username);
	}",0
"@Override
        public void onUserSwitchComplete(int userId) {
            if (DEBUG) Log.d(TAG, String.format(""onUserSwitchComplete %d"", userId));
            if (userId != UserHandle.USER_SYSTEM) {
                UserInfo info = UserManager.get(mContext).getUserInfo(userId);
                // Don't try to dismiss if the user has Pin/Pattern/Password set
                if (info == null || mLockPatternUtils.isSecure(userId)) {
                    return;
                } else if (info.isGuest() || info.isDemo()) {
                    // If we just switched to a guest, try to dismiss keyguard.
                    dismiss(null /* callback */, null /* message */);
                }
            }
        }",0
"public X509Certificate cert() {
        return cert;
    }",0
"protected Date checkoutDateValue(Cell cell) {
        Date date = cell.asDate();
        if (date != null) return date;

        String date2str = cell.asString();

        try {
            DateTime dt = DateUtil.parse(date2str);
            if (dt != null) date = dt.toJdkDate();
        } catch (DateException ignored) {
        }

        // 2017/11/19 11:07
        if (date == null && date2str.contains(""/"")) {
            date = cell.asDate(new String[]{""yyyy/M/d H:m:s"", ""yyyy/M/d H:m"", ""yyyy/M/d""});
        }
        return date;
    }",0
"public static GenericServlet unregisterServlet(Plugin plugin, String url)
            throws ServletException {
        String pluginName = pluginManager.getPluginPath(plugin).getFileName().toString();
        if (url == null) {
            throw new ServletException(""Servlet URL is missing"");
        }
        String fullUrl = pluginName + url;
        return servlets.remove(fullUrl.toLowerCase());
    }",0
"String getWorkingDirectoryAsString()
    {
        return workingDir;
    }",0
"public BatchOperaResponse batchCopy(ApiScenarioBatchRequest batchRequest) {

        ServiceUtils.getSelectAllIds(batchRequest, batchRequest.getCondition(),
                (query) -> extApiScenarioMapper.selectIdsByQuery(query));
        List<ApiScenarioWithBLOBs> apiScenarioList = extApiScenarioMapper.selectIds(batchRequest.getIds());
        StringBuffer stringBuffer = new StringBuffer();
        for (ApiScenarioWithBLOBs apiModel : apiScenarioList) {
            long time = System.currentTimeMillis();
            ApiScenarioWithBLOBs newModel = apiModel;
            newModel.setId(UUID.randomUUID().toString());
            newModel.setName(""copy_"" + apiModel.getName());
            newModel.setCreateTime(time);
            newModel.setUpdateTime(time);
            newModel.setNum(getNextNum(newModel.getProjectId()));

            ApiScenarioExample example = new ApiScenarioExample();
            example.createCriteria().andNameEqualTo(newModel.getName()).
                    andProjectIdEqualTo(newModel.getProjectId()).andStatusNotEqualTo(""Trash"").andIdNotEqualTo(newModel.getId());
            if (apiScenarioMapper.countByExample(example) > 0) {
                stringBuffer.append(newModel.getName() + "";"");
                continue;
            } else {
                boolean insertFlag = true;
                if (StringUtils.isNotBlank(newModel.getCustomNum())) {
                    insertFlag = false;
                    String projectId = newModel.getProjectId();
                    Project project = projectMapper.selectByPrimaryKey(projectId);
                    if (project != null) {
                        Boolean customNum = project.getScenarioCustomNum();
                        // 未开启自定义ID
                        if (!customNum) {
                            insertFlag = true;
                            newModel.setCustomNum(null);
                        } else {
                            boolean isCustomNumExist = true;
                            try {
                                isCustomNumExist = this.isCustomNumExist(newModel);
                            } catch (Exception e) {
                            }
                            insertFlag = !isCustomNumExist;
                        }
                    }
                }

                if (insertFlag) {
                    apiScenarioMapper.insert(newModel);
                    apiScenarioReferenceIdService.saveByApiScenario(newModel);
                }
            }
        }

        BatchOperaResponse result = new BatchOperaResponse();
        if (stringBuffer.length() == 0) {
            result.result = true;
        } else {
            result.result = false;
            result.errorMsg = stringBuffer.substring(0, stringBuffer.length() - 1);
        }
        return result;
    }",0
"void cleanUpSplashScreen() {
        // We only clean up the splash screen if we were supposed to handle it. If it was
        // transferred to another activity, the next one will handle the clean up.
        if (mHandleExitSplashScreen && !startingMoved
                && (mTransferringSplashScreenState == TRANSFER_SPLASH_SCREEN_FINISH
                || mTransferringSplashScreenState == TRANSFER_SPLASH_SCREEN_IDLE)) {
            ProtoLog.v(WM_DEBUG_STARTING_WINDOW, ""Cleaning splash screen token=%s"", this);
            mAtmService.mTaskOrganizerController.onAppSplashScreenViewRemoved(getTask());
        }
    }",0
"private void setRefinable(boolean refinable) {
        if (refinable) {
            mRefineView.setVisibility(VISIBLE);
            mRefineView.setOnClickListener(new OnClickListener() {
                @Override
                public void onClick(View v) {
                    // Post the refine action to the end of the UI thread to allow the refine view
                    // a chance to update its background selection state.
                    PerformRefineSuggestion performRefine = new PerformRefineSuggestion();
                    if (!post(performRefine)) performRefine.run();
                }
            });
        } else {
            mRefineView.setOnClickListener(null);
            mRefineView.setVisibility(GONE);
        }
    }",0
"public DeploymentConfiguration getDeploymentConfiguration() {
        return deploymentConfiguration;
    }",0
public abstract void run();,0
"public void requestBugReport(int bugreportType) {
        String service = null;
        switch (bugreportType) {
            case ActivityManager.BUGREPORT_OPTION_FULL:
                service = ""bugreport"";
                break;
            case ActivityManager.BUGREPORT_OPTION_INTERACTIVE:
                service = ""bugreportplus"";
                break;
            case ActivityManager.BUGREPORT_OPTION_REMOTE:
                service = ""bugreportremote"";
                break;
        }
        if (service == null) {
            throw new IllegalArgumentException(""Provided bugreport type is not correct, value: ""
                    + bugreportType);
        }
        enforceCallingPermission(android.Manifest.permission.DUMP, ""requestBugReport"");
        SystemProperties.set(""ctl.start"", service);
    }",0
"public void setName(String name) {
        this.name = name;
    }",0
"public DefaultHeaders<K, V, T> copy() {
        DefaultHeaders<K, V, T> copy = new DefaultHeaders<K, V, T>(
                hashingStrategy, valueConverter, nameValidator, entries.length);
        copy.addImpl(this);
        return copy;
    }",0
"@HotPath(caller = HotPath.PROCESS_CHANGE)
        @Override
        public void clearHeavyWeightProcessIfEquals(WindowProcessController proc) {
            synchronized (mGlobalLockWithoutBoost) {
                ActivityTaskManagerService.this.clearHeavyWeightProcessIfEquals(proc);
            }
        }",0
"@Override
    public List<String> listPolicyExemptApps() {
        CallerIdentity caller = getCallerIdentity();
        Preconditions.checkCallAuthorization(
                hasCallingOrSelfPermission(permission.MANAGE_DEVICE_ADMINS)
                        || isDefaultDeviceOwner(caller) || isProfileOwner(caller));

        return listPolicyExemptAppsUnchecked(mContext);
    }",0
"public void visitUris(@NonNull Consumer<Uri> visitor) {
        visitor.accept(sound);

        if (tickerView != null) tickerView.visitUris(visitor);
        if (contentView != null) contentView.visitUris(visitor);
        if (bigContentView != null) bigContentView.visitUris(visitor);
        if (headsUpContentView != null) headsUpContentView.visitUris(visitor);

        visitIconUri(visitor, mSmallIcon);
        visitIconUri(visitor, mLargeIcon);

        if (actions != null) {
            for (Action action : actions) {
                visitIconUri(visitor, action.getIcon());
            }
        }

        if (extras != null) {
            visitIconUri(visitor, extras.getParcelable(EXTRA_LARGE_ICON_BIG, Icon.class));
            visitIconUri(visitor, extras.getParcelable(EXTRA_PICTURE_ICON, Icon.class));

            // NOTE: The documentation of EXTRA_AUDIO_CONTENTS_URI explicitly says that it is a
            // String representation of a Uri, but the previous implementation (and unit test) of
            // this method has always treated it as a Uri object. Given the inconsistency,
            // supporting both going forward is the safest choice.
            Object audioContentsUri = extras.get(EXTRA_AUDIO_CONTENTS_URI);
            if (audioContentsUri instanceof Uri) {
                visitor.accept((Uri) audioContentsUri);
            } else if (audioContentsUri instanceof String) {
                visitor.accept(Uri.parse((String) audioContentsUri));
            }

            if (extras.containsKey(EXTRA_BACKGROUND_IMAGE_URI)) {
                visitor.accept(Uri.parse(extras.getString(EXTRA_BACKGROUND_IMAGE_URI)));
            }

            ArrayList<Person> people = extras.getParcelableArrayList(EXTRA_PEOPLE_LIST);
            if (people != null && !people.isEmpty()) {
                for (Person p : people) {
                    visitor.accept(p.getIconUri());
                }
            }

            final Person person = extras.getParcelable(EXTRA_MESSAGING_PERSON, Person.class);
            if (person != null) {
                visitor.accept(person.getIconUri());
            }
        }

        if (isStyle(MessagingStyle.class) && extras != null) {
            final Parcelable[] messages = extras.getParcelableArray(EXTRA_MESSAGES);
            if (!ArrayUtils.isEmpty(messages)) {
                for (MessagingStyle.Message message : MessagingStyle.Message
                        .getMessagesFromBundleArray(messages)) {
                    visitor.accept(message.getDataUri());

                    Person senderPerson = message.getSenderPerson();
                    if (senderPerson != null) {
                        visitor.accept(senderPerson.getIconUri());
                    }
                }
            }

            final Parcelable[] historic = extras.getParcelableArray(EXTRA_HISTORIC_MESSAGES);
            if (!ArrayUtils.isEmpty(historic)) {
                for (MessagingStyle.Message message : MessagingStyle.Message
                        .getMessagesFromBundleArray(historic)) {
                    visitor.accept(message.getDataUri());

                    Person senderPerson = message.getSenderPerson();
                    if (senderPerson != null) {
                        visitor.accept(senderPerson.getIconUri());
                    }
                }
            }
        }

        if (isStyle(CallStyle.class) & extras != null) {
            Person callPerson = extras.getParcelable(EXTRA_CALL_PERSON);
            if (callPerson != null) {
                visitor.accept(callPerson.getIconUri());
            }
            visitIconUri(visitor, extras.getParcelable(EXTRA_VERIFICATION_ICON));
        }

        if (mBubbleMetadata != null) {
            visitIconUri(visitor, mBubbleMetadata.getIcon());
        }
    }",1
"public boolean isReady() {
        if (mNativeContentViewCore == 0) return false;
        return nativeIsRenderWidgetHostViewReady(mNativeContentViewCore);
    }",0
"@Override
    public String[] currentToCanonicalPackageNames(String[] names) {
        String[] out = new String[names.length];
        // reader
        synchronized (mPackages) {
            for (int i=names.length-1; i>=0; i--) {
                PackageSetting ps = mSettings.mPackages.get(names[i]);
                out[i] = ps != null && ps.realName != null ? ps.realName : names[i];
            }
        }
        return out;
    }",0
"public boolean shouldUpRecreateTask(IBinder token, String destAffinity)
            throws RemoteException {
        Parcel data = Parcel.obtain();
        Parcel reply = Parcel.obtain();
        data.writeInterfaceToken(IActivityManager.descriptor);
        data.writeStrongBinder(token);
        data.writeString(destAffinity);
        mRemote.transact(SHOULD_UP_RECREATE_TASK_TRANSACTION, data, reply, 0);
        reply.readException();
        boolean result = reply.readInt() != 0;
        data.recycle();
        reply.recycle();
        return result;
    }",0
"void requestUpdateWallpaperIfNeeded() {
        final DisplayContent dc = getDisplayContent();
        if (dc != null && hasWallpaper()) {
            dc.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER;
            dc.setLayoutNeeded();
            mWmService.mWindowPlacerLocked.requestTraversal();
        }

        for (int i = mChildren.size() - 1; i >= 0; i--) {
            final WindowState c = mChildren.get(i);
            c.requestUpdateWallpaperIfNeeded();
        }
    }",0
"@Override
    public void killAllBackgroundProcesses() {
        if (checkCallingPermission(android.Manifest.permission.KILL_BACKGROUND_PROCESSES)
                != PackageManager.PERMISSION_GRANTED) {
            final String msg = ""Permission Denial: killAllBackgroundProcesses() from pid=""
                    + Binder.getCallingPid() + "", uid="" + Binder.getCallingUid()
                    + "" requires "" + android.Manifest.permission.KILL_BACKGROUND_PROCESSES;
            Slog.w(TAG, msg);
            throw new SecurityException(msg);
        }

        final int callingUid = Binder.getCallingUid();
        final int callingPid = Binder.getCallingPid();

        ProcessRecord proc;
        synchronized (mPidsSelfLocked) {
            proc = mPidsSelfLocked.get(callingPid);
        }
        if (callingUid >= FIRST_APPLICATION_UID
                && (proc == null || !proc.info.isSystemApp())) {
            final String msg = ""Permission Denial: killAllBackgroundProcesses() from pid=""
                    + callingPid + "", uid="" + callingUid + "" is not allowed"";
            Slog.w(TAG, msg);
            // Silently return to avoid existing apps from crashing.
            return;
        }

        final long callingId = Binder.clearCallingIdentity();
        try {
            synchronized (this) {
                // Allow memory level to go down (the flag needs to be set before updating oom adj)
                // because this method is also used to simulate low memory.
                mAppProfiler.setAllowLowerMemLevelLocked(true);
                synchronized (mProcLock) {
                    mProcessList.killPackageProcessesLSP(null /* packageName */, -1 /* appId */,
                            UserHandle.USER_ALL, ProcessList.CACHED_APP_MIN_ADJ,
                            ApplicationExitInfo.REASON_USER_REQUESTED,
                            ApplicationExitInfo.SUBREASON_KILL_BACKGROUND,
                            ""kill all background"");
                }

                mAppProfiler.doLowMemReportIfNeededLocked(null);
            }
        } finally {
            Binder.restoreCallingIdentity(callingId);
        }
    }",1
"public static String[] getDefaultKexAlgorithmList()
	{
		return KEX_ALGS.toArray(new String[0]);
	}",0
"private void addSharedLibraryLPw(ArraySet<String> usesLibraryFiles, SharedLibraryEntry file,
            PackageParser.Package changingLib) {
        if (file.path != null) {
            usesLibraryFiles.add(file.path);
            return;
        }
        PackageParser.Package p = mPackages.get(file.apk);
        if (changingLib != null && changingLib.packageName.equals(file.apk)) {
            // If we are doing this while in the middle of updating a library apk,
            // then we need to make sure to use that new apk for determining the
            // dependencies here.  (We haven't yet finished committing the new apk
            // to the package manager state.)
            if (p == null || p.packageName.equals(changingLib.packageName)) {
                p = changingLib;
            }
        }
        if (p != null) {
            usesLibraryFiles.addAll(p.getAllCodePaths());
        }
    }",0
"protected byte[] sendKexInit() throws Exception {
        Map<KexProposalOption, String> proposal = doStrictKexProposal(getKexProposal());

        byte[] seed;
        synchronized (kexState) {
            DefaultKeyExchangeFuture initFuture = kexInitializedFuture;
            if (initFuture == null) {
                initFuture = new DefaultKeyExchangeFuture(toString(), null);
                kexInitializedFuture = initFuture;
            }
            try {
                seed = sendKexInit(proposal);
                setKexSeed(seed);
                initFuture.setValue(Boolean.TRUE);
            } catch (Exception e) {
                initFuture.setValue(e);
                throw e;
            }
        }

        if (log.isTraceEnabled()) {
            log.trace(""sendKexInit({}) proposal={} seed: {}"", this, proposal, BufferUtils.toHex(':', seed));
        }
        return seed;
    }",1
"public void setSCDsTypesExpected() {
        this.unsetTypeExpected();
        int i=1;
        this.setTypeExpected(i, TypeNames.INT); // crf_id
        ++i; this.setTypeExpected(i, TypeNames.INT); // crf_version_id
        ++i; this.setTypeExpected(i, TypeNames.INT); // item_id
        ++i; this.setTypeExpected(i, TypeNames.STRING); // crf_version_oid
        ++i; this.setTypeExpected(i, TypeNames.STRING); // item_oid
        ++i; this.setTypeExpected(i, TypeNames.STRING); // control_item_name
        ++i; this.setTypeExpected(i, TypeNames.STRING); // option_value
        ++i; this.setTypeExpected(i, TypeNames.STRING); // message
    }",0
"public void setCallback(EmergencyButtonCallback callback) {
        mEmergencyButtonCallback = callback;
    }",0
"@Deprecated(since = ""2.2M2"")
    public void setLargeStringValue(String className, String fieldName, String value)
    {
        setLargeStringValue(
            getXClassEntityReferenceResolver().resolve(className, EntityType.DOCUMENT, getDocumentReference()),
            fieldName, value);
    }",0
"private void updateConnectingThread(Thread new_thread) {
		synchronized(mConnectingThreadMutex) {
			if (mConnectingThread == null) {
				mConnectingThread = new_thread;
			} else try {
				Log.d(TAG, ""updateConnectingThread: old thread is still running, killing it."");
				mConnectingThread.interrupt();
				mConnectingThread.join(50);
			} catch (InterruptedException e) {
				Log.d(TAG, ""updateConnectingThread: failed to join(): "" + e);
			} finally {
				mConnectingThread = new_thread;
			}
		}
	}",0
"@Nonnull
  public static byte[] base64decode(@Nonnull final String text) throws IOException {
    return Base64.decode(text);
  }",0
"@Override
    public void attach() {
        super.attach();
        attachDataProviderListener();
    }",0
"@Override
        public ServletInputStream getInputStream() throws IOException {
            return null;
        }",0
"@VisibleForTesting
    void saveState(Bundle outState) {
        if (mCategories.size() > 0) {
            outState.putParcelableArrayList(SAVE_KEY_CATEGORIES, mCategories);
        }
    }",0
"@Override
    public synchronized void onPerformSync(Account account, Bundle extras,
            String authority, ContentProviderClient providerClient,
            SyncResult syncResult) {

        mCancellation = false;
        mFailedResultsCounter = 0;
        mLastFailedResult = null;
        mConflictsFound = 0;
        mFailsInFavouritesFound = 0;
        mForgottenLocalFiles = new HashMap<String, String>();
        mSyncResult = syncResult;
        mSyncResult.fullSyncRequested = false;
        mSyncResult.delayUntil = (System.currentTimeMillis()/1000) + 3*60*60; // avoid too many automatic synchronizations

        this.setAccount(account);
        this.setContentProviderClient(providerClient);
        this.setStorageManager(new FileDataStorageManager(getUser(), providerClient));

        try {
            this.initClientForCurrentAccount();
        } catch (IOException | AccountsException e) {
            /// the account is unknown for the Synchronization Manager, unreachable this context,
            // or can not be authenticated; don't try this again
            mSyncResult.tooManyRetries = true;
            notifyFailedSynchronization();
            return;
        }

        Log_OC.d(TAG, ""Synchronization of ownCloud account "" + account.name + "" starting"");
        sendLocalBroadcast(EVENT_FULL_SYNC_START, null, null);  // message to signal the start
                                                                // of the synchronization to the UI

        /* When 'true' the process was requested by the user through the user interface;
           when 'false', it was requested automatically by the system */
        boolean mIsManualSync = extras.getBoolean(ContentResolver.SYNC_EXTRAS_MANUAL, false);
        try {
            updateOCVersion();
            mCurrentSyncTime = System.currentTimeMillis();
            if (!mCancellation) {
                synchronizeFolder(getStorageManager().getFileByPath(OCFile.ROOT_PATH));

            } else {
                Log_OC.d(TAG, ""Leaving synchronization before synchronizing the root folder "" +
                        ""because cancellation request"");
            }

        } finally {
            // it's important making this although very unexpected errors occur;
            // that's the reason for the finally

            if (mFailedResultsCounter > 0 && mIsManualSync) {
                /// don't let the system synchronization manager retries MANUAL synchronizations
                //      (be careful: ""MANUAL"" currently includes the synchronization requested when
                //      a new account is created and when the user changes the current account)
                mSyncResult.tooManyRetries = true;

                /// notify the user about the failure of MANUAL synchronization
                notifyFailedSynchronization();
            }
            if (mConflictsFound > 0 || mFailsInFavouritesFound > 0) {
                notifyFailsInFavourites();
            }
            if (mForgottenLocalFiles.size() > 0) {
                notifyForgottenLocalFiles();
            }
            sendLocalBroadcast(EVENT_FULL_SYNC_END, null, mLastFailedResult);   // message to signal
                                                                                // the end to the UI
        }

    }",0
"@Test
  public void executeTransNullConnection(TestContext context) throws Exception {
    setRootLevel(Level.FATAL);
    postgresClient().execute(null, ""SELECT 1"", context.asyncAssertFailure());
  }",0
"public static PSystemVersion createStdLib(UmlSource source) {
		final List<String> strings = new ArrayList<>();
		Stdlib.addInfoVersion(strings, true);
		strings.add("" "");

		return new PSystemVersion(source, true, strings);
	}",0
"private void toggleScrollDownButton(AbsListView listView) {
        if (conversation == null) {
            return;
        }
        if (scrolledToBottom(listView)) {
            lastMessageUuid = null;
            hideUnreadMessagesCount();
        } else {
            binding.scrollToBottomButton.setEnabled(true);
            binding.scrollToBottomButton.show();
            if (lastMessageUuid == null) {
                lastMessageUuid = conversation.getLatestMessage().getUuid();
            }
            if (conversation.getReceivedMessagesCountSinceUuid(lastMessageUuid) > 0) {
                binding.unreadCountCustomView.setVisibility(View.VISIBLE);
            }
        }
    }",0
"private MessageVO[] toArrayOfVO(List<Message> threads, UriInfo uriInfo) {
		MessageVO[] threadArr = new MessageVO[threads.size()];
		int i=0;
		for(Message thread:threads) {
			MessageVO msg = new MessageVO(thread);
			msg.setAttachments(getAttachments(thread, uriInfo));
			threadArr[i++] = msg;
		}
		return threadArr;
	}",0
"@Override
        public int getDisplayId() {
            synchronized (mService) {
                if (mActivityDisplay != null) {
                    return mActivityDisplay.mDisplayId;
                }
            }
            return -1;
        }",0
"private void updateChannel() {
        mBgHandler.post(
                new UpdateChannelRunnable(mINotificationManager, mPackageName,
                        mAppUid, mSelectedAction, mNotificationChannel));
        mEntry.markForUserTriggeredMovement(true);
        mMainHandler.postDelayed(
                () -> mOnUserInteractionCallback.onImportanceChanged(mEntry),
                StackStateAnimator.ANIMATION_DURATION_STANDARD);
    }",0
"@Override
    public boolean setTile(int x, int y, int z, CompoundTag tile) throws WorldEditException {
        return false;
    }",0
"private void notifyPackage(String packageName, UserAccounts accounts) {
        Intent intent = new Intent(AccountManager.ACTION_VISIBLE_ACCOUNTS_CHANGED);
        intent.setPackage(packageName);
        intent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
        mContext.sendBroadcastAsUser(intent, new UserHandle(accounts.userId));
    }",0
"@Override
    public List<String> getPermittedAccessibilityServices(ComponentName who) {
        if (!mHasFeature) {
            return null;
        }
        Objects.requireNonNull(who, ""ComponentName is null"");
        final CallerIdentity caller = getCallerIdentity(who);
        Preconditions.checkCallAuthorization(
                isDefaultDeviceOwner(caller) || isProfileOwner(caller));

        synchronized (getLockObject()) {
            ActiveAdmin admin = getProfileOwnerOrDeviceOwnerLocked(caller.getUserId());
            return admin.permittedAccessiblityServices;
        }
    }",0
"@Override
    public void onUserRemoved(RealmModel realm, UserModel user) {
        onUserRemoved(realm, user.getId());
    }",0
"@Override
   public void save(MapSession session) {
      if (!session.getId().equals(session.getOriginalId())) {
         removeFromCacheWithoutNotifications(session.getOriginalId());
      }
      cache.put(session.getId(), session, session.getMaxInactiveInterval().getSeconds(), TimeUnit.SECONDS);
   }",1
"private void watchPod(String namespace, String podName, AbortChecker abortChecker, TaskLogger jobLogger) {
		Commandline kubectl = newKubeCtl();
		
		ObjectMapper mapper = OneDev.getInstance(ObjectMapper.class);
		
		AtomicReference<Abort> abortRef = new AtomicReference<>(null);
		
		StringBuilder json = new StringBuilder();
		kubectl.addArgs(""get"", ""pod"", podName, ""-n"", namespace, ""--watch"", ""-o"", ""json"");
		
		kubectl.timeout(POD_WATCH_TIMEOUT);
		
		Thread thread = Thread.currentThread();
		
		while (true) {
			try {
				kubectl.execute(new LineConsumer() {
		
					@Override
					public void consume(String line) {
						if (line.startsWith(""{"")) {
							json.append(""{"").append(""\n"");
						} else if (line.startsWith(""}"")) {
							json.append(""}"");
							logger.trace(""Pod watching output:\n"" + json.toString());
							try {
								process(mapper.readTree(json.toString()));
							} catch (Exception e) {
								logger.error(""Error processing pod watching output"", e);
							}
							json.setLength(0);
						} else {
							json.append(line).append(""\n"");
						}
					}

					private void process(JsonNode podNode) {
						JsonNode statusNode = podNode.get(""status"");
						checkConditions(statusNode, jobLogger);

						if (abortRef.get() == null) {
							String nodeName = null;
							JsonNode specNode = podNode.get(""spec"");
							if (specNode != null) {
								JsonNode nodeNameNode = specNode.get(""nodeName"");
								if (nodeNameNode != null)
									nodeName = nodeNameNode.asText();
							}
							
							Collection<JsonNode> containerStatusNodes = new ArrayList<>();
							JsonNode initContainerStatusesNode = statusNode.get(""initContainerStatuses"");
							if (initContainerStatusesNode != null) {
								for (JsonNode containerStatusNode: initContainerStatusesNode)
									containerStatusNodes.add(containerStatusNode);
							}
							JsonNode containerStatusesNode = statusNode.get(""containerStatuses"");
							if (containerStatusesNode != null) {
								for (JsonNode containerStatusNode: containerStatusesNode)
									containerStatusNodes.add(containerStatusNode);
							}
							
							abortRef.set(abortChecker.check(nodeName, containerStatusNodes));
							
							if (abortRef.get() != null) 
								thread.interrupt();
						}
					}
					
				}, new LineConsumer() {
		
					@Override
					public void consume(String line) {
						jobLogger.error(""Kubernetes: "" + line);
					}
					
				}).checkReturnCode();
				
				throw new ExplicitException(""Unexpected end of pod watching"");
			} catch (Exception e) {
				Abort abort = abortRef.get();
				if (abort != null) {
					if (abort.getErrorMessage() != null)
						throw new ExplicitException(abort.getErrorMessage());
					else 
						break;
				} else if (ExceptionUtils.find(e, TimeoutException.class) == null) { 
					// If there is no output for some time, let's re-watch as sometimes 
					// pod status update is not pushed
					throw ExceptionUtils.unchecked(e);
				}
			}		
		}
	}",0
"public void onExtrasChanged(String callId, Bundle extras,
                Session.Info info) throws RemoteException {
            mConnectionServiceDelegateAdapter.onExtrasChanged(callId, extras, info);
        }",0
"protected RuntimeResourceDefinition getResourceType(HomeRequest theRequest, HttpServletRequest theReq) throws ServletException {
		String resourceName = sanitizeUrlPart(defaultString(theReq.getParameter(PARAM_RESOURCE)));
		RuntimeResourceDefinition def = getContext(theRequest).getResourceDefinition(resourceName);
		if (def == null) {
			throw new ServletException(""Invalid resourceName: "" + resourceName);
		}
		return def;
	}",1
"@Nullable
    private static SslContext findDefaultSslContext(VirtualHost defaultVirtualHost,
                                                    List<VirtualHost> virtualHosts) {
        final SslContext defaultSslContext = defaultVirtualHost.sslContext();
        if (defaultSslContext != null) {
            return defaultSslContext;
        }

        for (int i = virtualHosts.size() - 1; i >= 0; i--) {
            final SslContext sslContext = virtualHosts.get(i).sslContext();
            if (sslContext != null) {
                return sslContext;
            }
        }
        return null;
    }",0
"public AuthenticationInfo loadAuthenticationInfo(JSONWebToken token) {
        Key key = getJWTKey();
        Jws<Claims> jwt;
        try {
            jwt = Jwts.parser().setSigningKey(key).parseClaimsJws(token.getPrincipal());
        } catch (JwtException e) {
            throw new AuthenticationException(e);
        }
        String credentials = legacyHashing ? token.getCredentials() : encryptPassword(token.getCredentials());
        Object principal = extractPrincipalFromWebToken(jwt);
        return new SimpleAuthenticationInfo(principal, credentials, getName());
    }",1
"public synchronized void deregisterHandler(String iface, int what, Handler handler) {
        SparseArray<Set<Handler>> ifaceHandlers = mHandlerMap.get(iface);
        if (ifaceHandlers == null) {
            return;
        }
        Set<Handler> ifaceWhatHandlers = ifaceHandlers.get(what);
        if (ifaceWhatHandlers == null) {
            return;
        }
        ifaceWhatHandlers.remove(handler);
    }",0
"@SuppressJava6Requirement(reason = ""Usage guarded by java version check"")
    public static <C> Deque<C> newConcurrentDeque() {
        if (javaVersion() < 7) {
            return new LinkedBlockingDeque<C>();
        } else {
            return new ConcurrentLinkedDeque<C>();
        }
    }",0
"@Override
    public final int startActivityWithConfig(IApplicationThread caller, String callingPackage,
            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,
            int startFlags, Configuration config, Bundle options, int userId) {
        enforceNotIsolatedCaller(""startActivityWithConfig"");
        userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId,
                false, ALLOW_FULL_ONLY, ""startActivityWithConfig"", null);
        // TODO: Switch to user app stacks here.
        int ret = mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent,
                resolvedType, null, null, resultTo, resultWho, requestCode, startFlags,
                null, null, config, options, userId, null, null);
        return ret;
    }",0
"WindowFrames getWindowFrames() {
        return mWindowFrames;
    }",0
"@NonNull
        public Builder setLargeIcon(Bitmap b) {
            return setLargeIcon(b != null ? Icon.createWithBitmap(b) : null);
        }",0
"private void removePackageIfRequired(final String packageName, final int userId) {
        if (!packageHasActiveAdmins(packageName, userId)) {
            // Will not do anything if uninstall was not requested or was already started.
            startUninstallIntent(packageName, userId);
        }
    }",0
"@Pure
  public @Nullable String getString(String columnName) throws SQLException {
    return getString(findColumn(columnName));
  }",0
"@Override
    public void endQuotation(Map<String, String> parameters)
    {
        getXHTMLWikiPrinter().printXMLEndElement(""p"");

        getXHTMLWikiPrinter().printXMLEndElement(""blockquote"");

        if (getBlockState().isInQuotationLine()) {
            getXHTMLWikiPrinter().printXMLStartElement(""p"");
        }
    }",0
"@Override
        public void setVolume(int vol) {
            // float v = ((float) vol) / 100.0F;
            AudioManager am = (AudioManager) activity.getSystemService(Context.AUDIO_SERVICE);
            int max = am.getStreamMaxVolume(AudioManager.STREAM_MUSIC);
            am.setStreamVolume(AudioManager.STREAM_MUSIC, vol, 0);
        }",0
"public String includeForm(String topic) throws XWikiException
    {
        return includeForm(topic, true);
    }",0
"private int getPermissionGrantStateForUser(
            String packageName, String permission, CallerIdentity caller, int userId)
            throws RemoteException {
        int granted;
        if (getTargetSdk(caller.getPackageName(), caller.getUserId())
                < android.os.Build.VERSION_CODES.Q) {
            // The per-Q behavior was to not check the app-ops state.
            granted = mIPackageManager.checkPermission(permission, packageName, userId);
        } else {
            try (var snapshot = mInjector.getPackageManagerLocal().withUnfilteredSnapshot()) {
                var packageState = snapshot.getPackageStates().get(packageName);
                if (packageState == null) {
                    Slog.w(LOG_TAG, ""Can't get permission state for missing package ""
                            + packageName);
                    return DevicePolicyManager.PERMISSION_GRANT_STATE_DEFAULT;
                } else if (!packageState.getUserStateOrDefault(userId).isInstalled()) {
                    Slog.w(LOG_TAG, ""Can't get permission state for uninstalled package ""
                            + packageName);
                    return DevicePolicyManager.PERMISSION_GRANT_STATE_DEFAULT;
                } else {
                    if (PermissionChecker.checkPermissionForPreflight(mContext, permission,
                            PermissionChecker.PID_UNKNOWN,
                            UserHandle.getUid(userId, packageState.getAppId()), packageName)
                            != PermissionChecker.PERMISSION_GRANTED) {
                        granted = PackageManager.PERMISSION_DENIED;
                    } else {
                        granted = PackageManager.PERMISSION_GRANTED;
                    }

                }
            }
        }
        int permFlags = mInjector.getPackageManager().getPermissionFlags(
                permission, packageName, UserHandle.of(userId));
        if ((permFlags & PackageManager.FLAG_PERMISSION_POLICY_FIXED)
                != PackageManager.FLAG_PERMISSION_POLICY_FIXED) {
            // Not controlled by policy
            return DevicePolicyManager.PERMISSION_GRANT_STATE_DEFAULT;
        } else {
            // Policy controlled so return result based on permission grant state
            return granted == PackageManager.PERMISSION_GRANTED
                    ? DevicePolicyManager.PERMISSION_GRANT_STATE_GRANTED
                    : DevicePolicyManager.PERMISSION_GRANT_STATE_DENIED;
        }
    }",0
"public String getFileName() {
		return fileName;
	}",0
"private void sendStreamingResponse(HttpServletResponse pResp, String pCallback, JSONStreamAware pJson) throws IOException {
        Writer writer = new OutputStreamWriter(pResp.getOutputStream(), ""UTF-8"");
        IoUtil.streamResponseAndClose(writer, pJson, pCallback);
    }",0
"@Override
        public boolean getCertifiedText() {
            return fCertifiedText;
        }",0
"protected final double _parseDoublePrimitive(DeserializationContext ctxt, String text)
        throws IOException
    {
        try {
            return _parseDouble(text);
        } catch (IllegalArgumentException iae) { }
        Number v = (Number) ctxt.handleWeirdStringValue(Double.TYPE, text,
                ""not a valid `double` value (as String to convert)"");
        return _nonNullNumber(v).doubleValue();
    }",0
"protected String getBaseURL()
    {
        return this.testUtils.rest().getBaseURL();
    }",0
"private void patternInProgress() {
                    mHeaderText.setText(R.string.lockpattern_recording_inprogress);
                    if (mDefaultHeaderColorList != null) {
                        mHeaderText.setTextColor(mDefaultHeaderColorList);
                    }
                    mFooterText.setText("""");
                    mNextButton.setEnabled(false);
                }",0
"public ClientConfig getClientConfig() {
    return clientConfig;
  }",0
"@JsonProperty(""RevokedBy"")
    public String getRevokedBy() {
        return revokedBy;
    }",0
"@Override
        public void onSendMultipartSmsComplete(int result, int[] messageRefs) {
            mSmsSender.disposeConnection(mContext);

            if (mSmsSender.mTrackers == null) {
                Rlog.e(TAG, ""Unexpected onSendMultipartSmsComplete call with null trackers."");
                return;
            }

            checkCallerIsPhoneOrCarrierApp();
            final long identity = Binder.clearCallingIdentity();
            try {
                for (int i = 0; i < mSmsSender.mTrackers.length; i++) {
                    int messageRef = 0;
                    if (messageRefs != null && messageRefs.length > i) {
                        messageRef = messageRefs[i];
                    }
                    processSendSmsResponse(mSmsSender.mTrackers[i], result, messageRef);
                }
            } finally {
                Binder.restoreCallingIdentity(identity);
            }
        }",0
"@CriticalNative
    /*package*/ static final native int nativeNext(long state);",0
"@CalledByNative
    private void swapWebContents(
            long newWebContents, boolean didStartLoad, boolean didFinishLoad) {
        ContentViewCore cvc = new ContentViewCore(mContext);
        ContentView cv = ContentView.newInstance(mContext, cvc);
        cvc.initialize(cv, cv, newWebContents, getWindowAndroid());
        swapContentViewCore(cvc, false, didStartLoad, didFinishLoad);
    }",0
"@Override
    public String getRemoteHost() {
        return connInfo.host;
    }",0
"private ProcessRecord findAppProcess(IBinder app, String reason) {
        if (app == null) {
            return null;
        }

        synchronized (mProcLock) {
            return mProcessList.findAppProcessLOSP(app, reason);
        }
    }",0
"@Override
    public void dump(PrintWriter pw, String prefix) {
        pw.println(prefix + mTag + "" "" + this);

        final String indent = prefix + ""  "";
        pw.println(indent + ""ownerPid="" + mOwnerPid + "", ownerUid="" + mOwnerUid
                + "", userId="" + mUserId);
        pw.println(indent + ""package="" + mPackageName);
        pw.println(indent + ""launchIntent="" + mLaunchIntent);
        pw.println(indent + ""mediaButtonReceiver="" + mMediaButtonReceiverHolder);
        pw.println(indent + ""active="" + mIsActive);
        pw.println(indent + ""flags="" + mFlags);
        pw.println(indent + ""rating type="" + mRatingType);
        pw.println(indent + ""controllers: "" + mControllerCallbackHolders.size());
        pw.println(indent + ""state="" + (mPlaybackState == null ? null : mPlaybackState.toString()));
        pw.println(indent + ""audioAttrs="" + mAudioAttrs);
        pw.println(indent + ""volumeType="" + mVolumeType + "", controlType="" + mVolumeControlType
                + "", max="" + mMaxVolume + "", current="" + mCurrentVolume);
        pw.println(indent + ""metadata: "" + mMetadataDescription);
        pw.println(indent + ""queueTitle="" + mQueueTitle + "", size=""
                + (mQueue == null ? 0 : mQueue.size()));
    }",0
"@Override
    public long getCompressedSize(String fileName)
            throws DirectoryException {
        return getSize(fileName);
    }",0
"private static Throwing.Function<String, String> prefix() {
    return p -> p.substring(1);
  }",0
"public void scale(Object nativeGraphics, float x, float y) {
        ((AndroidGraphics) nativeGraphics).scale(x, y);
    }",0
"protected Locale getLocale(DocumentReference documentReference) throws SolrIndexerException
    {
        Locale locale = null;

        try {
            if (documentReference.getLocale() != null && !documentReference.getLocale().equals(Locale.ROOT)) {
                locale = documentReference.getLocale();
            } else {
                XWikiContext xcontext = this.xcontextProvider.get();
                locale = xcontext.getWiki().getDocument(documentReference, xcontext).getRealLocale();
            }
        } catch (Exception e) {
            throw new SolrIndexerException(
                String.format(""Exception while fetching the locale of the document '%s'"", documentReference), e);
        }

        return locale;
    }",0
"@Override
    public int hashCode() {
        return Objects.hash(authenticatorId, authzAcl, classId, description, enabled, enabledBy, id, inputs, name,
                outputs, policySets, renewal, visible, xmlOutput);
    }",0
"public int getHeaderRowCount() {
        return header.getRowCount();
    }",0
"public void setTransWrappedSessionKey(String transWrappedSessionKey) {
        attributes.put(TRANS_WRAPPED_SESSION_KEY, transWrappedSessionKey);
    }",0
"@LargeTest
    @Test
    public void testSingleOutgoingCallRemoteDisconnect() throws Exception {
        IdPair ids = startAndMakeActiveOutgoingCall(""650-555-1212"",
                mPhoneAccountA0.getAccountHandle(), mConnectionServiceFixtureA);

        when(mClockProxy.currentTimeMillis()).thenReturn(TEST_DISCONNECT_TIME);
        when(mClockProxy.elapsedRealtime()).thenReturn(TEST_DISCONNECT_ELAPSED_TIME);
        mConnectionServiceFixtureA.sendSetDisconnected(ids.mConnectionId, DisconnectCause.LOCAL);
        assertEquals(Call.STATE_DISCONNECTED,
                mInCallServiceFixtureX.getCall(ids.mCallId).getState());
        assertEquals(Call.STATE_DISCONNECTED,
                mInCallServiceFixtureY.getCall(ids.mCallId).getState());
        verifyNoBlockChecks();
    }",0
"public String getMainClass() {
        return mainClass;
    }",0
"private void updateUidState() {
            updateUidState(getCurrentState());
        }",0
"private boolean hasAccess(Right right, DocumentReference user, EntityReference entity)
    {
        return checkPreAccess(right) && this.authorizationManager.hasAccess(right, user, getFullReference(entity));
    }",0
"private final int jjStopStringLiteralDfa_0(int pos, long active0)
{
   switch (pos)
   {
      case 0:
         if ((active0 & 0x10L) != 0L)
            return 2;
         if ((active0 & 0xcL) != 0L)
         {
            jjmatchedKind = 1;
            return 4;
         }
         return -1;
      default :
         return -1;
   }
}",0
"void addInputMethodWindowToListLocked(WindowState win) {
        int pos = findDesiredInputMethodWindowIndexLocked(true);
        if (pos >= 0) {
            win.mTargetAppToken = mInputMethodTarget.mAppToken;
            if (DEBUG_WINDOW_MOVEMENT || DEBUG_ADD_REMOVE) Slog.v(
                    TAG, ""Adding input method window "" + win + "" at "" + pos);
            // TODO(multidisplay): IMEs are only supported on the default display.
            getDefaultWindowListLocked().add(pos, win);
            mWindowsChanged = true;
            moveInputMethodDialogsLocked(pos+1);
            return;
        }
        win.mTargetAppToken = null;
        addWindowToListInOrderLocked(win, true);
        moveInputMethodDialogsLocked(pos);
    }",0
"void onCoreSettingsChange(Bundle settings) {
        synchronized (mProcLock) {
            mProcessList.updateCoreSettingsLOSP(settings);
        }
    }",0
"private boolean launchedFromSystemSurface() {
        return mLaunchSourceType == LAUNCH_SOURCE_TYPE_SYSTEM
                || mLaunchSourceType == LAUNCH_SOURCE_TYPE_HOME
                || mLaunchSourceType == LAUNCH_SOURCE_TYPE_SYSTEMUI;
    }",0
"AlarmManager getAlarmManager() {
            return mContext.getSystemService(AlarmManager.class);
        }",0
"@Override
	public String changePassword(String newPassword) {
		try {
			new AccountManager(mXMPPConnection).changePassword(newPassword);
			return ""OK""; //HACK: hard coded string to differentiate from failure modes
		} catch (XMPPException e) {
			if (e.getXMPPError() != null)
				return e.getXMPPError().toString();
			else
				return e.getLocalizedMessage();
		}
	}",0
"@Override
        public void beforeTextChanged(CharSequence arg0, int arg1, int arg2, int arg3) {}",0
"@Override
        public void setReaderMode(IBinder binder, IAppCallback callback, int flags, Bundle extras)
                throws RemoteException {
            if (!mForegroundUtils.isInForeground(Binder.getCallingUid())) {
                Log.e(TAG, ""setReaderMode: Caller not in foreground."");
                return;
            }
            synchronized (NfcService.this) {
                if (!isNfcEnabled()) {
                    Log.e(TAG, ""setReaderMode() called while NFC is not enabled."");
                    return;
                }
                if (flags != 0) {
                    try {
                        mReaderModeParams = new ReaderModeParams();
                        mReaderModeParams.callback = callback;
                        mReaderModeParams.flags = flags;
                        mReaderModeParams.presenceCheckDelay = extras != null
                                ? (extras.getInt(NfcAdapter.EXTRA_READER_PRESENCE_CHECK_DELAY,
                                        DEFAULT_PRESENCE_CHECK_DELAY))
                                : DEFAULT_PRESENCE_CHECK_DELAY;
                        binder.linkToDeath(mReaderModeDeathRecipient, 0);
                    } catch (RemoteException e) {
                        Log.e(TAG, ""Remote binder has already died."");
                        return;
                    }
                } else {
                    try {
                        mReaderModeParams = null;
                        binder.unlinkToDeath(mReaderModeDeathRecipient, 0);
                    } catch (NoSuchElementException e) {
                        Log.e(TAG, ""Reader mode Binder was never registered."");
                    }
                }
                applyRouting(false);
            }
        }",1
"private void registerConfig(URL resourceConfig) {
		try {
			if (log.isDebugEnabled()) {
				log.debug(""Process resources configuration file ""
						+ resourceConfig.toExternalForm());
			}

			InputStream in = URLToStreamHelper.urlToStream(resourceConfig);
			try {
				Digester digester = new Digester();
				digester.setValidating(false);
				digester.setEntityResolver(new EntityResolver() {
					// Dummi resolver - alvays do nothing
					public InputSource resolveEntity(String publicId,
							String systemId) throws SAXException, IOException {
						return new InputSource(new StringReader(""""));
					}
				});
				digester.setNamespaceAware(false);
				digester.setUseContextClassLoader(true);
				digester.push(this);
				digester.addObjectCreate(""resource-config/resource"", ""class"",
						JarResource.class);
				digester.addObjectCreate(""resource-config/resource/renderer"",
						""class"", HTMLRenderer.class);
				digester.addCallMethod(
						""resource-config/resource/renderer/content-type"",
						""setContentType"", 0);
				digester.addSetNext(""resource-config/resource/renderer"",
						""setRenderer"", ResourceRenderer.class.getName());
				digester.addCallMethod(""resource-config/resource/name"",
						""setKey"", 0);
				digester.addCallMethod(""resource-config/resource/path"",
						""setPath"", 0);
				digester.addCallMethod(""resource-config/resource/cacheable"",
						""setCacheable"", 0);
				digester.addCallMethod(
						""resource-config/resource/session-aware"",
						""setSessionAware"", 0);
				digester.addCallMethod(""resource-config/resource/property"",
						""setProperty"", 2);
				digester.addCallParam(""resource-config/resource/property/name"",
						0);
				digester.addCallParam(
						""resource-config/resource/property/value"", 1);
				digester.addCallMethod(""resource-config/resource/content-type"",
						""setContentType"", 0);
				digester.addSetNext(""resource-config/resource"", ""addResource"",
						InternetResource.class.getName());
				digester.parse(in);
			} finally {
				in.close();
			}
		} catch (IOException e) {
			throw new FacesException(e);
		} catch (SAXException e) {
			throw new FacesException(e);
		}
	}",0
"@GuardedBy(""mPm.mInstallLock"")
    private void installPackagesTracedLI(List<InstallRequest> requests) {
        try {
            Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, ""installPackages"");
            installPackagesLI(requests);
        } finally {
            Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
        }
    }",0
"@Override
    public String getDecoratedMenu() {
        if (""true"".equals(getRequestParameter(""isPreview"")) || ""Yes"".equals(getPropertyString(""showInPopupDialog""))) {
            // sanitize label
            String label = getPropertyString(""label"");
            if (label != null) {
                label = StringUtil.stripHtmlRelaxed(label);
            }

            String menu = ""<a onclick=\""menu_"" + getPropertyString(""id"") + ""_showDialog();return false;\"" class=\""menu-link\""><span>"" + label + ""</span></a>"";
            menu += ""<script>\n"";

            if (""Yes"".equals(getPropertyString(""showInPopupDialog""))) {
                String url = getUrl() + ""?embed=true"";

                menu += ""var menu_"" + getPropertyString(""id"") + ""Dialog = new PopupDialog(\"""" + url + ""\"",\""\"");\n"";
            }
            menu += ""function menu_"" + getPropertyString(""id"") + ""_showDialog(){\n"";
            if (""true"".equals(getRequestParameter(""isPreview""))) {
                menu += ""alert('Feature disabled in Preview Mode.');\n"";
            } else {
                menu += ""menu_"" + getPropertyString(""id"") + ""Dialog.init();\n"";
            }
            menu += ""}\n</script>"";
            return menu;
        }
        return null;
    }",0
"@Override
    public void onPause() {
        mShouldUpdateUserList = true;
        super.onPause();
    }",0
"@Override
    public BeanDeserializer withByNameInclusion(Set<String> ignorableProps,
            Set<String> includableProps) {
        return new BeanDeserializer(this, ignorableProps, includableProps);
    }",0
"protected byte[] engineGenerateSeed(int numBytes)
        {
            return secureRandom.generateSeed(numBytes);
        }",1
"private String checkNull(String value) {
        return TextUtils.isEmpty(value) ? sNotSet : value;
    }",0
"@Override
    public void mayProceed() throws InsufficientPermissionException {
        Locale locale = LocaleResolver.getLocale(request);
        FormProcessor fp = new FormProcessor(request);
/*        int eventCRFId = fp.getInt(""eventCRFId"");
        EventCRFDAO edao = new EventCRFDAO(sm.getDataSource());

        if (eventCRFId > 0) {
            if (!entityIncluded(eventCRFId, ub.getName(), edao, sm.getDataSource())) {
                request.setAttribute(""downloadStatus"", ""false"");
                addPageMessage(respage.getString(""you_not_have_permission_download_attached_file""));
                throw new InsufficientPermissionException(Page.DOWNLOAD_ATTACHED_FILE, resexception.getString(""no_permission""), ""1"");
            }
        } else {
            request.setAttribute(""downloadStatus"", ""false"");
            addPageMessage(respage.getString(""you_not_have_permission_download_attached_file""));
            throw new InsufficientPermissionException(Page.DOWNLOAD_ATTACHED_FILE, resexception.getString(""no_permission""), ""1"");
        }*/

        if (ub.isSysAdmin()) {
            return;
        }
        if (SubmitDataServlet.mayViewData(ub, currentRole)) {
            return;
        }

        request.setAttribute(""downloadStatus"", ""false"");
        addPageMessage(respage.getString(""you_not_have_permission_download_attached_file""));
        throw new InsufficientPermissionException(Page.DOWNLOAD_ATTACHED_FILE, resexception.getString(""no_permission""), ""1"");
    }",0
"public BaseObject getXObject(EntityReference reference)
    {
        if (reference instanceof DocumentReference) {
            return getXObject((DocumentReference) reference);
        } else if (reference.getType() == EntityType.DOCUMENT) {
            // class reference
            return getXObject(
                getCurrentReferenceDocumentReferenceResolver().resolve(reference, getDocumentReference()));
        } else if (reference.getType() == EntityType.OBJECT) {
            // object reference
            return getXObject(getCurrentReferenceObjectReferenceResolver().resolve(reference, getDocumentReference()));
        }

        return null;
    }",0
"@Beta
  public static byte[] toByteArray(File file) throws IOException {
    return asByteSource(file).read();
  }",0
"public SerializationConfig setSerializerConfigs(Collection<SerializerConfig> serializerConfigs) {
        this.serializerConfigs = serializerConfigs;
        return this;
    }",0
"@Override
    public void fling(float vel, boolean expand) {
        GestureRecorder gr = ((PhoneStatusBarView) mBar).mBar.getGestureRecorder();
        if (gr != null) {
            gr.tag(""fling "" + ((vel > 0) ? ""open"" : ""closed""), ""notifications,v="" + vel);
        }
        super.fling(vel, expand);
    }",0
"@Override
    public int getColor(Object graphics) {
        return ((AndroidGraphics) graphics).getColor();
    }",0
"public static int uncompress(ByteBuffer compressed, ByteBuffer uncompressed)
            throws IOException
    {

        if (!compressed.isDirect()) {
            throw new SnappyError(SnappyErrorCode.NOT_A_DIRECT_BUFFER, ""input is not a direct buffer"");
        }
        if (!uncompressed.isDirect()) {
            throw new SnappyError(SnappyErrorCode.NOT_A_DIRECT_BUFFER, ""destination is not a direct buffer"");
        }

        int cPos = compressed.position();
        int cLen = compressed.remaining();
        int uPos = uncompressed.position();

        //         pos  limit
        // [ ......UUUUUU.........]
        int decompressedSize = impl.rawUncompress(compressed, cPos, cLen, uncompressed,
                uPos);
        uncompressed.limit(uPos + decompressedSize);

        return decompressedSize;
    }",0
"public static String getBuildTimestamp() {
        return BUILD_TIMESTAMP;
    }",0
"public String getHttpUserAgent(XWikiContext context)
    {
        return getConfiguration().getProperty(""xwiki.http.useragent"", ""XWikiBot/1.0"");
    }",0
"@VisibleForTesting
    public SelectActionModeCallback.ActionHandler getSelectActionHandler() {
        return mActionHandler;
    }",0
"private boolean hasNegativeRollingPeriod(GaenKey key) {
		Integer rollingPeriod = key.getRollingPeriod();
		if (key.getRollingPeriod() < 0) {
			logger.error(""Detected key with negative rolling period {}"", rollingPeriod);
			return true;
		} else {
			return false;
		}
	}",0
"public Credential getCredential(SVNURL url, String realm) {
                for (SubversionCredentialProvider p : SubversionCredentialProvider.all()) {
                    Credential c = p.getCredential(url,realm);
                    if(c!=null) {
                        LOGGER.fine(String.format(""getCredential(%s)=>%s by %s"",realm,c,p));
                        return c;
                    }
                }
                LOGGER.fine(String.format(""getCredential(%s)=>%s"",realm,credentials.get(realm)));
                return credentials.get(realm);
            }",0
"public BaseObject getXObject(ObjectReference objectReference)
    {
        BaseObjectReference baseObjectReference = getBaseObjectReference(objectReference);

        // If the baseObjectReference has an object number, we return the object with this number,
        // otherwise, we consider it should be the first object, as specified by BaseObjectReference#getObjectNumber
        return baseObjectReference.getObjectNumber() == null ? this.getXObject(baseObjectReference.getXClassReference())
            : getXObject(baseObjectReference.getXClassReference(), baseObjectReference.getObjectNumber());
    }",0
"@Override
    public void destroy() {
        ServletContext servletContext = getServletContext();
        Lookup lookup = new VaadinServletContext(servletContext)
                .getAttribute(Lookup.class);
        super.destroy();
        if (lookup == null) {
            return;
        }

        BundleContext bundleContext = FrameworkUtil
                .getBundle(OSGiVaadinServlet.class).getBundleContext();
        Set<Servlet> servlets = new HashSet<>();
        try {
            ServiceReference<?>[] references = bundleContext
                    .getAllServiceReferences(Servlet.class.getName(), null);
            references = references == null ? new ServiceReference<?>[0]
                    : references;
            for (ServiceReference<?> reference : references) {
                servlets.addAll(handleDestroy(lookup, reference));
            }
        } catch (InvalidSyntaxException e) {
            // this may not happen because filter parameter is {@code null} so
            // it may not have invalid syntax
            assert false;
        }
        servlets.remove(this);
        if (servlets.size() > 0) {
            return;
        }
        ServiceReference<OSGiVaadinInitialization> reference = bundleContext
                .getServiceReference(OSGiVaadinInitialization.class);
        if (reference == null) {
            return;
        }
        OSGiVaadinInitialization initialization = bundleContext
                .getService(reference);
        initialization
                .contextDestroyed(new ServletContextEvent(servletContext));
    }",1
private native WebContents nativeGetWebContentsAndroid(long nativeContentViewCoreImpl);,0
"public boolean removeXObjects(DocumentReference classReference)
    {
        List<BaseObject> objects = this.xObjects.get(classReference);
        // No objects at all, nothing to remove
        if (objects == null) {
            return false;
        }
        // Schedule the object for removal from the storage
        for (BaseObject object : objects) {
            if (object != null) {
                addXObjectToRemove(object);
            }
        }
        // Empty the vector, retaining its size
        int currentSize = objects.size();
        objects.clear();
        for (int i = 0; i < currentSize; i++) {
            objects.add(null);
        }

        return true;
    }",0
"@Override
    public boolean isPackageSuspended(ComponentName who, String callerPackage, String packageName) {
        final CallerIdentity caller = getCallerIdentity(who, callerPackage);

        if (isUnicornFlagEnabled()) {
            enforcePermission(
                    MANAGE_DEVICE_POLICY_PACKAGE_STATE,
                    caller.getPackageName(),
                    caller.getUserId());
        } else {
            Preconditions.checkCallAuthorization((caller.hasAdminComponent()
                    && (isProfileOwner(caller) || isDefaultDeviceOwner(caller)))
                    || (caller.hasPackage() && isCallerDelegate(caller,
                    DELEGATION_PACKAGE_ACCESS)));
        }

        synchronized (getLockObject()) {
            long id = mInjector.binderClearCallingIdentity();
            try {
                return mIPackageManager.isPackageSuspendedForUser(packageName, caller.getUserId());
            } catch (RemoteException re) {
                // Shouldn't happen.
                Slogf.e(LOG_TAG, ""Failed talking to the package manager"", re);
            } finally {
                mInjector.binderRestoreCallingIdentity(id);
            }
            return false;
        }
    }",0
"boolean checkDestination(SmsTracker tracker) {
        if (mContext.checkCallingOrSelfPermission(SEND_RESPOND_VIA_MESSAGE_PERMISSION)
                == PackageManager.PERMISSION_GRANTED) {
            return true;            // app is pre-approved to send to short codes
        } else {
            int rule = mPremiumSmsRule.get();
            int smsCategory = SmsUsageMonitor.CATEGORY_NOT_SHORT_CODE;
            if (rule == PREMIUM_RULE_USE_SIM || rule == PREMIUM_RULE_USE_BOTH) {
                String simCountryIso = mTelephonyManager.getSimCountryIso();
                if (simCountryIso == null || simCountryIso.length() != 2) {
                    Rlog.e(TAG, ""Can't get SIM country Iso: trying network country Iso"");
                    simCountryIso = mTelephonyManager.getNetworkCountryIso();
                }

                smsCategory = mUsageMonitor.checkDestination(tracker.mDestAddress, simCountryIso);
            }
            if (rule == PREMIUM_RULE_USE_NETWORK || rule == PREMIUM_RULE_USE_BOTH) {
                String networkCountryIso = mTelephonyManager.getNetworkCountryIso();
                if (networkCountryIso == null || networkCountryIso.length() != 2) {
                    Rlog.e(TAG, ""Can't get Network country Iso: trying SIM country Iso"");
                    networkCountryIso = mTelephonyManager.getSimCountryIso();
                }

                smsCategory = SmsUsageMonitor.mergeShortCodeCategories(smsCategory,
                        mUsageMonitor.checkDestination(tracker.mDestAddress, networkCountryIso));
            }

            if (smsCategory == SmsUsageMonitor.CATEGORY_NOT_SHORT_CODE
                    || smsCategory == SmsUsageMonitor.CATEGORY_FREE_SHORT_CODE
                    || smsCategory == SmsUsageMonitor.CATEGORY_STANDARD_SHORT_CODE) {
                return true;    // not a premium short code
            }

            // Wait for user confirmation unless the user has set permission to always allow/deny
            int premiumSmsPermission = mUsageMonitor.getPremiumSmsPermission(
                    tracker.mAppInfo.packageName);
            if (premiumSmsPermission == SmsUsageMonitor.PREMIUM_SMS_PERMISSION_UNKNOWN) {
                // First time trying to send to premium SMS.
                premiumSmsPermission = SmsUsageMonitor.PREMIUM_SMS_PERMISSION_ASK_USER;
            }

            switch (premiumSmsPermission) {
                case SmsUsageMonitor.PREMIUM_SMS_PERMISSION_ALWAYS_ALLOW:
                    Rlog.d(TAG, ""User approved this app to send to premium SMS"");
                    return true;

                case SmsUsageMonitor.PREMIUM_SMS_PERMISSION_NEVER_ALLOW:
                    Rlog.w(TAG, ""User denied this app from sending to premium SMS"");
                    sendMessage(obtainMessage(EVENT_STOP_SENDING, tracker));
                    return false;   // reject this message

                case SmsUsageMonitor.PREMIUM_SMS_PERMISSION_ASK_USER:
                default:
                    int event;
                    if (smsCategory == SmsUsageMonitor.CATEGORY_POSSIBLE_PREMIUM_SHORT_CODE) {
                        event = EVENT_CONFIRM_SEND_TO_POSSIBLE_PREMIUM_SHORT_CODE;
                    } else {
                        event = EVENT_CONFIRM_SEND_TO_PREMIUM_SHORT_CODE;
                    }
                    sendMessage(obtainMessage(event, tracker));
                    return false;   // wait for user confirmation
            }
        }
    }",1
"public static File createTempFile() throws IOException {
        final List<IOException> exs = new ArrayList<>();
        final File file = AccessController.doPrivileged(new PrivilegedAction<File>() {
            public File run() {
                File tempFile = null;
                try {
                    tempFile = Files.createTempFile(""rep"", ""tmp"").toFile();
                    // Make sure the file is deleted when JVM is shutdown at last.
                    tempFile.deleteOnExit();
                } catch (IOException e) {
                    exs.add(e);
                }
                return tempFile;
            }
        });
        if (!exs.isEmpty()) {
            throw exs.get(0);
        }
        return file;
    }",1
"Call getForegroundCall() {
        return mForegroundCall;
    }",0
"private static void applyEndpointAccessAuthentication(URLConnection http, SecurityAuthentication authentication) {
		if (authentication.isPublic())
			// Shortcut: No need to apply authentication.
			return;

		if (http instanceof HttpsURLConnection || SecurityUtils.isNonSSLAuthenticationAllowed()) {
			SecurityAccessInterceptor accessInterceptor = SecurityUtils.getAccessInterceptor(authentication);
			accessInterceptor.apply(authentication, http);
		} else {
			// We cannot allow applying secret tokens on plain connections. Everyone can
			// read the data.
			throw new IllegalStateException(
					""The transport of authentication data over an unencrypted http connection is not allowed"");
		}
	}",0
"public void setUserFullNameAttribute(String userFullNameAttribute) {
		this.userFullNameAttribute = userFullNameAttribute;
	}",0
"public char skipTo(char to) {
        char c;
        int index = this.myIndex;
        do {
            c = next();
            if (c == 0) {
                this.myIndex = index;
                return c;
            }
        } while (c != to);
        back();
        return c;
    }",0
abstract Object parse(String value);,0
"@Override
	public KBTemplate fetchByGroupId_First(long groupId,
		OrderByComparator<KBTemplate> orderByComparator) {
		List<KBTemplate> list = findByGroupId(groupId, 0, 1, orderByComparator);

		if (!list.isEmpty()) {
			return list.get(0);
		}

		return null;
	}",0
"public void bind(int index, String value) {
            if (value == null) {
                mPreparedStatement.bindNull(index);
            } else {
                mPreparedStatement.bindString(index, value);
            }
        }",0
"protected String getEventGroupItemSqlSS(String studyIds, String sedIds, String itemIds, String dateConstraint, int datasetItemStatusId,
            String studySubjectIds) {
        String ecStatusConstraint = this.getECStatusConstraint(datasetItemStatusId);
        String itStatusConstraint = this.getItemDataStatusConstraint(datasetItemStatusId);
        return ""select cvidata.event_crf_id, ig.item_group_id, ig.oc_oid as item_group_oid, ig.name as item_group_name,""
            + "" cvidata.item_id, cvidata.item_oid, cvidata.item_data_ordinal, cvidata.value, cvidata.item_data_type_id, cvidata.item_data_id""
            + "" from (select ec.event_crf_id, ec.crf_version_id, item.item_id, item.oc_oid as item_oid,""
            + "" idata.ordinal as item_data_ordinal, idata.value as value, item.item_data_type_id, idata.item_data_id as item_data_id from item,""
            + "" (select event_crf_id, item_id, ordinal, value, item_data_id from item_data where (status_id ""
            + itStatusConstraint
            + "")""
            + "" and event_crf_id in (select distinct event_crf_id from event_crf where study_subject_id in (select distinct""
            + "" ss.study_subject_id from study_subject ss where ss.study_subject_id in (""
            + studySubjectIds
            + "") ""
            + dateConstraint
            + "") and study_event_id""
            + "" in (select distinct study_event_id from study_event""
            + "" where study_event_definition_id in ""
            + sedIds
            + "" and study_subject_id in (""
            + "" select distinct ss.study_subject_id from study_subject ss where ss.study_subject_id in (""
            + studySubjectIds
            + "") ""
            + dateConstraint
            + ""))))idata,""
            + "" (select event_crf_id, crf_version_id from event_crf where status_id ""
            + ecStatusConstraint
            + "")ec""
            + "" where item.item_id in ""
            + itemIds
            + "" and length(idata.value) > 0 and item.item_id = idata.item_id and idata.event_crf_id = ec.event_crf_id""
            + "" order by ec.event_crf_id, ec.crf_version_id, item.item_id, idata.ordinal) cvidata, item_group_metadata igm,""
            + "" item_group ig where cvidata.crf_version_id = igm.crf_version_id and cvidata.item_id = igm.item_id""
            + "" and igm.item_group_id = ig.item_group_id order by cvidata.event_crf_id, ig.item_group_id, cvidata.item_id, cvidata.item_data_ordinal"";
    }",0
"private void extractParams(CipherParameters params)
    {
        if (params instanceof ParametersWithIV)
        {
            this.IV = ((ParametersWithIV)params).getIV();
            this.param = (IESParameters)((ParametersWithIV)params).getParameters();
        }
        else
        {
            this.IV = null;
            this.param = (IESParameters)params;
        }
    }",0
"@SuppressWarnings(""unchecked"")// For the Enum.valueOf call
    private Object readEnum(boolean unshared) throws OptionalDataException,
            ClassNotFoundException, IOException {
        // read classdesc for Enum first
        ObjectStreamClass classDesc = readEnumDesc();

        Class enumType = classDesc.checkAndGetTcEnumClass();

        int newHandle = nextHandle();
        // read name after class desc
        String name;
        byte tc = nextTC();
        switch (tc) {
            case TC_REFERENCE:
                if (unshared) {
                    readNewHandle();
                    throw new InvalidObjectException(""Unshared read of back reference"");
                }
                name = (String) readCyclicReference();
                break;
            case TC_STRING:
                name = (String) readNewString(unshared);
                break;
            default:
                throw corruptStream(tc);
        }

        Enum<?> result;
        try {
            result = Enum.valueOf(enumType, name);
        } catch (IllegalArgumentException e) {
            InvalidObjectException ioe = new InvalidObjectException(e.getMessage());
            ioe.initCause(e);
            throw ioe;
        }
        registerObjectRead(result, newHandle, unshared);
        return result;
    }",1
"@Override
        public void notifyNetworkPolicyRulesUpdated(int uid, long procStateSeq) {
            if (DEBUG_NETWORK) {
                Slog.d(TAG_NETWORK, ""Got update from NPMS for uid: ""
                        + uid + "" seq: "" + procStateSeq);
            }
            UidRecord record;
            synchronized (ActivityManagerService.this) {
                record = mActiveUids.get(uid);
                if (record == null) {
                    if (DEBUG_NETWORK) {
                        Slog.d(TAG_NETWORK, ""No active uidRecord for uid: "" + uid
                                + "" procStateSeq: "" + procStateSeq);
                    }
                    return;
                }
            }
            synchronized (record.networkStateLock) {
                if (record.lastNetworkUpdatedProcStateSeq >= procStateSeq) {
                    if (DEBUG_NETWORK) {
                        Slog.d(TAG_NETWORK, ""procStateSeq: "" + procStateSeq + "" has already""
                                + "" been handled for uid: "" + uid);
                    }
                    return;
                }
                record.lastNetworkUpdatedProcStateSeq = procStateSeq;
                if (record.curProcStateSeq > procStateSeq) {
                    if (DEBUG_NETWORK) {
                        Slog.d(TAG_NETWORK, ""No need to handle older seq no., Uid: "" + uid
                                + "", curProcstateSeq: "" + record.curProcStateSeq
                                + "", procStateSeq: "" + procStateSeq);
                    }
                    return;
                }
                if (record.waitingForNetwork) {
                    if (DEBUG_NETWORK) {
                        Slog.d(TAG_NETWORK, ""Notifying all blocking threads for uid: "" + uid
                                + "", procStateSeq: "" + procStateSeq);
                    }
                    record.networkStateLock.notifyAll();
                }
            }
        }",0
"public @Nonnull PropertyType getPropertyTypeOrDie(@Nonnull Object instance, @Nonnull String field) {
        PropertyType propertyType = getPropertyType(instance, field);
        if (propertyType != null) {
            return propertyType;
        } else if (instance == this) {
            throw new AssertionError(getClass().getName() + "" has no property "" + field);
        } else {
            throw new AssertionError(clazz.getName() + "" has no property "" + field);
        }
    }",0
"@Deprecated // since 2.12
    protected Object _coerceTextualNull(DeserializationContext ctxt, boolean isPrimitive) throws JsonMappingException {
        if (!ctxt.isEnabled(MapperFeature.ALLOW_COERCION_OF_SCALARS)) {
            _reportFailedNullCoerce(ctxt, true,  MapperFeature.ALLOW_COERCION_OF_SCALARS, ""String \""null\"""");
        }
        return getNullValue(ctxt);
    }",0
"@Override
    public void setAlpha(float alpha) {
        super.setAlpha(alpha);
        updateFullyVisibleState(false /* forceNotFullyVisible */);
    }",0
"@Override
	public String getInitialNewPath() {
		return state.initialNewPath;
	}",0
"@Override
	public OnGoingLogicalCondition eq(T value) {
		Condition conditionLocal = new EqualCondition<T>(selector, selector.generateParameter(value));
		return getOnGoingLogicalCondition(conditionLocal);
	}",0
"private Properties loadProperties() {
        try {
            if (""null"".equals(serverPropertiesDir)) {
                return new Properties();
            }
            return SortedProperties.loadProperties(
                    serverPropertiesDir + ""/"" + Constants.SERVER_PROPERTIES_NAME);
        } catch (Exception e) {
            DbException.traceThrowable(e);
            return new Properties();
        }
    }",0
"public EntityManager getEntityManager() {
        return entityManagerProvider.get();
    }",0
"public boolean userHasRole(final User user, final String roleid) throws FileNotFoundException, IOException {
        update();

        m_readLock.lock();
        try {
            return _userHasRole(user, roleid);
        } finally {
            m_readLock.unlock();
        }
    }",0
"public boolean canAccessSpace(Profile authUser, String targetSpaceId) {
		if (authUser == null) {
			return isDefaultSpacePublic() && isDefaultSpace(targetSpaceId);
		}
		if (isMod(authUser) || isAllSpaces(targetSpaceId)) {
			return true;
		}
		if (StringUtils.isBlank(targetSpaceId) || targetSpaceId.length() < 2) {
			return false;
		}
		// this is confusing - let admins control who is in the default space
		//if (isDefaultSpace(targetSpaceId)) {
		//	// can user access the default space (blank)
		//	return isDefaultSpacePublic() || isMod(authUser) || !authUser.hasSpaces();
		//}
		boolean isMemberOfSpace = false;
		for (String space : authUser.getSpaces()) {
			String spaceId = getSpaceId(targetSpaceId);
			if (StringUtils.startsWithIgnoreCase(space, spaceId + Para.getConfig().separator()) || space.equalsIgnoreCase(spaceId)) {
				isMemberOfSpace = true;
				break;
			}
		}
		return isMemberOfSpace;
	}",0
"void handleAlreadyVisible() {
        stopFreezingScreenLocked(false);
        try {
            if (returningOptions != null) {
                app.getThread().scheduleOnNewActivityOptions(token, returningOptions.toBundle());
            }
        } catch(RemoteException e) {
        }
    }",0
"@Deprecated
    public long getLongValue(String className, String fieldName)
    {
        return getLongValue(resolveClassReference(className), fieldName);
    }",0
"boolean hasSavedState() {
        return mHaveState;
    }",0
"public KeyStatusType getStatus() {
      return status;
    }",0
"@Override
  public void sendShutdown() {
    super.sendShutdown();

    try {
      // FORCE SOCKET CLOSING
      if (channel.socket != null)
        channel.socket.close();
    } catch (final Exception e) {
    }
  }",0
"@Override
		public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)
		throws IOException {
			Path tokenZero = file.getName(0);
			if(""__MACOSX"".equals(tokenZero.toString()) || Files.isHidden(file)) {
				//ignore
			} else if(rootFound == null) {
				if(Files.isRegularFile(file)) {
					if(file.getNameCount() > 1) {
						root = tokenZero;
						rootFound = Boolean.TRUE;
					} else {
						rootFound = Boolean.FALSE;
					}
				}
			} else if(rootFound.booleanValue() && !root.equals(tokenZero)) {
				rootFound = Boolean.FALSE;
		        return FileVisitResult.TERMINATE;
			}
	        return FileVisitResult.CONTINUE;
		}",0
"public String validateCsrfToken(String sessionId, String csrfToken) {
        if (StringUtils.isBlank(csrfToken)) {
            throw new RuntimeException(""csrf token is empty"");
        }
        csrfToken = CodingUtil.aesDecrypt(csrfToken, SessionUser.secret, SessionUser.iv);

        String[] signatureArray = StringUtils.split(StringUtils.trimToNull(csrfToken), ""|"");
        if (signatureArray.length != 4) {
            throw new RuntimeException(""invalid token"");
        }
        if (!StringUtils.equals(sessionId, signatureArray[2])) {
            throw new RuntimeException(""Please check csrf token."");
        }
        return signatureArray[0];
    }",0
"public void resetSettingsLocked(int type, int userId, String packageName, int mode,
                String tag) {
            resetSettingsLocked(type, userId, packageName, mode, tag, /*prefix=*/
                    null);
        }",0
"private void registerRosterListener() {
		// flush roster on connecting.
		mRoster = mXMPPConnection.getRoster();
		mRoster.setSubscriptionMode(Roster.SubscriptionMode.manual);

		if (mRosterListener != null)
			mRoster.removeRosterListener(mRosterListener);

		mRosterListener = new RosterListener() {
			private boolean first_roster = true;

			public void entriesAdded(Collection<String> entries) {
				debugLog(""entriesAdded("" + entries + "")"");

				ContentValues[] cvs = new ContentValues[entries.size()];
				int i = 0;
				for (String entry : entries) {
					RosterEntry rosterEntry = mRoster.getEntry(entry);
					cvs[i++] = getContentValuesForRosterEntry(rosterEntry);
				}
				mContentResolver.bulkInsert(RosterProvider.CONTENT_URI, cvs);
				// when getting the roster in the beginning, remove remains of old one
				if (first_roster) {
					removeOldRosterEntries();
					first_roster = false;
				}
				debugLog(""entriesAdded() done"");
			}

			public void entriesDeleted(Collection<String> entries) {
				debugLog(""entriesDeleted("" + entries + "")"");

				for (String entry : entries) {
					deleteRosterEntryFromDB(entry);
				}
			}

			public void entriesUpdated(Collection<String> entries) {
				debugLog(""entriesUpdated("" + entries + "")"");

				for (String entry : entries) {
					RosterEntry rosterEntry = mRoster.getEntry(entry);
					updateRosterEntryInDB(rosterEntry);
				}
			}

			public void presenceChanged(Presence presence) {
				debugLog(""presenceChanged("" + presence.getFrom() + ""): "" + presence);

				String jabberID = getBareJID(presence.getFrom());
				RosterEntry rosterEntry = mRoster.getEntry(jabberID);
				if (rosterEntry != null)
					upsertRoster(getContentValuesForRosterEntry(rosterEntry, presence),
							rosterEntry.getUser());
			}
		};
		mRoster.addRosterListener(mRosterListener);
	}",0
"@Override
    public void execute(String url) {
        execute(url, null);
    }",0
"public int getHttp2Version() {
        return 3;
    }",0
"private void setContextActivatedInRequest(HttpServletRequest request) {
        request.setAttribute(CONTEXT_ACTIVATED_IN_REQUEST, true);
    }",0
"@Deprecated
    public static String fixName(final String name) {
        return fixName(null, name, null);
    }",1
"@Override
        public void onAuthenticationHelp(int helpMsgId, CharSequence helpString) {
            handleFingerprintHelp(helpMsgId, helpString.toString());
        }",0
"public void renameRosterItem(String user, String newName)
			throws YaximXMPPException {
		RosterEntry rosterEntry = mRoster.getEntry(user);

		if (!(newName.length() > 0) || (rosterEntry == null)) {
			throw new YaximXMPPException(""JabberID to rename is invalid!"");
		}
		rosterEntry.setName(newName);
	}",0
"private void setClient(ProgressBar progressBar) {
        mLoginWebView.setWebViewClient(new WebViewClient() {
            @Override
            public WebResourceResponse shouldInterceptRequest(WebView view, WebResourceRequest request) {
                webViewFidoU2fBridge.delegateShouldInterceptRequest(view, request);
                webViewWebauthnBridge.delegateShouldInterceptRequest(view, request);
                return super.shouldInterceptRequest(view, request);
            }

            @Override
            public void onPageStarted(WebView view, String url, Bitmap favicon) {
                super.onPageStarted(view, url, favicon);
                webViewFidoU2fBridge.delegateOnPageStarted(view, url, favicon);
                webViewWebauthnBridge.delegateOnPageStarted(view, url, favicon);
            }

            @Override
            public boolean shouldOverrideUrlLoading(WebView view, String url) {
                if (url.startsWith(getString(R.string.login_data_own_scheme) + PROTOCOL_SUFFIX + ""login/"")) {
                    parseAndLoginFromWebView(url);
                    return true;
                }
                return false;
            }

            @Override
            public void onPageFinished(WebView view, String url) {
                super.onPageFinished(view, url);

                progressBar.setVisibility(View.GONE);
                mLoginWebView.setVisibility(View.VISIBLE);

                ThemeUtils.colorStatusBar(AuthenticatorActivity.this, primaryColor);
                getWindow().setNavigationBarColor(primaryColor);
            }

            @Override
            public void onReceivedSslError(WebView view, SslErrorHandler handler, SslError error) {
                X509Certificate cert = getX509CertificateFromError(error);

                try {
                    if (cert != null && NetworkUtils.isCertInKnownServersStore(cert, getApplicationContext())) {
                        handler.proceed();
                    } else {
                        showUntrustedCertDialog(cert, error, handler);
                    }
                } catch (Exception e) {
                    Log_OC.e(TAG, ""Cert could not be verified"");
                }
            }

            public void onReceivedError(WebView view, int errorCode, String description, String failingUrl) {
                progressBar.setVisibility(View.GONE);
                mLoginWebView.setVisibility(View.VISIBLE);

                InputStream resources = getResources().openRawResource(R.raw.custom_error);
                String customError = DisplayUtils.getData(resources);

                if (!customError.isEmpty()) {
                    mLoginWebView.loadData(customError, ""text/html; charset=UTF-8"", null);
                }
            }
        });
    }",0
"@TestApi
    @RequiresPermission(android.Manifest.permission.FORCE_DEVICE_POLICY_MANAGER_LOGS)
    public long forceSecurityLogs() {
        if (mService == null) {
            return 0;
        }
        try {
            return mService.forceSecurityLogs();
        } catch (RemoteException re) {
            throw re.rethrowFromSystemServer();
        }
    }",0
"private native long nativeInit(long webContentsPtr,
            long viewAndroidPtr, long windowAndroidPtr, HashSet<Object> retainedObjectSet);",0
"@Override
    public Bundle getAssistContextExtras(int requestType) {
        PendingAssistExtras pae = enqueueAssistContext(requestType, null, null, null,
                null, null, true /* checkActivityIsTop */, true /* newSessionId */,
                UserHandle.getCallingUserId(), null, PENDING_ASSIST_EXTRAS_TIMEOUT, 0);
        if (pae == null) {
            return null;
        }
        synchronized (pae) {
            while (!pae.haveResult) {
                try {
                    pae.wait();
                } catch (InterruptedException e) {
                }
            }
        }
        synchronized (mGlobalLock) {
            buildAssistBundleLocked(pae, pae.result);
            mPendingAssistExtras.remove(pae);
            mUiHandler.removeCallbacks(pae);
        }
        return pae.extras;
    }",0
"@SystemApi
    @RequiresPermission(android.Manifest.permission.MANAGE_DEVICE_POLICY_APP_EXEMPTIONS)
    public void setApplicationExemptions(@NonNull String packageName,
            @NonNull @ApplicationExemptionConstants Set<Integer> exemptions)
            throws NameNotFoundException {
        throwIfParentInstance(""setApplicationExemptions"");
        if (mService != null) {
            try {
                mService.setApplicationExemptions(mContext.getPackageName(), packageName,
                        ArrayUtils.convertToIntArray(new ArraySet<>(exemptions)));
            } catch (ServiceSpecificException e) {
                switch (e.errorCode) {
                    case ERROR_PACKAGE_NAME_NOT_FOUND:
                        throw new NameNotFoundException(e.getMessage());
                    default:
                        throw new RuntimeException(
                                ""Unknown error setting application exemptions: "" + e.errorCode, e);
                }
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
        }
    }",0
"private boolean inSamePackage(Class<?> c1, Class<?> c2) {
        String nameC1 = c1.getName();
        String nameC2 = c2.getName();
        int indexDotC1 = nameC1.lastIndexOf('.');
        int indexDotC2 = nameC2.lastIndexOf('.');
        if (indexDotC1 != indexDotC2) {
            return false; // cannot be in the same package if indices are not the same
        }
        if (indexDotC1 == -1) {
            return true; // both of them are in default package
        }
        return nameC1.regionMatches(0, nameC2, 0, indexDotC1);
    }",0
"protected boolean encoderEnforceMaxConcurrentStreams() {
        return encoderEnforceMaxConcurrentStreams != null ? encoderEnforceMaxConcurrentStreams : false;
    }",0
"public void setOutputRoot(String argOutputRoot) {
        this.outputRoot = argOutputRoot;
    }",0
"@Override
        protected boolean isFilterStopped(PackageParser.ActivityIntentInfo filter, int userId) {
            if (!sUserManager.exists(userId)) return true;
            PackageParser.Package p = filter.activity.owner;
            if (p != null) {
                PackageSetting ps = (PackageSetting)p.mExtras;
                if (ps != null) {
                    // System apps are never considered stopped for purposes of
                    // filtering, because there may be no way for the user to
                    // actually re-launch them.
                    return (ps.pkgFlags&ApplicationInfo.FLAG_SYSTEM) == 0
                            && ps.getStopped(userId);
                }
            }
            return false;
        }",0
"public List<MetaDataDiff> getMetaDataDiff(Document origdoc, Document newdoc) throws XWikiException
    {
        try {
            if ((origdoc == null) && (newdoc == null)) {
                return Collections.emptyList();
            }
            if (origdoc == null) {
                return this.doc.getMetaDataDiff(new XWikiDocument(newdoc.getDocumentReference()), newdoc.doc,
                    getXWikiContext());
            }
            if (newdoc == null) {
                return this.doc.getMetaDataDiff(origdoc.doc, new XWikiDocument(origdoc.getDocumentReference()),
                    getXWikiContext());
            }

            return this.doc.getMetaDataDiff(origdoc.doc, newdoc.doc, getXWikiContext());
        } catch (Exception e) {
            java.lang.Object[] args = { origdoc.getFullName(), origdoc.getVersion(), newdoc.getVersion() };
            List list = new ArrayList();
            XWikiException xe =
                new XWikiException(XWikiException.MODULE_XWIKI_DIFF, XWikiException.ERROR_XWIKI_DIFF_METADATA_ERROR,
                    ""Error while making meta data diff of {0} between version {1} and version {2}"", e, args);
            String errormsg = Util.getHTMLExceptionMessage(xe, getXWikiContext());
            list.add(errormsg);
            return list;
        }
    }",0
"@Override
    public List<String> getAutoRevokeExemptionGrantedPackages(int userId) {
        return getPackagesWithAutoRevokePolicy(AUTO_REVOKE_DISALLOWED, userId);
    }",0
"void stopDtmfTone(Call call) {
        if (!mCalls.contains(call)) {
            Log.i(this, ""Request to stop DTMF in a non-existent call %s"", call);
        } else {
            call.stopDtmfTone();
            mDtmfLocalTonePlayer.stopTone(call);
        }
    }",0
"List<DictModelMany> queryManyDictByKeys(@Param(""dictCodeList"") List<String> dictCodeList, @Param(""keys"") List<String> keys);",0
"public static String marshal(final Object obj) {
        final StringWriter jaxbWriter = new StringWriter();
        marshal(obj, jaxbWriter);
        return jaxbWriter.toString();
    }",0
"boolean manageExternalJars(final URL ref, final String version, final DownloadAction action) {
        boolean approved = false;
        JNLPClassLoader foundLoader = LocateJnlpClassLoader.getLoaderByResourceUrl(this, ref, version);
        final VersionString resourceVersion = (version == null) ? null : VersionString.fromString(version);

        if (foundLoader != null) {
            approved = true;
        } else if (ref.toString().startsWith(file.getNotNullProbableCodeBase().toString())) {
            approved = true;
        } else if (SecurityDesc.ALL_PERMISSIONS.equals(security.getSecurityType())) {
            approved = true;
        }

        if (approved) {
            if (foundLoader == null) {
                foundLoader = this;
            }

            if (action == DownloadAction.DOWNLOAD_TO_CACHE) {
                JARDesc jarToCache = new JARDesc(ref, resourceVersion, null, false, true, false, true);
                LOG.info(""Downloading and initializing jar: {}"", ref.toString());

                foundLoader.addNewJar(jarToCache, UpdatePolicy.FORCE);

            } else if (action == DownloadAction.REMOVE_FROM_CACHE) {
                JARDesc[] jarToRemove = {new JARDesc(ref, resourceVersion, null, false, true, false, true)};
                foundLoader.removeJars(jarToRemove);

            } else if (action == DownloadAction.CHECK_CACHE) {
                return CacheUtil.isCached(ref, resourceVersion);
            }
        }
        return false;
    }",0
"public DocumentStats getCurrentMonthSpaceStats(String action)
    {
        Scope scope = ScopeFactory.createSpaceScope(this.doc.getSpace(), false);
        Range range = RangeFactory.ALL;
        Period period = PeriodFactory.getCurrentMonth();
        XWikiStatsService statisticsService = getXWikiContext().getWiki().getStatsService(getXWikiContext());
        List<DocumentStats> stats = statisticsService.getDocumentStatistics(action, scope, period, range, this.context);
        if (stats.size() > 0) {
            return stats.get(0);
        }
        return new DocumentStats();
    }",0
"private V fromShort(K name, short value) {
        try {
            return valueConverter.convertShort(value);
        } catch (IllegalArgumentException e) {
            throw new IllegalArgumentException(""Failed to convert short value for header '"" + name + '\'', e);
        }
    }",0
"@Override
    public void transformPoint(Object nativeTransform, float[] in, float[] out) {
        //Matrix t = (Matrix) nativeTransform;
        //t.mapPoints(in, 0, out, 0, 2);
        ((CN1Matrix4f)nativeTransform).transformCoord(in, out);
    }",0
"@Test
    public void testSerializationWithTypeInfo02() throws Exception
    {
        Instant date = Instant.ofEpochSecond(123456789L, 183917322);
        ObjectMapper m = newMapper()
                .configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, true)
                .configure(SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS, false);
        m.addMixIn(Temporal.class, MockObjectConfiguration.class);
        String value = m.writeValueAsString(date);
        assertEquals(""The value is not correct."", ""[\"""" + Instant.class.getName() + ""\"",123456789183]"", value);
    }",0
"private void migrate105(File dataDir, Stack<Integer> versions) {
		for (File file: dataDir.listFiles()) {
			if (file.getName().startsWith(""Settings.xml"")) {
				VersionedXmlDoc dom = VersionedXmlDoc.fromFile(file);
				for (Element element: dom.getRootElement().elements()) {
					String key = element.elementTextTrim(""key"");
					if (key.equals(""JOB_EXECUTORS"")) {
						Element valueElement = element.element(""value"");
						if (valueElement != null) {
							for (Element executorElement: valueElement.elements()) 
								executorElement.addElement(""sitePublishEnabled"").setText(""false"");
						}						
					}
				}
				dom.writeToFile(file, false);
			}
		}
	}",0
"public static String getUser() {
        return System.getProperty(KieServerConstants.CFG_KIE_USER, ""kieserver"");
    }",0
"@Pure
  @Override
  public double getDouble(@Positive int columnIndex) throws SQLException {
    connection.getLogger().log(Level.FINEST, ""  getDouble columnIndex: {0}"", columnIndex);
    byte[] value = getRawValue(columnIndex);
    if (value == null) {
      return 0; // SQL NULL
    }

    if (isBinary(columnIndex)) {
      int col = columnIndex - 1;
      int oid = fields[col].getOID();
      if (oid == Oid.FLOAT8) {
        return ByteConverter.float8(value, 0);
      }
      return readDoubleValue(value, oid, ""double"");
    }

    return toDouble(getFixedString(columnIndex));
  }",0
"private void initChangeListeners() {
        // Make sure we only add text changed listeners once!
        clearChangeListeners();
        mSubject.addTextChangedListener(this);
        mBodyView.addTextChangedListener(this);
        if (mToListener == null) {
            mToListener = new RecipientTextWatcher(mTo, this);
        }
        mTo.addTextChangedListener(mToListener);
        if (mCcListener == null) {
            mCcListener = new RecipientTextWatcher(mCc, this);
        }
        mCc.addTextChangedListener(mCcListener);
        if (mBccListener == null) {
            mBccListener = new RecipientTextWatcher(mBcc, this);
        }
        mBcc.addTextChangedListener(mBccListener);
        mFromSpinner.setOnAccountChangedListener(this);
        mAttachmentsView.setAttachmentChangesListener(this);
    }",0
"VerifyResult verifyJarEntryCerts(String jarName, boolean jarHasManifest,
            Vector<JarEntry> entries) throws Exception {
        // Contains number of entries the cert with this CertPath has signed.
        Map<CertPath, Integer> jarSignCount = new HashMap<>();
        int numSignableEntriesInJar = 0;

        // Record current time just before checking the jar begins.
        long now = System.currentTimeMillis();
        if (jarHasManifest) {

            for (JarEntry je : entries) {
                String name = je.getName();
                CodeSigner[] signers = je.getCodeSigners();
                boolean isSigned = (signers != null);

                boolean shouldHaveSignature = !je.isDirectory()
                        && !isMetaInfFile(name);

                if (shouldHaveSignature) {
                    numSignableEntriesInJar++;
                }

                if (shouldHaveSignature && isSigned) {
                    for (CodeSigner signer : signers) {
                        CertPath certPath = signer.getSignerCertPath();
                        if (!jarSignCount.containsKey(certPath))
                            jarSignCount.put(certPath, 1);
                        else
                            jarSignCount.put(certPath,
                                    jarSignCount.get(certPath) + 1);
                    }
                }
            } // while e has more elements
        } else { // if manifest is null

            // Else increment total entries by 1 so that unsigned jars with
            // no manifests can't sneak in
            numSignableEntriesInJar++;
        }

        jarSignableEntries.put(jarName, numSignableEntriesInJar);

        // Find all signers that have signed every signable entry in this jar.
        boolean allEntriesSignedBySingleCert = false;
        for (CertPath certPath : jarSignCount.keySet()) {
            if (jarSignCount.get(certPath) == numSignableEntriesInJar) {
                allEntriesSignedBySingleCert = true;

                boolean wasPreviouslyVerified = certs.containsKey(certPath);
                if (!wasPreviouslyVerified)
                    certs.put(certPath, new CertInformation());

                CertInformation certInfo = certs.get(certPath);
                if (wasPreviouslyVerified)
                    certInfo.resetForReverification();

                certInfo.setNumJarEntriesSigned(jarName,
                        numSignableEntriesInJar);

                Certificate cert = certPath.getCertificates().get(0);
                if (cert instanceof X509Certificate) {
                    checkCertUsage(certPath, (X509Certificate) cert, null);
                    long notBefore = ((X509Certificate) cert).getNotBefore().getTime();
                    long notAfter = ((X509Certificate) cert).getNotAfter().getTime();
                    if (now < notBefore) {
                        certInfo.setNotYetValidCert();
                    }

                    if (notAfter < now) {
                        certInfo.setHasExpiredCert();
                    } else if (notAfter < now + SIX_MONTHS) {
                        certInfo.setHasExpiringCert();
                    }
                }
            }
        }

        // Every signable entry of this jar needs to be signed by at least
        // one signer for the jar to be considered successfully signed.
        VerifyResult result = null;

        if (numSignableEntriesInJar == 0) {
            // Allow jars with no signable entries to simply be considered signed.
            // There should be no security risk in doing so.
            result = VerifyResult.SIGNED_OK;
        } else if (allEntriesSignedBySingleCert) {

            // We need to find at least one signer without any issues.
            for (CertPath entryCertPath : jarSignCount.keySet()) {
                if (certs.containsKey(entryCertPath)
                        && !hasSigningIssues(entryCertPath)) {
                    result = VerifyResult.SIGNED_OK;
                    break;
                }
            }
            if (result == null) {
                // All signers had issues
                result = VerifyResult.SIGNED_NOT_OK;
            }
        } else {
            result = VerifyResult.UNSIGNED;
        }

        LOG.debug(""Jar found at {} has been verified as {}"", jarName, result);
        return result;
    }",0
"private void newBuildSupportNote(@Nullable AjaxRequestTarget target) {
		Component buildSupportNote = new WebMarkupContainer(""buildSupportNote"") {

			@Override
			protected void onInitialize() {
				super.onInitialize();
				
				String branch = state.blobIdent.revision;
				if (branch == null)
					branch = ""master"";
				if (SecurityUtils.canModify(getProject(), branch, BuildSpec.BLOB_PATH)) {
					add(new ViewStateAwareAjaxLink<Void>(""addFile"") {
	
						@Override
						public void onClick(AjaxRequestTarget target) {
							onModeChange(target, Mode.ADD, BuildSpec.BLOB_PATH);
						}

						@Override
						public IModel<?> getBody() {
							return Model.of(""adding "" + BuildSpec.BLOB_PATH);
						}
						
					});
				} else {
					add(new Label(""addFile"", ""adding "" + BuildSpec.BLOB_PATH) {

						@Override
						protected void onComponentTag(ComponentTag tag) {
							super.onComponentTag(tag);
							tag.setName(""span"");
						}
						
					});
				}
				setOutputMarkupPlaceholderTag(true);
			}

			@Override
			protected void onConfigure() {
				super.onConfigure();
				if (resolvedRevision != null && isOnBranch() && state.blobIdent.path == null && state.mode == Mode.VIEW) {
					BlobIdent oldBlobIdent = new BlobIdent(resolvedRevision.name(), "".onedev-buildspec"", FileMode.TYPE_FILE);
					BlobIdent blobIdent = new BlobIdent(resolvedRevision.name(), BuildSpec.BLOB_PATH, FileMode.TYPE_FILE);
					setVisible(getProject().getBlob(blobIdent, false) == null && getProject().getBlob(oldBlobIdent, false) == null);
				} else {
					setVisible(false);
				}
			}
			
		};
		
		if (target != null) {
			replace(buildSupportNote);
			target.add(buildSupportNote);
		} else {
			add(buildSupportNote);
		}
	}",0
"@Override
    public void verifyStates() {
        super.verifyStates();

        final boolean[] failed = new boolean[1];

        final ShortcutService s = mShortcutUser.mService;

        final ArrayMap<ComponentName, ArrayList<ShortcutInfo>> all =
                sortShortcutsToActivities();

        // Make sure each activity won't have more than max shortcuts.
        for (int outer = all.size() - 1; outer >= 0; outer--) {
            final ArrayList<ShortcutInfo> list = all.valueAt(outer);
            if (list.size() > mShortcutUser.mService.getMaxActivityShortcuts()) {
                failed[0] = true;
                Log.e(TAG_VERIFY, ""Package "" + getPackageName() + "": activity "" + all.keyAt(outer)
                        + "" has "" + all.valueAt(outer).size() + "" shortcuts."");
            }

            // Sort by rank.
            Collections.sort(list, (a, b) -> Integer.compare(a.getRank(), b.getRank()));

            // Split into two arrays for each kind.
            final ArrayList<ShortcutInfo> dynamicList = new ArrayList<>(list);
            dynamicList.removeIf((si) -> !si.isDynamic());

            final ArrayList<ShortcutInfo> manifestList = new ArrayList<>(list);
            manifestList.removeIf((si) -> !si.isManifestShortcut());

            verifyRanksSequential(dynamicList);
            verifyRanksSequential(manifestList);
        }

        // Verify each shortcut's status.
        forEachShortcut(si -> {
            if (!(si.isDeclaredInManifest() || si.isDynamic() || si.isPinned() || si.isCached())) {
                failed[0] = true;
                Log.e(TAG_VERIFY, ""Package "" + getPackageName() + "": shortcut "" + si.getId()
                        + "" is not manifest, dynamic or pinned."");
            }
            if (si.isDeclaredInManifest() && si.isDynamic()) {
                failed[0] = true;
                Log.e(TAG_VERIFY, ""Package "" + getPackageName() + "": shortcut "" + si.getId()
                        + "" is both dynamic and manifest at the same time."");
            }
            if (si.getActivity() == null && !si.isFloating()) {
                failed[0] = true;
                Log.e(TAG_VERIFY, ""Package "" + getPackageName() + "": shortcut "" + si.getId()
                        + "" has null activity, but not floating."");
            }
            if ((si.isDynamic() || si.isManifestShortcut()) && !si.isEnabled()) {
                failed[0] = true;
                Log.e(TAG_VERIFY, ""Package "" + getPackageName() + "": shortcut "" + si.getId()
                        + "" is not floating, but is disabled."");
            }
            if (si.isFloating() && si.getRank() != 0) {
                failed[0] = true;
                Log.e(TAG_VERIFY, ""Package "" + getPackageName() + "": shortcut "" + si.getId()
                        + "" is floating, but has rank="" + si.getRank());
            }
            if (si.getIcon() != null) {
                failed[0] = true;
                Log.e(TAG_VERIFY, ""Package "" + getPackageName() + "": shortcut "" + si.getId()
                        + "" still has an icon"");
            }
            if (si.hasAdaptiveBitmap() && !(si.hasIconFile() || si.hasIconUri())) {
                failed[0] = true;
                Log.e(TAG_VERIFY, ""Package "" + getPackageName() + "": shortcut "" + si.getId()
                        + "" has adaptive bitmap but was not saved to a file nor has icon uri."");
            }
            if (si.hasIconFile() && si.hasIconResource()) {
                failed[0] = true;
                Log.e(TAG_VERIFY, ""Package "" + getPackageName() + "": shortcut "" + si.getId()
                        + "" has both resource and bitmap icons"");
            }
            if (si.hasIconFile() && si.hasIconUri()) {
                failed[0] = true;
                Log.e(TAG_VERIFY, ""Package "" + getPackageName() + "": shortcut "" + si.getId()
                        + "" has both url and bitmap icons"");
            }
            if (si.hasIconUri() && si.hasIconResource()) {
                failed[0] = true;
                Log.e(TAG_VERIFY, ""Package "" + getPackageName() + "": shortcut "" + si.getId()
                        + "" has both url and resource icons"");
            }
            if (si.isEnabled()
                    != (si.getDisabledReason() == ShortcutInfo.DISABLED_REASON_NOT_DISABLED)) {
                failed[0] = true;
                Log.e(TAG_VERIFY, ""Package "" + getPackageName() + "": shortcut "" + si.getId()
                        + "" isEnabled() and getDisabledReason() disagree: ""
                        + si.isEnabled() + "" vs "" + si.getDisabledReason());
            }
            if ((si.getDisabledReason() == ShortcutInfo.DISABLED_REASON_VERSION_LOWER)
                    && (getPackageInfo().getBackupSourceVersionCode()
                    == ShortcutInfo.VERSION_CODE_UNKNOWN)) {
                failed[0] = true;
                Log.e(TAG_VERIFY, ""Package "" + getPackageName() + "": shortcut "" + si.getId()
                        + "" RESTORED_VERSION_LOWER with no backup source version code."");
            }
            if (s.isDummyMainActivity(si.getActivity())) {
                failed[0] = true;
                Log.e(TAG_VERIFY, ""Package "" + getPackageName() + "": shortcut "" + si.getId()
                        + "" has a dummy target activity"");
            }
        });

        if (failed[0]) {
            throw new IllegalStateException(""See logcat for errors"");
        }
    }",0
"public void setRestTemplate(RestTemplate restTemplate) {
		this.restTemplate = restTemplate;
	}",0
"public void providerChanged(int appWidgetId, AppWidgetProviderInfo info) {
            if (isLocalBinder() && info != null) {
                info = info.clone();
            }
            Message msg = mHandler.obtainMessage(HANDLE_PROVIDER_CHANGED,
                    appWidgetId, 0, info);
            msg.sendToTarget();
        }",0
"@Override
    public long getLongAndRemove(K name, long defaultValue) {
        Long v = getLongAndRemove(name);
        return v != null ? v : defaultValue;
    }",0
"public Column<T, ?> addColumn(String propertyName) {
        return addColumn(propertyName, new TextRenderer());
    }",0
"protected CoercionAction _checkCoercionFail(DeserializationContext ctxt,
            CoercionAction act, Class<?> targetType, Object inputValue,
            String inputDesc)
        throws IOException
    {
        if (act == CoercionAction.Fail) {
            ctxt.reportBadCoercion(this, targetType, inputValue,
""Cannot coerce %s to %s (but could if coercion was enabled using `CoercionConfig`)"",
inputDesc, _coercedTypeDesc());
        }
        return act;
    }",0
"private void setPasswordInternal(UserAccounts accounts, Account account, String password,
            int callingUid) {
        if (account == null) {
            return;
        }
        boolean isChanged = false;
        synchronized (accounts.dbLock) {
            synchronized (accounts.cacheLock) {
                accounts.accountsDb.beginTransaction();
                try {
                    final long accountId = accounts.accountsDb.findDeAccountId(account);
                    if (accountId >= 0) {
                        accounts.accountsDb.updateCeAccountPassword(accountId, password);
                        accounts.accountsDb.deleteAuthTokensByAccountId(accountId);
                        accounts.authTokenCache.remove(account);
                        accounts.accountTokenCaches.remove(account);
                        accounts.accountsDb.setTransactionSuccessful();
                        // If there is an account whose password will be updated and the database
                        // transactions succeed, then we say that a change has occured. Even if the
                        // new password is the same as the old and there were no authtokens to
                        // delete.
                        isChanged = true;
                        String action = (password == null || password.length() == 0) ?
                                AccountsDb.DEBUG_ACTION_CLEAR_PASSWORD
                                : AccountsDb.DEBUG_ACTION_SET_PASSWORD;
                        logRecord(action, AccountsDb.TABLE_ACCOUNTS, accountId, accounts,
                                callingUid);
                    }
                } finally {
                    accounts.accountsDb.endTransaction();
                    if (isChanged) {
                        // Send LOGIN_ACCOUNTS_CHANGED only if the something changed.
                        sendNotificationAccountUpdated(account, accounts);
                        sendAccountsChangedBroadcast(accounts.userId);
                    }
                }
            }
        }
    }",0
"@Override
    public boolean updateDocument(XWikiDocument document)
    {
        boolean needsUpdate = false;

        if (updateReferences(document)) {
            needsUpdate = true;
        }

        // Ensure the document is hidden, like every technical document
        if (!document.isHidden()) {
            document.setHidden(true);
            needsUpdate = true;
        }

        // Set the title
        if (document.getTitle().isEmpty()) {
            document.setTitle(""Mail Configuration"");
            needsUpdate = true;
        }

        // Ensure the document has a Mail.GeneralMailConfigClass xobject
        if (addGeneralMailConfigClassXObject(document)) {
            needsUpdate = true;
        }

        // Ensure the document has a Mail.SendMailConfigClass xobject
        if (addSendMailConfigClassXObject(document)) {
            needsUpdate = true;
        }

        // Migration: Since the XWiki.Configurable class used to be located in Mail.MailConfig and has been moved to
        // Mail.MailConfigurable, we need to remove it from this page in case it's there as otherwise there would be
        // duplicate Admin UI entries...
        // TODO: Ideally this code should be executed only once.
        if (removeConfigurableClass(document)) {
            needsUpdate = true;
        }

        if (this.documentInitializerRightsManager.restrictToAdmin(document)) {
            needsUpdate = true;
        }

        return needsUpdate;
    }",1
"private static void clearDirectory(IMediaContainerService mcs, File[] paths) {
        for (File path : paths) {
            try {
                mcs.clearDirectory(path.getAbsolutePath());
            } catch (RemoteException e) {
            }
        }
    }",0
"@Override
    public void endWikiDocumentRevision(String version, FilterEventParameters parameters) throws FilterException
    {
        end(parameters);

        // Reset
        this.currentVersion = null;
    }",0
"public void deleteInput(ProfileInput input) {
        ProfileInput curInput = getInput(input.getName());
        if (curInput != null) {
            inputs.remove(curInput);
        }
    }",0
"public XWikiWebDriver getDriver()
    {
        return TestUtils.context.getDriver();
    }",0
"public void unmuteConversation(final Conversation conversation) {
        conversation.setMutedTill(0);
        this.activity.xmppConnectionService.updateConversation(conversation);
        this.activity.onConversationsListItemUpdated();
        refresh();
        getActivity().invalidateOptionsMenu();
    }",0
"@SuppressWarnings(""NullableProblems"")
    @Override
    default Iterator<Map.Entry<String, V>> iterator() {
        Iterator<String> names = names().iterator();
        return new Iterator<Map.Entry<String, V>>() {
            @Override
            public boolean hasNext() {
                return names.hasNext();
            }

            @Override
            public Map.Entry<String, V> next() {
                if (!hasNext()) {
                    throw new NoSuchElementException();
                }

                String name = names.next();
                return new Map.Entry<String, V>() {
                    @Override
                    public String getKey() {
                        return name;
                    }

                    @Override
                    public V getValue() {
                        return get(name, getValueType()).orElse(null);
                    }

                    @Override
                    public V setValue(V value) {
                        throw new UnsupportedOperationException(""Not mutable"");
                    }
                };
            }
        };
    }",0
"private void maybeDeleteXWikiSpace(SpaceReference spaceReference, String deletedDocument, Session session)
    {
        if (!hasDocuments(spaceReference, session,
            ""fullName <> :deletedDocument AND (language IS NULL OR language = '')"",
            Collections.singletonMap(""deletedDocument"", deletedDocument))) {
            // The document was the last document in the space
            XWikiSpace space = new XWikiSpace(spaceReference, this);

            session.delete(space);

            // Update parent
            if (spaceReference.getParent() instanceof SpaceReference) {
                maybeDeleteXWikiSpace((SpaceReference) spaceReference.getParent(), deletedDocument, session);
            }
        } else {
            // Update space hidden property if needed
            maybeMakeSpaceHidden(spaceReference, deletedDocument, session);
        }
    }",0
"public String getMessageSummary() {
		return messageSummary;
	}",0
"ObjectStreamClass getSuperclass() {
        return superclass;
    }",0
"private static Number stringToNumber(final String val) throws NumberFormatException {
        char initial = val.charAt(0);
        if ((initial >= '0' && initial <= '9') || initial == '-') {
            // decimal representation
            if (isDecimalNotation(val)) {
                // Use a BigDecimal all the time so we keep the original
                // representation. BigDecimal doesn't support -0.0, ensure we
                // keep that by forcing a decimal.
                try {
                    BigDecimal bd = new BigDecimal(val);
                    if(initial == '-' && BigDecimal.ZERO.compareTo(bd)==0) {
                        return Double.valueOf(-0.0);
                    }
                    return bd;
                } catch (NumberFormatException retryAsDouble) {
                    // this is to support ""Hex Floats"" like this: 0x1.0P-1074
                    try {
                        Double d = Double.valueOf(val);
                        if(d.isNaN() || d.isInfinite()) {
                            throw new NumberFormatException(""val [""+val+""] is not a valid number."");
                        }
                        return d;
                    } catch (NumberFormatException ignore) {
                        throw new NumberFormatException(""val [""+val+""] is not a valid number."");
                    }
                }
            }
            // block items like 00 01 etc. Java number parsers treat these as Octal.
            if(initial == '0' && val.length() > 1) {
                char at1 = val.charAt(1);
                if(at1 >= '0' && at1 <= '9') {
                    throw new NumberFormatException(""val [""+val+""] is not a valid number."");
                }
            } else if (initial == '-' && val.length() > 2) {
                char at1 = val.charAt(1);
                char at2 = val.charAt(2);
                if(at1 == '0' && at2 >= '0' && at2 <= '9') {
                    throw new NumberFormatException(""val [""+val+""] is not a valid number."");
                }
            }
            // integer representation.
            // This will narrow any values to the smallest reasonable Object representation
            // (Integer, Long, or BigInteger)
            
            // BigInteger down conversion: We use a similar bitLength compare as
            // BigInteger#intValueExact uses. Increases GC, but objects hold
            // only what they need. i.e. Less runtime overhead if the value is
            // long lived.
            BigInteger bi = new BigInteger(val);
            if(bi.bitLength() <= 31){
                return Integer.valueOf(bi.intValue());
            }
            if(bi.bitLength() <= 63){
                return Long.valueOf(bi.longValue());
            }
            return bi;
        }
        throw new NumberFormatException(""val [""+val+""] is not a valid number."");
    }",0
"private boolean anyDpcHasPermission(String permission, int userId) {
        if (mOwners.isDefaultDeviceOwnerUserId(userId)) {
            return DPC_PERMISSIONS.get(DEFAULT_DEVICE_OWNER).contains(permission);
        }
        if (mOwners.isFinancedDeviceOwnerUserId(userId)) {
            return DPC_PERMISSIONS.get(FINANCED_DEVICE_OWNER).contains(permission);
        }
        if (mOwners.isProfileOwnerOfOrganizationOwnedDevice(userId)) {
            return DPC_PERMISSIONS.get(PROFILE_OWNER_OF_ORGANIZATION_OWNED_DEVICE).contains(
                    permission);
        }
        if (userId == 0 && mOwners.hasProfileOwner(0)) {
            return DPC_PERMISSIONS.get(PROFILE_OWNER_ON_USER_0).contains(permission);
        }
        if (mOwners.hasProfileOwner(userId)) {
            return DPC_PERMISSIONS.get(PROFILE_OWNER).contains(permission);
        }
        return false;
    }",0
"@Override
    public void writeToParcel(Parcel dest, int flags) {
        dest.writeParcelable(mHomeSp, flags);
        dest.writeParcelable(mCredential, flags);
        dest.writeParcelable(mPolicy, flags);
        dest.writeParcelable(mSubscriptionUpdate, flags);
        writeTrustRootCerts(dest, mTrustRootCertList);
        dest.writeInt(mUpdateIdentifier);
        dest.writeInt(mCredentialPriority);
        dest.writeLong(mSubscriptionCreationTimeInMillis);
        dest.writeLong(mSubscriptionExpirationTimeMillis);
        dest.writeString(mSubscriptionType);
        dest.writeLong(mUsageLimitUsageTimePeriodInMinutes);
        dest.writeLong(mUsageLimitStartTimeInMillis);
        dest.writeLong(mUsageLimitDataLimit);
        dest.writeLong(mUsageLimitTimeLimitInMinutes);
        dest.writeStringArray(mAaaServerTrustedNames);
        Bundle bundle = new Bundle();
        bundle.putSerializable(""serviceFriendlyNames"",
                (HashMap<String, String>) mServiceFriendlyNames);
        dest.writeBundle(bundle);
        dest.writeInt(mCarrierId);
        dest.writeBoolean(mIsAutojoinEnabled);
        dest.writeBoolean(mIsMacRandomizationEnabled);
        dest.writeBoolean(mIsNonPersistentMacRandomizationEnabled);
        dest.writeInt(mMeteredOverride);
        dest.writeInt(mSubscriptionId);
        dest.writeBoolean(mIsCarrierMerged);
        dest.writeBoolean(mIsOemPaid);
        dest.writeBoolean(mIsOemPrivate);
        dest.writeString(mDecoratedIdentityPrefix);
        dest.writeParcelable(mSubscriptionGroup, flags);
    }",0
"@Override
  public String load(ImageTarball imageTarball, Consumer<Long> writtenByteCountListener)
      throws InterruptedException, IOException {
    // Runs 'docker load'.
    Process dockerProcess = docker(""load"");

    try (NotifyingOutputStream stdin =
        new NotifyingOutputStream(dockerProcess.getOutputStream(), writtenByteCountListener)) {
      imageTarball.writeTo(stdin);

    } catch (IOException ex) {
      // Tries to read from stderr. Not using getStderrOutput(), as we want to show the error
      // message from the tarball I/O write failure when reading from stderr fails.
      String error;
      try (InputStreamReader stderr =
          new InputStreamReader(dockerProcess.getErrorStream(), StandardCharsets.UTF_8)) {
        error = CharStreams.toString(stderr);
      } catch (IOException ignored) {
        // This ignores exceptions from reading stderr and uses the original exception from
        // writing to stdin.
        error = ex.getMessage();
      }
      throw new IOException(""'docker load' command failed with error: "" + error, ex);
    }

    try (InputStreamReader stdout =
        new InputStreamReader(dockerProcess.getInputStream(), StandardCharsets.UTF_8)) {
      String output = CharStreams.toString(stdout);

      if (dockerProcess.waitFor() != 0) {
        throw new IOException(
            ""'docker load' command failed with error: "" + getStderrOutput(dockerProcess));
      }

      return output;
    }
  }",0
"private boolean isCurrentUserDemo() {
        if (UserManager.isDeviceInDemoMode(mContext)) {
            final int userId = mInjector.userHandleGetCallingUserId();
            return mInjector.binderWithCleanCallingIdentity(
                    () -> mUserManager.getUserInfo(userId).isDemo());
        }
        return false;
    }",0
"public static String sanitize(String jsonish, int maximumNestingDepth) {
    JsonSanitizer s = new JsonSanitizer(jsonish, maximumNestingDepth);
    s.sanitize();
    return s.toString();
  }",0
"@Override
    public void confirmCredentialsAsUser(
            IAccountManagerResponse response,
            final Account account,
            final Bundle options,
            final boolean expectActivityLaunch,
            int userId) {
        Bundle.setDefusable(options, true);
        int callingUid = Binder.getCallingUid();
        if (Log.isLoggable(TAG, Log.VERBOSE)) {
            Log.v(TAG, ""confirmCredentials: "" + account
                    + "", response "" + response
                    + "", expectActivityLaunch "" + expectActivityLaunch
                    + "", caller's uid "" + callingUid
                    + "", pid "" + Binder.getCallingPid());
        }
        // Only allow the system process to read accounts of other users
        if (isCrossUser(callingUid, userId)) {
            throw new SecurityException(
                    String.format(
                            ""User %s trying to confirm account credentials for %s"" ,
                            UserHandle.getCallingUserId(),
                            userId));
        }
        if (response == null) throw new IllegalArgumentException(""response is null"");
        if (account == null) throw new IllegalArgumentException(""account is null"");
        final long identityToken = clearCallingIdentity();
        try {
            UserAccounts accounts = getUserAccounts(userId);
            new Session(accounts, response, account.type, expectActivityLaunch,
                    true /* stripAuthTokenFromResult */, account.name,
                    true /* authDetailsRequired */, true /* updateLastAuthenticatedTime */) {
                @Override
                public void run() throws RemoteException {
                    mAuthenticator.confirmCredentials(this, account, options);
                }
                @Override
                protected String toDebugString(long now) {
                    return super.toDebugString(now) + "", confirmCredentials""
                            + "", "" + account.toSafeString();
                }
            }.bind();
        } finally {
            restoreCallingIdentity(identityToken);
        }
    }",0
"private void updateVMPreferenceWidgets(String currentProviderSetting) {
        final String key = currentProviderSetting;
        final VoicemailProviderListPreference.VoicemailProvider provider =
                mVoicemailProviders.getVoicemailProvider(key);

        /* This is the case when we are coming up on a freshly wiped phone and there is no
         persisted value for the list preference mVoicemailProviders.
         In this case we want to show the UI asking the user to select a voicemail provider as
         opposed to silently falling back to default one. */
        if (provider == null) {
            if (DBG) log(""updateVMPreferenceWidget: key: "" + key + "" -> null."");

            mVoicemailProviders.setSummary(getString(R.string.sum_voicemail_choose_provider));
            mVoicemailSettings.setEnabled(false);
            mVoicemailSettings.setIntent(null);
        } else {
            if (DBG) log(""updateVMPreferenceWidget: key: "" + key + "" -> "" + provider.toString());

            final String providerName = provider.name;
            mVoicemailProviders.setSummary(providerName);
            mVoicemailSettings.setEnabled(true);
            mVoicemailSettings.setIntent(provider.intent);
        }
    }",0
"public static OpenFileResult testFilePermissions(File file) {
        if (file == null || !file.exists()) {
            return OpenFileResult.FAILURE;
        }
        try {
            file = file.getCanonicalFile();
        } catch (final IOException e) {
            return OpenFileResult.FAILURE;
        }
        final DirectoryCheckResults dcr = FileUtils.testDirectoryPermissions(file);
        if (dcr != null && dcr.getFailures() == 0) {
            if (file.isDirectory())
                return OpenFileResult.NOT_FILE;
            try {
                if (!file.exists() && !file.createNewFile()) {
                    return OpenFileResult.CANT_CREATE;
                }
            } catch (IOException e) {
                return OpenFileResult.CANT_CREATE;
            }
            final boolean read = file.canRead(), write = file.canWrite();
            if (read && write)
                return OpenFileResult.SUCCESS;
            else if (read)
                return OpenFileResult.CANT_WRITE;
            else
                return OpenFileResult.FAILURE;
        }
        return OpenFileResult.FAILURE;
    }",0
"private void enforceModifyPermission() {
        enforcePermission(MODIFY_PHONE_STATE);
    }",0
"@Deprecated
    public String getTemplate()
    {
        String templateReferenceAsString;
        DocumentReference templateDocumentReference = getTemplateDocumentReference();
        if (templateDocumentReference != null) {
            templateReferenceAsString = LOCAL_REFERENCE_SERIALIZER.serialize(templateDocumentReference);
        } else {
            templateReferenceAsString = """";
        }
        return templateReferenceAsString;
    }",0
"private static String fromObject(Object value) {
        final String strVal = StringValueConverter.INSTANCE.convertObject(value);
        assert strVal != null : value + "" converted to null."";
        return strVal;
    }",0
"public List<IssueWithParams> getAllErrors() {
            List<IssueWithParams> errors = new ArrayList<>();
            errors.addAll(mErrors);
            if (mWarningsAsErrors) {
                errors.addAll(mWarnings);
            }
            if (!mV1SchemeSigners.isEmpty()) {
                for (V1SchemeSignerInfo signer : mV1SchemeSigners) {
                    errors.addAll(signer.mErrors);
                    if (mWarningsAsErrors) {
                        errors.addAll(signer.getWarnings());
                    }
                }
            }
            if (!mV2SchemeSigners.isEmpty()) {
                for (V2SchemeSignerInfo signer : mV2SchemeSigners) {
                    errors.addAll(signer.mErrors);
                    if (mWarningsAsErrors) {
                        errors.addAll(signer.getWarnings());
                    }
                }
            }
            if (!mV3SchemeSigners.isEmpty()) {
                for (V3SchemeSignerInfo signer : mV3SchemeSigners) {
                    errors.addAll(signer.mErrors);
                    if (mWarningsAsErrors) {
                        errors.addAll(signer.getWarnings());
                    }
                }
            }
            if (mSourceStampInfo != null) {
                errors.addAll(mSourceStampInfo.getErrors());
                if (mWarningsAsErrors) {
                    errors.addAll(mSourceStampInfo.getWarnings());
                }
            }
            return errors;
        }",0
"public void playBuiltinSound(String soundIdentifier) {
        if (getActivity() != null && Display.SOUND_TYPE_BUTTON_PRESS == soundIdentifier) {
            getActivity().runOnUiThread(new Runnable() {
                public void run() {
                    if (myView != null) {
                        myView.getAndroidView().playSoundEffect(AudioManager.FX_KEY_CLICK);
                    }
                }
            });
        }
    }",0
"private void getInKeyResponse(ByteArrayOutputStream buf, Input cmdInput) {
        int tag = ComprehensionTlvTag.DURATION.value();

        buf.write(tag);
        buf.write(0x02); // length
        buf.write(cmdInput.duration.timeUnit.SECOND.value()); // Time (Unit,Seconds)
        buf.write(cmdInput.duration.timeInterval); // Time Duration
    }",0
"void dumpBinderProxies(PrintWriter pw, int minCountToDumpInterfaces) {
        pw.println(""ACTIVITY MANAGER BINDER PROXY STATE (dumpsys activity binder-proxies)"");
        final int proxyCount = BinderProxy.getProxyCount();
        if (proxyCount >= minCountToDumpInterfaces) {
            dumpBinderProxyInterfaceCounts(pw,
                    ""Top proxy interface names held by SYSTEM"");
        } else {
            pw.print(""Not dumping proxy interface counts because size (""
                    + Integer.toString(proxyCount) + "") looks reasonable"");
            pw.println();
        }
        dumpBinderProxiesCounts(pw,
                ""  Counts of Binder Proxies held by SYSTEM"");
    }",0
"static int clamp(int x, int low, int high) {
        return (x < low) ? low : ((x > high) ? high : x);
    }",0
"@Override
        void detachActivitiesLocked(ActivityStack stack) {
            super.detachActivitiesLocked(stack);
            if (mVirtualDisplay != null) {
                mVirtualDisplay.release();
                mVirtualDisplay = null;
            }
        }",0
"@Override
    public boolean isSupported(final String namespace, final String featureName) {
        throw new UnsupportedOperationException(""DomNode.isSupported is not yet implemented."");
    }",0
"private final boolean finishReceiverLocked(IBinder receiver, int resultCode,
            String resultData, Bundle resultExtras, boolean resultAbort) {
        final BroadcastRecord r = broadcastRecordForReceiverLocked(receiver);
        if (r == null) {
            Slog.w(TAG, ""finishReceiver called but not found on queue"");
            return false;
        }

        return r.queue.finishReceiverLocked(r, resultCode, resultData, resultExtras, resultAbort, false);
    }",0
"public Object optQuery(String jsonPointer) {
    	return optQuery(new JSONPointer(jsonPointer));
    }",0
"@Override
    protected void onNewIntent(Intent intent) {
        super.onNewIntent(intent);

        // When it's large screen 2-pane and Settings app is in the background, receiving an Intent
        // will not recreate this activity. Update the intent for this case.
        setIntent(intent);
        reloadHighlightMenuKey();
        if (isFinishing()) {
            return;
        }
        // Launch the intent from deep link for large screen devices.
        launchDeepLinkIntentToRight();
    }",0
"public boolean isCurrentUserCreator(XWikiContext context)
    {
        return isCreator(context.getUserReference());
    }",0
"private int getConsumerCount(ConnectionId connectionId) {
        int result = 0;
        TransportConnectionState cs = lookupConnectionState(connectionId);
        if (cs != null) {
            for (SessionId sessionId : cs.getSessionIds()) {
                SessionState sessionState = cs.getSessionState(sessionId);
                if (sessionState != null) {
                    result += sessionState.getConsumerIds().size();
                }
            }
        }
        return result;
    }",0
"public boolean isSleeping() {
        return mSleeping;
    }",0
"public static List<Field> getFilesFieldsList(Structure structure, List<String> parametersName, List<String[]> values){
		List<Field> fileList = new ArrayList<Field>();
		for(int i=0; i < parametersName.size(); i++){
			String fieldname = parametersName.get(i);
			String[] fieldValue = values.get(i);
			Field field = structure.getFieldVar(fieldname);
			if(UtilMethods.isSet(field) && APILocator.getFieldAPI().valueSettable(field)){
				if(field.getFieldType().equals(Field.FieldType.FILE.toString()) && UtilMethods.isSet(fieldValue)){
					fileList.add(field);
				}
			}
		}
		return fileList;
	}",0
"@Override
	public VFSStatus deleteSilently() {
		if(!getBasefile().exists()) {
			return VFSConstants.YES;  // already non-existent
		}
		// we must empty the folders and subfolders first
		List<VFSItem> children = getItems();
		for (VFSItem child:children) {
			child.deleteSilently(); 
		}
		
		if(canMeta() == VFSConstants.YES) {
			CoreSpringFactory.getImpl(VFSRepositoryService.class).deleteMetadata(getMetaInfo());
		}
		// now delete the directory itself
		return deleteBasefile();
	}",0
"public List<String> getShellCommandLine( String... arguments )
    {

        List<String> commandLine = new ArrayList<>();

        if ( getShellCommand() != null )
        {
            commandLine.add( getShellCommand() );
        }

        if ( getShellArgs() != null )
        {
            commandLine.addAll( getShellArgsList() );
        }

        commandLine.addAll( getCommandLine( executable, arguments ) );

        return commandLine;

    }",1
"@Override
    public GlobalRequestFuture request(Buffer buffer, String request, GlobalRequestFuture.ReplyHandler replyHandler)
            throws IOException {
        GlobalRequestFuture globalRequest;
        if (!wantReply(buffer)) {
            if (!isOpen()) {
                throw new IOException(""Global request "" + request + "": session is closing or closed."");
            }
            // Fire-and-forget global requests (want-reply = false) are always allowed; we don't need to register the
            // future, nor do we have to wait for anything. Client code can wait on the returned future if it wants to
            // be sure the message has been sent.
            globalRequest = new GlobalRequestFuture(request, replyHandler) {

                @Override
                public void operationComplete(IoWriteFuture future) {
                    if (future.isWritten()) {
                        if (log.isDebugEnabled()) {
                            log.debug(""makeGlobalRequest({})[{}] want-reply=false sent"", this, getId());
                        }
                        setValue(new ByteArrayBuffer(new byte[0]));
                        GlobalRequestFuture.ReplyHandler handler = getHandler();
                        if (handler != null) {
                            handler.accept(SshConstants.SSH_MSG_REQUEST_SUCCESS, getBuffer());
                        }
                    }
                    super.operationComplete(future);
                }
            };
            writePacket(buffer).addListener(globalRequest);
            return globalRequest;
        }
        // We do expect a reply. The packet may get queued or otherwise delayed for an unknown time. We must
        // consider this request pending only once its sequence number is known. If sending the message fails,
        // the writeFuture will set an exception on the globalRequest, or will fail it.
        globalRequest = new GlobalRequestFuture(request, replyHandler) {

            @Override
            public void operationComplete(IoWriteFuture future) {
                if (!future.isWritten()) {
                    // If it was not written after all, make sure it's not considered pending anymore.
                    pendingGlobalRequests.removeFirstOccurrence(this);
                }
                // Super call will fulfill the future if not written
                super.operationComplete(future);
                if (future.isWritten() && getHandler() != null) {
                    // Fulfill this future now. The GlobalRequestFuture can thus be used to wait for the
                    // successful sending of the request, the framework will invoke the handler whenever
                    // the reply arrives. The buffer cannot be obtained though the future.
                    setValue(null);
                }
            }
        };
        if (!isOpen()) {
            throw new IOException(""Global request "" + request + "": session is closing or closed."");
        }
        // This consumer will be invoked once before the packet actually goes out. Some servers respond to global
        // requests with SSH_MSG_UNIMPLEMENTED instead of SSH_MSG_REQUEST_FAILURE (see SSHD-968), so we need to make
        // sure we do know the sequence number.
        globalSequenceNumbers.put(buffer, seqNo -> {
            globalRequest.setSequenceNumber(seqNo);
            if (log.isDebugEnabled()) {
                log.debug(""makeGlobalRequest({})[{}] want-reply=true with seqNo={}"", this, globalRequest.getId(), seqNo);
            }
            // Insert at front
            pendingGlobalRequests.push(globalRequest);
        });
        writePacket(buffer).addListener(f -> {
            Throwable t = f.getException();
            if (t != null) {
                // Just in case we get an exception before preProcessEncodeBuffer was even called
                globalSequenceNumbers.remove(buffer);
            }
        }).addListener(globalRequest); // Report errors through globalRequest, fulfilling globalRequest
        return globalRequest;
    }",0
"@Override
        boolean check(MapIndexConfig c1, MapIndexConfig c2) {
            return c1 == c2 || !(c1 == null || c2 == null)
                    && nullSafeEqual(c1.getAttribute(), c2.getAttribute())
                    && nullSafeEqual(c1.isOrdered(), c2.isOrdered());
        }",0
"public void upgradeIfNeededLocked() {
                // The version of all settings for a user is the same (all users have secure).
                SettingsState secureSettings = getSettingsLocked(
                        SETTINGS_TYPE_SECURE, mUserId);

                // Try an update from the current state.
                final int oldVersion = secureSettings.getVersionLocked();
                final int newVersion = SETTINGS_VERSION;

                // If up do date - done.
                if (oldVersion == newVersion) {
                    return;
                }

                // Try to upgrade.
                final int curVersion = onUpgradeLocked(mUserId, oldVersion, newVersion);

                // If upgrade failed start from scratch and upgrade.
                if (curVersion != newVersion) {
                    // Drop state we have for this user.
                    removeUserStateLocked(mUserId, true);

                    // Recreate the database.
                    DatabaseHelper dbHelper = new DatabaseHelper(getContext(), mUserId);
                    SQLiteDatabase database = dbHelper.getWritableDatabase();
                    dbHelper.recreateDatabase(database, newVersion, curVersion, oldVersion);

                    // Migrate the settings for this user.
                    migrateLegacySettingsForUserLocked(dbHelper, database, mUserId);

                    // Now upgrade should work fine.
                    onUpgradeLocked(mUserId, oldVersion, newVersion);

                    // Make a note what happened, so we don't wonder why data was lost
                    String reason = ""Settings rebuilt! Current version: ""
                            + curVersion + "" while expected: "" + newVersion;
                    getGlobalSettingsLocked().insertSettingLocked(
                            Settings.Global.DATABASE_DOWNGRADE_REASON,
                            reason, null, true, SettingsState.SYSTEM_PACKAGE_NAME);
                }

                // Set the global settings version if owner.
                if (mUserId == UserHandle.USER_SYSTEM) {
                    SettingsState globalSettings = getSettingsLocked(
                            SETTINGS_TYPE_GLOBAL, mUserId);
                    globalSettings.setVersionLocked(newVersion);
                }

                // Set the secure settings version.
                secureSettings.setVersionLocked(newVersion);

                // Set the system settings version.
                SettingsState systemSettings = getSettingsLocked(
                        SETTINGS_TYPE_SYSTEM, mUserId);
                systemSettings.setVersionLocked(newVersion);
            }",0
"public static ClassLoader getContextClassLoader() {
        return PlatformDependent0.getContextClassLoader();
    }",0
"private ResolveInfo createForwardingResolveInfo(IntentFilter filter,
            int sourceUserId, int targetUserId) {
        ResolveInfo forwardingResolveInfo = new ResolveInfo();
        String className;
        if (targetUserId == UserHandle.USER_OWNER) {
            className = FORWARD_INTENT_TO_USER_OWNER;
        } else {
            className = FORWARD_INTENT_TO_MANAGED_PROFILE;
        }
        ComponentName forwardingActivityComponentName = new ComponentName(
                mAndroidApplication.packageName, className);
        ActivityInfo forwardingActivityInfo = getActivityInfo(forwardingActivityComponentName, 0,
                sourceUserId);
        if (targetUserId == UserHandle.USER_OWNER) {
            forwardingActivityInfo.showUserIcon = UserHandle.USER_OWNER;
            forwardingResolveInfo.noResourceId = true;
        }
        forwardingResolveInfo.activityInfo = forwardingActivityInfo;
        forwardingResolveInfo.priority = 0;
        forwardingResolveInfo.preferredOrder = 0;
        forwardingResolveInfo.match = 0;
        forwardingResolveInfo.isDefault = true;
        forwardingResolveInfo.filter = filter;
        forwardingResolveInfo.targetUserId = targetUserId;
        return forwardingResolveInfo;
    }",0
"public Document getDocumentAsAuthor(String fullName) throws XWikiException
    {
        DocumentReference reference;

        // We ignore the passed full name if it's null to match behavior of getDocument
        if (fullName != null) {
            // Note: We use the CurrentMixed Resolver since we want to use the default page name if the page isn't
            // specified in the passed string, rather than use the current document's page name.
            reference = getCurrentMixedDocumentReferenceResolver().resolve(fullName);
        } else {
            reference = getDefaultDocumentReferenceResolver().resolve("""");
        }

        return getDocumentAsAuthor(reference);
    }",0
"public boolean clearTargetBssid(String dbg) {
        WifiConfiguration config = mWifiConfigManager.getConfiguredNetwork(mTargetNetworkId);
        if (config == null) {
            return false;
        }
        String bssid = SUPPLICANT_BSSID_ANY;
        if (config.BSSID != null) {
            bssid = config.BSSID;
            if (mVerboseLoggingEnabled) {
                Log.d(getTag(), ""force BSSID to "" + bssid + ""due to config"");
            }
        }
        if (mVerboseLoggingEnabled) {
            logd(dbg + "" clearTargetBssid "" + bssid + "" key="" + config.getProfileKey());
        }
        mTargetBssid = bssid;
        return mWifiNative.setNetworkBSSID(mInterfaceName, bssid);
    }",0
"@Override
    public boolean setBiome(int x, int y, int z, BiomeType biome) {
        return setBiome(BlockVector3.at(x, y, z), biome);
    }",0
"private static String formatSenders(final String string) {
        if (!TextUtils.isEmpty(string) && string.charAt(string.length() - 1) == ',') {
            return string.substring(0, string.length() - 1);
        }
        return string;
    }",0
"public String getDescriptorUrl() {
        return ""descriptorByName/""+getId();
    }",0
"public void setBookshelfBean(BookmarkBean bookshelfBean) {
        this.bookmarkBean = bookshelfBean;
    }",0
"@RequestMapping(value = ""/repository/restful/artifact/PUT/*"", method = RequestMethod.PUT)
    public ModelAndView putArtifact(@RequestParam(""pipelineName"") String pipelineName,
                                    @RequestParam(""pipelineCounter"") String pipelineCounter,
                                    @RequestParam(""stageName"") String stageName,
                                    @RequestParam(value = ""stageCounter"", required = false) String stageCounter,
                                    @RequestParam(""buildName"") String buildName,
                                    @RequestParam(value = ""buildId"", required = false) Long buildId,
                                    @RequestParam(""filePath"") String filePath,
                                    @RequestParam(value = ""agentId"", required = false) String agentId,
                                    HttpServletRequest request
    ) throws Exception {
        if (filePath.contains("".."")) {
            return FileModelAndView.forbiddenUrl(filePath);
        }

        if (!isValidStageCounter(stageCounter)) {
            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);
        }

        JobIdentifier jobIdentifier;
        try {
            jobIdentifier = restfulService.findJob(pipelineName, pipelineCounter, stageName, stageCounter, buildName, buildId);
        } catch (Exception e) {
            return buildNotFound(pipelineName, pipelineCounter, stageName, stageCounter, buildName);
        }

        if (isConsoleOutput(filePath)) {
            return putConsoleOutput(jobIdentifier, request.getInputStream());
        } else {
            return putArtifact(jobIdentifier, filePath, request.getInputStream());
        }
    }",1
"public void enqueueParallelBroadcastLocked(BroadcastRecord r) {
        mParallelBroadcasts.add(r);
        r.enqueueClockTime = System.currentTimeMillis();
    }",0
"@TestOnly
    public List<String> submoduleFolders() {
        CommandLine gitCmd = gitWd().withArgs(""submodule"", ""status"");
        ConsoleResult result = runOrBomb(gitCmd);
        return submoduleFolders(result.output());
    }",0
"private void sendDeviceOwnerUserCommand(String action, int userHandle) {
            synchronized (getLockObject()) {
                ActiveAdmin deviceOwner = getDeviceOwnerAdminLocked();
                if (deviceOwner != null) {
                    Bundle extras = new Bundle();
                    extras.putParcelable(Intent.EXTRA_USER, UserHandle.of(userHandle));
                    sendAdminCommandLocked(deviceOwner, action, extras, /* result */ null,
                            /* inForeground */ true);
                }
            }
        }",0
"private UserAccounts getUserAccountsForCaller() {
        return getUserAccounts(UserHandle.getCallingUserId());
    }",0
"public static String simplifyPath(String pathname) {
    checkNotNull(pathname);
    if (pathname.length() == 0) {
      return ""."";
    }

    // split the path apart
    Iterable<String> components = Splitter.on('/').omitEmptyStrings().split(pathname);
    List<String> path = new ArrayList<>();

    // resolve ., .., and //
    for (String component : components) {
      switch (component) {
        case ""."":
          continue;
        case "".."":
          if (path.size() > 0 && !path.get(path.size() - 1).equals("".."")) {
            path.remove(path.size() - 1);
          } else {
            path.add("".."");
          }
          break;
        default:
          path.add(component);
          break;
      }
    }

    // put it back together
    String result = Joiner.on('/').join(path);
    if (pathname.charAt(0) == '/') {
      result = ""/"" + result;
    }

    while (result.startsWith(""/../"")) {
      result = result.substring(3);
    }
    if (result.equals(""/.."")) {
      result = ""/"";
    } else if ("""".equals(result)) {
      result = ""."";
    }

    return result;
  }",0
"private final boolean moveAffiliatedTasksToFront(TaskRecord task, int taskIndex) {
        int N = mRecentTasks.size();
        TaskRecord top = task;
        int topIndex = taskIndex;
        while (top.mNextAffiliate != null && topIndex > 0) {
            top = top.mNextAffiliate;
            topIndex--;
        }
        if (DEBUG_RECENTS) Slog.d(TAG, ""addRecent: adding affilliates starting at ""
                + topIndex + "" from intial "" + taskIndex);
        // Find the end of the chain, doing a sanity check along the way.
        boolean sane = top.mAffiliatedTaskId == task.mAffiliatedTaskId;
        int endIndex = topIndex;
        TaskRecord prev = top;
        while (endIndex < N) {
            TaskRecord cur = mRecentTasks.get(endIndex);
            if (DEBUG_RECENTS) Slog.d(TAG, ""addRecent: looking at next chain @""
                    + endIndex + "" "" + cur);
            if (cur == top) {
                // Verify start of the chain.
                if (cur.mNextAffiliate != null || cur.mNextAffiliateTaskId != INVALID_TASK_ID) {
                    Slog.wtf(TAG, ""Bad chain @"" + endIndex
                            + "": first task has next affiliate: "" + prev);
                    sane = false;
                    break;
                }
            } else {
                // Verify middle of the chain's next points back to the one before.
                if (cur.mNextAffiliate != prev
                        || cur.mNextAffiliateTaskId != prev.taskId) {
                    Slog.wtf(TAG, ""Bad chain @"" + endIndex
                            + "": middle task "" + cur + "" @"" + endIndex
                            + "" has bad next affiliate ""
                            + cur.mNextAffiliate + "" id "" + cur.mNextAffiliateTaskId
                            + "", expected "" + prev);
                    sane = false;
                    break;
                }
            }
            if (cur.mPrevAffiliateTaskId == INVALID_TASK_ID) {
                // Chain ends here.
                if (cur.mPrevAffiliate != null) {
                    Slog.wtf(TAG, ""Bad chain @"" + endIndex
                            + "": last task "" + cur + "" has previous affiliate ""
                            + cur.mPrevAffiliate);
                    sane = false;
                }
                if (DEBUG_RECENTS) Slog.d(TAG, ""addRecent: end of chain @"" + endIndex);
                break;
            } else {
                // Verify middle of the chain's prev points to a valid item.
                if (cur.mPrevAffiliate == null) {
                    Slog.wtf(TAG, ""Bad chain @"" + endIndex
                            + "": task "" + cur + "" has previous affiliate ""
                            + cur.mPrevAffiliate + "" but should be id ""
                            + cur.mPrevAffiliate);
                    sane = false;
                    break;
                }
            }
            if (cur.mAffiliatedTaskId != task.mAffiliatedTaskId) {
                Slog.wtf(TAG, ""Bad chain @"" + endIndex
                        + "": task "" + cur + "" has affiliated id ""
                        + cur.mAffiliatedTaskId + "" but should be ""
                        + task.mAffiliatedTaskId);
                sane = false;
                break;
            }
            prev = cur;
            endIndex++;
            if (endIndex >= N) {
                Slog.wtf(TAG, ""Bad chain ran off index "" + endIndex
                        + "": last task "" + prev);
                sane = false;
                break;
            }
        }
        if (sane) {
            if (endIndex < taskIndex) {
                Slog.wtf(TAG, ""Bad chain @"" + endIndex
                        + "": did not extend to task "" + task + "" @"" + taskIndex);
                sane = false;
            }
        }
        if (sane) {
            // All looks good, we can just move all of the affiliated tasks
            // to the top.
            for (int i=topIndex; i<=endIndex; i++) {
                if (DEBUG_RECENTS) Slog.d(TAG, ""addRecent: moving affiliated "" + task
                        + "" from "" + i + "" to "" + (i-topIndex));
                TaskRecord cur = mRecentTasks.remove(i);
                mRecentTasks.add(i-topIndex, cur);
            }
            if (DEBUG_RECENTS) Slog.d(TAG, ""addRecent: done moving tasks  "" +  topIndex
                    + "" to "" + endIndex);
            return true;
        }

        // Whoops, couldn't do it.
        return false;
    }",0
"public @Nullable String getAlwaysOnVpnPackage(@NonNull ComponentName admin) {
        throwIfParentInstance(""getAlwaysOnVpnPackage"");
        if (mService != null) {
            try {
                return mService.getAlwaysOnVpnPackage(admin);
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
        }
        return null;
    }",0
"public boolean isMinorEdit()
    {
        return this.doc.isMinorEdit();
    }",0
"private static void writeEntry(PrintWriter printWriter, String key, String value) {
		printWriter.printf(""\t%s = %s\n"", key, escape(value));
	}",0
"private Set<String> getAllResolvedPermittedIndices(Resolved resolved, User user, String[] actions, IndexNameExpressionResolver resolver,
                ClusterService cs) {

            final Set<String> retVal = new HashSet<>();
            for (IndexPattern p : ipatterns) {
                //what if we cannot resolve one (for create purposes)
                final boolean patternMatch = p.getPerms().matchAll(actions);
                
//                final Set<TypePerm> tperms = p.getTypePerms();
//                for (TypePerm tp : tperms) {
//                    if (WildcardMatcher.matchAny(tp.typePattern, resolved.getTypes(-).toArray(new String[0]))) {
//                        patternMatch = WildcardMatcher.matchAll(tp.perms.toArray(new String[0]), actions);
//                    }
//                }
                if (patternMatch) {
                    //resolved but can contain patterns for nonexistent indices
                    final WildcardMatcher permitted = WildcardMatcher.from(p.attemptResolveIndexNames(user, resolver, cs)); //maybe they do not exist
                    final Set<String> res = new HashSet<>();
                    if (!resolved.isLocalAll() && !resolved.getAllIndices().contains(""*"") && !resolved.getAllIndices().contains(""_all"")) {
                        //resolved but can contain patterns for nonexistent indices
                        resolved.getAllIndices().stream().filter(permitted).forEach(res::add);
                    } else {
                        //we want all indices so just return what's permitted

                        //#557
                        //final String[] allIndices = resolver.concreteIndexNames(cs.state(), IndicesOptions.lenientExpandOpen(), ""*"");
                        final String[] allIndices = cs.state().metadata().getConcreteAllOpenIndices();
                        Arrays.stream(allIndices).filter(permitted).forEach(res::add);
                    }
                    retVal.addAll(res);
                }
            }

            //all that we want and all thats permitted of them
            return Collections.unmodifiableSet(retVal);
        }",0
"public static SvgSize parse(String s) {

            if (CmsStringUtil.isEmptyOrWhitespaceOnly(s)) {
                return null;
            }
            s = s.trim();
            double length = -1;
            int unitPos;
            String unit = """";
            // find longest prefix of s that can be parsed as a number, use the remaining part as the unit
            for (unitPos = s.length(); unitPos >= 0; unitPos--) {
                String prefix = s.substring(0, unitPos);
                unit = s.substring(unitPos);
                try {
                    length = Double.parseDouble(prefix);
                    break;
                } catch (NumberFormatException e) {
                    // ignore
                }
            }
            if (length < 0) {
                LOG.warn(""Invalid string for SVG size: "" + s);
                return null;
            }
            SvgSize result = new SvgSize();
            result.m_size = length;
            result.m_unit = unit;
            return result;
        }",0
"public Object getObject(String classname, boolean create)
    {
        try {
            BaseObject obj = getDoc().getObject(classname, create, getXWikiContext());

            if (obj == null) {
                return null;
            } else {
                return newObjectApi(obj, getXWikiContext());
            }
        } catch (Exception e) {
            return null;
        }
    }",0
"@Sessional
	@Override
	public Collection<Project> getPermittedProjects(Permission permission) {
		return query().stream()
				.filter(it->SecurityUtils.getSubject().isPermitted(new ProjectPermission(it, permission)))
				.collect(toList());
	}",0
"void enableVerboseLogging(boolean verbose) {
        mVerboseLoggingEnabled = verbose;
    }",0
"private void notifyFinishedGoingToSleep() {
        if (DEBUG) Log.d(TAG, ""notifyFinishedGoingToSleep"");
        mHandler.sendEmptyMessage(NOTIFY_FINISHED_GOING_TO_SLEEP);
    }",0
"private boolean isWhiteSpace() {
    return current==' ' || current=='\t' || current=='\n' || current=='\r';
  }",0
"@Override
        public void stopShellPermissionIdentityDelegation() {
            stopShellPermissionIdentityDelegationInternal();
        }",0
"protected HttpServletRequest prepareRequest() throws ChangeRequestException
    {
        XWikiContext context = this.contextProvider.get();
        HttpServletRequest request = context.getRequest();
        try {
            return (HttpServletRequest) this.requestParameterConverter.convert(request, context.getResponse()).get();
        } catch (IOException e) {
            throw new ChangeRequestException(""Error while converting request"", e);
        }
    }",0
"protected void executePreProcessCommands(Scheduler scheduler) 
        throws SchedulerException {
        
        for(String group: jobGroupsToDelete) {
            if(group.equals(""*"")) {
                log.info(""Deleting all jobs in ALL groups."");
                for (String groupName : scheduler.getJobGroupNames()) {
                    if (!jobGroupsToNeverDelete.contains(groupName)) {
                        for (JobKey key : scheduler.getJobKeys(GroupMatcher.jobGroupEquals(groupName))) {
                            scheduler.deleteJob(key);
                        }
                    }
                }
            }
            else {
                if(!jobGroupsToNeverDelete.contains(group)) {
                    log.info(""Deleting all jobs in group: {}"", group);
                    for (JobKey key : scheduler.getJobKeys(GroupMatcher.jobGroupEquals(group))) {
                        scheduler.deleteJob(key);
                    }
                }
            }
        }
        
        for(String group: triggerGroupsToDelete) {
            if(group.equals(""*"")) {
                log.info(""Deleting all triggers in ALL groups."");
                for (String groupName : scheduler.getTriggerGroupNames()) {
                    if (!triggerGroupsToNeverDelete.contains(groupName)) {
                        for (TriggerKey key : scheduler.getTriggerKeys(GroupMatcher.triggerGroupEquals(groupName))) {
                            scheduler.unscheduleJob(key);
                        }
                    }
                }
            }
            else {
                if(!triggerGroupsToNeverDelete.contains(group)) {
                    log.info(""Deleting all triggers in group: {}"", group);
                    for (TriggerKey key : scheduler.getTriggerKeys(GroupMatcher.triggerGroupEquals(group))) {
                        scheduler.unscheduleJob(key);
                    }
                }
            }
        }
        
        for(JobKey key: jobsToDelete) {
            if(!jobGroupsToNeverDelete.contains(key.getGroup())) {
                log.info(""Deleting job: {}"", key);
                scheduler.deleteJob(key);
            } 
        }
        
        for(TriggerKey key: triggersToDelete) {
            if(!triggerGroupsToNeverDelete.contains(key.getGroup())) {
                log.info(""Deleting trigger: {}"", key);
                scheduler.unscheduleJob(key);
            }
        }
    }",0
"private void validateHostName(String hostName) {

        if (!isHostName(hostName)) {
            throw new IllegalArgumentException(
                    String.format(Locale.ENGLISH, ""[%s] is an invalid hostname. Please supply a pure hostname (eg. api.graylog.com)"",
                                  hostName));
        }
    }",0
"@Override
    public void visit(Modification modification) {
        modifiedFilesJson = new ArrayList<>();

        Map<String, Object> jsonMap = new LinkedHashMap<>();
        jsonMap.put(""user"", modification.getUserDisplayName());
        jsonMap.put(""revision"", modification.getRevision());
        jsonMap.put(""date"", formatISO8601(modification.getModifiedTime()));
        String comment = modification.getComment();
        if (!revision.getMaterial().getMaterialType().equals(TYPE)) {
            comment = commentRenderer.render(comment);
        }
        jsonMap.put(""comment"", comment);
        jsonMap.put(""modifiedFiles"", modifiedFilesJson);

        modificationsJson.add(jsonMap);
    }",1
"public void setIssuedOn(Date issuedOn) {
        this.issuedOn = issuedOn;
    }",0
"@Override
    public Bundle getAssistContextExtras(int requestType) {
        PendingAssistExtras pae = enqueueAssistContext(requestType, null, null, null,
                null, UserHandle.getCallingUserId(), null, PENDING_ASSIST_EXTRAS_TIMEOUT);
        if (pae == null) {
            return null;
        }
        synchronized (pae) {
            while (!pae.haveResult) {
                try {
                    pae.wait();
                } catch (InterruptedException e) {
                }
            }
        }
        synchronized (this) {
            buildAssistBundleLocked(pae, pae.result);
            mPendingAssistExtras.remove(pae);
            mUiHandler.removeCallbacks(pae);
        }
        return pae.extras;
    }",0
"public QName get(String qualifiedName, String uri) {
        int index = qualifiedName.indexOf(':');

        if (index < 0) {
            return get(qualifiedName, Namespace.get(uri));
        } else if (index == 0){
            throw new IllegalArgumentException(""Qualified name cannot start with ':'."");
        } else {
            String name = qualifiedName.substring(index + 1);
            String prefix = qualifiedName.substring(0, index);

            return get(name, Namespace.get(prefix, uri));
        }
    }",1
"public void setCategories(String categories) {
        this.categories = categories;
    }",0
"private void showNotification(int id, NotificationCompat.Builder builder) {
        NotificationManager notificationManager = (NotificationManager) getContext().
                getSystemService(Context.NOTIFICATION_SERVICE);

        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.O) {
            builder.setChannelId(NotificationUtils.NOTIFICATION_CHANNEL_FILE_SYNC);
        }

        notificationManager.notify(id, builder.build());
    }",0
"@Test
  public void save4returnId(TestContext context) {
    postgresClient = createFoo(context);
    postgresClient.save(FOO, xPojo, /* returnId */ true, context.asyncAssertSuccess(save -> {
      String id = save;
      postgresClient.getById(FOO, id, context.asyncAssertSuccess(get -> {
        context.assertEquals(""x"", get.getString(""key""));
      }));
    }));
  }",0
"@SuppressWarnings(""unchecked"")
    default Map<String, V> subMap(String prefix, ArgumentConversionContext<V> valueType) {
        // special handling for maps for resolving sub keys
        String finalPrefix = prefix + '.';
        return names().stream()
            .filter(name -> name.startsWith(finalPrefix))
            .collect(Collectors.toMap((name) -> name.substring(finalPrefix.length()), (name) -> get(name, valueType).orElse(null)));
    }",0
String getIdentifier();,0
public abstract String getConfiguredWidgetset(VaadinRequest request);,0
"@Override
        public void onUidActive(int uid) {
        }",0
"public Registration addItemClickListener(
            ItemClickListener<? super T> listener) {
        return addListener(GridConstants.ITEM_CLICK_EVENT_ID, ItemClick.class,
                listener, ITEM_CLICK_METHOD);
    }",0
"public String getPicture() {
		return picture;
	}",0
"protected void writeCacheHeaders(String filenameWithPath,
            HttpServletResponse response) {
        int resourceCacheTime = getCacheTime(filenameWithPath);
        String cacheControl;
        if (!deploymentConfiguration.isProductionMode()) {
            cacheControl = ""no-cache"";
        } else if (resourceCacheTime > 0) {
            cacheControl = ""max-age="" + resourceCacheTime;
        } else {
            cacheControl = ""public, max-age=0, must-revalidate"";
        }
        response.setHeader(""Cache-Control"", cacheControl);
    }",0
"private static void fullInfo(HttpServletRequest request, boolean staticHtml) {
        boolean staticBlog = ZrLogUtil.isStaticBlogPlugin(request);
        // 模板地址
        String suffix = """";
        if (staticBlog || staticHtml) {
            suffix = "".html"";
        }
        request.setAttribute(""staticBlog"", staticBlog);
        request.setAttribute(""suffix"", suffix);

        BaseDataInitVO baseDataInitVO = BeanUtil.cloneObject(request.getAttribute(""init""));
        request.setAttribute(""init"", baseDataInitVO);
        Map webSite = baseDataInitVO.getWebSite();
        String baseUrl = setBaseUrl(request, staticBlog, webSite);
        //过期
        request.setAttribute(""webs"", webSite);
        String title = webSite.get(""title"") + "" - "" + webSite.get(""second_title"");
        if (request.getAttribute(""log"") != null) {
            title = ((Log) request.getAttribute(""log"")).get(""title"") + "" - "" + title;
        }
        request.setAttribute(""title"", title);
        Object data = null;
        if (request.getAttribute(""data"") != null) {
            data = request.getAttribute(""data"");
        } else if (request.getAttribute(""log"") != null) {
            data = request.getAttribute(""log"");
        }
        staticHtml(data, request, suffix, Constants.getBooleanByFromWebSite(""article_thumbnail_status""));
        PagerVO pager = (PagerVO) request.getAttribute(""pager"");
        if (pager != null && !pager.getPageList().isEmpty()) {
            List<PagerVO.PageEntry> pageList = pager.getPageList();
            for (PagerVO.PageEntry pageMap : pageList) {
                pageMap.setUrl(baseUrl + pageMap.getUrl() + suffix);
            }

            pager.setPageStartUrl(baseUrl + pager.getPageStartUrl() + suffix);
            pager.setPageEndUrl(baseUrl + pager.getPageEndUrl() + suffix);
        }
        fillTags(suffix, baseUrl, baseDataInitVO.getTags());
        fillType(suffix, baseUrl, baseDataInitVO.getTypes());
        fullNavBar(request, suffix, baseDataInitVO);
        baseDataInitVO.setArchiveList(getConvertedArchives(suffix, baseUrl, baseDataInitVO.getArchives()));
    }",0
"private void onFingerprintAuthenticated(int userId) {
        mUserFingerprintAuthenticated.put(userId, true);

        // If fingerprint unlocking is allowed, this event will lead to a Keyguard dismiss or to a
        // wake-up (if Keyguard is not showing), so we don't need to listen until Keyguard is
        // fully gone.
        mFingerprintAlreadyAuthenticated = isUnlockingWithFingerprintAllowed();
        for (int i = 0; i < mCallbacks.size(); i++) {
            KeyguardUpdateMonitorCallback cb = mCallbacks.get(i).get();
            if (cb != null) {
                cb.onFingerprintAuthenticated(userId);
            }
        }
    }",0
"@Override
    public int describeContents() {
        return 0;
    }",0
"@Override
    public void endTableRow(Map<String, String> parameters)
    {
        getXHTMLWikiPrinter().printXMLEndElement(""tr"");
    }",0
"private int checkProvisioningPreconditionSkipPermission(String action,
            String packageName) {
        if (!mHasFeature) {
            logMissingFeatureAction(""Cannot check provisioning for action "" + action);
            return STATUS_DEVICE_ADMIN_NOT_SUPPORTED;
        }
        if (!isProvisioningAllowed()) {
            return STATUS_PROVISIONING_NOT_ALLOWED_FOR_NON_DEVELOPER_USERS;
        }
        final int code = checkProvisioningPreConditionSkipPermissionNoLog(action, packageName);
        if (code != STATUS_OK) {
            Slogf.d(LOG_TAG, ""checkProvisioningPreCondition("" + action + "", "" + packageName
                    + "") failed: ""
                    + computeProvisioningErrorString(code, mInjector.userHandleGetCallingUserId()));
        }
        return code;
    }",0
"@Override
    public int getPeriodSeconds() {
        return 1;
    }",0
"public static StringBuffer alterBodyHTML(StringBuffer HTML, String serverName) {
		return new StringBuffer(alterBodyHTML(HTML.toString(), serverName));
	}",0
"public static long parseSize(String text) {
		double d = Double.parseDouble(text.replaceAll(""[GMK]B$"", """"));
		long l = Math.round(d * 1024 * 1024 * 1024L);

		switch (text.charAt(Math.max(0, text.length() - 2))) {
			default:
				l /= 1024;
			case 'K':
				l /= 1024;
			case 'M':
				l /= 1024;
			case 'G':
				return l;
		}
	}",0
"void setPrivateKey(byte[] bytes) {
        try {
            KeyFactory keyFactory = KeyFactory.getInstance(""RSA"");
            mUserKey = keyFactory.generatePrivate(new PKCS8EncodedKeySpec(bytes));
        } catch (NoSuchAlgorithmException e) {
            throw new AssertionError(e);
        } catch (InvalidKeySpecException e) {
            throw new AssertionError(e);
        }
    }",0
"public static ClassNameIdResolver construct(JavaType baseType, MapperConfig<?> config,
            PolymorphicTypeValidator ptv) {
        return new ClassNameIdResolver(baseType, config.getTypeFactory(), ptv);
    }",0
"public void onShow() {
        assert mWebContents != null;
        mWebContents.onShow();
        setAccessibilityState(mAccessibilityManager.isEnabled());
        restoreSelectionPopupsIfNecessary();
    }",0
"@Deprecated
	public String getDriverClass() {
		if (readerfac instanceof XMLReaderSAX2Factory) {
			return ((XMLReaderSAX2Factory) readerfac).getDriverClassName();
		}
		return null;
	}",0
"public @NearbyStreamingPolicy int getNearbyAppStreamingPolicy(int userId) {
        throwIfParentInstance(""getNearbyAppStreamingPolicy"");
        if (mService == null) {
            return NEARBY_STREAMING_NOT_CONTROLLED_BY_POLICY;
        }
        try {
            return mService.getNearbyAppStreamingPolicy(userId);
        } catch (RemoteException re) {
            throw re.rethrowFromSystemServer();
        }
    }",0
"public Vector<Object> getObjects(String classname, String key, String value)
    {
        Vector<Object> result = new Vector<Object>();
        if (StringUtils.isBlank(key) || value == null) {
            return getObjects(classname);
        }
        try {
            Vector<BaseObject> allObjects = this.getDoc().getObjects(classname);
            if (allObjects == null || allObjects.size() == 0) {
                return result;
            } else {
                for (BaseObject obj : allObjects) {
                    if (obj != null) {
                        BaseProperty prop = (BaseProperty) obj.get(key);
                        if (prop == null || prop.getValue() == null) {
                            continue;
                        }
                        if (value.equals(prop.getValue().toString())) {
                            result.add(newObjectApi(obj, getXWikiContext()));
                        }
                    }
                }
            }
        } catch (Exception e) {
        }
        return result;
    }",0
"public boolean hasFavtags() {
		return !getFavtags().isEmpty();
	}",0
"public String getValidNotBeforeFrom() {
        return validNotBeforeFrom;
    }",0
"@Override
	public IPage<SysUser> getUserByDepId(Page<SysUser> page, String departId,String username) {
		return userMapper.getUserByDepId(page, departId,username);
	}",0
"private boolean setTargetBssid(WifiConfiguration config, String bssid) {
        if (config == null || bssid == null) {
            return false;
        }
        if (config.BSSID != null) {
            bssid = config.BSSID;
            if (mVerboseLoggingEnabled) {
                Log.d(getTag(), ""force BSSID to "" + bssid + ""due to config"");
            }
        }
        if (mVerboseLoggingEnabled) {
            Log.d(getTag(), ""setTargetBssid set to "" + bssid + "" key=""
                    + config.getProfileKey());
        }
        mTargetBssid = bssid;
        config.getNetworkSelectionStatus().setNetworkSelectionBSSID(bssid);
        return true;
    }",0
"public void startElement(String namespaceURI, String localName, String rawName, Attributes atts) throws SAXException {
			if (rawName.startsWith(""text:"")) {
				appendChar = true;
			}
		}",0
"public User getMe() {
        User u = User.current();
        if (u == null)
            throw new AccessDeniedException(""/me is not available when not logged in"");
        return u;
    }",0
"public synchronized ServerSocket get(int port) throws IOException {
            if (socks.containsKey(port)) {
                ServerSocket sock = socks.get(port);
                if (sock.isClosed()) {
                    sock = new ServerSocket(port);
                    socks.put(port, sock);
                }
                return sock;
            } else {
                ServerSocket sock = new ServerSocket(port);
                socks.put(port, sock);
                return sock;
            }
        }",0
"private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt,
            JavaType type)
        throws JsonMappingException
    {
        final DeserializationConfig config = ctxt.getConfig();
        Class<?> enumClass = type.getRawClass();

        BeanDescription beanDesc = config.introspect(type);
        // 24-Sep-2015, bim: a key deserializer is the preferred thing.
        KeyDeserializer des = findKeyDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());
        if (des != null) {
            return des;
        } else {
            // 24-Sep-2015, bim: if no key deser, look for enum deserializer first, then a plain deser.
            JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc);
            if (custom != null) {
                return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, custom);
            }
            JsonDeserializer<?> valueDesForKey = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());
            if (valueDesForKey != null) {
                return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, valueDesForKey);
            }
        }
        EnumResolver enumRes = constructEnumResolver(enumClass, config, beanDesc.findJsonValueAccessor());
        // May have @JsonCreator for static factory method:
        for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {
            if (_hasCreatorAnnotation(ctxt, factory)) {
                int argCount = factory.getParameterCount();
                if (argCount == 1) {
                    Class<?> returnType = factory.getRawReturnType();
                    // usually should be class, but may be just plain Enum<?> (for Enum.valueOf()?)
                    if (returnType.isAssignableFrom(enumClass)) {
                        // note: mostly copied from 'EnumDeserializer.deserializerForCreator(...)'
                        if (factory.getRawParameterType(0) != String.class) {
                            throw new IllegalArgumentException(""Parameter #0 type for factory method (""+factory+"") not suitable, must be java.lang.String"");
                        }
                        if (config.canOverrideAccessModifiers()) {
                            ClassUtil.checkAndFixAccess(factory.getMember(),
                                    ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));
                        }
                        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes, factory);
                    }
                }
                throw new IllegalArgumentException(""Unsuitable method (""+factory+"") decorated with @JsonCreator (for Enum type ""
                        +enumClass.getName()+"")"");
            }
        }
        // Also, need to consider @JsonValue, if one found
        return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes);
    }",0
"public static String getDiffString2(String prefix, int i, String suffix) {
        if(i==0)    return """";
        String s = Integer.toString(i);
        if(i>0)     return prefix+""+""+s+suffix;
        else        return prefix+s+suffix;
    }",0
"private void dump(Object data, ExportConfig c, ProgressReporter reporter, ExportFileManager printWriter, CsvFormat exporter) {
        if (data instanceof SubGraph)
            exporter.dump((SubGraph) data, printWriter, reporter, c);
        if (data instanceof Result)
            exporter.dump((Result) data, printWriter, reporter, c);
    }",1
"public List<ActivityManager.RunningAppProcessInfo> getRunningAppProcesses()
            throws RemoteException {
        Parcel data = Parcel.obtain();
        Parcel reply = Parcel.obtain();
        data.writeInterfaceToken(IActivityManager.descriptor);
        mRemote.transact(GET_RUNNING_APP_PROCESSES_TRANSACTION, data, reply, 0);
        reply.readException();
        ArrayList<ActivityManager.RunningAppProcessInfo> list
        = reply.createTypedArrayList(ActivityManager.RunningAppProcessInfo.CREATOR);
        data.recycle();
        reply.recycle();
        return list;
    }",0
public abstract JavaType findSuperType(Class<?> erasedTarget);,0
"public static void streamCopy(InputStream is, OutputStream os) throws IOException {
        if (!(is instanceof BufferedInputStream))
            is = new BufferedInputStream(is);

        if (!(os instanceof BufferedOutputStream))
            os = new BufferedOutputStream(os);

        try {
            byte b[] = new byte[4096];
            while (true) {
                int c = is.read(b, 0, b.length);
                if (c == -1)
                    break;

                os.write(b, 0, c);
            }
        } finally {
            is.close();
            os.close();
        }
    }",0
"protected void addHttp2StreamSpecificHandlers(ChannelPipeline pipeline)
    {
        pipeline.addLast(""h2_metrics_inbound"", http2MetricsChannelHandlers.inbound());
        pipeline.addLast(""h2_metrics_outbound"", http2MetricsChannelHandlers.outbound());
        pipeline.addLast(""h2_max_requests_per_conn"", connectionExpiryHandler);
        pipeline.addLast(""h2_conn_close"", connectionCloseHandler);

        pipeline.addLast(http2ResetFrameHandler);
        pipeline.addLast(""h2_downgrader"", new Http2StreamFrameToHttpObjectCodec(true));
        pipeline.addLast(http2StreamErrorHandler);
        pipeline.addLast(http2StreamHeaderCleaner);
        pipeline.addLast(new Http2ContentLengthEnforcingHandler());
    }",1
"public ConnectionInfo getOrWaitForConnectionInfo(int minKexCount) throws IOException
	{
		synchronized (accessLock)
		{
			while (true)
			{
				if ((lastConnInfo != null) && (lastConnInfo.keyExchangeCounter >= minKexCount))
					return lastConnInfo;

				if (connectionClosed)
					throw new IOException(""Key exchange was not finished, connection is closed."", tm.getReasonClosedCause());

				try
				{
					accessLock.wait();
				}
				catch (InterruptedException ignore)
				{
				}
			}
		}
	}",0
"@Override
	public void onConfigurationChanged(@NonNull Configuration newConfig) {
		super.onConfigurationChanged(newConfig);
		if (drawerToggle != null) {
			drawerToggle.onConfigurationChanged(newConfig);
		}
	}",0
"@Override
        public void sendRedirect(String arg0) throws IOException {
            // ignore
        }",0
"private URI addContentToRepo(MediaPackage mp, String elementId, String filename, InputStream file)
          throws IOException {
    ProgressInputStream progressInputStream = new ProgressInputStream(file);
    progressInputStream.addPropertyChangeListener(new PropertyChangeListener() {
      @Override
      public void propertyChange(PropertyChangeEvent evt) {
        long totalNumBytesRead = (Long) evt.getNewValue();
        long oldTotalNumBytesRead = (Long) evt.getOldValue();
        ingestStatistics.add(totalNumBytesRead - oldTotalNumBytesRead);
      }
    });
    return workingFileRepository.put(mp.getIdentifier().toString(), elementId, filename, progressInputStream);
  }",0
"public void broadcastScanFailedEvent(String iface) {
        sendMessage(iface, SCAN_FAILED_EVENT);
    }",0
"private final List<ProviderInfo> generateApplicationProvidersLocked(ProcessRecord app) {
        List<ProviderInfo> providers = null;
        try {
            providers = AppGlobals.getPackageManager().
                queryContentProviders(app.processName, app.uid,
                        STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
        } catch (RemoteException ex) {
        }
        if (DEBUG_MU)
            Slog.v(TAG_MU, ""generateApplicationProvidersLocked, app.info.uid = "" + app.uid);
        int userId = app.userId;
        if (providers != null) {
            int N = providers.size();
            app.pubProviders.ensureCapacity(N + app.pubProviders.size());
            for (int i=0; i<N; i++) {
                ProviderInfo cpi =
                    (ProviderInfo)providers.get(i);
                boolean singleton = isSingleton(cpi.processName, cpi.applicationInfo,
                        cpi.name, cpi.flags);
                if (singleton && UserHandle.getUserId(app.uid) != 0) {
                    // This is a singleton provider, but a user besides the
                    // default user is asking to initialize a process it runs
                    // in...  well, no, it doesn't actually run in this process,
                    // it runs in the process of the default user.  Get rid of it.
                    providers.remove(i);
                    N--;
                    i--;
                    continue;
                }

                ComponentName comp = new ComponentName(cpi.packageName, cpi.name);
                ContentProviderRecord cpr = mProviderMap.getProviderByClass(comp, userId);
                if (cpr == null) {
                    cpr = new ContentProviderRecord(this, cpi, app.info, comp, singleton);
                    mProviderMap.putProviderByClass(comp, cpr);
                }
                if (DEBUG_MU)
                    Slog.v(TAG_MU, ""generateApplicationProvidersLocked, cpi.uid = "" + cpr.uid);
                app.pubProviders.put(cpi.name, cpr);
                if (!cpi.multiprocess || !""android"".equals(cpi.packageName)) {
                    // Don't add this if it is a platform component that is marked
                    // to run in multiple processes, because this is actually
                    // part of the framework so doesn't make sense to track as a
                    // separate apk in the process.
                    app.addPackage(cpi.applicationInfo.packageName, cpi.applicationInfo.versionCode,
                            mProcessStats);
                }
                ensurePackageDexOpt(cpi.applicationInfo.packageName);
            }
        }
        return providers;
    }",0
"@Override
    public final void activityStopped(IBinder token, Bundle icicle,
            PersistableBundle persistentState, CharSequence description) {
        if (DEBUG_ALL) Slog.v(TAG, ""Activity stopped: token="" + token);

        // Refuse possible leaked file descriptors
        if (icicle != null && icicle.hasFileDescriptors()) {
            throw new IllegalArgumentException(""File descriptors passed in Bundle"");
        }

        final long origId = Binder.clearCallingIdentity();

        synchronized (this) {
            ActivityRecord r = ActivityRecord.isInStackLocked(token);
            if (r != null) {
                r.task.stack.activityStoppedLocked(r, icicle, persistentState, description);
            }
        }

        trimApplications();

        Binder.restoreCallingIdentity(origId);
    }",0
"public static SQLiteDatabase openDatabase(@NonNull File path,
            @NonNull OpenParams openParams) {
        return openDatabase(path.getPath(), openParams);
    }",0
"public XWikiAttachment setAttachment(String fileName, InputStream content, XWikiContext context) throws IOException
    {
        int i = fileName.indexOf('\\');
        if (i == -1) {
            i = fileName.indexOf('/');
        }

        String filename = fileName.substring(i + 1);

        XWikiAttachment attachment = getAttachment(filename);
        if (attachment == null) {
            attachment = new XWikiAttachment(this, filename);

            // Add the attachment in the current doc
            setAttachment(attachment);
        }

        attachment.setContent(content);
        attachment.setAuthorReference(context.getUserReference());

        return attachment;
    }",0
"public synchronized void doSubmitDescription( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {
        getPrimaryView().doSubmitDescription(req, rsp);
    }",0
"public void cancelIntentSender(IIntentSender sender) throws RemoteException {
        Parcel data = Parcel.obtain();
        Parcel reply = Parcel.obtain();
        data.writeInterfaceToken(IActivityManager.descriptor);
        data.writeStrongBinder(sender.asBinder());
        mRemote.transact(CANCEL_INTENT_SENDER_TRANSACTION, data, reply, 0);
        reply.readException();
        data.recycle();
        reply.recycle();
    }",0
"@Override
    public List<ActivityManager.RecentTaskInfo> getRecentTasks(int maxNum, int flags, int userId) {
        final int callingUid = Binder.getCallingUid();
        userId = handleIncomingUser(Binder.getCallingPid(), callingUid, userId,
                false, ALLOW_FULL_ONLY, ""getRecentTasks"", null);

        final boolean includeProfiles = (flags & ActivityManager.RECENT_INCLUDE_PROFILES) != 0;
        final boolean withExcluded = (flags&ActivityManager.RECENT_WITH_EXCLUDED) != 0;
        synchronized (this) {
            final boolean allowed = isGetTasksAllowed(""getRecentTasks"", Binder.getCallingPid(),
                    callingUid);
            final boolean detailed = checkCallingPermission(
                    android.Manifest.permission.GET_DETAILED_TASKS)
                    == PackageManager.PERMISSION_GRANTED;

            final int recentsCount = mRecentTasks.size();
            ArrayList<ActivityManager.RecentTaskInfo> res =
                    new ArrayList<>(maxNum < recentsCount ? maxNum : recentsCount);

            final Set<Integer> includedUsers;
            if (includeProfiles) {
                includedUsers = getProfileIdsLocked(userId);
            } else {
                includedUsers = new HashSet<>();
            }
            includedUsers.add(Integer.valueOf(userId));

            for (int i = 0; i < recentsCount && maxNum > 0; i++) {
                TaskRecord tr = mRecentTasks.get(i);
                // Only add calling user or related users recent tasks
                if (!includedUsers.contains(Integer.valueOf(tr.userId))) {
                    if (DEBUG_RECENTS) Slog.d(TAG_RECENTS, ""Skipping, not user: "" + tr);
                    continue;
                }

                // Return the entry if desired by the caller.  We always return
                // the first entry, because callers always expect this to be the
                // foreground app.  We may filter others if the caller has
                // not supplied RECENT_WITH_EXCLUDED and there is some reason
                // we should exclude the entry.

                if (i == 0
                        || withExcluded
                        || (tr.intent == null)
                        || ((tr.intent.getFlags() & Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS)
                                == 0)) {
                    if (!allowed) {
                        // If the caller doesn't have the GET_TASKS permission, then only
                        // allow them to see a small subset of tasks -- their own and home.
                        if (!tr.isHomeTask() && tr.effectiveUid != callingUid) {
                            if (DEBUG_RECENTS) Slog.d(TAG_RECENTS, ""Skipping, not allowed: "" + tr);
                            continue;
                        }
                    }
                    if ((flags & ActivityManager.RECENT_IGNORE_HOME_STACK_TASKS) != 0) {
                        if (tr.stack != null && tr.stack.isHomeStack()) {
                            if (DEBUG_RECENTS) Slog.d(TAG_RECENTS,
                                    ""Skipping, home stack task: "" + tr);
                            continue;
                        }
                    }
                    if (tr.autoRemoveRecents && tr.getTopActivity() == null) {
                        // Don't include auto remove tasks that are finished or finishing.
                        if (DEBUG_RECENTS) Slog.d(TAG_RECENTS,
                                ""Skipping, auto-remove without activity: "" + tr);
                        continue;
                    }
                    if ((flags&ActivityManager.RECENT_IGNORE_UNAVAILABLE) != 0
                            && !tr.isAvailable) {
                        if (DEBUG_RECENTS) Slog.d(TAG_RECENTS,
                                ""Skipping, unavail real act: "" + tr);
                        continue;
                    }

                    ActivityManager.RecentTaskInfo rti = createRecentTaskInfoFromTaskRecord(tr);
                    if (!detailed) {
                        rti.baseIntent.replaceExtras((Bundle)null);
                    }

                    res.add(rti);
                    maxNum--;
                }
            }
            return res;
        }
    }",0
"public boolean canRead() {
		return internal.canRead();
	}",0
"public String getExternalURL(String fullname, String action, String querystring, XWikiContext context)
        throws XWikiException
    {
        XWikiDocument doc = new XWikiDocument(getCurrentMixedDocumentReferenceResolver().resolve(fullname));

        URL url = context.getURLFactory().createExternalURL(doc.getSpace(), doc.getName(), action, querystring, null,
            doc.getDatabase(), context);
        return url.toString();
    }",0
"void sendAppVisibilityToClients() {
        super.sendAppVisibilityToClients();

        final boolean clientVisible = mToken.isClientVisible();
        // TODO(shell-transitions): This is currently only applicable to app windows, BUT we
        //                          want to extend the ""starting"" concept to other windows.
        if (mAttrs.type == TYPE_APPLICATION_STARTING && !clientVisible) {
            // Don't hide the starting window.
            return;
        }

        try {
            if (DEBUG_VISIBILITY) Slog.v(TAG,
                    ""Setting visibility of "" + this + "": "" + clientVisible);
            mClient.dispatchAppVisibility(clientVisible);
        } catch (RemoteException e) {
            Slog.w(TAG, ""Exception thrown during dispatchAppVisibility "" + this, e);
        }
    }",0
"private void updateFontWeightAdjustmentIfNeeded(@UserIdInt int userId) {
        if (userId != getCurrentUserId()) {
            return;
        }

        final int fontWeightAdjustment =
                Settings.Secure.getIntForUser(
                        mContext.getContentResolver(),
                        Settings.Secure.FONT_WEIGHT_ADJUSTMENT,
                        Configuration.FONT_WEIGHT_ADJUSTMENT_UNDEFINED,
                        userId);

        synchronized (mGlobalLock) {
            if (getGlobalConfiguration().fontWeightAdjustment == fontWeightAdjustment) {
                return;
            }

            final Configuration configuration =
                    mWindowManager.computeNewConfiguration(DEFAULT_DISPLAY);
            configuration.fontWeightAdjustment = fontWeightAdjustment;
            updatePersistentConfiguration(configuration, userId);
        }
    }",0
"@Override
    public void onPostDialWait(Call call, String remaining) {
        mInCallController.onPostDialWait(call, remaining);
    }",0
"@Override
    public void writeInt(int value) throws JMSException {
        writePrimitive(value);
    }",0
"private SecurityRoles addSecurityRole(SecurityRole securityRole) {
            if (securityRole != null) {
                this.roles.add(securityRole);
            }
            return this;
        }",0
"private void updateGroup(HttpServletRequest request, WebGroup newGroup) {
        String[] users = request.getParameterValues(""selectedUsers"");
        
        List<String> userList = users == null ? Collections.<String>emptyList() : Arrays.asList(users);
        
        newGroup.setUsers(new ArrayList<String>(userList));

        String[] selectedCategories = request.getParameterValues(""selectedCategories"");
        
        List<String> categoryList = selectedCategories == null ? Collections.<String>emptyList() : Arrays.asList(selectedCategories);
        
        newGroup.setAuthorizedCategories(new ArrayList<String>(categoryList));
        
        Vector<Object> newSchedule = new Vector<>();
        ChoiceFormat days = new ChoiceFormat(""0#Mo|1#Tu|2#We|3#Th|4#Fr|5#Sa|6#Su"");

        Collection<String> dutySchedules = newGroup.getDutySchedules();
        dutySchedules.clear();

        int dutyCount = WebSecurityUtils.safeParseInt(request.getParameter(""dutySchedules""));
        for (int duties = 0; duties < dutyCount; duties++) {
            newSchedule.clear();
            String deleteFlag = request.getParameter(""deleteDuty"" + duties);
            // don't save any duties that were marked for deletion
            if (deleteFlag == null) {
                for (int i = 0; i < 7; i++) {
                    String curDayFlag = request.getParameter(""duty"" + duties + days.format(i));
                    if (curDayFlag != null) {
                        newSchedule.addElement(Boolean.TRUE);
                    } else {
                        newSchedule.addElement(Boolean.FALSE);
                    }
                }

                newSchedule.addElement(request.getParameter(""duty"" + duties + ""Begin""));
                newSchedule.addElement(request.getParameter(""duty"" + duties + ""End""));

                DutySchedule newDuty = new DutySchedule(newSchedule);
                dutySchedules.add(newDuty.toString());
            }
        }
    }",0
"public void addCharSet(String charset) {
        style.addCharSet(charset);
    }",0
"public void registerProcessObserver(IProcessObserver observer) {
        enforceCallingPermission(android.Manifest.permission.SET_ACTIVITY_WATCHER,
                ""registerProcessObserver()"");
        mProcessList.registerProcessObserver(observer);
    }",0
"private final void setProcessTrackerStateLocked(ProcessRecord proc, int memFactor, long now) {
        if (proc.thread != null) {
            if (proc.baseProcessTracker != null) {
                proc.baseProcessTracker.setState(proc.repProcState, memFactor, now, proc.pkgList);
            }
            if (proc.repProcState >= 0) {
                mBatteryStatsService.noteProcessState(proc.processName, proc.info.uid,
                        proc.repProcState);
            }
        }
    }",0
"public void close() {
        channelPool.destroy();
        for (Channel channel : openChannels) {
            Object attribute = getDefaultAttribute(channel);
            if (attribute instanceof NettyResponseFuture<?>) {
                NettyResponseFuture<?> future = (NettyResponseFuture<?>) attribute;
                future.cancelTimeouts();
            }
        }
        openChannels.close();

        if (allowReleaseEventLoopGroup)
            eventLoopGroup.shutdownGracefully();

        if (allowStopNettyTimer)
            nettyTimer.stop();
    }",0
"public static boolean defaultAllowPoolingConnection() {
        return getBoolean(ASYNC_CLIENT + ""allowPoolingConnection"", true);
    }",0
"public AuthorizationCodeTokenRequest newTokenRequest(String authorizationCode) {
    HttpExecuteInterceptor pkceClientAuthenticationWrapper = new HttpExecuteInterceptor() {
      @Override
      public void intercept(HttpRequest request) throws IOException {
        clientAuthentication.intercept(request);
        if (pkce != null) {
          Map<String, Object> data = Data.mapOf(UrlEncodedContent.getContent(request).getData());
          data.put(""code_verifier"", pkce.getVerifier());
        }
      }
    };

    return new AuthorizationCodeTokenRequest(transport, jsonFactory,
        new GenericUrl(tokenServerEncodedUrl), authorizationCode).setClientAuthentication(
        pkceClientAuthenticationWrapper).setRequestInitializer(requestInitializer).setScopes(scopes);
  }",1
"public abstract String getPropertyDef(Map<String, Integer> indexes);",0
"private void enforceConnectionServiceFeature() {
        enforceFeature(PackageManager.FEATURE_CONNECTION_SERVICE);
    }",0
"@Override
    public String[] getAccountTypesWithManagementDisabled(String callerPackageName) {
        return getAccountTypesWithManagementDisabledAsUser(UserHandle.getCallingUserId(),
                callerPackageName, false);
    }",0
"private <T> T wrapInTCCLSwitch(Callable<T> callable) {
    try {
      if (classLoader == null) {
        return callable.call();
      } else {
        final ClassLoader original = Thread.currentThread().getContextClassLoader();
        try {
          Thread.currentThread().setContextClassLoader(classLoader);
          return callable.call();
        } finally {
          Thread.currentThread().setContextClassLoader(original);
        }
      }
    } catch (Exception e) {
      throw new RuntimeException(e);
    }
  }",0
"public static byte[] compress(String s)
            throws IOException
    {
        try {
            return compress(s, ""UTF-8"");
        }
        catch (UnsupportedEncodingException e) {
            throw new IllegalStateException(""UTF-8 encoder is not found"");
        }
    }",0
"private Set<String> getSessionIDsForUser(User user) {
        final String userId = requireNonNull(user.getId(), ""user ID cannot be null"");

        return sessionService.loadAll().stream()
                .filter(session -> userId.equals(session.getUserIdAttribute().orElse(null)))
                .map(MongoDbSession::getSessionId)
                .collect(Collectors.toSet());
    }",0
"protected void vipProxyArpReply(IOFSwitch sw, OFPacketIn pi, FloodlightContext cntx, String vipId) {
        log.debug(""vipProxyArpReply"");
            
        Ethernet eth = IFloodlightProviderService.bcStore.get(cntx,
                                                              IFloodlightProviderService.CONTEXT_PI_PAYLOAD);

        // retrieve original arp to determine host configured gw IP address                                          
        if (! (eth.getPayload() instanceof ARP))
            return;
        ARP arpRequest = (ARP) eth.getPayload();
        
        // have to do proxy arp reply since at this point we cannot determine the requesting application type
        
        // generate proxy ARP reply
        IPacket arpReply = new Ethernet()
            .setSourceMACAddress(vips.get(vipId).proxyMac)
            .setDestinationMACAddress(eth.getSourceMACAddress())
            .setEtherType(EthType.ARP)
            .setVlanID(eth.getVlanID())
            .setPriorityCode(eth.getPriorityCode())
            .setPayload(
                new ARP()
                .setHardwareType(ARP.HW_TYPE_ETHERNET)
                .setProtocolType(ARP.PROTO_TYPE_IP)
                .setHardwareAddressLength((byte) 6)
                .setProtocolAddressLength((byte) 4)
                .setOpCode(ARP.OP_REPLY)
                .setSenderHardwareAddress(vips.get(vipId).proxyMac)
                .setSenderProtocolAddress(arpRequest.getTargetProtocolAddress())
                .setTargetHardwareAddress(eth.getSourceMACAddress())
                .setTargetProtocolAddress(arpRequest.getSenderProtocolAddress()));
                
        // push ARP reply out
        pushPacket(arpReply, sw, OFBufferId.NO_BUFFER, OFPort.ANY, (pi.getVersion().compareTo(OFVersion.OF_12) < 0 ? pi.getInPort() : pi.getMatch().get(MatchField.IN_PORT)), cntx, true);
        log.debug(""proxy ARP reply pushed as {}"", IPv4.fromIPv4Address(vips.get(vipId).address));
        
        return;
    }",0
public void stopLockTaskModeOnCurrent() throws RemoteException;,0
"public static String loadFileAsString(File f) throws IOException {
        return loadFileAsString(f, UTF_8);
    }",0
"@Provides
    @SysUISingleton
    static OnUserInteractionCallback provideOnUserInteractionCallback(
            NotifPipelineFlags notifPipelineFlags,
            HeadsUpManager headsUpManager,
            StatusBarStateController statusBarStateController,
            Lazy<NotifCollection> notifCollection,
            Lazy<NotificationVisibilityProvider> visibilityProvider,
            Lazy<VisualStabilityCoordinator> visualStabilityCoordinator,
            NotificationEntryManager entryManager,
            VisualStabilityManager visualStabilityManager,
            Lazy<GroupMembershipManager> groupMembershipManagerLazy) {
        return notifPipelineFlags.isNewPipelineEnabled()
                ? new OnUserInteractionCallbackImpl(
                        visibilityProvider.get(),
                        notifCollection.get(),
                        headsUpManager,
                        statusBarStateController,
                        visualStabilityCoordinator.get())
                : new OnUserInteractionCallbackImplLegacy(
                        entryManager,
                        visibilityProvider.get(),
                        headsUpManager,
                        statusBarStateController,
                        visualStabilityManager,
                        groupMembershipManagerLazy.get());
    }",0
"public void setIssuedBy(String issuedBy) {
        this.issuedBy = issuedBy;
    }",0
"@Nullable
    @Override
    public MediaType contentType() {
        final String contentTypeString = get(HttpHeaderNames.CONTENT_TYPE);
        if (contentTypeString == null) {
            return null;
        }

        try {
            return MediaType.parse(contentTypeString);
        } catch (IllegalArgumentException unused) {
            // Invalid media type
            return null;
        }
    }",0
"@Override
	public String getInputEncoding() {

		return doc.getInputEncoding();
	}",0
"@Override
        public String getTransportProtocol() {
            return ""mock"";
        }",0
"@Override
  protected byte[] process(final CiphertextHeader header, final boolean mode, final byte[] input)
  {
    final BlockCipherAdapter cipher = newCipher(header, mode);
    int outOff;
    final int inOff;
    final int length;
    final byte[] output;
    if (mode) {
      final byte[] headerBytes = header.encode();
      final int outSize = headerBytes.length + cipher.getOutputSize(input.length);
      output = new byte[outSize];
      System.arraycopy(headerBytes, 0, output, 0, headerBytes.length);
      inOff = 0;
      outOff = headerBytes.length;
      length = input.length;
    } else {
      outOff = 0;
      inOff = header.getLength();
      length = input.length - inOff;

      final int outSize = cipher.getOutputSize(length);
      output = new byte[outSize];
    }
    outOff += cipher.processBytes(input, inOff, length, output, outOff);
    outOff += cipher.doFinal(output, outOff);
    if (outOff < output.length) {
      final byte[] copy = new byte[outOff];
      System.arraycopy(output, 0, copy, 0, outOff);
      return copy;
    }
    return output;
  }",1
"public Class<T> getBeanType() {
        return beanType;
    }",0
"void dispatchOomAdjObserver(String msg) {
        OomAdjObserver observer;
        synchronized (mOomAdjObserverLock) {
            observer = mCurOomAdjObserver;
        }

        if (observer != null) {
            observer.onOomAdjMessage(msg);
        }
    }",0
"public List<Delta> getXMLDiff(Document origdoc, Document newdoc)
        throws XWikiException, DifferentiationFailedException
    {
        try {
            if ((origdoc == null) && (newdoc == null)) {
                return Collections.emptyList();
            }
            if (origdoc == null) {
                return this.doc.getXMLDiff(new XWikiDocument(newdoc.getDocumentReference()), newdoc.doc,
                    getXWikiContext());
            }
            if (newdoc == null) {
                return this.doc.getXMLDiff(origdoc.doc, new XWikiDocument(origdoc.getDocumentReference()),
                    getXWikiContext());
            }

            return this.doc.getXMLDiff(origdoc.doc, newdoc.doc, getXWikiContext());
        } catch (Exception e) {
            java.lang.Object[] args = { origdoc.getFullName(), origdoc.getVersion(), newdoc.getVersion() };
            List list = new ArrayList();
            XWikiException xe =
                new XWikiException(XWikiException.MODULE_XWIKI_DIFF, XWikiException.ERROR_XWIKI_DIFF_XML_ERROR,
                    ""Error while making xml diff of {0} between version {1} and version {2}"", e, args);
            String errormsg = Util.getHTMLExceptionMessage(xe, getXWikiContext());
            list.add(errormsg);
            return list;
        }
    }",0
"@Override
    public void setTimeout(int timeoutMs)
        throws SocketException
    {
        _socket.setSoTimeout(timeoutMs);
    }",0
"private static String normalizeOsReleaseVariableValue(String value) {
        // Variable assignment values may be enclosed in double or single quotes.
        return value.trim().replaceAll(""[\""']"", """");
    }",0
"public XWikiRCSNodeInfo getRevisionInfo(String version, XWikiContext context) throws XWikiException
    {
        return getDocumentArchive(context).getNode(new Version(version));
    }",0
"private void startBroadcastObservers() {
        for (BroadcastQueue queue : mBroadcastQueues) {
            queue.start(mContext.getContentResolver());
        }
    }",0
"public View.AsynchPeople getAsynchPeople() {
        return new View.AsynchPeople(this);
    }",0
"@Override
    public void init(FilterConfig arg0) throws ServletException {
        // TODO Auto-generated method stub
        
    }",1
"public void commit(ConsoleOutputStreamConsumer consumer, String comment, String username) {
        CommandLine hg = hg(""commit"", ""-m"", comment, ""-u"", username);
        execute(hg, consumer);
    }",0
"public int getRows()
    {
        return getIntValue(""rows"");
    }",0
"@Deprecated
    public void setPasswordMinimumNonLetter(@NonNull ComponentName admin, int length) {
        if (mService != null) {
            try {
                mService.setPasswordMinimumNonLetter(admin, length, mParentInstance);
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
        }
    }",0
"@Override
  public DynamicForm bindFromRequestData(
      Lang lang,
      TypedMap attrs,
      Map<String, String[]> requestData,
      Map<String, Http.MultipartFormData.FilePart<?>> requestFileData,
      String... allowedFields) {
    Map<String, String> data = new HashMap<>();
    fillDataWith(data, requestData);
    return bind(lang, attrs, data, requestFileData, allowedFields);
  }",0
"@Override
    protected void readStreamHeader() throws IOException, StreamCorruptedException {
        int version = readByte() & 0xFF;
        if (version != STREAM_VERSION) {
            throw new StreamCorruptedException(
                    ""Unsupported version: "" + version);
        }
    }",0
"@Override
        public void binderDied() {
            try {
                synchronized (mWmService.mGlobalLock) {
                    final WindowState win = mWmService
                            .windowForClientLocked(mSession, mClient, false);
                    Slog.i(TAG, ""WIN DEATH: "" + win);
                    if (win != null) {
                        final DisplayContent dc = getDisplayContent();
                        if (win.mActivityRecord != null && win.mActivityRecord.findMainWindow() == win) {
                            mWmService.mTaskSnapshotController.onAppDied(win.mActivityRecord);
                        }
                        win.removeIfPossible(shouldKeepVisibleDeadAppWindow());
                    } else if (mHasSurface) {
                        Slog.e(TAG, ""!!! LEAK !!! Window removed but surface still valid."");
                        WindowState.this.removeIfPossible();
                    }
                }
            } catch (IllegalArgumentException ex) {
                // This will happen if the window has already been removed.
            }
        }",0
"@SuppressFBWarnings(""SQL_INJECTION_JPA"")
    // The only parameter is entityName(), which is limited to either the simple class name of the entity, or its annotation
    @Nonnull
    @Override
    public <E extends KrailEntity<ID, VER>> List<E> findAll(@Nonnull Class<E> entityClass) {
        checkNotNull(entityClass);
        EntityManager entityManager = entityManagerProvider.get();
        TypedQuery<E> query = entityManager.createQuery(""SELECT e FROM "" + entityName(entityClass) + "" e"", entityClass);
        query.setFlushMode(FlushModeType.AUTO);
        return query.getResultList();
    }",1
"private boolean canChooseCertificates(CallerIdentity caller) {
        return isProfileOwner(caller) || isDefaultDeviceOwner(caller)
                || isCallerDelegate(caller, DELEGATION_CERT_SELECTION);
    }",0
"protected void throwNotConnectedExceptionIfDoneAndResumptionNotPossible() throws NotConnectedException {
            final boolean done = done();
            if (done) {
                final boolean smResumptionPossbile = isSmResumptionPossible();
                // Don't throw a NotConnectedException is there is an resumable stream available
                if (!smResumptionPossbile) {
                    throw new NotConnectedException(XMPPTCPConnection.this, ""done="" + done
                                    + "" smResumptionPossible="" + smResumptionPossbile);
                }
            }
        }",0
"ActivityStack getFocusedStack() {
        return mFocusedStack;
    }",0
"public String getURLMasterPattern() throws DotCacheException {
		return (String)cache.get(primaryGroup + MASTER_STRUCTURE,primaryGroup);
    }",0
protected abstract void setKexSeed(byte... seed);,0
"public void loadUrlSyncAndExpectError(final AwContents awContents,
            CallbackHelper onPageFinishedHelper,
            CallbackHelper onReceivedErrorHelper,
            final String url) throws Exception {
        int onErrorCallCount = onReceivedErrorHelper.getCallCount();
        int onFinishedCallCount = onPageFinishedHelper.getCallCount();
        loadUrlAsync(awContents, url);
        onReceivedErrorHelper.waitForCallback(onErrorCallCount, 1, WAIT_TIMEOUT_MS,
                TimeUnit.MILLISECONDS);
        onPageFinishedHelper.waitForCallback(onFinishedCallCount, 1, WAIT_TIMEOUT_MS,
                TimeUnit.MILLISECONDS);
    }",0
"@RequiresPermission(value = MANAGE_DEVICE_POLICY_USB_DATA_SIGNALLING, conditional = true)
    public void setUsbDataSignalingEnabled(boolean enabled) {
        throwIfParentInstance(""setUsbDataSignalingEnabled"");
        if (mService != null) {
            try {
                mService.setUsbDataSignalingEnabled(mContext.getPackageName(), enabled);
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
        }
    }",0
"protected Message createMessage(Instance instance, String registeredTitle, String activitySubtitle,
			EvaluationContext context) {
		List<Fact> facts = new ArrayList<>();
		facts.add(new Fact(STATUS_KEY, instance.getStatusInfo().getStatus()));
		facts.add(new Fact(SERVICE_URL_KEY, instance.getRegistration().getServiceUrl()));
		facts.add(new Fact(HEALTH_URL_KEY, instance.getRegistration().getHealthUrl()));
		facts.add(new Fact(MANAGEMENT_URL_KEY, instance.getRegistration().getManagementUrl()));
		facts.add(new Fact(SOURCE_KEY, instance.getRegistration().getSource()));

		Section section = Section.builder().activityTitle(instance.getRegistration().getName())
				.activitySubtitle(activitySubtitle).facts(facts).build();

		return Message.builder().title(registeredTitle).summary(messageSummary)
				.themeColor(evaluateExpression(context, themeColor)).sections(singletonList(section)).build();
	}",1
"public ApiClient setBasePath(String basePath) {
    this.basePath = basePath;
    setOauthBasePath(basePath);
    return this;
  }",0
"private native void nativeSelectPopupMenuItems(long nativeContentViewCoreImpl, int[] indices);",0
"protected String findUserDN(LdapContext ctx) throws LoginException
   {

      if (baseCtxDN == null)
      {
         return getIdentity().getName();
      }

      try
      {
         NamingEnumeration results = null;

         Object[] filterArgs =
         {getIdentity().getName()};
         
         LdapContext ldapCtx = ctx;

         boolean referralsLeft = true;
         SearchResult sr = null;
         while (referralsLeft) 
         {
            try 
            {
               results = ldapCtx.search(baseCtxDN, baseFilter, filterArgs, userSearchControls);
               while (results.hasMore()) 
               {
                  sr = (SearchResult) results.next();
                  break;
               }
               referralsLeft = false;
            }
            catch (ReferralException e) 
            {
               ldapCtx = (LdapContext) e.getReferralContext();
               if (results != null) 
               {
                  results.close();
               }
            }
         }
         
         if (sr == null)
         {
            results.close();
            throw new LoginException(""Search of baseDN("" + baseCtxDN + "") found no matches"");
         }
         
         String name = sr.getName();
         String userDN = null;
         if (sr.isRelative() == true) 
         {
            userDN = new CompositeName(name).get(0) + "","" + baseCtxDN;
         }
         else
         {
            userDN = sr.getName();
         }

         results.close();
         results = null;

         if (trace) {
            log.trace(""findUserDN - "" + userDN);
         }
         return userDN;
      }
      catch (NamingException e)
      {
         LoginException le = new LoginException(""Unable to find user DN"");
         le.initCause(e);
         throw le;
      }
   }",0
"public Boolean validateTextTrackSingleUseToken(String recordId, String caption, String token) {
        return recordingServiceHelper.validateTextTrackSingleUseToken(recordId, caption, token);
    }",0
"public static GameData parseShallow(final String mapName, final InputStream stream)
      throws GameParseException, EngineVersionException {
    checkNotNull(mapName);
    checkNotNull(stream);

    return new GameParser(new GameData(), mapName).parseShallow(stream);
  }",0
"public String[] getExcludedCommitMessagesNormalized() {
        String s = fixEmptyAndTrim(excludedCommitMessages);
        return s == null ? new String[0] : s.split(""[\\r\\n]+"");
    }",0
"private void restoreFull() {
            // None of this can run on the work looper here, so we spin asynchronous
            // work like this:
            //
            //   StreamFeederThread: read data from mTransport.getNextFullRestoreDataChunk()
            //                       write it into the pipe to the engine
            //   EngineThread: FullRestoreEngine thread communicating with the target app
            //
            // When finished, StreamFeederThread executes next state as appropriate on the
            // backup looper, and the overall unified restore task resumes
            try {
                StreamFeederThread feeder = new StreamFeederThread();
                if (MORE_DEBUG) {
                    Slog.i(TAG, ""Spinning threads for stream restore of ""
                            + mCurrentPackage.packageName);
                }
                new Thread(feeder, ""unified-stream-feeder"").start();

                // At this point the feeder is responsible for advancing the restore
                // state, so we're done here.
            } catch (IOException e) {
                // Unable to instantiate the feeder thread -- we need to bail on the
                // current target.  We haven't asked the transport for data yet, though,
                // so we can do that simply by going back to running the restore queue.
                Slog.e(TAG, ""Unable to construct pipes for stream restore!"");
                executeNextState(UnifiedRestoreState.RUNNING_QUEUE);
            }
        }",0
"public static String sanitizePath(String path, char substitute) {
        //on windows, we can receive both c:/path/ and c:\path\
        path = path.replace(""\\"", ""/"");
        if (OsUtil.isWindows() && path.matches(""^[a-zA-Z]\\:.*"")) {
            path = path.replaceFirst("":"", WIN_DRIVE_LETTER_COLON_WILDCHAR);
        }
        for (int i = 0; i < INVALID_PATH.size(); i++) {
            if (-1 != path.indexOf(INVALID_PATH.get(i))) {
                path = path.replace(INVALID_PATH.get(i), substitute);
            }
        }
        if (OsUtil.isWindows()) {
            path = path.replaceFirst(WIN_DRIVE_LETTER_COLON_WILDCHAR, "":"");
        }
        return path;
    }",0
"boolean isInvalidJar(JARDesc jar) {
        File cacheFile = tracker.getCacheFile(jar.getLocation());
        if (cacheFile == null) {
            return false;//File cannot be retrieved, do not claim it is an invalid jar
        }
        boolean isInvalid = false;
        try {
            JarFile jarFile = new JarFile(cacheFile.getAbsolutePath());
            jarFile.close();
        } catch (IOException ioe) {
            //Catch a ZipException or any other read failure
            isInvalid = true;
        }
        return isInvalid;
    }",0
"private void showRecentApps(boolean triggeredFromAltTab) {
        mPreloadedRecentApps = false; // preloading no longer needs to be canceled
        try {
            IStatusBarService statusbar = getStatusBarService();
            if (statusbar != null) {
                statusbar.showRecentApps(triggeredFromAltTab);
            }
        } catch (RemoteException e) {
            Slog.e(TAG, ""RemoteException when showing recent apps"", e);
            // re-acquire status bar service next time it is needed.
            mStatusBarService = null;
        }
    }",0
"@Override
    protected void hangupAndPowerOff() {
        // hang up all active voice calls
        if (mPhone.isInCall()) {
            mPhone.mCT.mRingingCall.hangupIfAlive();
            mPhone.mCT.mBackgroundCall.hangupIfAlive();
            mPhone.mCT.mForegroundCall.hangupIfAlive();
        }

        mCi.setRadioPower(false, null);
    }",0
"public void processAnnotations(final Class type) {
        processAnnotations(new Class[]{type});
    }",0
"void addMetaEntry(String name, byte[] buf) {
        metaEntries.put(name.toUpperCase(Locale.US), buf);
    }",0
"public void setFileResourceManager(FileResourceManager fileResourceManager) {
		this.fileResourceManager = fileResourceManager;
	}",0
"@Override
    boolean isWaitingForTransitionStart() {
        final DisplayContent dc = getDisplayContent();
        return dc != null && dc.mAppTransition.isTransitionSet()
                && (dc.mOpeningApps.contains(this)
                || dc.mClosingApps.contains(this)
                || dc.mChangingContainers.contains(this));
    }",0
"Configuration getGlobalConfiguration() {
        return mStackSupervisor.getConfiguration();
    }",0
"public PopupInfo connectPendingPopup(final AwContents parentAwContents) throws Exception {
        TestAwContentsClient popupContentsClient;
        AwTestContainerView popupContainerView;
        final AwContents popupContents;
        popupContentsClient = new TestAwContentsClient();
        popupContainerView = createAwTestContainerViewOnMainSync(popupContentsClient);
        popupContents = popupContainerView.getAwContents();
        enableJavaScriptOnUiThread(popupContents);

        getInstrumentation().runOnMainSync(new Runnable() {
            @Override
            public void run() {
                parentAwContents.supplyContentsForPopup(popupContents);
            }
        });

        OnPageFinishedHelper onPageFinishedHelper = popupContentsClient.getOnPageFinishedHelper();
        int finishCallCount = onPageFinishedHelper.getCallCount();
        TestAwContentsClient.OnReceivedTitleHelper onReceivedTitleHelper =
                popupContentsClient.getOnReceivedTitleHelper();
        int titleCallCount = onReceivedTitleHelper.getCallCount();

        onPageFinishedHelper.waitForCallback(finishCallCount, 1, WAIT_TIMEOUT_MS,
                TimeUnit.MILLISECONDS);
        onReceivedTitleHelper.waitForCallback(titleCallCount, 1, WAIT_TIMEOUT_MS,
                TimeUnit.MILLISECONDS);

        return new PopupInfo(popupContentsClient, popupContainerView, popupContents);
    }",1
"private boolean isAncestorOf(StateNode node) {
        while (node != null) {
            if (node == this) {
                return true;
            }
            node = node.getParent();
        }

        return false;
    }",0
"@Override
    public int getInitialDelaySeconds() {
        return 0;
    }",0
"public <V extends Component> Column<T, V> addComponentColumn(
            ValueProvider<T, V> componentProvider) {
        return addColumn(componentProvider, new ComponentRenderer());
    }",0
"@Override
        public void onReceive(Context context, Intent intent) {
            if (Intent.ACTION_USER_ADDED.equals(intent.getAction())) {
                // Notify keystore that a new user was added.
                final int userHandle = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, 0);
                if (userHandle > UserHandle.USER_SYSTEM) {
                    removeUser(userHandle, /* unknownUser= */ true);
                }
                final KeyStore ks = KeyStore.getInstance();
                final UserInfo parentInfo = mUserManager.getProfileParent(userHandle);
                final int parentHandle = parentInfo != null ? parentInfo.id : -1;
                ks.onUserAdded(userHandle, parentHandle);
            } else if (Intent.ACTION_USER_STARTING.equals(intent.getAction())) {
                final int userHandle = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, 0);
                mStorage.prefetchUser(userHandle);
            } else if (Intent.ACTION_USER_REMOVED.equals(intent.getAction())) {
                final int userHandle = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, 0);
                if (userHandle > 0) {
                    removeUser(userHandle, /* unknownUser= */ false);
                }
            }
        }",0
"public void clearNotificationEffects() {
        try {
            mBarService.clearNotificationEffects();
        } catch (RemoteException e) {
            // Won't fail unless the world has ended.
        }
    }",0
"public boolean isApiRequest(HttpServletRequest req) {
		return req.getRequestURI().startsWith(CONF.serverContextPath() + ""/api/"") || req.getRequestURI().equals(CONF.serverContextPath() + ""/api"");
	}",0
"@AppSwitchState int getBalAppSwitchesState() {
        return mAppSwitchesState;
    }",0
"public boolean reuseDevServer() {
        return reuseDevServer;
    }",0
