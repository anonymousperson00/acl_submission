instruction,function,label
Detect whether the following code contains vulnerabilities.,"DateTimeFieldElement::DateTimeFieldElement(Document* document, FieldOwner& fieldOwner)
    : HTMLElement(spanTag, document)
    , m_fieldOwner(&fieldOwner)
 {
     setAttribute(roleAttr, ""spinbutton"");
 }
",1
Detect whether the following code contains vulnerabilities.,"void WebGL2RenderingContextBase::texImage3D(
    GLenum target,
    GLint level,
    GLint internalformat,
    GLsizei width,
    GLsizei height,
    GLsizei depth,
    GLint border,
    GLenum format,
    GLenum type,
    MaybeShared<DOMArrayBufferView> pixels,
    GLuint src_offset) {
  if (isContextLost())
    return;
  if (bound_pixel_unpack_buffer_) {
    SynthesizeGLError(GL_INVALID_OPERATION, ""texImage3D"",
                       ""a buffer is bound to PIXEL_UNPACK_BUFFER"");
     return;
   }
   TexImageHelperDOMArrayBufferView(
       kTexImage3D, target, level, internalformat, width, height, depth, border,
       format, type, 0, 0, 0, pixels.View(), kNullNotReachable, src_offset);
}
",1
Detect whether the following code contains vulnerabilities.,"void RenderViewImpl::OnSelectPopupMenuItems(
    bool canceled,
    const std::vector<int>& selected_indices) {
  if (!external_popup_menu_.get())
    return;

  external_popup_menu_->DidSelectItems(canceled, selected_indices);
  external_popup_menu_.reset();
}
",0
Detect whether the following code contains vulnerabilities.,"void ContextState::RestoreRenderbufferBindings() {
  bound_renderbuffer_valid = false;
}
",0
Detect whether the following code contains vulnerabilities.,"CJSON_PUBLIC(cJSON *) cJSON_CreateIntArray(const int *numbers, int count)
{
    size_t i = 0;
    cJSON *n = NULL;
    cJSON *p = NULL;
    cJSON *a = NULL;

    if ((count < 0) || (numbers == NULL))
    {
        return NULL;
    }

    a = cJSON_CreateArray();
    for(i = 0; a && (i < (size_t)count); i++)
    {
        n = cJSON_CreateNumber(numbers[i]);
        if (!n)
        {
            cJSON_Delete(a);
            return NULL;
        }
        if(!i)
        {
            a->child = n;
        }
        else
        {
            suffix_object(p, n);
        }
        p = n;
    }

    return a;
}
",0
Detect whether the following code contains vulnerabilities.,"void CrosLibrary::TestApi::SetBrightnessLibrary(
    BrightnessLibrary* library, bool own) {
  library_->brightness_lib_.SetImpl(library, own);
}
",1
Detect whether the following code contains vulnerabilities.,"static inline bool match_option(const char *arg, int arglen, const char *opt)
{
	int len = strlen(opt);

	return len == arglen && !strncmp(arg, opt, len);
}
",0
Detect whether the following code contains vulnerabilities.,"Chapters::Display::~Display()
{
}
",1
Detect whether the following code contains vulnerabilities.," void CoordinatorImpl::RequestGlobalMemoryDumpAndAppendToTrace(
     MemoryDumpType dump_type,
     MemoryDumpLevelOfDetail level_of_detail,
     const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback) {
   auto adapter =
       [](const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback,
         bool success, uint64_t dump_guid,
         mojom::GlobalMemoryDumpPtr) { callback.Run(success, dump_guid); };

  QueuedRequest::Args args(dump_type, level_of_detail, {},
                           true /* add_to_trace */, base::kNullProcessId);
  RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));
}
",1
Detect whether the following code contains vulnerabilities.,"gst_pngdec_base_init (gpointer g_class)
{
  GstElementClass *element_class = GST_ELEMENT_CLASS (g_class);

  gst_element_class_add_pad_template (element_class,
      gst_static_pad_template_get (&gst_pngdec_src_pad_template));
  gst_element_class_add_pad_template (element_class,
      gst_static_pad_template_get (&gst_pngdec_sink_pad_template));
  gst_element_class_set_details (element_class, &gst_pngdec_details);
}
",0
Detect whether the following code contains vulnerabilities.,"  void CreateOAuth2ServiceDelegate(
       signin::AccountConsistencyMethod account_consistency) {
    oauth2_service_delegate_.reset(new MutableProfileOAuth2TokenServiceDelegate(
         client_.get(), &signin_error_controller_, &account_tracker_service_,
         token_web_data_, account_consistency, revoke_all_tokens_on_load_,
        true /* can_revoke_credantials */));
     base::RunLoop().RunUntilIdle();
     oauth2_service_delegate_->AddObserver(this);
   }
",1
Detect whether the following code contains vulnerabilities.,"mm_create(struct mm_master *mmalloc, size_t size)
{
	void *address;
	struct mm_master *mm;

	if (mmalloc == NULL)
		mm = xcalloc(1, sizeof(struct mm_master));
	else
		mm = mm_xmalloc(mmalloc, sizeof(struct mm_master));

	/*
	 * If the memory map has a mm_master it can be completely
	 * shared including authentication between the child
	 * and the client.
	 */
	mm->mmalloc = mmalloc;

	address = mmap(NULL, size, PROT_WRITE|PROT_READ, MAP_ANON|MAP_SHARED,
	    -1, 0);
	if (address == MAP_FAILED)
		fatal(""mmap(%zu): %s"", size, strerror(errno));

	mm->address = address;
	mm->size = size;

	RB_INIT(&mm->rb_free);
	RB_INIT(&mm->rb_allocated);

	mm_make_entry(mm, &mm->rb_free, address, size);

	return (mm);
}
",0
Detect whether the following code contains vulnerabilities.," image_transform_png_set_expand_add(image_transform *this,
    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
 {
    UNUSED(bit_depth)
 
 this->next = *that;
 *that = this;

 /* 'expand' should do nothing for RGBA or GA input - no tRNS and the bit
    * depth is at least 8 already.
    */
 return (colour_type & PNG_COLOR_MASK_ALPHA) == 0;
}
",1
Detect whether the following code contains vulnerabilities.,"EffectPaintPropertyNode* EffectPaintPropertyNode::Root() {
  DEFINE_STATIC_REF(EffectPaintPropertyNode, root,
                    (EffectPaintPropertyNode::Create(
                        nullptr, State{TransformPaintPropertyNode::Root(),
                                       ClipPaintPropertyNode::Root()})));
   return root;
 }
",1
Detect whether the following code contains vulnerabilities.,"int Textfield::OnDragUpdated(const ui::DropTargetEvent& event) {
  DCHECK(CanDrop(event.data()));
  gfx::RenderText* render_text = GetRenderText();
  const gfx::Range& selection = render_text->selection();
  drop_cursor_position_ = render_text->FindCursorPosition(event.location());
  bool in_selection =
      !selection.is_empty() &&
      selection.Contains(gfx::Range(drop_cursor_position_.caret_pos()));
  drop_cursor_visible_ = !in_selection;
  OnCaretBoundsChanged();
  SchedulePaint();

  StopBlinkingCursor();

  if (initiating_drag_) {
    if (in_selection)
      return ui::DragDropTypes::DRAG_NONE;
    return event.IsControlDown() ? ui::DragDropTypes::DRAG_COPY
                                 : ui::DragDropTypes::DRAG_MOVE;
  }
  return ui::DragDropTypes::DRAG_COPY | ui::DragDropTypes::DRAG_MOVE;
}
",0
Detect whether the following code contains vulnerabilities.,"GF_Err extr_Read(GF_Box *s, GF_BitStream *bs)
{
	GF_Err e;
	GF_ExtraDataBox *ptr = (GF_ExtraDataBox *)s;

	e = gf_isom_box_parse((GF_Box**) &ptr->feci, bs);
	if (e) return e;
	if (ptr->feci->size>ptr->size) return GF_ISOM_INVALID_MEDIA;
	ptr->data_length = (u32) (ptr->size - ptr->feci->size);
	ptr->data = gf_malloc(sizeof(char)*ptr->data_length);
	gf_bs_read_data(bs, ptr->data, ptr->data_length);

	return GF_OK;
}
",0
Detect whether the following code contains vulnerabilities.,"void SyncBackendHost::StartConfiguration(Callback0::Type* callback) {
  core_thread_.message_loop()->PostTask(FROM_HERE, NewRunnableMethod(
    core_.get(),&SyncBackendHost::Core::DoStartConfiguration, callback));
}
",0
Detect whether the following code contains vulnerabilities.,"static inline void vmxnet3_ring_init(PCIDevice *d,
				     Vmxnet3Ring *ring,
                                     hwaddr pa,
                                     size_t size,
                                     size_t cell_size,
                                     bool zero_region)
{
    ring->pa = pa;
    ring->size = size;
    ring->cell_size = cell_size;
    ring->gen = VMXNET3_INIT_GEN;
    ring->next = 0;

    if (zero_region) {
        vmw_shmem_set(d, pa, 0, size * cell_size);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static const wbxml_decoding *get_wbxml_decoding_from_content_type (
								   const char *content_type, tvbuff_t *tvb, guint32 offset)
{
	const wbxml_decoding *map = NULL;

	DebugLog((""get_wbxml_decoding_from_content_type: content_type = [%s]\n"",
		  content_type));
	if (content_type && content_type[0]) {
		const wbxml_literal_list *item = content_type_list;

		while (item && item->content_type) {
			if (g_ascii_strcasecmp(content_type, item->content_type) == 0) {
				/* Try the discriminator */
				if (item->discriminator != NULL) {
					map = item->discriminator(tvb, offset);
				}
				if (map == NULL) {
					map = item->map;
				}
				break;
			}
			item++;
		}
	}
	return map;
}
",0
Detect whether the following code contains vulnerabilities.,"void SyncBackendHost::Core::RouteJsEvent(
    const std::string& name, const JsEventDetails& details) {
  host_->frontend_loop_->PostTask(
      FROM_HERE, NewRunnableMethod(
          this, &Core::RouteJsEventOnFrontendLoop, name, details));
}
",0
Detect whether the following code contains vulnerabilities.," static inline void set_socket_blocking(int s, int blocking)
 {
     int opts;
    opts = fcntl(s, F_GETFL);
     if (opts<0) APPL_TRACE_ERROR(""set blocking (%s)"", strerror(errno));
     if(blocking)
         opts &= ~O_NONBLOCK;
     else opts |= O_NONBLOCK;
    if (fcntl(s, F_SETFL, opts) < 0)
         APPL_TRACE_ERROR(""set blocking (%s)"", strerror(errno));
 }
",1
Detect whether the following code contains vulnerabilities.,"bool IsFormSubmit(const NavigationEntry* entry) {
  return (ui::PageTransitionStripQualifier(entry->GetTransitionType()) ==
          ui::PAGE_TRANSITION_FORM_SUBMIT);
}
",0
Detect whether the following code contains vulnerabilities.,"    ~AutoInstallCurrentThreadPlatformMock()
    {
        Platform::initialize(m_oldPlatform);
    }
",0
Detect whether the following code contains vulnerabilities.,"RenderWidgetHostView* RenderWidgetHostImpl::GetView() const {
  return view_;
}
",0
Detect whether the following code contains vulnerabilities.,"void CompositorImpl::DidInitializeLayerTreeFrameSink() {
  layer_tree_frame_sink_request_pending_ = false;
  has_layer_tree_frame_sink_ = true;
  for (auto& frame_sink_id : pending_child_frame_sink_ids_)
    AddChildFrameSink(frame_sink_id);

  pending_child_frame_sink_ids_.clear();
}
",0
Detect whether the following code contains vulnerabilities.," SPL_METHOD(RecursiveDirectoryIterator, getSubPath)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}

	if (intern->u.dir.sub_path) {
		RETURN_STRINGL(intern->u.dir.sub_path, intern->u.dir.sub_path_len, 1);
	} else {
		RETURN_STRINGL("""", 0, 1);
	}
}
",1
Detect whether the following code contains vulnerabilities.,"static int rose_getsockopt(struct socket *sock, int level, int optname,
	char __user *optval, int __user *optlen)
{
	struct sock *sk = sock->sk;
	struct rose_sock *rose = rose_sk(sk);
	int val = 0;
	int len;

	if (level != SOL_ROSE)
		return -ENOPROTOOPT;

	if (get_user(len, optlen))
		return -EFAULT;

	if (len < 0)
		return -EINVAL;

	switch (optname) {
	case ROSE_DEFER:
		val = rose->defer;
		break;

	case ROSE_T1:
		val = rose->t1 / HZ;
		break;

	case ROSE_T2:
		val = rose->t2 / HZ;
		break;

	case ROSE_T3:
		val = rose->t3 / HZ;
		break;

	case ROSE_HOLDBACK:
		val = rose->hb / HZ;
		break;

	case ROSE_IDLE:
		val = rose->idle / (60 * HZ);
		break;

	case ROSE_QBITINCL:
		val = rose->qbitincl;
		break;

	default:
		return -ENOPROTOOPT;
	}

	len = min_t(unsigned int, len, sizeof(int));

	if (put_user(len, optlen))
		return -EFAULT;

	return copy_to_user(optval, &val, len) ? -EFAULT : 0;
}
",0
Detect whether the following code contains vulnerabilities.,"NaClProcessHost::NaClProcessHost(const GURL& manifest_url, bool off_the_record)
    : manifest_url_(manifest_url),
#if defined(OS_WIN)
      process_launched_by_broker_(false),
#elif defined(OS_LINUX)
      wait_for_nacl_gdb_(false),
#endif
      reply_msg_(NULL),
#if defined(OS_WIN)
      debug_exception_handler_requested_(false),
#endif
      internal_(new NaClInternal()),
      ALLOW_THIS_IN_INITIALIZER_LIST(weak_factory_(this)),
      enable_exception_handling_(false),
      off_the_record_(off_the_record) {
  process_.reset(content::BrowserChildProcessHost::Create(
      content::PROCESS_TYPE_NACL_LOADER, this));

  process_->SetName(net::FormatUrl(manifest_url_, std::string()));

  if (CommandLine::ForCurrentProcess()->HasSwitch(
          switches::kEnableNaClExceptionHandling) ||
       getenv(""NACL_UNTRUSTED_EXCEPTION_HANDLING"") != NULL) {
     enable_exception_handling_ = true;
   }
  enable_ipc_proxy_ = CommandLine::ForCurrentProcess()->HasSwitch(
      switches::kEnableNaClIPCProxy);
 }
",1
Detect whether the following code contains vulnerabilities.,"static struct key *request_master_key(struct encrypted_key_payload *epayload,
				      u8 **master_key, size_t *master_keylen)
{
	struct key *mkey = NULL;

	if (!strncmp(epayload->master_desc, KEY_TRUSTED_PREFIX,
		     KEY_TRUSTED_PREFIX_LEN)) {
		mkey = request_trusted_key(epayload->master_desc +
					   KEY_TRUSTED_PREFIX_LEN,
					   master_key, master_keylen);
	} else if (!strncmp(epayload->master_desc, KEY_USER_PREFIX,
			    KEY_USER_PREFIX_LEN)) {
		mkey = request_user_key(epayload->master_desc +
					KEY_USER_PREFIX_LEN,
					master_key, master_keylen);
	} else
		goto out;

	if (IS_ERR(mkey)) {
		int ret = PTR_ERR(mkey);

		if (ret == -ENOTSUPP)
			pr_info(""encrypted_key: key %s not supported"",
				epayload->master_desc);
		else
			pr_info(""encrypted_key: key %s not found"",
				epayload->master_desc);
		goto out;
	}

	dump_master_key(*master_key, *master_keylen);
out:
	return mkey;
}
",0
Detect whether the following code contains vulnerabilities.,"  std::unique_ptr<net::URLRequest> CreateAndExecuteRequest(const GURL& url) {
    std::unique_ptr<net::URLRequest> request(context_.CreateRequest(
        url, net::IDLE, &delegate_, TRAFFIC_ANNOTATION_FOR_TESTS));
    request->Start();
    drp_test_context_->RunUntilIdle();
    return request;
  }
",0
Detect whether the following code contains vulnerabilities.,"PHP_FUNCTION(money_format)
{
	size_t format_len = 0;
	char *format, *p, *e;
	double value;
	zend_bool check = 0;
	zend_string *str;
	ssize_t res_len;

	if (zend_parse_parameters(ZEND_NUM_ARGS(), ""sd"", &format, &format_len, &value) == FAILURE) {
		return;
	}

	p = format;
	e = p + format_len;
	while ((p = memchr(p, '%', (e - p)))) {
		if (*(p + 1) == '%') {
			p += 2;
		} else if (!check) {
			check = 1;
			p++;
		} else {
			php_error_docref(NULL, E_WARNING, ""Only a single %%i or %%n token can be used"");
			RETURN_FALSE;
		}
	}

	str = zend_string_alloc(format_len + 1024, 0);
	if ((res_len = strfmon(ZSTR_VAL(str), ZSTR_LEN(str), format, value)) < 0) {
		zend_string_free(str);
		RETURN_FALSE;
	}
	ZSTR_LEN(str) = (size_t)res_len;
	ZSTR_VAL(str)[ZSTR_LEN(str)] = '\0';

	RETURN_NEW_STR(zend_string_truncate(str, ZSTR_LEN(str), 0));
}
",0
Detect whether the following code contains vulnerabilities.,"void ResourcePrefetchPredictor::Shutdown() {
  history_service_observer_.RemoveAll();
}
",0
Detect whether the following code contains vulnerabilities.,"void mon_st_callback(stonith_t *st, stonith_event_t *e)
{
    char *desc = g_strdup_printf(
        ""Operation %s requested by %s for peer %s: %s (ref=%s)"",
        e->operation, e->origin, e->target, pcmk_strerror(e->result), e->id); 

    if (snmp_target) {
        send_snmp_trap(e->target, NULL, e->operation, pcmk_ok, e->result, 0, desc);
    }
    if (crm_mail_to) {
        send_smtp_trap(e->target, NULL, e->operation, pcmk_ok, e->result, 0, desc);
    }
    if (external_agent) {
        send_custom_trap(e->target, NULL, e->operation, pcmk_ok, e->result, 0, desc);
    }
    g_free(desc);
}
",0
Detect whether the following code contains vulnerabilities.,"cJSON *cJSON_DetachItemFromArray( cJSON *array, int which )
{
	cJSON *c = array->child;
	while ( c && which > 0 ) {
		c = c->next;
		--which;
	}
	if ( ! c )
		return 0;
	if ( c->prev )
		c->prev->next = c->next;
	if ( c->next ) c->next->prev = c->prev;
	if ( c == array->child )
		array->child = c->next;
	c->prev = c->next = 0;
	return c;
}
",1
Detect whether the following code contains vulnerabilities.,"const SeekHead* Segment::GetSeekHead() const
{
    return m_pSeekHead;
}
",1
Detect whether the following code contains vulnerabilities.," SchedulerObject::_continue(std::string key, std::string &/*reason*/, std::string &text)
 {
        PROC_ID id = getProcByString(key.c_str());
       if (id.cluster < 0 || id.proc < 0) {
                dprintf(D_FULLDEBUG, ""Remove: Failed to parse id: %s\n"", key.c_str());
                text = ""Invalid Id"";
                return false;
	}

	scheduler.enqueueActOnJobMyself(id,JA_CONTINUE_JOBS,true);

	return true;
}
",1
Detect whether the following code contains vulnerabilities.,"error::Error GLES2DecoderPassthroughImpl::DoBindFragmentInputLocationCHROMIUM(
    GLuint program,
    GLint location,
    const char* name) {
  NOTIMPLEMENTED();
  return error::kNoError;
}
",0
Detect whether the following code contains vulnerabilities.,"  int64 host_quota() const { return host_quota_; }
",0
Detect whether the following code contains vulnerabilities.,"UpdateLibrary* CrosLibrary::GetUpdateLibrary() {
  return update_lib_.GetDefaultImpl(use_stub_impl_);
}
",1
Detect whether the following code contains vulnerabilities.,"INST_HANDLER (muls) {	// MULS Rd, Rr
	int d = (buf[0] >> 4 & 0x0f) + 16;
	int r = (buf[0] & 0x0f) + 16;

	ESIL_A (""r%d,DUP,0x80,&,?{,0xffff00,|,},"", r);	// sign extension Rr
	ESIL_A (""r%d,DUP,0x80,&,?{,0xffff00,|,},"", d);	// sign extension Rd
	ESIL_A (""*,"");					// 0: (Rd*Rr)
	ESIL_A (""DUP,0xff,&,r0,=,"");			// r0 = LO(0)
	ESIL_A (""8,0,RPICK,>>,0xff,&,r1,=,"");		// r1 = HI(0)
	ESIL_A (""DUP,0x8000,&,!,!,cf,=,"");		// C = R/15
	ESIL_A (""DUP,!,zf,=,"");				// Z = !R
}
",0
Detect whether the following code contains vulnerabilities.,"flush_signal_handlers(struct task_struct *t, int force_default)
{
	int i;
	struct k_sigaction *ka = &t->sighand->action[0];
	for (i = _NSIG ; i != 0 ; i--) {
 		if (force_default || ka->sa.sa_handler != SIG_IGN)
 			ka->sa.sa_handler = SIG_DFL;
 		ka->sa.sa_flags = 0;
 		sigemptyset(&ka->sa.sa_mask);
 		ka++;
 	}
}
",1
Detect whether the following code contains vulnerabilities.,"static int init_nss_hash(struct crypto_instance *instance)
{
	PK11SlotInfo*	hash_slot = NULL;
	SECItem		hash_param;

	if (!hash_to_nss[instance->crypto_hash_type]) {
		return 0;
 	}
 
 	hash_param.type = siBuffer;
	hash_param.data = 0;
	hash_param.len = 0;
 
 	hash_slot = PK11_GetBestSlot(hash_to_nss[instance->crypto_hash_type], NULL);
 	if (hash_slot == NULL) {
		log_printf(instance->log_level_security, ""Unable to find security slot (err %d)"",
			   PR_GetError());
		return -1;
	}

	instance->nss_sym_key_sign = PK11_ImportSymKey(hash_slot,
						       hash_to_nss[instance->crypto_hash_type],
						       PK11_OriginUnwrap, CKA_SIGN,
						       &hash_param, NULL);
	if (instance->nss_sym_key_sign == NULL) {
		log_printf(instance->log_level_security, ""Failure to import key into NSS (err %d)"",
			   PR_GetError());
		return -1;
	}

	PK11_FreeSlot(hash_slot);

	return 0;
}
",1
Detect whether the following code contains vulnerabilities.,"status_t MediaPlayer::setDataSource(
 const sp<IMediaHTTPService> &httpService,
 const char *url, const KeyedVector<String8, String8> *headers)
{

     ALOGV(""setDataSource(%s)"", url);
     status_t err = BAD_VALUE;
     if (url != NULL) {
        const sp<IMediaPlayerService>& service(getMediaPlayerService());
         if (service != 0) {
             sp<IMediaPlayer> player(service->create(this, mAudioSessionId));
             if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||
 (NO_ERROR != player->setDataSource(httpService, url, headers))) {
                player.clear();
 }
            err = attachNewPlayer(player);
 }
 }
 return err;
}
",1
Detect whether the following code contains vulnerabilities.," PHP_FUNCTION(mcrypt_module_is_block_algorithm_mode)
 {
 	MCRYPT_GET_MODE_DIR_ARGS(modes_dir)
 	if (mcrypt_module_is_block_algorithm_mode(module, dir) == 1) {
 		RETURN_TRUE;
 	} else {
		RETURN_FALSE;
	}
}
",1
Detect whether the following code contains vulnerabilities.,"rar_read_ahead(struct archive_read *a, size_t min, ssize_t *avail)
{
  struct rar *rar = (struct rar *)(a->format->data);
  const void *h = __archive_read_ahead(a, min, avail);
  int ret;
  if (avail)
  {
    if (a->archive.read_data_is_posix_read && *avail > (ssize_t)a->archive.read_data_requested)
      *avail = a->archive.read_data_requested;
    if (*avail > rar->bytes_remaining)
      *avail = (ssize_t)rar->bytes_remaining;
    if (*avail < 0)
      return NULL;
     else if (*avail == 0 && rar->main_flags & MHD_VOLUME &&
       rar->file_flags & FHD_SPLIT_AFTER)
     {
       ret = archive_read_format_rar_read_header(a, a->entry);
       if (ret == (ARCHIVE_EOF))
       {
         rar->has_endarc_header = 1;
         ret = archive_read_format_rar_read_header(a, a->entry);
       }
       if (ret != (ARCHIVE_OK))
         return NULL;
       return rar_read_ahead(a, min, avail);
    }
  }
  return h;
}
",1
Detect whether the following code contains vulnerabilities.,"static unsigned int stack_maxrandom_size(void)
 {
	unsigned int max = 0;
 	if ((current->flags & PF_RANDOMIZE) &&
 		!(current->personality & ADDR_NO_RANDOMIZE)) {
		max = ((-1U) & STACK_RND_MASK) << PAGE_SHIFT;
 	}
 
 	return max;
}
",1
Detect whether the following code contains vulnerabilities.,"static void update_group_shares_cpu(struct task_group *tg, int cpu,
				    unsigned long sd_shares,
				    unsigned long sd_rq_weight,
				    unsigned long *usd_rq_weight)
{
	unsigned long shares, rq_weight;
	int boost = 0;

	rq_weight = usd_rq_weight[cpu];
	if (!rq_weight) {
		boost = 1;
		rq_weight = NICE_0_LOAD;
	}

	/*
	 *             \Sum_j shares_j * rq_weight_i
	 * shares_i =  -----------------------------
	 *                  \Sum_j rq_weight_j
	 */
	shares = (sd_shares * rq_weight) / sd_rq_weight;
	shares = clamp_t(unsigned long, shares, MIN_SHARES, MAX_SHARES);

	if (abs(shares - tg->se[cpu]->load.weight) >
			sysctl_sched_shares_thresh) {
		struct rq *rq = cpu_rq(cpu);
		unsigned long flags;

		raw_spin_lock_irqsave(&rq->lock, flags);
		tg->cfs_rq[cpu]->rq_weight = boost ? 0 : rq_weight;
		tg->cfs_rq[cpu]->shares = boost ? 0 : shares;
		__set_se_shares(tg->se[cpu], shares);
		raw_spin_unlock_irqrestore(&rq->lock, flags);
	}
}
",0
Detect whether the following code contains vulnerabilities.,"bool AXNodeObject::isModal() const {
  if (roleValue() != DialogRole && roleValue() != AlertDialogRole)
    return false;
 
   if (hasAttribute(aria_modalAttr)) {
     const AtomicString& modal = getAttribute(aria_modalAttr);
    if (equalIgnoringCase(modal, ""true""))
       return true;
    if (equalIgnoringCase(modal, ""false""))
       return false;
   }
 
  if (getNode() && isHTMLDialogElement(*getNode()))
    return toElement(getNode())->isInTopLayer();

  return false;
}
",1
Detect whether the following code contains vulnerabilities.,"static ps_sd *ps_sd_new(ps_mm *data, const char *key)
{
	php_uint32 hv, slot;
	ps_sd *sd;
	int keylen;

	keylen = strlen(key);

	sd = mm_malloc(data->mm, sizeof(ps_sd) + keylen);
        if (!sd) {
                TSRMLS_FETCH();
 
               php_error_docref(NULL TSRMLS_CC, E_WARNING, ""mm_malloc failed, avail %d, err %s"", mm_available(data->mm), mm_error());
                return NULL;
        }
 
	hv = ps_sd_hash(key, keylen);
	slot = hv & data->hash_max;

	sd->ctime = 0;
	sd->hv = hv;
	sd->data = NULL;
	sd->alloclen = sd->datalen = 0;

	memcpy(sd->key, key, keylen + 1);

	sd->next = data->hash[slot];
	data->hash[slot] = sd;

	data->hash_cnt++;

	if (!sd->next) {
		if (data->hash_cnt >= data->hash_max) {
			hash_split(data);
		}
	}

	ps_mm_debug((""inserting %s(%p) into slot %d\n"", key, sd, slot));

	return sd;
}
",1
Detect whether the following code contains vulnerabilities.,"set_pwd ()
{
  SHELL_VAR *temp_var, *home_var;
  char *temp_string, *home_string;

  home_var = find_variable (""HOME"");
  home_string = home_var ? value_cell (home_var) : (char *)NULL;

  temp_var = find_variable (""PWD"");
  if (temp_var && imported_p (temp_var) &&
      (temp_string = value_cell (temp_var)) &&
      same_file (temp_string, ""."", (struct stat *)NULL, (struct stat *)NULL))
    set_working_directory (temp_string);
  else if (home_string && interactive_shell && login_shell &&
	   same_file (home_string, ""."", (struct stat *)NULL, (struct stat *)NULL))
    {
      set_working_directory (home_string);
      temp_var = bind_variable (""PWD"", home_string, 0);
      set_auto_export (temp_var);
    }
  else
    {
      temp_string = get_working_directory (""shell-init"");
      if (temp_string)
	{
	  temp_var = bind_variable (""PWD"", temp_string, 0);
	  set_auto_export (temp_var);
	  free (temp_string);
	}
    }

  /* According to the Single Unix Specification, v2, $OLDPWD is an
     `environment variable' and therefore should be auto-exported.
     Make a dummy invisible variable for OLDPWD, and mark it as exported. */
  temp_var = bind_variable (""OLDPWD"", (char *)NULL, 0);
  VSETATTR (temp_var, (att_exported | att_invisible));
}
",0
Detect whether the following code contains vulnerabilities.," bool GesturePoint::IsSecondClickInsideManhattanSquare(
     const TouchEvent& event) const {
   int manhattanDistance = abs(event.x() - last_tap_position_.x()) +
                           abs(event.y() - last_tap_position_.y());
  return manhattanDistance < kMaximumTouchMoveInPixelsForClick;
 }
",1
Detect whether the following code contains vulnerabilities.,"  int clear_count() const { return clear_count_; }
",0
Detect whether the following code contains vulnerabilities.,"long long BlockGroup::GetPrevTimeCode() const
{
    return m_prev;
}
",1
Detect whether the following code contains vulnerabilities.," static void unregisterBlobURLTask(void* context)
 {
     OwnPtr<BlobRegistryContext> blobRegistryContext = adoptPtr(static_cast<BlobRegistryContext*>(context));
    blobRegistry().unregisterBlobURL(blobRegistryContext->url);
 }
",1
Detect whether the following code contains vulnerabilities.,"void Document::setCompatibilityMode(CompatibilityMode mode)
{
    if (m_compatibilityModeLocked || mode == m_compatibilityMode)
        return;
    bool wasInQuirksMode = inQuirksMode();
    m_compatibilityMode = mode;
    selectorQueryCache()->invalidate();
    if (inQuirksMode() != wasInQuirksMode) {
        m_styleSheetCollection->clearPageUserSheet();
        m_styleSheetCollection->invalidateInjectedStyleSheetCache();
    }
}
",0
Detect whether the following code contains vulnerabilities.,"GBool ArthurOutputDev::beginType3Char(GfxState *state, double x, double y,
				      double dx, double dy,
				      CharCode code, Unicode *u, int uLen)
{
  return gFalse;
}
",0
Detect whether the following code contains vulnerabilities.," bool MediaElementAudioSourceHandler::WouldTaintOrigin() {
  if (MediaElement()->GetWebMediaPlayer()->DidPassCORSAccessCheck()) {
    return false;
  }
  if (!MediaElement()->HasSingleSecurityOrigin()) {
    return true;
  }
  return Context()->WouldTaintOrigin(MediaElement()->currentSrc());
 }
",1
Detect whether the following code contains vulnerabilities.,"void SelectionEditor::DidSplitTextNode(const Text& old_node) {
  if (selection_.IsNone() || !old_node.isConnected()) {
    DidFinishDOMMutation();
    return;
  }
  const Position& new_base =
      UpdatePostionAfterAdoptingTextNodeSplit(selection_.base_, old_node);
  const Position& new_extent =
      UpdatePostionAfterAdoptingTextNodeSplit(selection_.extent_, old_node);
  DidFinishTextChange(new_base, new_extent);
}
",0
Detect whether the following code contains vulnerabilities.,"TransportDIB::TransportDIB()
    : address_(kInvalidAddress),
      x_shm_(0),
      display_(NULL),
      size_(0) {
}
",0
Detect whether the following code contains vulnerabilities.," bool SoundPool::unload(int sampleID)
{
    ALOGV(""unload: sampleID=%d"", sampleID);
 Mutex::Autolock lock(&mLock);
 return mSamples.removeItem(sampleID);
}
",0
Detect whether the following code contains vulnerabilities.,"  WebsiteSettings* website_settings() {
     if (!website_settings_.get()) {
       website_settings_.reset(new WebsiteSettings(
           mock_ui(), profile(), tab_specific_content_settings(),
          infobar_service(), url(), ssl(), cert_store()));
     }
     return website_settings_.get();
   }
",1
Detect whether the following code contains vulnerabilities.,"static void parse_error(struct filter_parse_error *pe, int err, int pos)
{
	pe->lasterr = err;
	pe->lasterr_pos = pos;
}
",0
Detect whether the following code contains vulnerabilities.,"static v8::Handle<v8::Value> methodWithCallbackArgCallback(const v8::Arguments& args)
 {
     INC_STATS(""DOM.TestObj.methodWithCallbackArg"");
     if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
     TestObj* imp = V8TestObj::toNative(args.Holder());
     if (args.Length() <= 0 || !args[0]->IsFunction())
         return throwError(TYPE_MISMATCH_ERR, args.GetIsolate());
    RefPtr<TestCallback> callback = V8TestCallback::create(args[0], getScriptExecutionContext());
    imp->methodWithCallbackArg(callback);
    return v8::Handle<v8::Value>();
}
",1
Detect whether the following code contains vulnerabilities.," virtual void unsetHeap(int32_t seqNum) {
 Parcel data, reply;
        data.writeInterfaceToken(ICrypto::getInterfaceDescriptor());
        data.writeInt32(seqNum);
        remote()->transact(UNSET_HEAP, data, &reply);
 return;
 }
",0
Detect whether the following code contains vulnerabilities.,"static int ps_files_valid_key(const char *key)
{
       size_t len;
       const char *p;
       char c;
       int ret = 1;
       for (p = key; (c = *p); p++) {
               /* valid characters are a..z,A..Z,0..9 */
               if (!((c >= 'a' && c <= 'z')
                               || (c >= 'A' && c <= 'Z')
                               || (c >= '0' && c <= '9')
                               || c == ','
                               || c == '-')) {
                       ret = 0;
                       break;
               }
       }
       len = p - key;
       /* Somewhat arbitrary length limit here, but should be way more than
          anyone needs and avoids file-level warnings later on if we exceed MAX_PATH */
       if (len == 0 || len > 128) {
               ret = 0;
       }
       return ret;
}
",1
Detect whether the following code contains vulnerabilities.,"void EditorClientBlackBerry::willSetInputMethodState()
{
    notImplemented();
}
",0
Detect whether the following code contains vulnerabilities.,"long Chapters::Atom::ParseDisplay(
    IMkvReader* pReader,
    long long pos,
    long long size)
{
    if (!ExpandDisplaysArray())
        return -1;
    Display& d = m_displays[m_displays_count++];
    d.Init();
    return d.Parse(pReader, pos, size);
}
",1
Detect whether the following code contains vulnerabilities.," void WebGL2RenderingContextBase::deleteVertexArray(
     WebGLVertexArrayObject* vertex_array) {
  if (isContextLost() || !vertex_array)
     return;
 
   if (!vertex_array->IsDefaultObject() &&
      vertex_array == bound_vertex_array_object_)
    SetBoundVertexArrayObject(nullptr);

  vertex_array->DeleteObject(ContextGL());
}
",1
Detect whether the following code contains vulnerabilities.,"int send_event (int fd, uint16_t type, uint16_t code, int32_t value)
{
 struct uinput_event event;
    BTIF_TRACE_DEBUG(""%s type:%u code:%u value:%d"", __FUNCTION__,
        type, code, value);
    memset(&event, 0, sizeof(event));
    event.type  = type;

     event.code  = code;
     event.value = value;
 
    return write(fd, &event, sizeof(event));
 }
",1
Detect whether the following code contains vulnerabilities.,"static inline bool nested_svm_nmi(struct vcpu_svm *svm)
{
	if (!is_guest_mode(&svm->vcpu))
		return true;

	if (!(svm->nested.intercept & (1ULL << INTERCEPT_NMI)))
		return true;

	svm->vmcb->control.exit_code = SVM_EXIT_NMI;
	svm->nested.exit_required = true;

	return false;
}
",0
Detect whether the following code contains vulnerabilities.,"static inline void shmem_unacct_blocks(unsigned long flags, long pages)
{
	if (flags & VM_NORESERVE)
		vm_unacct_memory(pages * VM_ACCT(PAGE_CACHE_SIZE));
}
",0
Detect whether the following code contains vulnerabilities.,"int WebContentsImpl::CreateOpenerRenderViewsForRenderManager(
    SiteInstance* instance) {
  if (!opener_)
    return MSG_ROUTING_NONE;

  return opener_->CreateOpenerRenderViews(instance);
}
",0
Detect whether the following code contains vulnerabilities.,"bool AutocompleteEditModel::AcceptCurrentInstantPreview() {
  return InstantController::CommitIfCurrent(controller_->GetInstant());
}
",0
Detect whether the following code contains vulnerabilities.,"int ipmi_destroy_user(struct ipmi_user *user)
 {
 	_ipmi_destroy_user(user);
 
	cleanup_srcu_struct(&user->release_barrier);
 	kref_put(&user->refcount, free_user);
 
 	return 0;
}
",1
Detect whether the following code contains vulnerabilities.,"bool WebGLRenderingContextBase::ValidateHTMLImageElement(
    const SecurityOrigin* security_origin,
    const char* function_name,
    HTMLImageElement* image,
    ExceptionState& exception_state) {
  if (!image || !image->CachedImage()) {
    SynthesizeGLError(GL_INVALID_VALUE, function_name, ""no image"");
    return false;
  }
  const KURL& url = image->CachedImage()->GetResponse().Url();
  if (url.IsNull() || url.IsEmpty() || !url.IsValid()) {
    SynthesizeGLError(GL_INVALID_VALUE, function_name, ""invalid image"");
    return false;
   }
 
   if (WouldTaintOrigin(image, security_origin)) {
    exception_state.ThrowSecurityError(""The cross-origin image at "" +
                                       url.ElidedString() +
                                       "" may not be loaded."");
     return false;
   }
   return true;
}
",1
Detect whether the following code contains vulnerabilities.,"unsigned long nr_iowait(void)
{
	unsigned long i, sum = 0;

	for_each_possible_cpu(i)
		sum += atomic_read(&cpu_rq(i)->nr_iowait);

	return sum;
}
",0
Detect whether the following code contains vulnerabilities.,"static CallInfo *growCI (lua_State *L) {
  if (L->size_ci > LUAI_MAXCALLS)  /* overflow while handling overflow? */
    luaD_throw(L, LUA_ERRERR);
  else {
    luaD_reallocCI(L, 2*L->size_ci);
    if (L->size_ci > LUAI_MAXCALLS)
      luaG_runerror(L, ""stack overflow"");
  }
  return ++L->ci;
}
",0
Detect whether the following code contains vulnerabilities.,"static bool cmd_ibm_sense_condition(IDEState *s, uint8_t cmd)
{
    switch (s->feature) {
    case 0x01:  /* sense temperature in device */
        s->nsector = 0x50;      /* +20 C */
        break;
    default:
        ide_abort_command(s);
        return true;
    }

    return true;
}
",0
Detect whether the following code contains vulnerabilities.,"RenderWidgetHostViewAndroid::RenderWidgetHostViewAndroid(
    RenderWidgetHostImpl* widget_host,
    ContentViewCoreImpl* content_view_core)
    : host_(widget_host),
      is_layer_attached_(true),
       content_view_core_(NULL),
       ime_adapter_android_(ALLOW_THIS_IN_INITIALIZER_LIST(this)),
       cached_background_color_(SK_ColorWHITE),
      texture_id_in_layer_(0) {
   if (CompositorImpl::UsesDirectGL()) {
     surface_texture_transport_.reset(new SurfaceTextureTransportClient());
     layer_ = surface_texture_transport_->Initialize();
  } else {
    texture_layer_ = cc::TextureLayer::create(0);
    layer_ = texture_layer_;
  }

  layer_->setContentsOpaque(true);
  layer_->setIsDrawable(true);

  host_->SetView(this);
  SetContentViewCore(content_view_core);
}
",1
Detect whether the following code contains vulnerabilities.,"static int __net_init nfnetlink_net_init(struct net *net)
{
	struct sock *nfnl;
	struct netlink_kernel_cfg cfg = {
		.groups	= NFNLGRP_MAX,
		.input	= nfnetlink_rcv,
#ifdef CONFIG_MODULES
		.bind	= nfnetlink_bind,
#endif
	};

	nfnl = netlink_kernel_create(net, NETLINK_NETFILTER, &cfg);
	if (!nfnl)
		return -ENOMEM;
	net->nfnl_stash = nfnl;
	rcu_assign_pointer(net->nfnl, nfnl);
	return 0;
}
",0
Detect whether the following code contains vulnerabilities.," monitor_init(void)
 {
	struct ssh *ssh = active_state;			/* XXX */
 	struct monitor *mon;
 
 	mon = xcalloc(1, sizeof(*mon));
 	monitor_openfds(mon, 1);
 
	/* Used to share zlib space across processes */
	if (options.compression) {
		mon->m_zback = mm_create(NULL, MM_MEMSIZE);
		mon->m_zlib = mm_create(mon->m_zback, 20 * MM_MEMSIZE);
		/* Compression needs to share state across borders */
		ssh_packet_set_compress_hooks(ssh, mon->m_zlib,
		    (ssh_packet_comp_alloc_func *)mm_zalloc,
		    (ssh_packet_comp_free_func *)mm_zfree);
	}
 	return mon;
 }
",1
Detect whether the following code contains vulnerabilities.,"void GfxPatternColorSpace::getRGB(GfxColor *color, GfxRGB *rgb) {
  rgb->r = rgb->g = rgb->b = 0;
}
",0
Detect whether the following code contains vulnerabilities.,"     ~OffScreenRootWindow()
     {
         if (!--refCount) {
#if PLATFORM(QT)
            delete window;
            window = 0;
#elif PLATFORM(EFL)
             XUnmapWindow(display, window);
             XDestroyWindow(display, window);
#endif
         }
     }
",1
Detect whether the following code contains vulnerabilities.,"fbCombineConjointOutPart (CARD8 a, CARD8 b)
{
    /* max (1-b/a,0) */
    /* = 1-min(b/a,1) */

    /* min (1, (1-b) / a) */

    if (b >= a)		    /* b >= a -> b/a >= 1 */
	return 0x00;	    /* 0 */
    return ~FbIntDiv(b,a);   /* 1 - b/a */
}
",0
Detect whether the following code contains vulnerabilities.,"static ssize_t ReadBlobBlock(Image *image,unsigned char *data)
{
  ssize_t
    count;

  unsigned char
    block_count;

  assert(image != (Image *) NULL);
  assert(image->signature == MagickSignature);
  assert(data != (unsigned char *) NULL);
  count=ReadBlob(image,1,&block_count);
  if (count != 1)
    return(0);
  count=ReadBlob(image,(size_t) block_count,data);
  if (count != (ssize_t) block_count)
    return(0);
  return(count);
}
",0
Detect whether the following code contains vulnerabilities.,"void WebPage::loadString(const BlackBerry::Platform::String& string, const BlackBerry::Platform::String& baseURL, const BlackBerry::Platform::String& mimeType, const BlackBerry::Platform::String& failingURL)
{
    d->loadString(string, baseURL, mimeType, failingURL);
}
",0
Detect whether the following code contains vulnerabilities.,"mrb_class_get_under(mrb_state *mrb, struct RClass *outer, const char *name)
{
  return class_from_sym(mrb, outer, mrb_intern_cstr(mrb, name));
}
",0
Detect whether the following code contains vulnerabilities.," bool IsSiteMuted(const TabStripModel& tab_strip, const int index) {
   content::WebContents* web_contents = tab_strip.GetWebContentsAt(index);
   GURL url = web_contents->GetLastCommittedURL();
 
  if (url.SchemeIs(content::kChromeUIScheme)) {
    return web_contents->IsAudioMuted() &&
           GetTabAudioMutedReason(web_contents) ==
               TabMutedReason::CONTENT_SETTING_CHROME;
  }

  Profile* profile =
      Profile::FromBrowserContext(web_contents->GetBrowserContext());
  HostContentSettingsMap* settings =
      HostContentSettingsMapFactory::GetForProfile(profile);
  return settings->GetContentSetting(url, url, CONTENT_SETTINGS_TYPE_SOUND,
                                     std::string()) == CONTENT_SETTING_BLOCK;
}
",1
Detect whether the following code contains vulnerabilities.,"status_t DRMSource::start(MetaData *params) {
 int32_t val;
 if (params && params->findInt32(kKeyWantsNALFragments, &val)
 && val != 0) {
        mWantsNALFragments = true;
 } else {
        mWantsNALFragments = false;
 }

 return mOriginalMediaSource->start(params);
}
",0
Detect whether the following code contains vulnerabilities.,"static void callWithScriptStateExecutionContextVoidMethodMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TestObjectPython* imp = V8TestObjectPython::toNative(info.Holder());
    ScriptState* currentState = ScriptState::current();
    if (!currentState)
        return;
    ScriptState& state = *currentState;
    ExecutionContext* scriptContext = currentExecutionContext(info.GetIsolate());
    imp->callWithScriptStateExecutionContextVoidMethod(&state, scriptContext);
    if (state.hadException()) {
        v8::Local<v8::Value> exception = state.exception();
        state.clearException();
        throwError(exception, info.GetIsolate());
        return;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void GLSurfaceOzoneSurfacelessSurfaceImpl::Destroy() {
  if (!context_)
    return;
  scoped_refptr<gfx::GLContext> previous_context = gfx::GLContext::GetCurrent();
  scoped_refptr<gfx::GLSurface> previous_surface;

  bool was_current = previous_context && previous_context->IsCurrent(nullptr) &&
                     gfx::GLSurface::GetCurrent() == this;
  if (!was_current) {
    previous_surface = gfx::GLSurface::GetCurrent();
    context_->MakeCurrent(this);
  }

  glBindFramebufferEXT(GL_FRAMEBUFFER, 0);
  if (fbo_) {
    glDeleteTextures(arraysize(textures_), textures_);
    for (auto& texture : textures_)
      texture = 0;
    glDeleteFramebuffersEXT(1, &fbo_);
    fbo_ = 0;
  }
  for (auto image : images_) {
    if (image)
      image->Destroy(true);
   }
 
   if (!was_current) {
    previous_context->MakeCurrent(previous_surface.get());
  } else {
    context_->ReleaseCurrent(this);
   }
 }
",1
Detect whether the following code contains vulnerabilities.,"bool RenderFrameHostManager::IsRendererTransferNeededForNavigation(
    RenderFrameHostImpl* rfh,
    const GURL& dest_url) {
  if (!rfh->GetSiteInstance()->HasSite())
    return false;

  if (rfh->GetSiteInstance()->GetSiteURL().SchemeIs(kGuestScheme))
    return false;

  BrowserContext* context = rfh->GetSiteInstance()->GetBrowserContext();
  if (IsCurrentlySameSite(rfh, dest_url)) {
    return false;
  }

  if (rfh->GetSiteInstance()->RequiresDedicatedProcess() ||
      SiteInstanceImpl::DoesSiteRequireDedicatedProcess(context,
                                                        dest_url)) {
    return true;
  }

  if (SiteIsolationPolicy::IsTopDocumentIsolationEnabled() &&
      (!frame_tree_node_->IsMainFrame() ||
       rfh->GetSiteInstance()->IsDefaultSubframeSiteInstance())) {
    return true;
  }

  return false;
}
",0
Detect whether the following code contains vulnerabilities.,"bool Block::IsInvisible() const
{
    return bool(int(m_flags & 0x08) != 0);
 }
",1
Detect whether the following code contains vulnerabilities.,"PP_InputEvent_Type ConvertEventTypes(WebInputEvent::Type wetype) {
  switch (wetype) {
    case WebInputEvent::MouseDown:
      return PP_INPUTEVENT_TYPE_MOUSEDOWN;
    case WebInputEvent::MouseUp:
      return PP_INPUTEVENT_TYPE_MOUSEUP;
    case WebInputEvent::MouseMove:
      return PP_INPUTEVENT_TYPE_MOUSEMOVE;
    case WebInputEvent::MouseEnter:
       return PP_INPUTEVENT_TYPE_MOUSEENTER;
     case WebInputEvent::MouseLeave:
       return PP_INPUTEVENT_TYPE_MOUSELEAVE;
     case WebInputEvent::MouseWheel:
       return PP_INPUTEVENT_TYPE_MOUSEWHEEL;
     case WebInputEvent::RawKeyDown:
      return PP_INPUTEVENT_TYPE_RAWKEYDOWN;
    case WebInputEvent::KeyDown:
      return PP_INPUTEVENT_TYPE_KEYDOWN;
    case WebInputEvent::KeyUp:
      return PP_INPUTEVENT_TYPE_KEYUP;
    case WebInputEvent::Char:
      return PP_INPUTEVENT_TYPE_CHAR;
    case WebInputEvent::Undefined:
    default:
      return PP_INPUTEVENT_TYPE_UNDEFINED;
  }
}
",1
Detect whether the following code contains vulnerabilities.,"void CuePoint::TrackPosition::Parse(IMkvReader* pReader, long long start_,
                                     long long size_) {
   const long long stop = start_ + size_;
   long long pos = start_;

  m_track = -1;
  m_pos = -1;
  m_block = 1; // default


   while (pos < stop) {
     long len;
 
    const long long id = ReadUInt(pReader, pos, len);
    assert(id >= 0);  // TODO
    assert((pos + len) <= stop);
 
     pos += len;  // consume ID
 
     const long long size = ReadUInt(pReader, pos, len);
    assert(size >= 0);
    assert((pos + len) <= stop);
 
     pos += len;  // consume Size field
    assert((pos + size) <= stop);
 
     if (id == 0x77)  // CueTrack ID
       m_track = UnserializeUInt(pReader, pos, size);

 else if (id == 0x71) // CueClusterPos ID
      m_pos = UnserializeUInt(pReader, pos, size);

 else if (id == 0x1378) // CueBlockNumber

       m_block = UnserializeUInt(pReader, pos, size);
 
     pos += size;  // consume payload
    assert(pos <= stop);
   }
 
  assert(m_pos >= 0);
  assert(m_track > 0);
 }
",1
Detect whether the following code contains vulnerabilities.," std::string GetUploadData(const std::string& brand) {
   DCHECK(!brand.empty());
  std::string data(kPostXml);
  const std::string placeholder(""__BRANDCODE_PLACEHOLDER__"");
  size_t placeholder_pos = data.find(placeholder);
  DCHECK(placeholder_pos != std::string::npos);
  data.replace(placeholder_pos, placeholder.size(), brand);
  return data;
 }
",1
Detect whether the following code contains vulnerabilities.,"PanoramiXRenderSetPictureClipRectangles(ClientPtr client)
{
    REQUEST(xRenderSetPictureClipRectanglesReq);
    int result = Success, j;
    PanoramiXRes *pict;

    REQUEST_AT_LEAST_SIZE(xRenderSetPictureClipRectanglesReq);

    VERIFY_XIN_PICTURE(pict, stuff->picture, client, DixWriteAccess);

    FOR_NSCREENS_BACKWARD(j) {
        stuff->picture = pict->info[j].id;
        result =
            (*PanoramiXSaveRenderVector[X_RenderSetPictureClipRectangles])
            (client);
        if (result != Success)
            break;
    }

    return result;
}
",0
Detect whether the following code contains vulnerabilities.,"void FrameSelection::MoveRangeSelection(const VisiblePosition& base_position,
                                        const VisiblePosition& extent_position,
                                        TextGranularity granularity) {
  SelectionInDOMTree new_selection =
      SelectionInDOMTree::Builder()
           .SetBaseAndExtentDeprecated(base_position.DeepEquivalent(),
                                       extent_position.DeepEquivalent())
           .SetAffinity(base_position.Affinity())
          .SetIsHandleVisible(IsHandleVisible())
           .Build();
 
   if (new_selection.IsNone())
    return;

  const VisibleSelection& visible_selection =
      CreateVisibleSelectionWithGranularity(new_selection, granularity);
  if (visible_selection.IsNone())
    return;

  SelectionInDOMTree::Builder builder;
  if (visible_selection.IsBaseFirst()) {
    builder.SetBaseAndExtent(visible_selection.Start(),
                             visible_selection.End());
  } else {
    builder.SetBaseAndExtent(visible_selection.End(),
                              visible_selection.Start());
   }
   builder.SetAffinity(visible_selection.Affinity());
  builder.SetIsHandleVisible(IsHandleVisible());
   SetSelection(builder.Build(), SetSelectionData::Builder()
                                     .SetShouldCloseTyping(true)
                                     .SetShouldClearTypingStyle(true)
                                     .SetGranularity(granularity)
                                     .Build());
 }
",1
Detect whether the following code contains vulnerabilities.,"cifs_sb_master_tlink(struct cifs_sb_info *cifs_sb)
{
	return cifs_sb->master_tlink;
}
",0
Detect whether the following code contains vulnerabilities.,"static int set_file_offset(stb_vorbis *f, unsigned int loc)
{
   #ifndef STB_VORBIS_NO_PUSHDATA_API
   if (f->push_mode) return 0;
   #endif
   f->eof = 0;
   if (USE_MEMORY(f)) {
      if (f->stream_start + loc >= f->stream_end || f->stream_start + loc < f->stream_start) {
         f->stream = f->stream_end;
         f->eof = 1;
         return 0;
      } else {
         f->stream = f->stream_start + loc;
         return 1;
      }
   }
   #ifndef STB_VORBIS_NO_STDIO
   if (loc + f->f_start < loc || loc >= 0x80000000) {
      loc = 0x7fffffff;
      f->eof = 1;
   } else {
      loc += f->f_start;
   }
   if (!fseek(f->f, loc, SEEK_SET))
      return 1;
   f->eof = 1;
   fseek(f->f, f->f_start, SEEK_END);
   return 0;
   #endif
}
",0
Detect whether the following code contains vulnerabilities.,"SAPI_API int sapi_add_header_ex(char *header_line, uint header_line_len, zend_bool duplicate, zend_bool replace TSRMLS_DC)
{
	sapi_header_line ctr = {0};
	int r;
	
	ctr.line = header_line;
	ctr.line_len = header_line_len;

	r = sapi_header_op(replace ? SAPI_HEADER_REPLACE : SAPI_HEADER_ADD,
			&ctr TSRMLS_CC);

	if (!duplicate)
		efree(header_line);

	return r;
}
",0
Detect whether the following code contains vulnerabilities.,"void TabStripGtk::TabDetachedAt(TabContents* contents, int index) {
   GenerateIdealBounds();
  StartRemoveTabAnimation(index, contents->web_contents());
  GetTabAt(index)->set_closing(true);
}
",1
Detect whether the following code contains vulnerabilities.,"PHP_FUNCTION(imagesetstyle)
{
	zval *IM, *styles;
	gdImagePtr im;
	int * stylearr;
	int index;
	HashPosition pos;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ra"", &IM, &styles) == FAILURE)  {
		return;
	}

	ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, ""Image"", le_gd);

	/* copy the style values in the stylearr */
	stylearr = safe_emalloc(sizeof(int), zend_hash_num_elements(HASH_OF(styles)), 0);

	zend_hash_internal_pointer_reset_ex(HASH_OF(styles), &pos);

	for (index = 0;; zend_hash_move_forward_ex(HASH_OF(styles), &pos))	{
		zval ** item;

		if (zend_hash_get_current_data_ex(HASH_OF(styles), (void **) &item, &pos) == FAILURE) {
 			break;
 		}
 
		convert_to_long_ex(item);
		stylearr[index++] = Z_LVAL_PP(item);
 	}
 
 	gdImageSetStyle(im, stylearr, index);

	efree(stylearr);

	RETURN_TRUE;
}
",1
Detect whether the following code contains vulnerabilities.,"static void detach_task(struct task_struct *p, struct lb_env *env)
{
	lockdep_assert_held(&env->src_rq->lock);

	p->on_rq = TASK_ON_RQ_MIGRATING;
	deactivate_task(env->src_rq, p, DEQUEUE_NOCLOCK);
	set_task_cpu(p, env->dst_cpu);
}
",0
Detect whether the following code contains vulnerabilities.,"void imap_cachepath(struct ImapData *idata, const char *mailbox, char *dest, size_t dlen)
{
  char *s = NULL;
  const char *p = mailbox;

  for (s = dest; p && *p && dlen; dlen--)
  {
    if (*p == idata->delim)
    {
      *s = '/';
      /* simple way to avoid collisions with UIDs */
      if (*(p + 1) >= '0' && *(p + 1) <= '9')
      {
        if (--dlen)
          *++s = '_';
      }
    }
    else
      *s = *p;
    p++;
    s++;
  }
  *s = '\0';
}
",0
Detect whether the following code contains vulnerabilities.,"void BackendImpl::CleanupCache() {
  DCHECK(background_queue_.BackgroundIsCurrentSequence());
  Trace(""Backend Cleanup"");
  eviction_.Stop();
  timer_.reset();

  if (init_) {
    StoreStats();
    if (data_)
      data_->header.crash = 0;

    if (user_flags_ & kNoRandom) {
      File::WaitForPendingIO(&num_pending_io_);
      DCHECK(!num_refs_);
    } else {
      File::DropPendingIO();
    }
  }
  block_files_.CloseFiles();
  FlushIndex();
  index_ = NULL;
  ptr_factory_.InvalidateWeakPtrs();
  done_.Signal();
}
",0
Detect whether the following code contains vulnerabilities.,"static bool is_ereg(u32 reg)
{
	return (1 << reg) & (BIT(BPF_REG_5) |
			     BIT(AUX_REG) |
			     BIT(BPF_REG_7) |
			     BIT(BPF_REG_8) |
			     BIT(BPF_REG_9));
}
",0
Detect whether the following code contains vulnerabilities.,"bool RendererPermissionsPolicyDelegate::IsRestrictedUrl(
    const GURL& document_url,
    std::string* error) {
  if (dispatcher_->IsExtensionActive(kWebStoreAppId)) {
    if (error)
      *error = errors::kCannotScriptGallery;
     return true;
   }
 
  if (SearchBouncer::GetInstance()->IsNewTabPage(document_url)) {
     if (error)
       *error = errors::kCannotScriptNtp;
     return true;
  }

  return false;
}
",1
Detect whether the following code contains vulnerabilities.,"static void nfs4_open_confirm_release(void *calldata)
{
	struct nfs4_opendata *data = calldata;
	struct nfs4_state *state = NULL;

	/* If this request hasn't been cancelled, do nothing */
	if (data->cancelled == 0)
		goto out_free;
	/* In case of error, no cleanup! */
	if (!data->rpc_done)
 		goto out_free;
 	state = nfs4_opendata_to_nfs4_state(data);
 	if (!IS_ERR(state))
		nfs4_close_state(&data->path, state, data->o_arg.open_flags);
 out_free:
 	nfs4_opendata_put(data);
 }
",1
Detect whether the following code contains vulnerabilities.,"bool GLES2DecoderImpl::DoIsProgram(GLuint client_id) {
  const ProgramManager::ProgramInfo* program = GetProgramInfo(client_id);
  return program != NULL && !program->IsDeleted();
}
",0
Detect whether the following code contains vulnerabilities.,"void ChromeClientImpl::AttachRootGraphicsLayer(GraphicsLayer* root_layer,
                                               LocalFrame* local_frame) {
  DCHECK(!RuntimeEnabledFeatures::SlimmingPaintV2Enabled());
  WebLocalFrameImpl* web_frame =
      WebLocalFrameImpl::FromFrame(local_frame)->LocalRoot();

  DCHECK(web_frame->FrameWidget() || !root_layer);
  if (web_frame->FrameWidget())
    web_frame->FrameWidget()->SetRootGraphicsLayer(root_layer);
}
",0
Detect whether the following code contains vulnerabilities.,"void mp_encode_lua_table_as_map(lua_State *L, mp_buf *buf, int level) {
    size_t len = 0;

    /* First step: count keys into table. No other way to do it with the
      * Lua API, we need to iterate a first time. Note that an alternative
      * would be to do a single run, and then hack the buffer to insert the
      * map opcodes for message pack. Too hackish for this lib. */
     lua_pushnil(L);
     while(lua_next(L,-2)) {
         lua_pop(L,1); /* remove value, keep key for next iteration. */
        len++;
    }

    /* Step two: actually encoding of the map. */
    mp_encode_map(L,buf,len);
    lua_pushnil(L);
    while(lua_next(L,-2)) {
        /* Stack: ... key value */
        lua_pushvalue(L,-2); /* Stack: ... key value key */
        mp_encode_lua_type(L,buf,level+1); /* encode key */
        mp_encode_lua_type(L,buf,level+1); /* encode val */
    }
}
",1
Detect whether the following code contains vulnerabilities.,"LayoutBlockFlow::~LayoutBlockFlow()
{
}
",0
Detect whether the following code contains vulnerabilities.,"  DEFINE_INLINE_TRACE() { visitor->trace(arrayBuffer); }
",0
Detect whether the following code contains vulnerabilities.," static void shm_destroy(struct ipc_namespace *ns, struct shmid_kernel *shp)
 {
 	ns->shm_tot -= (shp->shm_segsz + PAGE_SIZE - 1) >> PAGE_SHIFT;
 	shm_rmid(ns, shp);
 	shm_unlock(shp);
	if (!is_file_hugepages(shp->shm_file))
		shmem_lock(shp->shm_file, 0, shp->mlock_user);
 	else if (shp->mlock_user)
		user_shm_unlock(file_inode(shp->shm_file)->i_size,
						shp->mlock_user);
	fput (shp->shm_file);
 	ipc_rcu_putref(shp, shm_rcu_free);
 }
",1
Detect whether the following code contains vulnerabilities.,"   void RemoveClientSession() {
    context_.network_message_loop()->PostTask(
        FROM_HERE, base::Bind(
            &ClientSession::OnConnectionClosed, client_, connection_));
   }
",1
Detect whether the following code contains vulnerabilities.,"bool AXNodeObject::isMenu() const {
  return roleValue() == MenuRole;
}
",0
Detect whether the following code contains vulnerabilities.,"ExtensionPrefs* ExtensionService::extension_prefs() {
  return extension_prefs_;
}
",0
Detect whether the following code contains vulnerabilities.," status_t SampleTable::setTimeToSampleParams(
         off64_t data_offset, size_t data_size) {
    if (!mTimeToSample.empty() || data_size < 8) {
         return ERROR_MALFORMED;
     }
 
 uint8_t header[8];
 if (mDataSource->readAt(
                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {
 return ERROR_IO;
 }

 if (U32_AT(header) != 0) {
 return ERROR_MALFORMED;
 }

    mTimeToSampleCount = U32_AT(&header[4]);
 if ((uint64_t)mTimeToSampleCount >
 (uint64_t)UINT32_MAX / (2 * sizeof(uint32_t))) {
        ALOGE(""  Error: Time-to-sample table size too large."");

 return ERROR_OUT_OF_RANGE;
 }

 if (!mDataSource->getVector(data_offset + 8, &mTimeToSample,
                                mTimeToSampleCount * 2)) {
        ALOGE(""  Error: Incomplete data read for time-to-sample table."");
 return ERROR_IO;
 }


     for (size_t i = 0; i < mTimeToSample.size(); ++i) {
         mTimeToSample.editItemAt(i) = ntohl(mTimeToSample[i]);
     }
     return OK;
 }
",1
Detect whether the following code contains vulnerabilities.,"vrrp_state_handler(vector_t *strvec)
{
	char *str = strvec_slot(strvec, 1);
	vrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);

	if (!strcmp(str, ""MASTER""))
		vrrp->wantstate = VRRP_STATE_MAST;
	else if (!strcmp(str, ""BACKUP""))
	{
		if (vrrp->wantstate == VRRP_STATE_MAST)
			report_config_error(CONFIG_GENERAL_ERROR, ""(%s) state previously set as MASTER - ignoring BACKUP"", vrrp->iname);
		else
			vrrp->wantstate = VRRP_STATE_BACK;
	}
	else {
		report_config_error(CONFIG_GENERAL_ERROR,""(%s) unknown state '%s', defaulting to BACKUP"", vrrp->iname, str);
		vrrp->wantstate = VRRP_STATE_BACK;
	}
}
",0
Detect whether the following code contains vulnerabilities.,"static int __follow_pte(struct mm_struct *mm, unsigned long address,
		pte_t **ptepp, spinlock_t **ptlp)
{
	pgd_t *pgd;
	pud_t *pud;
	pmd_t *pmd;
	pte_t *ptep;

	pgd = pgd_offset(mm, address);
	if (pgd_none(*pgd) || unlikely(pgd_bad(*pgd)))
		goto out;

	pud = pud_offset(pgd, address);
	if (pud_none(*pud) || unlikely(pud_bad(*pud)))
		goto out;

	pmd = pmd_offset(pud, address);
	VM_BUG_ON(pmd_trans_huge(*pmd));
	if (pmd_none(*pmd) || unlikely(pmd_bad(*pmd)))
		goto out;

	/* We cannot handle huge page PFN maps. Luckily they don't exist. */
	if (pmd_huge(*pmd))
		goto out;

	ptep = pte_offset_map_lock(mm, pmd, address, ptlp);
	if (!ptep)
		goto out;
	if (!pte_present(*ptep))
		goto unlock;
	*ptepp = ptep;
	return 0;
unlock:
	pte_unmap_unlock(ptep, *ptlp);
out:
	return -EINVAL;
}
",0
Detect whether the following code contains vulnerabilities.,"static void reflectUnsignedShortAttributeAttributeSetterCallback(v8::Local<v8::String>, v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE(""Blink"", ""DOMSetter"");
    CustomElementCallbackDispatcher::CallbackDeliveryScope deliveryScope;
    TestObjectPythonV8Internal::reflectUnsignedShortAttributeAttributeSetter(jsValue, info);
    TRACE_EVENT_SET_SAMPLING_STATE(""V8"", ""V8Execution"");
}
",0
Detect whether the following code contains vulnerabilities.,"static int xfrm_exp_policy_notify(struct xfrm_policy *xp, int dir, const struct km_event *c)
{
	struct net *net = xp_net(xp);
	struct sk_buff *skb;

	skb = nlmsg_new(xfrm_polexpire_msgsize(xp), GFP_ATOMIC);
	if (skb == NULL)
		return -ENOMEM;

	if (build_polexpire(skb, xp, dir, c) < 0)
		BUG();

	return xfrm_nlmsg_multicast(net, skb, 0, XFRMNLGRP_EXPIRE);
}
",0
Detect whether the following code contains vulnerabilities.,"void RenderFrameHostImpl::OnJavaScriptExecuteResponse(
    int id, const base::ListValue& result) {
  const base::Value* result_value;
  if (!result.Get(0, &result_value)) {
    NOTREACHED() << ""Got bad arguments for OnJavaScriptExecuteResponse"";
    return;
  }

  auto it = javascript_callbacks_.find(id);
  if (it != javascript_callbacks_.end()) {
    it->second.Run(result_value);
    javascript_callbacks_.erase(it);
  } else {
    NOTREACHED() << ""Received script response for unknown request"";
  }
}
",0
Detect whether the following code contains vulnerabilities.,"static int dcbnl_getstate(struct net_device *netdev, struct nlmsghdr *nlh,
			  u32 seq, struct nlattr **tb, struct sk_buff *skb)
{
	/* if (!tb[DCB_ATTR_STATE] || !netdev->dcbnl_ops->getstate) */
	if (!netdev->dcbnl_ops->getstate)
		return -EOPNOTSUPP;

	return nla_put_u8(skb, DCB_ATTR_STATE,
			  netdev->dcbnl_ops->getstate(netdev));
}
",0
Detect whether the following code contains vulnerabilities.,"static void kvm_update_dr0123(struct kvm_vcpu *vcpu)
{
	int i;

	if (!(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)) {
		for (i = 0; i < KVM_NR_DB_REGS; i++)
			vcpu->arch.eff_db[i] = vcpu->arch.db[i];
		vcpu->arch.switch_db_regs |= KVM_DEBUGREG_RELOAD;
	}
}
",0
Detect whether the following code contains vulnerabilities.,"inline bool SearchBuffer::isBadMatch(const UChar* match, size_t matchLength) const
{
    if (!m_targetRequiresKanaWorkaround)
        return false;

    normalizeCharacters(match, matchLength, m_normalizedMatch);

    const UChar* a = m_normalizedTarget.begin();
    const UChar* aEnd = m_normalizedTarget.end();

    const UChar* b = m_normalizedMatch.begin();
    const UChar* bEnd = m_normalizedMatch.end();

    while (true) {
        while (a != aEnd && !isKanaLetter(*a))
            ++a;
        while (b != bEnd && !isKanaLetter(*b))
            ++b;

        if (a == aEnd || b == bEnd) {
            ASSERT(a == aEnd);
            ASSERT(b == bEnd);
            return false;
        }

        if (isSmallKanaLetter(*a) != isSmallKanaLetter(*b))
            return true;
        if (composedVoicedSoundMark(*a) != composedVoicedSoundMark(*b))
            return true;
        ++a;
        ++b;

        while (1) {
            if (!(a != aEnd && isCombiningVoicedSoundMark(*a))) {
                if (b != bEnd && isCombiningVoicedSoundMark(*b))
                    return true;
                break;
            }
            if (!(b != bEnd && isCombiningVoicedSoundMark(*b)))
                return true;
            if (*a != *b)
                return true;
            ++a;
            ++b;
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"  views::ImageButton* close_button() const {
    return media_controls_view_->close_button_;
  }
",1
Detect whether the following code contains vulnerabilities.,"void WebGraphicsContext3DCommandBufferImpl::OnMemoryAllocationChanged(
    const GpuMemoryAllocation& allocation) {
  if (memory_allocation_changed_callback_)
    memory_allocation_changed_callback_->onMemoryAllocationChanged(
        allocation.gpu_resource_size_in_bytes);
}
",0
Detect whether the following code contains vulnerabilities.,"int GetSystemMetricsInDIP(int metric) {
  return static_cast<int>(GetSystemMetrics(metric) /
      GetDeviceScaleFactor() + 0.5);
}
",0
Detect whether the following code contains vulnerabilities.," void PrintWebViewHelper::OnPrintForSystemDialog() {
   blink::WebLocalFrame* frame = print_preview_context_.source_frame();
   if (!frame) {
     NOTREACHED();
    return;
  }
  Print(frame, print_preview_context_.source_node(), false);
}
",1
Detect whether the following code contains vulnerabilities.,"  void WaitForCopySourceReady() {
    while (!GetRenderWidgetHostViewPort()->IsSurfaceAvailableForCopy())
      GiveItSomeTime();
  }
",0
Detect whether the following code contains vulnerabilities.,"void Vp9Parser::ReadSegmentationMap() {
   for (size_t i = 0; i < Vp9Segmentation::kNumTreeProbs; i++) {
    segmentation_.tree_probs[i] =
         reader_.ReadBool() ? reader_.ReadLiteral(8) : kVp9MaxProb;
   }
 
   for (size_t i = 0; i < Vp9Segmentation::kNumPredictionProbs; i++)
    segmentation_.pred_probs[i] = kVp9MaxProb;
 
  segmentation_.temporal_update = reader_.ReadBool();
  if (segmentation_.temporal_update) {
     for (size_t i = 0; i < Vp9Segmentation::kNumPredictionProbs; i++) {
       if (reader_.ReadBool())
        segmentation_.pred_probs[i] = reader_.ReadLiteral(8);
     }
   }
 }
",1
Detect whether the following code contains vulnerabilities.,"static inline int nfs4_lock_type(struct file_lock *fl, int block)
{
	if ((fl->fl_type & (F_RDLCK|F_WRLCK|F_UNLCK)) == F_RDLCK)
		return block ? NFS4_READW_LT : NFS4_READ_LT;
	return block ? NFS4_WRITEW_LT : NFS4_WRITE_LT;
}
",0
Detect whether the following code contains vulnerabilities.,"static void display_motd() {
	FILE *fp;
	int c;

	if ((fp = fopen(""/etc/motd"", ""r""))) {
		while ((c = getc(fp)) != EOF) {
			putchar(c);
		}
		fclose(fp);
	}
}
",0
Detect whether the following code contains vulnerabilities.,"bool SiteInstanceImpl::ShouldLockToOrigin(BrowserContext* browser_context,
                                          GURL site_url) {
  if (RenderProcessHost::run_renderer_in_process())
    return false;

  if (!DoesSiteRequireDedicatedProcess(browser_context, site_url))
    return false;

   if (site_url.SchemeIs(content::kGuestScheme))
     return false;
 
  if (site_url.SchemeIs(content::kChromeUIScheme))
    return false;
  if (!GetContentClient()->browser()->ShouldLockToOrigin(browser_context,
                                                         site_url)) {
    return false;
  }

  return true;
}
",1
Detect whether the following code contains vulnerabilities.,"status_t SampleTable::setCompositionTimeToSampleParams(
 off64_t data_offset, size_t data_size) {
    ALOGI(""There are reordered frames present."");

 if (mCompositionTimeDeltaEntries != NULL || data_size < 8) {
 return ERROR_MALFORMED;
 }

 uint8_t header[8];
 if (mDataSource->readAt(
                data_offset, header, sizeof(header))
 < (ssize_t)sizeof(header)) {
 return ERROR_IO;
 }

 if (U32_AT(header) != 0) {
 return ERROR_MALFORMED;
 }

 size_t numEntries = U32_AT(&header[4]);

 if (data_size != (numEntries + 1) * 8) {
 return ERROR_MALFORMED;

     }
 
     mNumCompositionTimeDeltaEntries = numEntries;
     mCompositionTimeDeltaEntries = new uint32_t[2 * numEntries];
 
     if (mDataSource->readAt(
                data_offset + 8, mCompositionTimeDeltaEntries, numEntries * 8)
 < (ssize_t)numEntries * 8) {
 delete[] mCompositionTimeDeltaEntries;
        mCompositionTimeDeltaEntries = NULL;

 return ERROR_IO;
 }

 for (size_t i = 0; i < 2 * numEntries; ++i) {
        mCompositionTimeDeltaEntries[i] = ntohl(mCompositionTimeDeltaEntries[i]);
 }

    mCompositionDeltaLookup->setEntries(
            mCompositionTimeDeltaEntries, mNumCompositionTimeDeltaEntries);

 return OK;
}
",1
Detect whether the following code contains vulnerabilities.,"void Tab::OnMouseReleased(const ui::MouseEvent& event) {
  controller_->OnMouseEventInTab(this, event);

  if (controller_->EndDrag(END_DRAG_COMPLETE))
    return;

  if (event.IsMiddleMouseButton()) {
    if (HitTestPoint(event.location())) {
      controller_->CloseTab(this, CLOSE_TAB_FROM_MOUSE);
    } else if (closing_) {
      gfx::Point location_in_parent = event.location();
      ConvertPointToTarget(this, parent(), &location_in_parent);
      Tab* closest_tab = controller_->GetTabAt(location_in_parent);
      if (closest_tab)
        controller_->CloseTab(closest_tab, CLOSE_TAB_FROM_MOUSE);
    }
  } else if (event.IsOnlyLeftMouseButton() && !event.IsShiftDown() &&
             !IsSelectionModifierDown(event)) {
    controller_->SelectTab(this, event);
  }
}
",0
Detect whether the following code contains vulnerabilities.," static void skcipher_release(void *private)
 {
	crypto_free_skcipher(private);
 }
",1
Detect whether the following code contains vulnerabilities.," Blob::Blob(PassOwnPtr<BlobData> blobData, long long size)
    : m_type(blobData->contentType())
    , m_size(size)
{
    ASSERT(blobData);
    ScriptWrappable::init(this);
 
     m_internalURL = BlobURL::createInternalURL();
    ThreadableBlobRegistry::registerBlobURL(m_internalURL, blobData);
 }
",1
Detect whether the following code contains vulnerabilities.,"static void srpt_cm_rep_error(struct ib_cm_id *cm_id)
{
	pr_info(""Received IB REP error for cm_id %p.\n"", cm_id);
	srpt_drain_channel(cm_id);
}
",0
Detect whether the following code contains vulnerabilities.,"IPC::PlatformFileForTransit ProxyChannelDelegate::ShareHandleWithRemote(
    base::PlatformFile handle,
    const IPC::SyncChannel& channel,
    bool should_close_source) {
  return content::BrokerGetFileHandleForProcess(handle, channel.peer_pid(),
                                                should_close_source);
}
",1
Detect whether the following code contains vulnerabilities.,"service_is_single_onion_poisoned(const rend_service_t *service)
{
  char *poison_fname = NULL;
  file_status_t fstatus;

  /* Passing a NULL service is a bug */
  if (BUG(!service)) {
    return 0;
  }

  if (rend_service_is_ephemeral(service)) {
    return 0;
  }

  poison_fname = rend_service_sos_poison_path(service);

  fstatus = file_status(poison_fname);
  tor_free(poison_fname);

  /* If this fname is occupied, the hidden service has been poisoned.
   * fstatus can be FN_ERROR if the service directory does not exist, in that
   * case, there is obviously no private key. */
  if (fstatus == FN_FILE || fstatus == FN_EMPTY) {
    return 1;
  }

  return 0;
}
",0
Detect whether the following code contains vulnerabilities.,"PS_SERIALIZER_DECODE_FUNC(php_serialize) /* {{{ */
{
	const char *endptr = val + vallen;
	zval *session_vars;
	php_unserialize_data_t var_hash;

	PHP_VAR_UNSERIALIZE_INIT(var_hash);
	ALLOC_INIT_ZVAL(session_vars);
        if (php_var_unserialize(&session_vars, &val, endptr, &var_hash TSRMLS_CC)) {
                var_push_dtor(&var_hash, &session_vars);
        }
        PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
        if (PS(http_session_vars)) {
                zval_ptr_dtor(&PS(http_session_vars));
	}
	if (Z_TYPE_P(session_vars) == IS_NULL) {
		array_init(session_vars);
	}
	PS(http_session_vars) = session_vars;
	ZEND_SET_GLOBAL_VAR_WITH_LENGTH(""_SESSION"", sizeof(""_SESSION""), PS(http_session_vars), Z_REFCOUNT_P(PS(http_session_vars)) + 1, 1);
	return SUCCESS;
}
/* }}} */
",1
Detect whether the following code contains vulnerabilities.,"static void ext2_put_super (struct super_block * sb)
{
	int db_count;
	int i;
	struct ext2_sb_info *sbi = EXT2_SB(sb);
 
 	dquot_disable(sb, -1, DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);
 
	ext2_xattr_put_super(sb);
 	if (!(sb->s_flags & MS_RDONLY)) {
 		struct ext2_super_block *es = sbi->s_es;
 
		spin_lock(&sbi->s_lock);
		es->s_state = cpu_to_le16(sbi->s_mount_state);
		spin_unlock(&sbi->s_lock);
		ext2_sync_super(sb, es, 1);
	}
	db_count = sbi->s_gdb_count;
	for (i = 0; i < db_count; i++)
		if (sbi->s_group_desc[i])
			brelse (sbi->s_group_desc[i]);
	kfree(sbi->s_group_desc);
	kfree(sbi->s_debts);
	percpu_counter_destroy(&sbi->s_freeblocks_counter);
	percpu_counter_destroy(&sbi->s_freeinodes_counter);
	percpu_counter_destroy(&sbi->s_dirs_counter);
	brelse (sbi->s_sbh);
	sb->s_fs_info = NULL;
	kfree(sbi->s_blockgroup_lock);
	kfree(sbi);
}
",1
Detect whether the following code contains vulnerabilities.,"__u32 secure_ipv6_id(const __be32 daddr[4])
{
	const struct keydata *keyptr;
	__u32 hash[4];
	keyptr = get_keyptr();
	hash[0] = (__force __u32)daddr[0];
	hash[1] = (__force __u32)daddr[1];
	hash[2] = (__force __u32)daddr[2];
	hash[3] = (__force __u32)daddr[3];
	return half_md4_transform(hash, keyptr->secret);
}
",1
Detect whether the following code contains vulnerabilities.," RenderFrameObserverNatives::RenderFrameObserverNatives(ScriptContext* context)
    : ObjectBackedNativeHandler(context) {
   RouteFunction(
       ""OnDocumentElementCreated"",
       base::Bind(&RenderFrameObserverNatives::OnDocumentElementCreated,
                  base::Unretained(this)));
 }
",1
Detect whether the following code contains vulnerabilities.,"getnetnum(
	const char *num,
	sockaddr_u *addr,
	int complain,
	enum gnn_type a_type	/* ignored */
	)
{
	NTP_REQUIRE(AF_UNSPEC == AF(addr) ||
		    AF_INET == AF(addr) ||
		    AF_INET6 == AF(addr));

	if (!is_ip_address(num, AF(addr), addr))
		return 0;

	if (IS_IPV6(addr) && !ipv6_works)
		return -1;

# ifdef ISC_PLATFORM_HAVESALEN
	addr->sa.sa_len = SIZEOF_SOCKADDR(AF(addr));
# endif
	SET_PORT(addr, NTP_PORT);

	DPRINTF(2, (""getnetnum given %s, got %s\n"", num, stoa(addr)));

	return 1;
}
",0
Detect whether the following code contains vulnerabilities.,"std::string SanitizeRevision(const std::string& revision) {
  for (size_t i = 0; i < revision.length(); i++) {
    if (!(revision[i] == '@' && i == 0)
        && !(revision[i] >= '0' && revision[i] <= '9')
        && !(revision[i] >= 'a' && revision[i] <= 'z')
        && !(revision[i] >= 'A' && revision[i] <= 'Z')) {
      return std::string();
    }
  }
  return revision;
}
",1
Detect whether the following code contains vulnerabilities.,"int fastcall __lock_page_killable(struct page *page)
{
	DEFINE_WAIT_BIT(wait, &page->flags, PG_locked);

	return __wait_on_bit_lock(page_waitqueue(page), &wait,
					sync_page_killable, TASK_KILLABLE);
}
",0
Detect whether the following code contains vulnerabilities.," pvscsi_ring_init_data(PVSCSIRingInfo *m, PVSCSICmdDescSetupRings *ri)
 {
     int i;
    uint32_t txr_len_log2, rxr_len_log2;
     uint32_t req_ring_size, cmp_ring_size;
     m->rs_pa = ri->ringsStatePPN << VMW_PAGE_SHIFT;
 
    if ((ri->reqRingNumPages > PVSCSI_SETUP_RINGS_MAX_NUM_PAGES)
        || (ri->cmpRingNumPages > PVSCSI_SETUP_RINGS_MAX_NUM_PAGES)) {
        return -1;
    }
     req_ring_size = ri->reqRingNumPages * PVSCSI_MAX_NUM_REQ_ENTRIES_PER_PAGE;
     cmp_ring_size = ri->cmpRingNumPages * PVSCSI_MAX_NUM_CMP_ENTRIES_PER_PAGE;
     txr_len_log2 = pvscsi_log2(req_ring_size - 1);
    }
",1
Detect whether the following code contains vulnerabilities.,"unsigned venc_dev::venc_flush( unsigned port)
{
 struct v4l2_encoder_cmd enc;
    DEBUG_PRINT_LOW(""in %s"", __func__);

    enc.cmd = V4L2_ENC_QCOM_CMD_FLUSH;
    enc.flags = V4L2_QCOM_CMD_FLUSH_OUTPUT | V4L2_QCOM_CMD_FLUSH_CAPTURE;

 if (ioctl(m_nDriver_fd, VIDIOC_ENCODER_CMD, &enc)) {
        DEBUG_PRINT_ERROR(""Flush Port (%d) Failed "", port);
 return -1;
 }

 return 0;

}
",0
Detect whether the following code contains vulnerabilities.,"static void perf_event_reset(struct perf_event *event)
 {
 	(void)perf_event_read(event);
 	local64_set(&event->count, 0);
	perf_event_update_userpage(event);
}
",1
Detect whether the following code contains vulnerabilities.," void WebPagePrivate::didComposite()
 {
     if (!m_page->settings()->developerExtrasEnabled())
         return;
    InspectorInstrumentation::didComposite(m_page);
 }
",1
Detect whether the following code contains vulnerabilities.,"static void kvm_unpin_pages(struct kvm *kvm, pfn_t pfn, unsigned long npages)
{
	unsigned long i;
	for (i = 0; i < npages; ++i)
		kvm_release_pfn_clean(pfn + i);
}
",1
Detect whether the following code contains vulnerabilities.,"virDomainGetJobInfo(virDomainPtr domain, virDomainJobInfoPtr info)
{
    virConnectPtr conn;

    VIR_DOMAIN_DEBUG(domain, ""info=%p"", info);

    virResetLastError();

    if (info)
        memset(info, 0, sizeof(*info));

    virCheckDomainReturn(domain, -1);
    virCheckNonNullArgGoto(info, error);

    conn = domain->conn;

    if (conn->driver->domainGetJobInfo) {
        int ret;
        ret = conn->driver->domainGetJobInfo(domain, info);
        if (ret < 0)
            goto error;
        return ret;
    }

    virReportUnsupportedError();

 error:
    virDispatchError(domain->conn);
    return -1;
}
",0
Detect whether the following code contains vulnerabilities.,"std::string GLES2Util::GetQualifiedEnumString(const EnumToString* table,
                                              size_t count,
                                              uint32_t value) {
  for (const EnumToString* end = table + count; table < end; ++table) {
    if (table->value == value) {
      return table->name;
    }
  }
  return GetStringEnum(value);
}
",0
Detect whether the following code contains vulnerabilities.,"static int show_traces_open(struct inode *inode, struct file *file)
{
	struct trace_array *tr = inode->i_private;
	struct seq_file *m;
	int ret;

	if (tracing_disabled)
		return -ENODEV;

	ret = seq_open(file, &show_traces_seq_ops);
	if (ret)
		return ret;

	m = file->private_data;
	m->private = tr;

	return 0;
}
",0
Detect whether the following code contains vulnerabilities.,"static float CL_DemoFrameDurationSDev( void )
{
	int i;
	int numFrames;
	float mean = 0.0f;
	float variance = 0.0f;

	if( ( clc.timeDemoFrames - 1 ) > MAX_TIMEDEMO_DURATIONS )
		numFrames = MAX_TIMEDEMO_DURATIONS;
	else
		numFrames = clc.timeDemoFrames - 1;

	for( i = 0; i < numFrames; i++ )
		mean += clc.timeDemoDurations[ i ];
	mean /= numFrames;

	for( i = 0; i < numFrames; i++ )
	{
		float x = clc.timeDemoDurations[ i ];

		variance += ( ( x - mean ) * ( x - mean ) );
	}
	variance /= numFrames;

	return sqrt( variance );
}
",0
Detect whether the following code contains vulnerabilities.,"WebContents* GetEmbedderForGuest(content::WebContents* guest) {
  CHECK(guest);
  return static_cast<content::WebContentsImpl*>(guest)->GetOuterWebContents();
}
",0
Detect whether the following code contains vulnerabilities.,"bool LayoutSVGTransformableContainer::calculateLocalTransform()
 {
     SVGGraphicsElement* element = toSVGGraphicsElement(this->element());
     ASSERT(element);

    SVGUseElement* useElement = nullptr;
    if (isSVGUseElement(*element)) {
        useElement = toSVGUseElement(element);
    } else if (isSVGGElement(*element) && toSVGGElement(element)->inUseShadowTree()) {
        SVGElement* correspondingElement = element->correspondingElement();
        if (isSVGUseElement(correspondingElement))
            useElement = toSVGUseElement(correspondingElement);
    }

    if (useElement) {
        SVGLengthContext lengthContext(useElement);
         FloatSize translation(
             useElement->x()->currentValue()->value(lengthContext),
             useElement->y()->currentValue()->value(lengthContext));
         if (translation != m_additionalTranslation)
            m_needsTransformUpdate = true;
         m_additionalTranslation = translation;
     }
 
     if (!m_needsTransformUpdate)
        return false;
 
     m_localTransform = element->calculateAnimatedLocalTransform();
     m_localTransform.translate(m_additionalTranslation.width(), m_additionalTranslation.height());
     m_needsTransformUpdate = false;
    return true;
 }
",1
Detect whether the following code contains vulnerabilities.,"  CacheThread() : base::Thread(""CacheThread_BlockFile"") {
    CHECK(
        StartWithOptions(base::Thread::Options(base::MessageLoop::TYPE_IO, 0)));
  }
",0
Detect whether the following code contains vulnerabilities.,"compile_string_raw_node(StrNode* sn, regex_t* reg)
{
  if (sn->end <= sn->s)
    return 0;

  return add_compile_string(sn->s, 1 /* sb */, (int )(sn->end - sn->s), reg, 0);
}
",0
Detect whether the following code contains vulnerabilities.,"void DownloadResourceHandler::OnRequestRedirected(
    const net::RedirectInfo& redirect_info,
    network::ResourceResponse* response,
    std::unique_ptr<ResourceController> controller) {
  url::Origin new_origin(url::Origin::Create(redirect_info.new_url));
  if (!follow_cross_origin_redirects_ &&
      !first_origin_.IsSameOriginWith(new_origin)) {
    base::PostTaskWithTraits(
        FROM_HERE, {BrowserThread::UI},
        base::BindOnce(
            &NavigateOnUIThread, redirect_info.new_url, request()->url_chain(),
            Referrer(GURL(redirect_info.new_referrer),
                      Referrer::NetReferrerPolicyToBlinkReferrerPolicy(
                          redirect_info.new_referrer_policy)),
             GetRequestInfo()->HasUserGesture(),
            GetRequestInfo()->GetWebContentsGetterForRequest()));
     controller->Cancel();
     return;
   }
  if (core_.OnRequestRedirected()) {
    controller->Resume();
  } else {
    controller->Cancel();
  }
}
",1
Detect whether the following code contains vulnerabilities.,"static int nfs_idmap_read_and_verify_message(struct idmap_msg *im,
		struct idmap_msg *upcall,
		struct key *key, struct key *authkey)
{
	char id_str[NFS_UINT_MAXLEN];
	size_t len;
	int ret = -ENOKEY;

	/* ret = -ENOKEY */
	if (upcall->im_type != im->im_type || upcall->im_conv != im->im_conv)
		goto out;
	switch (im->im_conv) {
	case IDMAP_CONV_NAMETOID:
		if (strcmp(upcall->im_name, im->im_name) != 0)
			break;
		/* Note: here we store the NUL terminator too */
		len = sprintf(id_str, ""%d"", im->im_id) + 1;
		ret = nfs_idmap_instantiate(key, authkey, id_str, len);
		break;
	case IDMAP_CONV_IDTONAME:
		if (upcall->im_id != im->im_id)
			break;
		len = strlen(im->im_name);
		ret = nfs_idmap_instantiate(key, authkey, im->im_name, len);
		break;
	default:
		ret = -EINVAL;
	}
out:
	return ret;
}
",0
Detect whether the following code contains vulnerabilities.,"void FrameLoader::Trace(blink::Visitor* visitor) {
  visitor->Trace(frame_);
   visitor->Trace(progress_tracker_);
   visitor->Trace(document_loader_);
   visitor->Trace(provisional_document_loader_);
 }
",1
Detect whether the following code contains vulnerabilities.,"Platform::IntPoint InRegionScrollableArea::calculateMaximumScrollPosition(const Platform::IntSize& viewportSize, const Platform::IntSize& contentsSize, float overscrollLimitFactor) const
{
    ASSERT(!allowsOverscroll());
    return Platform::IntPoint(std::max(contentsSize.width() - viewportSize.width(), 0) + overscrollLimitFactor,
                              std::max(contentsSize.height() - viewportSize.height(), 0) + overscrollLimitFactor);
}
",1
Detect whether the following code contains vulnerabilities.,"device_constructor (GType type,
                    guint n_construct_properties,
                    GObjectConstructParam *construct_properties)
{
  Device *device;
  DeviceClass *klass;

  klass = DEVICE_CLASS (g_type_class_peek (TYPE_DEVICE));

  device = DEVICE (G_OBJECT_CLASS (device_parent_class)->constructor (type,
                                                                      n_construct_properties,
                                                                      construct_properties));
  return G_OBJECT (device);
}
",0
Detect whether the following code contains vulnerabilities.,"void BrightnessObserver::BrightnessChanged(int level, bool user_initiated) {
  if (user_initiated)
    BrightnessBubble::GetInstance()->ShowBubble(level, true);
  else
    BrightnessBubble::GetInstance()->UpdateWithoutShowingBubble(level, true);

  VolumeBubble::GetInstance()->HideBubble();
}
",0
Detect whether the following code contains vulnerabilities.,"void RenderWidgetHostViewAura::UpdateExternalTexture() {
  if (accelerated_compositing_state_changed_)
    accelerated_compositing_state_changed_ = false;

  bool is_compositing_active = host_->is_accelerated_compositing_active();
  if (is_compositing_active && current_surface_.get()) {
    window_->layer()->SetExternalTexture(current_surface_.get());
    current_frame_size_ = ConvertSizeToDIP(
        current_surface_->device_scale_factor(), current_surface_->size());
    CheckResizeLock();
    software_frame_manager_->DiscardCurrentFrame();
  } else if (is_compositing_active &&
             software_frame_manager_->HasCurrentFrame()) {
    cc::TextureMailbox mailbox;
    scoped_ptr<cc::SingleReleaseCallback> callback;
    software_frame_manager_->GetCurrentFrameMailbox(&mailbox, &callback);
    window_->layer()->SetTextureMailbox(mailbox,
                                        callback.Pass(),
                                        last_swapped_surface_scale_factor_);
    current_frame_size_ = ConvertSizeToDIP(last_swapped_surface_scale_factor_,
                                           mailbox.shared_memory_size());
    CheckResizeLock();
  } else {
    window_->layer()->SetShowPaintedContent();
    resize_lock_.reset();
    host_->WasResized();
    software_frame_manager_->DiscardCurrentFrame();
  }
}
",0
Detect whether the following code contains vulnerabilities.,"static inline unsigned long hash_name(const char *name, unsigned int *hashp)
{
	unsigned long hash = init_name_hash();
	unsigned long len = 0, c;

	c = (unsigned char)*name;
	do {
		len++;
		hash = partial_name_hash(c, hash);
		c = (unsigned char)name[len];
	} while (c && c != '/');
	*hashp = end_name_hash(hash);
	return len;
}
",0
Detect whether the following code contains vulnerabilities.,"SYSCALL_DEFINE5(waitid, int, which, pid_t, upid, struct siginfo __user *,
		infop, int, options, struct rusage __user *, ru)
{
	struct rusage r;
 	struct waitid_info info = {.status = 0};
 	long err = kernel_waitid(which, upid, &info, options, ru ? &r : NULL);
 	int signo = 0;
 	if (err > 0) {
 		signo = SIGCHLD;
 		err = 0;
	}
	if (!err) {
 		if (ru && copy_to_user(ru, &r, sizeof(struct rusage)))
 			return -EFAULT;
 	}
	if (!infop)
		return err;

	user_access_begin();
	unsafe_put_user(signo, &infop->si_signo, Efault);
	unsafe_put_user(0, &infop->si_errno, Efault);
	unsafe_put_user(info.cause, &infop->si_code, Efault);
	unsafe_put_user(info.pid, &infop->si_pid, Efault);
	unsafe_put_user(info.uid, &infop->si_uid, Efault);
	unsafe_put_user(info.status, &infop->si_status, Efault);
	user_access_end();
	return err;
Efault:
	user_access_end();
	return -EFAULT;
}
",1
Detect whether the following code contains vulnerabilities.,"static jboolean enableNative(JNIEnv* env, jobject obj) {
     ALOGV(""%s:"",__FUNCTION__);
 
     jboolean result = JNI_FALSE;
     if (!sBluetoothInterface) return result;
    int ret = sBluetoothInterface->enable();
     result = (ret == BT_STATUS_SUCCESS || ret == BT_STATUS_DONE) ? JNI_TRUE : JNI_FALSE;
     return result;
 }
",1
Detect whether the following code contains vulnerabilities.," ImageBitmapFactories::ImageBitmapLoader::ImageBitmapLoader(
     ImageBitmapFactories& factory,
     base::Optional<IntRect> crop_rect,
     ScriptState* script_state,
     const ImageBitmapOptions* options)
    : loader_(
           FileReaderLoader::Create(FileReaderLoader::kReadAsArrayBuffer, this)),
       factory_(&factory),
       resolver_(ScriptPromiseResolver::Create(script_state)),
       crop_rect_(crop_rect),
       options_(options) {}
",1
Detect whether the following code contains vulnerabilities.,"long Cluster::CreateBlock(
    long long id,
    long long pos,   //absolute pos of payload
    long long size,
    long long discard_padding)
{
    assert((id == 0x20) || (id == 0x23));  //BlockGroup or SimpleBlock
    if (m_entries_count < 0)  //haven't parsed anything yet
    {
        assert(m_entries == NULL);
        assert(m_entries_size == 0);
        m_entries_size = 1024;
        m_entries = new BlockEntry*[m_entries_size];
        m_entries_count = 0;
    }
    else
    {
        assert(m_entries);
        assert(m_entries_size > 0);
        assert(m_entries_count <= m_entries_size);
        if (m_entries_count >= m_entries_size)
        {
            const long entries_size = 2 * m_entries_size;
            BlockEntry** const entries = new BlockEntry*[entries_size];
            assert(entries);
            BlockEntry** src = m_entries;
            BlockEntry** const src_end = src + m_entries_count;
            BlockEntry** dst = entries;
            while (src != src_end)
                *dst++ = *src++;
            delete[] m_entries;
            m_entries = entries;
            m_entries_size = entries_size;
        }
     }
 
    if (id == 0x20)  //BlockGroup ID
        return CreateBlockGroup(pos, size, discard_padding);
    else  //SimpleBlock ID
        return CreateSimpleBlock(pos, size);
 }
",1
Detect whether the following code contains vulnerabilities.,"long long mkvparser::ReadUInt(IMkvReader* pReader, long long pos, long& len) {
  assert(pReader);
  assert(pos >= 0);
  int status;
 
   len = 1;
   unsigned char b;
  status = pReader->Read(pos, 1, &b);
 
   if (status < 0)  // error or underflow
     return status;

 if (status > 0) // interpreted as ""underflow""
 return E_BUFFER_NOT_FULL;

 if (b == 0) // we can't handle u-int values larger than 8 bytes
 return E_FILE_FORMAT_INVALID;

 unsigned char m = 0x80;

 while (!(b & m)) {
    m >>= 1;

     ++len;
   }
 
   long long result = b & (~m);
   ++pos;
 
 for (int i = 1; i < len; ++i) {
    status = pReader->Read(pos, 1, &b);

 if (status < 0) {
      len = 1;
 return status;
 }

 if (status > 0) {
      len = 1;
 return E_BUFFER_NOT_FULL;
 }

    result <<= 8;
    result |= b;

 ++pos;
 }


   return result;
 }
",1
Detect whether the following code contains vulnerabilities.," void WtsSessionProcessDelegate::Core::KillProcess(DWORD exit_code) {
   DCHECK(main_task_runner_->BelongsToCurrentThread());
 
   channel_.reset();
 
   if (launch_elevated_) {
     if (job_.IsValid()) {
      TerminateJobObject(job_, exit_code);
    }
  } else {
    if (worker_process_.IsValid()) {
      TerminateProcess(worker_process_, exit_code);
    }
  }
}
",1
Detect whether the following code contains vulnerabilities.,"static void kgdb_hw_overflow_handler(struct perf_event *event, int nmi,
 		struct perf_sample_data *data, struct pt_regs *regs)
 {
 	struct task_struct *tsk = current;
	int i;

	for (i = 0; i < 4; i++)
		if (breakinfo[i].enabled)
			tsk->thread.debugreg6 |= (DR_TRAP0 << i);
}
",1
Detect whether the following code contains vulnerabilities.," static size_t safecat(char *buffer, size_t bufsize, size_t pos,
   PNG_CONST char *cat)
 {
    while (pos < bufsize && cat != NULL && *cat != 0)
       buffer[pos++] = *cat++;

 if (pos >= bufsize)
      pos = bufsize-1;

   buffer[pos] = 0;
 return pos;
}
",1
Detect whether the following code contains vulnerabilities.,"struct sctp_chunk *sctp_make_shutdown_ack(const struct sctp_association *asoc,
				     const struct sctp_chunk *chunk)
{
	struct sctp_chunk *retval;

	retval = sctp_make_control(asoc, SCTP_CID_SHUTDOWN_ACK, 0, 0);

	/* RFC 2960 6.4 Multi-homed SCTP Endpoints
	 *
	 * An endpoint SHOULD transmit reply chunks (e.g., SACK,
	 * HEARTBEAT ACK, * etc.) to the same destination transport
	 * address from which it * received the DATA or control chunk
	 * to which it is replying.
	 *
	 * [ACK back to where the SHUTDOWN came from.]
	 */
	if (retval && chunk)
		retval->transport = chunk->transport;

	return retval;
}
",0
Detect whether the following code contains vulnerabilities.,"cib_remote_dispatch(gpointer user_data)
 {
     cib_t *cib = user_data;
     cib_remote_opaque_t *private = cib->variant_opaque;
 
     xmlNode *msg = NULL;
    const char *type = NULL;
 
     crm_info(""Message on callback channel"");
    msg = crm_recv_remote_msg(private->callback.session, private->callback.encrypted);
 
    type = crm_element_value(msg, F_TYPE);
    crm_trace(""Activating %s callbacks..."", type);
 
    if (safe_str_eq(type, T_CIB)) {
        cib_native_callback(cib, msg, 0, 0);
 
    } else if (safe_str_eq(type, T_CIB_NOTIFY)) {
        g_list_foreach(cib->notify_list, cib_native_notify, msg);
 
    } else {
        crm_err(""Unknown message type: %s"", type);
    }
 
    if (msg != NULL) {
         free_xml(msg);
        return 0;
     }
    return -1;
 }
",1
Detect whether the following code contains vulnerabilities.,"  uint64_t received_page_id() const { return received_page_id_; }
",0
Detect whether the following code contains vulnerabilities.,"static int gdImageTileGet (gdImagePtr im, int x, int y)
{
	int srcx, srcy;
	int tileColor,p;
	if (!im->tile) {
		return -1;
	}
	srcx = x % gdImageSX(im->tile);
	srcy = y % gdImageSY(im->tile);
	p = gdImageGetPixel(im->tile, srcx, srcy);

	if (im->trueColor) {
		if (im->tile->trueColor) {
			tileColor = p;
		} else {
			tileColor = gdTrueColorAlpha( gdImageRed(im->tile,p), gdImageGreen(im->tile,p), gdImageBlue (im->tile,p), gdImageAlpha (im->tile,p));
		}
	} else {
		if (im->tile->trueColor) {
			tileColor = gdImageColorResolveAlpha(im, gdTrueColorGetRed (p), gdTrueColorGetGreen (p), gdTrueColorGetBlue (p), gdTrueColorGetAlpha (p));
		} else {
			tileColor = p;
			tileColor = gdImageColorResolveAlpha(im, gdImageRed (im->tile,p), gdImageGreen (im->tile,p), gdImageBlue (im->tile,p), gdImageAlpha (im->tile,p));
		}
	}
	return tileColor;
}
",0
Detect whether the following code contains vulnerabilities.,"static bool generic_pkt_to_tuple(const struct sk_buff *skb,
				 unsigned int dataoff,
				 struct nf_conntrack_tuple *tuple)
{
	tuple->src.u.all = 0;
	tuple->dst.u.all = 0;

	return true;
}
",0
Detect whether the following code contains vulnerabilities.," static void php_snmp_object_free_storage(void *object TSRMLS_DC)
 {
        php_snmp_object *intern = (php_snmp_object *)object;
        if (!intern) {
                return;
        }

        netsnmp_session_free(&(intern->session));
 
        zend_object_std_dtor(&intern->zo TSRMLS_CC);
        efree(intern);
 }
",1
Detect whether the following code contains vulnerabilities.,"static int ghash_final(struct shash_desc *desc, u8 *dst)
{
	struct ghash_desc_ctx *dctx = shash_desc_ctx(desc);
 	struct ghash_ctx *ctx = crypto_shash_ctx(desc->tfm);
 	u8 *buf = dctx->buffer;
 
 	ghash_flush(ctx, dctx);
 	memcpy(dst, buf, GHASH_BLOCK_SIZE);
 
	return 0;
}
",1
Detect whether the following code contains vulnerabilities.," void PartialMagnificationController::OnWidgetDestroying(views::Widget* widget) {
  DCHECK_EQ(widget, zoom_widget_);
   RemoveZoomWidgetObservers();
  zoom_widget_ = NULL;
 }
",1
Detect whether the following code contains vulnerabilities.," void __ip_select_ident(struct iphdr *iph, int segs)
 {
 	static u32 ip_idents_hashrnd __read_mostly;
 	u32 hash, id;
 
 	net_get_random_once(&ip_idents_hashrnd, sizeof(ip_idents_hashrnd));
 
 	hash = jhash_3words((__force u32)iph->daddr,
 			    (__force u32)iph->saddr,
			    iph->protocol,
 			    ip_idents_hashrnd);
 	id = ip_idents_reserve(hash, segs);
 	iph->id = htons(id);
}
",1
Detect whether the following code contains vulnerabilities.," OJPEGDecode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)
 {
 	OJPEGState* sp=(OJPEGState*)tif->tif_data;
 	(void)s;
 	if (sp->libjpeg_jpeg_query_style==0)
 	{
 		if (OJPEGDecodeRaw(tif,buf,cc)==0)
			return(0);
	}
	else
	{
		if (OJPEGDecodeScanlines(tif,buf,cc)==0)
			return(0);
	}
	return(1);
}
",1
Detect whether the following code contains vulnerabilities.,"     CCLayerTreeHostTest()
         : m_beginning(false)
         , m_endWhenBeginReturns(false)
        , m_running(false)
         , m_timedOut(false)
     {
         m_webThread = adoptPtr(webKitPlatformSupport()->createThread(""CCLayerTreeHostTest""));
         WebCompositor::setThread(m_webThread.get());
#if USE(THREADED_COMPOSITING)
        m_settings.enableCompositorThread = true;
#else
        m_settings.enableCompositorThread = false;
 #endif
     }
",1
Detect whether the following code contains vulnerabilities.,"void PPB_Buffer_Proxy::OnMsgCreate(
    PP_Instance instance,
    uint32_t size,
    HostResource* result_resource,
    ppapi::proxy::SerializedHandle* result_shm_handle) {
  result_shm_handle->set_null_shmem();
   HostDispatcher* dispatcher = HostDispatcher::GetForInstance(instance);
   if (!dispatcher)
     return;
 
   thunk::EnterResourceCreation enter(instance);
   if (enter.failed())
    return;
  PP_Resource local_buffer_resource = enter.functions()->CreateBuffer(instance,
                                                                      size);
  if (local_buffer_resource == 0)
    return;

  thunk::EnterResourceNoLock<thunk::PPB_BufferTrusted_API> trusted_buffer(
      local_buffer_resource, false);
  if (trusted_buffer.failed())
    return;
  int local_fd;
  if (trusted_buffer.object()->GetSharedMemory(&local_fd) != PP_OK)
    return;

  result_resource->SetHostResource(instance, local_buffer_resource);

  base::PlatformFile platform_file =
#if defined(OS_WIN)
      reinterpret_cast<HANDLE>(static_cast<intptr_t>(local_fd));
#elif defined(OS_POSIX)
      local_fd;
#else
  #error Not implemented.
#endif
  result_shm_handle->set_shmem(
      dispatcher->ShareHandleWithRemote(platform_file, false), size);
}
",1
Detect whether the following code contains vulnerabilities.,"static Bool leap_year(u32 year) {
	year += 1900;
	return (year % 4) == 0 && ((year % 100) != 0 || (year % 400) == 0) ? GF_TRUE : GF_FALSE;
}
",0
Detect whether the following code contains vulnerabilities.,"int fix_log_file_owner(uid_t uid, gid_t gid)
{
	int r1 = 0, r2 = 0;

	if (!(log_fp = open_log_file()))
		return -1;
	r1 = fchown(fileno(log_fp), uid, gid);

	if (open_debug_log() != OK)
		return -1;
	if (debug_file_fp)
		r2 = fchown(fileno(debug_file_fp), uid, gid);

	/* return 0 if both are 0 and otherwise < 0 */
	return r1 < r2 ? r1 : r2;
}
",0
Detect whether the following code contains vulnerabilities.,"PlatformSensorFusion::~PlatformSensorFusion() {
  for (const auto& pair : source_sensors_)
    pair.second->RemoveClient(this);
}
",0
Detect whether the following code contains vulnerabilities.,"static int addrconf_ifid_gre(u8 *eui, struct net_device *dev)
{
	return __ipv6_isatap_ifid(eui, *(__be32 *)dev->dev_addr);
}
",0
Detect whether the following code contains vulnerabilities.," void CastCastView::ButtonPressed(views::Button* sender,
                                  const ui::Event& event) {
   DCHECK(sender == stop_button_);
  StopCast();
 }
",1
Detect whether the following code contains vulnerabilities.,"WebsiteSettingsPopupAndroid::~WebsiteSettingsPopupAndroid() {}
",0
Detect whether the following code contains vulnerabilities.," static inline void sem_getref_and_unlock(struct sem_array *sma)
 {
	ipc_rcu_getref(sma);
	ipc_unlock(&(sma)->sem_perm);
 }
",1
Detect whether the following code contains vulnerabilities.," static sk_sp<SkImage> unPremulSkImageToPremul(SkImage* input) {
  SkImageInfo info = SkImageInfo::Make(input->width(), input->height(),
                                       kN32_SkColorType, kPremul_SkAlphaType);
  RefPtr<Uint8Array> dstPixels = copySkImageData(input, info);
  if (!dstPixels)
     return nullptr;
   return newSkImageFromRaster(
       info, std::move(dstPixels),
      static_cast<size_t>(input->width()) * info.bytesPerPixel());
 }
",1
Detect whether the following code contains vulnerabilities.,"void Segment::PreloadCluster(Cluster* pCluster, ptrdiff_t idx)
{
    assert(pCluster);
    assert(pCluster->m_index < 0);
    assert(idx >= m_clusterCount);
    const long count = m_clusterCount + m_clusterPreloadCount;
    long& size = m_clusterSize;
    assert(size >= count);
    if (count >= size)
    {
        const long n = (size <= 0) ? 2048 : 2*size;
        Cluster** const qq = new Cluster*[n];
        Cluster** q = qq;
        Cluster** p = m_clusters;
        Cluster** const pp = p + count;
        while (p != pp)
            *q++ = *p++;
        delete[] m_clusters;
        m_clusters = qq;
        size = n;
    }
     assert(m_clusters);
 
    Cluster** const p = m_clusters + idx;
 
    Cluster** q = m_clusters + count;
    assert(q >= p);
     assert(q < (m_clusters + size));
 
    while (q > p)
    {
        Cluster** const qq = q - 1;
        assert((*qq)->m_index < 0);
 
        *q = *qq;
        q = qq;
     }
 
    m_clusters[idx] = pCluster;
    ++m_clusterPreloadCount;
 }
",1
Detect whether the following code contains vulnerabilities.,"String HTMLInputElement::accept() const
{
    return fastGetAttribute(acceptAttr);
}
",0
Detect whether the following code contains vulnerabilities.,"blink::ParsedFeaturePolicy CreateFPHeaderMatchesAll(
    blink::mojom::FeaturePolicyFeature feature) {
  blink::ParsedFeaturePolicy result(1);
  result[0].feature = feature;
  result[0].matches_all_origins = true;
  return result;
}
",0
Detect whether the following code contains vulnerabilities.,"TestBrowserWindow::~TestBrowserWindow() {}
",0
Detect whether the following code contains vulnerabilities.,"  StatisticsCB NewStatisticsCB() {
    return base::Bind(&MockStatisticsCB::OnStatistics,
                      base::Unretained(&statistics_cb_));
   }
",0
Detect whether the following code contains vulnerabilities.,"report_error (const char *format, ...)
#else
report_error (format, va_alist)
     const char *format;
     va_dcl
#endif
{
  va_list args;

  error_prolog (1);

  SH_VA_START (args, format);

  vfprintf (stderr, format, args);
  fprintf (stderr, ""\n"");
 
   va_end (args);
   if (exit_immediately_on_error)
    exit_shell (1);
 }
",1
Detect whether the following code contains vulnerabilities.,"static void Sp_search(js_State *J)
{
	js_Regexp *re;
	const char *text;
	Resub m;

	text = checkstring(J, 0);

	if (js_isregexp(J, 1))
		js_copy(J, 1);
	else if (js_isundefined(J, 1))
		js_newregexp(J, """", 0);
	else
		js_newregexp(J, js_tostring(J, 1), 0);
 
 	re = js_toregexp(J, -1);
 
	if (!js_regexec(re->prog, text, &m, 0))
 		js_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));
 	else
 		js_pushnumber(J, -1);
}
",1
Detect whether the following code contains vulnerabilities.,"static int cx24116_sleep(struct dvb_frontend *fe)
{
	struct cx24116_state *state = fe->demodulator_priv;
	struct cx24116_cmd cmd;
	int ret;

	dprintk(""%s()\n"", __func__);

	/* Firmware CMD 36: Power config */
	cmd.args[0x00] = CMD_TUNERSLEEP;
	cmd.args[0x01] = 1;
	cmd.len = 0x02;
	ret = cx24116_cmd_execute(fe, &cmd);
	if (ret != 0)
		return ret;

	/* Power off (Shutdown clocks) */
	cx24116_writereg(state, 0xea, 0xff);
	cx24116_writereg(state, 0xe1, 1);
	cx24116_writereg(state, 0xe0, 1);

	return 0;
}
",0
Detect whether the following code contains vulnerabilities.,"EntryInfoResult::EntryInfoResult() : error(GDATA_FILE_ERROR_FAILED) {
}
",0
Detect whether the following code contains vulnerabilities.,"iakerb_gss_delete_sec_context(OM_uint32 *minor_status,
                               gss_ctx_id_t *context_handle,
                               gss_buffer_t output_token)
 {
    OM_uint32 major_status = GSS_S_COMPLETE;
 
     if (output_token != GSS_C_NO_BUFFER) {
         output_token->length = 0;
         output_token->value = NULL;
     }
 
     *minor_status = 0;
 
    if (*context_handle != GSS_C_NO_CONTEXT) {
        iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*context_handle;
        if (iakerb_ctx->magic == KG_IAKERB_CONTEXT) {
            iakerb_release_context(iakerb_ctx);
            *context_handle = GSS_C_NO_CONTEXT;
        } else {
            assert(iakerb_ctx->magic == KG_CONTEXT);
            major_status = krb5_gss_delete_sec_context(minor_status,
                                                       context_handle,
                                                       output_token);
        }
    }
    return major_status;
 }
",1
Detect whether the following code contains vulnerabilities.,"static int hid_abort_transfers(int sub_api, struct usbi_transfer *itransfer)
{
	struct libusb_transfer *transfer = USBI_TRANSFER_TO_LIBUSB_TRANSFER(itransfer);
	struct windows_transfer_priv *transfer_priv = (struct windows_transfer_priv*)usbi_transfer_get_os_priv(itransfer);
	struct windows_device_handle_priv *handle_priv = _device_handle_priv(transfer->dev_handle);
	HANDLE hid_handle;
	int current_interface;
	CHECK_HID_AVAILABLE;
	current_interface = transfer_priv->interface_number;
	hid_handle = handle_priv->interface_handle[current_interface].api_handle;
	CancelIo(hid_handle);
	return LIBUSB_SUCCESS;
}
",1
Detect whether the following code contains vulnerabilities.,"static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,
						void **list)
{
#if DEBUG
	void *next = *list;
	void *objp;

	while (next) {
		objp = next - obj_offset(cachep);
		next = *(void **)next;
		poison_obj(cachep, objp, POISON_FREE);
	}
#endif
}
",0
Detect whether the following code contains vulnerabilities.,"static void vmx_complete_atomic_exit(struct vcpu_vmx *vmx)
{
	u32 exit_intr_info;

	if (!(vmx->exit_reason == EXIT_REASON_MCE_DURING_VMENTRY
	      || vmx->exit_reason == EXIT_REASON_EXCEPTION_NMI))
		return;

	vmx->exit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO);
	exit_intr_info = vmx->exit_intr_info;

	/* Handle machine checks before interrupts are enabled */
	if (is_machine_check(exit_intr_info))
 		kvm_machine_check();
 
 	/* We need to handle NMIs before interrupts are enabled */
	if ((exit_intr_info & INTR_INFO_INTR_TYPE_MASK) == INTR_TYPE_NMI_INTR &&
	    (exit_intr_info & INTR_INFO_VALID_MASK)) {
 		kvm_before_handle_nmi(&vmx->vcpu);
 		asm(""int $2"");
 		kvm_after_handle_nmi(&vmx->vcpu);
	}
}
",1
Detect whether the following code contains vulnerabilities.,"authentic_get_challenge(struct sc_card *card, unsigned char *rnd, size_t len)
{
	/* 'GET CHALLENGE' returns always 24 bytes */
	unsigned char rbuf[0x18];
	size_t out_len;
	int r;

	LOG_FUNC_CALLED(card->ctx);

	r = iso_ops->get_challenge(card, rbuf, sizeof rbuf);
	LOG_TEST_RET(card->ctx, r, ""GET CHALLENGE cmd failed"");

	if (len < (size_t) r) {
		out_len = len;
	} else {
		out_len = (size_t) r;
	}
	memcpy(rnd, rbuf, out_len);

	LOG_FUNC_RETURN(card->ctx, out_len);
}
",0
Detect whether the following code contains vulnerabilities.,"static int emulate_store_desc_ptr(struct x86_emulate_ctxt *ctxt,
				  void (*get)(struct x86_emulate_ctxt *ctxt,
					      struct desc_ptr *ptr))
{
	struct desc_ptr desc_ptr;

	if (ctxt->mode == X86EMUL_MODE_PROT64)
		ctxt->op_bytes = 8;
	get(ctxt, &desc_ptr);
	if (ctxt->op_bytes == 2) {
		ctxt->op_bytes = 4;
		desc_ptr.address &= 0x00ffffff;
 	}
 	/* Disable writeback. */
 	ctxt->dst.type = OP_NONE;
	return segmented_write(ctxt, ctxt->dst.addr.mem,
			       &desc_ptr, 2 + ctxt->op_bytes);
 }
",1
Detect whether the following code contains vulnerabilities.,"LockContentsView::UserState::UserState(AccountId account_id)
    : account_id(account_id) {}
",1
Detect whether the following code contains vulnerabilities.,"  std::string GetBody(Browser* browser) {
    std::string body;
    EXPECT_TRUE(content::ExecuteScriptAndExtractString(
        browser->tab_strip_model()->GetActiveWebContents(),
        ""window.domAutomationController.send(document.body.textContent);"",
        &body));
    return body;
  }
",0
Detect whether the following code contains vulnerabilities.,"void iov_iter_pipe(struct iov_iter *i, int direction,
			struct pipe_inode_info *pipe,
 			size_t count)
 {
 	BUG_ON(direction != ITER_PIPE);
 	i->type = direction;
 	i->pipe = pipe;
 	i->idx = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);
	i->iov_offset = 0;
	i->count = count;
}
",1
Detect whether the following code contains vulnerabilities.,"int user_update(struct key *key, struct key_preparsed_payload *prep)
{
	struct user_key_payload *upayload, *zap;
	size_t datalen = prep->datalen;
	int ret;

	ret = -EINVAL;
	if (datalen <= 0 || datalen > 32767 || !prep->data)
		goto error;

	/* construct a replacement payload */
	ret = -ENOMEM;
	upayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);
	if (!upayload)
		goto error;

	upayload->datalen = datalen;
	memcpy(upayload->data, prep->data, datalen);

	/* check the quota and attach the new data */
	zap = upayload;

	ret = key_payload_reserve(key, datalen);
 
 	if (ret == 0) {
 		/* attach the new data, displacing the old */
		zap = key->payload.data[0];
 		rcu_assign_keypointer(key, upayload);
 		key->expiry = 0;
 	}

	if (zap)
		kfree_rcu(zap, rcu);

error:
	return ret;
}
",1
Detect whether the following code contains vulnerabilities.,"bool FlagsState::IsRestartNeededToCommitChanges() {
  return needs_restart_;
}
",0
Detect whether the following code contains vulnerabilities.,"bool GDataDirectory::FromProto(const GDataDirectoryProto& proto) {
  DCHECK(proto.gdata_entry().file_info().is_directory());
   DCHECK(!proto.gdata_entry().has_file_specific_info());
 
   for (int i = 0; i < proto.child_files_size(); ++i) {
    scoped_ptr<GDataFile> file(new GDataFile(NULL, directory_service_));
     if (!file->FromProto(proto.child_files(i))) {
       RemoveChildren();
       return false;
     }
     AddEntry(file.release());
   }
   for (int i = 0; i < proto.child_directories_size(); ++i) {
    scoped_ptr<GDataDirectory> dir(new GDataDirectory(NULL,
                                                      directory_service_));
     if (!dir->FromProto(proto.child_directories(i))) {
       RemoveChildren();
       return false;
    }
    AddEntry(dir.release());
  }

  if (!GDataEntry::FromProto(proto.gdata_entry()))
    return false;

  return true;
}
",1
Detect whether the following code contains vulnerabilities.,"void Editor::RevealSelectionAfterEditingOperation(
    const ScrollAlignment& alignment,
    RevealExtentOption reveal_extent_option) {
  if (prevent_reveal_selection_)
    return;
  if (!GetFrame().Selection().IsAvailable())
    return;
   GetFrame().Selection().RevealSelection(alignment, reveal_extent_option);
 }
",0
Detect whether the following code contains vulnerabilities.,"vhost_scsi_send_evt(struct vhost_scsi *vs,
		   struct vhost_scsi_tpg *tpg,
		   struct se_lun *lun,
		   u32 event,
		   u32 reason)
{
	struct vhost_scsi_evt *evt;

	evt = vhost_scsi_allocate_evt(vs, event, reason);
	if (!evt)
		return;

	if (tpg && lun) {
		/* TODO: share lun setup code with virtio-scsi.ko */
		/*
		 * Note: evt->event is zeroed when we allocate it and
 		 * lun[4-7] need to be zero according to virtio-scsi spec.
 		 */
 		evt->event.lun[0] = 0x01;
		evt->event.lun[1] = tpg->tport_tpgt & 0xFF;
 		if (lun->unpacked_lun >= 256)
 			evt->event.lun[2] = lun->unpacked_lun >> 8 | 0x40 ;
 		evt->event.lun[3] = lun->unpacked_lun & 0xFF;
	}

	llist_add(&evt->list, &vs->vs_event_list);
	vhost_work_queue(&vs->dev, &vs->vs_event_work);
}
",1
Detect whether the following code contains vulnerabilities.,"PrintPreviewHandler::PrintPreviewHandler()
    : print_backend_(printing::PrintBackend::CreateInstance(NULL)),
      regenerate_preview_request_count_(0),
      manage_printers_dialog_request_count_(0),
      manage_cloud_printers_dialog_request_count_(0),
      reported_failed_preview_(false),
      has_logged_printers_count_(false) {
  ReportUserActionHistogram(PREVIEW_STARTED);
}
",0
Detect whether the following code contains vulnerabilities.,"void ath_tx_aggr_sleep(struct ieee80211_sta *sta, struct ath_softc *sc,
		       struct ath_node *an)
{
	struct ath_atx_tid *tid;
	struct ath_atx_ac *ac;
	struct ath_txq *txq;
	bool buffered;
	int tidno;

 	for (tidno = 0, tid = &an->tid[tidno];
 	     tidno < IEEE80211_NUM_TIDS; tidno++, tid++) {
 
		if (!tid->sched)
			continue;
 		ac = tid->ac;
 		txq = ac->txq;
 
 		ath_txq_lock(sc, txq);
 
 		buffered = ath_tid_has_buffered(tid);
 
 		tid->sched = false;
		list_del(&tid->list);

		if (ac->sched) {
			ac->sched = false;
			list_del(&ac->list);
		}

		ath_txq_unlock(sc, txq);

		ieee80211_sta_set_buffered(sta, tidno, buffered);
	}
}
",1
Detect whether the following code contains vulnerabilities.,"xmlFatalErrMsg(xmlParserCtxtPtr ctxt, xmlParserErrors error,
 const char *msg)
{
 if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
 (ctxt->instate == XML_PARSER_EOF))
 return;
 if (ctxt != NULL)
	ctxt->errNo = error;
    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
                    XML_ERR_FATAL, NULL, 0, NULL, NULL, NULL, 0, 0, ""%s"", msg);
 if (ctxt != NULL) {
	ctxt->wellFormed = 0;
 if (ctxt->recovery == 0)
	    ctxt->disableSAX = 1;
 }
}
",0
Detect whether the following code contains vulnerabilities.,"static uint32 SelectSamplesPerPacket(AudioParameters params) {
  int samples = kMinSamplesPerHardwarePacket;
  while (samples <= kMaxSamplesPerHardwarePacket &&
         samples * base::Time::kMillisecondsPerSecond <
         params.sample_rate * kMillisecondsPerHardwarePacket) {
    samples *= 2;
  }
  return samples;
}
",0
Detect whether the following code contains vulnerabilities.,"static void vapic_exit(struct kvm_vcpu *vcpu)
{
	struct kvm_lapic *apic = vcpu->arch.apic;
	int idx;
	if (!apic || !apic->vapic_addr)
		return;
	idx = srcu_read_lock(&vcpu->kvm->srcu);
	kvm_release_page_dirty(apic->vapic_page);
	mark_page_dirty(vcpu->kvm, apic->vapic_addr >> PAGE_SHIFT);
	srcu_read_unlock(&vcpu->kvm->srcu, idx);
}
",1
Detect whether the following code contains vulnerabilities.,"std::unique_ptr<service_manager::Service> CreateDataDecoderService() {
  content::UtilityThread::Get()->EnsureBlinkInitialized();
  return data_decoder::DataDecoderService::Create();
}
",0
Detect whether the following code contains vulnerabilities.,"void V8TestObject::ActivityLoggingAccessForIsolatedWorldsPerWorldBindingsLongAttributeAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), ""Blink_TestObject_activityLoggingAccessForIsolatedWorldsPerWorldBindingsLongAttribute_Getter"");

  ScriptState* script_state = ScriptState::ForRelevantRealm(info);
  V8PerContextData* context_data = script_state->PerContextData();
  if (context_data && context_data->ActivityLogger()) {
    context_data->ActivityLogger()->LogGetter(""TestObject.activityLoggingAccessForIsolatedWorldsPerWorldBindingsLongAttribute"");
  }

  test_object_v8_internal::ActivityLoggingAccessForIsolatedWorldsPerWorldBindingsLongAttributeAttributeGetter(info);
}
",0
Detect whether the following code contains vulnerabilities.,"ZEND_API void ZEND_FASTCALL _zend_hash_init(HashTable *ht, uint32_t nSize, dtor_func_t pDestructor, zend_bool persistent ZEND_FILE_LINE_DC)
{
 	GC_REFCOUNT(ht) = 1;
 	GC_TYPE_INFO(ht) = IS_ARRAY;
 	ht->u.flags = (persistent ? HASH_FLAG_PERSISTENT : 0) | HASH_FLAG_APPLY_PROTECTION | HASH_FLAG_STATIC_KEYS;
	ht->nTableSize = zend_hash_check_size(nSize);
 	ht->nTableMask = HT_MIN_MASK;
 	HT_SET_DATA_ADDR(ht, &uninitialized_bucket);
 	ht->nNumUsed = 0;
 	ht->nNumOfElements = 0;
 	ht->nInternalPointer = HT_INVALID_IDX;
 	ht->nNextFreeElement = 0;
 	ht->pDestructor = pDestructor;
 }
",1
Detect whether the following code contains vulnerabilities.,"void CCLayerTreeHostTest::endTest()
 {
     if (!isMainThread())
        CCMainThread::postTask(createMainThreadTask(this, &CCLayerTreeHostTest::endTest));
     else {
        if (m_beginning)
            m_endWhenBeginReturns = true;
        else
            onEndTest(static_cast<void*>(this));
    }
}
",1
Detect whether the following code contains vulnerabilities.," static void sgi_timer_get(struct k_itimer *timr, struct itimerspec *cur_setting)
 {

	if (timr->it.mmtimer.clock == TIMER_OFF) {
		cur_setting->it_interval.tv_nsec = 0;
		cur_setting->it_interval.tv_sec = 0;
		cur_setting->it_value.tv_nsec = 0;
		cur_setting->it_value.tv_sec =0;
 		return;
 	}
 
	ns_to_timespec(cur_setting->it_interval, timr->it.mmtimer.incr * sgi_clock_period);
	ns_to_timespec(cur_setting->it_value, (timr->it.mmtimer.expires - rtc_time())* sgi_clock_period);
	return;
 }
",1
Detect whether the following code contains vulnerabilities.,"bool WebRuntimeFeatures::isPrefixedEncryptedMediaEnabled()
{
    return RuntimeEnabledFeatures::prefixedEncryptedMediaEnabled();
}
",0
Detect whether the following code contains vulnerabilities.," static void array_cleanup( char* arr[] , int arr_size)
 {
 	int i=0;
	for( i=0; i< arr_size; i++ ){ 
 		if( arr[i*2] ){
 			efree( arr[i*2]);
 		}
	}
	efree(arr);
}
",1
Detect whether the following code contains vulnerabilities.,"static MagickOffsetType TIFFSeekCustomStream(const MagickOffsetType offset,
  const int whence,void *user_data)
{
  PhotoshopProfile
    *profile;

  profile=(PhotoshopProfile *) user_data;
  switch (whence)
  {
    case SEEK_SET:
    default:
    {
      if (offset < 0)
        return(-1);
      profile->offset=offset;
      break;
     }
     case SEEK_CUR:
     {
       if ((profile->offset+offset) < 0)
         return(-1);
       profile->offset+=offset;
      break;
    }
    case SEEK_END:
    {
      if (((MagickOffsetType) profile->length+offset) < 0)
        return(-1);
      profile->offset=profile->length+offset;
      break;
    }
  }

  return(profile->offset);
}
",1
Detect whether the following code contains vulnerabilities.,"FrameView::FrameView(LocalFrame* frame)
    : m_frame(frame)
    , m_canHaveScrollbars(true)
    , m_slowRepaintObjectCount(0)
    , m_hasPendingLayout(false)
    , m_layoutSubtreeRoot(0)
    , m_inSynchronousPostLayout(false)
    , m_postLayoutTasksTimer(this, &FrameView::postLayoutTimerFired)
    , m_updateWidgetsTimer(this, &FrameView::updateWidgetsTimerFired)
    , m_isTransparent(false)
    , m_baseBackgroundColor(Color::white)
    , m_mediaType(""screen"")
    , m_overflowStatusDirty(true)
    , m_viewportRenderer(0)
    , m_wasScrolledByUser(false)
    , m_inProgrammaticScroll(false)
    , m_safeToPropagateScrollToParent(true)
    , m_isTrackingPaintInvalidations(false)
    , m_scrollCorner(nullptr)
    , m_hasSoftwareFilters(false)
    , m_visibleContentScaleFactor(1)
     , m_inputEventsScaleFactorForEmulation(1)
     , m_layoutSizeFixedToFrameSize(true)
     , m_didScrollTimer(this, &FrameView::didScrollTimerFired)
 {
     ASSERT(m_frame);
     init();

    if (!m_frame->isMainFrame())
        return;

    ScrollableArea::setVerticalScrollElasticity(ScrollElasticityAllowed);
    ScrollableArea::setHorizontalScrollElasticity(ScrollElasticityAllowed);
}
",1
Detect whether the following code contains vulnerabilities.," php_http_url_t *php_http_url_parse(const char *str, size_t len, unsigned flags TSRMLS_DC)
 {
	size_t maxlen = 3 * len;
 	struct parse_state *state = ecalloc(1, sizeof(*state) + maxlen);
 
 	state->end = str + len;
	state->ptr = str;
	state->flags = flags;
	state->maxlen = maxlen;
	TSRMLS_SET_CTX(state->ts);

	if (!parse_scheme(state)) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Failed to parse URL scheme: '%s'"", state->ptr);
		efree(state);
		return NULL;
	}

	if (!parse_hier(state)) {
		efree(state);
		return NULL;
	}

	if (!parse_query(state)) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Failed to parse URL query: '%s'"", state->ptr);
		efree(state);
		return NULL;
	}

	if (!parse_fragment(state)) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Failed to parse URL fragment: '%s'"", state->ptr);
		efree(state);
		return NULL;
	}

	return (php_http_url_t *) state;
}
",1
Detect whether the following code contains vulnerabilities.,"static inline long decode_twos_comp(ulong c, int prec)
 {
 	long result;
 	assert(prec >= 2);
	jas_eprintf(""warning: support for signed data is untested\n"");
	result = (c & ((1 << (prec - 1)) - 1)) - (c & (1 << (prec - 1)));
 	return result;
 }
",1
Detect whether the following code contains vulnerabilities.,"status_t Parcel::readPointer(uintptr_t *pArg) const
{
 status_t ret;
 binder_uintptr_t ptr;
    ret = readAligned(&ptr);
 if (!ret)
 *pArg = ptr;
 return ret;
}
",0
Detect whether the following code contains vulnerabilities.,"l2tp_proto_ver_print(netdissect_options *ndo, const uint16_t *dat)
 {
 	ND_PRINT((ndo, ""%u.%u"", (EXTRACT_16BITS(dat) >> 8),
 	    (EXTRACT_16BITS(dat) & 0xff)));
 }
",1
Detect whether the following code contains vulnerabilities.,"process(struct magic_set *ms, const char *inname, int wid)
{
	const char *type;
	int std_in = strcmp(inname, ""-"") == 0;

	if (wid > 0 && !bflag) {
		(void)printf(""%s"", std_in ? ""/dev/stdin"" : inname);
		if (nulsep)
			(void)putc('\0', stdout);
		(void)printf(""%s"", separator);
		(void)printf(""%*s "",
		    (int) (nopad ? 0 : (wid - file_mbswidth(inname))), """");
	}

	type = magic_file(ms, std_in ? NULL : inname);
	if (type == NULL) {
		(void)printf(""ERROR: %s\n"", magic_error(ms));
		return 1;
	} else {
		(void)printf(""%s\n"", type);
		return 0;
	}
}
",0
Detect whether the following code contains vulnerabilities.,"static struct block_device *ext3_blkdev_get(dev_t dev, struct super_block *sb)
{
	struct block_device *bdev;
	char b[BDEVNAME_SIZE];

	bdev = blkdev_get_by_dev(dev, FMODE_READ|FMODE_WRITE|FMODE_EXCL, sb);
	if (IS_ERR(bdev))
		goto fail;
 	return bdev;
 
 fail:
	ext3_msg(sb, ""error: failed to open journal device %s: %ld"",
 		__bdevname(dev, b), PTR_ERR(bdev));
 
 	return NULL;
}
",1
Detect whether the following code contains vulnerabilities.,"void HTMLSelectElement::accessKeySetSelectedIndex(int index)
{    
    if (!focused())
        accessKeyAction(false);
    
    const Vector<HTMLElement*>& items = listItems();
    int listIndex = optionToListIndex(index);
    if (listIndex >= 0) {
        HTMLElement* element = items[listIndex];
        if (element->hasTagName(optionTag)) {
            if (toHTMLOptionElement(element)->selected())
                toHTMLOptionElement(element)->setSelectedState(false);
            else
                selectOption(index, DispatchChangeEvent | UserDriven);
        }
    }

    if (usesMenuList())
        dispatchChangeEventForMenuList();
    else
        listBoxOnChange();

    scrollToSelection();
}
",0
Detect whether the following code contains vulnerabilities.,"static char *rfc2047_decode_word(const char *s, size_t len, enum ContentEncoding enc)
{
  const char *it = s;
  const char *end = s + len;

  if (enc == ENCQUOTEDPRINTABLE)
  {
    struct Buffer buf = { 0 };
    for (; it < end; ++it)
    {
      if (*it == '_')
      {
        mutt_buffer_addch(&buf, ' ');
      }
      else if ((*it == '=') && (!(it[1] & ~127) && hexval(it[1]) != -1) &&
               (!(it[2] & ~127) && hexval(it[2]) != -1))
      {
        mutt_buffer_addch(&buf, (hexval(it[1]) << 4) | hexval(it[2]));
        it += 2;
      }
      else
      {
        mutt_buffer_addch(&buf, *it);
      }
    }
    mutt_buffer_addch(&buf, '\0');
    return buf.data;
   }
   else if (enc == ENCBASE64)
   {
    char *out = mutt_mem_malloc(3 * len / 4 + 1);
    int dlen = mutt_b64_decode(out, it);
     if (dlen == -1)
     {
       FREE(&out);
      return NULL;
    }
    out[dlen] = '\0';
    return out;
  }

  assert(0); /* The enc parameter has an invalid value */
  return NULL;
}
",1
Detect whether the following code contains vulnerabilities.,"GpuProcessHost::GpuProcessHost(int host_id, GpuProcessKind kind)
    : host_id_(host_id),
      valid_(true),
      in_process_(false),
      software_rendering_(false),
      kind_(kind),
      process_launched_(false) {
  if (CommandLine::ForCurrentProcess()->HasSwitch(switches::kSingleProcess) ||
      CommandLine::ForCurrentProcess()->HasSwitch(switches::kInProcessGPU))
    in_process_ = true;

  DCHECK(!in_process_ || g_gpu_process_hosts[kind] == NULL);

  g_gpu_process_hosts[kind] = this;

  BrowserThread::PostTask(
      BrowserThread::UI,
      FROM_HERE,
      base::Bind(base::IgnoreResult(&GpuProcessHostUIShim::Create), host_id));

  process_.reset(new BrowserChildProcessHostImpl(PROCESS_TYPE_GPU, this));
}
",0
Detect whether the following code contains vulnerabilities.,"ssize_t rawexpread(off_t a, char *buf, size_t len, CLIENT *client) {
	int fhandle;
	off_t foffset;
	size_t maxbytes;

	if(get_filepos(client->export, a, &fhandle, &foffset, &maxbytes))
		return -1;
	if(maxbytes && len > maxbytes)
		len = maxbytes;

	DEBUG(""(READ from fd %d offset %llu len %u), "", fhandle, (long long unsigned int)foffset, (unsigned int)len);

	myseek(fhandle, foffset);
	return read(fhandle, buf, len);
}
",0
Detect whether the following code contains vulnerabilities.," std::string MasterPreferences::GetCompressedVariationsSeed() const {
  return ExtractPrefString(prefs::kVariationsCompressedSeed);
 }
",1
Detect whether the following code contains vulnerabilities.,"void FrameSelection::MoveRangeSelectionExtent(const IntPoint& contents_point) {
  if (ComputeVisibleSelectionInDOMTree().IsNone())
    return;

   SetSelection(
       SelectionInDOMTree::Builder(
           GetGranularityStrategy()->UpdateExtent(contents_point, frame_))
          .SetIsHandleVisible(true)
           .Build(),
       SetSelectionData::Builder()
           .SetShouldCloseTyping(true)
           .SetShouldClearTypingStyle(true)
           .SetDoNotClearStrategy(true)
           .SetSetSelectionBy(SetSelectionBy::kUser)
           .Build());
 }
",1
Detect whether the following code contains vulnerabilities.,"ia64_patch_vtop (unsigned long start, unsigned long end)
{
	s32 *offp = (s32 *) start;
	u64 ip;

	while (offp < (s32 *) end) {
		ip = (u64) offp + *offp;

		/* replace virtual address with corresponding physical address: */
		ia64_patch_imm64(ip, ia64_tpa(get_imm64(ip)));
		ia64_fc((void *) ip);
		++offp;
	}
	ia64_sync_i();
 	ia64_srlz_i();
 }
",0
Detect whether the following code contains vulnerabilities.,"static void checkListProperties(sqlite3 *db){
  sqlite3 *p;
  for(p=sqlite3BlockedList; p; p=p->pNextBlocked){
    int seen = 0;
    sqlite3 *p2;

    /* Verify property (1) */
    assert( p->pUnlockConnection || p->pBlockingConnection );

    /* Verify property (2) */
    for(p2=sqlite3BlockedList; p2!=p; p2=p2->pNextBlocked){
      if( p2->xUnlockNotify==p->xUnlockNotify ) seen = 1;
      assert( p2->xUnlockNotify==p->xUnlockNotify || !seen );
      assert( db==0 || p->pUnlockConnection!=db );
      assert( db==0 || p->pBlockingConnection!=db );
    }
  }
}
",0
Detect whether the following code contains vulnerabilities.,"void qeth_clear_thread_start_bit(struct qeth_card *card, unsigned long thread)
{
	unsigned long flags;

	spin_lock_irqsave(&card->thread_mask_lock, flags);
	card->thread_start_mask &= ~thread;
	spin_unlock_irqrestore(&card->thread_mask_lock, flags);
	wake_up(&card->wait_q);
}
",0
Detect whether the following code contains vulnerabilities.,"static void sample_hbp_handler(struct perf_event *bp, int nmi,
 			       struct perf_sample_data *data,
 			       struct pt_regs *regs)
 {
	printk(KERN_INFO ""%s value is changed\n"", ksym_name);
	dump_stack();
	printk(KERN_INFO ""Dump stack from sample_hbp_handler\n"");
}
",1
Detect whether the following code contains vulnerabilities.,"INST_HANDLER (lac) {	// LAC Z, Rd
	int d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);

	__generic_ld_st (op, ""ram"", 'z', 1, 0, 0, 0);	// 0: Read (RAMPZ:Z)
	ESIL_A (""r%d,0xff,^,&,"", d);			// 0: (Z) & ~Rd
	ESIL_A (""DUP,r%d,=,"", d);			// Rd = [0]
	__generic_ld_st (op, ""ram"", 'z', 1, 0, 0, 1);	// Store in RAM
}
",0
Detect whether the following code contains vulnerabilities.," static inline void VectorClamp3(DDSVector3 *value)
 {
  value->x = MinF(1.0f,MaxF(0.0f,value->x));
  value->y = MinF(1.0f,MaxF(0.0f,value->y));
  value->z = MinF(1.0f,MaxF(0.0f,value->z));
 }
",1
Detect whether the following code contains vulnerabilities.,"l2tp_accm_print(netdissect_options *ndo, const u_char *dat)
 {
 	const uint16_t *ptr = (const uint16_t *)dat;
 	uint16_t val_h, val_l;
 
 	ptr++;		/* skip ""Reserved"" */
 
	val_h = EXTRACT_16BITS(ptr); ptr++;
	val_l = EXTRACT_16BITS(ptr); ptr++;
 	ND_PRINT((ndo, ""send=%08x "", (val_h<<16) + val_l));
 
 	val_h = EXTRACT_16BITS(ptr); ptr++;
 	val_l = EXTRACT_16BITS(ptr); ptr++;
 	ND_PRINT((ndo, ""recv=%08x "", (val_h<<16) + val_l));
}
",1
Detect whether the following code contains vulnerabilities.,"void smp_send_pair_fail(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {
  p_cb->status = p_data->status;
  p_cb->failure = p_data->status;

  SMP_TRACE_DEBUG(""%s: status=%d failure=%d "", __func__, p_cb->status,
                  p_cb->failure);

 if (p_cb->status <= SMP_MAX_FAIL_RSN_PER_SPEC &&
      p_cb->status != SMP_SUCCESS) {
    smp_send_cmd(SMP_OPCODE_PAIRING_FAILED, p_cb);
    p_cb->wait_for_authorization_complete = true;
 }
}
",0
Detect whether the following code contains vulnerabilities.,"  UpdateTemporaryGlobalQuotaTask(
      QuotaManager* manager,
      int64 new_quota,
      QuotaCallback* callback)
      : DatabaseTaskBase(manager),
        new_quota_(new_quota),
        callback_(callback) {
    DCHECK_GE(new_quota, 0);
  }
",0
Detect whether the following code contains vulnerabilities.,"static int php_stream_temp_seek(php_stream *stream, off_t offset, int whence, off_t *newoffs TSRMLS_DC)
{
	php_stream_temp_data *ts = (php_stream_temp_data*)stream->abstract;
	int ret;

	assert(ts != NULL);

	if (!ts->innerstream) {
		*newoffs = -1;
		return -1;
	}
        ret = php_stream_seek(ts->innerstream, offset, whence);
        *newoffs = php_stream_tell(ts->innerstream);
        stream->eof = ts->innerstream->eof;
        return ret;
 }
",1
Detect whether the following code contains vulnerabilities.,"void WebGL2RenderingContextBase::texImage2D(GLenum target,
                                            GLint level,
                                            GLint internalformat,
                                            GLsizei width,
                                            GLsizei height,
                                            GLint border,
                                            GLenum format,
                                            GLenum type,
                                            GLintptr offset) {
  if (isContextLost())
    return;
  if (!ValidateTexture2DBinding(""texImage2D"", target))
    return;
  if (!bound_pixel_unpack_buffer_) {
    SynthesizeGLError(GL_INVALID_OPERATION, ""texImage2D"",
                       ""no bound PIXEL_UNPACK_BUFFER"");
     return;
   }
   if (!ValidateTexFunc(""texImage2D"", kTexImage, kSourceUnpackBuffer, target,
                        level, internalformat, width, height, 1, border, format,
                        type, 0, 0, 0))
    return;
  if (!ValidateValueFitNonNegInt32(""texImage2D"", ""offset"", offset))
    return;

  ContextGL()->TexImage2D(
      target, level, ConvertTexInternalFormat(internalformat, type), width,
      height, border, format, type, reinterpret_cast<const void*>(offset));
}
",1
Detect whether the following code contains vulnerabilities.,"void bdt_enable(void)
{
    bdt_log(""ENABLE BT"");
 if (bt_enabled) {

         bdt_log(""Bluetooth is already enabled"");
         return;
     }
    status = sBtInterface->enable();
 
     check_return_status(status);
 }
",1
Detect whether the following code contains vulnerabilities.,"static inline bool shouldSetStrutOnBlock(const LayoutBlockFlow& block, const RootInlineBox& lineBox, LayoutUnit lineLogicalOffset, int lineIndex, LayoutUnit remainingLogicalHeight)
{
    bool wantsStrutOnBlock = false;
    if (!block.style()->hasAutoOrphans() && block.style()->orphans() >= lineIndex) {
        wantsStrutOnBlock = true;
    } else if (lineBox == block.firstRootBox() && lineLogicalOffset == block.borderAndPaddingBefore()) {
        LayoutUnit lineHeight = lineBox.lineBottomWithLeading() - lineBox.lineTopWithLeading();
        LayoutUnit totalLogicalHeight = lineHeight + std::max<LayoutUnit>(0, lineLogicalOffset);
        LayoutUnit pageLogicalHeightAtNewOffset = block.pageLogicalHeightForOffset(lineLogicalOffset + remainingLogicalHeight);
         if (totalLogicalHeight < pageLogicalHeightAtNewOffset)
             wantsStrutOnBlock = true;
     }
    if (!wantsStrutOnBlock || block.isOutOfFlowPositioned())
        return false;
    LayoutBlock* containingBlock = block.containingBlock();
    return containingBlock && containingBlock->isLayoutBlockFlow();
 }
",1
Detect whether the following code contains vulnerabilities.," SPL_METHOD(FilesystemIterator, current)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}

	if (SPL_FILE_DIR_CURRENT(intern, SPL_FILE_DIR_CURRENT_AS_PATHNAME)) {
		spl_filesystem_object_get_file_name(intern TSRMLS_CC);
		RETURN_STRINGL(intern->file_name, intern->file_name_len, 1);
	} else if (SPL_FILE_DIR_CURRENT(intern, SPL_FILE_DIR_CURRENT_AS_FILEINFO)) {
		spl_filesystem_object_get_file_name(intern TSRMLS_CC);
		spl_filesystem_object_create_type(0, intern, SPL_FS_INFO, NULL, return_value TSRMLS_CC);
	} else {
		RETURN_ZVAL(getThis(), 1, 0);
		/*RETURN_STRING(intern->u.dir.entry.d_name, 1);*/
	}
}
",1
Detect whether the following code contains vulnerabilities.,"static void sock_spd_release(struct splice_pipe_desc *spd, unsigned int i)
{
	put_page(spd->pages[i]);
}
",0
Detect whether the following code contains vulnerabilities.,"void setSerifFontFamilyWrapper(WebSettings* settings,
                               const string16& font,
                               UScriptCode script) {
  settings->setSerifFontFamily(font, script);
}
",0
Detect whether the following code contains vulnerabilities.,"static bool IsValidElementName(Document* document, const String& name) {
  bool is_valid_dom_name = Document::IsValidName(name);
  bool is_valid_html_name = IsValidElementNamePerHTMLParser(name);
  if (UNLIKELY(is_valid_html_name != is_valid_dom_name)) {
    UseCounter::Count(document,
                      is_valid_dom_name
                          ? WebFeature::kElementNameDOMValidHTMLParserInvalid
                          : WebFeature::kElementNameDOMInvalidHTMLParserValid);
  }
  return is_valid_dom_name;
}
",0
Detect whether the following code contains vulnerabilities.,"void DevToolsWindow::Inspect(scoped_refptr<content::DevToolsAgentHost> host) {
  DevToolsWindow::OpenDevToolsWindow(host, profile_);
}
",0
Detect whether the following code contains vulnerabilities.,"void WebDevToolsAgentImpl::didNavigate()
{
    ClientMessageLoopAdapter::didNavigate();
}
",0
Detect whether the following code contains vulnerabilities.,"void RenderFrameImpl::OnCopyToFindPboard() {
  if (frame_->HasSelection()) {
    if (!clipboard_host_) {
      auto* platform = RenderThreadImpl::current_blink_platform_impl();
      platform->GetConnector()->BindInterface(platform->GetBrowserServiceName(),
                                              &clipboard_host_);
    }
    base::string16 selection = frame_->SelectionAsText().Utf16();
    clipboard_host_->WriteStringToFindPboard(selection);
  }
}
",0
Detect whether the following code contains vulnerabilities.,"    StringCapturingFunction(ScriptState* scriptState, String* value)
        : ScriptFunction(scriptState)
        , m_value(value)
    {
    }
",0
Detect whether the following code contains vulnerabilities.,"ContentSettingsClient* FrameFetchContext::GetContentSettingsClient() const {
  if (IsDetached())
    return nullptr;
  return GetFrame()->GetContentSettingsClient();
}
",0
Detect whether the following code contains vulnerabilities.," static uint32_t readU32(const uint8_t* data, size_t offset) {
    return data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3];
 }
",1
Detect whether the following code contains vulnerabilities.," void DataReductionProxySettings::InitDataReductionProxySettings(
     PrefService* prefs,
    DataReductionProxyIOData* io_data,
    std::unique_ptr<DataReductionProxyService> data_reduction_proxy_service) {
  DCHECK(thread_checker_.CalledOnValidThread());
  DCHECK(prefs);
  DCHECK(io_data);
  DCHECK(io_data->config());
  DCHECK(data_reduction_proxy_service);
  prefs_ = prefs;
   config_ = io_data->config();
   data_reduction_proxy_service_ = std::move(data_reduction_proxy_service);
   data_reduction_proxy_service_->AddObserver(this);
  InitPrefMembers();
   RecordDataReductionInit();
 
 #if defined(OS_ANDROID)
  if (spdy_proxy_auth_enabled_.GetValue()) {
     data_reduction_proxy_service_->compression_stats()
         ->SetDataUsageReportingEnabled(true);
   }
#endif  // defined(OS_ANDROID)

  for (auto& observer : observers_)
    observer.OnSettingsInitialized();
}
",1
Detect whether the following code contains vulnerabilities.,"bool CheckBasicProxyAuth(const AuthChallengeInfo* auth_challenge) {
  if (!auth_challenge)
    return false;
  EXPECT_TRUE(auth_challenge->is_proxy);
  EXPECT_EQ(""myproxy:70"", auth_challenge->challenger.ToString());
  EXPECT_EQ(""MyRealm1"", auth_challenge->realm);
  EXPECT_EQ(""basic"", auth_challenge->scheme);
  return true;
}
",0
Detect whether the following code contains vulnerabilities.,"  bool StopInputMethodProcess() {
     if (!IBusConnectionsAreAlive()) {
       LOG(ERROR) << ""StopInputMethodProcess: IBus connection is not alive"";
       return false;
    }

    ibus_bus_exit_async(ibus_,
                        FALSE  /* do not restart */,
                        -1  /* timeout */,
                        NULL  /* cancellable */,
                        NULL  /* callback */,
                        NULL  /* user_data */);

    if (ibus_config_) {
      g_object_unref(ibus_config_);
      ibus_config_ = NULL;
    }
     return true;
   }
",1
Detect whether the following code contains vulnerabilities.,"void kvm_register_target_sys_reg_table(unsigned int target,
				       struct kvm_sys_reg_target_table *table)
{
	target_tables[target] = table;
}
",0
Detect whether the following code contains vulnerabilities.," v8::Local<v8::Value> V8Debugger::functionLocation(v8::Local<v8::Context> context, v8::Local<v8::Function> function)
{
    int scriptId = function->ScriptId();
    if (scriptId == v8::UnboundScript::kNoScriptId)
        return v8::Null(m_isolate);
    int lineNumber = function->GetScriptLineNumber();
    int columnNumber = function->GetScriptColumnNumber();
     if (lineNumber == v8::Function::kLineOffsetNotFound || columnNumber == v8::Function::kLineOffsetNotFound)
         return v8::Null(m_isolate);
     v8::Local<v8::Object> location = v8::Object::New(m_isolate);
     if (!location->Set(context, toV8StringInternalized(m_isolate, ""scriptId""), toV8String(m_isolate, String16::fromInteger(scriptId))).FromMaybe(false))
         return v8::Null(m_isolate);
     if (!location->Set(context, toV8StringInternalized(m_isolate, ""lineNumber""), v8::Integer::New(m_isolate, lineNumber)).FromMaybe(false))
        return v8::Null(m_isolate);
    if (!location->Set(context, toV8StringInternalized(m_isolate, ""columnNumber""), v8::Integer::New(m_isolate, columnNumber)).FromMaybe(false))
        return v8::Null(m_isolate);
    if (!markAsInternal(context, location, V8InternalValueType::kLocation))
        return v8::Null(m_isolate);
    return location;
}
",1
Detect whether the following code contains vulnerabilities.,"void RenderFrameImpl::DidChangeCpuTiming(base::TimeDelta time) {
  for (auto& observer : observers_)
    observer.DidChangeCpuTiming(time);
}
",0
Detect whether the following code contains vulnerabilities.,"dcputs(const char *s)
{
	int len=strlen(s);
	dcchkstr(len);
	strcat(dcptr,s);
	dcptr+=len;
	strsize+=len;
}
",0
Detect whether the following code contains vulnerabilities.,"     void makeCurrent()
     {
#if PLATFORM(QT)
        m_detachedContext = QOpenGLContext::currentContext();
        if (m_detachedContext)
            m_detachedSurface = m_detachedContext->surface();
        if (m_surface && m_glContext)
            m_glContext->makeCurrent(m_surface.get());
#elif PLATFORM(EFL)
         m_detachedContext = glXGetCurrentContext();
         m_detachedSurface = glXGetCurrentDrawable();
         if (m_surface && m_glContext)
             glXMakeCurrent(m_display, m_surface, m_glContext);
#endif
     }
",1
Detect whether the following code contains vulnerabilities.," bool PrintPreviewMessageHandler::OnMessageReceived(
     const IPC::Message& message) {
   bool handled = true;
  IPC_BEGIN_MESSAGE_MAP(PrintPreviewMessageHandler, message)
    IPC_MESSAGE_HANDLER(PrintHostMsg_RequestPrintPreview,
                        OnRequestPrintPreview)
    IPC_MESSAGE_HANDLER(PrintHostMsg_DidGetPreviewPageCount,
                        OnDidGetPreviewPageCount)
    IPC_MESSAGE_HANDLER(PrintHostMsg_DidPreviewPage,
                        OnDidPreviewPage)
    IPC_MESSAGE_HANDLER(PrintHostMsg_MetafileReadyForPrinting,
                        OnMetafileReadyForPrinting)
    IPC_MESSAGE_HANDLER(PrintHostMsg_PrintPreviewFailed,
                        OnPrintPreviewFailed)
    IPC_MESSAGE_HANDLER(PrintHostMsg_DidGetDefaultPageLayout,
                        OnDidGetDefaultPageLayout)
    IPC_MESSAGE_HANDLER(PrintHostMsg_PrintPreviewCancelled,
                         OnPrintPreviewCancelled)
     IPC_MESSAGE_HANDLER(PrintHostMsg_PrintPreviewInvalidPrinterSettings,
                         OnInvalidPrinterSettings)
     IPC_MESSAGE_UNHANDLED(handled = false)
   IPC_END_MESSAGE_MAP()
   return handled;
}
",1
Detect whether the following code contains vulnerabilities.,"void WebSettingsImpl::setExperimentalNotificationsEnabled(bool enabled)
{
    m_settings->setExperimentalNotificationsEnabled(enabled);
}
",1
Detect whether the following code contains vulnerabilities.,"void svc_rdma_xdr_encode_reply_array(struct rpcrdma_write_array *ary,
				 int chunks)
{
	ary->wc_discrim = xdr_one;
	ary->wc_nchunks = cpu_to_be32(chunks);
}
",1
Detect whether the following code contains vulnerabilities.,"ProcessIdToFilterMap* GetProcessIdToFilterMap() {
  static base::NoDestructor<ProcessIdToFilterMap> instance;
  return instance.get();
}
",1
Detect whether the following code contains vulnerabilities.,"seamless_process(STREAM s)
 {
 	unsigned int pkglen;
 	char *buf;
 
 	pkglen = s->end - s->p;
 	/* str_handle_lines requires null terminated strings */
	buf = xmalloc(pkglen + 1);
	STRNCPY(buf, (char *) s->p, pkglen + 1);
	str_handle_lines(buf, &seamless_rest, seamless_line_handler, NULL);

	xfree(buf);
}
",1
Detect whether the following code contains vulnerabilities.,"static Position ComputePositionForChildrenRemoval(const Position& position,
                                                  ContainerNode& container) {
  Node* node = position.ComputeContainerNode();
  if (container.ContainsIncludingHostElements(*node))
    return Position::FirstPositionInNode(container);
  return position;
}
",0
Detect whether the following code contains vulnerabilities.,"void PrintMsg_Print_Params::Reset() {
  page_size = gfx::Size();
  content_size = gfx::Size();
  printable_area = gfx::Rect();
  margin_top = 0;
  margin_left = 0;
  dpi = 0;
  scale_factor = 1.0f;
  rasterize_pdf = false;
  document_cookie = 0;
  selection_only = false;
  supports_alpha_blend = false;
  preview_ui_id = -1;
  preview_request_id = 0;
  is_first_request = false;
  print_scaling_option = blink::kWebPrintScalingOptionSourceSize;
  print_to_pdf = false;
   display_header_footer = false;
   title = base::string16();
   url = base::string16();
   should_print_backgrounds = false;
   printed_doc_type = printing::SkiaDocumentType::PDF;
 }
",1
Detect whether the following code contains vulnerabilities.,"pdf_load_version(fz_context *ctx, pdf_document *doc)
{
	char buf[20];

	fz_seek(ctx, doc->file, 0, SEEK_SET);
	fz_read_line(ctx, doc->file, buf, sizeof buf);
	if (memcmp(buf, ""%PDF-"", 5) != 0)
		fz_throw(ctx, FZ_ERROR_GENERIC, ""cannot recognize version marker"");

	doc->version = 10 * (fz_atof(buf+5) + 0.05f);
	if (doc->version < 10 || doc->version > 17)
		if (doc->version != 20)
			fz_warn(ctx, ""unknown PDF version: %d.%d"", doc->version / 10, doc->version % 10);
}
",0
Detect whether the following code contains vulnerabilities.,"void d_instantiate(struct dentry *entry, struct inode * inode)
{
	BUG_ON(!hlist_unhashed(&entry->d_u.d_alias));
	if (inode) {
		security_d_instantiate(entry, inode);
		spin_lock(&inode->i_lock);
		__d_instantiate(entry, inode);
		spin_unlock(&inode->i_lock);
	}
}
",0
Detect whether the following code contains vulnerabilities.," void install_local_socket(asocket* s) {
    adb_mutex_lock(&socket_list_lock);
 
     s->id = local_socket_next_id++;
 
     if (local_socket_next_id == 0) {
        local_socket_next_id = 1;
     }
 
     insert_local_socket(s, &local_socket_list);
    adb_mutex_unlock(&socket_list_lock);
 }
",1
Detect whether the following code contains vulnerabilities.,"bool WebMediaPlayerMS::HasSingleSecurityOrigin() const {
  DCHECK(thread_checker_.CalledOnValidThread());
  return true;
}
",1
Detect whether the following code contains vulnerabilities.,"void InspectorResourceAgent::markResourceAsCached(unsigned long identifier)
{
    m_frontend->requestServedFromCache(IdentifiersFactory::requestId(identifier));
}
",0
Detect whether the following code contains vulnerabilities.,"unsigned long long Chapters::Atom::GetUID() const
{
    return m_uid;
 }
",1
Detect whether the following code contains vulnerabilities.,"int __hid_register_driver(struct hid_driver *hdrv, struct module *owner,
		const char *mod_name)
{
	int ret;

	hdrv->driver.name = hdrv->name;
	hdrv->driver.bus = &hid_bus_type;
	hdrv->driver.owner = owner;
	hdrv->driver.mod_name = mod_name;

	INIT_LIST_HEAD(&hdrv->dyn_list);
	spin_lock_init(&hdrv->dyn_lock);

	ret = driver_register(&hdrv->driver);
	if (ret)
		return ret;

	ret = driver_create_file(&hdrv->driver, &driver_attr_new_id);
	if (ret)
		driver_unregister(&hdrv->driver);

	return ret;
}
",0
Detect whether the following code contains vulnerabilities.,"status_t IPCThreadState::requestDeathNotification(int32_t handle, BpBinder* proxy)
{
    mOut.writeInt32(BC_REQUEST_DEATH_NOTIFICATION);
    mOut.writeInt32((int32_t)handle);
    mOut.writePointer((uintptr_t)proxy);
 return NO_ERROR;
}
",0
Detect whether the following code contains vulnerabilities.," long ssl_get_algorithm2(SSL *s)
        {
        long alg2 = s->s3->tmp.new_cipher->algorithm2;
       if (TLS1_get_version(s) >= TLS1_2_VERSION &&
            alg2 == (SSL_HANDSHAKE_MAC_DEFAULT|TLS1_PRF))
                return SSL_HANDSHAKE_MAC_SHA256 | TLS1_PRF_SHA256;
        return alg2;
	}
",1
Detect whether the following code contains vulnerabilities.,"base::PortProvider* BrowserChildProcessHost::GetPortProvider() {
  return MachBroker::GetInstance();
}
",0
Detect whether the following code contains vulnerabilities.,"void __detach_mounts(struct dentry *dentry)
{
	struct mountpoint *mp;
	struct mount *mnt;

	namespace_lock();
	mp = lookup_mountpoint(dentry);
	if (IS_ERR_OR_NULL(mp))
		goto out_unlock;

	lock_mount_hash();
	while (!hlist_empty(&mp->m_list)) {
		mnt = hlist_entry(mp->m_list.first, struct mount, mnt_mp_list);
		if (mnt->mnt.mnt_flags & MNT_UMOUNT) {
			struct mount *p, *tmp;
			list_for_each_entry_safe(p, tmp, &mnt->mnt_mounts,  mnt_child) {
				hlist_add_head(&p->mnt_umount.s_list, &unmounted);
 				umount_mnt(p);
 			}
 		}
		else umount_tree(mnt, 0);
 	}
 	unlock_mount_hash();
 	put_mountpoint(mp);
out_unlock:
	namespace_unlock();
}
",1
Detect whether the following code contains vulnerabilities.,"void IndexedDBCursor::RemoveCursorFromTransaction() {
  if (transaction_)
    transaction_->UnregisterOpenCursor(this);
}
",1
Detect whether the following code contains vulnerabilities.,"static int ne2000_buffer_full(NE2000State *s)
 {
     int avail, index, boundary;
 
     index = s->curpag << 8;
     boundary = s->boundary << 8;
     if (index < boundary)
        return 1;
    return 0;
}
",1
Detect whether the following code contains vulnerabilities.,"bool WebPagePrivate::dispatchTouchPointAsMouseEventToFullScreenPlugin(PluginView* pluginView, const Platform::TouchPoint& point)
{
     NPEvent npEvent;
     NPMouseEvent mouse;
 
    switch (point.m_state) {
     case Platform::TouchPoint::TouchPressed:
         mouse.type = MOUSE_BUTTON_DOWN;
         break;
    case Platform::TouchPoint::TouchReleased:
        mouse.type = MOUSE_BUTTON_UP;
        break;
    case Platform::TouchPoint::TouchMoved:
        mouse.type = MOUSE_MOTION;
        break;
    case Platform::TouchPoint::TouchStationary:
         return true;
     }
 
    mouse.x = point.m_screenPos.x();
    mouse.y = point.m_screenPos.y();
     mouse.button = mouse.type != MOUSE_BUTTON_UP;
     mouse.flags = 0;
     npEvent.type = NP_MouseEvent;
    npEvent.data = &mouse;

    pluginView->dispatchFullScreenNPEvent(npEvent);
    return true;
}
",1
Detect whether the following code contains vulnerabilities.,"void ScreenRecorder::DoAddConnection(
    scoped_refptr<ConnectionToClient> connection) {
  DCHECK(network_loop_->BelongsToCurrentThread());
  connections_.push_back(connection);
}
",1
Detect whether the following code contains vulnerabilities.,"PassRefPtr<DocumentFragment> XSLTProcessor::transformToFragment(Node* sourceNode, Document* outputDoc)
{
    String resultMIMEType;
    String resultString;
    String resultEncoding;

    if (outputDoc->isHTMLDocument())
        resultMIMEType = ""text/html"";
 
     if (!transformToString(sourceNode, resultMIMEType, resultString, resultEncoding))
         return 0;
    return createFragmentFromSource(resultString, resultMIMEType, outputDoc);
 }
",1
Detect whether the following code contains vulnerabilities.,"ExtensionsGuestViewMessageFilter::FrameNavigationHelper::FrameNavigationHelper(
    RenderFrameHost* plugin_rfh,
    int32_t guest_instance_id,
    int32_t element_instance_id,
    bool is_full_page_plugin,
    ExtensionsGuestViewMessageFilter* filter)
    : content::WebContentsObserver(
          content::WebContents::FromRenderFrameHost(plugin_rfh)),
      frame_tree_node_id_(plugin_rfh->GetFrameTreeNodeId()),
      guest_instance_id_(guest_instance_id),
      element_instance_id_(element_instance_id),
      is_full_page_plugin_(is_full_page_plugin),
      filter_(filter),
      parent_site_instance_(plugin_rfh->GetParent()->GetSiteInstance()),
      weak_factory_(this) {
  DCHECK(GetGuestView());
  NavigateToAboutBlank();
  base::PostDelayedTaskWithTraits(
      FROM_HERE, {BrowserThread::UI},
      base::BindOnce(&ExtensionsGuestViewMessageFilter::FrameNavigationHelper::
                         CancelPendingTask,
                     weak_factory_.GetWeakPtr()),
      base::TimeDelta::FromMilliseconds(kAttachFailureDelayMS));
}
",1
Detect whether the following code contains vulnerabilities.,"void GaiaCookieManagerService::ForceOnCookieChangedProcessing() {
  GURL google_url = GaiaUrls::GetInstance()->google_url();
  std::unique_ptr<net::CanonicalCookie> cookie(net::CanonicalCookie::Create(
      google_url, kGaiaCookieName, std::string(), ""."" + google_url.host(),
      std::string(), base::Time(), base::Time(), false, false,
      net::CookieSameSite::DEFAULT_MODE, false, net::COOKIE_PRIORITY_DEFAULT));
  OnCookieChanged(*cookie, net::CookieStore::ChangeCause::UNKNOWN_DELETION);
}
",0
Detect whether the following code contains vulnerabilities.,"static void ifb_setup(struct net_device *dev)
{
	/* Initialize the device structure. */
	dev->destructor = free_netdev;
	dev->netdev_ops = &ifb_netdev_ops;

	/* Fill in device structure with ethernet-generic values. */
	ether_setup(dev);
	dev->tx_queue_len = TX_Q_LIMIT;

	dev->features |= IFB_FEATURES;
	dev->vlan_features |= IFB_FEATURES;
 
 	dev->flags |= IFF_NOARP;
 	dev->flags &= ~IFF_MULTICAST;
	dev->priv_flags &= ~IFF_XMIT_DST_RELEASE;
 	random_ether_addr(dev->dev_addr);
 }
",1
Detect whether the following code contains vulnerabilities.,"  string cookie_value() {
    return decoder_->cookie_value_;
  }
",0
Detect whether the following code contains vulnerabilities.,"status_t OMXNodeInstance::getConfig(

         OMX_INDEXTYPE index, void *params, size_t /* size */) {
     Mutex::Autolock autoLock(mLock);
 
     OMX_ERRORTYPE err = OMX_GetConfig(mHandle, index, params);
     OMX_INDEXEXTTYPE extIndex = (OMX_INDEXEXTTYPE)index;
 if (err != OMX_ErrorNoMore) {
        CLOG_IF_ERROR(getConfig, err, ""%s(%#x)"", asString(extIndex), index);
 }
 return StatusFromOMXError(err);
}
",1
Detect whether the following code contains vulnerabilities.,"void StoreAccumulatedContentLength(int received_content_length,
                                   int original_content_length,
                                   bool data_reduction_proxy_was_used) {
   BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,
       base::Bind(&UpdateContentLengthPrefs,
                  received_content_length, original_content_length,
                 data_reduction_proxy_was_used));
 }
",1
Detect whether the following code contains vulnerabilities.,"OMX_ERRORTYPE SimpleSoftOMXComponent::internalSetParameter(
        OMX_INDEXTYPE index, const OMX_PTR params) {
 switch (index) {
 case OMX_IndexParamPortDefinition:
 {

             OMX_PARAM_PORTDEFINITIONTYPE *defParams =
                 (OMX_PARAM_PORTDEFINITIONTYPE *)params;
 
             if (defParams->nPortIndex >= mPorts.size()) {
                 return OMX_ErrorBadPortIndex;
             }
 if (defParams->nSize != sizeof(OMX_PARAM_PORTDEFINITIONTYPE)) {
 return OMX_ErrorUnsupportedSetting;
 }

 PortInfo *port =
 &mPorts.editItemAt(defParams->nPortIndex);

 if (defParams->nBufferSize > port->mDef.nBufferSize) {
                port->mDef.nBufferSize = defParams->nBufferSize;
 }

 if (defParams->nBufferCountActual < port->mDef.nBufferCountMin) {
                ALOGW(""component requires at least %u buffers (%u requested)"",
                        port->mDef.nBufferCountMin, defParams->nBufferCountActual);
 return OMX_ErrorUnsupportedSetting;
 }

            port->mDef.nBufferCountActual = defParams->nBufferCountActual;
 return OMX_ErrorNone;
 }

 default:
 return OMX_ErrorUnsupportedIndex;
 }
}
",1
Detect whether the following code contains vulnerabilities.,"static ssize_t handle_readlink(FsContext *fs_ctx, V9fsPath *fs_path,
                               char *buf, size_t bufsz)
{
    int fd, ret;
    struct handle_data *data = (struct handle_data *)fs_ctx->private;

    fd = open_by_handle(data->mountfd, fs_path->data, O_PATH);
    if (fd < 0) {
        return fd;
    }
    ret = readlinkat(fd, """", buf, bufsz);
    close(fd);
    return ret;
}
",0
Detect whether the following code contains vulnerabilities.,"static int devicenrange(i_ctx_t * i_ctx_p, ref *space, float *ptr)
{
    int i, limit, code;
    PS_colour_space_t *cspace;

    ref altspace;

    code = array_get(imemory, space, 1, &altspace);
    if (code < 0)
        return code;

    code = get_space_object(i_ctx_p, &altspace, &cspace);
    if (code < 0)
        return code;

    code = cspace->numcomponents(i_ctx_p, &altspace, &limit);
    if (code < 0)
        return code;

    for (i = 0;i < limit * 2;i+=2) {
        ptr[i] = 0;
        ptr[i+1] = 1;
    }
    return 0;
}
",0
Detect whether the following code contains vulnerabilities.,"static void bt_for_each(struct blk_mq_hw_ctx *hctx,
		struct blk_mq_bitmap_tags *bt, unsigned int off,
		busy_iter_fn *fn, void *data, bool reserved)
{
	struct request *rq;
	int bit, i;

	for (i = 0; i < bt->map_nr; i++) {
		struct blk_align_bitmap *bm = &bt->map[i];

 		for (bit = find_first_bit(&bm->word, bm->depth);
 		     bit < bm->depth;
 		     bit = find_next_bit(&bm->word, bm->depth, bit + 1)) {
		     	rq = blk_mq_tag_to_rq(hctx->tags, off + bit);
 			if (rq->q == hctx->queue)
 				fn(hctx, rq, data, reserved);
 		}

		off += (1 << bt->bits_per_word);
	}
}
",1
Detect whether the following code contains vulnerabilities.," void ChromeMockRenderThread::OnMsgOpenChannelToExtension(
    int routing_id, const std::string& source_extension_id,
     const std::string& target_extension_id,
    const std::string& channel_name, int* port_id) {
   *port_id = 0;
 }
",1
Detect whether the following code contains vulnerabilities.," SendTabToSelfInfoBarDelegate::SendTabToSelfInfoBarDelegate(
     const SendTabToSelfEntry* entry) {
   entry_ = entry;
 }
",1
Detect whether the following code contains vulnerabilities.,"static int opfiadd(RAsm *a, ut8 *data, const Opcode *op) {
	int l = 0;
	switch (op->operands_count) {
	case 1:
		if ( op->operands[0].type & OT_MEMORY ) {
			if ( op->operands[0].type & OT_WORD ) {
				data[l++] = 0xde;
				data[l++] = 0x00 | op->operands[0].regs[0];
			} else if ( op->operands[0].type & OT_DWORD ) {
				data[l++] = 0xda;
				data[l++] = 0x00 | op->operands[0].regs[0];
			} else {
				return -1;
			}
		} else {
			return -1;
		}
		break;
	default:
		return -1;
	}
	return l;
}
",0
Detect whether the following code contains vulnerabilities.,"static inline void jmp_rel(struct x86_emulate_ctxt *ctxt, int rel)
 {
	assign_eip_near(ctxt, ctxt->_eip + rel);
 }
",1
Detect whether the following code contains vulnerabilities.,"format_STACK_POP(const struct ofpact_stack *a, struct ds *s)
{
    nxm_format_stack_pop(a, s);
}
",0
Detect whether the following code contains vulnerabilities.,"static void usb_net_reset_in_buf(USBNetState *s)
{
    s->in_ptr = s->in_len = 0;
    qemu_flush_queued_packets(qemu_get_queue(s->nic));
}
",0
Detect whether the following code contains vulnerabilities.,"void RenderFrameHostImpl::SetCommitCallbackInterceptorForTesting(
    CommitCallbackInterceptor* interceptor) {
  DCHECK(!commit_callback_interceptor_ || !interceptor);
  commit_callback_interceptor_ = interceptor;
}
",0
Detect whether the following code contains vulnerabilities.,"encode_UNROLL_XLATE(const struct ofpact_unroll_xlate *unroll OVS_UNUSED,
                    enum ofp_version ofp_version OVS_UNUSED,
                    struct ofpbuf *out OVS_UNUSED)
{
    OVS_NOT_REACHED();
}
",0
Detect whether the following code contains vulnerabilities.,"char *path_name(const struct name_path *path, const char *name)
{
	const struct name_path *p;
	char *n, *m;
	int nlen = strlen(name);
	int len = nlen + 1;

	for (p = path; p; p = p->up) {
		if (p->elem_len)
			len += p->elem_len + 1;
 	}
 	n = xmalloc(len);
 	m = n + len - (nlen + 1);
	strcpy(m, name);
 	for (p = path; p; p = p->up) {
 		if (p->elem_len) {
 			m -= p->elem_len + 1;
			memcpy(m, p->elem, p->elem_len);
			m[p->elem_len] = '/';
		}
	}
	return n;
}
",1
Detect whether the following code contains vulnerabilities.,"void HTMLInputElement::setSize(unsigned size)
{
    setAttribute(sizeAttr, String::number(size));
}
",0
Detect whether the following code contains vulnerabilities.,"  virtual void Observe(NotificationType type,
                       const NotificationSource& source,
                       const NotificationDetails& details) {
    if (type == NotificationType::NAV_LIST_PRUNED) {
      notification_count_++;
      details_ = *(Details<NavigationController::PrunedDetails>(details).ptr());
    }
  }
",0
Detect whether the following code contains vulnerabilities.,"static bool name_is_in_groupnames(char *name, char **groupnames)
{
	while (groupnames != NULL) {
		if (strcmp(name, *groupnames) == 0)
			return true;
		groupnames++;
	}
	return false;
}
",0
Detect whether the following code contains vulnerabilities.,"void RenderBox::panScroll(const IntPoint& source)
{
    if (layer())
        layer()->panScrollFromPoint(source);
}
",0
Detect whether the following code contains vulnerabilities.," void ImageBitmapFactories::ImageBitmapLoader::Trace(blink::Visitor* visitor) {
   visitor->Trace(factory_);
   visitor->Trace(resolver_);
   visitor->Trace(options_);
}
",1
Detect whether the following code contains vulnerabilities.,"void WebPluginDelegateProxy::CopyFromTransportToBacking(const gfx::Rect& rect) {
  if (!backing_store_canvas_.get()) {
    return;
  }

#if defined(OS_MACOSX)
  const size_t stride =
      skia::PlatformCanvas::StrideForWidth(plugin_rect_.width());
  const size_t chunk_size = 4 * rect.width();
  uint8* source_data = static_cast<uint8*>(transport_store_->memory()) +
                       rect.y() * stride + 4 * rect.x();
  int dest_starting_row = plugin_rect_.height() - rect.y() - 1;
  DCHECK(backing_store_.size() > 0);
  uint8* target_data = &(backing_store_[0]) + dest_starting_row * stride +
                       4 * rect.x();
  for (int row = 0; row < rect.height(); ++row) {
    memcpy(target_data, source_data, chunk_size);
    source_data += stride;
    target_data -= stride;
  }
#else
  BlitCanvasToCanvas(backing_store_canvas_.get(), rect,
                     transport_store_canvas_.get(), rect.origin());
#endif
  backing_store_painted_ = backing_store_painted_.Union(rect);
}
",0
Detect whether the following code contains vulnerabilities.,"int main(int argc, char *argv[])
{
	int ret;
	struct lxc_lock *lock;

	lock = lxc_newlock(NULL, NULL);
	if (!lock) {
		fprintf(stderr, ""%d: failed to get unnamed lock\n"", __LINE__);
		exit(1);
	}
	ret = lxclock(lock, 0);
	if (ret) {
		fprintf(stderr, ""%d: failed to take unnamed lock (%d)\n"", __LINE__, ret);
		exit(1);
	}

	ret = lxcunlock(lock);
	if (ret) {
		fprintf(stderr, ""%d: failed to put unnamed lock (%d)\n"", __LINE__, ret);
		exit(1);
	}
	lxc_putlock(lock);

	lock = lxc_newlock(""/var/lib/lxc"", mycontainername);
	if (!lock) {
		fprintf(stderr, ""%d: failed to get lock\n"", __LINE__);
 		exit(1);
 	}
 	struct stat sb;
	char *pathname = RUNTIME_PATH ""/lock/lxc/var/lib/lxc/"";
 	ret = stat(pathname, &sb);
 	if (ret != 0) {
 		fprintf(stderr, ""%d: filename %s not created\n"", __LINE__,
			pathname);
		exit(1);
	}
	lxc_putlock(lock);

	test_two_locks();

	fprintf(stderr, ""all tests passed\n"");

	exit(ret);
}
",1
Detect whether the following code contains vulnerabilities.,"int BN_hex2bn(BIGNUM **bn, const char *a)
{
    BIGNUM *ret = NULL;
    BN_ULONG l = 0;
    int neg = 0, h, m, i, j, k, c;
    int num;

    if ((a == NULL) || (*a == '\0'))
        return (0);

    if (*a == '-') {
        neg = 1;
        a++;
         a++;
     }
 
    for (i = 0; isxdigit((unsigned char)a[i]); i++) ;
 
     num = i + neg;
     if (bn == NULL)
            return (0);
    } else {
        ret = *bn;
        BN_zero(ret);
    }
",1
Detect whether the following code contains vulnerabilities.,"void AllocateDataSet(cmsIT8* it8)
{
    TABLE* t = GetTable(it8);

    if (t -> Data) return;    // Already allocated

     t-> nSamples   = atoi(cmsIT8GetProperty(it8, ""NUMBER_OF_FIELDS""));
     t-> nPatches   = atoi(cmsIT8GetProperty(it8, ""NUMBER_OF_SETS""));
 
    t-> Data = (char**)AllocChunk (it8, ((cmsUInt32Number) t->nSamples + 1) * ((cmsUInt32Number) t->nPatches + 1) *sizeof (char*));
    if (t->Data == NULL) {
 
        SynError(it8, ""AllocateDataSet: Unable to allocate data array"");
     }
 
 }
",1
Detect whether the following code contains vulnerabilities.,"void RenderWidgetHostImpl::DidNavigate(uint32_t next_source_id) {
  current_content_source_id_ = next_source_id;
  did_receive_first_frame_after_navigation_ = false;

  if (enable_surface_synchronization_) {
     visual_properties_ack_pending_ = false;
    viz::LocalSurfaceId old_surface_id = view_->GetLocalSurfaceId();
     if (view_)
       view_->DidNavigate();
    viz::LocalSurfaceId new_surface_id = view_->GetLocalSurfaceId();
    if (old_surface_id == new_surface_id)
      return;
   } else {
    if (last_received_content_source_id_ >= current_content_source_id_)
      return;
  }

  if (!new_content_rendering_timeout_)
    return;

  new_content_rendering_timeout_->Start(new_content_rendering_delay_);
}
",1
Detect whether the following code contains vulnerabilities.," rs_filter_graph(RSFilter *filter)
 {
 	g_return_if_fail(RS_IS_FILTER(filter));
 	GString *str = g_string_new(""digraph G {\n"");
 
 	rs_filter_graph_helper(str, filter);
 
 	g_string_append_printf(str, ""}\n"");
	g_file_set_contents(""/tmp/rs-filter-graph"", str->str, str->len, NULL);
 
	if (0 != system(""dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph""))
 		g_warning(""Calling dot failed"");
	if (0 != system(""gnome-open /tmp/rs-filter-graph.png""))
 		g_warning(""Calling gnome-open failed."");
 
 	g_string_free(str, TRUE);
 }
",1
Detect whether the following code contains vulnerabilities.," static void ReconfigureImpl(Handle<JSObject> object,
 Handle<FixedArrayBase> store, uint32_t entry,
 Handle<Object> value,
 PropertyAttributes attributes) {
 Handle<SeededNumberDictionary> dictionary =
 JSObject::NormalizeElements(object);
 FixedArray::cast(*store)->set(1, *dictionary);
 uint32_t length = static_cast<uint32_t>(store->length()) - 2;
 if (entry >= length) {
      entry = dictionary->FindEntry(entry - length) + length;
 }
 SlowSloppyArgumentsElementsAccessor::ReconfigureImpl(object, store, entry,
                                                         value, attributes);
 }
",0
Detect whether the following code contains vulnerabilities.,"static int mwifiex_update_vs_ie(const u8 *ies, int ies_len,
				struct mwifiex_ie **ie_ptr, u16 mask,
				unsigned int oui, u8 oui_type)
{
	struct ieee_types_header *vs_ie;
	struct mwifiex_ie *ie = *ie_ptr;
	const u8 *vendor_ie;

	vendor_ie = cfg80211_find_vendor_ie(oui, oui_type, ies, ies_len);
	if (vendor_ie) {
		if (!*ie_ptr) {
			*ie_ptr = kzalloc(sizeof(struct mwifiex_ie),
					  GFP_KERNEL);
			if (!*ie_ptr)
				return -ENOMEM;
			ie = *ie_ptr;
 		}
 
 		vs_ie = (struct ieee_types_header *)vendor_ie;
 		memcpy(ie->ie_buffer + le16_to_cpu(ie->ie_length),
 		       vs_ie, vs_ie->len + 2);
 		le16_unaligned_add_cpu(&ie->ie_length, vs_ie->len + 2);
		ie->mgmt_subtype_mask = cpu_to_le16(mask);
		ie->ie_index = cpu_to_le16(MWIFIEX_AUTO_IDX_MASK);
	}

	*ie_ptr = ie;
	return 0;
}
",1
Detect whether the following code contains vulnerabilities.,"BOOL license_read_scope_list(wStream* s, SCOPE_LIST* scopeList)
{
	UINT32 i;
	UINT32 scopeCount;

	if (Stream_GetRemainingLength(s) < 4)
		return FALSE;
 
 	Stream_Read_UINT32(s, scopeCount); /* ScopeCount (4 bytes) */
 
 	scopeList->count = scopeCount;
 	scopeList->array = (LICENSE_BLOB*) malloc(sizeof(LICENSE_BLOB) * scopeCount);
 
	/* ScopeArray */
	for (i = 0; i < scopeCount; i++)
	{
		scopeList->array[i].type = BB_SCOPE_BLOB;

		if (!license_read_binary_blob(s, &scopeList->array[i]))
			return FALSE;
	}

	return TRUE;
}
",1
Detect whether the following code contains vulnerabilities.,"bool effect_exists(effect_context_t *context)
{
 struct listnode *node;

    list_for_each(node, &created_effects_list) {
 effect_context_t *fx_ctxt = node_to_item(node,
 effect_context_t,
                                                 effects_list_node);
 if (fx_ctxt == context) {
 return true;
 }
 }
 return false;
}
",0
Detect whether the following code contains vulnerabilities.,"bool JSTestInterfaceConstructor::getOwnPropertySlot(JSCell* cell, ExecState* exec, const Identifier& propertyName, PropertySlot& slot)
{
    return getStaticPropertySlot<JSTestInterfaceConstructor, JSDOMWrapper>(exec, &JSTestInterfaceConstructorTable, jsCast<JSTestInterfaceConstructor*>(cell), propertyName, slot);
}
",0
Detect whether the following code contains vulnerabilities.," SPL_METHOD(SplFileObject, next)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}

	spl_filesystem_file_free_line(intern TSRMLS_CC);
	if (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_AHEAD)) {
		spl_filesystem_file_read_line(getThis(), intern, 1 TSRMLS_CC);
	}
	intern->u.file.current_line_num++;
} /* }}} */

/* {{{ proto void SplFileObject::setFlags(int flags)
",1
Detect whether the following code contains vulnerabilities.,"AtomicString GetInputModeAttribute(Element* element) {
  if (!element)
    return AtomicString();

  bool query_attribute = false;
  if (isHTMLInputElement(*element)) {
    query_attribute = toHTMLInputElement(*element).SupportsInputModeAttribute();
  } else if (isHTMLTextAreaElement(*element)) {
    query_attribute = true;
  } else {
    element->GetDocument().UpdateStyleAndLayoutTree();
    if (HasEditableStyle(*element))
      query_attribute = true;
  }

  if (!query_attribute)
    return AtomicString();

  return element->FastGetAttribute(HTMLNames::inputmodeAttr).DeprecatedLower();
}
",0
Detect whether the following code contains vulnerabilities.,"static int load_segment_descriptor(struct x86_emulate_ctxt *ctxt,
 				   u16 selector, int seg)
 {
 	u8 cpl = ctxt->ops->cpl(ctxt);
 	return __load_segment_descriptor(ctxt, selector, seg, cpl,
 					 X86_TRANSFER_NONE, NULL);
 }
",1
Detect whether the following code contains vulnerabilities.," FilePath ExtensionPrefs::GetExtensionPath(const std::string& extension_id) {
   const DictionaryValue* dict = GetExtensionPref(extension_id);
   std::string path;
   if (!dict->GetString(kPrefPath, &path))
     return FilePath();

  return install_directory_.Append(FilePath::FromWStringHack(UTF8ToWide(path)));
}
",1
Detect whether the following code contains vulnerabilities.,"LayoutUnit RenderBox::computeReplacedLogicalWidthRespectingMinMaxWidth(LayoutUnit logicalWidth, ShouldComputePreferred shouldComputePreferred) const
{
    LayoutUnit minLogicalWidth = (shouldComputePreferred == ComputePreferred && style()->logicalMinWidth().isPercent()) || style()->logicalMinWidth().isUndefined() ? logicalWidth : computeReplacedLogicalWidthUsing(style()->logicalMinWidth());
    LayoutUnit maxLogicalWidth = (shouldComputePreferred == ComputePreferred && style()->logicalMaxWidth().isPercent()) || style()->logicalMaxWidth().isUndefined() ? logicalWidth : computeReplacedLogicalWidthUsing(style()->logicalMaxWidth());
    return max(minLogicalWidth, min(logicalWidth, maxLogicalWidth));
}
",0
Detect whether the following code contains vulnerabilities.," void OffscreenCanvasFrameReceiverImpl::SubmitCompositorFrame(
     const cc::SurfaceId& surface_id,
     cc::CompositorFrame frame) {
    cc::Surface* surface = GetSurfaceManager()->GetSurfaceForId(surface_id);
    if (surface) {
        surface->QueueFrame(std::move(frame), base::Closure());
     }
 }
",1
Detect whether the following code contains vulnerabilities.," static void ieee80211_if_setup(struct net_device *dev)
 {
 	ether_setup(dev);
 	dev->netdev_ops = &ieee80211_dataif_ops;
 	dev->destructor = free_netdev;
 }
",1
Detect whether the following code contains vulnerabilities.," void OffscreenCanvasSurfaceImpl::Create(
    mojo::InterfaceRequest<blink::mojom::OffscreenCanvasSurface> request) {
  mojo::MakeStrongBinding(base::MakeUnique<OffscreenCanvasSurfaceImpl>(),
                          std::move(request));
}
",0
Detect whether the following code contains vulnerabilities.,"std::unique_ptr<BlobDataHandle> BlobStorageContext::GetBlobDataFromPublicURL(
    const GURL& url) {
  std::string uuid;
  BlobEntry* entry = registry_.GetEntryFromURL(url, &uuid);
  if (!entry)
    return nullptr;
  return CreateHandle(uuid, entry);
}
",0
Detect whether the following code contains vulnerabilities.,"void TextAutosizer::processCluster(RenderBlock* cluster, RenderBlock* container, RenderObject* subtreeRoot, const TextAutosizingWindowInfo& windowInfo)
{
    ASSERT(isAutosizingCluster(cluster));

    RenderBlock* lowestCommonAncestor = cluster;
    float commonAncestorWidth = lowestCommonAncestor->contentLogicalWidth();

    float multiplier = 1;
    if (clusterShouldBeAutosized(lowestCommonAncestor, commonAncestorWidth)) {
        int logicalWindowWidth = cluster->isHorizontalWritingMode() ? windowInfo.windowSize.width() : windowInfo.windowSize.height();
        int logicalLayoutWidth = cluster->isHorizontalWritingMode() ? windowInfo.minLayoutSize.width() : windowInfo.minLayoutSize.height();
        float logicalClusterWidth = std::min<float>(commonAncestorWidth, logicalLayoutWidth);

        multiplier = logicalClusterWidth / logicalWindowWidth;
        multiplier *= m_document->settings()->textAutosizingFontScaleFactor();
        multiplier = std::max(1.0f, multiplier);
    }

    processContainer(multiplier, container, subtreeRoot, windowInfo);
}
",0
Detect whether the following code contains vulnerabilities.,"nm_setting_vpn_foreach_secret (NMSettingVPN *setting,
                               NMVPNIterFunc func,
                               gpointer user_data)
{
	g_return_if_fail (setting != NULL);
	g_return_if_fail (NM_IS_SETTING_VPN (setting));

	foreach_item_helper (NM_SETTING_VPN_GET_PRIVATE (setting)->secrets, func, user_data);
}
",0
Detect whether the following code contains vulnerabilities.,"bool SendNativeKeyEventJSONRequest(
    AutomationMessageSender* sender,
    int browser_index,
    int tab_index,
    ui::KeyboardCode key_code,
    int modifiers,
    std::string* error_msg) {
  DictionaryValue dict;
  dict.SetString(""command"", ""SendOSLevelKeyEventToTab"");
  dict.SetInteger(""windex"", browser_index);
  dict.SetInteger(""tab_index"", tab_index);
  dict.SetInteger(""keyCode"", key_code);
  dict.SetInteger(""modifiers"", modifiers);
  DictionaryValue reply_dict;
  return SendAutomationJSONRequest(sender, dict, &reply_dict, error_msg);
}
",0
Detect whether the following code contains vulnerabilities.,"    StateBase* handleError(Status errorStatus, const String& message, StateBase* state)
    {
        ASSERT(errorStatus != Success);
        m_status = errorStatus;
        m_errorMessage = message;
        while (state) {
            StateBase* tmp = state->nextState();
            delete state;
            state = tmp;
        }
        return new ErrorState;
    }
",0
Detect whether the following code contains vulnerabilities.,"static void llc_sap_rcv(struct llc_sap *sap, struct sk_buff *skb,
			struct sock *sk)
{
	struct llc_sap_state_ev *ev = llc_sap_ev(skb);
 
 	ev->type   = LLC_SAP_EV_TYPE_PDU;
 	ev->reason = 0;
 	skb->sk = sk;
 	llc_sap_state_process(sap, skb);
 }
",1
Detect whether the following code contains vulnerabilities.,"void* sspi_SecureHandleGetLowerPointer(SecHandle* handle)
 {
 	void* pointer;
 
	if (!handle)
 		return NULL;
 
 	pointer = (void*) ~((size_t) handle->dwLower);

	return pointer;
}
",1
Detect whether the following code contains vulnerabilities.,"int nfs4_proc_fs_locations(struct rpc_clnt *client, struct inode *dir,
			   const struct qstr *name,
			   struct nfs4_fs_locations *fs_locations,
			   struct page *page)
{
	struct nfs4_exception exception = { };
	int err;
	do {
		err = _nfs4_proc_fs_locations(client, dir, name,
				fs_locations, page);
		trace_nfs4_get_fs_locations(dir, name, err);
		err = nfs4_handle_exception(NFS_SERVER(dir), err,
				&exception);
	} while (exception.retry);
	return err;
}
",0
Detect whether the following code contains vulnerabilities.,"CuePoint::~CuePoint()
{
    delete[] m_track_positions;
}
",1
Detect whether the following code contains vulnerabilities.,"WebsiteSettingsPopupAndroid::WebsiteSettingsPopupAndroid(
    JNIEnv* env,
    jobject java_website_settings_pop,
    content::WebContents* web_contents) {
  content::NavigationEntry* nav_entry =
      web_contents->GetController().GetVisibleEntry();
  if (nav_entry == NULL)
    return;

  url_ = nav_entry->GetURL();

  popup_jobject_.Reset(env, java_website_settings_pop);

  presenter_.reset(new WebsiteSettings(
       this,
       Profile::FromBrowserContext(web_contents->GetBrowserContext()),
       TabSpecificContentSettings::FromWebContents(web_contents),
      InfoBarService::FromWebContents(web_contents),
       nav_entry->GetURL(),
       nav_entry->GetSSL(),
       content::CertStore::GetInstance()));
}
",1
Detect whether the following code contains vulnerabilities.,"error::Error GLES2DecoderPassthroughImpl::DoScheduleCALayerCHROMIUM(
    GLuint contents_texture_id,
    const GLfloat* contents_rect,
    GLuint background_color,
    GLuint edge_aa_mask,
    const GLfloat* bounds_rect) {
  NOTIMPLEMENTED();
  return error::kNoError;
}
",0
Detect whether the following code contains vulnerabilities.,"   bool ReceiverWasAdded(const RtpTransceiverState& transceiver_state) {
     uintptr_t receiver_id = RTCRtpReceiver::getId(
         transceiver_state.receiver_state()->webrtc_receiver().get());
     for (const auto& receiver : handler_->rtp_receivers_) {
      if (receiver->Id() == receiver_id)
        return false;
    }
    return true;
  }
",1
Detect whether the following code contains vulnerabilities.,"static ssize_t eth_rx(NetClientState *nc, const uint8_t *buf, size_t size)
{
    struct xlx_ethlite *s = qemu_get_nic_opaque(nc);
    unsigned int rxbase = s->rxbuf * (0x800 / 4);

    /* DA filter.  */
    if (!(buf[0] & 0x80) && memcmp(&s->conf.macaddr.a[0], buf, 6))
        return size;

    if (s->regs[rxbase + R_RX_CTRL0] & CTRL_S) {
        D(qemu_log(""ethlite lost packet %x\n"", s->regs[R_RX_CTRL0]));
        return -1;
     }
 
     D(qemu_log(""%s %zd rxbase=%x\n"", __func__, size, rxbase));
     memcpy(&s->regs[rxbase + R_RX_BUF0], buf, size);
 
     s->regs[rxbase + R_RX_CTRL0] |= CTRL_S;
    /* If c_rx_pingpong was set flip buffers.  */
    s->rxbuf ^= s->c_rx_pingpong;
    return size;
}
",1
Detect whether the following code contains vulnerabilities.,"static void vapic_exit(struct kvm_vcpu *vcpu)
{
	struct kvm_lapic *apic = vcpu->arch.apic;
	int idx;

	if (!apic || !apic->vapic_addr)
		return;

	idx = srcu_read_lock(&vcpu->kvm->srcu);
	kvm_release_page_dirty(apic->vapic_page);
	mark_page_dirty(vcpu->kvm, apic->vapic_addr >> PAGE_SHIFT);
	srcu_read_unlock(&vcpu->kvm->srcu, idx);
}
",0
Detect whether the following code contains vulnerabilities.," SPL_METHOD(SplFileObject, valid)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}

	if (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_AHEAD)) {
		RETURN_BOOL(intern->u.file.current_line || intern->u.file.current_zval);
	} else {
		RETVAL_BOOL(!php_stream_eof(intern->u.file.stream));
	}
} /* }}} */

/* {{{ proto string SplFileObject::fgets()
",1
Detect whether the following code contains vulnerabilities.," void SynchronousCompositorImpl::PostInvalidate() {
   DCHECK(CalledOnValidThread());
   DCHECK(compositor_client_);
  compositor_client_->PostInvalidate();
 }
",1
Detect whether the following code contains vulnerabilities.,"const std::string& WebContentsImpl::GetUserAgentOverride() const {
  return renderer_preferences_.user_agent_override;
}
",0
Detect whether the following code contains vulnerabilities.,"   void DoTest(ExternalProtocolHandler::BlockState block_state,
               shell_integration::DefaultWebClientState os_state,
               Action expected_action) {
    GURL url(""mailto:test@test.com"");
     EXPECT_FALSE(delegate_.has_prompted());
     EXPECT_FALSE(delegate_.has_launched());
     EXPECT_FALSE(delegate_.has_blocked());

    delegate_.set_block_state(block_state);
    delegate_.set_os_state(os_state);
    ExternalProtocolHandler::LaunchUrlWithDelegate(
        url, 0, 0, ui::PAGE_TRANSITION_LINK, true, &delegate_);
    content::RunAllTasksUntilIdle();

    EXPECT_EQ(expected_action == Action::PROMPT, delegate_.has_prompted());
    EXPECT_EQ(expected_action == Action::LAUNCH, delegate_.has_launched());
    EXPECT_EQ(expected_action == Action::BLOCK, delegate_.has_blocked());
  }
",1
Detect whether the following code contains vulnerabilities.," set_text_distance(gs_point *pdist, double dx, double dy, const gs_matrix *pmat)
 {
    int code = gs_distance_transform_inverse(dx, dy, pmat, pdist);
     double rounded;
 
     if (code == gs_error_undefinedresult) {
         /* The CTM is degenerate.
            Can't know the distance in user space.
    } else if (code < 0)
        return code;
    /* If the distance is very close to integers, round it. */
    if (fabs(pdist->x - (rounded = floor(pdist->x + 0.5))) < 0.0005)
        pdist->x = rounded;
    if (fabs(pdist->y - (rounded = floor(pdist->y + 0.5))) < 0.0005)
        pdist->y = rounded;
    return 0;
}
",1
Detect whether the following code contains vulnerabilities.,"xmlXPathNextPrecedingInternal(xmlXPathParserContextPtr ctxt,
                               xmlNodePtr cur)
 {
     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);
    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||
	(ctxt->context->node->type == XML_NAMESPACE_DECL))
	return(NULL);
     if (cur == NULL) {
         cur = ctxt->context->node;
         if (cur == NULL)
             return (NULL);
         ctxt->ancestor = cur->parent;
     }
     if ((cur->prev != NULL) && (cur->prev->type == XML_DTD_NODE))
	cur = cur->prev;
    while (cur->prev == NULL) {
        cur = cur->parent;
        if (cur == NULL)
            return (NULL);
        if (cur == ctxt->context->doc->children)
            return (NULL);
        if (cur != ctxt->ancestor)
            return (cur);
        ctxt->ancestor = cur->parent;
    }
    cur = cur->prev;
    while (cur->last != NULL)
        cur = cur->last;
    return (cur);
}
",1
Detect whether the following code contains vulnerabilities.,"void PlatformSensorProviderLinux::FreeResources() {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  DCHECK(file_task_runner_);
  Shutdown();
  file_task_runner_->PostTask(
      FROM_HERE, base::Bind(&PlatformSensorProviderLinux::StopPollingThread,
                            base::Unretained(this)));
}
",0
Detect whether the following code contains vulnerabilities.,"static inline void removeElementPreservingChildren(PassRefPtr<DocumentFragment> fragment, HTMLElement* element)
{
    ExceptionCode ignoredExceptionCode;
    RefPtr<Node> nextChild;
    for (RefPtr<Node> child = element->firstChild(); child; child = nextChild) {
        nextChild = child->nextSibling();
        element->removeChild(child.get(), ignoredExceptionCode);
        ASSERT(!ignoredExceptionCode);
        fragment->insertBefore(child, element, ignoredExceptionCode);
        ASSERT(!ignoredExceptionCode);
    }
    fragment->removeChild(element, ignoredExceptionCode);
    ASSERT(!ignoredExceptionCode);
}
",1
Detect whether the following code contains vulnerabilities.,"LayoutUnit RenderFlexibleBox::crossAxisExtentForChild(RenderBox* child) const
{
    return isHorizontalFlow() ? child->height() : child->width();
}
",0
Detect whether the following code contains vulnerabilities.,"  Ins_OR( INS_ARG )
  {
    DO_OR
  }
",0
Detect whether the following code contains vulnerabilities.," int SoundPool::load(int fd, int64_t offset, int64_t length, int priority __unused)
 {
     ALOGV(""load: fd=%d, offset=%"" PRId64 "", length=%"" PRId64 "", priority=%d"",
             fd, offset, length, priority);
    Mutex::Autolock lock(&mLock);
    sp<Sample> sample = new Sample(++mNextSampleID, fd, offset, length);
    mSamples.add(sample->sampleID(), sample);
    doLoad(sample);
    return sample->sampleID();
}
",1
Detect whether the following code contains vulnerabilities.,"media::AudioParameters GetDeviceParametersOnDeviceThread(
    media::AudioManager* audio_manager,
    const std::string& unique_id) {
  DCHECK(audio_manager->GetTaskRunner()->BelongsToCurrentThread());
  return media::AudioDeviceDescription::IsDefaultDevice(unique_id)
             ? audio_manager->GetDefaultOutputStreamParameters()
             : audio_manager->GetOutputStreamParameters(unique_id);
}
",1
Detect whether the following code contains vulnerabilities.,"void DiceResponseHandler::DeleteTokenFetcher(DiceTokenFetcher* token_fetcher) {
  for (auto it = token_fetchers_.begin(); it != token_fetchers_.end(); ++it) {
    if (it->get() == token_fetcher) {
      token_fetchers_.erase(it);
      return;
    }
  }
  NOTREACHED();
}
",0
Detect whether the following code contains vulnerabilities.,"static int kill_something_info(int sig, struct siginfo *info, pid_t pid)
{
	int ret;

	if (pid > 0) {
		rcu_read_lock();
		ret = kill_pid_info(sig, info, find_vpid(pid));
		rcu_read_unlock();
 		return ret;
 	}
 
 	read_lock(&tasklist_lock);
 	if (pid != -1) {
 		ret = __kill_pgrp_info(sig, info,
				pid ? find_vpid(-pid) : task_pgrp(current));
	} else {
		int retval = 0, count = 0;
		struct task_struct * p;

		for_each_process(p) {
			if (task_pid_vnr(p) > 1 &&
					!same_thread_group(p, current)) {
				int err = group_send_sig_info(sig, info, p);
				++count;
				if (err != -EPERM)
					retval = err;
			}
		}
		ret = count ? retval : -ESRCH;
	}
	read_unlock(&tasklist_lock);

	return ret;
}
",1
Detect whether the following code contains vulnerabilities.,"OMX_ERRORTYPE SoftRaw::internalGetParameter(
        OMX_INDEXTYPE index, OMX_PTR params) {
 switch (index) {
 case OMX_IndexParamAudioPcm:
 {

             OMX_AUDIO_PARAM_PCMMODETYPE *pcmParams =
                 (OMX_AUDIO_PARAM_PCMMODETYPE *)params;
 
             if (pcmParams->nPortIndex != 0 && pcmParams->nPortIndex != 1) {
                 return OMX_ErrorUndefined;
             }

            pcmParams->eNumData = OMX_NumericalDataSigned;
            pcmParams->eEndian = OMX_EndianBig;
            pcmParams->bInterleaved = OMX_TRUE;
            pcmParams->nBitPerSample = 16;
            pcmParams->ePCMMode = OMX_AUDIO_PCMModeLinear;
            pcmParams->eChannelMapping[0] = OMX_AUDIO_ChannelLF;
            pcmParams->eChannelMapping[1] = OMX_AUDIO_ChannelRF;

            pcmParams->nChannels = mChannelCount;
            pcmParams->nSamplingRate = mSampleRate;

 return OMX_ErrorNone;
 }

 default:
 return SimpleSoftOMXComponent::internalGetParameter(index, params);
 }
}
",1
Detect whether the following code contains vulnerabilities.,"static int parse_token(char **name, char **value, char **cp)
{
	char *end;

	if (!name || !value || !cp)
		return -BLKID_ERR_PARAM;

	if (!(*value = strchr(*cp, '=')))
		return 0;

	**value = '\0';
	*name = strip_line(*cp);
 	*value = skip_over_blank(*value + 1);
 
 	if (**value == '""') {
		end = strchr(*value + 1, '""');
		if (!end) {
 			DBG(READ, ul_debug(""unbalanced quotes at: %s"", *value));
 			*cp = *value;
 			return -BLKID_ERR_CACHE;
 		}
 		(*value)++;
 		*end = '\0';
		end++;
 	} else {
 		end = skip_over_word(*value);
 		if (*end) {
			*end = '\0';
			end++;
		}
	}
	*cp = end;

	return 1;
}
",1
Detect whether the following code contains vulnerabilities.,"ASN1_OBJECT *OBJ_txt2obj(const char *s, int no_name)
	{
	int nid = NID_undef;
	ASN1_OBJECT *op=NULL;
	unsigned char *buf;
	unsigned char *p;
	const unsigned char *cp;
	int i, j;

	if(!no_name) {
		if( ((nid = OBJ_sn2nid(s)) != NID_undef) ||
			((nid = OBJ_ln2nid(s)) != NID_undef) ) 
					return OBJ_nid2obj(nid);
	}

	/* Work out size of content octets */
	i=a2d_ASN1_OBJECT(NULL,0,s,-1);
	if (i <= 0) {
		/* Don't clear the error */
		/*ERR_clear_error();*/
		return NULL;
	}
	/* Work out total size */
	j = ASN1_object_size(0,i,V_ASN1_OBJECT);

	if((buf=(unsigned char *)OPENSSL_malloc(j)) == NULL) return NULL;

	p = buf;
	/* Write out tag+length */
	ASN1_put_object(&p,0,i,V_ASN1_OBJECT,V_ASN1_UNIVERSAL);
	/* Write out contents */
	a2d_ASN1_OBJECT(p,i,s,-1);

	cp=buf;
	op=d2i_ASN1_OBJECT(NULL,&cp,j);
	OPENSSL_free(buf);
	return op;
	}
",0
Detect whether the following code contains vulnerabilities.,"static int kvm_vm_ioctl_reinject(struct kvm *kvm,
				 struct kvm_reinject_control *control)
{
	if (!kvm->arch.vpit)
		return -ENXIO;
	mutex_lock(&kvm->arch.vpit->pit_state.lock);
	kvm->arch.vpit->pit_state.pit_timer.reinject = control->pit_reinject;
	mutex_unlock(&kvm->arch.vpit->pit_state.lock);
	return 0;
}
",0
Detect whether the following code contains vulnerabilities.,"static void perf_cgroup_attach(struct cgroup_taskset *tset)
{
	struct task_struct *task;
	struct cgroup_subsys_state *css;

	cgroup_taskset_for_each(task, css, tset)
		task_function_call(task, __perf_cgroup_move, task);
}
",0
Detect whether the following code contains vulnerabilities.,"void BinaryUploadService::IsAuthorized(AuthorizationCallback callback) {
  if (!timer_.IsRunning()) {
    timer_.Start(FROM_HERE, base::TimeDelta::FromHours(24), this,
                 &BinaryUploadService::ResetAuthorizationData);
  }

   if (!can_upload_data_.has_value()) {
     if (!pending_validate_data_upload_request_) {
      std::string dm_token = GetDMToken();
      if (dm_token.empty()) {
         std::move(callback).Run(false);
         return;
       }

      pending_validate_data_upload_request_ = true;
       auto request = std::make_unique<ValidateDataUploadRequest>(base::BindOnce(
           &BinaryUploadService::ValidateDataUploadRequestCallback,
           weakptr_factory_.GetWeakPtr()));
      request->set_dm_token(dm_token);
       UploadForDeepScanning(std::move(request));
     }
     authorization_callbacks_.push_back(std::move(callback));
    return;
  }
  std::move(callback).Run(can_upload_data_.value());
}
",1
Detect whether the following code contains vulnerabilities.,"void ServiceWorkerDevToolsAgentHost::AttachSession(DevToolsSession* session) {
  if (state_ == WORKER_READY) {
    if (sessions().size() == 1) {
      BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,
                               base::BindOnce(&SetDevToolsAttachedOnIO,
                                              context_weak_, version_id_, true));
     }
    session->SetRenderer(RenderProcessHost::FromID(worker_process_id_),
                         nullptr);
     session->AttachToAgent(agent_ptr_);
   }
   session->AddHandler(base::WrapUnique(new protocol::InspectorHandler()));
  session->AddHandler(base::WrapUnique(new protocol::NetworkHandler(GetId())));
  session->AddHandler(base::WrapUnique(new protocol::SchemaHandler()));
}
",1
Detect whether the following code contains vulnerabilities.,"static void anyAttributeAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TestObjectPython* imp = V8TestObjectPython::toNative(info.Holder());
    v8SetReturnValue(info, imp->anyAttribute().v8Value());
}
",0
Detect whether the following code contains vulnerabilities.,"struct sock *llc_sk_alloc(struct net *net, int family, gfp_t priority, struct proto *prot, int kern)
{
	struct sock *sk = sk_alloc(net, family, priority, prot, kern);

	if (!sk)
		goto out;
	llc_sk_init(sk);
	sock_init_data(NULL, sk);
#ifdef LLC_REFCNT_DEBUG
	atomic_inc(&llc_sock_nr);
	printk(KERN_DEBUG ""LLC socket %p created in %s, now we have %d alive\n"", sk,
		__func__, atomic_read(&llc_sock_nr));
#endif
out:
	return sk;
}
",0
Detect whether the following code contains vulnerabilities.,"static inline int qeth_get_initial_mtu_for_card(struct qeth_card *card)
{
	switch (card->info.type) {
	case QETH_CARD_TYPE_UNKNOWN:
		return 1500;
	case QETH_CARD_TYPE_IQD:
		return card->info.max_mtu;
	case QETH_CARD_TYPE_OSD:
		switch (card->info.link_type) {
		case QETH_LINK_TYPE_HSTR:
		case QETH_LINK_TYPE_LANE_TR:
			return 2000;
		default:
			return card->options.layer2 ? 1500 : 1492;
		}
	case QETH_CARD_TYPE_OSM:
	case QETH_CARD_TYPE_OSX:
		return card->options.layer2 ? 1500 : 1492;
	default:
		return 1500;
	}
}
",0
Detect whether the following code contains vulnerabilities.,"SPL_METHOD(SplFileObject, seek)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
 	long line_pos;
 	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""l"", &line_pos) == FAILURE) {
 		return;
 	}
 	if (line_pos < 0) {
 		zend_throw_exception_ex(spl_ce_LogicException, 0 TSRMLS_CC, ""Can't seek file %s to negative line %ld"", intern->file_name, line_pos);
		RETURN_FALSE;		
 	}
 	spl_filesystem_file_rewind(getThis(), intern TSRMLS_CC);
 	while(intern->u.file.current_line_num < line_pos) {
 		if (spl_filesystem_file_read_line(getThis(), intern, 1 TSRMLS_CC) == FAILURE) {
 			break;
		}
	}
} /* }}} */

/* {{{ Function/Class/Method definitions */
",1
Detect whether the following code contains vulnerabilities.,"void TypingCommand::insertText(Document& document,
                               const String& text,
                               Options options,
                               TextCompositionType composition,
                               const bool isIncrementalInsertion) {
  LocalFrame* frame = document.frame();
  DCHECK(frame);

  if (!text.isEmpty())
     document.frame()->spellChecker().updateMarkersForWordsAffectedByEditing(
         isSpaceOrNewline(text[0]));
 
  insertText(document, text,
             frame->selection().computeVisibleSelectionInDOMTreeDeprecated(),
             options, composition, isIncrementalInsertion);
 }
",1
Detect whether the following code contains vulnerabilities.,"void AffineTransform::recompose(const DecomposedType& decomp)
{
    this->setA(decomp.remainderA);
    this->setB(decomp.remainderB);
    this->setC(decomp.remainderC);
    this->setD(decomp.remainderD);
    this->setE(decomp.translateX);
    this->setF(decomp.translateY);
    this->rotateRadians(decomp.angle);
    this->scale(decomp.scaleX, decomp.scaleY);
}
",0
Detect whether the following code contains vulnerabilities.,"bool ProfileSyncService::IsSyncEnabledAndLoggedIn() {
  if (IsManaged() || sync_prefs_.IsStartSuppressed())
    return false;

  return !signin_->GetAuthenticatedUsername().empty();
}
",0
Detect whether the following code contains vulnerabilities.,"void xmlrpc_char_encode(char *outbuffer, const char *s1)
{
	long unsigned int i;
	unsigned char c;
	char buf2[15];
	mowgli_string_t *s = mowgli_string_create();
	*buf2 = '\0';
	*outbuffer = '\0';

	if ((!(s1) || (*(s1) == '\0')))
	{
		return;
	}

	for (i = 0; s1[i] != '\0'; i++)
	{
		c = s1[i];
		if (c > 127)
		{
			snprintf(buf2, sizeof buf2, ""&#%d;"", c);
			s->append(s, buf2, strlen(buf2));
		}
		else if (c == '&')
		{
			s->append(s, ""&amp;"", 5);
		}
		else if (c == '<')
		{
			s->append(s, ""&lt;"", 4);
		}
		else if (c == '>')
		{
			s->append(s, ""&gt;"", 4);
		}
		else if (c == '""')
		{
			s->append(s, ""&quot;"", 6);
		}
		else
		{
 			s->append_char(s, c);
 		}
 	}
 
	memcpy(outbuffer, s->str, XMLRPC_BUFSIZE);
 }
",1
Detect whether the following code contains vulnerabilities.,"  LocalSiteCharacteristicsWebContentsObserver* observer() {
    return observer_.get();
   }
",0
Detect whether the following code contains vulnerabilities.,"void exit_creds(struct task_struct *tsk)
{
	struct cred *cred;

	kdebug(""exit_creds(%u,%p,%p,{%d,%d})"", tsk->pid, tsk->real_cred, tsk->cred,
	       atomic_read(&tsk->cred->usage),
	       read_cred_subscribers(tsk->cred));

	cred = (struct cred *) tsk->real_cred;
	tsk->real_cred = NULL;
	validate_creds(cred);
	alter_cred_subscribers(cred, -1);
	put_cred(cred);

	cred = (struct cred *) tsk->cred;
	tsk->cred = NULL;
	validate_creds(cred);
	alter_cred_subscribers(cred, -1);
	put_cred(cred);

	cred = (struct cred *) tsk->replacement_session_keyring;
	if (cred) {
		tsk->replacement_session_keyring = NULL;
		validate_creds(cred);
		put_cred(cred);
	}
}
",0
Detect whether the following code contains vulnerabilities.,"void MojoJpegDecodeAccelerator::Decode(
    const BitstreamBuffer& bitstream_buffer,
    const scoped_refptr<VideoFrame>& video_frame) {
  DCHECK(io_task_runner_->BelongsToCurrentThread());
  DCHECK(jpeg_decoder_.is_bound());

  DCHECK(
      base::SharedMemory::IsHandleValid(video_frame->shared_memory_handle()));

  base::SharedMemoryHandle output_handle =
      base::SharedMemory::DuplicateHandle(video_frame->shared_memory_handle());
  if (!base::SharedMemory::IsHandleValid(output_handle)) {
    DLOG(ERROR) << ""Failed to duplicate handle of VideoFrame"";
    return;
  }

   size_t output_buffer_size = VideoFrame::AllocationSize(
       video_frame->format(), video_frame->coded_size());
   mojo::ScopedSharedBufferHandle output_frame_handle =
      mojo::WrapSharedMemoryHandle(output_handle, output_buffer_size,
                                   false /* read_only */);
 
   jpeg_decoder_->Decode(bitstream_buffer, video_frame->coded_size(),
                        std::move(output_frame_handle),
                        base::checked_cast<uint32_t>(output_buffer_size),
                        base::Bind(&MojoJpegDecodeAccelerator::OnDecodeAck,
                                   base::Unretained(this)));
}
",1
Detect whether the following code contains vulnerabilities.,"bt_status_t btif_storage_add_bonded_device(bt_bdaddr_t *remote_bd_addr,
                                           LINK_KEY link_key,
 uint8_t key_type,
 uint8_t pin_length)
{
 bdstr_t bdstr;
    bdaddr_to_string(remote_bd_addr, bdstr, sizeof(bdstr));

     int ret = btif_config_set_int(bdstr, ""LinkKeyType"", (int)key_type);
     ret &= btif_config_set_int(bdstr, ""PinLength"", (int)pin_length);
     ret &= btif_config_set_bin(bdstr, ""LinkKey"", link_key, sizeof(LINK_KEY));
     /* write bonded info immediately */
     btif_config_flush();
     return ret ? BT_STATUS_SUCCESS : BT_STATUS_FAIL;
}
",1
Detect whether the following code contains vulnerabilities.,"static void strictFunctionMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, ""strictFunction"", ""TestObject"", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 3)) {
        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
        exceptionState.throwIfNeeded();
        return;
    }
    TestObject* imp = V8TestObject::toNative(info.Holder());
    V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, str, info[0]);
    V8TRYCATCH_VOID(float, a, static_cast<float>(info[1]->NumberValue()));
    V8TRYCATCH_EXCEPTION_VOID(int, b, toInt32(info[2], exceptionState), exceptionState);
    bool result = imp->strictFunction(str, a, b, exceptionState);
    if (exceptionState.throwIfNeeded())
        return;
    v8SetReturnValueBool(info, result);
}
",0
Detect whether the following code contains vulnerabilities.,"DefaultAudioDestinationNode* DefaultAudioDestinationNode::Create(
    BaseAudioContext* context,
    const WebAudioLatencyHint& latency_hint) {
  return MakeGarbageCollected<DefaultAudioDestinationNode>(*context,
                                                           latency_hint);
}
",0
Detect whether the following code contains vulnerabilities.,"void MediaControlsProgressView::HandleSeeking(
    const gfx::Point& location_in_bar) {
   double seek_to_progress =
       static_cast<double>(location_in_bar.x()) / progress_bar_->width();
   seek_callback_.Run(seek_to_progress);
}
",1
Detect whether the following code contains vulnerabilities.,"bool TopSitesImpl::IsKnownURL(const GURL& url) {
  return loaded_ && cache_->IsKnownURL(url);
}
",0
Detect whether the following code contains vulnerabilities.,"static void detect_allow_debuggers(int argc, char **argv) {
	int i;
	
 	for (i = 1; i < argc; i++) {
 		if (strcmp(argv[i], ""--allow-debuggers"") == 0) {
 			arg_allow_debuggers = 1;
 			break;
 		}
		
		if (strcmp(argv[i], ""--"") == 0)
			break;
		if (strncmp(argv[i], ""--"", 2) != 0)
			break;
	}
}
",1
Detect whether the following code contains vulnerabilities.,"n_tty_receive_buf_closing(struct tty_struct *tty, const unsigned char *cp,
			  char *fp, int count)
{
	char flag = TTY_NORMAL;

	while (count--) {
		if (fp)
			flag = *fp++;
		if (likely(flag == TTY_NORMAL))
			n_tty_receive_char_closing(tty, *cp++);
		else
			n_tty_receive_char_flagged(tty, *cp++, flag);
	}
}
",0
Detect whether the following code contains vulnerabilities.,"void InspectorTraceEvents::Did(const probe::ParseHTML& probe) {
  TRACE_EVENT_END1(
      ""devtools.timeline"", ""ParseHTML"", ""endData"",
      InspectorParseHtmlEndData(probe.parser->LineNumber().ZeroBasedInt() - 1));
  TRACE_EVENT_INSTANT1(TRACE_DISABLED_BY_DEFAULT(""devtools.timeline""),
                       ""UpdateCounters"", TRACE_EVENT_SCOPE_THREAD, ""data"",
                       InspectorUpdateCountersEvent::Data());
}
",0
Detect whether the following code contains vulnerabilities.,"void DevToolsDownloadManagerDelegate::OnDownloadPathGenerated(
    uint32_t download_id,
    const content::DownloadTargetCallback& callback,
    const base::FilePath& suggested_path) {
  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
 
   callback.Run(suggested_path,
                content::DownloadItem::TARGET_DISPOSITION_OVERWRITE,
               download::DOWNLOAD_DANGER_TYPE_NOT_DANGEROUS,
                suggested_path.AddExtension(FILE_PATH_LITERAL("".crdownload"")),
                content::DOWNLOAD_INTERRUPT_REASON_NONE);
 }
",1
Detect whether the following code contains vulnerabilities.,"static void start_unregistering(struct ctl_table_header *p)
{
	/*
	 * if p->used is 0, nobody will ever touch that entry again;
	 * we'll eliminate all paths to it before dropping sysctl_lock
	 */
	if (unlikely(p->used)) {
		struct completion wait;
		init_completion(&wait);
		p->unregistering = &wait;
		spin_unlock(&sysctl_lock);
		wait_for_completion(&wait);
		spin_lock(&sysctl_lock);
	} else {
		/* anything non-NULL; we'll never dereference it */
		p->unregistering = ERR_PTR(-EINVAL);
	}
	/*
	 * do not remove from the list until nobody holds it; walking the
	 * list in do_sysctl() relies on that.
	 */
	erase_header(p);
}
",0
Detect whether the following code contains vulnerabilities.,"void WallpaperManager::OnWallpaperDecoded(
    const AccountId& account_id,
    const wallpaper::WallpaperInfo& info,
    bool update_wallpaper,
    MovableOnDestroyCallbackHolder on_finish,
    std::unique_ptr<user_manager::UserImage> user_image) {
  DCHECK_CURRENTLY_ON(BrowserThread::UI);
  TRACE_EVENT_ASYNC_END0(""ui"", ""LoadAndDecodeWallpaper"", this);

  if (user_image->image().isNull()) {
    wallpaper::WallpaperInfo default_info(
         """", wallpaper::WALLPAPER_LAYOUT_CENTER_CROPPED, wallpaper::DEFAULT,
         base::Time::Now().LocalMidnight());
     SetUserWallpaperInfo(account_id, default_info, true);
    if (update_wallpaper)
      DoSetDefaultWallpaper(account_id, std::move(on_finish));
     return;
   }
 
  wallpaper_cache_[account_id].second = user_image->image();

  if (update_wallpaper)
    SetWallpaper(user_image->image(), info);
}
",1
Detect whether the following code contains vulnerabilities.,"static void tcp_send_challenge_ack(struct sock *sk, const struct sk_buff *skb)
{
	/* unprotected vars, we dont care of overwrites */
 	static u32 challenge_timestamp;
 	static unsigned int challenge_count;
 	struct tcp_sock *tp = tcp_sk(sk);
	u32 now;
 
 	/* First check our per-socket dupack rate limit. */
 	if (tcp_oow_rate_limited(sock_net(sk), skb,
 				 LINUX_MIB_TCPACKSKIPPEDCHALLENGE,
 				 &tp->last_oow_ack_time))
 		return;
 
	/* Then check the check host-wide RFC 5961 rate limit. */
 	now = jiffies / HZ;
 	if (now != challenge_timestamp) {
 		challenge_timestamp = now;
		challenge_count = 0;
 	}
	if (++challenge_count <= sysctl_tcp_challenge_ack_limit) {
 		NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPCHALLENGEACK);
 		tcp_send_ack(sk);
 	}
}
",1
Detect whether the following code contains vulnerabilities.," static void addDataToStreamTask(void* context)
 {
     OwnPtr<BlobRegistryContext> blobRegistryContext = adoptPtr(static_cast<BlobRegistryContext*>(context));
    blobRegistry().addDataToStream(blobRegistryContext->url, blobRegistryContext->streamData);
 }
",1
Detect whether the following code contains vulnerabilities.,"build_config(char *prefix, struct server *server)
 {
     char *path    = NULL;
     int path_size = strlen(prefix) + strlen(server->port) + 20;

    path = ss_malloc(path_size);
    snprintf(path, path_size, ""%s/.shadowsocks_%s.conf"", prefix, server->port);
    FILE *f = fopen(path, ""w+"");
    if (f == NULL) {
        if (verbose) {
            LOGE(""unable to open config file"");
        }
        ss_free(path);
        return;
    }
     fprintf(f, ""{\n"");
     fprintf(f, ""\""server_port\"":%d,\n"", atoi(server->port));
     fprintf(f, ""\""password\"":\""%s\"""", server->password);
    if (server->fast_open[0]) fprintf(f, "",\n\""fast_open\"": %s"", server->fast_open);
    if (server->mode)   fprintf(f, "",\n\""mode\"":\""%s\"""", server->mode);
    if (server->method) fprintf(f, "",\n\""method\"":\""%s\"""", server->method);
    if (server->plugin) fprintf(f, "",\n\""plugin\"":\""%s\"""", server->plugin);
    if (server->plugin_opts) fprintf(f, "",\n\""plugin_opts\"":\""%s\"""", server->plugin_opts);
     fprintf(f, ""\n}\n"");
     fclose(f);
     ss_free(path);
}
",1
Detect whether the following code contains vulnerabilities.,"int git_index__changed_relative_to(
	git_index *index, const git_oid *checksum)
{
	/* attempt to update index (ignoring errors) */
	if (git_index_read(index, false) < 0)
		giterr_clear();

	return !!git_oid_cmp(&index->checksum, checksum);
}
",0
Detect whether the following code contains vulnerabilities.,"PHP_METHOD(Phar, getSupportedCompression)
{
        if (zend_parse_parameters_none() == FAILURE) {
                return;
        }
        array_init(return_value);
        phar_request_initialize(TSRMLS_C);
 
	if (PHAR_G(has_zlib)) {
		add_next_index_stringl(return_value, ""GZ"", 2, 1);
	}

	if (PHAR_G(has_bz2)) {
		add_next_index_stringl(return_value, ""BZIP2"", 5, 1);
	}
}
",1
Detect whether the following code contains vulnerabilities.,"static int key_notify_policy_flush(const struct km_event *c)
{
	struct sk_buff *skb_out;
	struct sadb_msg *hdr;

	skb_out = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);
	if (!skb_out)
		return -ENOBUFS;
	hdr = (struct sadb_msg *) skb_put(skb_out, sizeof(struct sadb_msg));
	hdr->sadb_msg_type = SADB_X_SPDFLUSH;
	hdr->sadb_msg_seq = c->seq;
 	hdr->sadb_msg_pid = c->portid;
 	hdr->sadb_msg_version = PF_KEY_V2;
 	hdr->sadb_msg_errno = (uint8_t) 0;
 	hdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));
 	pfkey_broadcast(skb_out, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);
 	return 0;

}
",1
Detect whether the following code contains vulnerabilities.,"long Chapters::Parse()
{
    IMkvReader* const pReader = m_pSegment->m_pReader;
    long long pos = m_start;  // payload start
    const long long stop = pos + m_size;  // payload stop
    while (pos < stop)
    {
        long long id, size;
        long status = ParseElementHeader(
                        pReader,
                        pos,
                        stop,
                        id,
                        size);
        if (status < 0)  // error
            return status;
        if (size == 0)  // weird
            continue;
        if (id == 0x05B9)  // EditionEntry ID
        {
            status = ParseEdition(pos, size);
            if (status < 0)  // error
                return status;
        }
        pos += size;
        assert(pos <= stop);
     }
 
    assert(pos == stop);
    return 0;
 }
",1
Detect whether the following code contains vulnerabilities.,"static struct mt_connection *list_find_connection(unsigned short seskey, unsigned char *srcmac) {
	struct mt_connection *p;

	DL_FOREACH(connections_head, p) {
		if (p->seskey == seskey && memcmp(srcmac, p->srcmac, ETH_ALEN) == 0) {
			return p;
		}
	}

	return NULL;
}
",0
Detect whether the following code contains vulnerabilities.,"static void charstring_end(void)
{
  byte *bp;

  sprintf(line, ""%d "", (int) (charstring_bp - charstring_buf));
  eexec_string(line);
  sprintf(line, ""%s "", cs_start);
  eexec_string(line);
  for (bp = charstring_buf; bp < charstring_bp; bp++)
    eexec_byte(*bp);
}
",0
Detect whether the following code contains vulnerabilities.,"bool ParseRequestInfo(const struct mg_request_info* const request_info,
                      std::string* method,
                      std::vector<std::string>* path_segments,
                      DictionaryValue** parameters,
                      Response* const response) {
  *method = request_info->request_method;
  if (*method == ""HEAD"")
    *method = ""GET"";
  else if (*method == ""PUT"")
    *method = ""POST"";

  std::string uri(request_info->uri);
  SessionManager* manager = SessionManager::GetInstance();
  uri = uri.substr(manager->url_base().length());

   base::SplitString(uri, '/', path_segments);
 
   if (*method == ""POST"" && request_info->post_data_len > 0) {
    VLOG(1) << ""...parsing request body"";
     std::string json(request_info->post_data, request_info->post_data_len);
    std::string error;
    if (!ParseJSONDictionary(json, parameters, &error)) {
       response->SetError(new Error(
           kBadRequest,
          ""Failed to parse command data: "" + error + ""\n  Data: "" + json));
       return false;
     }
   }
  VLOG(1) << ""Parsed "" << method << "" "" << uri
        << std::string(request_info->post_data, request_info->post_data_len);
   return true;
 }
",1
Detect whether the following code contains vulnerabilities.,"void vfio_pci_intx_mask(struct vfio_pci_device *vdev)
{
	struct pci_dev *pdev = vdev->pdev;
	unsigned long flags;

	spin_lock_irqsave(&vdev->irqlock, flags);

	/*
	 * Masking can come from interrupt, ioctl, or config space
	 * via INTx disable.  The latter means this can get called
	 * even when not using intx delivery.  In this case, just
	 * try to have the physical bit follow the virtual bit.
	 */
	if (unlikely(!is_intx(vdev))) {
		if (vdev->pci_2_3)
			pci_intx(pdev, 0);
	} else if (!vdev->ctx[0].masked) {
		/*
		 * Can't use check_and_mask here because we always want to
		 * mask, not just when something is pending.
		 */
		if (vdev->pci_2_3)
			pci_intx(pdev, 0);
		else
			disable_irq_nosync(pdev->irq);

		vdev->ctx[0].masked = true;
	}

	spin_unlock_irqrestore(&vdev->irqlock, flags);
}
",0
Detect whether the following code contains vulnerabilities.,"error_detected(uint32_t errnum, char *errstr, ...)
{
    va_list args;

    va_start(args, errstr);

    {
        TSK_ERROR_INFO *errInfo = tsk_error_get_info();
        char *loc_errstr = errInfo->errstr;

        if (errInfo->t_errno == 0)
            errInfo->t_errno = errnum;
        else {
            size_t sl = strlen(errstr);
            snprintf(loc_errstr + sl, TSK_ERROR_STRING_MAX_LENGTH - sl,
                "" Next errnum: 0x%x "", errnum);
        }
        if (errstr != NULL) {
            size_t sl = strlen(loc_errstr);
            vsnprintf(loc_errstr + sl, TSK_ERROR_STRING_MAX_LENGTH - sl,
                errstr, args);
        }
    }

    va_end(args);

}
",0
Detect whether the following code contains vulnerabilities.," static grub_err_t read_foo (struct grub_disk *disk, grub_disk_addr_t sector, grub_size_t size, char *buf) {
	if (disk != NULL) {
		const int blocksize = 512; // unhardcode 512
		int ret;
		RIOBind *iob = disk->data;
		if (bio) iob = bio;
		ret = iob->read_at (iob->io, delta+(blocksize*sector),
			(ut8*)buf, size*blocksize);
		if (ret == -1)
			return 1;
	} else eprintf (""oops. no disk\n"");
	return 0; // 0 is ok
 }
",1
Detect whether the following code contains vulnerabilities.,"void CameraSource::signalBufferReturned(MediaBuffer *buffer) {
    ALOGV(""signalBufferReturned: %p"", buffer->data());
 Mutex::Autolock autoLock(mLock);

     for (List<sp<IMemory> >::iterator it = mFramesBeingEncoded.begin();
          it != mFramesBeingEncoded.end(); ++it) {
         if ((*it)->pointer() ==  buffer->data()) {
             releaseOneRecordingFrame((*it));
             mFramesBeingEncoded.erase(it);
             ++mNumFramesEncoded;
            buffer->setObserver(0);
            buffer->release();
            mFrameCompleteCondition.signal();
 return;
 }
 }
    CHECK(!""signalBufferReturned: bogus buffer"");
}
",1
Detect whether the following code contains vulnerabilities.,"void Dispatcher::OnShouldSuspend(const std::string& extension_id,
                                 uint64_t sequence_id) {
  RenderThread::Get()->Send(
      new ExtensionHostMsg_ShouldSuspendAck(extension_id, sequence_id));
}
",0
Detect whether the following code contains vulnerabilities.,"const base::Time& BaseNode::GetModificationTime() const {
   return GetEntry()->Get(syncable::MTIME);
 }
",1
Detect whether the following code contains vulnerabilities.,"static void renew_lease(const struct nfs_server *server, unsigned long timestamp)
{
	struct nfs_client *clp = server->nfs_client;

	if (!nfs4_has_session(clp))
		do_renew_lease(clp, timestamp);
}
",0
Detect whether the following code contains vulnerabilities.," static void ReconfigureImpl(Handle<JSObject> object,
 Handle<FixedArrayBase> store, uint32_t entry,
 Handle<Object> value,
 PropertyAttributes attributes) {
    UNREACHABLE();
 }
",0
Detect whether the following code contains vulnerabilities.,"static zend_always_inline uint32_t zend_array_dup_elements(HashTable *source, HashTable *target, int static_keys, int with_holes)
{
	uint32_t idx = 0;
	Bucket *p = source->arData;
	Bucket *q = target->arData;
	Bucket *end = p + source->nNumUsed;

	do {
		if (!zend_array_dup_element(source, target, idx, p, q, 0, static_keys, with_holes)) {
			uint32_t target_idx = idx;

			idx++; p++;
			while (p != end) {
				if (zend_array_dup_element(source, target, target_idx, p, q, 0, static_keys, with_holes)) {
					if (source->nInternalPointer == idx) {
						target->nInternalPointer = target_idx;
					}
					target_idx++; q++;
				}
				idx++; p++;
			}
			return target_idx;
		}
		idx++; p++; q++;
	} while (p != end);
	return idx;
}
",0
Detect whether the following code contains vulnerabilities.,"static void PerWorldBindingsRuntimeEnabledVoidMethodMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  TestObject* impl = V8TestObject::ToImpl(info.Holder());

  impl->perWorldBindingsRuntimeEnabledVoidMethod();
}
",0
Detect whether the following code contains vulnerabilities.,"static int command_read(struct pci_dev *dev, int offset, u16 *value, void *data)
 {
	int i;
	int ret;
	ret = xen_pcibk_read_config_word(dev, offset, value, data);
	if (!pci_is_enabled(dev))
		return ret;
	for (i = 0; i < PCI_ROM_RESOURCE; i++) {
		if (dev->resource[i].flags & IORESOURCE_IO)
			*value |= PCI_COMMAND_IO;
		if (dev->resource[i].flags & IORESOURCE_MEM)
			*value |= PCI_COMMAND_MEMORY;
 	}
 
 	return ret;
 }
",1
Detect whether the following code contains vulnerabilities.,"bool IsURLAllowedInIncognito(const GURL& url) {
  return url.scheme() == chrome::kChromeUIScheme &&
      (url.host() == chrome::kChromeUISettingsHost ||
       url.host() == chrome::kChromeUIExtensionsHost ||
       url.host() == chrome::kChromeUIBookmarksHost);
}
",0
Detect whether the following code contains vulnerabilities.," FileStream::FileStream(base::File file,
                        const scoped_refptr<base::TaskRunner>& task_runner)
    : context_(base::MakeUnique<Context>(std::move(file), task_runner)) {}
",1
Detect whether the following code contains vulnerabilities.,"static void print_errors(void)
{
	DPRINT("""");
	if (ST0 & ST0_ECE) {
		pr_cont(""Recalibrate failed!"");
	} else if (ST2 & ST2_CRC) {
		pr_cont(""data CRC error"");
		tell_sector();
	} else if (ST1 & ST1_CRC) {
		pr_cont(""CRC error"");
		tell_sector();
	} else if ((ST1 & (ST1_MAM | ST1_ND)) ||
		   (ST2 & ST2_MAM)) {
		if (!probing) {
			pr_cont(""sector not found"");
			tell_sector();
		} else
			pr_cont(""probe failed..."");
	} else if (ST2 & ST2_WC) {	/* seek error */
		pr_cont(""wrong cylinder"");
	} else if (ST2 & ST2_BC) {	/* cylinder marked as bad */
		pr_cont(""bad cylinder"");
	} else {
		pr_cont(""unknown error. ST[0..2] are: 0x%x 0x%x 0x%x"",
			ST0, ST1, ST2);
		tell_sector();
	}
	pr_cont(""\n"");
}
",0
Detect whether the following code contains vulnerabilities.,"static int jpeg_size(unsigned char* data, unsigned int data_size,
                     int *width, int *height)
{
    int i = 0;
    if (i + 3 < data_size && data[i] == 0xFF && data[i+1] == 0xD8 &&
            data[i+2] == 0xFF && data[i+3] == 0xE0) {
        i += 4;
        if(i + 6 < data_size &&
                data[i+2] == 'J' && data[i+3] == 'F' && data[i+4] == 'I' &&
                data[i+5] == 'F' && data[i+6] == 0x00) {
            unsigned short block_length = data[i] * 256 + data[i+1];
            while(i<data_size) {
                i+=block_length;
                if((i + 1) >= data_size)
                    return -1;
                if(data[i] != 0xFF)
                    return -1;
                if(data[i+1] == 0xC0) {
                    *height = data[i+5]*256 + data[i+6];
                    *width = data[i+7]*256 + data[i+8];
                     return 0;
                 }
                 i+=2;
                block_length = data[i] * 256 + data[i+1];
             }
         }
     }

    return -1;
}
",1
Detect whether the following code contains vulnerabilities.,"static unsigned next_desc(struct vhost_virtqueue *vq, struct vring_desc *desc)
{
	unsigned int next;

	/* If this descriptor says it doesn't chain, we're done. */
	if (!(desc->flags & cpu_to_vhost16(vq, VRING_DESC_F_NEXT)))
		return -1U;

	/* Check they're not leading us off end of descriptors. */
	next = vhost16_to_cpu(vq, desc->next);
	/* Make sure compiler knows to grab that: we don't want it changing! */
	/* We will use the result as an index in an array, so most
	 * architectures only need a compiler barrier here. */
	read_barrier_depends();

	return next;
}
",0
Detect whether the following code contains vulnerabilities.,"base::FilePath ChromeContentBrowserClient::GetShaderDiskCacheDirectory() {
  base::FilePath user_data_dir;
  base::PathService::Get(chrome::DIR_USER_DATA, &user_data_dir);
  DCHECK(!user_data_dir.empty());
  return user_data_dir.Append(FILE_PATH_LITERAL(""ShaderCache""));
}
",0
Detect whether the following code contains vulnerabilities.,"gx_dc_colored_masked_get_dev_halftone(const gx_device_color * pdevc)
{
    return pdevc->colors.colored.c_ht;
}
",0
Detect whether the following code contains vulnerabilities.,"status_t MediaPlayerService::Client::setNextPlayer(const sp<IMediaPlayer>& player) {

     ALOGV(""setNextPlayer"");
     Mutex::Autolock l(mLock);
     sp<Client> c = static_cast<Client*>(player.get());
     mNextClient = c;
 
     if (c != NULL) {
 if (mAudioOutput != NULL) {
            mAudioOutput->setNextOutput(c->mAudioOutput);
 } else if ((mPlayer != NULL) && !mPlayer->hardwareOutput()) {
            ALOGE(""no current audio output"");
 }

 if ((mPlayer != NULL) && (mNextClient->getPlayer() != NULL)) {
            mPlayer->setNextPlayer(mNextClient->getPlayer());
 }
 }

 return OK;
}
",1
Detect whether the following code contains vulnerabilities.,"bool BrowserView::HasClientEdge() const {
  return frame()->GetFrameView()->HasClientEdge();
}
",0
Detect whether the following code contains vulnerabilities.,"ssh_packet_backup_state(struct ssh *ssh,
    struct ssh *backup_state)
{
	struct ssh *tmp;

	close(ssh->state->connection_in);
	ssh->state->connection_in = -1;
	close(ssh->state->connection_out);
	ssh->state->connection_out = -1;
	if (backup_state)
		tmp = backup_state;
	else
		tmp = ssh_alloc_session_state();
	backup_state = ssh;
	ssh = tmp;
}
",0
Detect whether the following code contains vulnerabilities.,"string16 ExtensionGlobalError::GenerateMessageSection(
    const ExtensionIdSet* extensions,
    int template_message_id) {
  CHECK(extensions);
  CHECK(template_message_id);
  string16 message;

   for (ExtensionIdSet::const_iterator iter = extensions->begin();
        iter != extensions->end(); ++iter) {
     const Extension* e = extension_service_->GetExtensionById(*iter, true);
    message += l10n_util::GetStringFUTF16(
        template_message_id,
        string16(ASCIIToUTF16(e->name())),
        l10n_util::GetStringUTF16(IDS_SHORT_PRODUCT_NAME));
   }
   return message;
 }
",1
Detect whether the following code contains vulnerabilities.," image_transform_png_set_strip_16_add(image_transform *this,
    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
 {
    UNUSED(colour_type)
 
 this->next = *that;
 *that = this;

 return bit_depth > 8;
}
",1
Detect whether the following code contains vulnerabilities.,"int lxc_clear_environment(struct lxc_conf *c)
{
	struct lxc_list *it,*next;

	lxc_list_for_each_safe(it, &c->environment, next) {
		lxc_list_del(it);
		free(it->elem);
		free(it);
	}
	return 0;
}
",0
Detect whether the following code contains vulnerabilities.,"  CurrentThreadMock()
      : task_runner_delegate_(
            scheduler::LazySchedulerMessageLoopDelegateForTests::Create()),
        scheduler_(
            new scheduler::RendererSchedulerImpl(task_runner_delegate_.get())),
        web_scheduler_(
            new scheduler::RendererWebSchedulerImpl(scheduler_.get())),
        web_task_runner_(
            new scheduler::WebTaskRunnerImpl(scheduler_->DefaultTaskRunner())) {
  }
",0
Detect whether the following code contains vulnerabilities.," void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(
     JNIEnv* env,
    mojo::ScopedSharedBufferMapping mapping,
     const CreateSensorCallback& callback) {
   ScopedJavaLocalRef<jobject> sensor = Java_PlatformSensorProvider_createSensor(
       env, j_object_,
       static_cast<jint>(mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION));
 
   if (sensor.obj()) {
     auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(
        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, std::move(mapping),
         this, sensor);
 
     callback.Run(concrete_sensor);
  } else {
    auto sensor_fusion_algorithm =
        std::make_unique<OrientationQuaternionFusionAlgorithmUsingEulerAngles>(
            true /* absolute */);
 
    PlatformSensorFusion::Create(std::move(mapping), this,
                                  std::move(sensor_fusion_algorithm), callback);
   }
 }
",1
Detect whether the following code contains vulnerabilities.,"ext4_xattr_create_cache(char *name)
 {
	return mb_cache_create(name, HASH_BUCKET_BITS);
 }
",1
Detect whether the following code contains vulnerabilities.,"jas_matrix_t *jas_seq2d_create(int xstart, int ystart, int xend, int yend)
 {
 	jas_matrix_t *matrix;
 	assert(xstart <= xend && ystart <= yend);
	if (!(matrix = jas_matrix_create(yend - ystart, xend - xstart))) {
		return 0;
	}
	matrix->xstart_ = xstart;
	matrix->ystart_ = ystart;
	matrix->xend_ = xend;
	matrix->yend_ = yend;
 	return matrix;
 }
",1
Detect whether the following code contains vulnerabilities.," struct bpf_map *bpf_map_get_with_uref(u32 ufd)
{
	struct fd f = fdget(ufd);
	struct bpf_map *map;

	map = __bpf_map_get(f);
 	if (IS_ERR(map))
 		return map;
 
	bpf_map_inc(map, true);
 	fdput(f);
 
 	return map;
}
",1
Detect whether the following code contains vulnerabilities.,"static __always_inline int __do_follow_link(struct path *path, struct nameidata *nd)
{
	int error;
	void *cookie;
	struct dentry *dentry = path->dentry;

	touch_atime(path->mnt, dentry);
	nd_set_link(nd, NULL);

	if (path->mnt != nd->path.mnt) {
		path_to_nameidata(path, nd);
 		dget(dentry);
 	}
 	mntget(path->mnt);
 	cookie = dentry->d_inode->i_op->follow_link(dentry, nd);
 	error = PTR_ERR(cookie);
 	if (!IS_ERR(cookie)) {
		char *s = nd_get_link(nd);
		error = 0;
		if (s)
			error = __vfs_follow_link(nd, s);
		else if (nd->last_type == LAST_BIND) {
			error = force_reval_path(&nd->path, nd);
			if (error)
				path_put(&nd->path);
		}
		if (dentry->d_inode->i_op->put_link)
			dentry->d_inode->i_op->put_link(dentry, nd, cookie);
	}
	return error;
}
",1
Detect whether the following code contains vulnerabilities.," bool MessageLoop::DoDelayedWork(TimeTicks* next_delayed_work_time) {
  if (!nestable_tasks_allowed_ ||
       !SweepDelayedWorkQueueAndReturnTrueIfStillHasWork()) {
     recent_time_ = *next_delayed_work_time = TimeTicks();
     return false;
  }


  TimeTicks next_run_time = delayed_work_queue_.top().delayed_run_time;
  if (next_run_time > recent_time_) {
    recent_time_ = TimeTicks::Now();  // Get a better view of Now();
    if (next_run_time > recent_time_) {
      *next_delayed_work_time = next_run_time;
      return false;
    }
  }

  PendingTask pending_task =
      std::move(const_cast<PendingTask&>(delayed_work_queue_.top()));
  delayed_work_queue_.pop();

  if (SweepDelayedWorkQueueAndReturnTrueIfStillHasWork())
    *next_delayed_work_time = delayed_work_queue_.top().delayed_run_time;

  return DeferOrRunPendingTask(std::move(pending_task));
}
",1
Detect whether the following code contains vulnerabilities.,"static void xfrm6_tunnel_spi_fini(void)
{
	kmem_cache_destroy(xfrm6_tunnel_spi_kmem);
}
",1
Detect whether the following code contains vulnerabilities.,"store_image_check(PNG_CONST png_store* ps, png_const_structp pp, int iImage)
 {
    png_const_bytep image = ps->image;
 
 if (image[-1] != 0xed || image[ps->cb_image] != 0xfe)
      png_error(pp, ""image overwrite"");
 else
 {
 png_size_t cbRow = ps->cb_row;
      png_uint_32 rows = ps->image_h;

      image += iImage * (cbRow+5) * ps->image_h;

      image += 2; /* skip image first row markers */

 while (rows-- > 0)
 {
 if (image[-2] != 190 || image[-1] != 239)
            png_error(pp, ""row start overwritten"");

 if (image[cbRow] != 222 || image[cbRow+1] != 173 ||
            image[cbRow+2] != 17)
            png_error(pp, ""row end overwritten"");

         image += cbRow+5;
 }
 }
}
",1
Detect whether the following code contains vulnerabilities.,"void GLES2DecoderImpl::DoGetTexParameteriv(
    GLenum target, GLenum pname, GLint* params) {
  InitTextureMaxAnisotropyIfNeeded(target, pname);
  glGetTexParameteriv(target, pname, params);
}
",0
Detect whether the following code contains vulnerabilities.,"GURL DecorateFrontendURL(const GURL& base_url) {
  std::string frontend_url = base_url.spec();
  std::string url_string(
      frontend_url +
      ((frontend_url.find(""?"") == std::string::npos) ? ""?"" : ""&"") +
      ""dockSide=undocked""); // TODO(dgozman): remove this support in M38.
  base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
  if (command_line->HasSwitch(switches::kEnableDevToolsExperiments))
     url_string += ""&experiments=true"";
 
   if (command_line->HasSwitch(switches::kDevToolsFlags)) {
    std::string flags = command_line->GetSwitchValueASCII(
                            switches::kDevToolsFlags);
    flags = net::EscapeQueryParamValue(flags, false);
    url_string += ""&flags="" + flags;
   }
 
 #if defined(DEBUG_DEVTOOLS)
  url_string += ""&debugFrontend=true"";
#endif  // defined(DEBUG_DEVTOOLS)

  return GURL(url_string);
}
",1
Detect whether the following code contains vulnerabilities.,"   virtual bool InputMethodIsActivated(const std::string& input_method_id) {
    scoped_ptr<InputMethodDescriptors> active_input_method_descriptors(
        GetActiveInputMethods());
     for (size_t i = 0; i < active_input_method_descriptors->size(); ++i) {
       if (active_input_method_descriptors->at(i).id == input_method_id) {
         return true;
      }
    }
    return false;
  }
",1
Detect whether the following code contains vulnerabilities.,"static int crypto_authenc_verify(struct aead_request *req,
				 authenc_ahash_t authenc_ahash_fn)
{
	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
	struct authenc_request_ctx *areq_ctx = aead_request_ctx(req);
	u8 *ohash;
	u8 *ihash;
	unsigned int authsize;

	areq_ctx->complete = authenc_verify_ahash_done;
	areq_ctx->update_complete = authenc_verify_ahash_update_done;

	ohash = authenc_ahash_fn(req, CRYPTO_TFM_REQ_MAY_SLEEP);
	if (IS_ERR(ohash))
		return PTR_ERR(ohash);

	authsize = crypto_aead_authsize(authenc);
	ihash = ohash + authsize;
	scatterwalk_map_and_copy(ihash, areq_ctx->sg, areq_ctx->cryptlen,
				 authsize, 0);
	return crypto_memneq(ihash, ohash, authsize) ? -EBADMSG : 0;
}
",0
Detect whether the following code contains vulnerabilities.,"void acpi_os_printf(const char *fmt, ...)
{
	va_list args;
	va_start(args, fmt);
	acpi_os_vprintf(fmt, args);
	va_end(args);
}
",0
Detect whether the following code contains vulnerabilities.," static void perf_swevent_overflow(struct perf_event *event, u64 overflow,
				    int nmi, struct perf_sample_data *data,
 				    struct pt_regs *regs)
 {
 	struct hw_perf_event *hwc = &event->hw;
	int throttle = 0;

	data->period = event->hw.last_period;
	if (!overflow)
		overflow = perf_swevent_set_period(event);

	if (hwc->interrupts == MAX_INTERRUPTS)
 		return;
 
 	for (; overflow; overflow--) {
		if (__perf_event_overflow(event, nmi, throttle,
 					    data, regs)) {
 			/*
 			 * We inhibit the overflow from happening when
			 * hwc->interrupts == MAX_INTERRUPTS.
			 */
			break;
		}
		throttle = 1;
	}
 }
",1
Detect whether the following code contains vulnerabilities.,"static bool arg_type_is_refcounted(enum bpf_arg_type type)
{
	return type == ARG_PTR_TO_SOCKET;
}
",0
Detect whether the following code contains vulnerabilities.,"static int sysMapFD(int fd, MemMapping* pMap)
{
 off_t start;
 size_t length;
 void* memPtr;

    assert(pMap != NULL);

 if (getFileStartAndLength(fd, &start, &length) < 0)
 return -1;

    memPtr = mmap(NULL, length, PROT_READ, MAP_PRIVATE, fd, start);
 if (memPtr == MAP_FAILED) {
        LOGW(""mmap(%d, R, PRIVATE, %d, %d) failed: %s\n"", (int) length,
            fd, (int) start, strerror(errno));
 return -1;
 }

    pMap->addr = memPtr;

     pMap->length = length;
     pMap->range_count = 1;
     pMap->ranges = malloc(sizeof(MappedRange));
     pMap->ranges[0].addr = memPtr;
     pMap->ranges[0].length = length;
 
 return 0;
}
",1
Detect whether the following code contains vulnerabilities.," static enum AVPixelFormat h263_get_format(AVCodecContext *avctx)
 {
     /* MPEG-4 Studio Profile only, not supported by hardware */
     if (avctx->bits_per_raw_sample > 8) {
        av_assert1(avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);
         return avctx->pix_fmt;
     }
 
    if (avctx->codec->id == AV_CODEC_ID_MSS2)
        return AV_PIX_FMT_YUV420P;

    if (CONFIG_GRAY && (avctx->flags & AV_CODEC_FLAG_GRAY)) {
        if (avctx->color_range == AVCOL_RANGE_UNSPECIFIED)
            avctx->color_range = AVCOL_RANGE_MPEG;
        return AV_PIX_FMT_GRAY8;
    }

    return avctx->pix_fmt = ff_get_format(avctx, avctx->codec->pix_fmts);
}
",1
Detect whether the following code contains vulnerabilities.,"void *load_device_tree(const char *filename_path, int *sizep)
{
    int dt_size;
    int dt_file_load_size;
    int ret;
    void *fdt = NULL;

    *sizep = 0;
    dt_size = get_image_size(filename_path);
    if (dt_size < 0) {
        error_report(""Unable to get size of device tree file '%s'"",
                     filename_path);
        goto fail;
    }

    /* Expand to 2x size to give enough room for manipulation.  */
    dt_size += 10000;
    dt_size *= 2;
     /* First allocate space in qemu for device tree */
     fdt = g_malloc0(dt_size);
 
    dt_file_load_size = load_image(filename_path, fdt);
     if (dt_file_load_size < 0) {
         error_report(""Unable to open device tree file '%s'"",
                      filename_path);
        goto fail;
    }

    ret = fdt_open_into(fdt, fdt, dt_size);
    if (ret) {
        error_report(""Unable to copy device tree in memory"");
        goto fail;
    }

    /* Check sanity of device tree */
    if (fdt_check_header(fdt)) {
        error_report(""Device tree file loaded into memory is invalid: %s"",
                     filename_path);
        goto fail;
    }
    *sizep = dt_size;
    return fdt;

fail:
    g_free(fdt);
    return NULL;
}
",1
Detect whether the following code contains vulnerabilities.," static void DeleteImpl(Handle<JSObject> obj, uint32_t entry) {
 Handle<SeededNumberDictionary> dict(
 SeededNumberDictionary::cast(obj->elements()));
 uint32_t index = GetIndexForEntryImpl(*dict, entry);
 Handle<Object> result = SeededNumberDictionary::DeleteProperty(dict, entry);
    USE(result);
    DCHECK(result->IsTrue(dict->GetIsolate()));
 Handle<FixedArray> new_elements =
 SeededNumberDictionary::Shrink(dict, index);
    obj->set_elements(*new_elements);
 }
",0
Detect whether the following code contains vulnerabilities.,"dissect_spoolss_keybuffer(tvbuff_t *tvb, int offset, packet_info *pinfo,
			  proto_tree *tree, dcerpc_info *di, guint8 *drep)
{
	guint32 size;
	int end_offset;

	if (di->conformant_run)
		return offset;

	/* Dissect size and data */

	offset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,
				    hf_keybuffer_size, &size);

	end_offset = offset + (size*2);
	if (end_offset < offset) {
		/*
		 * Overflow - make the end offset one past the end of
		 * the packet data, so we throw an exception (as the
		 * size is almost certainly too big).
		 */
 		end_offset = tvb_reported_length_remaining(tvb, offset) + 1;
 	}
 
	while (offset < end_offset)
 		offset = dissect_spoolss_uint16uni(
 			tvb, offset, pinfo, tree, drep, NULL, hf_keybuffer);
 
 	return offset;
 }
",1
Detect whether the following code contains vulnerabilities.,"PasswordAutofillAgent::PasswordAutofillAgent(content::RenderFrame* render_frame)
     : content::RenderFrameObserver(render_frame),
       logging_state_active_(false),
       was_username_autofilled_(false),
      was_password_autofilled_(false),
      weak_ptr_factory_(this) {
   Send(new AutofillHostMsg_PasswordAutofillAgentConstructed(routing_id()));
 }
",1
Detect whether the following code contains vulnerabilities.,"timeval_equals(struct timeval * tv0, struct timeval * tv1)
{
    if ( tv0->tv_sec == tv1->tv_sec && tv0->tv_usec == tv1->tv_usec )
	return 1;
    else
	return 0;
}
",0
Detect whether the following code contains vulnerabilities.," PrintPreviewUI::PrintPreviewUI(content::WebUI* web_ui)
     : ConstrainedWebDialogUI(web_ui),
       initial_preview_start_time_(base::TimeTicks::Now()),
       handler_(NULL),
       source_is_modifiable_(true),
       tab_closed_(false) {
  Profile* profile = Profile::FromWebUI(web_ui);
  ChromeURLDataManager::AddDataSource(profile, new PrintPreviewDataSource());

   handler_ = new PrintPreviewHandler();
   web_ui->AddMessageHandler(handler_);
 
  preview_ui_addr_str_ = GetPrintPreviewUIAddress();
  g_print_preview_request_id_map.Get().Set(preview_ui_addr_str_, -1);
 }
",1
Detect whether the following code contains vulnerabilities.,"  void RegisterProperties(IBusPropList* ibus_prop_list) {
    DLOG(INFO) << ""RegisterProperties"" << (ibus_prop_list ? """" : "" (clear)"");
 
     ImePropertyList prop_list;  // our representation.
     if (ibus_prop_list) {
       if (!FlattenPropertyList(ibus_prop_list, &prop_list)) {
        RegisterProperties(NULL);
         return;
       }
     }
    register_ime_properties_(language_library_, prop_list);
  }
",1
Detect whether the following code contains vulnerabilities.,"static int transport_read_nonblocking(rdpTransport* transport)
{
	int status;

	status = transport_read(transport, transport->ReceiveBuffer);

	if (status <= 0)
		return status;

	Stream_Seek(transport->ReceiveBuffer, status);

	return status;
}
",0
Detect whether the following code contains vulnerabilities.,"void GLES2DecoderImpl::DoScheduleCALayerInUseQueryCHROMIUM(
    GLsizei count,
    const volatile GLuint* textures) {
  std::vector<gl::GLSurface::CALayerInUseQuery> queries;
  queries.reserve(count);
  for (GLsizei i = 0; i < count; ++i) {
    gl::GLImage* image = nullptr;
    GLuint texture_id = textures[i];
    if (texture_id) {
      TextureRef* ref = texture_manager()->GetTexture(texture_id);
      if (!ref) {
        LOCAL_SET_GL_ERROR(GL_INVALID_VALUE,
                           ""glScheduleCALayerInUseQueryCHROMIUM"",
                           ""unknown texture"");
        return;
      }
      Texture::ImageState image_state;
      image = ref->texture()->GetLevelImage(ref->texture()->target(), 0,
                                            &image_state);
    }
    gl::GLSurface::CALayerInUseQuery query;
    query.image = image;
    query.texture = texture_id;
    queries.push_back(query);
  }

  surface_->ScheduleCALayerInUseQuery(std::move(queries));
}
",0
Detect whether the following code contains vulnerabilities.,"static EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionOverloadedMethod6(ExecState* exec)
{
    JSValue thisValue = exec->hostThisValue();
    if (!thisValue.inherits(&JSTestObj::s_info))
        return throwVMTypeError(exec);
    JSTestObj* castedThis = jsCast<JSTestObj*>(asObject(thisValue));
     ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);
     TestObj* impl = static_cast<TestObj*>(castedThis->impl());
     if (exec->argumentCount() < 1)
        return throwVMError(exec, createTypeError(exec, ""Not enough arguments""));
     DOMStringList* listArg(toDOMStringList(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));
     if (exec->hadException())
         return JSValue::encode(jsUndefined());
    impl->overloadedMethod(listArg);
    return JSValue::encode(jsUndefined());
}
",1
Detect whether the following code contains vulnerabilities.,"XGetModifierMapping(register Display *dpy)
{
    xGetModifierMappingReply rep;
    register xReq *req;
    unsigned long nbytes;
    XModifierKeymap *res;

    LockDisplay(dpy);
     GetEmptyReq(GetModifierMapping, req);
     (void) _XReply (dpy, (xReply *)&rep, 0, xFalse);
 
    if (rep.length < (INT_MAX >> 2)) {
 	nbytes = (unsigned long)rep.length << 2;
 	res = Xmalloc(sizeof (XModifierKeymap));
 	if (res)
    } else
	res = NULL;
    if ((! res) || (! res->modifiermap)) {
	Xfree(res);
	res = (XModifierKeymap *) NULL;
	_XEatDataWords(dpy, rep.length);
    } else {
	_XReadPad(dpy, (char *) res->modifiermap, (long) nbytes);
	res->max_keypermod = rep.numKeyPerModifier;
    }

    UnlockDisplay(dpy);
    SyncHandle();
    return (res);
}
",1
Detect whether the following code contains vulnerabilities.,"PHP_FUNCTION(pg_lo_write)
{
  	zval *pgsql_id;
  	char *str;
  	zend_long z_len;
	size_t str_len, nbytes;
	size_t len;
	pgLofp *pgsql;
	int argc = ZEND_NUM_ARGS();

	if (zend_parse_parameters(argc, ""rs|l"", &pgsql_id, &str, &str_len, &z_len) == FAILURE) {
		return;
	}

	if (argc > 2) {
		if (z_len > (zend_long)str_len) {
			php_error_docref(NULL, E_WARNING, ""Cannot write more than buffer size %d. Tried to write %pd"", str_len, z_len);
			RETURN_FALSE;
		}
		if (z_len < 0) {
			php_error_docref(NULL, E_WARNING, ""Buffer size must be larger than 0, but %pd was specified"", z_len);
			RETURN_FALSE;
		}
		len = z_len;
	}
	else {
		len = str_len;
	}

	ZEND_FETCH_RESOURCE(pgsql, pgLofp *, pgsql_id, -1, ""PostgreSQL large object"", le_lofp);

	if ((nbytes = lo_write((PGconn *)pgsql->conn, pgsql->lofd, str, len)) == -1) {
		RETURN_FALSE;
	}

	RETURN_LONG(nbytes);
}
",0
Detect whether the following code contains vulnerabilities.," static int inotify_release(struct inode *ignored, struct file *file)
 {
 	struct fsnotify_group *group = file->private_data;
	struct user_struct *user = group->inotify_data.user;
 
 	pr_debug(""%s: group=%p\n"", __func__, group);
 
	fsnotify_clear_marks_by_group(group);

 	/* free this group, matching get was inotify_init->fsnotify_obtain_group */
 	fsnotify_put_group(group);
 
	atomic_dec(&user->inotify_devs);
 	return 0;
 }
",1
Detect whether the following code contains vulnerabilities.,"ProfileKeyedAPIFactory<BookmarksAPI>* BookmarksAPI::GetFactoryInstance() {
  return &g_factory.Get();
}
",0
Detect whether the following code contains vulnerabilities.,"RenderProcessHostImpl::TakeMetricsAllocator() {
  return std::move(metrics_allocator_);
}
",0
Detect whether the following code contains vulnerabilities.,"gfx::Size ScaleSizeToFitView(const gfx::Size& size,
                             const gfx::Size& view_size) {
  if ((size.width() > view_size.width() ||
       size.height() > view_size.height()) ||
      (size.width() < view_size.width() &&
       size.height() < view_size.height())) {
    const float scale =
        std::min(view_size.width() / static_cast<float>(size.width()),
                 view_size.height() / static_cast<float>(size.height()));
    return gfx::ScaleToFlooredSize(size, scale);
  }

  return size;
}
",0
Detect whether the following code contains vulnerabilities.,"int svc_rdma_xdr_encode_error(struct svcxprt_rdma *xprt,
			      struct rpcrdma_msg *rmsgp,
			      enum rpcrdma_errcode err, __be32 *va)
{
	__be32 *startp = va;
	*va++ = rmsgp->rm_xid;
	*va++ = rmsgp->rm_vers;
	*va++ = xprt->sc_fc_credits;
	*va++ = rdma_error;
	*va++ = cpu_to_be32(err);
	if (err == ERR_VERS) {
		*va++ = rpcrdma_version;
		*va++ = rpcrdma_version;
	}
	return (int)((unsigned long)va - (unsigned long)startp);
}
",1
Detect whether the following code contains vulnerabilities.,"error::Error GLES2DecoderPassthroughImpl::DoUniform1i(GLint location, GLint x) {
  api()->glUniform1iFn(location, x);
  return error::kNoError;
}
",0
Detect whether the following code contains vulnerabilities.,"static void webkitWebViewBaseContainerAdd(GtkContainer* container, GtkWidget* widget)
{
    WebKitWebViewBase* webView = WEBKIT_WEB_VIEW_BASE(container);
    WebKitWebViewBasePrivate* priv = webView->priv;

    if (WEBKIT_IS_WEB_VIEW_BASE(widget)
         && WebInspectorProxy::isInspectorPage(WEBKIT_WEB_VIEW_BASE(widget)->priv->pageProxy.get())) {
         ASSERT(!priv->inspectorView);
         priv->inspectorView = widget;
        priv->inspectorViewHeight = gMinimumAttachedInspectorHeight;
     } else {
         GtkAllocation childAllocation;
         gtk_widget_get_allocation(widget, &childAllocation);
        priv->children.set(widget, childAllocation);
    }

    gtk_widget_set_parent(widget, GTK_WIDGET(container));
}
",1
Detect whether the following code contains vulnerabilities.,"void LinkChangeSerializerMarkupAccumulator::appendAttribute(StringBuilder& result, Element* element, const Attribute& attribute, Namespaces* namespaces)
{
    if (m_replaceLinks && element->isURLAttribute(attribute) && !element->isJavaScriptURLAttribute(attribute)) {
        String completeURL = m_document->completeURL(attribute.value());
        if (m_replaceLinks->contains(completeURL)) {
            result.append(' ');
            result.append(attribute.name().toString());
            result.appendLiteral(""=\"""");
            if (!m_directoryName.isEmpty()) {
                result.appendLiteral(""./"");
                result.append(m_directoryName);
                result.append('/');
            }
            result.append(m_replaceLinks->get(completeURL));
            result.appendLiteral(""\"""");
            return;
        }
    }
    MarkupAccumulator::appendAttribute(result, element, attribute, namespaces);
}
",1
Detect whether the following code contains vulnerabilities.," static int omninet_open(struct tty_struct *tty, struct usb_serial_port *port)
 {
	struct usb_serial	*serial = port->serial;
	struct usb_serial_port	*wport;
	wport = serial->port[1];
	tty_port_tty_set(&wport->port, tty);
 	return usb_serial_generic_open(tty, port);
 }
",1
Detect whether the following code contains vulnerabilities.,"bool SendGoBackJSONRequest(
    AutomationMessageSender* sender,
    int browser_index,
    int tab_index,
    std::string* error_msg) {
  DictionaryValue dict;
  dict.SetString(""command"", ""GoBack"");
  dict.SetInteger(""windex"", browser_index);
  dict.SetInteger(""tab_index"", tab_index);
  DictionaryValue reply_dict;
  return SendAutomationJSONRequest(sender, dict, &reply_dict, error_msg);
}
",0
Detect whether the following code contains vulnerabilities.,"static netdev_tx_t hns_nic_net_xmit(struct sk_buff *skb,
 				    struct net_device *ndev)
 {
 	struct hns_nic_priv *priv = netdev_priv(ndev);
	int ret;
 
 	assert(skb->queue_mapping < ndev->ae_handle->q_num);
	ret = hns_nic_net_xmit_hw(ndev, skb,
				  &tx_ring_data(priv, skb->queue_mapping));
	if (ret == NETDEV_TX_OK) {
		netif_trans_update(ndev);
		ndev->stats.tx_bytes += skb->len;
		ndev->stats.tx_packets++;
	}
	return (netdev_tx_t)ret;
 }
",1
Detect whether the following code contains vulnerabilities.,"spnego_gss_wrap_iov(OM_uint32 *minor_status,
		    gss_ctx_id_t context_handle,
		    int conf_req_flag,
		    gss_qop_t qop_req,
		    int *conf_state,
		    gss_iov_buffer_desc *iov,
 		    int iov_count)
 {
 	OM_uint32 ret;
 	ret = gss_wrap_iov(minor_status,
			   context_handle,
 			   conf_req_flag,
 			   qop_req,
 			   conf_state,
			   iov,
			   iov_count);
	return (ret);
}
",1
Detect whether the following code contains vulnerabilities.,"UserCloudPolicyManagerChromeOS::UserCloudPolicyManagerChromeOS(
    scoped_ptr<CloudPolicyStore> store,
    scoped_ptr<CloudExternalDataManager> external_data_manager,
    const base::FilePath& component_policy_cache_path,
    bool wait_for_policy_fetch,
    base::TimeDelta initial_policy_fetch_timeout,
    const scoped_refptr<base::SequencedTaskRunner>& task_runner,
    const scoped_refptr<base::SequencedTaskRunner>& file_task_runner,
    const scoped_refptr<base::SequencedTaskRunner>& io_task_runner)
    : CloudPolicyManager(
          PolicyNamespaceKey(dm_protocol::kChromeUserPolicyType, std::string()),
          store.get(),
          task_runner,
          file_task_runner,
          io_task_runner),
      store_(store.Pass()),
      external_data_manager_(external_data_manager.Pass()),
      component_policy_cache_path_(component_policy_cache_path),
       wait_for_policy_fetch_(wait_for_policy_fetch),
       policy_fetch_timeout_(false, false) {
   time_init_started_ = base::Time::Now();
  if (wait_for_policy_fetch_) {
     policy_fetch_timeout_.Start(
         FROM_HERE,
         initial_policy_fetch_timeout,
        base::Bind(&UserCloudPolicyManagerChromeOS::OnBlockingFetchTimeout,
                   base::Unretained(this)));
  }
}
",1
Detect whether the following code contains vulnerabilities.," FileEntrySync* DirectoryEntrySync::getFile(const String& path, const Dictionary& options, ExceptionState& exceptionState)
 {
     FileSystemFlags flags(options);
    RefPtr<EntrySyncCallbackHelper> helper = EntrySyncCallbackHelper::create();
     m_fileSystem->getFile(this, path, flags, helper->successCallback(), helper->errorCallback(), DOMFileSystemBase::Synchronous);
     return static_cast<FileEntrySync*>(helper->getResult(exceptionState));
 }
",1
Detect whether the following code contains vulnerabilities.,"ScreenLockLibrary* CrosLibrary::GetScreenLockLibrary() {
  return screen_lock_lib_.GetDefaultImpl(use_stub_impl_);
}
",1
Detect whether the following code contains vulnerabilities.,"void SkiaOutputSurfaceImpl::Reshape(const gfx::Size& size,
                                    float device_scale_factor,
                                    const gfx::ColorSpace& color_space,
                                    bool has_alpha,
                                    bool use_stencil) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   if (initialize_waitable_event_) {
     initialize_waitable_event_->Wait();
    initialize_waitable_event_ = nullptr;
   }
 
   SkSurfaceCharacterization* characterization = nullptr;
   if (characterization_.isValid()) {
    characterization_ =
        characterization_.createResized(size.width(), size.height());
     RecreateRootRecorder();
   } else {
     characterization = &characterization_;
    initialize_waitable_event_ = std::make_unique<base::WaitableEvent>(
        base::WaitableEvent::ResetPolicy::MANUAL,
        base::WaitableEvent::InitialState::NOT_SIGNALED);
  }
 
  auto callback = base::BindOnce(
      &SkiaOutputSurfaceImplOnGpu::Reshape,
      base::Unretained(impl_on_gpu_.get()), size, device_scale_factor,
      std::move(color_space), has_alpha, use_stencil, pre_transform_,
      characterization, initialize_waitable_event_.get());
  ScheduleGpuTask(std::move(callback), std::vector<gpu::SyncToken>());
 }
",1
Detect whether the following code contains vulnerabilities.,"static int search_old_relocation(struct reloc_struct_t *reloc_table, ut32 addr_to_patch, int n_reloc) {
 	int i;
 	for (i = 0; i < n_reloc; i++) {
 		if (addr_to_patch == reloc_table[i].data_offset) {
			return i;
		}
	}
	return -1;
}
",1
Detect whether the following code contains vulnerabilities.," void GpuVideoDecodeAccelerator::OnDecode(
    base::SharedMemoryHandle handle, int32 id, int32 size) {
   DCHECK(video_decode_accelerator_.get());
   video_decode_accelerator_->Decode(media::BitstreamBuffer(id, handle, size));
 }
",1
Detect whether the following code contains vulnerabilities.,"void RenderWidgetHostViewAura::ExtendSelectionAndDelete(
    size_t before, size_t after) {
  RenderFrameHostImpl* rfh = GetFocusedFrame();
  if (rfh)
    rfh->ExtendSelectionAndDelete(before, after);
}
",0
Detect whether the following code contains vulnerabilities.,"void WebContentsImpl::DidFailProvisionalLoadWithError(
    RenderViewHost* render_view_host,
    const ViewHostMsg_DidFailProvisionalLoadWithError_Params& params) {
  VLOG(1) << ""Failed Provisional Load: "" << params.url.possibly_invalid_spec()
          << "", error_code: "" << params.error_code
          << "", error_description: "" << params.error_description
          << "", is_main_frame: "" << params.is_main_frame
          << "", showing_repost_interstitial: "" <<
            params.showing_repost_interstitial
          << "", frame_id: "" << params.frame_id;
  GURL validated_url(params.url);
  RenderProcessHost* render_process_host =
      render_view_host->GetProcess();
  RenderViewHost::FilterURL(render_process_host, false, &validated_url);

  if (net::ERR_ABORTED == params.error_code) {
    if (ShowingInterstitialPage()) {
      LOG(WARNING) << ""Discarding message during interstitial."";
       return;
     }
 
     render_manager_.RendererAbortedProvisionalLoad(render_view_host);
   }
 
   FOR_EACH_OBSERVER(WebContentsObserver,
                     observers_,
                     DidFailProvisionalLoad(params.frame_id,
                                           params.is_main_frame,
                                           validated_url,
                                           params.error_code,
                                           params.error_description,
                                           render_view_host));
}
",1
Detect whether the following code contains vulnerabilities.,"void ExtensionOptionsGuest::DidNavigateMainFrame(
    const content::LoadCommittedDetails& details,
    const content::FrameNavigateParams& params) {
  if (attached()) {
    auto guest_zoom_controller =
        ui_zoom::ZoomController::FromWebContents(web_contents());
    guest_zoom_controller->SetZoomMode(
         ui_zoom::ZoomController::ZOOM_MODE_ISOLATED);
     SetGuestZoomLevelToMatchEmbedder();
 
    if (params.url.GetOrigin() != options_page_.GetOrigin()) {
       bad_message::ReceivedBadMessage(web_contents()->GetRenderProcessHost(),
                                       bad_message::EOG_BAD_ORIGIN);
     }
  }
}
",1
Detect whether the following code contains vulnerabilities.,"static void CacheThru_abort(HTStream *me, HTError e)
{
    if (me->fp)
	LYCloseTempFP(me->fp);
    if (LYCacheSourceForAborted == SOURCE_CACHE_FOR_ABORTED_DROP) {
	if (me->filename) {
	    CTRACE((tfp, ""SourceCacheWriter: Removing active file %s\n"",
		    me->filename));
	    (void) LYRemoveTemp(me->filename);
	    FREE(me->filename);
	}
	if (me->chunk) {
	    CTRACE((tfp,
		    ""SourceCacheWriter: Removing active memory chunk %p\n"",
		    (void *) me->chunk));
	    HTChunkFree(me->chunk);
	}
    } else {
	me->status = HT_OK;	/*fake it */
	CacheThru_do_free(me);
    }
    (*me->actions->_abort) (me->target, e);
    FREE(me);
}
",0
Detect whether the following code contains vulnerabilities.,"ResourceDispatcherHost::~ResourceDispatcherHost() {
  AsyncResourceHandler::GlobalCleanup();
   STLDeleteValues(&pending_requests_);
 
   user_script_listener_->ShutdownMainThread();
  std::set<ProcessRouteIDs> ids;
  for (BlockedRequestMap::const_iterator iter = blocked_requests_map_.begin();
       iter != blocked_requests_map_.end(); ++iter) {
    std::pair<std::set<ProcessRouteIDs>::iterator, bool> result =
        ids.insert(iter->first);
    DCHECK(result.second);
  }
  for (std::set<ProcessRouteIDs>::const_iterator iter = ids.begin();
       iter != ids.end(); ++iter) {
    CancelBlockedRequestsForRoute(iter->first, iter->second);
  }
 }
",1
Detect whether the following code contains vulnerabilities.,"nfsd4_close(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
	    struct nfsd4_close *close)
{
	__be32 status;
	struct nfs4_ol_stateid *stp;
	struct net *net = SVC_NET(rqstp);
	struct nfsd_net *nn = net_generic(net, nfsd_net_id);

	dprintk(""NFSD: nfsd4_close on file %pd\n"", 
			cstate->current_fh.fh_dentry);

	status = nfs4_preprocess_seqid_op(cstate, close->cl_seqid,
					&close->cl_stateid,
					NFS4_OPEN_STID|NFS4_CLOSED_STID,
					&stp, nn);
	nfsd4_bump_seqid(cstate, status);
	if (status)
		goto out; 
	nfs4_inc_and_copy_stateid(&close->cl_stateid, &stp->st_stid);
	mutex_unlock(&stp->st_mutex);

	nfsd4_close_open_stateid(stp);

	/* put reference from nfs4_preprocess_seqid_op */
	nfs4_put_stid(&stp->st_stid);
out:
	return status;
}
",0
Detect whether the following code contains vulnerabilities.,"static void checkPtrmap(
  IntegrityCk *pCheck,   /* Integrity check context */
  Pgno iChild,           /* Child page number */
  u8 eType,              /* Expected pointer map type */
  Pgno iParent           /* Expected pointer map parent page number */
){
  int rc;
  u8 ePtrmapType;
  Pgno iPtrmapParent;

  rc = ptrmapGet(pCheck->pBt, iChild, &ePtrmapType, &iPtrmapParent);
  if( rc!=SQLITE_OK ){
    if( rc==SQLITE_NOMEM || rc==SQLITE_IOERR_NOMEM ) pCheck->mallocFailed = 1;
    checkAppendMsg(pCheck, ""Failed to read ptrmap key=%d"", iChild);
    return;
  }

  if( ePtrmapType!=eType || iPtrmapParent!=iParent ){
    checkAppendMsg(pCheck,
      ""Bad ptr map entry key=%d expected=(%d,%d) got=(%d,%d)"", 
      iChild, eType, iParent, ePtrmapType, iPtrmapParent);
  }
}
",0
Detect whether the following code contains vulnerabilities.," bool GesturePoint::IsInSecondClickTimeWindow() const {
   double duration =  last_touch_time_ - last_tap_time_;
  return duration < kMaximumSecondsBetweenDoubleClick;
 }
",1
Detect whether the following code contains vulnerabilities.,"WebPlugin* RenderView::CreateNPAPIPlugin(
    WebFrame* frame,
    const WebPluginParams& params,
    const FilePath& path,
    const std::string& mime_type) {
  return new webkit::npapi::WebPluginImpl(
      frame, params, path, mime_type, AsWeakPtr());
}
",0
Detect whether the following code contains vulnerabilities.,"     virtual void scheduleBeginFrameAndCommit()
     {
        CCMainThread::postTask(m_proxy->createBeginFrameAndCommitTaskOnCCThread());
     }
",1
Detect whether the following code contains vulnerabilities.,"VOID NBLSet8021QInfo(PPARANDIS_ADAPTER pContext, PNET_BUFFER_LIST pNBL, PNET_PACKET_INFO pPacketInfo)
{
    NDIS_NET_BUFFER_LIST_8021Q_INFO qInfo;
    qInfo.Value = NULL;

    if (IsPrioritySupported(pContext))
        qInfo.TagHeader.UserPriority = pPacketInfo->Vlan.UserPriority;

    if (IsVlanSupported(pContext))
        qInfo.TagHeader.VlanId = pPacketInfo->Vlan.VlanId;

    if(qInfo.Value != NULL)
        pContext->extraStatistics.framesRxPriority++;

    NET_BUFFER_LIST_INFO(pNBL, Ieee8021QNetBufferListInfo) = qInfo.Value;
}
",0
Detect whether the following code contains vulnerabilities.,"static v8::Handle<v8::Value> acceptTransferListCallback(const v8::Arguments& args)
 {
     INC_STATS(""DOM.TestSerializedScriptValueInterface.acceptTransferList"");
     if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
     TestSerializedScriptValueInterface* imp = V8TestSerializedScriptValueInterface::toNative(args.Holder());
     MessagePortArray messagePortArrayTransferList;
     ArrayBufferArray arrayBufferArrayTransferList;
    if (args.Length() > 1) {
        if (!extractTransferables(args[1], messagePortArrayTransferList, arrayBufferArrayTransferList))
            return V8Proxy::throwTypeError(""Could not extract transferables"");
    }
    bool dataDidThrow = false;
    RefPtr<SerializedScriptValue> data = SerializedScriptValue::create(args[0], &messagePortArrayTransferList, &arrayBufferArrayTransferList, dataDidThrow, args.GetIsolate());
    if (dataDidThrow)
        return v8::Undefined();
    if (args.Length() <= 1) {
        imp->acceptTransferList(data);
        return v8::Handle<v8::Value>();
    }
    imp->acceptTransferList(data, messagePortArrayTransferList);
    return v8::Handle<v8::Value>();
}
",1
Detect whether the following code contains vulnerabilities.,"static void br_multicast_del_pg(struct net_bridge *br,
				struct net_bridge_port_group *pg)
{
	struct net_bridge_mdb_htable *mdb;
	struct net_bridge_mdb_entry *mp;
	struct net_bridge_port_group *p;
	struct net_bridge_port_group __rcu **pp;

	mdb = mlock_dereference(br->mdb, br);

	mp = br_mdb_ip_get(mdb, &pg->addr);
	if (WARN_ON(!mp))
		return;

	for (pp = &mp->ports;
	     (p = mlock_dereference(*pp, br)) != NULL;
	     pp = &p->next) {
		if (p != pg)
			continue;

		rcu_assign_pointer(*pp, p->next);
		hlist_del_init(&p->mglist);
 		del_timer(&p->timer);
 		call_rcu_bh(&p->rcu, br_multicast_free_pg);
 
		if (!mp->ports && !mp->mglist &&
 		    netif_running(br->dev))
 			mod_timer(&mp->timer, jiffies);
 
		return;
	}

	WARN_ON(1);
}
",1
Detect whether the following code contains vulnerabilities.,"bool RenderFrameImpl::UniqueNameFrameAdapter::IsMainFrame() const {
  return render_frame_->IsMainFrame();
}
",0
Detect whether the following code contains vulnerabilities.,"  bool IsMultiByteResponseExpected() {
    return multibyte_response_expected_;
  }
",0
Detect whether the following code contains vulnerabilities.,"status_t Camera3Device::createDefaultRequest(int templateId,

         CameraMetadata *request) {
     ATRACE_CALL();
     ALOGV(""%s: for template %d"", __FUNCTION__, templateId);
     Mutex::Autolock il(mInterfaceLock);
     Mutex::Autolock l(mLock);
 
 switch (mStatus) {
 case STATUS_ERROR:
            CLOGE(""Device has encountered a serious error"");
 return INVALID_OPERATION;
 case STATUS_UNINITIALIZED:
            CLOGE(""Device is not initialized!"");
 return INVALID_OPERATION;
 case STATUS_UNCONFIGURED:
 case STATUS_CONFIGURED:
 case STATUS_ACTIVE:
 break;
 default:
            SET_ERR_L(""Unexpected status: %d"", mStatus);
 return INVALID_OPERATION;
 }

 if (!mRequestTemplateCache[templateId].isEmpty()) {
 *request = mRequestTemplateCache[templateId];
 return OK;
 }

 const camera_metadata_t *rawRequest;
    ATRACE_BEGIN(""camera3->construct_default_request_settings"");
    rawRequest = mHal3Device->ops->construct_default_request_settings(
        mHal3Device, templateId);
    ATRACE_END();
 if (rawRequest == NULL) {
        ALOGI(""%s: template %d is not supported on this camera device"",
              __FUNCTION__, templateId);
 return BAD_VALUE;
 }
 *request = rawRequest;
    mRequestTemplateCache[templateId] = rawRequest;

 return OK;
}
",1
Detect whether the following code contains vulnerabilities.,"void TextIterator::handleTextNodeFirstLetter(RenderTextFragment* renderer)
{
    if (renderer->firstLetter()) {
        RenderObject* r = renderer->firstLetter();
        if (r->style()->visibility() != VISIBLE && !m_ignoresStyleVisibility)
            return;
        if (RenderText* firstLetter = firstRenderTextInFirstLetter(r)) {
            m_handledFirstLetter = true;
            m_remainingTextBox = m_textBox;
            m_textBox = firstLetter->firstTextBox();
            m_sortedTextBoxes.clear();
            m_firstLetterText = firstLetter;
        }
    }
    m_handledFirstLetter = true;
}
",0
Detect whether the following code contains vulnerabilities.," static void copyStereo8(
         short *dst,
        const int *const *src,
         unsigned nSamples,
         unsigned /* nChannels */) {
     for (unsigned i = 0; i < nSamples; ++i) {
 *dst++ = src[0][i] << 8;
 *dst++ = src[1][i] << 8;

     }
 }
",1
Detect whether the following code contains vulnerabilities.,"ACodec::UninitializedState::UninitializedState(ACodec *codec)
 : BaseState(codec) {
}
",0
Detect whether the following code contains vulnerabilities.,"static inline void invalidate_cursor1(CirrusVGAState *s)
{
    if (s->last_hw_cursor_size) {
        vga_invalidate_scanlines(&s->vga,
                                 s->last_hw_cursor_y + s->last_hw_cursor_y_start,
                                 s->last_hw_cursor_y + s->last_hw_cursor_y_end);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"mm_sshpam_init_ctx(Authctxt *authctxt)
{
	Buffer m;
	int success;
 
 	debug3(""%s"", __func__);
 	buffer_init(&m);
	buffer_put_cstring(&m, authctxt->user);
 	mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_PAM_INIT_CTX, &m);
 	debug3(""%s: waiting for MONITOR_ANS_PAM_INIT_CTX"", __func__);
 	mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_PAM_INIT_CTX, &m);
	success = buffer_get_int(&m);
	if (success == 0) {
		debug3(""%s: pam_init_ctx failed"", __func__);
		buffer_free(&m);
		return (NULL);
	}
	buffer_free(&m);
	return (authctxt);
}
",1
Detect whether the following code contains vulnerabilities.,"Eina_Bool ewk_frame_back(Evas_Object* ewkFrame)
{
    return ewk_frame_navigate(ewkFrame, -1);
}
",0
Detect whether the following code contains vulnerabilities.,"EncodedJSValue JSC_HOST_CALL JSTestObjConstructor::constructJSTestObj(ExecState* exec)
 {
     JSTestObjConstructor* castedThis = jsCast<JSTestObjConstructor*>(exec->callee());
     if (exec->argumentCount() < 1)
        return throwVMError(exec, createTypeError(exec, ""Not enough arguments""));
     if (exec->argumentCount() <= 0 || !exec->argument(0).isFunction()) {
         setDOMException(exec, TYPE_MISMATCH_ERR);
         return JSValue::encode(jsUndefined());
    }
    RefPtr<TestCallback> testCallback = JSTestCallback::create(asObject(exec->argument(0)), castedThis->globalObject());
    RefPtr<TestObj> object = TestObj::create(testCallback);
    return JSValue::encode(asObject(toJS(exec, castedThis->globalObject(), object.get())));
}
",1
Detect whether the following code contains vulnerabilities.,"  gray_render_span( int             y,
                    int             count,
                    const FT_Span*  spans,
                    PWorker         worker )
  {
    unsigned char*  p;
    FT_Bitmap*      map = &worker->target;


     /* first of all, compute the scanline offset */
     p = (unsigned char*)map->buffer - y * map->pitch;
     if ( map->pitch >= 0 )
      p += ( map->rows - 1 ) * map->pitch;
 
     for ( ; count > 0; count--, spans++ )
     {
      unsigned char  coverage = spans->coverage;


      if ( coverage )
      {
        /* For small-spans it is faster to do it by ourselves than
         * calling `memset'.  This is mainly due to the cost of the
         * function call.
         */
        if ( spans->len >= 8 )
          FT_MEM_SET( p + spans->x, (unsigned char)coverage, spans->len );
        else
        {
          unsigned char*  q = p + spans->x;


          switch ( spans->len )
          {
          case 7: *q++ = (unsigned char)coverage;
          case 6: *q++ = (unsigned char)coverage;
          case 5: *q++ = (unsigned char)coverage;
          case 4: *q++ = (unsigned char)coverage;
          case 3: *q++ = (unsigned char)coverage;
          case 2: *q++ = (unsigned char)coverage;
          case 1: *q   = (unsigned char)coverage;
          default:
            ;
          }
        }
      }
    }
  }
",1
Detect whether the following code contains vulnerabilities.,"void StartupBrowserCreator::AddFirstRunTab(const GURL& url) {
  first_run_tabs_.push_back(url);
}
",0
Detect whether the following code contains vulnerabilities.,"static void enforcedRangeLongLongAttrAttributeSetterCallback(v8::Local<v8::String>, v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE(""Blink"", ""DOMSetter"");
    TestObjectV8Internal::enforcedRangeLongLongAttrAttributeSetter(jsValue, info);
    TRACE_EVENT_SET_SAMPLING_STATE(""V8"", ""V8Execution"");
}
",0
Detect whether the following code contains vulnerabilities.,"static int proc_key_users_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &proc_key_users_ops);
}
",0
Detect whether the following code contains vulnerabilities.,"int hashtable_set(hashtable_t *hashtable,
                  const char *key, size_t serial,
                  json_t *value)
{
    pair_t *pair;
    bucket_t *bucket;
     size_t hash, index;
 
     /* rehash if the load ratio exceeds 1 */
    if(hashtable->size >= num_buckets(hashtable))
         if(hashtable_do_rehash(hashtable))
             return -1;
 
     hash = hash_str(key);
    index = hash % num_buckets(hashtable);
     bucket = &hashtable->buckets[index];
     pair = hashtable_find_pair(hashtable, bucket, key, hash);
 
    if(pair)
    {
        json_decref(pair->value);
        pair->value = value;
    }
    else
    {
        /* offsetof(...) returns the size of pair_t without the last,
           flexible member. This way, the correct amount is
           allocated. */
        pair = jsonp_malloc(offsetof(pair_t, key) + strlen(key) + 1);
        if(!pair)
            return -1;

        pair->hash = hash;
        pair->serial = serial;
        strcpy(pair->key, key);
        pair->value = value;
        list_init(&pair->list);

        insert_to_bucket(hashtable, bucket, &pair->list);

        hashtable->size++;
    }
    return 0;
}
",1
Detect whether the following code contains vulnerabilities.," int PDFiumEngine::GetVisiblePageIndex(FPDF_PAGE page) {
  for (int page_index : visible_pages_) {
     if (pages_[page_index]->GetPage() == page)
       return page_index;
   }
  return -1;
}
",1
Detect whether the following code contains vulnerabilities.,"content::ColorChooser* ShowColorChooser(content::WebContents* web_contents,
                                        SkColor initial_color) {
#if defined(USE_ASH)
  gfx::NativeView native_view = web_contents->GetView()->GetNativeView();
  if (GetHostDesktopTypeForNativeView(native_view) == HOST_DESKTOP_TYPE_ASH)
    return ColorChooserAura::Open(web_contents, initial_color);
#endif
  return ColorChooserWin::Open(web_contents, initial_color);
}
",0
Detect whether the following code contains vulnerabilities.,"void V8TestObject::Uint8ArrayMethodMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), ""Blink_TestObject_uint8ArrayMethod"");

  test_object_v8_internal::Uint8ArrayMethodMethod(info);
}
",0
Detect whether the following code contains vulnerabilities.,"struct edid *drm_load_edid_firmware(struct drm_connector *connector)
{
	const char *connector_name = connector->name;
	char *edidname, *last, *colon, *fwstr, *edidstr, *fallback = NULL;
	struct edid *edid;

	if (edid_firmware[0] == '\0')
		return ERR_PTR(-ENOENT);

	/*
	 * If there are multiple edid files specified and separated
	 * by commas, search through the list looking for one that
	 * matches the connector.
	 *
	 * If there's one or more that doesn't specify a connector, keep
 	 * the last one found one as a fallback.
 	 */
 	fwstr = kstrdup(edid_firmware, GFP_KERNEL);
 	edidstr = fwstr;
 
 	while ((edidname = strsep(&edidstr, "",""))) {
			if (strncmp(connector_name, edidname, colon - edidname))
				continue;
			edidname = colon + 1;
			break;
		}

		if (*edidname != '\0') /* corner case: multiple ',' */
			fallback = edidname;
	}
",1
Detect whether the following code contains vulnerabilities.," virtual bool DnsResolveEx(const std::string& host,
                            std::string* ip_address_list) {
    dns_resolves_ex.push_back(host);
 *ip_address_list = dns_resolve_ex_result;
 return !dns_resolve_ex_result.empty();
 }
",0
Detect whether the following code contains vulnerabilities.,"void rose_add_loopback_neigh(void)
{
	struct rose_neigh *sn;

	rose_loopback_neigh = kmalloc(sizeof(struct rose_neigh), GFP_KERNEL);
	if (!rose_loopback_neigh)
		return;
	sn = rose_loopback_neigh;

	sn->callsign  = null_ax25_address;
	sn->digipeat  = NULL;
	sn->ax25      = NULL;
	sn->dev       = NULL;
	sn->count     = 0;
	sn->use       = 0;
	sn->dce_mode  = 1;
	sn->loopback  = 1;
	sn->number    = rose_neigh_no++;
	sn->restarted = 1;

	skb_queue_head_init(&sn->queue);

	init_timer(&sn->ftimer);
	init_timer(&sn->t0timer);

	spin_lock_bh(&rose_neigh_list_lock);
	sn->next = rose_neigh_list;
	rose_neigh_list           = sn;
	spin_unlock_bh(&rose_neigh_list_lock);
}
",0
Detect whether the following code contains vulnerabilities.,"static int decode_attr_group(struct xdr_stream *xdr, uint32_t *bitmap, struct nfs_client *clp, uint32_t *gid)
{
	uint32_t len;
	__be32 *p;

	*gid = -2;
	if (unlikely(bitmap[1] & (FATTR4_WORD1_OWNER_GROUP - 1U)))
		return -EIO;
	if (likely(bitmap[1] & FATTR4_WORD1_OWNER_GROUP)) {
		READ_BUF(4);
		READ32(len);
		READ_BUF(len);
		if (len < XDR_MAX_NETOBJ) {
			if (nfs_map_group_to_gid(clp, (char *)p, len, gid) != 0)
				dprintk(""%s: nfs_map_group_to_gid failed!\n"",
						__func__);
		} else
			dprintk(""%s: name too long (%u)!\n"",
					__func__, len);
		bitmap[1] &= ~FATTR4_WORD1_OWNER_GROUP;
	}
	dprintk(""%s: gid=%d\n"", __func__, (int)*gid);
	return 0;
}
",0
Detect whether the following code contains vulnerabilities.,"fn_printzp(netdissect_options *ndo,
           register const u_char *s, register u_int n,
           register const u_char *ep)
{
	register int ret;
	register u_char c;

	ret = 1;			/* assume truncated */
	while (n > 0 && (ep == NULL || s < ep)) {
		n--;
		c = *s++;
		if (c == '\0') {
			ret = 0;
			break;
		}
		if (!ND_ISASCII(c)) {
			c = ND_TOASCII(c);
			ND_PRINT((ndo, ""M-""));
		}
		if (!ND_ISPRINT(c)) {
			c ^= 0x40;	/* DEL to ?, others to alpha */
			ND_PRINT((ndo, ""^""));
		}
		ND_PRINT((ndo, ""%c"", c));
	}
	return (n == 0) ? 0 : ret;
}
",0
Detect whether the following code contains vulnerabilities.," views::View* LauncherView::GetAppListButtonView() const {
   for (int i = 0; i < model_->item_count(); ++i) {
     if (model_->items()[i].type == TYPE_APP_LIST)
      return view_model_->view_at(i);
  }

  NOTREACHED() << ""Applist button not found"";
  return NULL;
}
",0
Detect whether the following code contains vulnerabilities.,"FileTransfer::AddDownloadFilenameRemap(char const *source_name,char const *target_name) {
	if(!download_filename_remaps.IsEmpty()) {
		download_filename_remaps += "";"";
	}
	download_filename_remaps += source_name;
	download_filename_remaps += ""="";
	download_filename_remaps += target_name;
}
",0
Detect whether the following code contains vulnerabilities.,"void xdr_init_encode(struct xdr_stream *xdr, struct xdr_buf *buf, __be32 *p)
{
	struct kvec *iov = buf->head;
	int scratch_len = buf->buflen - buf->page_len - buf->tail[0].iov_len;

	BUG_ON(scratch_len < 0);
	xdr->buf = buf;
	xdr->iov = iov;
	xdr->p = (__be32 *)((char *)iov->iov_base + iov->iov_len);
	xdr->end = (__be32 *)((char *)iov->iov_base + scratch_len);
	BUG_ON(iov->iov_len > scratch_len);

	if (p != xdr->p && p != NULL) {
		size_t len;

		BUG_ON(p < xdr->p || p > xdr->end);
		len = (char *)p - (char *)xdr->p;
		xdr->p = p;
		buf->len += len;
		iov->iov_len += len;
	}
}
",0
Detect whether the following code contains vulnerabilities.,"static void echo_set_canon_col(struct n_tty_data *ldata)
{
	add_echo_byte(ECHO_OP_START, ldata);
	add_echo_byte(ECHO_OP_SET_CANON_COL, ldata);
}
",0
Detect whether the following code contains vulnerabilities.,"void GpuCommandBufferStub::OnCommandProcessed() {
  if (watchdog_)
    watchdog_->CheckArmed();
}
",0
Detect whether the following code contains vulnerabilities.,"OMXNodeInstance::OMXNodeInstance(
        OMX *owner, const sp<IOMXObserver> &observer, const char *name)
 : mOwner(owner),
      mNodeID(0),

       mHandle(NULL),
       mObserver(observer),
       mDying(false),
       mBufferIDCount(0)
 {
     mName = ADebug::GetDebugName(name);
    DEBUG = ADebug::GetDebugLevelFromProperty(name, ""debug.stagefright.omx-debug"");
    ALOGV(""debug level for %s is %d"", name, DEBUG);
    DEBUG_BUMP = DEBUG;
    mNumPortBuffers[0] = 0;
    mNumPortBuffers[1] = 0;
    mDebugLevelBumpPendingBuffers[0] = 0;
    mDebugLevelBumpPendingBuffers[1] = 0;
    mMetadataType[0] = kMetadataBufferTypeInvalid;
    mMetadataType[1] = kMetadataBufferTypeInvalid;
    mSecureBufferType[0] = kSecureBufferTypeUnknown;
    mSecureBufferType[1] = kSecureBufferTypeUnknown;
    mIsSecure = AString(name).endsWith("".secure"");
}
",1
Detect whether the following code contains vulnerabilities.,"SProcXFixesCreatePointerBarrier(ClientPtr client)
{
    REQUEST(xXFixesCreatePointerBarrierReq);
    int i;
     int i;
     CARD16 *in_devices = (CARD16 *) &stuff[1];
 
     swaps(&stuff->length);
     swaps(&stuff->num_devices);
     REQUEST_FIXED_SIZE(xXFixesCreatePointerBarrierReq, pad_to_int32(stuff->num_devices));
    swaps(&stuff->x1);
    swaps(&stuff->y1);
    swaps(&stuff->x2);
    swaps(&stuff->y2);
    swapl(&stuff->directions);
    for (i = 0; i < stuff->num_devices; i++) {
        swaps(in_devices + i);
    }

    return ProcXFixesVector[stuff->xfixesReqType] (client);
}
",1
Detect whether the following code contains vulnerabilities.,"void PPB_URLLoader_Impl::RunCallback(int32_t result) {
  if (!pending_callback_.get()) {
     CHECK(main_document_loader_);
     return;
   }
   TrackedCallback::ClearAndRun(&pending_callback_, result);
 }
",1
Detect whether the following code contains vulnerabilities.,"void ArcVoiceInteractionFrameworkService::ToggleSessionFromUserInteraction() {
  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);

  if (!InitiateUserInteraction(true /* is_toggle */))
    return;

  mojom::VoiceInteractionFrameworkInstance* framework_instance =
      ARC_GET_INSTANCE_FOR_METHOD(
          arc_bridge_service_->voice_interaction_framework(),
          ToggleVoiceInteractionSession);
  DCHECK(framework_instance);
  framework_instance->ToggleVoiceInteractionSession(IsHomescreenActive());
}
",0
Detect whether the following code contains vulnerabilities.,"static inline void advance(struct pt_regs *regs)
{
	regs->tpc   = regs->tnpc;
	regs->tnpc += 4;
	if (test_thread_flag(TIF_32BIT)) {
		regs->tpc &= 0xffffffff;
		regs->tnpc &= 0xffffffff;
	}
}
",0
Detect whether the following code contains vulnerabilities.,"  void Initialize(ChannelLayout channel_layout, int bits_per_channel) {
     AudioParameters params(
         media::AudioParameters::AUDIO_PCM_LINEAR, channel_layout,
        kSamplesPerSecond, bits_per_channel, kRawDataSize);
 
     algorithm_.Initialize(1, params, base::Bind(
         &AudioRendererAlgorithmTest::EnqueueData, base::Unretained(this)));
    EnqueueData();
  }
",1
Detect whether the following code contains vulnerabilities.,"gfx::Size GLES2DecoderImpl::GetBoundReadFrameBufferSize() {
  Framebuffer* framebuffer =
      GetFramebufferInfoForTarget(GL_READ_FRAMEBUFFER_EXT);
  if (framebuffer != NULL) {
    const Framebuffer::Attachment* attachment =
        framebuffer->GetAttachment(GL_COLOR_ATTACHMENT0);
    if (attachment) {
      return gfx::Size(attachment->width(), attachment->height());
    }
    return gfx::Size(0, 0);
  } else if (offscreen_target_frame_buffer_.get()) {
    return offscreen_size_;
  } else {
    return surface_->GetSize();
  }
}
",0
Detect whether the following code contains vulnerabilities.,"static int ppp_gidle(unsigned int fd, unsigned int cmd,
		struct ppp_idle32 __user *idle32)
{
	struct ppp_idle __user *idle;
	__kernel_time_t xmit, recv;
	int err;

	idle = compat_alloc_user_space(sizeof(*idle));

	err = sys_ioctl(fd, PPPIOCGIDLE, (unsigned long) idle);

	if (!err) {
		if (get_user(xmit, &idle->xmit_idle) ||
		    get_user(recv, &idle->recv_idle) ||
		    put_user(xmit, &idle32->xmit_idle) ||
		    put_user(recv, &idle32->recv_idle))
			err = -EFAULT;
	}
	return err;
}
",0
Detect whether the following code contains vulnerabilities.,"native_handle* Parcel::readNativeHandle() const
{
 int numFds, numInts;
 status_t err;
    err = readInt32(&numFds);
 if (err != NO_ERROR) return 0;
    err = readInt32(&numInts);
 if (err != NO_ERROR) return 0;

    native_handle* h = native_handle_create(numFds, numInts);
 if (!h) {
 return 0;
 }

 
     for (int i=0 ; err==NO_ERROR && i<numFds ; i++) {
         h->data[i] = dup(readFileDescriptor());
        if (h->data[i] < 0) err = BAD_VALUE;
     }
     err = read(h->data + numFds, sizeof(int)*numInts);
     if (err != NO_ERROR) {
        native_handle_close(h);
        native_handle_delete(h);
        h = 0;
 }
 return h;
}
",1
Detect whether the following code contains vulnerabilities.,"  static void CloudPrintInfoCallback(bool enabled,
                                     const std::string& email,
                                     const std::string& proxy_id) {
    QuitMessageLoop();
   }
",1
Detect whether the following code contains vulnerabilities.," virtual void ResetModel() {
    last_pts_ = 0;
    bits_in_buffer_model_ = cfg_.rc_target_bitrate * cfg_.rc_buf_initial_sz;
    frame_number_ = 0;

     tot_frame_number_ = 0;
     first_drop_ = 0;
     num_drops_ = 0;
     for (int i = 0; i < 3; ++i) {
       bits_total_[i] = 0;
     }
   }
",1
Detect whether the following code contains vulnerabilities.,"static inline int vmcs12_write_any(struct kvm_vcpu *vcpu,
				   unsigned long field, u64 field_value){
	short offset = vmcs_field_to_offset(field);
	char *p = ((char *) get_vmcs12(vcpu)) + offset;
	if (offset < 0)
		return offset;

	switch (vmcs_field_width(field)) {
	case VMCS_FIELD_WIDTH_U16:
		*(u16 *)p = field_value;
		return 0;
	case VMCS_FIELD_WIDTH_U32:
		*(u32 *)p = field_value;
		return 0;
	case VMCS_FIELD_WIDTH_U64:
		*(u64 *)p = field_value;
		return 0;
	case VMCS_FIELD_WIDTH_NATURAL_WIDTH:
		*(natural_width *)p = field_value;
		return 0;
	default:
		WARN_ON(1);
		return -ENOENT;
	}

}
",0
Detect whether the following code contains vulnerabilities.,"void WallpaperManager::InitializeRegisteredDeviceWallpaper() {
  if (user_manager::UserManager::Get()->IsUserLoggedIn())
    return;

  bool disable_boot_animation =
      GetCommandLine()->HasSwitch(switches::kDisableBootAnimation);
  bool show_users = true;
  bool result = CrosSettings::Get()->GetBoolean(
      kAccountsPrefShowUserNamesOnSignIn, &show_users);
  DCHECK(result) << ""Unable to fetch setting ""
                 << kAccountsPrefShowUserNamesOnSignIn;
  const user_manager::UserList& users =
      user_manager::UserManager::Get()->GetUsers();
  int public_session_user_index = FindPublicSession(users);
  if ((!show_users && public_session_user_index == -1) ||
      !HasNonDeviceLocalAccounts(users)) {
    if (!SetDeviceWallpaperIfApplicable(user_manager::SignInAccountId()))
      SetDefaultWallpaperDelayed(user_manager::SignInAccountId());
    return;
  }

  if (!disable_boot_animation) {
    int index = public_session_user_index != -1 ? public_session_user_index : 0;
    SetUserWallpaperDelayed(users[index]->GetAccountId());
  }
}
",0
Detect whether the following code contains vulnerabilities.,"hash_foreach_mangle_dict_of_strings (gpointer key, gpointer val, gpointer user_data)
{
  GHashTable *out = (GHashTable*) user_data;
  GHashTable *in_dict = (GHashTable *) val;
  HashAndString *data = g_new0 (HashAndString, 1);
  data->string = (gchar*) key;
  data->hash = g_hash_table_new_full (g_str_hash, g_str_equal,
                                            g_free, g_free);
  g_hash_table_foreach (in_dict, hash_foreach_prepend_string, data);
  g_hash_table_insert(out, g_strdup ((gchar*) key), data->hash);
}
",1
Detect whether the following code contains vulnerabilities.,"size_t compile_tree(struct filter_op **fop)
{
   int i = 1;
    struct filter_op *array = NULL;
    struct unfold_elm *ue;
 
   BUG_IF(tree_root == NULL);
   
    fprintf(stdout, "" Unfolding the meta-tree "");
    fflush(stdout);
     
   /* start the recursion on the tree */
   unfold_blk(&tree_root);

   fprintf(stdout, "" done.\n\n"");

   /* substitute the virtual labels with real offsets */
   labels_to_offsets();
   
   /* convert the tailq into an array */
   TAILQ_FOREACH(ue, &unfolded_tree, next) {

      /* label == 0 means a real instruction */
      if (ue->label == 0) {
         SAFE_REALLOC(array, i * sizeof(struct filter_op));
         memcpy(&array[i - 1], &ue->fop, sizeof(struct filter_op));
         i++;
      }
   }
   
   /* always append the exit function to a script */
   SAFE_REALLOC(array, i * sizeof(struct filter_op));
   array[i - 1].opcode = FOP_EXIT;
   
   /* return the pointer to the array */
   *fop = array;
   
   return (i);
}
",1
Detect whether the following code contains vulnerabilities.," virtual void SetUp() {
    video_ = new libvpx_test::WebMVideoSource(kVP9TestFile);
    ASSERT_TRUE(video_ != NULL);

     video_->Init();
     video_->Begin();
 
    vpx_codec_dec_cfg_t cfg = {0};
     decoder_ = new libvpx_test::VP9Decoder(cfg, 0);
     ASSERT_TRUE(decoder_ != NULL);
   }
",1
Detect whether the following code contains vulnerabilities.,"raptor_rdfxml_comment_handler(void *user_data, raptor_xml_element* xml_element,
                              const unsigned char *s)
{
  raptor_parser* rdf_parser = (raptor_parser*)user_data;
  raptor_rdfxml_parser* rdf_xml_parser;
  raptor_rdfxml_element* element;

  if(rdf_parser->failed || !xml_element)
    return;

  rdf_xml_parser = (raptor_rdfxml_parser*)rdf_parser->context;
  element = rdf_xml_parser->current_element;

  if(element) {
    if(element->child_content_type == RAPTOR_RDFXML_ELEMENT_CONTENT_TYPE_XML_LITERAL)
      raptor_xml_writer_comment(rdf_xml_parser->xml_writer, s);
  }
  

#ifdef RAPTOR_DEBUG_VERBOSE
  RAPTOR_DEBUG2(""XML Comment '%s'\n"", s);
#endif
}
",0
Detect whether the following code contains vulnerabilities.,"GF_Err tfdt_Read(GF_Box *s,GF_BitStream *bs)
{
	GF_TFBaseMediaDecodeTimeBox *ptr = (GF_TFBaseMediaDecodeTimeBox *)s;

	if (ptr->version==1) {
		ptr->baseMediaDecodeTime = gf_bs_read_u64(bs);
		ISOM_DECREASE_SIZE(ptr, 8);
	} else {
		ptr->baseMediaDecodeTime = (u32) gf_bs_read_u32(bs);
		ISOM_DECREASE_SIZE(ptr, 4);
	}
	return GF_OK;
}
",0
Detect whether the following code contains vulnerabilities.,"static void LongOrNullAttributeAttributeSetter(
    v8::Local<v8::Value> v8_value, const v8::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  ALLOW_UNUSED_LOCAL(isolate);

  v8::Local<v8::Object> holder = info.Holder();
  ALLOW_UNUSED_LOCAL(holder);

  TestObject* impl = V8TestObject::ToImpl(holder);
 
   ExceptionState exception_state(isolate, ExceptionState::kSetterContext, ""TestObject"", ""longOrNullAttribute"");
 
  int32_t cpp_value = NativeValueTraits<IDLLong>::NativeValue(info.GetIsolate(), v8_value, exception_state);
   if (exception_state.HadException())
     return;
 
  bool is_null = IsUndefinedOrNull(v8_value);
   impl->setLongOrNullAttribute(cpp_value, is_null);
 }
",1
Detect whether the following code contains vulnerabilities.,"void simulatePageScale(WebViewImpl* webViewImpl, float& scale)
{
    WebCore::IntSize scrollDelta = webViewImpl->fakePageScaleAnimationTargetPositionForTesting() - webViewImpl->mainFrameImpl()->frameView()->scrollPosition();
    float scaleDelta = webViewImpl->fakePageScaleAnimationPageScaleForTesting() / webViewImpl->pageScaleFactor();
    webViewImpl->applyScrollAndScale(scrollDelta, scaleDelta);
    scale = webViewImpl->pageScaleFactor();
}
",0
Detect whether the following code contains vulnerabilities.,"static int __init big_key_crypto_init(void)
{
	int ret = -EINVAL;
 
	/* init RNG */
	big_key_rng = crypto_alloc_rng(big_key_rng_name, 0, 0);
	if (IS_ERR(big_key_rng)) {
		big_key_rng = NULL;
		return -EFAULT;
 	}
 
 	/* seed RNG */
	ret = crypto_rng_reset(big_key_rng, NULL, crypto_rng_seedsize(big_key_rng));
	if (ret)
		goto error;
 
 	/* init block cipher */
	big_key_skcipher = crypto_alloc_skcipher(big_key_alg_name,
						 0, CRYPTO_ALG_ASYNC);
	if (IS_ERR(big_key_skcipher)) {
		big_key_skcipher = NULL;
		ret = -EFAULT;
		goto error;
 	}
 
 	return 0;
 
error:
 	crypto_free_rng(big_key_rng);
	big_key_rng = NULL;
 	return ret;
 }
",1
Detect whether the following code contains vulnerabilities.,"static int asymmetric_key_match(const struct key *key,
				const struct key_match_data *match_data)
 {
 	const struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);
 	const char *description = match_data->raw_data;
	const char *spec = description;
	const char *id;
	ptrdiff_t speclen;

	if (!subtype || !spec || !*spec)
		return 0;

	/* See if the full key description matches as is */
	if (key->description && strcmp(key->description, description) == 0)
		return 1;

	/* All tests from here on break the criterion description into a
	 * specifier, a colon and then an identifier.
	 */
	id = strchr(spec, ':');
	if (!id)
		return 0;

	speclen = id - spec;
	id++;

	if (speclen == 2 && memcmp(spec, ""id"", 2) == 0)
		return asymmetric_keyid_match(asymmetric_key_id(key), id);

	if (speclen == subtype->name_len &&
	    memcmp(spec, subtype->name, speclen) == 0)
		return 1;

	return 0;
}
",1
Detect whether the following code contains vulnerabilities.,"void NuPlayer::GenericSource::setDrmPlaybackStatusIfNeeded(int playbackStatus, int64_t position) {
 if (mDecryptHandle != NULL) {
        mDrmManagerClient->setPlaybackStatus(mDecryptHandle, playbackStatus, position);
 }
    mSubtitleTrack.mPackets = new AnotherPacketSource(NULL);
    mTimedTextTrack.mPackets = new AnotherPacketSource(NULL);
}
",0
Detect whether the following code contains vulnerabilities.,"void sum_update(const char *p, int32 len)
{
	switch (cursum_type) {
	  case CSUM_MD5:
		md5_update(&md, (uchar *)p, len);
		break;
          case CSUM_MD4:
          case CSUM_MD4_OLD:
          case CSUM_MD4_BUSTED:
                if (len + sumresidue < CSUM_CHUNK) {
                        memcpy(md.buffer + sumresidue, p, len);
                        sumresidue += len;
		}

		if (sumresidue) {
			int32 i = CSUM_CHUNK - sumresidue;
			memcpy(md.buffer + sumresidue, p, i);
			mdfour_update(&md, (uchar *)md.buffer, CSUM_CHUNK);
			len -= i;
			p += i;
		}

		while (len >= CSUM_CHUNK) {
			mdfour_update(&md, (uchar *)p, CSUM_CHUNK);
			len -= CSUM_CHUNK;
			p += CSUM_CHUNK;
		}

		sumresidue = len;
		if (sumresidue)
			memcpy(md.buffer, p, sumresidue);
		break;
	  case CSUM_NONE:
		break;
	}
}
",1
Detect whether the following code contains vulnerabilities.," void EnableHighDPISupport() {
   if (IsHighDPIEnabled() &&
      (base::win::GetVersion() < base::win::VERSION_WIN8_1)) {
    if (!SetProcessDpiAwarenessWrapper(PROCESS_SYSTEM_DPI_AWARE)) {
      SetProcessDPIAwareWrapper();
    }
   }
 }
",1
Detect whether the following code contains vulnerabilities.,"bool ATSParser::PTSTimeDeltaEstablished() {
 if (mPrograms.isEmpty()) {
 return false;
 }

 return mPrograms.editItemAt(0)->PTSTimeDeltaEstablished();
}
",0
Detect whether the following code contains vulnerabilities.,"void RenderView::printPage(WebFrame* frame) {
  DCHECK(frame);
  Print(frame, true);
}
",0
Detect whether the following code contains vulnerabilities.," accept_ice_connection (GIOChannel           *source,
                        GIOCondition          condition,
                        GsmIceConnectionData *data)
 {
        IceListenObj    listener;
         IceConn         ice_conn;
         IceAcceptStatus status;
        GsmClient      *client;
        GsmXsmpServer  *server;
        listener = data->listener;
        server = data->server;
 
         g_debug (""GsmXsmpServer: accept_ice_connection()"");
 
        ice_conn = IceAcceptConnection (listener, &status);
         if (status != IceAcceptSuccess) {
                 g_debug (""GsmXsmpServer: IceAcceptConnection returned %d"", status);
                 return TRUE;
         }
 
        client = gsm_xsmp_client_new (ice_conn);
        ice_conn->context = client;
        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));
        /* the store will own the ref */
        g_object_unref (client);
 
         return TRUE;
 }
",1
Detect whether the following code contains vulnerabilities.,"static void aes_encrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)
{
	struct crypto_sparc64_aes_ctx *ctx = crypto_tfm_ctx(tfm);

	ctx->ops->encrypt(&ctx->key[0], (const u32 *) src, (u32 *) dst);
}
",0
Detect whether the following code contains vulnerabilities.,"int __remove_suid(struct dentry *dentry, int kill)
{
	struct iattr newattrs;

	newattrs.ia_valid = ATTR_FORCE | kill;
	return notify_change(dentry, &newattrs);
}
",0
Detect whether the following code contains vulnerabilities.,"void WebPluginImpl::didFinishLoadingFrameRequest(
     const WebURL& url, void* notify_data) {
   if (delegate_) {
     delegate_->DidFinishLoadWithReason(
        url, NPRES_DONE, reinterpret_cast<intptr_t>(notify_data));
   }
 }
",1
Detect whether the following code contains vulnerabilities.,"static int srpt_ch_qp_rtr(struct srpt_rdma_ch *ch, struct ib_qp *qp)
{
	struct ib_qp_attr qp_attr;
	int attr_mask;
	int ret;

	qp_attr.qp_state = IB_QPS_RTR;
	ret = ib_cm_init_qp_attr(ch->cm_id, &qp_attr, &attr_mask);
	if (ret)
		goto out;

	qp_attr.max_dest_rd_atomic = 4;

	ret = ib_modify_qp(qp, &qp_attr, attr_mask);

out:
	return ret;
}
",0
Detect whether the following code contains vulnerabilities.,"static void nested_vmx_abort(struct kvm_vcpu *vcpu, u32 indicator)
{
	/* TODO: not to reset guest simply here. */
	kvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);
	pr_debug_ratelimited(""kvm: nested vmx abort, indicator %d\n"", indicator);
}
",0
Detect whether the following code contains vulnerabilities.,"void ptrace_triggered(struct perf_event *bp, int nmi,
 		      struct perf_sample_data *data, struct pt_regs *regs)
 {
 	struct perf_event_attr attr;

	/*
	 * Disable the breakpoint request here since ptrace has defined a
	 * one-shot behaviour for breakpoint exceptions in PPC64.
	 * The SIGTRAP signal is generated automatically for us in do_dabr().
	 * We don't have to do anything about that here
	 */
	attr = bp->attr;
	attr.disabled = true;
	modify_user_hw_breakpoint(bp, &attr);
}
",1
Detect whether the following code contains vulnerabilities.," static void build_l4proto_sctp(const struct nf_conntrack *ct, struct nethdr *n)
 {
	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
		      sizeof(struct nfct_attr_grp_port));
 	if (!nfct_attr_is_set(ct, ATTR_SCTP_STATE))
 		return;
 
 	ct_build_u8(ct, ATTR_SCTP_STATE, n, NTA_SCTP_STATE);
 	ct_build_u32(ct, ATTR_SCTP_VTAG_ORIG, n, NTA_SCTP_VTAG_ORIG);
 	ct_build_u32(ct, ATTR_SCTP_VTAG_REPL, n, NTA_SCTP_VTAG_REPL);
}
",1
Detect whether the following code contains vulnerabilities.,"static ssize_t sched_mc_power_savings_show(struct sysdev_class *class,
					   struct sysdev_class_attribute *attr,
					   char *page)
{
	return sprintf(page, ""%u\n"", sched_mc_power_savings);
}
",0
Detect whether the following code contains vulnerabilities.,"nm_ip4_config_get_ifindex (const NMIP4Config *config)
{
	return NM_IP4_CONFIG_GET_PRIVATE (config)->ifindex;
}
",0
Detect whether the following code contains vulnerabilities.,"PHP_FUNCTION(openssl_x509_check_private_key)
{
	zval ** zcert, **zkey;
	X509 * cert = NULL;
	EVP_PKEY * key = NULL;
	long certresource = -1, keyresource = -1;

	RETVAL_FALSE;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ZZ"", &zcert, &zkey) == FAILURE) {
		return;
	}
	cert = php_openssl_x509_from_zval(zcert, 0, &certresource TSRMLS_CC);
	if (cert == NULL) {
		RETURN_FALSE;
	}
	key = php_openssl_evp_from_zval(zkey, 0, """", 1, &keyresource TSRMLS_CC);
	if (key) {
		RETVAL_BOOL(X509_check_private_key(cert, key));
	}

	if (keyresource == -1 && key) {
		EVP_PKEY_free(key);
	}
	if (certresource == -1 && cert) {
		X509_free(cert);
	}
 }
",0
Detect whether the following code contains vulnerabilities.,"Eina_Bool ewk_view_back(Evas_Object* ewkView)
{
    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);
    return ewk_frame_back(smartData->main_frame);
}
",0
Detect whether the following code contains vulnerabilities.," static MagickBooleanType CheckMemoryOverflow(const size_t count,
   const size_t quantum)
 {
  size_t
    size;

  size=count*quantum;
  if ((count == 0) || (quantum != (size/count)))
    {
      errno=ENOMEM;
      return(MagickTrue);
    }
  return(MagickFalse);
}
",0
Detect whether the following code contains vulnerabilities.," void RenderViewImpl::EnsureMediaStreamImpl() {
  if (!RenderThreadImpl::current())  // Will be NULL during unit tests.
    return;

#if defined(ENABLE_WEBRTC)
  if (!media_stream_dispatcher_)
    media_stream_dispatcher_ = new MediaStreamDispatcher(this);

  if (!media_stream_impl_) {
    media_stream_impl_ = new MediaStreamImpl(
        this,
        media_stream_dispatcher_,
        RenderThreadImpl::current()->video_capture_impl_manager(),
        RenderThreadImpl::current()->GetMediaStreamDependencyFactory());
  }
#endif
}
",0
Detect whether the following code contains vulnerabilities.,"static int m_show(struct seq_file *m, void *v)
{
	struct proc_mounts *p = proc_mounts(m);
	struct mount *r = list_entry(v, struct mount, mnt_list);
	return p->show(m, &r->mnt);
}
",0
Detect whether the following code contains vulnerabilities.,"bool ResourceTracker::UnrefResource(PP_Resource res) {
  DLOG_IF(ERROR, !CheckIdType(res, PP_ID_TYPE_RESOURCE))
      << res << "" is not a PP_Resource."";
  ResourceMap::iterator i = live_resources_.find(res);
  if (i != live_resources_.end()) {
    if (!--i->second.second) {
      Resource* to_release = i->second.first;
       PP_Instance instance = to_release->instance()->pp_instance();
      to_release->LastPluginRefWasDeleted(false);
 
      instance_map_[instance]->resources.erase(res);
       live_resources_.erase(i);
     }
     return true;
  } else {
    return false;
  }
}
",1
Detect whether the following code contains vulnerabilities.,"gboolean Shell::OnWindowDestroyed(GtkWidget* window) {
  delete this;
  return FALSE;  // Don't stop this message.
}
",0
Detect whether the following code contains vulnerabilities.,"int create_flush_cmd_control(struct f2fs_sb_info *sbi)
{
	dev_t dev = sbi->sb->s_bdev->bd_dev;
	struct flush_cmd_control *fcc;
	int err = 0;

	if (SM_I(sbi)->fcc_info) {
		fcc = SM_I(sbi)->fcc_info;
		goto init_thread;
	}

	fcc = kzalloc(sizeof(struct flush_cmd_control), GFP_KERNEL);
	if (!fcc)
		return -ENOMEM;
	atomic_set(&fcc->issued_flush, 0);
	atomic_set(&fcc->issing_flush, 0);
 	init_waitqueue_head(&fcc->flush_wait_queue);
 	init_llist_head(&fcc->issue_list);
 	SM_I(sbi)->fcc_info = fcc;
 init_thread:
 	fcc->f2fs_issue_flush = kthread_run(issue_flush_thread, sbi,
 				""f2fs_flush-%u:%u"", MAJOR(dev), MINOR(dev));
	if (IS_ERR(fcc->f2fs_issue_flush)) {
		err = PTR_ERR(fcc->f2fs_issue_flush);
		kfree(fcc);
		SM_I(sbi)->fcc_info = NULL;
		return err;
	}

	return err;
}
",1
Detect whether the following code contains vulnerabilities.,"void dtls1_hm_fragment_free(hm_fragment *frag)
{
    if (!frag)
        return;
    if (frag->msg_header.is_ccs) {
        EVP_CIPHER_CTX_free(frag->msg_header.
                            saved_retransmit_state.enc_write_ctx);
        EVP_MD_CTX_free(frag->msg_header.saved_retransmit_state.write_hash);
    }
    OPENSSL_free(frag->fragment);
    OPENSSL_free(frag->reassembly);
    OPENSSL_free(frag);
}
",0
Detect whether the following code contains vulnerabilities.,"METHODDEF(JDIMENSION)
get_raw_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)
/* This version is for reading raw-byte-format files with maxval = MAXJSAMPLE.
 * In this case we just read right into the JSAMPLE buffer!
 * Note that same code works for PPM and PGM files.
 */
{
  ppm_source_ptr source = (ppm_source_ptr)sinfo;

  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))
    ERREXIT(cinfo, JERR_INPUT_EOF);
  return 1;
}
",0
Detect whether the following code contains vulnerabilities.,"void V8TestObject::DoubleAttributeAttributeGetterCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), ""Blink_TestObject_doubleAttribute_Getter"");

  test_object_v8_internal::DoubleAttributeAttributeGetter(info);
}
",0
Detect whether the following code contains vulnerabilities.,"static MagickBooleanType SkipDXTMipmaps(Image *image,DDSInfo *dds_info,
  int texel_size,ExceptionInfo *exception)
{
  register ssize_t
    i;

  MagickOffsetType
    offset;

  size_t
    h,
    w;

  /*
    Only skip mipmaps for textures and cube maps
  */
  if (EOFBlob(image) != MagickFalse)
    {
      ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
        image->filename);
      return(MagickFalse);
    }
  if (dds_info->ddscaps1 & DDSCAPS_MIPMAP
      && (dds_info->ddscaps1 & DDSCAPS_TEXTURE
          || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))
    {
      w = DIV2(dds_info->width);
      h = DIV2(dds_info->height);

      /*
        Mipmapcount includes the main image, so start from one
      */
       for (i = 1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)
       {
         offset = (MagickOffsetType) ((w + 3) / 4) * ((h + 3) / 4) * texel_size;
        (void) SeekBlob(image, offset, SEEK_CUR);
         w = DIV2(w);
         h = DIV2(h);
       }
    }
  return(MagickTrue);
}
",1
Detect whether the following code contains vulnerabilities.,"MagickExport ssize_t WriteBlobMSBSignedShort(Image *image,
  const signed short value)
{
  union
  {
    unsigned short
      unsigned_value;

    signed short
      signed_value;
  } quantum;

  unsigned char
    buffer[2];

  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  quantum.signed_value=value;
  buffer[0]=(unsigned char) (quantum.unsigned_value >> 8);
  buffer[1]=(unsigned char) quantum.unsigned_value;
  return(WriteBlobStream(image,2,buffer));
}
",0
Detect whether the following code contains vulnerabilities.,"static int r_bin_mdmp_init(struct r_bin_mdmp_obj *obj) {
	r_bin_mdmp_init_parsing (obj);

	if (!r_bin_mdmp_init_hdr (obj)) {
		eprintf (""[ERROR] Failed to initialise header\n"");
		return false;
	}

	if (!r_bin_mdmp_init_directory (obj)) {
		eprintf (""[ERROR] Failed to initialise directory structures!\n"");
		return false;
	}

	if (!r_bin_mdmp_init_pe_bins (obj)) {
		eprintf (""[ERROR] Failed to initialise pe binaries!\n"");
		return false;
	}

	return true;
}
",0
Detect whether the following code contains vulnerabilities.,"bool XSSAuditor::filterFrameToken(const FilterTokenRequest& request)
{
    ASSERT(request.token.type() == HTMLToken::StartTag);
    ASSERT(hasName(request.token, iframeTag) || hasName(request.token, frameTag));

    bool didBlockScript = eraseAttributeIfInjected(request, srcdocAttr, String(), ScriptLikeAttribute);
    if (isContainedInRequest(decodedSnippetForName(request)))
        didBlockScript |= eraseAttributeIfInjected(request, srcAttr, String(), SrcLikeAttribute);

    return didBlockScript;
}
",0
Detect whether the following code contains vulnerabilities.,"   void FireInvalidateAll() {
    invalidation::AckHandle ack_handle(""fakedata"");
    EXPECT_CALL(mock_invalidation_client_, Acknowledge(ack_handle));
    client_.InvalidateAll(&mock_invalidation_client_, ack_handle);
   }
",1
Detect whether the following code contains vulnerabilities.,"  void GoBackCrossSite() {
     NavigationEntry* entry = contents()->controller().GetEntryAtOffset(-1);
     ASSERT_TRUE(entry);
     contents()->controller().GoBack();
 
    contents()->TestDidNavigate(
        contents()->pending_rvh(), entry->page_id(), GURL(entry->url()),
        content::PAGE_TRANSITION_TYPED);
   }
",1
Detect whether the following code contains vulnerabilities.,"GLsync GLES2DecoderImpl::DoFenceSync(GLenum condition, GLbitfield flags) {
  const char* function_name = ""glFenceSync"";
  if (condition != GL_SYNC_GPU_COMMANDS_COMPLETE) {
    LOCAL_SET_GL_ERROR(GL_INVALID_ENUM, function_name, ""invalid condition"");
    return 0;
  }
  if (flags != 0) {
    LOCAL_SET_GL_ERROR(GL_INVALID_VALUE, function_name, ""invalid flags"");
    return 0;
  }
  return api()->glFenceSyncFn(condition, flags);
}
",0
Detect whether the following code contains vulnerabilities.,"static int cipso_v4_map_cat_rbm_valid(const struct cipso_v4_doi *doi_def,
				      const unsigned char *bitmap,
				      u32 bitmap_len)
{
	int cat = -1;
	u32 bitmap_len_bits = bitmap_len * 8;
	u32 cipso_cat_size;
	u32 *cipso_array;

	switch (doi_def->type) {
	case CIPSO_V4_MAP_PASS:
		return 0;
	case CIPSO_V4_MAP_TRANS:
		cipso_cat_size = doi_def->map.std->cat.cipso_size;
		cipso_array = doi_def->map.std->cat.cipso;
		for (;;) {
			cat = cipso_v4_bitmap_walk(bitmap,
						   bitmap_len_bits,
						   cat + 1,
						   1);
			if (cat < 0)
				break;
			if (cat >= cipso_cat_size ||
			    cipso_array[cat] >= CIPSO_V4_INV_CAT)
				return -EFAULT;
		}

		if (cat == -1)
			return 0;
		break;
	}

	return -EFAULT;
}
",0
Detect whether the following code contains vulnerabilities.,"static ssize_t show_ibdev(struct device *dev, struct device_attribute *attr,
			  char *buf)
{
	struct ib_ucm_device *ucm_dev;

	ucm_dev = container_of(dev, struct ib_ucm_device, dev);
	return sprintf(buf, ""%s\n"", ucm_dev->ib_dev->name);
}
",0
Detect whether the following code contains vulnerabilities.,"onig_free_body(regex_t* reg)
{
  if (IS_NOT_NULL(reg)) {
    ops_free(reg);
    if (IS_NOT_NULL(reg->string_pool)) {
      xfree(reg->string_pool);
      reg->string_pool_end = reg->string_pool = 0;
    }
    if (IS_NOT_NULL(reg->exact))            xfree(reg->exact);
    if (IS_NOT_NULL(reg->repeat_range))     xfree(reg->repeat_range);
    if (IS_NOT_NULL(reg->extp)) {
      free_regex_ext(reg->extp);
      reg->extp = 0;
    }

    onig_names_free(reg);
  }
}
",0
Detect whether the following code contains vulnerabilities.,"  void ProcessControlLaunched() {
     base::ScopedAllowBlockingForTesting allow_blocking;
     base::ProcessId service_pid;
     EXPECT_TRUE(GetServiceProcessData(NULL, &service_pid));
    EXPECT_NE(static_cast<base::ProcessId>(0), service_pid);
#if defined(OS_WIN)
    service_process_ =
        base::Process::OpenWithAccess(service_pid,
                                      SYNCHRONIZE | PROCESS_QUERY_INFORMATION);
#else
     service_process_ = base::Process::Open(service_pid);
 #endif
     EXPECT_TRUE(service_process_.IsValid());
    base::ThreadTaskRunnerHandle::Get()->PostTask(
        FROM_HERE, base::RunLoop::QuitCurrentWhenIdleClosureDeprecated());
   }
",1
Detect whether the following code contains vulnerabilities.,"void RenderViewHostImpl::OnTargetDropACK() {
  NotificationService::current()->Notify(
      NOTIFICATION_RENDER_VIEW_HOST_DID_RECEIVE_DRAG_TARGET_DROP_ACK,
      Source<RenderViewHost>(this),
      NotificationService::NoDetails());
}
",0
Detect whether the following code contains vulnerabilities.,"static bool check_underflow(const struct ip6t_entry *e)
{
 	const struct xt_entry_target *t;
 	unsigned int verdict;
 
	if (!unconditional(&e->ipv6))
 		return false;
 	t = ip6t_get_target_c(e);
 	if (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)
		return false;
	verdict = ((struct xt_standard_target *)t)->verdict;
	verdict = -verdict - 1;
	return verdict == NF_DROP || verdict == NF_ACCEPT;
}
",1
Detect whether the following code contains vulnerabilities.,"void V8Window::namedPropertyGetterCustom(v8::Local<v8::Name> name, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    if (!name->IsString())
        return;

    auto nameString = name.As<v8::String>();
    LocalDOMWindow* window = toLocalDOMWindow(V8Window::toImpl(info.Holder()));
    if (!window)
        return;

    LocalFrame* frame = window->frame();
    if (!frame)
        return;

    AtomicString propName = toCoreAtomicString(nameString);
    Frame* child = frame->tree().scopedChild(propName);
    if (child) {
        v8SetReturnValueFast(info, child->domWindow(), window);
        return;
    }

     if (!info.Holder()->GetRealNamedProperty(nameString).IsEmpty())
         return;
 
     Document* doc = frame->document();
 
    if (doc && doc->isHTMLDocument()) {
        if (toHTMLDocument(doc)->hasNamedItem(propName) || doc->hasElementWithId(propName)) {
            RefPtrWillBeRawPtr<HTMLCollection> items = doc->windowNamedItems(propName);
            if (!items->isEmpty()) {
                if (items->hasExactlyOneItem()) {
                    v8SetReturnValueFast(info, items->item(0), window);
                    return;
                }
                v8SetReturnValueFast(info, items.release(), window);
                return;
            }
        }
    }
}
",1
Detect whether the following code contains vulnerabilities.,"void FS_ClearPakReferences( int flags ) {
	searchpath_t *search;

	if ( !flags ) {
		flags = -1;
	}
	for ( search = fs_searchpaths; search; search = search->next ) {
		if ( search->pack ) {
			search->pack->referenced &= ~flags;
		}
	}
}
",0
Detect whether the following code contains vulnerabilities.,"        ~CreateFileResult()
        {
        }
",1
Detect whether the following code contains vulnerabilities.,"xmlParse3986RelativeRef(xmlURIPtr uri, const char *str) {
 int ret;

 if ((*str == '/') && (*(str + 1) == '/')) {
        str += 2;
	ret = xmlParse3986Authority(uri, &str);
 if (ret != 0) return(ret);
	ret = xmlParse3986PathAbEmpty(uri, &str);
 if (ret != 0) return(ret);
 } else if (*str == '/') {
	ret = xmlParse3986PathAbsolute(uri, &str);
 if (ret != 0) return(ret);
 } else if (ISA_PCHAR(str)) {
        ret = xmlParse3986PathNoScheme(uri, &str);
 if (ret != 0) return(ret);
 } else {
 /* path-empty is effectively empty */
 if (uri != NULL) {
 if (uri->path != NULL) xmlFree(uri->path);
	    uri->path = NULL;
 }
 }

 if (*str == '?') {
	str++;
	ret = xmlParse3986Query(uri, &str);
 if (ret != 0) return(ret);
 }
 if (*str == '#') {
	str++;
	ret = xmlParse3986Fragment(uri, &str);
 if (ret != 0) return(ret);
 }
 if (*str != 0) {
	xmlCleanURI(uri);
 return(1);
 }
 return(0);
}
",0
Detect whether the following code contains vulnerabilities.,"  void Dispose() {
    raw_data_ = nullptr;
    delete this;
  }
",0
Detect whether the following code contains vulnerabilities.,"static void mptsas_free_request(MPTSASRequest *req)
{
    MPTSASState *s = req->dev;

    if (req->sreq != NULL) {
        req->sreq->hba_private = NULL;
        scsi_req_unref(req->sreq);
        req->sreq = NULL;
        QTAILQ_REMOVE(&s->pending, req, next);
    }
    qemu_sglist_destroy(&req->qsg);
    g_free(req);
}
",0
Detect whether the following code contains vulnerabilities.,"static void __net_exit sctp_net_exit(struct net *net)
 {
 	/* Free the local address list */
 	sctp_free_addr_wq(net);
 	sctp_free_local_addr_list(net);
 
	/* Free the control endpoint.  */
	inet_ctl_sock_destroy(net->sctp.ctl_sock);
 	sctp_dbg_objcnt_exit(net);
 
 	sctp_proc_exit(net);
 	cleanup_sctp_mibs(net);
 	sctp_sysctl_net_unregister(net);
 }
",1
Detect whether the following code contains vulnerabilities.,"bool WebstoreStandaloneInstaller::EnsureUniqueInstall(
    webstore_install::Result* reason,
    std::string* error) {
  InstallTracker* tracker = InstallTracker::Get(profile_);
  DCHECK(tracker);

  const ActiveInstallData* existing_install_data =
       tracker->GetActiveInstall(id_);
   if (existing_install_data) {
     *reason = webstore_install::INSTALL_IN_PROGRESS;
    *error = kInstallInProgressError;
     return false;
   }
 
  ActiveInstallData install_data(id_);
  InitInstallData(&install_data);
  scoped_active_install_.reset(new ScopedActiveInstall(tracker, install_data));
  return true;
}
",1
Detect whether the following code contains vulnerabilities.," SProcXFixesQueryVersion(ClientPtr client)
 {
     REQUEST(xXFixesQueryVersionReq);
 
     swaps(&stuff->length);
     swapl(&stuff->majorVersion);
    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);
}
",1
Detect whether the following code contains vulnerabilities.,"static u8 vhost_scsi_get_fabric_proto_ident(struct se_portal_group *se_tpg)
{
	struct vhost_scsi_tpg *tpg = container_of(se_tpg,
				struct vhost_scsi_tpg, se_tpg);
	struct vhost_scsi_tport *tport = tpg->tport;

	switch (tport->tport_proto_id) {
	case SCSI_PROTOCOL_SAS:
		return sas_get_fabric_proto_ident(se_tpg);
	case SCSI_PROTOCOL_FCP:
		return fc_get_fabric_proto_ident(se_tpg);
	case SCSI_PROTOCOL_ISCSI:
		return iscsi_get_fabric_proto_ident(se_tpg);
	default:
		pr_err(""Unknown tport_proto_id: 0x%02x, using""
			"" SAS emulation\n"", tport->tport_proto_id);
		break;
	}

	return sas_get_fabric_proto_ident(se_tpg);
}
",0
Detect whether the following code contains vulnerabilities.,"PasswordStoreLoginsChangedObserver::PasswordStoreLoginsChangedObserver(
    AutomationProvider* automation,
    IPC::Message* reply_message,
    PasswordStoreChange::Type expected_type,
    const std::string& result_key)
    : automation_(automation->AsWeakPtr()),
      reply_message_(reply_message),
      expected_type_(expected_type),
      result_key_(result_key),
      done_event_(false, false) {
  AddRef();
}
",0
Detect whether the following code contains vulnerabilities.,"void ContentSecurityPolicy::BindToExecutionContext(
    ExecutionContext* execution_context) {
  execution_context_ = execution_context;
  ApplyPolicySideEffectsToExecutionContext();
}
",0
Detect whether the following code contains vulnerabilities.," SoftMPEG4Encoder::~SoftMPEG4Encoder() {
     ALOGV(""Destruct SoftMPEG4Encoder"");
     releaseEncoder();
     List<BufferInfo *> &outQueue = getPortQueue(1);
     List<BufferInfo *> &inQueue = getPortQueue(0);
    CHECK(outQueue.empty());
    CHECK(inQueue.empty());
}
",1
Detect whether the following code contains vulnerabilities.,"static void __net_exit sysctl_net_exit(struct net *net)
{
	retire_sysctl_set(&net->sysctls);
}
",0
Detect whether the following code contains vulnerabilities.,"bool UnprivilegedProcessDelegate::CreateConnectedIpcChannel(
    const std::string& channel_name,
    IPC::Listener* delegate,
    ScopedHandle* client_out,
    scoped_ptr<IPC::ChannelProxy>* server_out) {
  scoped_ptr<IPC::ChannelProxy> server;
  if (!CreateIpcChannel(channel_name, kDaemonIpcSecurityDescriptor,
                        io_task_runner_, delegate, &server)) {
    return false;
  }
  std::string pipe_name(kChromePipeNamePrefix);
  pipe_name.append(channel_name);
  SECURITY_ATTRIBUTES security_attributes;
  security_attributes.nLength = sizeof(security_attributes);
  security_attributes.lpSecurityDescriptor = NULL;
  security_attributes.bInheritHandle = TRUE;
  ScopedHandle client;
  client.Set(CreateFile(UTF8ToUTF16(pipe_name).c_str(),
                        GENERIC_READ | GENERIC_WRITE,
                        0,
                        &security_attributes,
                        OPEN_EXISTING,
                        SECURITY_SQOS_PRESENT | SECURITY_IDENTIFICATION |
                            FILE_FLAG_OVERLAPPED,
                        NULL));
  if (!client.IsValid())
    return false;
  *client_out = client.Pass();
  *server_out = server.Pass();
  return true;
}
",1
Detect whether the following code contains vulnerabilities.,"static void emitnumber(JF, double num)
{
	if (num == 0) {
		emit(J, F, OP_NUMBER_0);
		if (signbit(num))
			emit(J, F, OP_NEG);
	} else if (num == 1) {
		emit(J, F, OP_NUMBER_1);
	} else if (num == (js_Instruction)num) {
		emit(J, F, OP_NUMBER_POS);
		emitraw(J, F, (js_Instruction)num);
	} else if (num < 0 && -num == (js_Instruction)(-num)) {
		emit(J, F, OP_NUMBER_NEG);
		emitraw(J, F, (js_Instruction)(-num));
	} else {
		emit(J, F, OP_NUMBER);
		emitraw(J, F, addnumber(J, F, num));
	}
}
",0
Detect whether the following code contains vulnerabilities.,"bool f2fs_init_extent_tree(struct inode *inode, struct f2fs_extent *i_ext)
 {
 	struct f2fs_sb_info *sbi = F2FS_I_SB(inode);
 	struct extent_tree *et;
	struct extent_node *en;
	struct extent_info ei;

	if (!f2fs_may_extent_tree(inode)) {
		/* drop largest extent */
		if (i_ext && i_ext->len) {
			i_ext->len = 0;
			return true;
		}
		return false;
	}

	et = __grab_extent_tree(inode);

	if (!i_ext || !i_ext->len)
		return false;

	get_extent_info(&ei, i_ext);

	write_lock(&et->lock);
	if (atomic_read(&et->node_cnt))
		goto out;

	en = __init_extent_tree(sbi, et, &ei);
	if (en) {
		spin_lock(&sbi->extent_lock);
		list_add_tail(&en->list, &sbi->extent_list);
		spin_unlock(&sbi->extent_lock);
	}
out:
	write_unlock(&et->lock);
 	return false;
 }
",1
Detect whether the following code contains vulnerabilities.,"static int writeWepKeyRid(struct airo_info *ai, WepKeyRid *wkr, int perm, int lock)
{
	int rc;
	rc = PC4500_writerid(ai, RID_WEP_TEMP, wkr, sizeof(*wkr), lock);
	if (rc!=SUCCESS)
		airo_print_err(ai->dev->name, ""WEP_TEMP set %x"", rc);
	if (perm) {
		rc = PC4500_writerid(ai, RID_WEP_PERM, wkr, sizeof(*wkr), lock);
		if (rc!=SUCCESS)
			airo_print_err(ai->dev->name, ""WEP_PERM set %x"", rc);
	}
	return rc;
}
",0
Detect whether the following code contains vulnerabilities.,"calc_delta_mine(unsigned long delta_exec, unsigned long weight,
		struct load_weight *lw)
{
	u64 tmp;

	/*
	 * weight can be less than 2^SCHED_LOAD_RESOLUTION for task group sched
	 * entities since MIN_SHARES = 2. Treat weight as 1 if less than
	 * 2^SCHED_LOAD_RESOLUTION.
	 */
	if (likely(weight > (1UL << SCHED_LOAD_RESOLUTION)))
		tmp = (u64)delta_exec * scale_load_down(weight);
	else
		tmp = (u64)delta_exec;

	if (!lw->inv_weight) {
		unsigned long w = scale_load_down(lw->weight);

		if (BITS_PER_LONG > 32 && unlikely(w >= WMULT_CONST))
			lw->inv_weight = 1;
		else if (unlikely(!w))
			lw->inv_weight = WMULT_CONST;
		else
			lw->inv_weight = WMULT_CONST / w;
	}

	/*
	 * Check whether we'd overflow the 64-bit multiplication:
	 */
	if (unlikely(tmp > WMULT_CONST))
		tmp = SRR(SRR(tmp, WMULT_SHIFT/2) * lw->inv_weight,
			WMULT_SHIFT/2);
	else
		tmp = SRR(tmp * lw->inv_weight, WMULT_SHIFT);

	return (unsigned long)min(tmp, (u64)(unsigned long)LONG_MAX);
}
",0
Detect whether the following code contains vulnerabilities.," WebPluginResourceClient* WebPluginDelegateImpl::CreateResourceClient(
    unsigned long resource_id, const GURL& url, bool notify_needed,
    intptr_t notify_data, intptr_t existing_stream) {
  if (existing_stream) {
    NPAPI::PluginStream* plugin_stream =
        reinterpret_cast<NPAPI::PluginStream*>(existing_stream);
    return plugin_stream->AsResourceClient();
  }
 
  std::string mime_type;
  NPAPI::PluginStreamUrl *stream = instance()->CreateStream(
      resource_id, url, mime_type, notify_needed,
      reinterpret_cast<void*>(notify_data));
  return stream;
 }
",1
Detect whether the following code contains vulnerabilities.,"void close_all_sockets(atransport* t) {
    asocket* s;


     /* this is a little gross, but since s->close() *will* modify
     ** the list out from under you, your options are limited.
     */
    adb_mutex_lock(&socket_list_lock);
 restart:
     for (s = local_socket_list.next; s != &local_socket_list; s = s->next) {
         if (s->transport == t || (s->peer && s->peer->transport == t)) {
            local_socket_close_locked(s);
             goto restart;
         }
     }
    adb_mutex_unlock(&socket_list_lock);
 }
",1
Detect whether the following code contains vulnerabilities.,"static int skt_write(int fd, const void *p, size_t len)
{
 int sent;
 struct pollfd pfd;

    FNLOG();

    pfd.fd = fd;
    pfd.events = POLLOUT;


     /* poll for 500 ms */
 
     /* send time out */
    if (poll(&pfd, 1, 500) == 0)
         return 0;
 
     ts_log(""skt_write"", len, NULL);
 
    if ((sent = send(fd, p, len, MSG_NOSIGNAL)) == -1)
     {
         ERROR(""write failed with errno=%d\n"", errno);
         return -1;
 }

 return sent;
}
",1
Detect whether the following code contains vulnerabilities.,"static void unix_detach_fds(struct scm_cookie *scm, struct sk_buff *skb)
{
	int i;

	scm->fp = UNIXCB(skb).fp;
 	UNIXCB(skb).fp = NULL;
 
 	for (i = scm->fp->count-1; i >= 0; i--)
		unix_notinflight(scm->fp->fp[i]);
 }
",1
Detect whether the following code contains vulnerabilities.,"void SpeechSynthesis::trace(Visitor* visitor)
{
    visitor->trace(m_voiceList);
    visitor->trace(m_utteranceQueue);
}
",0
Detect whether the following code contains vulnerabilities.,"  std::string GetRequestStringForPNACL(const std::string& fragment) const {
    return RequestString(test_page_url_ + fragment, ""navigate"", ""include"") +
           RequestString(GetURL(""/pnacl_url_loader.nmf""), ""same-origin"",
                         ""same-origin"") +
           RequestString(GetURL(""/pnacl_url_loader_newlib_pnacl.pexe""),
                         ""same-origin"", ""same-origin"");
  }
",0
Detect whether the following code contains vulnerabilities.,"ssh_packet_get_compress_state(struct sshbuf *m, struct ssh *ssh)
{
	struct session_state *state = ssh->state;
	struct sshbuf *b;
	int r;
	if ((b = sshbuf_new()) == NULL)
		return SSH_ERR_ALLOC_FAIL;
	if (state->compression_in_started) {
		if ((r = sshbuf_put_string(b, &state->compression_in_stream,
		    sizeof(state->compression_in_stream))) != 0)
			goto out;
	} else if ((r = sshbuf_put_string(b, NULL, 0)) != 0)
		goto out;
	if (state->compression_out_started) {
		if ((r = sshbuf_put_string(b, &state->compression_out_stream,
		    sizeof(state->compression_out_stream))) != 0)
			goto out;
	} else if ((r = sshbuf_put_string(b, NULL, 0)) != 0)
		goto out;
	r = sshbuf_put_stringb(m, b);
 out:
	sshbuf_free(b);
	return r;
}
",1
Detect whether the following code contains vulnerabilities.,"void Browser::FindInPage(bool find_next, bool forward_direction) {
  ShowFindBar();
  if (find_next) {
    string16 find_text;
#if defined(OS_MACOSX)
     find_text = GetFindPboardText();
 #endif
     GetSelectedTabContentsWrapper()->
        GetFindManager()->StartFinding(find_text,
                                       forward_direction,
                                       false);  // Not case sensitive.
   }
 }
",1
Detect whether the following code contains vulnerabilities.,"status_t SampleTable::setChunkOffsetParams(
 uint32_t type, off64_t data_offset, size_t data_size) {
 if (mChunkOffsetOffset >= 0) {
 return ERROR_MALFORMED;
 }

    CHECK(type == kChunkOffsetType32 || type == kChunkOffsetType64);

    mChunkOffsetOffset = data_offset;
    mChunkOffsetType = type;

 if (data_size < 8) {
 return ERROR_MALFORMED;
 }

 uint8_t header[8];
 if (mDataSource->readAt(
                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {
 return ERROR_IO;
 }

 if (U32_AT(header) != 0) {
 return ERROR_MALFORMED;
 }

    mNumChunkOffsets = U32_AT(&header[4]);

 if (mChunkOffsetType == kChunkOffsetType32) {
 if ((data_size - 8) / 4 < mNumChunkOffsets) {
 return ERROR_MALFORMED;
 }
 } else {
 if ((data_size - 8) / 8 < mNumChunkOffsets) {
 return ERROR_MALFORMED;
 }
 }

 return OK;
}
",0
Detect whether the following code contains vulnerabilities.,"MagickExport int ErrorBlob(const Image *image)
{
  BlobInfo
    *magick_restrict blob_info;

  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""..."");
  assert(image->blob != (BlobInfo *) NULL);
  assert(image->blob->type != UndefinedStream);
  blob_info=image->blob;
  switch (blob_info->type)
  {
    case UndefinedStream:
    case StandardStream:
      break;
    case FileStream:
    case PipeStream:
    {
      blob_info->error=ferror(blob_info->file_info.file);
      break;
    }
    case ZipStream:
    {
#if defined(MAGICKCORE_ZLIB_DELEGATE)
      (void) gzerror(blob_info->file_info.gzfile,&blob_info->error);
#endif
      break;
    }
    case BZipStream:
    {
#if defined(MAGICKCORE_BZLIB_DELEGATE)
      (void) BZ2_bzerror(blob_info->file_info.bzfile,&blob_info->error);
#endif
      break;
    }
    case FifoStream:
    {
      blob_info->error=0;
      break;
    }
    case BlobStream:
      break;
  }
  return(blob_info->error);
}
",0
Detect whether the following code contains vulnerabilities.,"static void update_open_stateflags(struct nfs4_state *state, mode_t open_flags)
 {
	switch (open_flags) {
 		case FMODE_WRITE:
 			state->n_wronly++;
 			break;
		case FMODE_READ:
			state->n_rdonly++;
			break;
 		case FMODE_READ|FMODE_WRITE:
 			state->n_rdwr++;
 	}
	nfs4_state_set_mode_locked(state, state->state | open_flags);
 }
",1
Detect whether the following code contains vulnerabilities.," static void sas_scsi_clear_queue_lu(struct list_head *error_q, struct scsi_cmnd *my_cmd)
 {
 	struct scsi_cmnd *cmd, *n;
 
 	list_for_each_entry_safe(cmd, n, error_q, eh_entry) {
 		if (cmd->device->sdev_target == my_cmd->device->sdev_target &&
 		    cmd->device->lun == my_cmd->device->lun)
			sas_eh_defer_cmd(cmd);
 	}
 }
",1
Detect whether the following code contains vulnerabilities.," void InfoBarContainer::ChangeTabContents(TabContents* contents) {
   registrar_.RemoveAll();
   RemoveAllChildViews(false);
   tab_contents_ = contents;
   if (tab_contents_) {
    UpdateInfoBars();
    Source<TabContents> tc_source(tab_contents_);
    registrar_.Add(this, NotificationType::TAB_CONTENTS_INFOBAR_ADDED,
                   tc_source);
    registrar_.Add(this, NotificationType::TAB_CONTENTS_INFOBAR_REMOVED,
                   tc_source);
    registrar_.Add(this, NotificationType::TAB_CONTENTS_INFOBAR_REPLACED,
                   tc_source);
  }
}
",1
Detect whether the following code contains vulnerabilities.,"cmsUInt32Number CMSEXPORT cmsMLUgetWide(const cmsMLU* mlu,
                                      const char LanguageCode[3], const char CountryCode[3],
                                      wchar_t* Buffer, cmsUInt32Number BufferSize)
{
    const wchar_t *Wide;
    cmsUInt32Number  StrLen = 0;

    cmsUInt16Number Lang  = _cmsAdjustEndianess16(*(cmsUInt16Number*) LanguageCode);
    cmsUInt16Number Cntry = _cmsAdjustEndianess16(*(cmsUInt16Number*) CountryCode);

    if (mlu == NULL) return 0;

    Wide = _cmsMLUgetWide(mlu, &StrLen, Lang, Cntry, NULL, NULL);
    if (Wide == NULL) return 0;

    if (Buffer == NULL) return StrLen + sizeof(wchar_t);

    if (BufferSize <= 0) return 0;

    if (BufferSize < StrLen + sizeof(wchar_t))
        StrLen = BufferSize - + sizeof(wchar_t);

    memmove(Buffer, Wide, StrLen);
    Buffer[StrLen / sizeof(wchar_t)] = 0;

    return StrLen + sizeof(wchar_t);
}
",0
Detect whether the following code contains vulnerabilities.,"void PasswordAutofillAgent::UpdateStateForTextChange(
    const WebInputElement& element) {
  if (!element.IsTextField())
    return;
  WebInputElement mutable_element = element;  // We need a non-const.

  const base::string16 element_value = element.Value().Utf16();
  field_data_manager_.UpdateFieldDataMap(element, element_value,
                                         FieldPropertiesFlags::USER_TYPED);

  ProvisionallySavePassword(element.Form(), element, RESTRICTION_NONE);

  if (element.IsPasswordFieldForAutofill()) {
    auto iter = password_to_username_.find(element);
    if (iter != password_to_username_.end()) {
      web_input_to_password_info_[iter->second].password_was_edited_last = true;
      mutable_element.SetAutofillState(WebAutofillState::kNotFilled);
    }
    GetPasswordManagerDriver()->UserModifiedPasswordField();
  } else {
    GetPasswordManagerDriver()->UserModifiedNonPasswordField(
        element.UniqueRendererFormControlId(), element_value);
  }
}
",0
Detect whether the following code contains vulnerabilities.,"drive_eject_completed_cb (DBusGMethodInvocation *context,
                          Device *device,
                          gboolean job_was_cancelled,
                          int status,
                          const char *stderr,
                          const char *stdout,
                          gpointer user_data)
{
  if (WEXITSTATUS (status) == 0 && !job_was_cancelled)
    {
      /* TODO: probably wait for has_media to change to FALSE */
      dbus_g_method_return (context);
    }
  else
    {
      if (job_was_cancelled)
        {
          throw_error (context, ERROR_CANCELLED, ""Job was cancelled"");
        }
      else
        {
          throw_error (context,
                       ERROR_FAILED,
                       ""Error ejecting: eject exited with exit code %d: %s"",
                       WEXITSTATUS (status),
                       stderr);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"sec_reset_state(void)
{
	g_server_rdp_version = 0;
	g_sec_encrypt_use_count = 0;
	g_sec_decrypt_use_count = 0;
	g_licence_issued = 0;
	g_licence_error_result = 0;
	mcs_reset_state();
}
",0
Detect whether the following code contains vulnerabilities.,"SIZED_STRING* yr_re_ast_extract_literal(
    RE_AST* re_ast)
{
  SIZED_STRING* string;
  RE_NODE* node = re_ast->root_node;

  int i, length = 0;
  char tmp;

  while (node != NULL)
  {
    length++;

    if (node->type == RE_NODE_LITERAL)
      break;

    if (node->type != RE_NODE_CONCAT)
      return NULL;

    if (node->right == NULL ||
        node->right->type != RE_NODE_LITERAL)
      return NULL;

    node = node->left;
  }

  string = (SIZED_STRING*) yr_malloc(sizeof(SIZED_STRING) + length);

  if (string == NULL)
    return NULL;

  string->length = 0;

  node = re_ast->root_node;

  while (node->type == RE_NODE_CONCAT)
  {
    string->c_string[string->length++] = node->right->value;
    node = node->left;
  }

  string->c_string[string->length++] = node->value;


  for (i = 0; i < length / 2; i++)
  {
    tmp = string->c_string[i];
    string->c_string[i] = string->c_string[length - i - 1];
    string->c_string[length - i - 1] = tmp;
  }

  return string;
}
",0
Detect whether the following code contains vulnerabilities.,"void MediaElementAudioSourceHandler::Process(size_t number_of_frames) {
  AudioBus* output_bus = Output(0).Bus();

  MutexTryLocker try_locker(process_lock_);
  if (try_locker.Locked()) {
    if (!MediaElement() || !source_sample_rate_) {
      output_bus->Zero();
      return;
    }

    if (source_number_of_channels_ != output_bus->NumberOfChannels()) {
      output_bus->Zero();
      return;
    }

    AudioSourceProvider& provider = MediaElement()->GetAudioSourceProvider();
    if (multi_channel_resampler_.get()) {
      DCHECK_NE(source_sample_rate_, Context()->sampleRate());
      multi_channel_resampler_->Process(&provider, output_bus,
                                        number_of_frames);
    } else {
      DCHECK_EQ(source_sample_rate_, Context()->sampleRate());
       provider.ProvideInput(output_bus, number_of_frames);
     }
    if (!PassesCORSAccessCheck()) {
      if (maybe_print_cors_message_) {
        maybe_print_cors_message_ = false;
        PostCrossThreadTask(
            *task_runner_, FROM_HERE,
            CrossThreadBind(&MediaElementAudioSourceHandler::PrintCORSMessage,
                            WrapRefCounted(this), current_src_string_));
      }
       output_bus->Zero();
     }
   } else {
    output_bus->Zero();
  }
}
",1
Detect whether the following code contains vulnerabilities.,"static int accept_server_socket(int sfd)
{
 struct sockaddr_un remote;
 struct pollfd pfd;
 int fd;
 socklen_t len = sizeof(struct sockaddr_un);

    BTIF_TRACE_EVENT(""accept fd %d"", sfd);

 /* make sure there is data to process */

     pfd.fd = sfd;
     pfd.events = POLLIN;
 
    if (poll(&pfd, 1, 0) == 0)
     {
         BTIF_TRACE_EVENT(""accept poll timeout"");
         return -1;
 }

 
 
    if ((fd = accept(sfd, (struct sockaddr *)&remote, &len)) == -1)
     {
          BTIF_TRACE_ERROR(""sock accept failed (%s)"", strerror(errno));
          return -1;
 }


 return fd;
}
",1
Detect whether the following code contains vulnerabilities.,"static bool tcp_prune_ofo_queue(struct sock *sk)
{
	struct tcp_sock *tp = tcp_sk(sk);
	bool res = false;

	if (!skb_queue_empty(&tp->out_of_order_queue)) {
		NET_INC_STATS(sock_net(sk), LINUX_MIB_OFOPRUNED);
		__skb_queue_purge(&tp->out_of_order_queue);

		/* Reset SACK state.  A conforming SACK implementation will
		 * do the same at a timeout based retransmit.  When a connection
		 * is in a sad state like this, we care only about integrity
		 * of the connection not performance.
		 */
		if (tp->rx_opt.sack_ok)
			tcp_sack_reset(&tp->rx_opt);
		sk_mem_reclaim(sk);
		res = true;
	}
	return res;
}
",0
Detect whether the following code contains vulnerabilities.,"struct net_bridge_mdb_entry *br_mdb_get(struct net_bridge *br,
					struct sk_buff *skb, u16 vid)
{
	struct net_bridge_mdb_htable *mdb = rcu_dereference(br->mdb);
	struct br_ip ip;

	if (br->multicast_disabled)
		return NULL;

	if (BR_INPUT_SKB_CB(skb)->igmp)
		return NULL;

	ip.proto = skb->protocol;
	ip.vid = vid;

	switch (skb->protocol) {
	case htons(ETH_P_IP):
		ip.u.ip4 = ip_hdr(skb)->daddr;
		break;
#if IS_ENABLED(CONFIG_IPV6)
	case htons(ETH_P_IPV6):
		ip.u.ip6 = ipv6_hdr(skb)->daddr;
		break;
#endif
	default:
		return NULL;
	}

	return br_mdb_ip_get(mdb, &ip);
}
",0
Detect whether the following code contains vulnerabilities.,"InputImeEventRouter* GetInputImeEventRouter(Profile* profile) {
   if (!profile)
     return nullptr;
   return extensions::InputImeEventRouterFactory::GetInstance()->GetRouter(
      profile->GetOriginalProfile());
 }
",1
Detect whether the following code contains vulnerabilities.,"  write_message( RenderState  state )
  {
    ADisplay  adisplay = (ADisplay)state->display.disp;


    if ( state->message == NULL )
    {
      FontFace  face = &state->faces[state->face_index];
      int       idx, total;


      idx   = face->index;
      total = 1;
      while ( total + state->face_index < state->num_faces &&
              face[total].filepath == face[0].filepath     )
        total++;

      total += idx;
 
       state->message = state->message0;
       if ( total > 1 )
        sprintf( state->message0, ""%s %d/%d @ %5.1fpt"",
                  state->filename, idx + 1, total,
                  state->char_size );
       else
        sprintf( state->message0, ""%s @ %5.1fpt"",
                  state->filename,
                  state->char_size );
     }

    grWriteCellString( adisplay->bitmap, 0, DIM_Y - 10, state->message,
                       adisplay->fore_color );

    state->message = NULL;
  }
",1
Detect whether the following code contains vulnerabilities.,"static void fpm_child_free(struct fpm_child_s *child) /* {{{ */
{
	free(child);
}
/* }}} */
",0
Detect whether the following code contains vulnerabilities.,"rx_cache_insert(netdissect_options *ndo,
                const u_char *bp, const struct ip *ip, int dport)
{
	struct rx_cache_entry *rxent;
	const struct rx_header *rxh = (const struct rx_header *) bp;

	if (ndo->ndo_snapend - bp + 1 <= (int)(sizeof(struct rx_header) + sizeof(int32_t)))
		return;

	rxent = &rx_cache[rx_cache_next];

	if (++rx_cache_next >= RX_CACHE_SIZE)
		rx_cache_next = 0;

	rxent->callnum = EXTRACT_32BITS(&rxh->callNumber);
 	UNALIGNED_MEMCPY(&rxent->client, &ip->ip_src, sizeof(uint32_t));
 	UNALIGNED_MEMCPY(&rxent->server, &ip->ip_dst, sizeof(uint32_t));
 	rxent->dport = dport;
	rxent->serviceId = EXTRACT_32BITS(&rxh->serviceId);
 	rxent->opcode = EXTRACT_32BITS(bp + sizeof(struct rx_header));
 }
",1
Detect whether the following code contains vulnerabilities.,"void ResourceDispatcherHostImpl::OnSSLCertificateError(
    net::URLRequest* request,
    const net::SSLInfo& ssl_info,
    bool is_hsts_host) {
  DCHECK(request);
  ResourceRequestInfoImpl* info = ResourceRequestInfoImpl::ForRequest(request);
  DCHECK(info);
  GlobalRequestID request_id(info->GetChildID(), info->GetRequestID());
  int render_process_id;
   int render_view_id;
   if(!info->GetAssociatedRenderView(&render_process_id, &render_view_id))
     NOTREACHED();
  SSLManager::OnSSLCertificateError(ssl_delegate_weak_factory_.GetWeakPtr(),
      request_id, info->GetResourceType(), request->url(), render_process_id,
      render_view_id, ssl_info, is_hsts_host);
 }
",1
Detect whether the following code contains vulnerabilities.," void HttpAuthFilterWhitelist::SetWhitelist(
     const std::string& server_whitelist) {
  rules_.ParseFromString(server_whitelist);
 }
",1
Detect whether the following code contains vulnerabilities.," static unsigned int seedsize(struct crypto_alg *alg)
 {
 	struct rng_alg *ralg = container_of(alg, struct rng_alg, base);
 
	return alg->cra_rng.rng_make_random ?
	       alg->cra_rng.seedsize : ralg->seedsize;
 }
",1
Detect whether the following code contains vulnerabilities.,"static void tcp_v4_reqsk_destructor(struct request_sock *req)
{
	kfree(inet_rsk(req)->opt);
}
",0
Detect whether the following code contains vulnerabilities.,"static int nbd_negotiate_drop_sync(QIOChannel *ioc, size_t size)
{
    ssize_t ret;
    uint8_t *buffer = g_malloc(MIN(65536, size));
    while (size > 0) {
        size_t count = MIN(65536, size);
        ret = nbd_negotiate_read(ioc, buffer, count);
        if (ret < 0) {
            g_free(buffer);
            return ret;
        }
        size -= count;
    }
    g_free(buffer);
    return 0;
}
",1
Detect whether the following code contains vulnerabilities.,"entry_guard_obeys_restriction(const entry_guard_t *guard,
                              const entry_guard_restriction_t *rst)
{
  tor_assert(guard);
   if (! rst)
     return 1; // No restriction?  No problem.
 
   return tor_memneq(guard->identity, rst->exclude_id, DIGEST_LEN);
 }
",1
Detect whether the following code contains vulnerabilities.,"const PPB_NaCl_Private* GetNaclInterface() {
  pp::Module *module = pp::Module::Get();
  CHECK(module);
  return static_cast<const PPB_NaCl_Private*>(
      module->GetBrowserInterface(PPB_NACL_PRIVATE_INTERFACE));
}
",1
Detect whether the following code contains vulnerabilities.,"static struct dentry *udf_fh_to_parent(struct super_block *sb,
				       struct fid *fid, int fh_len, int fh_type)
{
	if (fh_len != 5 || fh_type != FILEID_UDF_WITH_PARENT)
		return NULL;

	return udf_nfs_get_inode(sb, fid->udf.parent_block,
				 fid->udf.parent_partref,
				 fid->udf.parent_generation);
}
",0
Detect whether the following code contains vulnerabilities.,"static int vapic_enter(struct kvm_vcpu *vcpu)
{
	struct kvm_lapic *apic = vcpu->arch.apic;
	struct page *page;
	if (!apic || !apic->vapic_addr)
		return 0;
	page = gfn_to_page(vcpu->kvm, apic->vapic_addr >> PAGE_SHIFT);
	if (is_error_page(page))
		return -EFAULT;
	vcpu->arch.apic->vapic_page = page;
	return 0;
}
",1
Detect whether the following code contains vulnerabilities.,"void ShelfLayoutManager::ProcessGestureEventOfAutoHideShelf(
    ui::GestureEvent* event,
    aura::Window* target) {
  const bool is_shelf_window = IsShelfWindow(target);
  if (IsVisible() || in_shutdown_) {
    if (!is_shelf_window && !IsStatusAreaWindow(target) &&
        visibility_state() == SHELF_AUTO_HIDE &&
        state_.auto_hide_state == SHELF_AUTO_HIDE_SHOWN &&
        event->type() == ui::ET_GESTURE_TAP) {
      UpdateAutoHideState();
    }
    return;
  }

  if (is_shelf_window) {
    ui::GestureEvent event_in_screen(*event);
    gfx::Point location_in_screen(event->location());
    ::wm::ConvertPointToScreen(target, &location_in_screen);
    event_in_screen.set_location(location_in_screen);
    if (ProcessGestureEvent(event_in_screen))
      event->StopPropagation();
  }
}
",0
Detect whether the following code contains vulnerabilities.," int re_yyget_lineno  (yyscan_t yyscanner)
 {
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
         if (! YY_CURRENT_BUFFER)
             return 0;
     
    return yylineno;
}
",1
Detect whether the following code contains vulnerabilities.,"static const char *func_id_name(int id)
{
	BUILD_BUG_ON(ARRAY_SIZE(func_id_str) != __BPF_FUNC_MAX_ID);

	if (id >= 0 && id < __BPF_FUNC_MAX_ID && func_id_str[id])
		return func_id_str[id];
	else
		return ""unknown"";
}
",0
Detect whether the following code contains vulnerabilities.,"bt_status_t btif_hh_execute_service(BOOLEAN b_enable)
{
 if (b_enable)
 {
 /* Enable and register with BTA-HH */
          BTA_HhEnable(BTUI_HH_SECURITY, bte_hh_evt);
 }
 else {
 /* Disable HH */
         BTA_HhDisable();
 }
 return BT_STATUS_SUCCESS;
}
",0
Detect whether the following code contains vulnerabilities.,"static void set_maintenance_mode(void *send_info, bool enable)
{
	struct smi_info   *smi_info = send_info;

	if (!enable)
		atomic_set(&smi_info->req_events, 0);
}
",0
Detect whether the following code contains vulnerabilities.,"int WebContentsImpl::DownloadImage(
    const GURL& url,
    bool is_favicon,
    uint32_t max_bitmap_size,
    bool bypass_cache,
    const WebContents::ImageDownloadCallback& callback) {
  DCHECK_CURRENTLY_ON(BrowserThread::UI);
  static int next_image_download_id = 0;
  const image_downloader::ImageDownloaderPtr& mojo_image_downloader =
      GetMainFrame()->GetMojoImageDownloader();
  const int download_id = ++next_image_download_id;
  if (!mojo_image_downloader) {
     BrowserThread::PostTask(
         BrowserThread::UI, FROM_HERE,
        base::Bind(&WebContents::ImageDownloadCallback::Run,
                   base::Owned(new ImageDownloadCallback(callback)),
                   download_id, 400, url, std::vector<SkBitmap>(),
                   std::vector<gfx::Size>()));
     return download_id;
   }
 
  image_downloader::DownloadRequestPtr req =
      image_downloader::DownloadRequest::New();

  req->url = mojo::String::From(url);
  req->is_favicon = is_favicon;
  req->max_bitmap_size = max_bitmap_size;
   req->bypass_cache = bypass_cache;
 
   mojo_image_downloader->DownloadImage(
      std::move(req),
      base::Bind(&DidDownloadImage, callback, download_id, url));
   return download_id;
 }
",1
Detect whether the following code contains vulnerabilities.," void EncoderTest::InitializeConfig() {
   const vpx_codec_err_t res = codec_->DefaultEncoderConfig(&cfg_, 0);
   ASSERT_EQ(VPX_CODEC_OK, res);
 }
",1
Detect whether the following code contains vulnerabilities.,"bool XSSAuditor::FilterInputToken(const FilterTokenRequest& request) {
  DCHECK_EQ(request.token.GetType(), HTMLToken::kStartTag);
  DCHECK(HasName(request.token, inputTag));

  return EraseAttributeIfInjected(request, formactionAttr, kURLWithUniqueOrigin,
                                  kSrcLikeAttributeTruncation);
}
",0
Detect whether the following code contains vulnerabilities.,"NDIS_STATUS ParaNdis6_ReceivePauseRestart(
    PARANDIS_ADAPTER *pContext,
    BOOLEAN bPause,
    ONPAUSECOMPLETEPROC Callback
    )
{
    NDIS_STATUS status = NDIS_STATUS_SUCCESS;

    if (bPause)
    {
        CNdisPassiveWriteAutoLock tLock(pContext->m_PauseLock);

        ParaNdis_DebugHistory(pContext, hopInternalReceivePause, NULL, 1, 0, 0);
        if (pContext->m_upstreamPacketPending != 0)
        {
            pContext->ReceiveState = srsPausing;
            pContext->ReceivePauseCompletionProc = Callback;
            status = NDIS_STATUS_PENDING;
        }
        else
        {
            ParaNdis_DebugHistory(pContext, hopInternalReceivePause, NULL, 0, 0, 0);
            pContext->ReceiveState = srsDisabled;
        }
    }
    else
    {
        ParaNdis_DebugHistory(pContext, hopInternalReceiveResume, NULL, 0, 0, 0);
        pContext->ReceiveState = srsEnabled;
    }
    return status;
}
",0
Detect whether the following code contains vulnerabilities.,"static int store_xauthority(void) {
	fs_build_mnt_dir();
 
 	char *src;
 	char *dest = RUN_XAUTHORITY_FILE;
 	FILE *fp = fopen(dest, ""w"");
 	if (fp) {
 		fprintf(fp, ""\n"");
		SET_PERMS_STREAM(fp, getuid(), getgid(), 0600);
		fclose(fp);
	}
	
	if (asprintf(&src, ""%s/.Xauthority"", cfg.homedir) == -1)
		errExit(""asprintf"");
	
	struct stat s;
	if (stat(src, &s) == 0) {
		if (is_link(src)) {
			fprintf(stderr, ""Warning: invalid .Xauthority file\n"");
			return 0;
		}

		copy_file_as_user(src, dest, getuid(), getgid(), 0600);
		fs_logger2(""clone"", dest);
		return 1; // file copied
	}
	
	return 0;
}
",1
Detect whether the following code contains vulnerabilities.,"static const char *default_charset(void)
{
# if defined HAVE_LIBCHARSET_H && defined HAVE_LOCALE_CHARSET
	return locale_charset();
# elif defined HAVE_LANGINFO_H && defined HAVE_NL_LANGINFO
	return nl_langinfo(CODESET);
# else
	return """"; /* Works with (at the very least) gnu iconv... */
# endif
}
",0
Detect whether the following code contains vulnerabilities.,"   void SetManualFallbacksForFilling(bool enabled) {
     if (enabled) {
       scoped_feature_list_.InitAndEnableFeature(
          password_manager::features::kEnableManualFallbacksFilling);
     } else {
       scoped_feature_list_.InitAndDisableFeature(
          password_manager::features::kEnableManualFallbacksFilling);
     }
   }
",1
Detect whether the following code contains vulnerabilities.,"ForeignSessionHelper::ForeignSessionHelper(Profile* profile)
    : profile_(profile) {
  sync_sessions::SessionSyncService* service =
      SessionSyncServiceFactory::GetInstance()->GetForProfile(profile);

  if (service) {
    foreign_session_updated_subscription_ =
        service->SubscribeToForeignSessionsChanged(base::BindRepeating(
            &ForeignSessionHelper::FireForeignSessionCallback,
            base::Unretained(this)));
  }
}
",0
Detect whether the following code contains vulnerabilities.,"SProcRenderCreateRadialGradient (ClientPtr client)
{
    register int n;
    int len;
    REQUEST (xRenderCreateRadialGradientReq);
    REQUEST_AT_LEAST_SIZE (xRenderCreateRadialGradientReq);

    swaps(&stuff->length, n);
    swapl(&stuff->pid, n);
    swapl(&stuff->inner.x, n);
    swapl(&stuff->inner.y, n);
    swapl(&stuff->outer.x, n);
    swapl(&stuff->outer.y, n);
    swapl(&stuff->inner_radius, n);
    swapl(&stuff->outer_radius, n);
    swapl(&stuff->nStops, n);

    len = (client->req_len << 2) - sizeof(xRenderCreateRadialGradientReq);
    if (stuff->nStops > UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
	return BadLength;
    if (len != stuff->nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
        return BadLength;

    swapStops(stuff+1, stuff->nStops);

    return (*ProcRenderVector[stuff->renderReqType]) (client);
}
",0
Detect whether the following code contains vulnerabilities.,"void RenderView::OnFillPasswordForm(
    const webkit_glue::PasswordFormFillData& form_data) {
#if defined(WEBKIT_BUG_41283_IS_FIXED)
  password_autocomplete_manager_.ReceivedPasswordFormFillData(webview(),
                                                              form_data);
#else
  webkit_glue::FillPasswordForm(this->webview(), form_data);
#endif
}
",0
Detect whether the following code contains vulnerabilities.,"void PreconnectManager::StartPreconnectUrl(
    const GURL& url,
    bool allow_credentials,
    net::NetworkIsolationKey network_isolation_key) {
  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
  if (!url.SchemeIsHTTPOrHTTPS())
    return;
  PreresolveJobId job_id = preresolve_jobs_.Add(std::make_unique<PreresolveJob>(
      url.GetOrigin(), 1, allow_credentials, std::move(network_isolation_key),
      nullptr));
  queued_jobs_.push_front(job_id);

  TryToLaunchPreresolveJobs();
}
",0
Detect whether the following code contains vulnerabilities.,"val_wrap_iov_args(
    OM_uint32 *minor_status,
    gss_ctx_id_t context_handle,
    int conf_req_flag,
    gss_qop_t qop_req,
    int *conf_state,
    gss_iov_buffer_desc *iov,
    int iov_count)
{

    /* Initialize outputs. */

    if (minor_status != NULL)
	*minor_status = 0;

    /* Validate arguments. */

    if (minor_status == NULL)
	return (GSS_S_CALL_INACCESSIBLE_WRITE);

    if (context_handle == GSS_C_NO_CONTEXT)
	return (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);

    if (iov == GSS_C_NO_IOV_BUFFER)
	return (GSS_S_CALL_INACCESSIBLE_READ);

    return (GSS_S_COMPLETE);
}
",0
Detect whether the following code contains vulnerabilities.,"static int i8042_start(struct serio *serio)
 {
 	struct i8042_port *port = serio->port_data;
 
 	port->exists = true;
	mb();
 	return 0;
 }
",1
Detect whether the following code contains vulnerabilities.,"void mp_decode_to_lua_array(lua_State *L, mp_cur *c, size_t len) {
    assert(len <= UINT_MAX);
     int index = 1;
 
     lua_newtable(L);
     while(len--) {
         lua_pushnumber(L,index++);
         mp_decode_to_lua_type(L,c);
        if (c->err) return;
        lua_settable(L,-3);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"  cff_decoder_init( CFF_Decoder*    decoder,
                    TT_Face         face,
                    CFF_Size        size,
                    CFF_GlyphSlot   slot,
                    FT_Bool         hinting,
                    FT_Render_Mode  hint_mode )
  {
    CFF_Font  cff = (CFF_Font)face->extra.data;


    /* clear everything */
    FT_MEM_ZERO( decoder, sizeof ( *decoder ) );

    /* initialize builder */
    cff_builder_init( &decoder->builder, face, size, slot, hinting );

    /* initialize Type2 decoder */
    decoder->cff          = cff;
    decoder->num_globals  = cff->global_subrs_index.count;
    decoder->globals      = cff->global_subrs;
    decoder->globals_bias = cff_compute_bias(
                              cff->top_font.font_dict.charstring_type,
                              decoder->num_globals );

    decoder->hint_mode    = hint_mode;
  }
",0
Detect whether the following code contains vulnerabilities.," bool PluginInstance::Start(const GURL& url,
                            char** const param_names,
                            char** const param_values,
                           int param_count,
                           bool load_manually) {
  load_manually_ = load_manually;
  unsigned short mode = load_manually_ ? NP_FULL : NP_EMBED;
  npp_->ndata = this;

  NPError err = NPP_New(mode, param_count,
      const_cast<char **>(param_names), const_cast<char **>(param_values));
  return err == NPERR_NO_ERROR;
}
",0
Detect whether the following code contains vulnerabilities.,"void ApiTestEnvironment::RunPromisesAgain() {
  env()->isolate()->RunMicrotasks();
  base::MessageLoop::current()->PostTask(
      FROM_HERE, base::Bind(&ApiTestEnvironment::RunPromisesAgain,
                            base::Unretained(this)));
}
",0
Detect whether the following code contains vulnerabilities.,"static int iwch_l2t_send(struct t3cdev *tdev, struct sk_buff *skb, struct l2t_entry *l2e)
{
	int	error = 0;
	struct cxio_rdev *rdev;

	rdev = (struct cxio_rdev *)tdev->ulp;
	if (cxio_fatal_error(rdev)) {
		kfree_skb(skb);
		return -EIO;
	}
 	error = l2t_send(tdev, skb, l2e);
 	if (error < 0)
 		kfree_skb(skb);
	return error;
 }
",1
Detect whether the following code contains vulnerabilities.,"cJSON *cJSON_CreateObject( void )
{
	cJSON *item = cJSON_New_Item();
	if ( item )
		item->type = cJSON_Object;
	return item;
}
",1
Detect whether the following code contains vulnerabilities.,"DrawingBuffer::DrawingBuffer(
    std::unique_ptr<WebGraphicsContext3DProvider> context_provider,
    std::unique_ptr<Extensions3DUtil> extensions_util,
    Client* client,
    bool discard_framebuffer_supported,
     bool want_alpha_channel,
     bool premultiplied_alpha,
     PreserveDrawingBuffer preserve,
    WebGLVersion web_gl_version,
     bool want_depth,
     bool want_stencil,
     ChromiumImageUsage chromium_image_usage,
     const CanvasColorParams& color_params)
     : client_(client),
       preserve_drawing_buffer_(preserve),
      web_gl_version_(web_gl_version),
       context_provider_(WTF::WrapUnique(new WebGraphicsContext3DProviderWrapper(
           std::move(context_provider)))),
       gl_(this->ContextProvider()->ContextGL()),
      extensions_util_(std::move(extensions_util)),
      discard_framebuffer_supported_(discard_framebuffer_supported),
      want_alpha_channel_(want_alpha_channel),
      premultiplied_alpha_(premultiplied_alpha),
      software_rendering_(this->ContextProvider()->IsSoftwareRendering()),
      want_depth_(want_depth),
      want_stencil_(want_stencil),
      color_space_(color_params.GetGfxColorSpace()),
      chromium_image_usage_(chromium_image_usage) {
  TRACE_EVENT_INSTANT0(""test_gpu"", ""DrawingBufferCreation"",
                       TRACE_EVENT_SCOPE_GLOBAL);
}
",1
Detect whether the following code contains vulnerabilities.,"void BlacklistAddOneDll(const wchar_t* module_name,
                        bool check_in_browser,
                        sandbox::TargetPolicy* policy) {
  HMODULE module = check_in_browser ? ::GetModuleHandleW(module_name) : NULL;
  if (!module) {
    std::wstring name(module_name);
    size_t period = name.rfind(L'.');
    DCHECK_NE(std::string::npos, period);
    DCHECK_LE(3U, (name.size() - period));
    if (period <= 8)
      return;
    for (int ix = 0; ix < 3; ++ix) {
      const wchar_t suffix[] = {'~', ('1' + ix), 0};
      std::wstring alt_name = name.substr(0, 6) + suffix;
      alt_name += name.substr(period, name.size());
      if (check_in_browser) {
        module = ::GetModuleHandleW(alt_name.c_str());
        if (!module)
          return;
        if (!IsExpandedModuleName(module, module_name))
          return;
      }
      policy->AddDllToUnload(alt_name.c_str());
    }
  }
  policy->AddDllToUnload(module_name);
  DVLOG(1) << ""dll to unload found: "" << module_name;
  return;
}
",0
Detect whether the following code contains vulnerabilities.,"void RenderFrameDevToolsAgentHost::DestroyOnRenderFrameGone() {
   scoped_refptr<RenderFrameDevToolsAgentHost> protect(this);
   if (IsAttached())
     RevokePolicy();
  ForceDetachAllClients();
   frame_host_ = nullptr;
   agent_ptr_.reset();
   SetFrameTreeNode(nullptr);
  Release();
}
",1
Detect whether the following code contains vulnerabilities.,"static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)

 {
     const char *perm = ""add"";
 
    if (uid >= AID_APP) {
         return 0; /* Don't allow apps to register services */
     }
 
 return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;
}
",1
Detect whether the following code contains vulnerabilities.,"void RenderFrameImpl::OnGetSerializedHtmlWithLocalLinks(
    const std::map<GURL, base::FilePath>& url_to_local_path,
    const std::map<int, base::FilePath>& frame_routing_id_to_local_path) {
  LinkRewritingDelegate delegate(url_to_local_path,
                                 frame_routing_id_to_local_path);

  WebFrameSerializer::Serialize(GetWebFrame(),
                                this,  // WebFrameSerializerClient.
                                &delegate);
}
",0
Detect whether the following code contains vulnerabilities.,"conv_swap4bytes(const UChar* s, const UChar* end, UChar* conv)
{
  while (s < end) {
    *conv++ = s[3];
    *conv++ = s[2];
    *conv++ = s[1];
    *conv++ = s[0];
    s += 4;
  }
}
",0
Detect whether the following code contains vulnerabilities.,"Condor_Auth_SSL::decrypt(unsigned char* input, int input_len, 
							unsigned char* & output, int& output_len)
{
	return encrypt_or_decrypt(false,input,input_len,output,output_len);
}
",0
Detect whether the following code contains vulnerabilities.,"WebMouseEvent* BuildMouseEvent(const PP_InputEvent& event) {
  WebMouseEvent* mouse_event = new WebMouseEvent();
  switch (event.type) {
    case PP_INPUTEVENT_TYPE_MOUSEDOWN:
      mouse_event->type = WebInputEvent::MouseDown;
      break;
    case PP_INPUTEVENT_TYPE_MOUSEUP:
      mouse_event->type = WebInputEvent::MouseUp;
      break;
    case PP_INPUTEVENT_TYPE_MOUSEMOVE:
      mouse_event->type = WebInputEvent::MouseMove;
      break;
    case PP_INPUTEVENT_TYPE_MOUSEENTER:
      mouse_event->type = WebInputEvent::MouseEnter;
      break;
     case PP_INPUTEVENT_TYPE_MOUSELEAVE:
       mouse_event->type = WebInputEvent::MouseLeave;
       break;
     default:
       NOTREACHED();
   }
  mouse_event->timeStampSeconds = event.time_stamp;
  mouse_event->modifiers = event.u.mouse.modifier;
  mouse_event->button =
      static_cast<WebMouseEvent::Button>(event.u.mouse.button);
  mouse_event->x = static_cast<int>(event.u.mouse.x);
  mouse_event->y = static_cast<int>(event.u.mouse.y);
  mouse_event->clickCount = event.u.mouse.click_count;
  return mouse_event;
}
",1
Detect whether the following code contains vulnerabilities.,"png_set_tIME(png_structp png_ptr, png_infop info_ptr, png_timep mod_time)
{
   png_debug1(1, ""in %s storage function"", ""tIME"");

   if (png_ptr == NULL || info_ptr == NULL ||
        (png_ptr->mode & PNG_WROTE_tIME))
       return;
 
    png_memcpy(&(info_ptr->mod_time), mod_time, png_sizeof(png_time));
    info_ptr->valid |= PNG_INFO_tIME;
 }
",1
Detect whether the following code contains vulnerabilities.,"WebInputEvent* CreateWebInputEvent(const PP_InputEvent& event) {
  scoped_ptr<WebInputEvent> web_input_event;
  switch (event.type) {
    case PP_INPUTEVENT_TYPE_UNDEFINED:
      return NULL;
    case PP_INPUTEVENT_TYPE_MOUSEDOWN:
    case PP_INPUTEVENT_TYPE_MOUSEUP:
     case PP_INPUTEVENT_TYPE_MOUSEMOVE:
     case PP_INPUTEVENT_TYPE_MOUSEENTER:
     case PP_INPUTEVENT_TYPE_MOUSELEAVE:
       web_input_event.reset(BuildMouseEvent(event));
       break;
     case PP_INPUTEVENT_TYPE_MOUSEWHEEL:
      web_input_event.reset(BuildMouseWheelEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_RAWKEYDOWN:
    case PP_INPUTEVENT_TYPE_KEYDOWN:
    case PP_INPUTEVENT_TYPE_KEYUP:
      web_input_event.reset(BuildKeyEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_CHAR:
      web_input_event.reset(BuildCharEvent(event));
      break;
  }
 
   return web_input_event.release();
 }
",1
Detect whether the following code contains vulnerabilities.," do_prefetch_tables (const void *gcmM, size_t gcmM_size)
 {
   prefetch_table(gcmM, gcmM_size);
  prefetch_table(gcmR, sizeof(gcmR));
 }
",1
Detect whether the following code contains vulnerabilities.,"void RenderFrameImpl::BubbleLogicalScrollInParentFrame(
    blink::WebScrollDirection direction,
    blink::WebScrollGranularity granularity) {
  DCHECK(IsLocalRoot());
  DCHECK(!IsMainFrame());
  Send(new FrameHostMsg_BubbleLogicalScrollInParentFrame(routing_id_, direction,
                                                         granularity));
}
",0
Detect whether the following code contains vulnerabilities.,"uint8_t CSPSourceList::hashAlgorithmsUsed() const
{
    return m_hashAlgorithmsUsed;
}
",0
Detect whether the following code contains vulnerabilities.,"static bool tailmatch(const char *little, const char *bigone)
 {
  size_t littlelen = strlen(little);
  size_t biglen = strlen(bigone);
 
  if(littlelen > biglen)
     return FALSE;
 
  return Curl_raw_equal(little, bigone+biglen-littlelen) ? TRUE : FALSE;
 }
",1
Detect whether the following code contains vulnerabilities.,"void FrameLoader::loadArchive(PassRefPtr<Archive> prpArchive)
{
    RefPtr<Archive> archive = prpArchive;
    
    ArchiveResource* mainResource = archive->mainResource();
    ASSERT(mainResource);
    if (!mainResource)
        return;
        
    SubstituteData substituteData(mainResource->data(), mainResource->mimeType(), mainResource->textEncoding(), KURL());
    
    ResourceRequest request(mainResource->url());
#if PLATFORM(MAC)
    request.applyWebArchiveHackForMail();
#endif

    RefPtr<DocumentLoader> documentLoader = m_client->createDocumentLoader(request, substituteData);
    documentLoader->addAllArchiveResources(archive.get());
    load(documentLoader.get());
}
",0
Detect whether the following code contains vulnerabilities.,"static void get_timewait4_sock(struct inet_timewait_sock *tw,
			       struct seq_file *f, int i, int *len)
{
	__be32 dest, src;
	__u16 destp, srcp;
	int ttd = tw->tw_ttd - jiffies;

	if (ttd < 0)
		ttd = 0;

	dest  = tw->tw_daddr;
	src   = tw->tw_rcv_saddr;
	destp = ntohs(tw->tw_dport);
	srcp  = ntohs(tw->tw_sport);

	seq_printf(f, ""%4d: %08X:%04X %08X:%04X""
		"" %02X %08X:%08X %02X:%08lX %08X %5d %8d %d %d %p%n"",
		i, src, srcp, dest, destp, tw->tw_substate, 0, 0,
		3, jiffies_to_clock_t(ttd), 0, 0, 0, 0,
		atomic_read(&tw->tw_refcnt), tw, len);
}
",0
Detect whether the following code contains vulnerabilities.,"atol10(const char *p, size_t char_cnt)
{
 	uint64_t l;
 	int digit;
 
 	l = 0;
 	digit = *p - '0';
 	while (digit >= 0 && digit < 10  && char_cnt-- > 0) {
		l = (l * 10) + digit;
		digit = *++p - '0';
	}
	return (l);
}
",1
Detect whether the following code contains vulnerabilities.," void BlobURLRegistry::unregisterURL(const KURL& url)
 {
    ThreadableBlobRegistry::unregisterBlobURL(url);
 }
",1
Detect whether the following code contains vulnerabilities.,"bool HpackDecoder::DecodeNextIndexedHeader(HpackInputStream* input_stream) {
  uint32 index = 0;
  if (!input_stream->DecodeNextUint32(&index))
    return false;

  HpackEntry* entry = header_table_.GetByIndex(index);
   if (entry == NULL)
     return false;
 
  HandleHeaderRepresentation(entry->name(), entry->value());
  return true;
 }
",1
Detect whether the following code contains vulnerabilities.,"status_t SampleTable::setTimeToSampleParams(
 off64_t data_offset, size_t data_size) {
 if (mTimeToSample != NULL || data_size < 8) {
 return ERROR_MALFORMED;
 }

 uint8_t header[8];
 if (mDataSource->readAt(
                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {
 return ERROR_IO;
 }

 if (U32_AT(header) != 0) {
 return ERROR_MALFORMED;

     }
 
     mTimeToSampleCount = U32_AT(&header[4]);
    uint64_t allocSize = mTimeToSampleCount * 2 * sizeof(uint32_t);
     if (allocSize > SIZE_MAX) {
         return ERROR_OUT_OF_RANGE;
     }
    mTimeToSample = new uint32_t[mTimeToSampleCount * 2];

 size_t size = sizeof(uint32_t) * mTimeToSampleCount * 2;
 if (mDataSource->readAt(
                data_offset + 8, mTimeToSample, size) < (ssize_t)size) {
 return ERROR_IO;
 }

 for (uint32_t i = 0; i < mTimeToSampleCount * 2; ++i) {
        mTimeToSample[i] = ntohl(mTimeToSample[i]);
 }

 return OK;
}
",1
Detect whether the following code contains vulnerabilities.," void PrintPreviewUI::ClearAllPreviewData() {
  print_preview_data_service()->RemoveEntry(preview_ui_addr_str_);
 }
",1
Detect whether the following code contains vulnerabilities.," FrameImpl::FrameImpl(std::unique_ptr<content::WebContents> web_contents,
                     chromium::web::FrameObserverPtr observer)
    : web_contents_(std::move(web_contents)), observer_(std::move(observer)) {
  Observe(web_contents.get());
 }
",1
Detect whether the following code contains vulnerabilities.,"BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)
{
	void *rv;
	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
 	if (out == NULL) {
 		return NULL;
 	}
	gdImageWebpCtx(im, out, quality);
	rv = gdDPExtractData(out, size);
 	out->gd_free(out);
 	return rv;
 }
",1
Detect whether the following code contains vulnerabilities.," BaseRenderingContext2D::BaseRenderingContext2D()
    : clip_antialiasing_(kNotAntiAliased) {
   state_stack_.push_back(CanvasRenderingContext2DState::Create());
 }
",1
Detect whether the following code contains vulnerabilities.,"void SpeechSynthesis::handleSpeakingCompleted(SpeechSynthesisUtterance* utterance, bool errorOccurred)
 {
     ASSERT(utterance);
 
     bool didJustFinishCurrentUtterance = false;
    if (utterance == currentSpeechUtterance()) {
        m_utteranceQueue.removeFirst();
        didJustFinishCurrentUtterance = true;
    }

    fireEvent(errorOccurred ? EventTypeNames::error : EventTypeNames::end, utterance, 0, String());

    if (didJustFinishCurrentUtterance && !m_utteranceQueue.isEmpty())
        startSpeakingImmediately();
}
",1
Detect whether the following code contains vulnerabilities.,"void NavigationController::GoToIndex(int index) {
  if (index < 0 || index >= static_cast<int>(entries_.size())) {
    NOTREACHED();
    return;
  }

  if (transient_entry_index_ != -1) {
    if (index == transient_entry_index_) {
      return;
    }
    if (index > transient_entry_index_) {
      index--;
     }
   }
 
  if (tab_contents_->interstitial_page()) {
    if (index == GetCurrentEntryIndex() - 1) {
      tab_contents_->interstitial_page()->DontProceed();
      return;
    } else {
      tab_contents_->interstitial_page()->CancelForNavigation();
    }
  }
   DiscardNonCommittedEntries();
 
   pending_entry_index_ = index;
  entries_[pending_entry_index_]->set_transition_type(
      content::PageTransitionFromInt(
          entries_[pending_entry_index_]->transition_type() |
          content::PAGE_TRANSITION_FORWARD_BACK));
  NavigateToPendingEntry(NO_RELOAD);
}
",1
Detect whether the following code contains vulnerabilities.,"static char *EscapeParenthesis(const char *source)
{
  char
    *destination;

  register char
    *q;

  register const char
    *p;

  size_t
    length;

  assert(source != (const char *) NULL);
  length=0;
  for (p=source; *p != '\0'; p++)
  {
    if ((*p == '\\') || (*p == '(') || (*p == ')'))
      {
        if (~length < 1)
          ThrowFatalException(ResourceLimitFatalError,""UnableToEscapeString"");
        length++;
      }
    length++;
  }
  destination=(char *) NULL;
  if (~length >= (MagickPathExtent-1))
    destination=(char *) AcquireQuantumMemory(length+MagickPathExtent,
      sizeof(*destination));
  if (destination == (char *) NULL)
    ThrowFatalException(ResourceLimitFatalError,""UnableToEscapeString"");
  *destination='\0';
  q=destination;
  for (p=source; *p != '\0'; p++)
  {
    if ((*p == '\\') || (*p == '(') || (*p == ')'))
      *q++='\\';
    *q++=(*p);
  }
  *q='\0';
  return(destination);
}
",0
Detect whether the following code contains vulnerabilities.,"   static void TearDownTestCase() {
    vpx_free(source_data_);
    source_data_ = NULL;
    vpx_free(reference_data_);
    reference_data_ = NULL;
   }
",1
Detect whether the following code contains vulnerabilities.,"static int tight_fill_palette(VncState *vs, int x, int y,
                              size_t count, uint32_t *bg, uint32_t *fg,
                              VncPalette **palette)
{
    int max;

    max = count / tight_conf[vs->tight.compression].idx_max_colors_divisor;
    if (max < 2 &&
        count >= tight_conf[vs->tight.compression].mono_min_rect_size) {
        max = 2;
    }
    if (max >= 256) {
         max = 256;
     }
 
    switch(vs->clientds.pf.bytes_per_pixel) {
     case 4:
         return tight_fill_palette32(vs, x, y, max, count, bg, fg, palette);
     case 2:
        return tight_fill_palette16(vs, x, y, max, count, bg, fg, palette);
    default:
        max = 2;
        return tight_fill_palette8(vs, x, y, max, count, bg, fg, palette);
    }
    return 0;
}
",1
Detect whether the following code contains vulnerabilities.,"rdpsnddbg_process(STREAM s)
{
	unsigned int pkglen;
 	static char *rest = NULL;
 	char *buf;
 
 	pkglen = s->end - s->p;
 	/* str_handle_lines requires null terminated strings */
 	buf = (char *) xmalloc(pkglen + 1);
	STRNCPY(buf, (char *) s->p, pkglen + 1);

	str_handle_lines(buf, &rest, rdpsnddbg_line_handler, NULL);

	xfree(buf);
}
",1
Detect whether the following code contains vulnerabilities.,"static void yy_flex_strncpy (char* s1, yyconst char * s2, int n , yyscan_t yyscanner)
{
	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	(void)yyg;

	int i;
	for ( i = 0; i < n; ++i )
		s1[i] = s2[i];
}
",0
Detect whether the following code contains vulnerabilities.,"bool AppCacheDatabase::FindEntriesForCache(int64_t cache_id,
                                           std::vector<EntryRecord>* records) {
  DCHECK(records && records->empty());
  if (!LazyOpen(kDontCreate))
     return false;
 
   static const char kSql[] =
      ""SELECT cache_id, url, flags, response_id, response_size FROM Entries""
       ""  WHERE cache_id = ?"";
 
   sql::Statement statement(db_->GetCachedStatement(SQL_FROM_HERE, kSql));
  statement.BindInt64(0, cache_id);

  while (statement.Step()) {
    records->push_back(EntryRecord());
    ReadEntryRecord(statement, &records->back());
    DCHECK(records->back().cache_id == cache_id);
  }

  return statement.Succeeded();
}
",1
Detect whether the following code contains vulnerabilities.,"DOMWindow* Document::open(v8::Isolate* isolate,
                          const USVStringOrTrustedURL& string_or_url,
                          const AtomicString& name,
                          const AtomicString& features,
                          ExceptionState& exception_state) {
  if (!domWindow()) {
    exception_state.ThrowDOMException(DOMExceptionCode::kInvalidAccessError,
                                      ""The document has no window associated."");
    return nullptr;
  }

  return domWindow()->open(isolate, string_or_url, name, features,
                           exception_state);
}
",0
Detect whether the following code contains vulnerabilities.,"void Editor::replaceSelectionWithText(const String& text,
                                      bool selectReplacement,
                                      bool smartReplace,
                                      InputEvent::InputType inputType) {
  replaceSelectionWithFragment(createFragmentFromText(selectedRange(), text),
                               selectReplacement, smartReplace, true,
                               inputType);
}
",0
Detect whether the following code contains vulnerabilities.,"long Track::GetFirst(const BlockEntry*& pBlockEntry) const {
 const Cluster* pCluster = m_pSegment->GetFirst();

 for (int i = 0;;) {
 if (pCluster == NULL) {
      pBlockEntry = GetEOS();
 return 1;
 }

 if (pCluster->EOS()) {
 if (m_pSegment->DoneParsing()) {
        pBlockEntry = GetEOS();
 return 1;
 }

      pBlockEntry = 0;
 return E_BUFFER_NOT_FULL;
 }

 long status = pCluster->GetFirst(pBlockEntry);

 if (status < 0) // error
 return status;

 if (pBlockEntry == 0) { // empty cluster
      pCluster = m_pSegment->GetNext(pCluster);
 continue;
 }

 for (;;) {
 const Block* const pBlock = pBlockEntry->GetBlock();
      assert(pBlock);

 const long long tn = pBlock->GetTrackNumber();

 if ((tn == m_info.number) && VetEntry(pBlockEntry))
 return 0;

 const BlockEntry* pNextEntry;

      status = pCluster->GetNext(pBlockEntry, pNextEntry);

 if (status < 0) // error
 return status;

 if (pNextEntry == 0)
 break;

      pBlockEntry = pNextEntry;
 }

 ++i;

 if (i >= 100)
 break;

    pCluster = m_pSegment->GetNext(pCluster);
 }


  pBlockEntry = GetEOS(); // so we can return a non-NULL value
 return 1;
}
",0
Detect whether the following code contains vulnerabilities.,"static void _close_pgsql_plink(zend_rsrc_list_entry *rsrc TSRMLS_DC)
{
	PGconn *link = (PGconn *)rsrc->ptr;
	PGresult *res;

	while ((res = PQgetResult(link))) {
		PQclear(res);
	}
	PQfinish(link);
	PGG(num_persistent)--;
	PGG(num_links)--;
}
",0
Detect whether the following code contains vulnerabilities.,"std::string ExtractResourceId(const GURL& url) {
  return net::UnescapeURLComponent(url.ExtractFileName(),
                                   net::UnescapeRule::URL_SPECIAL_CHARS);
}
",0
Detect whether the following code contains vulnerabilities.,"ftrace_regex_lseek(struct file *file, loff_t offset, int whence)
 {
 	loff_t ret;
 
	if (file->f_mode & FMODE_READ)
		ret = seq_lseek(file, offset, whence);
	else
		file->f_pos = ret = 1;

	return ret;
}
",1
Detect whether the following code contains vulnerabilities.,"parse_instruction_ids(struct ofpbuf *payload, bool loose, uint32_t *insts)
{
    *insts = 0;
    while (payload->size > 0) {
        enum ovs_instruction_type inst;
        enum ofperr error;
        uint64_t ofpit;

        /* OF1.3 and OF1.4 aren't clear about padding in the instruction IDs.
         * It seems clear that they aren't padded to 8 bytes, though, because
         * both standards say that ""non-experimenter instructions are 4 bytes""
         * and do not mention any padding before the first instruction ID.
         * (There wouldn't be any point in padding to 8 bytes if the IDs were
         * aligned on an odd 4-byte boundary.)
         *
         * Anyway, we just assume they're all glommed together on byte
         * boundaries. */
        error = ofpprop_pull__(payload, NULL, 1, 0x10000, &ofpit);
        if (error) {
            return error;
        }

        error = ovs_instruction_type_from_inst_type(&inst, ofpit);
        if (!error) {
            *insts |= 1u << inst;
        } else if (!loose) {
            return error;
        }
    }
    return 0;
}
",0
Detect whether the following code contains vulnerabilities.,"static ZIPARCHIVE_METHOD(addEmptyDir)
{
	struct zip *intern;
	zval *self = getThis();
	char *dirname;
	size_t   dirname_len;
	int idx;
	struct zip_stat sb;
	char *s;

	if (!self) {
		RETURN_FALSE;
	}

	ZIP_FROM_OBJECT(intern, self);

	if (zend_parse_parameters(ZEND_NUM_ARGS(), ""s"",
				&dirname, &dirname_len) == FAILURE) {
		return;
	}

	if (dirname_len<1) {
		RETURN_FALSE;
	}

	if (dirname[dirname_len-1] != '/') {
		s=(char *)emalloc(dirname_len+2);
		strcpy(s, dirname);
		s[dirname_len] = '/';
		s[dirname_len+1] = '\0';
	} else {
		s = dirname;
	}

	idx = zip_stat(intern, s, 0, &sb);
	if (idx >= 0) {
		RETVAL_FALSE;
	} else {
		if (zip_add_dir(intern, (const char *)s) == -1) {
			RETVAL_FALSE;
		}
		zip_error_clear(intern);
		RETVAL_TRUE;
	}

	if (s != dirname) {
		efree(s);
	}
}
",0
Detect whether the following code contains vulnerabilities.,"struct in6_addr *ndp_msg_opt_route_prefix(struct ndp_msg *msg, int offset)
{
	static struct in6_addr prefix;
	struct __nd_opt_route_info *ri =
			ndp_msg_payload_opts_offset(msg, offset);

	memset(&prefix, 0, sizeof(prefix));
	memcpy(&prefix, &ri->nd_opt_ri_prefix, (ri->nd_opt_ri_len - 1) << 3);
	return &prefix;
}
",0
Detect whether the following code contains vulnerabilities.,"static unsigned writeSignature(ucvector* out)
{
  /*8 bytes PNG signature, aka the magic bytes*/
  if (!ucvector_push_back(out, 137)) return 83;
  if (!ucvector_push_back(out, 80)) return 83;
  if (!ucvector_push_back(out, 78)) return 83;
  if (!ucvector_push_back(out, 71)) return 83;
  if (!ucvector_push_back(out, 13)) return 83;
  if (!ucvector_push_back(out, 10)) return 83;
  if (!ucvector_push_back(out, 26)) return 83;
  if (!ucvector_push_back(out, 10)) return 83;

  return 0;
}
",0
Detect whether the following code contains vulnerabilities.,"juniper_pppoe_atm_print(netdissect_options *ndo,
                        const struct pcap_pkthdr *h, register const u_char *p)
{
        struct juniper_l2info_t l2info;
	uint16_t extracted_ethertype;

        l2info.pictype = DLT_JUNIPER_PPPOE_ATM;
        if (juniper_parse_header(ndo, p, h, &l2info) == 0)
            return l2info.header_len;
 
         p+=l2info.header_len;
 
         extracted_ethertype = EXTRACT_16BITS(p);
         /* this DLT contains nothing but raw PPPoE frames,
          * prepended with a type field*/
        if (ethertype_print(ndo, extracted_ethertype,
                              p+ETHERTYPE_LEN,
                              l2info.length-ETHERTYPE_LEN,
                              l2info.caplen-ETHERTYPE_LEN,
                              NULL, NULL) == 0)
            /* ether_type not known, probably it wasn't one */
             ND_PRINT((ndo, ""unknown ethertype 0x%04x"", extracted_ethertype));
 
         return l2info.header_len;
 }
",1
Detect whether the following code contains vulnerabilities.,"qedi_dbg_notice(struct qedi_dbg_ctx *qedi, const char *func, u32 line,
		const char *fmt, ...)
 {
 	va_list va;
 	struct va_format vaf;
	char nfunc[32];
	memset(nfunc, 0, sizeof(nfunc));
	memcpy(nfunc, func, sizeof(nfunc) - 1);
 
 	va_start(va, fmt);
 
	vaf.fmt = fmt;
	vaf.va = &va;

	if (!(qedi_dbg_log & QEDI_LOG_NOTICE))
		goto ret;
 
 	if (likely(qedi) && likely(qedi->pdev))
 		pr_notice(""[%s]:[%s:%d]:%d: %pV"",
			  dev_name(&qedi->pdev->dev), nfunc, line,
 			  qedi->host_no, &vaf);
 	else
		pr_notice(""[0000:00:00.0]:[%s:%d]: %pV"", nfunc, line, &vaf);
 
 ret:
 	va_end(va);
}
",1
Detect whether the following code contains vulnerabilities.,"static int dynamicGetbuf(gdIOCtxPtr ctx, void *buf, int len)
{
	int rlen, remain;
	dpIOCtxPtr dctx;
	dynamicPtr *dp;

	dctx = (dpIOCtxPtr) ctx;
	dp = dctx->dp;

	remain = dp->logicalSize - dp->pos;
 	if(remain >= len) {
 		rlen = len;
 	} else {
		if(remain == 0) {
 			/* 2.0.34: EOF is incorrect. We use 0 for
 			 * errors and EOF, just like fileGetbuf,
 			 * which is a simple fread() wrapper.
			 * TBB. Original bug report: Daniel Cowgill. */
			return 0; /* NOT EOF */
		}

		rlen = remain;
	}

	memcpy(buf, (void *) ((char *)dp->data + dp->pos), rlen);
	dp->pos += rlen;

	return rlen;
}
",1
Detect whether the following code contains vulnerabilities.," void WebPluginDelegateProxy::OnGetWindowScriptNPObject(
    int route_id, bool* success, intptr_t* npobject_ptr) {
   *success = false;
   NPObject* npobject = NULL;
   if (plugin_)
    npobject = plugin_->GetWindowScriptNPObject();

  if (!npobject)
    return;

   window_script_object_ = (new NPObjectStub(
       npobject, channel_host_.get(), route_id, 0, page_url_))->AsWeakPtr();
   *success = true;
  *npobject_ptr = reinterpret_cast<intptr_t>(npobject);
 }
",1
Detect whether the following code contains vulnerabilities.,"map_id_range_down_base(unsigned extents, struct uid_gid_map *map, u32 id, u32 count)
{
	unsigned idx;
	u32 first, last, id2;

	id2 = id + count - 1;

	/* Find the matching extent */
	for (idx = 0; idx < extents; idx++) {
		first = map->extent[idx].first;
		last = first + map->extent[idx].count - 1;
		if (id >= first && id <= last &&
		    (id2 >= first && id2 <= last))
			return &map->extent[idx];
	}
	return NULL;
}
",0
Detect whether the following code contains vulnerabilities.,"static int store_asoundrc(void) {
	fs_build_mnt_dir();
 
 	char *src;
 	char *dest = RUN_ASOUNDRC_FILE;
 	FILE *fp = fopen(dest, ""w"");
 	if (fp) {
 		fprintf(fp, ""\n"");
		SET_PERMS_STREAM(fp, getuid(), getgid(), 0644);
		fclose(fp);
	}
	
	if (asprintf(&src, ""%s/.asoundrc"", cfg.homedir) == -1)
		errExit(""asprintf"");
	
	struct stat s;
	if (stat(src, &s) == 0) {
		if (is_link(src)) {
			/* coverity[toctou] */
			char* rp = realpath(src, NULL);
			if (!rp) {
				fprintf(stderr, ""Error: Cannot access %s\n"", src);
				exit(1);
			}
			if (strncmp(rp, cfg.homedir, strlen(cfg.homedir)) != 0) {
				fprintf(stderr, ""Error: .asoundrc is a symbolic link pointing to a file outside home directory\n"");
				exit(1);
			}
			free(rp);
		}

		copy_file_as_user(src, dest, getuid(), getgid(), 0644);
		fs_logger2(""clone"", dest);
		return 1; // file copied
	}
	
	return 0;
}
",1
Detect whether the following code contains vulnerabilities.,"armv6_pmcr_has_overflowed(unsigned long pmcr)
{
	return pmcr & ARMV6_PMCR_OVERFLOWED_MASK;
}
",0
Detect whether the following code contains vulnerabilities.,"int lxc_clear_config_network(struct lxc_conf *c)
{
	struct lxc_list *it,*next;
	lxc_list_for_each_safe(it, &c->network, next) {
		lxc_remove_nic(it);
	}
	return 0;
}
",0
Detect whether the following code contains vulnerabilities.,"SpoolssSetPrinter_q(tvbuff_t *tvb, int offset, packet_info *pinfo,
			       proto_tree *tree, dcerpc_info *di, guint8 *drep _U_)
{
	guint32 level;

	/* Parse packet */

	offset = dissect_nt_policy_hnd(
		tvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,
		FALSE, FALSE);

	offset = dissect_ndr_uint32(
		tvb, offset, pinfo, tree, di, drep, hf_level, &level);

	col_append_fstr(pinfo->cinfo, COL_INFO, "", level %d"", level);

	offset = dissect_SPOOL_PRINTER_INFO(
		tvb, offset, pinfo, tree, di, drep);

	offset = dissect_ndr_uint32(
		tvb, offset, pinfo, tree, di, drep,
		hf_setprinter_cmd, NULL);

	return offset;
}
",0
Detect whether the following code contains vulnerabilities.,"static void *eval_map_start(struct seq_file *m, loff_t *pos)
{
	union trace_eval_map_item *v;
	loff_t l = 0;

	mutex_lock(&trace_eval_mutex);

	v = trace_eval_maps;
	if (v)
		v++;

	while (v && l < *pos) {
		v = eval_map_next(m, v, &l);
	}

	return v;
}
",0
Detect whether the following code contains vulnerabilities.,"static int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_cipher rcipher;
 
	snprintf(rcipher.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""cipher"");
 
 	rcipher.blocksize = alg->cra_blocksize;
 	rcipher.min_keysize = alg->cra_cipher.cia_min_keysize;
	rcipher.max_keysize = alg->cra_cipher.cia_max_keysize;

	if (nla_put(skb, CRYPTOCFGA_REPORT_CIPHER,
		    sizeof(struct crypto_report_cipher), &rcipher))
		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}
",1
Detect whether the following code contains vulnerabilities.,"static int decode_create(struct xdr_stream *xdr, struct nfs4_change_info *cinfo)
{
	__be32 *p;
	uint32_t bmlen;
	int status;

	status = decode_op_hdr(xdr, OP_CREATE);
	if (status)
		return status;
	if ((status = decode_change_info(xdr, cinfo)))
		return status;
	READ_BUF(4);
	READ32(bmlen);
	READ_BUF(bmlen << 2);
	return 0;
}
",0
Detect whether the following code contains vulnerabilities.,"void RenderViewImpl::DidFlushPaint() {
  pepper_helper_->ViewFlushedPaint();

  if (!webview())
    return;

  WebFrame* main_frame = webview()->mainFrame();

  if (!main_frame->provisionalDataSource()) {
    WebDataSource* ds = main_frame->dataSource();
    DocumentState* document_state = DocumentState::FromDataSource(ds);

    Time now = Time::Now();
    if (document_state->first_paint_time().is_null()) {
      document_state->set_first_paint_time(now);
    }
    if (document_state->first_paint_after_load_time().is_null() &&
        !document_state->finish_load_time().is_null()) {
      document_state->set_first_paint_after_load_time(now);
    }
  }
}
",0
Detect whether the following code contains vulnerabilities.,"static ssize_t driver_override_show(struct device *dev,
 				    struct device_attribute *attr, char *buf)
 {
 	struct platform_device *pdev = to_platform_device(dev);
 
	return sprintf(buf, ""%s\n"", pdev->driver_override);
 }
",1
Detect whether the following code contains vulnerabilities.,"xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
 const char *msg,
 const xmlChar * info1, const xmlChar * info2,
 const xmlChar * info3)
{
 if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
 (ctxt->instate == XML_PARSER_EOF))
 return;
 if (ctxt != NULL)
	ctxt->errNo = error;
    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_NAMESPACE, error,
                    XML_ERR_ERROR, NULL, 0, (const char *) info1,
 (const char *) info2, (const char *) info3, 0, 0, msg,
                    info1, info2, info3);
 if (ctxt != NULL)
	ctxt->nsWellFormed = 0;
}
",0
Detect whether the following code contains vulnerabilities.,"   void TestPlaybackRate(double playback_rate) {
    static const int kDefaultBufferSize = kSamplesPerSecond / 10;
    static const int kDefaultFramesRequested = 5 * kSamplesPerSecond;
 
     TestPlaybackRate(playback_rate, kDefaultBufferSize,
                      kDefaultFramesRequested);
  }
",1
Detect whether the following code contains vulnerabilities.," static void fpm_child_init(struct fpm_worker_pool_s *wp) /* {{{ */
 {
 	fpm_globals.max_requests = wp->config->pm_max_requests;
 
 	if (0 > fpm_stdio_init_child(wp)  ||
 	    0 > fpm_log_init_child(wp)    ||
	    0 > fpm_status_init_child(wp) ||
	    0 > fpm_unix_init_child(wp)   ||
	    0 > fpm_signals_init_child()  ||
	    0 > fpm_env_init_child(wp)    ||
	    0 > fpm_php_init_child(wp)) {

		zlog(ZLOG_ERROR, ""[pool %s] child failed to initialize"", wp->config->name);
		exit(FPM_EXIT_SOFTWARE);
	}
}
/* }}} */
",1
Detect whether the following code contains vulnerabilities.,"   virtual void SetUp() {
    fwd_txfm_ = GET_PARAM(0);

     inv_txfm_ = GET_PARAM(1);
     version_  = GET_PARAM(2);  // 0: high precision forward transform
   }
",1
Detect whether the following code contains vulnerabilities.,"receive_carbon(void **state)
{
    prof_input(""/carbons on"");

    prof_connect();
    assert_true(stbbr_received(
        ""<iq id='*' type='set'><enable xmlns='urn:xmpp:carbons:2'/></iq>""
    ));

    stbbr_send(
        ""<presence to='stabber@localhost' from='buddy1@localhost/mobile'>""
            ""<priority>10</priority>""
            ""<status>On my mobile</status>""
        ""</presence>""
    );
    assert_true(prof_output_exact(""Buddy1 (mobile) is online, \""On my mobile\""""));
    prof_input(""/msg Buddy1"");
     assert_true(prof_output_exact(""unencrypted""));
 
     stbbr_send(
        ""<message type='chat' to='stabber@localhost/profanity' from='buddy1@localhost'>""
             ""<received xmlns='urn:xmpp:carbons:2'>""
                 ""<forwarded xmlns='urn:xmpp:forward:0'>""
                     ""<message id='prof_msg_7' xmlns='jabber:client' type='chat' lang='en' to='stabber@localhost/profanity' from='buddy1@localhost/mobile'>""
                        ""<body>test carbon from recipient</body>""
                    ""</message>""
                ""</forwarded>""
            ""</received>""
        ""</message>""
    );

    assert_true(prof_output_regex(""Buddy1/mobile: .+test carbon from recipient""));
}
",1
Detect whether the following code contains vulnerabilities.," void *arm_dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,
 		    gfp_t gfp, struct dma_attrs *attrs)
 {
	pgprot_t prot = __get_dma_pgprot(attrs, pgprot_kernel);
 	void *memory;
 
 	if (dma_alloc_from_coherent(dev, size, handle, &memory))
		return memory;

	return __dma_alloc(dev, size, handle, gfp, prot, false,
			   __builtin_return_address(0));
}
",1
Detect whether the following code contains vulnerabilities.,"inline void PulseAudioMixer::MainloopLock() const {
   pa_threaded_mainloop_lock(pa_mainloop_);
   ++mainloop_lock_count_;
 }
",1
Detect whether the following code contains vulnerabilities.,"void FillMiscNavigationParams(const CommonNavigationParams& common_params,
                              const CommitNavigationParams& commit_params,
                              blink::WebNavigationParams* navigation_params) {
  navigation_params->navigation_timings = BuildNavigationTimings(
      common_params.navigation_start, commit_params.navigation_timing,
      common_params.input_start);

  navigation_params->is_user_activated =
      commit_params.was_activated == WasActivatedOption::kYes;

  if (commit_params.origin_to_commit) {
    navigation_params->origin_to_commit =
        commit_params.origin_to_commit.value();
  }
}
",0
Detect whether the following code contains vulnerabilities.,"void WebSocketJob::OnConnected(
    SocketStream* socket, int max_pending_send_allowed) {
  if (state_ == CLOSED)
    return;
  DCHECK_EQ(CONNECTING, state_);
  if (delegate_)
    delegate_->OnConnected(socket, max_pending_send_allowed);
}
",0
Detect whether the following code contains vulnerabilities.,"base::string16 AuthenticatorBlePairingBeginSheetModel::GetStepDescription()
    const {
  return l10n_util::GetStringUTF16(IDS_WEBAUTHN_BLE_PAIRING_BEGIN_DESCRIPTION);
}
",0
Detect whether the following code contains vulnerabilities.," static int get_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)
 {
	return usb_control_msg(dev->udev, usb_rcvctrlpipe(dev->udev, 0),
			       RTL8150_REQ_GET_REGS, RTL8150_REQT_READ,
			       indx, 0, data, size, 500);
 }
",1
Detect whether the following code contains vulnerabilities.,"bool GLES2DecoderImpl::DoIsShader(GLuint client_id) {
  return GetShaderInfo(client_id) != NULL;
}
",0
Detect whether the following code contains vulnerabilities.," void UserSelectionScreen::OnBeforeUserRemoved(const AccountId& account_id) {
  for (user_manager::UserList::iterator it = users_.begin(); it != users_.end();
       ++it) {
     if ((*it)->GetAccountId() == account_id) {
       users_.erase(it);
       break;
    }
  }
}
",1
Detect whether the following code contains vulnerabilities.,"int invalidate_partition(struct gendisk *disk, int partno)
{
	int res = 0;
	struct block_device *bdev = bdget_disk(disk, partno);
	if (bdev) {
		fsync_bdev(bdev);
		res = __invalidate_device(bdev, true);
		bdput(bdev);
	}
	return res;
}
",0
Detect whether the following code contains vulnerabilities.,"static gboolean nbd_negotiate_continue(QIOChannel *ioc,
                                       GIOCondition condition,
                                       void *opaque)
{
    qemu_coroutine_enter(opaque);
    return TRUE;
}
",1
Detect whether the following code contains vulnerabilities.,"void UnloadController::TabDetachedAt(TabContents* contents, int index) {
   TabDetachedImpl(contents);
 }
",1
Detect whether the following code contains vulnerabilities.,"sector_t swapdev_block(int type, pgoff_t offset)
{
	struct block_device *bdev;

	if ((unsigned int)type >= nr_swapfiles)
		return 0;
	if (!(swap_info[type]->flags & SWP_WRITEOK))
		return 0;
	return map_swap_entry(swp_entry(type, offset), &bdev);
}
",0
Detect whether the following code contains vulnerabilities.,"void ExtensionServiceBackend::LoadSingleExtension(const FilePath& path_in) {
  CHECK(BrowserThread::CurrentlyOn(BrowserThread::FILE));

  FilePath extension_path = path_in;
  file_util::AbsolutePath(&extension_path);

  int flags = Extension::ShouldAlwaysAllowFileAccess(Extension::LOAD) ?
      Extension::ALLOW_FILE_ACCESS : Extension::NO_FLAGS;
  if (Extension::ShouldDoStrictErrorChecking(Extension::LOAD))
    flags |= Extension::STRICT_ERROR_CHECKS;
  std::string error;
  scoped_refptr<const Extension> extension(extension_file_util::LoadExtension(
      extension_path,
      Extension::LOAD,
      flags,
      &error));

  if (!extension) {
    if (!BrowserThread::PostTask(
            BrowserThread::UI, FROM_HERE,
            NewRunnableMethod(
                this,
                &ExtensionServiceBackend::ReportExtensionLoadError,
                extension_path, error)))
      NOTREACHED() << error;
    return;
  }

  if (!BrowserThread::PostTask(
           BrowserThread::UI, FROM_HERE,
           NewRunnableMethod(
               this,
              &ExtensionServiceBackend::OnExtensionInstalled,
               extension)))
     NOTREACHED();
 }
",1
Detect whether the following code contains vulnerabilities.,"static int shm_fsync(struct file *file, loff_t start, loff_t end, int datasync)
{
	struct shm_file_data *sfd = shm_file_data(file);

	if (!sfd->file->f_op->fsync)
		return -EINVAL;
	return sfd->file->f_op->fsync(sfd->file, start, end, datasync);
}
",0
Detect whether the following code contains vulnerabilities.," SPL_METHOD(GlobIterator, count)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}

	if (php_stream_is(intern->u.dir.dirp ,&php_glob_stream_ops)) {
		RETURN_LONG(php_glob_stream_get_count(intern->u.dir.dirp, NULL));
	} else {
		/* should not happen */
		php_error_docref(NULL TSRMLS_CC, E_ERROR, ""GlobIterator lost glob state"");
	}
}
",1
Detect whether the following code contains vulnerabilities.," void ExtensionViewGuest::DidNavigateMainFrame(
     const content::LoadCommittedDetails& details,
     const content::FrameNavigateParams& params) {
  if (attached() && (params.url.GetOrigin() != url_.GetOrigin())) {
     bad_message::ReceivedBadMessage(web_contents()->GetRenderProcessHost(),
                                     bad_message::EVG_BAD_ORIGIN);
   }
}
",1
Detect whether the following code contains vulnerabilities.,"static void put_crypt_info(struct fscrypt_info *ci)
{
 	if (!ci)
 		return;
 
	key_put(ci->ci_keyring_key);
 	crypto_free_skcipher(ci->ci_ctfm);
 	kmem_cache_free(fscrypt_info_cachep, ci);
 }
",1
Detect whether the following code contains vulnerabilities.,"void WebProcessProxy::addExistingWebPage(WebPageProxy* webPage, uint64_t pageID)
{
     m_pageMap.set(pageID, webPage);
     globalPageMap().set(pageID, webPage);
 #if PLATFORM(MAC)
    if (pageIsProcessSuppressible(webPage));
         m_processSuppressiblePages.add(pageID);
     updateProcessSuppressionState();
 #endif
}
",1
Detect whether the following code contains vulnerabilities.,"static inline bool use_goto_tb(DisasContext *s, target_ulong pc)
{
#ifndef CONFIG_USER_ONLY
    return (pc & TARGET_PAGE_MASK) == (s->tb->pc & TARGET_PAGE_MASK) ||
           (pc & TARGET_PAGE_MASK) == (s->pc_start & TARGET_PAGE_MASK);
#else
    return true;
#endif
}
",0
Detect whether the following code contains vulnerabilities.,"unsigned long iov_iter_alignment(const struct iov_iter *i)
{
	const struct iovec *iov = i->iov;
	unsigned long res;
	size_t size = i->count;
	size_t n;

	if (!size)
		return 0;

	res = (unsigned long)iov->iov_base + i->iov_offset;
	n = iov->iov_len - i->iov_offset;
	if (n >= size)
		return res | size;
	size -= n;
	res |= n;
	while (size > (++iov)->iov_len) {
		res |= (unsigned long)iov->iov_base | iov->iov_len;
		size -= iov->iov_len;
	}
	res |= (unsigned long)iov->iov_base | size;
	return res;
}
",0
Detect whether the following code contains vulnerabilities.,"fbStore_x1r5g5b5 (FbBits *bits, const CARD32 *values, int x, int width, miIndexedPtr indexed)
{
    int i;
    CARD16  *pixel = ((CARD16 *) bits) + x;
    for (i = 0; i < width; ++i) {
        Split(READ(values + i));
        WRITE(pixel++, ((r << 7) & 0x7c00) |
	      ((g << 2) & 0x03e0) |
	      ((b >> 3)         ));
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void HostPortAllocatorSession::OnSessionRequestDone(
    UrlFetcher* url_fetcher,
    const net::URLRequestStatus& status,
    int response_code,
    const std::string& response) {
  url_fetchers_.erase(url_fetcher);
  delete url_fetcher;
 
  if (response_code != net::HTTP_OK) {
     LOG(WARNING) << ""Received error when allocating relay session: ""
                 << response_code;
     TryCreateRelaySession();
     return;
   }
 
   ReceiveSessionResponse(response);
 }
",1
Detect whether the following code contains vulnerabilities.,"static int hash_recvmsg(struct kiocb *unused, struct socket *sock,
			struct msghdr *msg, size_t len, int flags)
{
	struct sock *sk = sock->sk;
	struct alg_sock *ask = alg_sk(sk);
	struct hash_ctx *ctx = ask->private;
	unsigned ds = crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req));
	int err;

	if (len > ds)
		len = ds;
 	else if (len < ds)
 		msg->msg_flags |= MSG_TRUNC;
 
	msg->msg_namelen = 0;
 	lock_sock(sk);
 	if (ctx->more) {
 		ctx->more = 0;
		ahash_request_set_crypt(&ctx->req, NULL, ctx->result, 0);
		err = af_alg_wait_for_completion(crypto_ahash_final(&ctx->req),
						 &ctx->completion);
		if (err)
			goto unlock;
	}

	err = memcpy_toiovec(msg->msg_iov, ctx->result, len);

unlock:
	release_sock(sk);

	return err ?: len;
}
",1
Detect whether the following code contains vulnerabilities.,"static void perf_swevent_del(struct perf_event *event, int flags)
{
	hlist_del_rcu(&event->hlist_entry);
}
",0
Detect whether the following code contains vulnerabilities.,"static int msg_cache_check(const char *id, struct BodyCache *bcache, void *data)
{
  struct Context *ctx = (struct Context *) data;
  if (!ctx)
    return -1;
  struct PopData *pop_data = (struct PopData *) ctx->data;
  if (!pop_data)
    return -1;

#ifdef USE_HCACHE
  /* keep hcache file if hcache == bcache */
  if (strcmp(HC_FNAME ""."" HC_FEXT, id) == 0)
    return 0;
#endif

  for (int i = 0; i < ctx->msgcount; i++)
  {
    /* if the id we get is known for a header: done (i.e. keep in cache) */
    if (ctx->hdrs[i]->data && (mutt_str_strcmp(ctx->hdrs[i]->data, id) == 0))
      return 0;
  }

   /* message not found in context -> remove it from cache
    * return the result of bcache, so we stop upon its first error
    */
  return mutt_bcache_del(bcache, id);
 }
",1
Detect whether the following code contains vulnerabilities.,"dns_resolver_match(const struct key *key,
		   const struct key_match_data *match_data)
 {
 	int slen, dlen, ret = 0;
 	const char *src = key->description, *dsp = match_data->raw_data;

	kenter(""%s,%s"", src, dsp);

	if (!src || !dsp)
		goto no_match;

	if (strcasecmp(src, dsp) == 0)
		goto matched;

	slen = strlen(src);
	dlen = strlen(dsp);
	if (slen <= 0 || dlen <= 0)
		goto no_match;
	if (src[slen - 1] == '.')
		slen--;
	if (dsp[dlen - 1] == '.')
		dlen--;
	if (slen != dlen || strncasecmp(src, dsp, slen) != 0)
		goto no_match;

matched:
	ret = 1;
no_match:
	kleave("" = %d"", ret);
 	return ret;
 }
",1
Detect whether the following code contains vulnerabilities.," image_transform_png_set_scale_16_add(image_transform *this,
    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
 {
    UNUSED(colour_type)
 
 this->next = *that;
 *that = this;

 return bit_depth > 8;
}
",1
Detect whether the following code contains vulnerabilities.," void InputMethodBase::OnInputMethodChanged() const {
   TextInputClient* client = GetTextInputClient();
  if (client && client->GetTextInputType() != TEXT_INPUT_TYPE_NONE)
     client->OnInputMethodChanged();
 }
",1
Detect whether the following code contains vulnerabilities.,"_tiffMapProc(thandle_t fd, tdata_t* pbase, toff_t* psize)
{
	return (0);
}
",0
Detect whether the following code contains vulnerabilities.,"SYSCALL_DEFINE2(listen, int, fd, int, backlog)
{
	struct socket *sock;
	int err, fput_needed;
	int somaxconn;

	sock = sockfd_lookup_light(fd, &err, &fput_needed);
	if (sock) {
		somaxconn = sock_net(sock->sk)->core.sysctl_somaxconn;
		if ((unsigned int)backlog > somaxconn)
			backlog = somaxconn;

		err = security_socket_listen(sock, backlog);
		if (!err)
			err = sock->ops->listen(sock, backlog);

		fput_light(sock->file, fput_needed);
	}
	return err;
}
",0
Detect whether the following code contains vulnerabilities.," static bool HasElementImpl(Isolate* isolate, Handle<JSObject> holder,
 uint32_t index,
 Handle<FixedArrayBase> backing_store,
 PropertyFilter filter = ALL_PROPERTIES) {
 return Subclass::GetEntryForIndexImpl(isolate, *holder, *backing_store,
                                          index, filter) != kMaxUInt32;
 }
",0
Detect whether the following code contains vulnerabilities.," static bool HasEntryImpl(Isolate* isolate, FixedArrayBase* backing_store,
 uint32_t entry) {
 return !BackingStore::cast(backing_store)->is_the_hole(isolate, entry);
 }
",0
Detect whether the following code contains vulnerabilities.,"static int cannotBeFunction(Parse *pParse, struct SrcList_item *pFrom){
  if( pFrom->fg.isTabFunc ){
    sqlite3ErrorMsg(pParse, ""'%s' is not a function"", pFrom->zName);
    return 1;
  }
  return 0;
}
",0
Detect whether the following code contains vulnerabilities.,"cJSON *cJSON_CreateString( const char *string )
{
	cJSON *item = cJSON_New_Item();
	if ( item ) {
		item->type = cJSON_String;
		item->valuestring = cJSON_strdup( string );
	}
	return item;
}
",1
Detect whether the following code contains vulnerabilities.,"static int burl_normalize_2F_to_slash_fix (buffer *b, int qs, int i)
{
    char * const s = b->ptr;
    const int blen = (int)buffer_string_length(b);
    const int used = qs < 0 ? blen : qs;
    int j = i;
    for (; i < used; ++i, ++j) {
        s[j] = s[i];
        if (s[i] == '%' && s[i+1] == '2' && s[i+2] == 'F') {
            s[j] = '/';
            i+=2;
         }
     }
     if (qs >= 0) {
        memmove(s+j, s+qs, blen - qs);
        j += blen - qs;
     }
     buffer_string_set_length(b, j);
     return qs;
}
",1
Detect whether the following code contains vulnerabilities.,"static void *__alloc_from_pool(size_t size, struct page **ret_page, gfp_t flags)
{
	unsigned long val;
	void *ptr = NULL;

	if (!atomic_pool) {
		WARN(1, ""coherent pool not initialised!\n"");
		return NULL;
	}

	val = gen_pool_alloc(atomic_pool, size);
	if (val) {
		phys_addr_t phys = gen_pool_virt_to_phys(atomic_pool, val);
 
 		*ret_page = phys_to_page(phys);
 		ptr = (void *)val;
		if (flags & __GFP_ZERO)
			memset(ptr, 0, size);
 	}
 
 	return ptr;
}
",1
Detect whether the following code contains vulnerabilities.,"void RootWindowHostWin::SetCapture() {
  if (!has_capture_) {
    has_capture_ = true;
    ::SetCapture(hwnd());
  }
}
",0
Detect whether the following code contains vulnerabilities.,"static void die(const char *fmt, ...) {
    va_list ap;
    va_start(ap, fmt);
    vprintf(fmt, ap);
    if(fmt[strlen(fmt)-1] != '\n')
        printf(""\n"");
    exit(EXIT_FAILURE);
}
",1
Detect whether the following code contains vulnerabilities.,"void LocalFileSystem::deleteFileSystem(ExecutionContext* context, FileSystemType type, PassOwnPtr<AsyncFileSystemCallbacks> callbacks)
{
    RefPtrWillBeRawPtr<ExecutionContext> contextPtr(context);
     ASSERT(context);
     ASSERT_WITH_SECURITY_IMPLICATION(context->isDocument());
 
    RefPtr<CallbackWrapper> wrapper = adoptRef(new CallbackWrapper(callbacks));
     requestFileSystemAccessInternal(context,
         bind(&LocalFileSystem::deleteFileSystemInternal, this, contextPtr, type, wrapper),
         bind(&LocalFileSystem::fileSystemNotAllowedInternal, this, contextPtr, wrapper));
}
",1
Detect whether the following code contains vulnerabilities.,"  TestResultCallback()
      : callback_(base::Bind(&TestResultCallback::SetResult,
                             base::Unretained(this))) {}
",1
Detect whether the following code contains vulnerabilities.," void PartialMagnificationController::OnWindowDestroying(aura::Window* window) {
   CloseMagnifierWindow();
 
   aura::Window* new_root_window = GetCurrentRootWindow();
   if (new_root_window != window)
    SwitchTargetRootWindow(new_root_window);
 }
",1
Detect whether the following code contains vulnerabilities.,"std::string GetStoreIdFromProfile(Profile* profile) {
   DCHECK(profile);
   return profile->IsOffTheRecord() ?
       kOffTheRecordProfileStoreId : kOriginalProfileStoreId;
}
",1
Detect whether the following code contains vulnerabilities.,"png_get_filter_type(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
      return info_ptr->filter_type;

   return (0);
}
",0
Detect whether the following code contains vulnerabilities.,"static void addr_hash_set(u32 *mask, const u8 *addr)
{
	int n = ether_crc(ETH_ALEN, addr) >> 26;
	mask[n >> 5] |= (1 << (n & 31));
}
",0
Detect whether the following code contains vulnerabilities.,"void br_mdb_notify(struct net_device *dev, struct net_bridge_port *port,
		   struct br_ip *group, int type)
 {
 	struct br_mdb_entry entry;
 
 	entry.ifindex = port->dev->ifindex;
 	entry.addr.proto = group->proto;
 	entry.addr.u.ip4 = group->u.ip4;
#if IS_ENABLED(CONFIG_IPV6)
	entry.addr.u.ip6 = group->u.ip6;
#endif
	__br_mdb_notify(dev, &entry, type);
}
",1
Detect whether the following code contains vulnerabilities.,"GF_Err grpl_dump(GF_Box *a, FILE * trace)
{
	gf_isom_box_dump_start(a, ""GroupListBox"", trace);
	fprintf(trace, "">\n"");
	gf_isom_box_dump_done(""GroupListBox"", a, trace);
	return GF_OK;
}
",0
Detect whether the following code contains vulnerabilities.," virtual void allocateBuffers(bool async, uint32_t width, uint32_t height,
 PixelFormat format, uint32_t usage) {
 Parcel data, reply;
        data.writeInterfaceToken(IGraphicBufferProducer::getInterfaceDescriptor());
        data.writeInt32(static_cast<int32_t>(async));
        data.writeUint32(width);
        data.writeUint32(height);
        data.writeInt32(static_cast<int32_t>(format));
        data.writeUint32(usage);
 status_t result = remote()->transact(ALLOCATE_BUFFERS, data, &reply);
 if (result != NO_ERROR) {
            ALOGE(""allocateBuffers failed to transact: %d"", result);
 }
 }
",0
Detect whether the following code contains vulnerabilities.,"static uint32_t kvm_get_exit_reason(struct kvm_vcpu *vcpu)
{
	struct exit_ctl_data *p_exit_data;

	p_exit_data = kvm_get_exit_data(vcpu);
	return p_exit_data->exit_reason;
}
",0
Detect whether the following code contains vulnerabilities.,"const Chapters::Display* Chapters::Atom::GetDisplay(int index) const
{
    if (index < 0)
        return NULL;
    if (index >= m_displays_count)
        return NULL;
    return m_displays + index;
}
",1
Detect whether the following code contains vulnerabilities.," static int atusb_get_and_show_revision(struct atusb *atusb)
 {
 	struct usb_device *usb_dev = atusb->usb_dev;
	unsigned char buffer[3];
 	int ret;
 
 	/* Get a couple of the ATMega Firmware values */
 	ret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),
 				ATUSB_ID, ATUSB_REQ_FROM_DEV, 0, 0,
				buffer, 3, 1000);
	if (ret >= 0) {
		atusb->fw_ver_maj = buffer[0];
		atusb->fw_ver_min = buffer[1];
		atusb->fw_hw_type = buffer[2];

		dev_info(&usb_dev->dev,
			 ""Firmware: major: %u, minor: %u, hardware type: %u\n"",
			 atusb->fw_ver_maj, atusb->fw_ver_min, atusb->fw_hw_type);
	}
	if (atusb->fw_ver_maj == 0 && atusb->fw_ver_min < 2) {
		dev_info(&usb_dev->dev,
			 ""Firmware version (%u.%u) predates our first public release."",
			 atusb->fw_ver_maj, atusb->fw_ver_min);
 		dev_info(&usb_dev->dev, ""Please update to version 0.2 or newer"");
 	}
 
 	return ret;
 }
",1
Detect whether the following code contains vulnerabilities.,"static void __exit tcm_loop_fabric_exit(void)
{
	tcm_loop_deregister_configfs();
	tcm_loop_release_core_bus();
	kmem_cache_destroy(tcm_loop_cmd_cache);
}
",0
Detect whether the following code contains vulnerabilities.,"  ~ConnectionFilterController() {}
",0
Detect whether the following code contains vulnerabilities.,"void PDFiumEngine::OnDocumentComplete() {
  if (!doc_ || !form_) {
    file_access_.m_FileLen = doc_loader_.document_size();
    if (!fpdf_availability_) {
      fpdf_availability_ = FPDFAvail_Create(&file_availability_, &file_access_);
      DCHECK(fpdf_availability_);
    }
    LoadDocument();
    return;
  }

  FinishLoadingDocument();
}
",0
Detect whether the following code contains vulnerabilities.,"string16 ExtensionInstallUI::Prompt::GetHeading(std::string extension_name)
    const {
   if (type_ == INLINE_INSTALL_PROMPT) {
     return UTF8ToUTF16(extension_name);
   } else {
    return l10n_util::GetStringFUTF16(
        kHeadingIds[type_], UTF8ToUTF16(extension_name));
  }
}
",1
Detect whether the following code contains vulnerabilities.,"WebMediaPlayer* RenderView::createMediaPlayer(
    WebFrame* frame, WebMediaPlayerClient* client) {
  FOR_EACH_OBSERVER(
      RenderViewObserver, observers_, WillCreateMediaPlayer(frame, client));

  scoped_ptr<media::MessageLoopFactory> message_loop_factory(
      new media::MessageLoopFactoryImpl());
  scoped_ptr<media::FilterCollection> collection(
      new media::FilterCollection());

  const CommandLine* cmd_line = CommandLine::ForCurrentProcess();
  if (!cmd_line->HasSwitch(switches::kDisableAudio)) {
    collection->AddAudioRenderer(new AudioRendererImpl());
  }

  scoped_refptr<webkit_glue::WebVideoRenderer> video_renderer;
  bool pts_logging = cmd_line->HasSwitch(switches::kEnableVideoLogging);
  scoped_refptr<webkit_glue::VideoRendererImpl> renderer(
      new webkit_glue::VideoRendererImpl(pts_logging));
  collection->AddVideoRenderer(renderer);
  video_renderer = renderer;

  scoped_ptr<webkit_glue::WebMediaPlayerImpl> result(
      new webkit_glue::WebMediaPlayerImpl(client,
                                          collection.release(),
                                          message_loop_factory.release(),
                                          media_stream_impl_.get()));
  if (!result->Initialize(frame,
                          cmd_line->HasSwitch(switches::kSimpleDataSource),
                          video_renderer)) {
    return NULL;
  }
  return result.release();
}
",0
Detect whether the following code contains vulnerabilities.,"w3m_exit(int i)
{
#ifdef USE_MIGEMO
    init_migemo();		/* close pipe to migemo */
#endif
    stopDownload();
    deleteFiles();
#ifdef USE_SSL
    free_ssl_ctx();
#endif
    disconnectFTP();
#ifdef USE_NNTP
    disconnectNews();
 #endif
 #ifdef __MINGW32_VERSION
     WSACleanup();
 #endif
     exit(i);
 }
",1
Detect whether the following code contains vulnerabilities.," Node::InsertionNotificationRequest HTMLBodyElement::insertedInto(ContainerNode* insertionPoint)
 {
     HTMLElement::insertedInto(insertionPoint);
    if (insertionPoint->inDocument()) {
        Element* ownerElement = document().ownerElement();
        if (isHTMLFrameElementBase(ownerElement)) {
            HTMLFrameElementBase& ownerFrameElement = toHTMLFrameElementBase(*ownerElement);
            int marginWidth = ownerFrameElement.marginWidth();
            if (marginWidth != -1)
                setIntegralAttribute(marginwidthAttr, marginWidth);
            int marginHeight = ownerFrameElement.marginHeight();
            if (marginHeight != -1)
                setIntegralAttribute(marginheightAttr, marginHeight);
        }
    }
    return InsertionDone;
 }
",1
Detect whether the following code contains vulnerabilities.," void TranslateInfoBarBase::Layout() {
  InfoBar::Layout();
 
   gfx::Size icon_ps = icon_->GetPreferredSize();
  icon_->SetBounds(InfoBar::kHorizontalPadding, InfoBar::OffsetY(this, icon_ps),
      icon_ps.width(), icon_ps.height());
 }
",1
Detect whether the following code contains vulnerabilities.,"static int set_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)
 {
	return usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0),
			       RTL8150_REQ_SET_REGS, RTL8150_REQT_WRITE,
			       indx, 0, data, size, 500);
 }
",1
Detect whether the following code contains vulnerabilities.,"bool BrowserCommandController::IsCommandEnabled(int id) const {
  return command_updater_.IsCommandEnabled(id);
}
",0
Detect whether the following code contains vulnerabilities.,"get_caller_uid (GDBusMethodInvocation *context, gint *uid)
 {
        PolkitSubject *subject;
        PolkitSubject *process;
 
        subject = polkit_system_bus_name_new (g_dbus_method_invocation_get_sender (context));
        process = polkit_system_bus_name_get_process_sync (POLKIT_SYSTEM_BUS_NAME (subject), NULL, NULL);
        if (!process) {
                g_object_unref (subject);
                 return FALSE;
         }
 
        *uid = polkit_unix_process_get_uid (POLKIT_UNIX_PROCESS (process));
        g_object_unref (subject);
        g_object_unref (process);
 
         return TRUE;
 }
",1
Detect whether the following code contains vulnerabilities.,"static int l2tp_ip6_backlog_recv(struct sock *sk, struct sk_buff *skb)
{
	int rc;

	/* Charge it to the socket, dropping if the queue is full. */
	rc = sock_queue_rcv_skb(sk, skb);
	if (rc < 0)
		goto drop;

	return 0;

drop:
	IP_INC_STATS(&init_net, IPSTATS_MIB_INDISCARDS);
	kfree_skb(skb);
	return -1;
}
",0
Detect whether the following code contains vulnerabilities.,"bool ParamTraits<AudioParameters>::Read(const Message* m,
                                        PickleIterator* iter,
                                        AudioParameters* r) {
  int format, channel_layout, sample_rate, bits_per_sample,
      frames_per_buffer, channels;

  if (!m->ReadInt(iter, &format) ||
      !m->ReadInt(iter, &channel_layout) ||
      !m->ReadInt(iter, &sample_rate) ||
      !m->ReadInt(iter, &bits_per_sample) ||
      !m->ReadInt(iter, &frames_per_buffer) ||
      !m->ReadInt(iter, &channels))
    return false;
   r->Reset(static_cast<AudioParameters::Format>(format),
            static_cast<ChannelLayout>(channel_layout),
            sample_rate, bits_per_sample, frames_per_buffer);
   return true;
 }
",1
Detect whether the following code contains vulnerabilities.,"void RenderBlockFlow::styleDidChange(StyleDifference diff, const RenderStyle* oldStyle)
{
    RenderBlock::styleDidChange(diff, oldStyle);

     bool canPropagateFloatIntoSibling = !isFloatingOrOutOfFlowPositioned() && !avoidsFloats();
    if (diff == StyleDifferenceLayout && s_canPropagateFloatIntoSibling && !canPropagateFloatIntoSibling && hasOverhangingFloats()) {
         RenderBlockFlow* parentBlockFlow = this;
         const FloatingObjectSet& floatingObjectSet = m_floatingObjects->set();
         FloatingObjectSetIterator end = floatingObjectSet.end();

        for (RenderObject* curr = parent(); curr && !curr->isRenderView(); curr = curr->parent()) {
            if (curr->isRenderBlockFlow()) {
                RenderBlockFlow* currBlock = toRenderBlockFlow(curr);

                if (currBlock->hasOverhangingFloats()) {
                    for (FloatingObjectSetIterator it = floatingObjectSet.begin(); it != end; ++it) {
                        RenderBox* renderer = (*it)->renderer();
                        if (currBlock->hasOverhangingFloat(renderer)) {
                            parentBlockFlow = currBlock;
                            break;
                        }
                    }
                }
            }
        }

        parentBlockFlow->markAllDescendantsWithFloatsForLayout();
         parentBlockFlow->markSiblingsWithFloatsForLayout();
     }
 
    if (diff == StyleDifferenceLayout || !oldStyle)
         createOrDestroyMultiColumnFlowThreadIfNeeded();
 }
",1
Detect whether the following code contains vulnerabilities.," checked_xcalloc (size_t num, size_t size)
 {
    alloc_limit_assert (""checked_xcalloc"", (num *size));
     return xcalloc (num, size);
 }
",1
Detect whether the following code contains vulnerabilities.,"PasswordGenerationUIData GetTestGenerationUIData2() {
  PasswordForm form;
  form.form_data = autofill::FormData();
  form.form_data.action = GURL(""http://www.example2.com/accounts/Login"");
  form.form_data.origin = GURL(""http://www.example2.com/accounts/LoginAuth"");
  PasswordGenerationUIData data;
  data.password_form = form;
  data.generation_element = ASCIIToUTF16(""testelement2"");
  data.max_length = 11;
  return data;
}
",1
Detect whether the following code contains vulnerabilities.,"static void sas_unregister_common_dev(struct asd_sas_port *port, struct domain_device *dev)
{
	struct sas_ha_struct *ha = port->ha;

	sas_notify_lldd_dev_gone(dev);
	if (!dev->parent)
		dev->port->port_dev = NULL;
	else
		list_del_init(&dev->siblings);

	spin_lock_irq(&port->dev_list_lock);
	list_del_init(&dev->dev_list_node);
	if (dev_is_sata(dev))
		sas_ata_end_eh(dev->sata_dev.ap);
	spin_unlock_irq(&port->dev_list_lock);

	spin_lock_irq(&ha->lock);
	if (dev->dev_type == SAS_END_DEVICE &&
	    !list_empty(&dev->ssp_dev.eh_list_node)) {
		list_del_init(&dev->ssp_dev.eh_list_node);
		ha->eh_active--;
	}
	spin_unlock_irq(&ha->lock);

 	sas_put_device(dev);
 }
",0
Detect whether the following code contains vulnerabilities.,"bool SocketStream::is_secure() const {
  return url_.SchemeIs(""wss"");
 }
",0
Detect whether the following code contains vulnerabilities.,"_tiffUnmapProc(thandle_t fd, void* base, toff_t size)
{
	(void) fd;
	(void) size;
	UnmapViewOfFile(base);
}
",0
Detect whether the following code contains vulnerabilities.,"void sched_destroy_group(struct task_group *tg)
{
	unsigned long flags;
	int i;

	/* end participation in shares distribution */
	for_each_possible_cpu(i)
		unregister_fair_sched_group(tg, i);

	spin_lock_irqsave(&task_group_lock, flags);
	list_del_rcu(&tg->list);
	list_del_rcu(&tg->siblings);
	spin_unlock_irqrestore(&task_group_lock, flags);

	/* wait for possible concurrent references to cfs_rqs complete */
	call_rcu(&tg->rcu, free_sched_group_rcu);
}
",0
Detect whether the following code contains vulnerabilities.,"static int nl80211_valid_4addr(struct cfg80211_registered_device *rdev,
			       struct net_device *netdev, u8 use_4addr,
			       enum nl80211_iftype iftype)
{
	if (!use_4addr) {
		if (netdev && (netdev->priv_flags & IFF_BRIDGE_PORT))
			return -EBUSY;
		return 0;
	}

	switch (iftype) {
	case NL80211_IFTYPE_AP_VLAN:
		if (rdev->wiphy.flags & WIPHY_FLAG_4ADDR_AP)
			return 0;
		break;
	case NL80211_IFTYPE_STATION:
		if (rdev->wiphy.flags & WIPHY_FLAG_4ADDR_STATION)
			return 0;
		break;
	default:
		break;
	}

	return -EOPNOTSUPP;
}
",0
Detect whether the following code contains vulnerabilities.,"int _our_safe_pcap_next_ex(pcap_t *pcap, struct pcap_pkthdr **pkthdr,
        const u_char **pktdata, const char *funcname,
        const int line, const char *file)
{
    int res = pcap_next_ex(pcap, pkthdr, pktdata);

    if (*pktdata && *pkthdr) {
        if ((*pkthdr)->len > MAXPACKET) {
            fprintf(stderr, ""safe_pcap_next_ex ERROR: Invalid packet length in %s:%s() line %d: %u is greater than maximum %u\n"",
                    file, funcname, line, (*pkthdr)->len, MAXPACKET);
             exit(-1);
         }
 
        if ((*pkthdr)->len < (*pkthdr)->caplen) {
            fprintf(stderr, ""safe_pcap_next_ex ERROR: Invalid packet length in %s:%s() line %d: packet length %u is less than capture length %u\n"",
                     file, funcname, line, (*pkthdr)->len, (*pkthdr)->caplen);
             exit(-1);
         }
    }

    return res;
}
",1
Detect whether the following code contains vulnerabilities.,"static void vrend_renderer_init_blit_ctx(struct vrend_blitter_ctx *blit_ctx)
{
   struct virgl_gl_ctx_param ctx_params;
   int i;
   if (blit_ctx->initialised) {
      vrend_clicbs->make_current(0, blit_ctx->gl_context);
       return;
    }
 
    ctx_params.shared = true;
    ctx_params.major_ver = VREND_GL_VER_MAJOR;
    ctx_params.minor_ver = VREND_GL_VER_MINOR;

   vrend_clicbs->make_current(0, blit_ctx->gl_context);
   glGenVertexArrays(1, &blit_ctx->vaoid);
   glGenFramebuffers(1, &blit_ctx->fb_id);

   glGenBuffers(1, &blit_ctx->vbo_id);
   blit_build_vs_passthrough(blit_ctx);

   for (i = 0; i < 4; i++)
      blit_ctx->vertices[i][0][3] = 1; /*v.w*/
   glBindVertexArray(blit_ctx->vaoid);
   glBindBuffer(GL_ARRAY_BUFFER, blit_ctx->vbo_id);
}
",1
Detect whether the following code contains vulnerabilities.,"void HTMLFormControlElement::parseAttribute(const QualifiedName& name, const AtomicString& value)
{
    if (name == formAttr) {
        formAttributeChanged();
        UseCounter::count(document(), UseCounter::FormAttribute);
    } else if (name == disabledAttr) {
        bool oldDisabled = m_disabled;
        m_disabled = !value.isNull();
        if (oldDisabled != m_disabled)
            disabledAttributeChanged();
    } else if (name == readonlyAttr) {
        bool wasReadOnly = m_isReadOnly;
         m_isReadOnly = !value.isNull();
         if (wasReadOnly != m_isReadOnly) {
             setNeedsWillValidateCheck();
            setNeedsStyleRecalc(SubtreeStyleChange, StyleChangeReasonForTracing::fromAttribute(name));
             if (layoutObject())
                 LayoutTheme::theme().controlStateChanged(*layoutObject(), ReadOnlyControlState);
         }
    } else if (name == requiredAttr) {
        bool wasRequired = m_isRequired;
        m_isRequired = !value.isNull();
        if (wasRequired != m_isRequired)
            requiredAttributeChanged();
        UseCounter::count(document(), UseCounter::RequiredAttribute);
    } else if (name == autofocusAttr) {
        HTMLElement::parseAttribute(name, value);
        UseCounter::count(document(), UseCounter::AutoFocusAttribute);
    } else {
        HTMLElement::parseAttribute(name, value);
    }
}
",1
Detect whether the following code contains vulnerabilities.,"static void br_multicast_group_expired(unsigned long data)
{
	struct net_bridge_mdb_entry *mp = (void *)data;
	struct net_bridge *br = mp->br;
	struct net_bridge_mdb_htable *mdb;

	spin_lock(&br->multicast_lock);
	if (!netif_running(br->dev) || timer_pending(&mp->timer))
		goto out;

	if (!hlist_unhashed(&mp->mglist))
		hlist_del_init(&mp->mglist);

	if (mp->ports)
		goto out;

	mdb = mlock_dereference(br->mdb, br);

	hlist_del_rcu(&mp->hlist[mdb->ver]);
	mdb->size--;

	del_timer(&mp->query_timer);
	call_rcu_bh(&mp->rcu, br_multicast_free_group);

out:
	spin_unlock(&br->multicast_lock);
}
",0
Detect whether the following code contains vulnerabilities.,"Plugin::~Plugin() {
  int64_t shutdown_start = NaClGetTimeOfDayMicroseconds();

  PLUGIN_PRINTF((""Plugin::~Plugin (this=%p, scriptable_plugin=%p)\n"",
                 static_cast<void*>(this),
                 static_cast<void*>(scriptable_plugin())));
  pnacl_coordinator_.reset(NULL);
  if (ppapi_proxy_ != NULL) {
    HistogramTimeLarge(
        ""NaCl.ModuleUptime.Normal"",
        (shutdown_start - ready_time_) / NACL_MICROS_PER_MILLI);
  }

  url_downloaders_.erase(url_downloaders_.begin(), url_downloaders_.end());

  ShutdownProxy();
  ScriptablePlugin* scriptable_plugin_ = scriptable_plugin();
  ScriptablePlugin::Unref(&scriptable_plugin_);

  ShutDownSubprocesses();

  delete wrapper_factory_;
  delete[] argv_;
  delete[] argn_;

  HistogramTimeSmall(
      ""NaCl.Perf.ShutdownTime.Total"",
      (NaClGetTimeOfDayMicroseconds() - shutdown_start)
          / NACL_MICROS_PER_MILLI);

  PLUGIN_PRINTF((""Plugin::~Plugin (this=%p, return)\n"",
                 static_cast<void*>(this)));
}
",0
Detect whether the following code contains vulnerabilities.,"void GpuProcessHostUIShim::OnAcceleratedSurfaceNew(
    const GpuHostMsg_AcceleratedSurfaceNew_Params& params) {
  RenderWidgetHostViewPort* view = GetRenderWidgetHostViewFromSurfaceID(
       params.surface_id);
   if (!view)
     return;
   view->AcceleratedSurfaceNew(
      params.width, params.height, params.surface_handle);
 }
",1
Detect whether the following code contains vulnerabilities.,"void SafeBrowsingBlockingPageV2::PopulateStringDictionary(
    DictionaryValue* strings,
    const string16& title,
    const string16& headline,
    const string16& description1,
    const string16& description2,
    const string16& description3) {
  strings->SetString(""title"", title);
  strings->SetString(""headLine"", headline);
  strings->SetString(""description1"", description1);
  strings->SetString(""description2"", description2);
  strings->SetString(""description3"", description3);
  strings->SetBoolean(""proceedDisabled"",
                      IsPrefEnabled(prefs::kSafeBrowsingProceedAnywayDisabled));
  strings->SetBoolean(""isMainFrame"", is_main_frame_load_blocked_);
  strings->SetBoolean(""isPhishing"", interstitial_type_ == TYPE_PHISHING);

  strings->SetString(""back_button"",
      l10n_util::GetStringUTF16(IDS_SAFE_BROWSING_MALWARE_BACK_BUTTON));
  strings->SetString(""seeMore"", l10n_util::GetStringUTF16(
      IDS_SAFE_BROWSING_MALWARE_V2_SEE_MORE));
  strings->SetString(""proceed"",
      l10n_util::GetStringUTF16(IDS_SAFE_BROWSING_MALWARE_V2_PROCEED_LINK));

  URLDataSource::SetFontAndTextDirection(strings);
}
",0
Detect whether the following code contains vulnerabilities.,"xfs_perag_set_reclaim_tag(
	struct xfs_perag	*pag)
{
	struct xfs_mount	*mp = pag->pag_mount;

	lockdep_assert_held(&pag->pag_ici_lock);
	if (pag->pag_ici_reclaimable++)
		return;

	/* propagate the reclaim tag up into the perag radix tree */
	spin_lock(&mp->m_perag_lock);
	radix_tree_tag_set(&mp->m_perag_tree, pag->pag_agno,
			   XFS_ICI_RECLAIM_TAG);
	spin_unlock(&mp->m_perag_lock);

	/* schedule periodic background inode reclaim */
	xfs_reclaim_work_queue(mp);

	trace_xfs_perag_set_reclaim(mp, pag->pag_agno, -1, _RET_IP_);
}
",0
Detect whether the following code contains vulnerabilities.,"static inline void unmap_mapping_range_tree(struct rb_root *root,
					    struct zap_details *details)
{
	struct vm_area_struct *vma;
	pgoff_t vba, vea, zba, zea;

	vma_interval_tree_foreach(vma, root,
			details->first_index, details->last_index) {

		vba = vma->vm_pgoff;
		vea = vba + vma_pages(vma) - 1;
		/* Assume for now that PAGE_CACHE_SHIFT == PAGE_SHIFT */
		zba = details->first_index;
		if (zba < vba)
			zba = vba;
		zea = details->last_index;
		if (zea > vea)
			zea = vea;

		unmap_mapping_range_vma(vma,
			((zba - vba) << PAGE_SHIFT) + vma->vm_start,
			((zea - vba + 1) << PAGE_SHIFT) + vma->vm_start,
				details);
	}
}
",0
Detect whether the following code contains vulnerabilities.,"    FinishCompleteLoginParams::~FinishCompleteLoginParams() {}
",0
Detect whether the following code contains vulnerabilities.,"static int cfg_keys(struct cryp_ctx *ctx)
{
	int i;
	int num_of_regs = ctx->keylen / 8;
	u32 swapped_key[CRYP_MAX_KEY_SIZE / 4];
	int cryp_error = 0;

	dev_dbg(ctx->device->dev, ""[%s]"", __func__);

	if (mode_is_aes(ctx->config.algomode)) {
		swap_words_in_key_and_bits_in_byte((u8 *)ctx->key,
						   (u8 *)swapped_key,
						   ctx->keylen);
	} else {
		for (i = 0; i < ctx->keylen / 4; i++)
			swapped_key[i] = uint8p_to_uint32_be(ctx->key + i*4);
	}

	for (i = 0; i < num_of_regs; i++) {
		cryp_error = set_key(ctx->device,
				     *(((u32 *)swapped_key)+i*2),
				     *(((u32 *)swapped_key)+i*2+1),
				     (enum cryp_key_reg_index) i);

		if (cryp_error != 0) {
			dev_err(ctx->device->dev, ""[%s]: set_key() failed!"",
					__func__);
			return cryp_error;
		}
	}
	return cryp_error;
}
",0
Detect whether the following code contains vulnerabilities.,"Node* Range::pastLastNode() const
{
    if (!m_start.container() || !m_end.container())
        return 0;
    if (m_end.container()->offsetInCharacters())
        return m_end.container()->traverseNextSibling();
    if (Node* child = m_end.container()->childNode(m_end.offset()))
        return child;
    return m_end.container()->traverseNextSibling();
}
",0
Detect whether the following code contains vulnerabilities.," av_cold void ff_mpv_idct_init(MpegEncContext *s)
 {
     ff_idctdsp_init(&s->idsp, s->avctx);
 
     /* load & permutate scantables
     * note: only wmv uses different ones
     */
    if (s->alternate_scan) {
        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_alternate_vertical_scan);
        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_alternate_vertical_scan);
    } else {
        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_zigzag_direct);
        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_zigzag_direct);
    }
    ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_horizontal_scan);
    ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);
}
",1
Detect whether the following code contains vulnerabilities.,"static void didFinishLoadForFrame(WKPageRef page, WKFrameRef frame, WKTypeRef userData, const void* clientInfo)
{
    if (!WKFrameIsMainFrame(frame))
        return;

    webkitWebViewLoadChanged(WEBKIT_WEB_VIEW(clientInfo), WEBKIT_LOAD_FINISHED);
}
",0
Detect whether the following code contains vulnerabilities.,"notify_setup(void)
{
	if (pipe(notify_pipe) < 0) {
		error(""pipe(notify_pipe) failed %s"", strerror(errno));
	} else if ((fcntl(notify_pipe[0], F_SETFD, FD_CLOEXEC) == -1) ||
	    (fcntl(notify_pipe[1], F_SETFD, FD_CLOEXEC) == -1)) {
		error(""fcntl(notify_pipe, F_SETFD) failed %s"", strerror(errno));
		close(notify_pipe[0]);
		close(notify_pipe[1]);
	} else {
		set_nonblock(notify_pipe[0]);
		set_nonblock(notify_pipe[1]);
		return;
	}
	notify_pipe[0] = -1;	/* read end */
	notify_pipe[1] = -1;	/* write end */
}
",0
Detect whether the following code contains vulnerabilities.,"my_object_dict_of_dicts (MyObject *obj, GHashTable *in,
                                GHashTable **out, GError **error)
{
  *out = g_hash_table_new_full (g_str_hash, g_str_equal,
				(GDestroyNotify) g_free,
                                (GDestroyNotify) g_hash_table_destroy);
  g_hash_table_foreach (in, hash_foreach_mangle_dict_of_strings, *out);
  return TRUE;
}
",1
Detect whether the following code contains vulnerabilities.,"static int authenticate_and_decrypt_nss_2_0 (
	struct crypto_instance *instance,
	unsigned char *buf,
	int *buf_len)
{
	if (hash_to_nss[instance->crypto_hash_type]) {
		unsigned char	tmp_hash[hash_len[instance->crypto_hash_type]];
		unsigned char	*hash = buf;
		unsigned char	*data = hash + hash_len[instance->crypto_hash_type];
		int		datalen = *buf_len - hash_len[instance->crypto_hash_type];

		if (calculate_nss_hash(instance, data, datalen, tmp_hash) < 0) {
			return -1;
		}

		if (memcmp(tmp_hash, hash, hash_len[instance->crypto_hash_type]) != 0) {
			log_printf(instance->log_level_error, ""Digest does not match"");
			return -1;
		}

		memmove(buf, data, datalen);
		*buf_len = datalen;
	}

	if (decrypt_nss(instance, buf, buf_len) < 0) {
		return -1;
	}

	return 0;
}
",0
Detect whether the following code contains vulnerabilities.," void VarianceTest<VarianceFunctionType>::ZeroTest() {
   for (int i = 0; i <= 255; ++i) {
    memset(src_, i, block_size_);
     for (int j = 0; j <= 255; ++j) {
      memset(ref_, j, block_size_);
       unsigned int sse;
       unsigned int var;
      REGISTER_STATE_CHECK(var = variance_(src_, width_, ref_, width_, &sse));
      EXPECT_EQ(0u, var) << ""src values: "" << i << ""ref values: "" << j;
     }
   }
 }
",1
Detect whether the following code contains vulnerabilities.,"GahpServer::RemoveGahpClient()
{
	m_reference_count--;

	if ( m_reference_count <= 0 ) {
		m_deleteMeTid = daemonCore->Register_Timer( 30,
								(TimerHandlercpp)&GahpServer::DeleteMe,
								""GahpServer::DeleteMe"", (Service*)this );
	}
}
",0
Detect whether the following code contains vulnerabilities.," static int set_register(pegasus_t *pegasus, __u16 indx, __u8 data)
 {
 	int ret;
 
 	ret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),
 			      PEGASUS_REQ_SET_REG, PEGASUS_REQT_WRITE, data,
			      indx, &data, 1, 1000);
 	if (ret < 0)
 		netif_dbg(pegasus, drv, pegasus->net,
 			  ""%s returned %d\n"", __func__, ret);
 	return ret;
 }
",1
Detect whether the following code contains vulnerabilities.," static int getStrrtokenPos(char* str, int savedPos)
 {
 	int result =-1;
 	int i;
 	for(i=savedPos-1; i>=0; i--) {
 		if(isIDSeparator(*(str+i)) ){
 			/* delimiter found; check for singleton */
			if(i>=2 && isIDSeparator(*(str+i-2)) ){
				/* a singleton; so send the position of token before the singleton */
				result = i-2;
			} else {
				result = i;
			}
			break;
		}
	}
	if(result < 1){
		/* Just in case inavlid locale e.g. '-x-xyz' or '-sl_Latn' */
		result =-1;
	}
	return result;
}
",1
Detect whether the following code contains vulnerabilities.,"static void conditionalAttr1AttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)
{
    ExceptionState exceptionState(ExceptionState::SetterContext, ""conditionalAttr1"", ""TestObject"", info.Holder(), info.GetIsolate());
    TestObject* imp = V8TestObject::toNative(info.Holder());
    V8TRYCATCH_EXCEPTION_VOID(int, cppValue, toInt32(jsValue, exceptionState), exceptionState);
    imp->setConditionalAttr1(cppValue);
}
",0
Detect whether the following code contains vulnerabilities.,"gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,
		   gss_qop_t *qop_state, gss_iov_buffer_desc *iov,
		   int iov_count)
{
    OM_uint32 status;
    gss_union_ctx_id_t ctx;
    gss_mechanism mech;

    status = val_unwrap_iov_args(minor_status, context_handle, NULL,
				 qop_state, iov, iov_count);
    if (status != GSS_S_COMPLETE)
	return status;
 
     /* Select the approprate underlying mechanism routine and call it. */
     ctx = (gss_union_ctx_id_t)context_handle;
     mech = gssint_get_mechanism(ctx->mech_type);
     if (mech == NULL)
 	return GSS_S_BAD_MECH;
    if (mech->gss_verify_mic_iov == NULL)
	return GSS_S_UNAVAILABLE;
    status = mech->gss_verify_mic_iov(minor_status, ctx->internal_ctx_id,
				      qop_state, iov, iov_count);
    if (status != GSS_S_COMPLETE)
	map_error(minor_status, mech);
    return status;
}
",1
Detect whether the following code contains vulnerabilities.,"void drop_privileges(char *username) {
	struct passwd *user = (struct passwd *) getpwnam(username);
	if (user == NULL) {
		fprintf(stderr, _(""Failed dropping privileges. The user %s is not a valid username on local system.\n""), username);
		exit(1);
	}
	if (getuid() == 0) {
		/* process is running as root, drop privileges */
		if (setgid(user->pw_gid) != 0) {
			fprintf(stderr, _(""setgid: Error dropping group privileges\n""));
			exit(1);
		}
		if (setuid(user->pw_uid) != 0) {
			fprintf(stderr, _(""setuid: Error dropping user privileges\n""));
			exit(1);
		}
		/* Verify if the privileges were developed. */
		if (setuid(0) != -1) {
			fprintf(stderr, _(""Failed to drop privileges\n""));
			exit(1);
		}
	}
}
",0
Detect whether the following code contains vulnerabilities.," void BufferQueueConsumer::dump(String8& result, const char* prefix) const {
    mCore->dump(result, prefix);
 }
",1
Detect whether the following code contains vulnerabilities.,"void WebContentsImpl::RenderViewForInterstitialPageCreated(
    RenderViewHost* render_view_host) {
  FOR_EACH_OBSERVER(WebContentsObserver, observers_,
                    RenderViewForInterstitialPageCreated(render_view_host));
}
",0
Detect whether the following code contains vulnerabilities.,"my_object_many_args (MyObject *obj, guint32 x, const char *str, double trouble, double *d_ret, char **str_ret, GError **error)
{
  *d_ret = trouble + (x * 2);
  *str_ret = g_ascii_strup (str, -1);
  return TRUE;
}
",1
Detect whether the following code contains vulnerabilities.,"static const char *set_async_filter(cmd_parms *cmd, void *dummy,
                                             const char *arg)
{
    core_server_config *conf =
    ap_get_core_module_config(cmd->server->module_config);
    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);

    if (err) {
        return err;
    }

    if (ap_cstr_casecmp(arg, ""network"") == 0) {
        conf->async_filter = AP_FTYPE_NETWORK;
    }
    else if (ap_cstr_casecmp(arg, ""connection"") == 0) {
        conf->async_filter = AP_FTYPE_CONNECTION;
    }
    else if (ap_cstr_casecmp(arg, ""request"") == 0) {
        conf->async_filter = 0;
    }
    else {
        return ""AsyncFilter must be 'network', 'connection' or 'request'"";
    }
    conf->async_filter_set = 1;

    return NULL;
}
",0
Detect whether the following code contains vulnerabilities.,"  virtual void SetUpCommandLine(CommandLine* command_line) {
    GpuFeatureTest::SetUpCommandLine(command_line);
    command_line->AppendSwitch(switches::kDisableExperimentalWebGL);
  }
",0
Detect whether the following code contains vulnerabilities.,"static v8::Handle<v8::Value> enabledAtRuntimeMethod2Callback(const v8::Arguments& args)
 {
     INC_STATS(""DOM.TestObj.enabledAtRuntimeMethod2"");
     if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
     TestObj* imp = V8TestObj::toNative(args.Holder());
     EXCEPTION_BLOCK(int, intArg, V8int::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8int::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
     imp->enabledAtRuntimeMethod2(intArg);
    return v8::Handle<v8::Value>();
}
",1
Detect whether the following code contains vulnerabilities.,"add_cipher_name_to_ary(const OBJ_NAME *name, VALUE ary)
{
    rb_ary_push(ary, rb_str_new2(name->name));
    return NULL;
}
",0
Detect whether the following code contains vulnerabilities.,"PaletteTool::~PaletteTool() {}
",0
Detect whether the following code contains vulnerabilities.,"init_ext2_xattr(void)
 {
	ext2_xattr_cache = mb_cache_create(""ext2_xattr"", 6);
	if (!ext2_xattr_cache)
		return -ENOMEM;
	return 0;
 }
",1
Detect whether the following code contains vulnerabilities.,"static bool vmxnet3_interrupt_asserted(VMXNET3State *s, int lidx)
{
    return s->interrupt_states[lidx].is_asserted;
}
",0
Detect whether the following code contains vulnerabilities.,"vips_malloc( VipsObject *object, size_t size )
 {
 	void *buf;
 
	buf = g_malloc( size );
 
         if( object ) {
 		g_signal_connect( object, ""postclose"", 
			G_CALLBACK( vips_malloc_cb ), buf );
		object->local_memory += size;
	}

	return( buf );
}
",1
Detect whether the following code contains vulnerabilities.,"void ObserverOnLogoAvailable(LogoObserver* observer,
                             bool from_cache,
                             LogoCallbackReason type,
                             const base::Optional<Logo>& logo) {
  switch (type) {
    case LogoCallbackReason::DISABLED:
    case LogoCallbackReason::CANCELED:
    case LogoCallbackReason::FAILED:
      break;
    case LogoCallbackReason::REVALIDATED:
      break;
    case LogoCallbackReason::DETERMINED:
      observer->OnLogoAvailable(logo ? &logo.value() : nullptr, from_cache);
      break;
  }
  if (!from_cache) {
    observer->OnObserverRemoved();
  }
}
",1
Detect whether the following code contains vulnerabilities.,"void SplitString(const std::wstring& str,
                 wchar_t c,
                 std::vector<std::wstring>* r) {
  SplitStringT(str, c, true, r);
}
",1
Detect whether the following code contains vulnerabilities.,"static double abserr(PNG_CONST png_modifier *pm, int in_depth, int out_depth)
 {
    /* Absolute error permitted in linear values - affected by the bit depth of
     * the calculations.
    */
 if (pm->assume_16_bit_calculations ||
 (pm->calculations_use_input_precision ? in_depth : out_depth) == 16)
 return pm->maxabs16;
 else

       return pm->maxabs8;
 }
",1
Detect whether the following code contains vulnerabilities.,"gpgsm_reset (void *engine)
{
  engine_gpgsm_t gpgsm = engine;

  /* IF we have an active connection we must send a reset because we
     need to reset the list of signers.  Note that RESET does not
     reset OPTION commands. */
  return (gpgsm->assuan_ctx
          ? gpgsm_assuan_simple_command (gpgsm->assuan_ctx, ""RESET"",
                                         NULL, NULL)
          : 0);
}
",0
Detect whether the following code contains vulnerabilities.,"ProcEstablishConnection(ClientPtr client)
{
    const char *reason;
    char *auth_proto, *auth_string;
    xConnClientPrefix *prefix;

    REQUEST(xReq);

     prefix = (xConnClientPrefix *) ((char *) stuff + sz_xReq);
     auth_proto = (char *) prefix + sz_xConnClientPrefix;
     auth_string = auth_proto + pad_to_int32(prefix->nbytesAuthProto);
    if ((prefix->majorVersion != X_PROTOCOL) ||
         (prefix->minorVersion != X_PROTOCOL_REVISION))
         reason = ""Protocol version mismatch"";
     else

    return (SendConnSetup(client, reason));
}
",1
Detect whether the following code contains vulnerabilities.,"void RenderFrameImpl::OnJavaScriptExecuteRequestInIsolatedWorld(
    const base::string16& jscript,
    int id,
    bool notify_result,
    int world_id) {
  TRACE_EVENT_INSTANT0(""test_tracing"",
                       ""OnJavaScriptExecuteRequestInIsolatedWorld"",
                       TRACE_EVENT_SCOPE_THREAD);

  if (world_id <= ISOLATED_WORLD_ID_GLOBAL ||
      world_id > ISOLATED_WORLD_ID_MAX) {
    NOTREACHED();
    return;
  }

  v8::HandleScope handle_scope(v8::Isolate::GetCurrent());
  WebScriptSource script = WebScriptSource(jscript);
  JavaScriptIsolatedWorldRequest* request = new JavaScriptIsolatedWorldRequest(
      id, notify_result, routing_id_, weak_factory_.GetWeakPtr());
  frame_->requestExecuteScriptInIsolatedWorld(world_id, &script, 1, 0, false,
                                              request);
}
",0
Detect whether the following code contains vulnerabilities.,"void DistillerNativeJavaScript::BindFunctionToObject(
    v8::Local<v8::Object> javascript_object,
    const std::string& name,
    const base::Callback<Sig> callback) {
  v8::Isolate* isolate = javascript_object->GetIsolate();
  javascript_object->Set(
      gin::StringToSymbol(isolate, name),
      gin::CreateFunctionTemplate(isolate, callback)->GetFunction());
 }
",0
Detect whether the following code contains vulnerabilities.,"static void LaunchDownloadOverwriteInfoBar(
    JNIEnv* env,
    const JavaParamRef<jclass>& clazz,
    const JavaParamRef<jobject>& delegate,
    const JavaParamRef<jobject>& tab,
    const JavaParamRef<jobject>& download_info,
    const JavaParamRef<jstring>& jfile_name,
    const JavaParamRef<jstring>& jdir_name,
    const JavaParamRef<jstring>& jdir_full_path) {
  TabAndroid* tab_android = TabAndroid::GetNativeTab(env, tab);

  std::string file_name =
      base::android::ConvertJavaStringToUTF8(env, jfile_name);
  std::string dir_name = base::android::ConvertJavaStringToUTF8(env, jdir_name);
  std::string dir_full_path =
      base::android::ConvertJavaStringToUTF8(env, jdir_full_path);

  chrome::android::AndroidDownloadManagerOverwriteInfoBarDelegate::Create(
      InfoBarService::FromWebContents(tab_android->web_contents()), file_name,
      dir_name, dir_full_path, delegate, download_info);
}
",0
Detect whether the following code contains vulnerabilities.,"GDataEntry* GDataEntry::FromDocumentEntry(
    GDataDirectory* parent,
    DocumentEntry* doc,
    GDataDirectoryService* directory_service) {
  DCHECK(doc);
  if (doc->is_folder())
    return GDataDirectory::FromDocumentEntry(parent, doc, directory_service);
  else if (doc->is_hosted_document() || doc->is_file())
    return GDataFile::FromDocumentEntry(parent, doc, directory_service);
  return NULL;
}
",1
Detect whether the following code contains vulnerabilities.,"int perf_event_refresh(struct perf_event *event, int refresh)
{
	/*
	 * not supported on inherited events
	 */
	if (event->attr.inherit || !is_sampling_event(event))
		return -EINVAL;

	atomic_add(refresh, &event->event_limit);
	perf_event_enable(event);

	return 0;
}
",0
Detect whether the following code contains vulnerabilities.,"static NetworkRoamingState ParseRoamingState(
    const std::string& roaming_state) {
    if (roaming_state == kRoamingStateHome)
    return ROAMING_STATE_HOME;
  if (roaming_state == kRoamingStateRoaming)
    return ROAMING_STATE_ROAMING;
  if (roaming_state == kRoamingStateUnknown)
    return ROAMING_STATE_UNKNOWN;
  return ROAMING_STATE_UNKNOWN;
}
",0
Detect whether the following code contains vulnerabilities.,"v8::Handle<v8::Value> V8WebGLRenderingContext::getAttachedShadersCallback(const v8::Arguments& args)
{
     INC_STATS(""DOM.WebGLRenderingContext.getAttachedShaders()"");
 
     if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
 
     ExceptionCode ec = 0;
     WebGLRenderingContext* context = V8WebGLRenderingContext::toNative(args.Holder());
    if (args.Length() > 0 && !isUndefinedOrNull(args[0]) && !V8WebGLProgram::HasInstance(args[0])) {
        V8Proxy::throwTypeError();
        return notHandledByInterceptor();
    }
    WebGLProgram* program = V8WebGLProgram::HasInstance(args[0]) ? V8WebGLProgram::toNative(v8::Handle<v8::Object>::Cast(args[0])) : 0;
    Vector<RefPtr<WebGLShader> > shaders;
    bool succeed = context->getAttachedShaders(program, shaders, ec);
    if (ec) {
        V8Proxy::setDOMException(ec, args.GetIsolate());
        return v8::Null();
    }
    if (!succeed)
        return v8::Null();
    v8::Local<v8::Array> array = v8::Array::New(shaders.size());
    for (size_t ii = 0; ii < shaders.size(); ++ii)
        array->Set(v8::Integer::New(ii), toV8(shaders[ii].get(), args.GetIsolate()));
    return array;
}
",1
Detect whether the following code contains vulnerabilities.,"static int read_int32_info (WavpackStream *wps, WavpackMetadata *wpmd)
{
    int bytecnt = wpmd->byte_length;
    char *byteptr = (char *)wpmd->data;

    if (bytecnt != 4)
        return FALSE;

    wps->int32_sent_bits = *byteptr++;
    wps->int32_zeros = *byteptr++;
    wps->int32_ones = *byteptr++;
    wps->int32_dups = *byteptr;

    return TRUE;
}
",0
Detect whether the following code contains vulnerabilities.," void AppCacheGroup::RemoveCache(AppCache* cache) {
   DCHECK(cache->associated_hosts().empty());
   if (cache == newest_complete_cache_) {
    CancelUpdate();
     AppCache* tmp_cache = newest_complete_cache_;
     newest_complete_cache_ = nullptr;
     tmp_cache->set_owning_group(nullptr);  // may cause this group to be deleted
   } else {
     scoped_refptr<AppCacheGroup> protect(this);

    Caches::iterator it =
        std::find(old_caches_.begin(), old_caches_.end(), cache);
    if (it != old_caches_.end()) {
      AppCache* tmp_cache = *it;
      old_caches_.erase(it);
      tmp_cache->set_owning_group(nullptr);  // may cause group to be released
    }

    if (!is_obsolete() && old_caches_.empty() &&
        !newly_deletable_response_ids_.empty()) {
      storage_->DeleteResponses(manifest_url_, newly_deletable_response_ids_);
      newly_deletable_response_ids_.clear();
    }
  }
}
",1
Detect whether the following code contains vulnerabilities.,"const base::FilePath& DriveFsHost::GetMountPath() const {
  DCHECK(IsMounted());
  return mount_state_->mount_path();
}
",0
Detect whether the following code contains vulnerabilities.,"NetworkThrottleManagerImpl::NetworkThrottleManagerImpl()
     : lifetime_median_estimate_(PercentileEstimator::kMedianPercentile,
                                 kInitialMedianInMs),
       outstanding_recomputation_timer_(
          base::MakeUnique<base::Timer>(false /* retain_user_task */,
                                         false /* is_repeating */)),
       tick_clock_(new base::DefaultTickClock()),
       weak_ptr_factory_(this) {}
",1
Detect whether the following code contains vulnerabilities.,"ossl_cipher_initialize(VALUE self, VALUE str)
{
     EVP_CIPHER_CTX *ctx;
     const EVP_CIPHER *cipher;
     char *name;
    unsigned char dummy_key[EVP_MAX_KEY_LENGTH] = { 0 };
 
     name = StringValueCStr(str);
     GetCipherInit(self, ctx);
    if (ctx) {
	ossl_raise(rb_eRuntimeError, ""Cipher already inititalized!"");
    }
    AllocCipher(self, ctx);
     if (!(cipher = EVP_get_cipherbyname(name))) {
 	ossl_raise(rb_eRuntimeError, ""unsupported cipher algorithm (%""PRIsVALUE"")"", str);
     }
    /*
     * EVP_CipherInit_ex() allows to specify NULL to key and IV, however some
     * ciphers don't handle well (OpenSSL's bug). [Bug #2768]
     *
     * The EVP which has EVP_CIPH_RAND_KEY flag (such as DES3) allows
     * uninitialized key, but other EVPs (such as AES) does not allow it.
     * Calling EVP_CipherUpdate() without initializing key causes SEGV so we
     * set the data filled with ""\0"" as the key by default.
     */
    if (EVP_CipherInit_ex(ctx, cipher, NULL, dummy_key, NULL, -1) != 1)
 	ossl_raise(eCipherError, NULL);
 
     return self;
}
",1
Detect whether the following code contains vulnerabilities.,"void MockWebRTCPeerConnectionHandler::setRemoteDescription(const WebRTCVoidRequest& request, const WebRTCSessionDescriptionDescriptor& remoteDescription)
{
    if (!remoteDescription.isNull() && remoteDescription.type() == ""answer"") {
        m_remoteDescription = remoteDescription;
        postTask(new RTCVoidRequestTask(this, request, true));
     } else
        postTask(new RTCVoidRequestTask(this, request, false));
}
",1
Detect whether the following code contains vulnerabilities.,"static bool is_valid(const char *test_name) {
 for (size_t i = 0; i < sanity_suite_size; ++i) {
 if (!strcmp(test_name, sanity_suite[i].function_name)) {
 return true;
 }
 }
 for (size_t i = 0; i < test_suite_size; ++i) {
 if (!strcmp(test_name, test_suite[i].function_name)) {
 return true;
 }
 }
 return false;
}
",0
Detect whether the following code contains vulnerabilities.,"void RenderBox::paintRootBoxFillLayers(const PaintInfo& paintInfo)
{
    if (paintInfo.skipRootBackground())
        return;

    RenderObject* rootBackgroundRenderer = rendererForRootBackground();

    const FillLayer* bgLayer = rootBackgroundRenderer->style()->backgroundLayers();
    Color bgColor = rootBackgroundRenderer->resolveColor(CSSPropertyBackgroundColor);

    paintFillLayers(paintInfo, bgColor, bgLayer, view()->backgroundRect(this), BackgroundBleedNone, CompositeSourceOver, rootBackgroundRenderer);
}
",0
Detect whether the following code contains vulnerabilities.,"bool RenderFrameImpl::ShouldDisplayErrorPageForFailedLoad(
    int error_code,
    const GURL& unreachable_url) {
  if (error_code == net::ERR_ABORTED)
    return false;

  if (error_code == net::ERR_BLOCKED_BY_CLIENT &&
      render_view_->renderer_preferences_.disable_client_blocked_error_page) {
    return false;
  }

  if (GetContentClient()->renderer()->ShouldSuppressErrorPage(
          this, unreachable_url)) {
    return false;
  }

  if (RenderThreadImpl::current() &&
      RenderThreadImpl::current()->layout_test_mode()) {
    return false;
  }

  return true;
}
",0
Detect whether the following code contains vulnerabilities.,"void SkiaOutputSurfaceImplTest::UnblockMainThread() {
  DCHECK(!wait_.IsSignaled());
  wait_.Signal();
}
",0
Detect whether the following code contains vulnerabilities.,"void ExtensionTtsController::Stop() {
  if (current_utterance_ && !current_utterance_->extension_id().empty()) {
    current_utterance_->profile()->GetExtensionEventRouter()->
        DispatchEventToExtension(
            current_utterance_->extension_id(),
            events::kOnStop,
            ""[]"",
            current_utterance_->profile(),
            GURL());
  } else {
    GetPlatformImpl()->clear_error();
    GetPlatformImpl()->StopSpeaking();
   }
 
  if (current_utterance_)
    current_utterance_->set_error(kSpeechInterruptedError);
  FinishCurrentUtterance();
  ClearUtteranceQueue();
}
",1
Detect whether the following code contains vulnerabilities.,"static int save_avio_options(AVFormatContext *s)
{
    HLSContext *c = s->priv_data;
    static const char *opts[] = {
        ""headers"", ""http_proxy"", ""user_agent"", ""user-agent"", ""cookies"", NULL };
    const char **opt = opts;
    uint8_t *buf;
    int ret = 0;

    while (*opt) {
        if (av_opt_get(s->pb, *opt, AV_OPT_SEARCH_CHILDREN | AV_OPT_ALLOW_NULL, &buf) >= 0) {
            ret = av_dict_set(&c->avio_opts, *opt, buf,
                              AV_DICT_DONT_STRDUP_VAL);
            if (ret < 0)
                return ret;
        }
        opt++;
    }

    return ret;
}
",0
Detect whether the following code contains vulnerabilities.,"static void save_text_if_changed(const char *name, const char *new_value)
{
    /* a text value can't be change if the file is not loaded */
    /* returns NULL if the name is not found; otherwise nonzero */
    if (!g_hash_table_lookup(g_loaded_texts, name))
        return;

    const char *old_value = g_cd ? problem_data_get_content_or_NULL(g_cd, name) : """";
    if (!old_value)
        old_value = """";
    if (strcmp(new_value, old_value) != 0)
    {
        struct dump_dir *dd = wizard_open_directory_for_writing(g_dump_dir_name);
        if (dd)
            dd_save_text(dd, name, new_value);
 
         dd_close(dd);
        problem_data_reload_from_dump_dir();
        update_gui_state_from_problem_data(/* don't update selected event */ 0);
     }
 }
",1
Detect whether the following code contains vulnerabilities.," TemplateURLRef::SearchTermsArgs::ContextualSearchParams::ContextualSearchParams(
     int version,
     const std::string& selection,
     const std::string& base_page_url,
    int now_on_tap_version)
     : version(version),
       start(base::string16::npos),
       end(base::string16::npos),
       selection(selection),
       base_page_url(base_page_url),
      now_on_tap_version(now_on_tap_version) {}
",1
Detect whether the following code contains vulnerabilities.,"bool ChromotingInstance::Init(uint32_t argc,
                              const char* argn[],
                              const char* argv[]) {
  CHECK(!initialized_);
  initialized_ = true;

  VLOG(1) << ""Started ChromotingInstance::Init"";

  if (!media::IsMediaLibraryInitialized()) {
    LOG(ERROR) << ""Media library not initialized."";
     return false;
   }
 
  net::EnableSSLServerSockets();

  context_.Start();

  scoped_refptr<FrameConsumerProxy> consumer_proxy =
      new FrameConsumerProxy(plugin_task_runner_);
  rectangle_decoder_ = new RectangleUpdateDecoder(context_.main_task_runner(),
                                                  context_.decode_task_runner(),
                                                  consumer_proxy);
  view_.reset(new PepperView(this, &context_, rectangle_decoder_.get()));
  consumer_proxy->Attach(view_->AsWeakPtr());

  return true;
}
",1
Detect whether the following code contains vulnerabilities.,"void br_netfilter_rtable_init(struct net_bridge *br)
{
	struct rtable *rt = &br->fake_rtable;

	atomic_set(&rt->dst.__refcnt, 1);
	rt->dst.dev = br->dev;
	rt->dst.path = &rt->dst;
	dst_metric_set(&rt->dst, RTAX_MTU, 1500);
	rt->dst.flags	= DST_NOXFRM;
	rt->dst.ops = &fake_dst_ops;
}
",0
Detect whether the following code contains vulnerabilities.," bool Extension::HasAPIPermission(const std::string& function_name) const {
   base::AutoLock auto_lock(runtime_data_lock_);
   return runtime_data_.GetActivePermissions()->
      HasAccessToFunction(function_name);
 }
",1
Detect whether the following code contains vulnerabilities.,"GpuChannelHost* RenderThreadImpl::EstablishGpuChannelSync(
    content::CauseForGpuLaunch cause_for_gpu_launch) {
  if (gpu_channel_.get()) {
    if (gpu_channel_->state() == GpuChannelHost::kUnconnected ||
        gpu_channel_->state() == GpuChannelHost::kConnected)
      return GetGpuChannel();

    gpu_channel_ = NULL;
  }

   int client_id = 0;
   IPC::ChannelHandle channel_handle;
  base::ProcessHandle renderer_process_for_gpu;
   content::GPUInfo gpu_info;
   if (!Send(new GpuHostMsg_EstablishGpuChannel(cause_for_gpu_launch,
                                                &client_id,
                                                &channel_handle,
                                               &renderer_process_for_gpu,
                                                &gpu_info)) ||
      channel_handle.name.empty() ||
 #if defined(OS_POSIX)
       channel_handle.socket.fd == -1 ||
 #endif
      renderer_process_for_gpu == base::kNullProcessHandle) {
     gpu_channel_ = NULL;
     return NULL;
  }

  gpu_channel_ = new GpuChannelHost(this, 0, client_id);
  gpu_channel_->set_gpu_info(gpu_info);
   content::GetContentClient()->SetGpuInfo(gpu_info);
 
  gpu_channel_->Connect(channel_handle, renderer_process_for_gpu);
 
   return GetGpuChannel();
 }
",1
Detect whether the following code contains vulnerabilities.,"static Mutex& threadSetMutex()
{
    AtomicallyInitializedStaticReference(Mutex, mutex, new Mutex);
    return mutex;
}
",0
Detect whether the following code contains vulnerabilities.,"static void iwjpeg_scan_exif(struct iwjpegrcontext *rctx,
		const iw_byte *d, size_t d_len)
{
	struct iw_exif_state e;
	iw_uint32 ifd;

	if(d_len<8) return;

	iw_zeromem(&e,sizeof(struct iw_exif_state));
	e.d = d;
	e.d_len = d_len;
 
 	e.endian = d[0]=='I' ? IW_ENDIAN_LITTLE : IW_ENDIAN_BIG;
 
	ifd = iw_get_ui32_e(&d[4],e.endian);
 
 	iwjpeg_scan_exif_ifd(rctx,&e,ifd);
 }
",1
Detect whether the following code contains vulnerabilities.,"HTMLAllCollection* Document::all() {
  return EnsureCachedCollection<HTMLAllCollection>(kDocAll);
}
",0
Detect whether the following code contains vulnerabilities.,"v8::Handle<v8::Value> V8XMLHttpRequest::openCallback(const v8::Arguments& args)
{
    INC_STATS(""DOM.XMLHttpRequest.open()"");
 
     if (args.Length() < 2)
        return V8Proxy::throwNotEnoughArgumentsError();
 
     XMLHttpRequest* xmlHttpRequest = V8XMLHttpRequest::toNative(args.Holder());
 
    String method = toWebCoreString(args[0]);
    String urlstring = toWebCoreString(args[1]);
    ScriptExecutionContext* context = getScriptExecutionContext();
    if (!context)
        return v8::Undefined();

    KURL url = context->completeURL(urlstring);

    ExceptionCode ec = 0;

    if (args.Length() >= 3) {
        bool async = args[2]->BooleanValue();

        if (args.Length() >= 4 && !args[3]->IsUndefined()) {
            String user = toWebCoreStringWithNullCheck(args[3]);
            
            if (args.Length() >= 5 && !args[4]->IsUndefined()) {
                String passwd = toWebCoreStringWithNullCheck(args[4]);
                xmlHttpRequest->open(method, url, async, user, passwd, ec);
            } else
                xmlHttpRequest->open(method, url, async, user, ec);
        } else
            xmlHttpRequest->open(method, url, async, ec);
    } else
        xmlHttpRequest->open(method, url, ec);

    if (ec)
        return throwError(ec, args.GetIsolate());

    return v8::Undefined();
}
",1
Detect whether the following code contains vulnerabilities.,"static v8::Handle<v8::Value> methodWithNonOptionalArgAndOptionalArgCallback(const v8::Arguments& args)
 {
     INC_STATS(""DOM.TestObj.methodWithNonOptionalArgAndOptionalArg"");
     if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
     TestObj* imp = V8TestObj::toNative(args.Holder());
     EXCEPTION_BLOCK(int, nonOpt, toInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));
     if (args.Length() <= 1) {
        imp->methodWithNonOptionalArgAndOptionalArg(nonOpt);
        return v8::Handle<v8::Value>();
    }
    EXCEPTION_BLOCK(int, opt, toInt32(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined)));
    imp->methodWithNonOptionalArgAndOptionalArg(nonOpt, opt);
    return v8::Handle<v8::Value>();
}
",1
Detect whether the following code contains vulnerabilities.,"int NaClIPCAdapter::RewrittenMessage::Read(char* dest_buffer,
                                           size_t dest_buffer_size) {
  CHECK(data_len_ >= data_read_cursor_);
  size_t bytes_to_write = std::min(dest_buffer_size,
                                   data_len_ - data_read_cursor_);
  if (bytes_to_write == 0)
    return 0;

  memcpy(dest_buffer, &data_[data_read_cursor_], bytes_to_write);
  data_read_cursor_ += bytes_to_write;
  return static_cast<int>(bytes_to_write);
}
",0
Detect whether the following code contains vulnerabilities.,"GesturePoint::GesturePoint()
     : first_touch_time_(0.0),
       last_touch_time_(0.0),
       last_tap_time_(0.0),
      velocity_calculator_(kBufferedPoints) {
 }
",1
Detect whether the following code contains vulnerabilities.,"void FileSystemOperation::GetUsageAndQuotaThenRunTask(
    const GURL& origin, FileSystemType type,
    const base::Closure& task,
    const base::Closure& error_callback) {
  quota::QuotaManagerProxy* quota_manager_proxy =
      file_system_context()->quota_manager_proxy();
  if (!quota_manager_proxy ||
      !file_system_context()->GetQuotaUtil(type)) {
    operation_context_.set_allowed_bytes_growth(kint64max);
    task.Run();
    return;
  }

  TaskParamsForDidGetQuota params;
  params.origin = origin;
  params.type = type;
  params.task = task;
  params.error_callback = error_callback;

  DCHECK(quota_manager_proxy);
  DCHECK(quota_manager_proxy->quota_manager());
  quota_manager_proxy->quota_manager()->GetUsageAndQuota(
       origin,
       FileSystemTypeToQuotaStorageType(type),
       base::Bind(&FileSystemOperation::DidGetUsageAndQuotaAndRunTask,
                 base::Unretained(this), params));
 }
",1
Detect whether the following code contains vulnerabilities.,"aodv_extension(netdissect_options *ndo,
               const struct aodv_ext *ep, u_int length)
 {
 	const struct aodv_hello *ah;
 
 	switch (ep->type) {
 	case AODV_EXT_HELLO:
 		ah = (const struct aodv_hello *)(const void *)ep;
 		ND_TCHECK(*ah);
 		if (length < sizeof(struct aodv_hello))
 			goto trunc;
 		ND_PRINT((ndo, ""\n\text HELLO %ld ms"",
 		    (unsigned long)EXTRACT_32BITS(&ah->interval)));
 		break;

	default:
		ND_PRINT((ndo, ""\n\text %u %u"", ep->type, ep->length));
		break;
	}
	return;

trunc:
	ND_PRINT((ndo, "" [|hello]""));
}
",1
Detect whether the following code contains vulnerabilities.," bool AudioHandler::VerifyMixerConnection() {
  PulseAudioMixer::State mixer_state = mixer_->CheckState();
  if (mixer_state == PulseAudioMixer::READY)
     return true;
   if (connected_) {
     connected_ = false;
    LOG(ERROR) << ""Lost connection to PulseAudio"";
   } else {
     LOG(ERROR) << ""Mixer not valid"";
   }
 
  if ((mixer_state == PulseAudioMixer::INITIALIZING) ||
      (mixer_state == PulseAudioMixer::SHUTTING_DOWN))
     return false;
 
   if (reconnect_tries_ < kMaxReconnectTries) {
     reconnect_tries_++;
    VLOG(1) << ""Re-connecting to PulseAudio attempt "" << reconnect_tries_ << ""/""
             << kMaxReconnectTries;
    mixer_.reset(new PulseAudioMixer());
    connected_ = mixer_->InitSync();
     if (connected_) {
       reconnect_tries_ = 0;
       return true;
     }
    LOG(ERROR) << ""Unable to re-connect to PulseAudio"";
   }
   return false;
 }
",1
Detect whether the following code contains vulnerabilities.,"parse_field(netdissect_options *ndo, const char **pptr, int *len)
 {
     const char *s;
 
    if (*len <= 0 || !pptr || !*pptr)
	return NULL;
    if (*pptr > (const char *) ndo->ndo_snapend)
	return NULL;
     s = *pptr;
    while (*pptr <= (const char *) ndo->ndo_snapend && *len >= 0 && **pptr) {
 	(*pptr)++;
 	(*len)--;
     }
     (*pptr)++;
     (*len)--;
    if (*len < 0 || *pptr > (const char *) ndo->ndo_snapend)
	return NULL;
     return s;
 }
",1
Detect whether the following code contains vulnerabilities.,"static int entersafe_process_fci(struct sc_card *card, struct sc_file *file,
						  const u8 *buf, size_t buflen)
{
	 int r;

	 assert(file);
	 SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);

	 r = iso_ops->process_fci(card,file,buf,buflen);
	 SC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, ""Process fci failed"");

	 if(file->namelen)
	 {
		  file->type = SC_FILE_TYPE_DF;
		  file->ef_structure = SC_FILE_EF_UNKNOWN;
	 }
	 else
	 {
		  file->type = SC_FILE_TYPE_WORKING_EF;
		  file->ef_structure = SC_FILE_EF_TRANSPARENT;
	 }

	 SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);
}
",0
Detect whether the following code contains vulnerabilities.,"void DecoderTest::RunLoop(CompressedVideoSource *video) {
  vpx_codec_dec_cfg_t dec_cfg = {0};
  Decoder* const decoder = codec_->CreateDecoder(dec_cfg, 0);
   ASSERT_TRUE(decoder != NULL);
 
  for (video->Begin(); video->cxdata(); video->Next()) {
     PreDecodeFrameHook(*video, decoder);
    vpx_codec_err_t res_dec = decoder->DecodeFrame(video->cxdata(),
                                                   video->frame_size());
    ASSERT_EQ(VPX_CODEC_OK, res_dec) << decoder->DecodeError();
 
     DxDataIterator dec_iter = decoder->GetDxData();
     const vpx_image_t *img = NULL;


     while ((img = dec_iter.Next()))
       DecompressedFrameHook(*img, video->frame_number());
   }
   delete decoder;
 }
",1
Detect whether the following code contains vulnerabilities.," static void add_bytes_c(uint8_t *dst, uint8_t *src, int w){
     long i;
    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){
         long a = *(long*)(src+i);
         long b = *(long*)(dst+i);
         *(long*)(dst+i) = ((a&pb_7f) + (b&pb_7f)) ^ ((a^b)&pb_80);
    }
    for(; i<w; i++)
        dst[i+0] += src[i+0];
}
",1
Detect whether the following code contains vulnerabilities.,"TIFFFdOpen(int fd, const char* name, const char* mode)
{
	TIFF* tif;

	tif = TIFFClientOpen(name, mode,  ddd
	    (thandle_t) fd,
	    _tiffReadProc, _tiffWriteProc, _tiffSeekProc, _tiffCloseProc,
	    _tiffSizeProc, _tiffMapProc, _tiffUnmapProc);
	if (tif)
		tif->tif_fd = fd;
	return (tif);
}
",0
Detect whether the following code contains vulnerabilities.,"void streamFreeCG(streamCG *cg) {
    raxFreeWithCallback(cg->pel,(void(*)(void*))streamFreeNACK);
    raxFreeWithCallback(cg->consumers,(void(*)(void*))streamFreeConsumer);
    zfree(cg);
}
",0
Detect whether the following code contains vulnerabilities.,"ofproto_port_get_stp_stats(struct ofproto *ofproto, ofp_port_t ofp_port,
                           struct ofproto_port_stp_stats *s)
{
    struct ofport *ofport = ofproto_get_port(ofproto, ofp_port);
    if (!ofport) {
        VLOG_WARN_RL(&rl, ""%s: cannot get STP stats on nonexistent ""
                     ""port %""PRIu32, ofproto->name, ofp_port);
        return ENODEV;
    }

    return (ofproto->ofproto_class->get_stp_port_stats
            ? ofproto->ofproto_class->get_stp_port_stats(ofport, s)
            : EOPNOTSUPP);
}
",0
Detect whether the following code contains vulnerabilities.,"static int midi_setup_channel_pressure(struct _mdi *mdi, uint8_t channel,
                                       uint8_t pressure) {
    MIDI_EVENT_DEBUG(__FUNCTION__,channel, pressure);
    _WM_CheckEventMemoryPool(mdi);
    mdi->events[mdi->event_count].do_event = *_WM_do_channel_pressure;
    mdi->events[mdi->event_count].event_data.channel = channel;
    mdi->events[mdi->event_count].event_data.data.value = pressure;
    mdi->events[mdi->event_count].samples_to_next = 0;
    mdi->event_count++;
    return (0);
}
",0
Detect whether the following code contains vulnerabilities.,"void BrowserViewRenderer::DidDestroyCompositor(
     content::SynchronousCompositor* compositor) {
   TRACE_EVENT0(""android_webview"", ""BrowserViewRenderer::DidDestroyCompositor"");
   DCHECK(compositor_);
   compositor_ = NULL;
 }
",1
Detect whether the following code contains vulnerabilities.,"Chunk::Chunk(Container* parent, WEBP_MetaHandler* handler)
{
    this->needsRewrite = (parent) ? parent->needsRewrite : false;
    this->parent = parent;

    XMP_IO* file = handler->parent->ioRef;
    this->pos = file->Offset();

    this->tag = XIO::ReadUns32_LE(file);

    this->size = XIO::ReadUns32_LE(file);

    if ((this->pos + this->size + 8) > handler->initialFileSize) {
        XMP_Throw(""Bad RIFF chunk size"", kXMPErr_BadFileFormat);
    }

    this->data.reserve((XMP_Int32) this->size);
    this->data.assign((XMP_Int32) this->size, '\0');
    file->ReadAll((void*)this->data.data(), (XMP_Int32) this->size);

    if (this->size & 1) {
        file->Seek(1, kXMP_SeekFromCurrent);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"void InterstitialPageImpl::InterstitialPageRVHDelegateView::ShowPopupMenu(
    RenderFrameHost* render_frame_host,
    const gfx::Rect& bounds,
    int item_height,
    double item_font_size,
    int selected_item,
    const std::vector<MenuItem>& items,
    bool right_aligned,
    bool allow_multiple_selection) {
  NOTREACHED() << ""InterstitialPage does not support showing popup menus."";
}
",0
Detect whether the following code contains vulnerabilities.,"static int rle_patch_file_size(struct iwbmpwcontext *wctx,size_t rlesize)
{
	iw_byte buf[4];
	size_t fileheader_size;
	int ret;

	if(!wctx->iodescr->seek_fn) {
		iw_set_error(wctx->ctx,""Writing compressed BMP requires a seek function"");
		return 0;
	}

	if(wctx->include_file_header) {
		ret=(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,2,SEEK_SET);
		if(!ret) return 0;
		iw_set_ui32le(buf,(unsigned int)(14+wctx->header_size+wctx->bitfields_size+wctx->palsize+rlesize));
		iwbmp_write(wctx,buf,4);
		fileheader_size = 14;
	}
	else {
		fileheader_size = 0;
	}

	ret=(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,fileheader_size+20,SEEK_SET);
	if(!ret) return 0;
	iw_set_ui32le(buf,(unsigned int)rlesize);
	iwbmp_write(wctx,buf,4);

	(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,0,SEEK_END);
	return 1;
}
",0
Detect whether the following code contains vulnerabilities.,"static int parse_sliteral(char **c, char **dst)
{
	struct token t;
	char *s = *c;

	get_token(c, &t, L_SLITERAL);

	if (t.type != T_STRING) {
		printf(""Expected string literal: %.*s\n"", (int)(*c - s), s);
		return -EINVAL;
	}

	*dst = t.val;

	return 1;
}
",0
Detect whether the following code contains vulnerabilities.,"des3_encrypt_ecb(const unsigned char *key, int keysize,
		const unsigned char *input, int length, unsigned char *output)
{
	unsigned char iv[EVP_MAX_IV_LENGTH] = { 0 };
	unsigned char bKey[24] = { 0 };

	if (keysize == 16) {
		memcpy(&bKey[0], key, 16);
		memcpy(&bKey[16], key, 8);
	}
	else {
		memcpy(&bKey[0], key, 24);
	}

	return openssl_enc(EVP_des_ede3(), bKey, iv, input, length, output);
}
",0
Detect whether the following code contains vulnerabilities.,"GooString *JBIG2Stream::getPSFilter(int psLevel, char *indent) {
  return NULL;
}
",0
Detect whether the following code contains vulnerabilities.,"void WorkerProcessLauncher::Core::Send(IPC::Message* message) {
  DCHECK(caller_task_runner_->BelongsToCurrentThread());

  if (ipc_enabled_) {
    launcher_delegate_->Send(message);
  } else {
    delete message;
  }
}
",0
Detect whether the following code contains vulnerabilities.,"void ChromeInvalidationClient::ReissueRegistrations(
    invalidation::InvalidationClient* client,
     const std::string& prefix,
     int prefix_length) {
   DCHECK(CalledOnValidThread());
   DVLOG(1) << ""AllRegistrationsLost"";
   registration_manager_->MarkAllRegistrationsLost();
 }
",1
Detect whether the following code contains vulnerabilities.," static void prefetch_enc(void)
 {
  prefetch_table((const void *)encT, sizeof(encT));
 }
",1
Detect whether the following code contains vulnerabilities.,"extern ""C"" void RIL_setcallbacks (const RIL_RadioFunctions *callbacks) {
    memcpy(&s_callbacks, callbacks, sizeof (RIL_RadioFunctions));
}
",0
Detect whether the following code contains vulnerabilities.,"void Vp9Parser::ReadSegmentation() {
  segmentation_.update_map = false;
  segmentation_.update_data = false;
 
  segmentation_.enabled = reader_.ReadBool();
  if (!segmentation_.enabled)
     return;
 
  segmentation_.update_map = reader_.ReadBool();
  if (segmentation_.update_map)
    ReadSegmentationMap();
 
  segmentation_.update_data = reader_.ReadBool();
  if (segmentation_.update_data)
    ReadSegmentationData();
 }
",1
Detect whether the following code contains vulnerabilities.,"std::wstring DetermineChannel(const InstallConstants& mode,
                              bool system_level,
                              bool from_binaries,
                              std::wstring* update_ap,
                              std::wstring* update_cohort_name) {
  if (!kUseGoogleUpdateIntegration)
    return std::wstring();

  std::wstring client_state(from_binaries
                                ? GetBinariesClientStateKeyPath()
                                : GetClientStateKeyPath(mode.app_guid));
  std::wstring ap_value;
  nt::QueryRegValueSZ(system_level ? nt::HKLM : nt::HKCU, nt::WOW6432,
                      client_state.c_str(), kRegValueAp, &ap_value);
  if (update_ap)
    *update_ap = ap_value;

  if (update_cohort_name) {
    nt::QueryRegValueSZ(system_level ? nt::HKLM : nt::HKCU, nt::WOW6432,
                        client_state.append(L""\\cohort"").c_str(), kRegValueName,
                        update_cohort_name);
  }

  switch (mode.channel_strategy) {
    case ChannelStrategy::UNSUPPORTED:
      assert(false);
      break;
    case ChannelStrategy::ADDITIONAL_PARAMETERS:
      return ChannelFromAdditionalParameters(mode, ap_value);
    case ChannelStrategy::FIXED:
      return mode.default_channel_name;
  }

  return std::wstring();
}
",0
Detect whether the following code contains vulnerabilities.," void AppShortcutManager::OnceOffCreateShortcuts() {
  bool was_enabled = prefs_->GetBoolean(prefs::kAppShortcutsHaveBeenCreated);
#if defined(OS_MACOSX)
  bool is_now_enabled = apps::IsAppShimsEnabled();
#else
  bool is_now_enabled = true;
#endif  // defined(OS_MACOSX)
  if (was_enabled != is_now_enabled)
    prefs_->SetBoolean(prefs::kAppShortcutsHaveBeenCreated, is_now_enabled);
  if (was_enabled || !is_now_enabled)
     return;
 
   extensions::ExtensionSystem* extension_system;
  ExtensionServiceInterface* extension_service;
  if (!(extension_system = extensions::ExtensionSystem::Get(profile_)) ||
      !(extension_service = extension_system->extension_service()))
    return;

  const extensions::ExtensionSet* apps = extension_service->extensions();
  for (extensions::ExtensionSet::const_iterator it = apps->begin();
       it != apps->end(); ++it) {
    if (ShouldCreateShortcutFor(profile_, it->get()))
      CreateShortcutsInApplicationsMenu(profile_, it->get());
  }
}
",1
Detect whether the following code contains vulnerabilities.,"void PreconnectManager::Start(const GURL& url,
                              std::vector<PreconnectRequest> requests) {
  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
  const std::string host = url.host();
  if (preresolve_info_.find(host) != preresolve_info_.end())
    return;

  auto iterator_and_whether_inserted = preresolve_info_.emplace(
      host, std::make_unique<PreresolveInfo>(url, requests.size()));
  PreresolveInfo* info = iterator_and_whether_inserted.first->second.get();
 
   for (auto request_it = requests.begin(); request_it != requests.end();
        ++request_it) {
    DCHECK(request_it->origin.GetOrigin() == request_it->origin);
     PreresolveJobId job_id = preresolve_jobs_.Add(
         std::make_unique<PreresolveJob>(std::move(*request_it), info));
     queued_jobs_.push_back(job_id);
  }

  TryToLaunchPreresolveJobs();
}
",1
Detect whether the following code contains vulnerabilities.,"void VideoCaptureImpl::OnBufferCreated(int32_t buffer_id,
                                       mojo::ScopedSharedBufferHandle handle) {
  DVLOG(1) << __func__ << "" buffer_id: "" << buffer_id;
  DCHECK(io_thread_checker_.CalledOnValidThread());
  DCHECK(handle.is_valid());
 
   base::SharedMemoryHandle memory_handle;
   size_t memory_size = 0;
  bool read_only_flag = false;
 
   const MojoResult result = mojo::UnwrapSharedMemoryHandle(
      std::move(handle), &memory_handle, &memory_size, &read_only_flag);
   DCHECK_EQ(MOJO_RESULT_OK, result);
   DCHECK_GT(memory_size, 0u);
 
   std::unique_ptr<base::SharedMemory> shm(
       new base::SharedMemory(memory_handle, true /* read_only */));
   if (!shm->Map(memory_size)) {
    DLOG(ERROR) << ""OnBufferCreated: Map failed."";
    return;
  }
  const bool inserted =
      client_buffers_
          .insert(std::make_pair(buffer_id,
                                 new ClientBuffer(std::move(shm), memory_size)))
          .second;
  DCHECK(inserted);
}
",1
Detect whether the following code contains vulnerabilities.,"  void CallbackAndDie(bool succeeded) {
    v8::Isolate* isolate = context_->isolate();
    v8::HandleScope handle_scope(isolate);
    v8::Local<v8::Value> args[] = {v8::Boolean::New(isolate, succeeded)};
    context_->CallFunction(v8::Local<v8::Function>::New(isolate, callback_),
                           arraysize(args), args);
     delete this;
   }
",1
Detect whether the following code contains vulnerabilities.," void TextTrack::addCue(TextTrackCue* cue) {
   DCHECK(cue);
 
  if (std::isnan(cue->startTime()) || std::isnan(cue->endTime()) ||
      cue->startTime() < 0 || cue->endTime() < 0)
     return;
 



  if (TextTrack* cue_track = cue->track())
    cue_track->removeCue(cue, ASSERT_NO_EXCEPTION);

  cue->SetTrack(this);
  EnsureTextTrackCueList()->Add(cue);

  if (GetCueTimeline() && mode_ != DisabledKeyword())
    GetCueTimeline()->AddCue(this, cue);
}
",1
Detect whether the following code contains vulnerabilities.," static void locationWithCallWithAttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)
 {
     TestObjectPython* proxyImp = V8TestObjectPython::toNative(info.Holder());
    TestNode* imp = WTF::getPtr(proxyImp->locationWithCallWith());
     if (!imp)
         return;
     V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, cppValue, jsValue);
    imp->setHrefCallWith(callingDOMWindow(info.GetIsolate()), enteredDOMWindow(info.GetIsolate()), cppValue);
}
",1
Detect whether the following code contains vulnerabilities.,"void AutocompleteProvider::AddProviderInfo(
    ProvidersInfo* provider_info) const {
}
",1
Detect whether the following code contains vulnerabilities.,"static void TestObjectConstructorGetter(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Value> data = info.Data();
    ASSERT(data->IsExternal());
    V8PerContextData* perContextData = V8PerContextData::from(info.Holder()->CreationContext());
    if (!perContextData)
        return;
    v8SetReturnValue(info, perContextData->constructorForType(WrapperTypeInfo::unwrap(data)));
}
",0
Detect whether the following code contains vulnerabilities.,"void vsock_enqueue_accept(struct sock *listener, struct sock *connected)
{
	struct vsock_sock *vlistener;
	struct vsock_sock *vconnected;

	vlistener = vsock_sk(listener);
	vconnected = vsock_sk(connected);

	sock_hold(connected);
	sock_hold(listener);
	list_add_tail(&vconnected->accept_queue, &vlistener->accept_queue);
}
",0
Detect whether the following code contains vulnerabilities.,"store_current_palette(png_store *ps, int *npalette)
{
 /* This is an internal error (the call has been made outside a read

     * operation.)
     */
    if (ps->current == NULL)
       store_log(ps, ps->pread, ""no current stream for palette"", 1);
 
    /* The result may be null if there is no palette. */
    *npalette = ps->current->npalette;
 return ps->current->palette;
}
",1
Detect whether the following code contains vulnerabilities.,"    StateBase* writeBlob(v8::Handle<v8::Value> value, StateBase* next)
    {
        Blob* blob = V8Blob::toNative(value.As<v8::Object>());
        if (!blob)
            return 0;
         if (blob->hasBeenClosed())
             return handleError(DataCloneError, ""A Blob object has been closed, and could therefore not be cloned."", next);
         int blobIndex = -1;
        m_blobDataHandles.add(blob->uuid(), blob->blobDataHandle());
         if (appendBlobInfo(blob->uuid(), blob->type(), blob->size(), &blobIndex))
             m_writer.writeBlobIndex(blobIndex);
         else
            m_writer.writeBlob(blob->uuid(), blob->type(), blob->size());
        return 0;
    }
",1
Detect whether the following code contains vulnerabilities.,"static void ept_set_mmio_spte_mask(void)
{
	/*
	 * EPT Misconfigurations can be generated if the value of bits 2:0
	 * of an EPT paging-structure entry is 110b (write/execute).
	 * Also, magic bits (0x3ull << 62) is set to quickly identify mmio
	 * spte.
	 */
	kvm_mmu_set_mmio_spte_mask((0x3ull << 62) | 0x6ull);
}
",0
Detect whether the following code contains vulnerabilities.," static int ohci_bus_start(OHCIState *ohci)
 {
    ohci->eof_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,
                    ohci_frame_boundary,
                    ohci);
    if (ohci->eof_timer == NULL) {
        trace_usb_ohci_bus_eof_timer_failed(ohci->name);
        ohci_die(ohci);
        return 0;
    }
     trace_usb_ohci_start(ohci->name);
 
     /* Delay the first SOF event by one frame time as

    if (ohci->eof_timer == NULL) {
        trace_usb_ohci_bus_eof_timer_failed(ohci->name);
        ohci_die(ohci);
        return 0;
    }

    trace_usb_ohci_start(ohci->name);

    /* Delay the first SOF event by one frame time as
 static void ohci_bus_stop(OHCIState *ohci)
 {
     trace_usb_ohci_stop(ohci->name);
    if (ohci->eof_timer) {
        timer_del(ohci->eof_timer);
        timer_free(ohci->eof_timer);
    }
    ohci->eof_timer = NULL;
 }
 
 /* Sets a flag in a port status register but only set it if the port is
}
",1
Detect whether the following code contains vulnerabilities.,"BrowserInit::LaunchWithProfile::~LaunchWithProfile() {
}
",0
Detect whether the following code contains vulnerabilities.,"unsigned long ring_buffer_size(struct ring_buffer *buffer, int cpu)
{
	/*
	 * Earlier, this method returned
	 *	BUF_PAGE_SIZE * buffer->nr_pages
	 * Since the nr_pages field is now removed, we have converted this to
	 * return the per cpu buffer value.
	 */
	if (!cpumask_test_cpu(cpu, buffer->cpumask))
		return 0;

	return BUF_PAGE_SIZE * buffer->buffers[cpu]->nr_pages;
}
",0
Detect whether the following code contains vulnerabilities.,"CSSStyleSheet* Document::createEmptyCSSStyleSheet(
    ScriptState* script_state,
    ExceptionState& exception_state) {
  return Document::createEmptyCSSStyleSheet(
      script_state, CSSStyleSheetInit::Create(), exception_state);
}
",0
Detect whether the following code contains vulnerabilities.,"void NetworkReaderProxy::OnGetContent(scoped_ptr<std::string> data) {
   DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));
   DCHECK(data && !data->empty());
 
   pending_data_.push_back(data.release());
   if (!buffer_) {
    return;
  }

  int result = ReadInternal(&pending_data_, buffer_.get(), buffer_length_);
  remaining_content_length_ -= result;
  DCHECK_GE(remaining_content_length_, 0);

  buffer_ = NULL;
  buffer_length_ = 0;
  DCHECK(!callback_.is_null());
  base::ResetAndReturn(&callback_).Run(result);
}
",1
Detect whether the following code contains vulnerabilities.,"int Browser::GetContentRestrictionsForSelectedTab() {
  int content_restrictions = 0;
  TabContents* current_tab = GetSelectedTabContents();
  if (current_tab) {
    content_restrictions = current_tab->content_restrictions();
    NavigationEntry* active_entry = current_tab->controller().GetActiveEntry();
    if (!SavePackage::IsSavableURL(active_entry ? active_entry->url() : GURL()))
      content_restrictions |= CONTENT_RESTRICTION_SAVE;
  }
  return content_restrictions;
}
",0
Detect whether the following code contains vulnerabilities.,"void SplashOutputDev::clipToStrokePath(GfxState *state) {
  SplashPath *path, *path2;

  path = convertPath(state, state->getPath());
  path2 = splash->makeStrokePath(path);
  delete path;
  splash->clipToPath(path2, gFalse);
  delete path2;
}
",0
Detect whether the following code contains vulnerabilities.,"  void HandleMousePressEvent(int x, int y) {
    WebMouseEvent event(
        WebInputEvent::kMouseDown, WebFloatPoint(x, y), WebFloatPoint(x, y),
        WebPointerProperties::Button::kLeft, 0,
        WebInputEvent::Modifiers::kLeftButtonDown, CurrentTimeTicksInSeconds());
    event.SetFrameScale(1);
    GetEventHandler().HandleMousePressEvent(event);
  }
",0
Detect whether the following code contains vulnerabilities.,"bool AutofillDownloadManager::StartUploadRequest(
    const FormStructure& form,
    bool form_was_autofilled,
    const FieldTypeSet& available_field_types) {
  if (next_upload_request_ > base::Time::Now()) {
    VLOG(1) << ""AutofillDownloadManager: Upload request is throttled."";
    return false;
  }

   double upload_rate = form_was_autofilled ? GetPositiveUploadRate() :
                                              GetNegativeUploadRate();
  if (base::RandDouble() > upload_rate) {
     VLOG(1) << ""AutofillDownloadManager: Upload request is ignored."";
     return false;
  }

  std::string form_xml;
  if (!form.EncodeUploadRequest(available_field_types, form_was_autofilled,
                                &form_xml))
    return false;

  FormRequestData request_data;
  request_data.form_signatures.push_back(form.FormSignature());
  request_data.request_type = AutofillDownloadManager::REQUEST_UPLOAD;

  return StartRequest(form_xml, request_data);
}
",1
Detect whether the following code contains vulnerabilities.,"freeimage(Image *image)
{
   freebuffer(image);
   png_image_free(&image->image);

 if (image->input_file != NULL)
 {
      fclose(image->input_file);
      image->input_file = NULL;
 }

 if (image->input_memory != NULL)
 {
      free(image->input_memory);
      image->input_memory = NULL;
      image->input_memory_size = 0;
 }

 
    if (image->tmpfile_name[0] != 0 && (image->opts & KEEP_TMPFILES) == 0)
    {
      remove(image->tmpfile_name);
       image->tmpfile_name[0] = 0;
    }
 }
",1
Detect whether the following code contains vulnerabilities.,"void PDFiumEngine::GetTextRunInfo(int page_index,
                                  int start_char_index,
                                  uint32_t* out_len,
                                  double* out_font_size,
                                  pp::FloatRect* out_bounds) {
  DCHECK(PageIndexInBounds(page_index));
  return pages_[page_index]->GetTextRunInfo(start_char_index, out_len,
                                            out_font_size, out_bounds);
}
",0
Detect whether the following code contains vulnerabilities.,"void ThreadableBlobRegistry::registerBlobURL(SecurityOrigin* origin, const KURL& url, const KURL& srcURL)
 {
     if (origin && BlobURL::getOrigin(url) == ""null"")
         originMap()->add(url.string(), origin);
 
    if (isMainThread())
        blobRegistry().registerBlobURL(url, srcURL);
    else {
         OwnPtr<BlobRegistryContext> context = adoptPtr(new BlobRegistryContext(url, srcURL));
         callOnMainThread(&registerBlobURLFromTask, context.leakPtr());
     }
}
",1
Detect whether the following code contains vulnerabilities.,"bool CanRendererHandleEvent(const ui::MouseEvent* event) {
  if (event->type() == ui::ET_MOUSE_CAPTURE_CHANGED)
    return false;

#if defined(OS_WIN)
  switch (event->native_event().message) {
    case WM_XBUTTONDOWN:
    case WM_XBUTTONUP:
     case WM_XBUTTONDBLCLK:
     case WM_NCMOUSELEAVE:
     case WM_NCMOUSEMOVE:
     case WM_NCXBUTTONDOWN:
     case WM_NCXBUTTONUP:
     case WM_NCXBUTTONDBLCLK:
      return false;
    default:
      break;
  }
#endif
  return true;
}
",1
Detect whether the following code contains vulnerabilities.,"static int handle_vmptrst(struct kvm_vcpu *vcpu)
{
	unsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);
	u32 vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);
	gva_t vmcs_gva;
	struct x86_exception e;

	if (!nested_vmx_check_permission(vcpu))
		return 1;

 	if (get_vmx_mem_address(vcpu, exit_qualification,
 			vmx_instruction_info, true, &vmcs_gva))
 		return 1;
	/* ok to use *_system, as hardware has verified cpl=0 */
 	if (kvm_write_guest_virt_system(&vcpu->arch.emulate_ctxt, vmcs_gva,
 				 (void *)&to_vmx(vcpu)->nested.current_vmptr,
 				 sizeof(u64), &e)) {
		kvm_inject_page_fault(vcpu, &e);
		return 1;
	}
	nested_vmx_succeed(vcpu);
	return kvm_skip_emulated_instruction(vcpu);
}
",1
Detect whether the following code contains vulnerabilities.,"analyze_stack(int cpu, struct task_struct *task, unsigned long *stack,
	      unsigned long **stack_end, unsigned long *irq_stack,
	      unsigned *used, char **id)
{
	unsigned long addr;

	addr = ((unsigned long)stack & (~(THREAD_SIZE - 1)));
	if ((unsigned long)task_stack_page(task) == addr)
		return STACK_IS_NORMAL;

	*stack_end = in_exception_stack(cpu, (unsigned long)stack,
					used, id);
	if (*stack_end)
		return STACK_IS_EXCEPTION;

	if (!irq_stack)
		return STACK_IS_NORMAL;

	*stack_end = irq_stack;
	irq_stack = irq_stack - irq_stack_size;

	if (in_irq_stack(stack, irq_stack, *stack_end))
		return STACK_IS_IRQ;

	return STACK_IS_UNKNOWN;
}
",0
Detect whether the following code contains vulnerabilities.,"  void FireInvalidateUnknownVersion(const char* type_name) {
    const invalidation::ObjectId object_id(
        ipc::invalidation::ObjectSource::CHROME_SYNC, type_name);
    invalidation::AckHandle ack_handle(""fakedata"");
    EXPECT_CALL(mock_invalidation_client_, Acknowledge(ack_handle));
    client_.InvalidateUnknownVersion(&mock_invalidation_client_, object_id,
                                      ack_handle);
   }
",1
Detect whether the following code contains vulnerabilities.,"int udp6_seq_show(struct seq_file *seq, void *v)
{
	if (v == SEQ_START_TOKEN)
		seq_printf(seq,
			   ""  sl  ""
			   ""local_address                         ""
			   ""remote_address                        ""
			   ""st tx_queue rx_queue tr tm->when retrnsmt""
			   ""   uid  timeout inode ref pointer drops\n"");
	else
		udp6_sock_seq_show(seq, v, ((struct udp_iter_state *)seq->private)->bucket);
	return 0;
}
",0
Detect whether the following code contains vulnerabilities.,"  virtual void TabMoved(
      TabContentsWrapper* contents, int from_index, int to_index) {
    State* s = new State(contents, to_index, MOVE);
    s->src_index = from_index;
    states_.push_back(s);
  }
",0
Detect whether the following code contains vulnerabilities.,"static void put_unused_buffer(QEMUFile *f, void *pv, size_t size)
{
    static const uint8_t buf[1024];
    int block_len;

    while (size > 0) {
        block_len = MIN(sizeof(buf), size);
        size -= block_len;
        qemu_put_buffer(f, buf, block_len);
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static int arcmsr_hbaA_handle_isr(struct AdapterControlBlock *acb)
{
	uint32_t outbound_intstatus;
	struct MessageUnit_A __iomem *reg = acb->pmuA;
	outbound_intstatus = readl(&reg->outbound_intstatus) &
		acb->outbound_int_enable;
	if (!(outbound_intstatus & ARCMSR_MU_OUTBOUND_HANDLE_INT))
		return IRQ_NONE;
	do {
		writel(outbound_intstatus, &reg->outbound_intstatus);
		if (outbound_intstatus & ARCMSR_MU_OUTBOUND_DOORBELL_INT)
			arcmsr_hbaA_doorbell_isr(acb);
		if (outbound_intstatus & ARCMSR_MU_OUTBOUND_POSTQUEUE_INT)
			arcmsr_hbaA_postqueue_isr(acb);
		if (outbound_intstatus & ARCMSR_MU_OUTBOUND_MESSAGE0_INT)
			arcmsr_hbaA_message_isr(acb);
		outbound_intstatus = readl(&reg->outbound_intstatus) &
			acb->outbound_int_enable;
	} while (outbound_intstatus & (ARCMSR_MU_OUTBOUND_DOORBELL_INT
		| ARCMSR_MU_OUTBOUND_POSTQUEUE_INT
		| ARCMSR_MU_OUTBOUND_MESSAGE0_INT));
	return IRQ_HANDLED;
}
",0
Detect whether the following code contains vulnerabilities.,"static unsigned int readuint(FILE * f, int bigendian)
{
    unsigned char c1, c2, c3, c4;
    if (!fread(&c1, 1, 1, f)) {
        fprintf(stderr,
                ""\nError: fread return a number of element different from the expected.\n"");
        return 0;
    }
    if (!fread(&c2, 1, 1, f)) {
        fprintf(stderr,
                ""\nError: fread return a number of element different from the expected.\n"");
        return 0;
    }
    if (!fread(&c3, 1, 1, f)) {
        fprintf(stderr,
                ""\nError: fread return a number of element different from the expected.\n"");
        return 0;
    }
    if (!fread(&c4, 1, 1, f)) {
        fprintf(stderr,
                ""\nError: fread return a number of element different from the expected.\n"");
        return 0;
    }
    if (bigendian) {
        return (unsigned int)(c1 << 24) + (unsigned int)(c2 << 16) + (unsigned int)(
                   c3 << 8) + c4;
    } else {
        return (unsigned int)(c4 << 24) + (unsigned int)(c3 << 16) + (unsigned int)(
                   c2 << 8) + c1;
    }
}
",0
Detect whether the following code contains vulnerabilities.,"static int ssh_channelcmp(void *av, void *bv)
{
    struct ssh_channel *a = (struct ssh_channel *) av;
    struct ssh_channel *b = (struct ssh_channel *) bv;
    if (a->localid < b->localid)
	return -1;
    if (a->localid > b->localid)
	return +1;
    return 0;
}
",0
Detect whether the following code contains vulnerabilities.," void ServiceWorkerPaymentInstrument::OnPaymentAppInvoked(
     mojom::PaymentHandlerResponsePtr response) {
  DCHECK(delegate_);
   if (delegate_ != nullptr) {
     delegate_->OnInstrumentDetailsReady(response->method_name,
                                         response->stringified_details);
    delegate_ = nullptr;
  }
}
",1
Detect whether the following code contains vulnerabilities.," ServiceWorkerHandler::ServiceWorkerHandler()
     : DevToolsDomainHandler(ServiceWorker::Metainfo::domainName),
       enabled_(false),
      process_(nullptr),
       weak_factory_(this) {}
",1
Detect whether the following code contains vulnerabilities.,"int BackendImpl::CheckAllEntries() {
  int num_dirty = 0;
  int num_entries = 0;
  DCHECK(mask_ < std::numeric_limits<uint32_t>::max());
  for (unsigned int i = 0; i <= mask_; i++) {
    Addr address(data_->table[i]);
    if (!address.is_initialized())
      continue;
    for (;;) {
      scoped_refptr<EntryImpl> cache_entry;
      int ret = NewEntry(address, &cache_entry);
      if (ret) {
        STRESS_NOTREACHED();
        return ret;
      }

      if (cache_entry->dirty())
        num_dirty++;
      else if (CheckEntry(cache_entry.get()))
        num_entries++;
      else
        return ERR_INVALID_ENTRY;

      DCHECK_EQ(i, cache_entry->entry()->Data()->hash & mask_);
      address.set_value(cache_entry->GetNextAddress());
      if (!address.is_initialized())
        break;
    }
  }

  Trace(""CheckAllEntries End"");
  if (num_entries + num_dirty != data_->header.num_entries) {
    LOG(ERROR) << ""Number of entries "" << num_entries << "" "" << num_dirty <<
                  "" "" << data_->header.num_entries;
    DCHECK_LT(num_entries, data_->header.num_entries);
    return ERR_NUM_ENTRIES_MISMATCH;
  }

  return num_dirty;
}
",0
Detect whether the following code contains vulnerabilities.,"void Editor::ChangeSelectionAfterCommand(
    const SelectionInDOMTree& new_selection,
    const SetSelectionData& options) {
  if (new_selection.IsNone())
    return;

   bool selection_did_not_change_dom_position =
       new_selection == GetFrame().Selection().GetSelectionInDOMTree();
   GetFrame().Selection().SetSelection(
      SelectionInDOMTree::Builder(new_selection)
          .SetIsHandleVisible(GetFrame().Selection().IsHandleVisible())
          .Build(),
      options);
 
  if (selection_did_not_change_dom_position) {
    Client().RespondToChangedSelection(
        frame_, GetFrame().Selection().GetSelectionInDOMTree().Type());
  }
}
",1
Detect whether the following code contains vulnerabilities.,"bool isUserInteractionEventForSlider(Event* event, LayoutObject* layoutObject) {
  if (isUserInteractionEvent(event))
    return true;

  LayoutSliderItem slider = LayoutSliderItem(toLayoutSlider(layoutObject));
  if (!slider.isNull() && !slider.inDragMode())
    return false;
 
   const AtomicString& type = event->type();
   return type == EventTypeNames::mouseover ||
         type == EventTypeNames::mouseout || type == EventTypeNames::mousemove;
 }
",1
Detect whether the following code contains vulnerabilities.,"void Textfield::SetColor(SkColor value) {
  GetRenderText()->SetColor(value);
  cursor_view_.layer()->SetColor(value);
  SchedulePaint();
}
",0
Detect whether the following code contains vulnerabilities.,"static int collationMatch(const char *zColl, Index *pIndex){
  int i;
  assert( zColl!=0 );
  for(i=0; i<pIndex->nColumn; i++){
    const char *z = pIndex->azColl[i];
    assert( z!=0 || pIndex->aiColumn[i]<0 );
    if( pIndex->aiColumn[i]>=0 && 0==sqlite3StrICmp(z, zColl) ){
      return 1;
    }
  }
  return 0;
}
",0
Detect whether the following code contains vulnerabilities.,"		void CWebServer::Cmd_GetAuth(WebEmSession & session, const request& req, Json::Value &root)
		{
			root[""status""] = ""OK"";
			root[""title""] = ""GetAuth"";
			if (session.rights != -1)
			{
				root[""version""] = szAppVersion;
			}
			root[""user""] = session.username;
			root[""rights""] = session.rights;
		}
",0
Detect whether the following code contains vulnerabilities.,"static void mk_request_premature_close(int http_status, struct client_session *cs)
{
    struct session_request *sr;
    struct mk_list *sr_list = &cs->request_list;
    struct mk_list *host_list = &config->hosts;

    /*
     * If the connection is too premature, we need to allocate a temporal session_request
     * to do not break the plugins stages
     */
    if (mk_list_is_empty(sr_list) == 0) {
        sr = &cs->sr_fixed;
        memset(sr, 0, sizeof(struct session_request));
        mk_request_init(sr);
        mk_list_add(&sr->_head, &cs->request_list);
    }
    else {
        sr = mk_list_entry_first(sr_list, struct session_request, _head);
    }

    /* Raise error */
    if (http_status > 0) {
        if (!sr->host_conf) {
            sr->host_conf = mk_list_entry_first(host_list, struct host, _head);
        }
        mk_request_error(http_status, cs, sr);

        /* STAGE_40, request has ended */
        mk_plugin_stage_run(MK_PLUGIN_STAGE_40, cs->socket,
                            NULL, cs, sr);
    }

    /* STAGE_50, connection closed  and remove client_session*/
    mk_plugin_stage_run(MK_PLUGIN_STAGE_50, cs->socket, NULL, NULL, NULL);
    mk_session_remove(cs->socket);
}
",0
Detect whether the following code contains vulnerabilities.,"bool GLES2Decoder::GetServiceTextureId(uint32_t client_texture_id,
                                       uint32_t* service_texture_id) {
  return false;
}
",0
Detect whether the following code contains vulnerabilities.,"static int snd_timer_user_open(struct inode *inode, struct file *file)
{
	struct snd_timer_user *tu;
	int err;

	err = nonseekable_open(inode, file);
	if (err < 0)
		return err;

	tu = kzalloc(sizeof(*tu), GFP_KERNEL);
	if (tu == NULL)
 		return -ENOMEM;
 	spin_lock_init(&tu->qlock);
 	init_waitqueue_head(&tu->qchange_sleep);
	mutex_init(&tu->tread_sem);
 	tu->ticks = 1;
 	tu->queue_size = 128;
 	tu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),
			    GFP_KERNEL);
	if (tu->queue == NULL) {
		kfree(tu);
		return -ENOMEM;
	}
	file->private_data = tu;
	return 0;
}
",1
Detect whether the following code contains vulnerabilities.,"static int find_hole(void)
{
   unsigned x;
   int      y, z;
   for (z = -1, y = INT_MAX, x = 0; x < FP_ENTRIES; x++) {
       if (fp_cache[x].lru_count < y && fp_cache[x].lock == 0) {
          z = x;
          y = fp_cache[x].lru_count;
       }
   }

   /* decrease all */
   for (x = 0; x < FP_ENTRIES; x++) {
      if (fp_cache[x].lru_count > 3) {
         --(fp_cache[x].lru_count);
      }
   }

   /* free entry z */
   if (z >= 0 && fp_cache[z].g) {
      mp_clear(&fp_cache[z].mu);
      wc_ecc_del_point(fp_cache[z].g);
      fp_cache[z].g  = NULL;
      for (x = 0; x < (1U<<FP_LUT); x++) {
         wc_ecc_del_point(fp_cache[z].LUT[x]);
         fp_cache[z].LUT[x] = NULL;
      }
      fp_cache[z].lru_count = 0;
   }
   return z;
}
",0
Detect whether the following code contains vulnerabilities.,"static void dispatchSimAuthentication(Parcel &p, RequestInfo *pRI)
{
    RIL_SimAuthentication pf;
 int32_t  t;
 status_t status;

    memset(&pf, 0, sizeof(pf));

    status = p.readInt32(&t);
    pf.authContext = (int) t;
    pf.authData = strdupReadString(p);
    pf.aid = strdupReadString(p);

    startRequest;
    appendPrintBuf(""authContext=%s, authData=%s, aid=%s"", pf.authContext, pf.authData, pf.aid);
    closeRequest;
    printRequest(pRI->token, pRI->pCI->requestNumber);

 if (status != NO_ERROR) {
 goto invalid;
 }
    CALL_ONREQUEST(pRI->pCI->requestNumber, &pf, sizeof(pf), pRI, pRI->socket_id);

#ifdef MEMSET_FREED
    memsetString(pf.authData);
    memsetString(pf.aid);
#endif

    free(pf.authData);
    free(pf.aid);

#ifdef MEMSET_FREED
    memset(&pf, 0, sizeof(pf));
#endif

 return;
invalid:
    invalidCommandBlock(pRI);
 return;
}
",0
Detect whether the following code contains vulnerabilities.," int __glXDispSwap_CreateContext(__GLXclientState *cl, GLbyte *pc)
 {
     xGLXCreateContextReq *req = (xGLXCreateContextReq *) pc;
     __GLX_DECLARE_SWAP_VARIABLES;
 
     __GLX_SWAP_SHORT(&req->length);
     __GLX_SWAP_INT(&req->context);
     __GLX_SWAP_INT(&req->visual);
    return __glXDisp_CreateContext(cl, pc);
}
",1
Detect whether the following code contains vulnerabilities.,"long Track::GetNumber() const
{
    return m_info.number;
}
",1
Detect whether the following code contains vulnerabilities.,"static int xc2028_get_reg(struct xc2028_data *priv, u16 reg, u16 *val)
{
	unsigned char buf[2];
	unsigned char ibuf[2];

	tuner_dbg(""%s %04x called\n"", __func__, reg);

	buf[0] = reg >> 8;
	buf[1] = (unsigned char) reg;

	if (i2c_send_recv(priv, buf, 2, ibuf, 2) != 2)
		return -EIO;

	*val = (ibuf[1]) | (ibuf[0] << 8);
	return 0;
}
",0
Detect whether the following code contains vulnerabilities.," void RTCSessionDescriptionRequestImpl::requestFailed(const String& error)
 {
     if (m_errorCallback)
        m_errorCallback->handleEvent(error);
 
     clear();
 }
",1
Detect whether the following code contains vulnerabilities.,"static inline u64 __scale_tsc(u64 ratio, u64 tsc)
{
	return mul_u64_u64_shr(tsc, ratio, kvm_tsc_scaling_ratio_frac_bits);
}
",0
Detect whether the following code contains vulnerabilities.," void SyncManager::SyncInternal::OnIPAddressChangedImpl() {
   DCHECK(thread_checker_.CalledOnValidThread());
  connection_manager()->CheckServerReachable();
 }
",1
Detect whether the following code contains vulnerabilities.,"  void DidReceiveData(const char* buffer, int length, int data_offset) {
    DCHECK(channel_ != NULL);
    DCHECK_GT(length, 0);
    std::vector<char> data;
    data.resize(static_cast<size_t>(length));
    memcpy(&data.front(), buffer, length);
    scoped_refptr<PluginChannelHost> channel_ref(channel_);
    channel_->Send(new PluginMsg_DidReceiveData(instance_id_, resource_id_,
                                                data, data_offset));
  }
",0
Detect whether the following code contains vulnerabilities.,"InterstitialPageImpl::~InterstitialPageImpl() {
  frame_tree_.reset();
}
",0
Detect whether the following code contains vulnerabilities.,"static int verify_newpolicy_info(struct xfrm_userpolicy_info *p)
{
	switch (p->share) {
	case XFRM_SHARE_ANY:
	case XFRM_SHARE_SESSION:
	case XFRM_SHARE_USER:
	case XFRM_SHARE_UNIQUE:
		break;

	default:
		return -EINVAL;
	}

	switch (p->action) {
	case XFRM_POLICY_ALLOW:
	case XFRM_POLICY_BLOCK:
		break;

	default:
		return -EINVAL;
	}

	switch (p->sel.family) {
	case AF_INET:
		break;

	case AF_INET6:
#if IS_ENABLED(CONFIG_IPV6)
		break;
#else
		return  -EAFNOSUPPORT;
#endif

	default:
		return -EINVAL;
	}

	return verify_policy_dir(p->dir);
}
",0
Detect whether the following code contains vulnerabilities.,"static int setup_dev_console(const struct lxc_rootfs *rootfs,
			 const struct lxc_console *console)
{
	char path[MAXPATHLEN];
	struct stat s;
	int ret;

	ret = snprintf(path, sizeof(path), ""%s/dev/console"", rootfs->mount);
	if (ret >= sizeof(path)) {
		ERROR(""console path too long"");
		return -1;
	}

	if (access(path, F_OK)) {
		WARN(""rootfs specified but no console found at '%s'"", path);
		return 0;
	}

	if (console->master < 0) {
		INFO(""no console"");
		return 0;
	}

	if (stat(path, &s)) {
		SYSERROR(""failed to stat '%s'"", path);
		return -1;
	}

	if (chmod(console->name, s.st_mode)) {
		SYSERROR(""failed to set mode '0%o' to '%s'"",
			 s.st_mode, console->name);
 		return -1;
 	}
 
	if (mount(console->name, path, ""none"", MS_BIND, 0)) {
 		ERROR(""failed to mount '%s' on '%s'"", console->name, path);
 		return -1;
 	}

	INFO(""console has been setup"");
	return 0;
}
",1
Detect whether the following code contains vulnerabilities.," void WebPluginDelegateImpl::SendJavaScriptStream(const GURL& url,
                                                  const std::string& result,
                                                  bool success,
                                                 bool notify_needed,
                                                 intptr_t notify_data) {
  instance()->SendJavaScriptStream(url, result, success, notify_needed,
                                   notify_data);
 }
",1
Detect whether the following code contains vulnerabilities.,"inline bool is_hsr_master(struct net_device *dev)
{
	return (dev->netdev_ops->ndo_start_xmit == hsr_dev_xmit);
}
",0
Detect whether the following code contains vulnerabilities.,"static void pdf_run_v(fz_context *ctx, pdf_processor *proc, float x2, float y2, float x3, float y3)
{
	pdf_run_processor *pr = (pdf_run_processor *)proc;
	fz_curvetov(ctx, pr->path, x2, y2, x3, y3);
}
",0
Detect whether the following code contains vulnerabilities.,"static ssize_t ib_uverbs_comp_event_read(struct file *filp, char __user *buf,
					 size_t count, loff_t *pos)
{
	struct ib_uverbs_completion_event_file *comp_ev_file =
		filp->private_data;

	return ib_uverbs_event_read(&comp_ev_file->ev_queue,
				    comp_ev_file->uobj.ufile, filp,
				    buf, count, pos,
				    sizeof(struct ib_uverbs_comp_event_desc));
}
",0
Detect whether the following code contains vulnerabilities.,"FFmpegVideoDecodeEngine::FFmpegVideoDecodeEngine()
    : codec_context_(NULL),
      event_handler_(NULL),
      frame_rate_numerator_(0),
      frame_rate_denominator_(0),
      pending_input_buffers_(0),
      pending_output_buffers_(0),
      output_eos_reached_(false),
      flush_pending_(false) {
}
",0
Detect whether the following code contains vulnerabilities.,"  virtual void SetUpCommandLine(CommandLine* command_line) {
    GpuFeatureTest::SetUpCommandLine(command_line);
    command_line->AppendSwitch(switches::kEnableThreadedCompositing);
  }
",1
Detect whether the following code contains vulnerabilities.,"void ReleaseProcessIfNeeded() {
  content::UtilityThread::Get()->ReleaseProcessIfNeeded();
}
",0
Detect whether the following code contains vulnerabilities.,"void RTCPeerConnection::setRemoteDescription(PassRefPtr<RTCSessionDescription> prpSessionDescription, PassRefPtr<VoidCallback> successCallback, PassRefPtr<RTCErrorCallback> errorCallback, ExceptionCode& ec)
{
    if (m_readyState == ReadyStateClosing || m_readyState == ReadyStateClosed) {
        ec = INVALID_STATE_ERR;
        return;
    }
    RefPtr<RTCSessionDescription> sessionDescription = prpSessionDescription;
    if (!sessionDescription) {
        ec = TYPE_MISMATCH_ERR;
        return;
    }
    RefPtr<RTCVoidRequestImpl> request = RTCVoidRequestImpl::create(scriptExecutionContext(), successCallback, errorCallback);
    m_peerHandler->setRemoteDescription(request.release(), sessionDescription->descriptor());
}
",1
Detect whether the following code contains vulnerabilities.,"asmlinkage long compat_sys_recvmmsg(int fd, struct compat_mmsghdr __user *mmsg,
				    unsigned int vlen, unsigned int flags,
				    struct compat_timespec __user *timeout)
{
	int datagrams;
	struct timespec ktspec;

 	if (flags & MSG_CMSG_COMPAT)
 		return -EINVAL;
 
	if (COMPAT_USE_64BIT_TIME)
		return __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,
				      flags | MSG_CMSG_COMPAT,
				      (struct timespec *) timeout);
 	if (timeout == NULL)
 		return __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,
 				      flags | MSG_CMSG_COMPAT, NULL);
 
	if (get_compat_timespec(&ktspec, timeout))
 		return -EFAULT;
 
 	datagrams = __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,
 				   flags | MSG_CMSG_COMPAT, &ktspec);
	if (datagrams > 0 && put_compat_timespec(&ktspec, timeout))
 		datagrams = -EFAULT;
 
 	return datagrams;
}
",1
Detect whether the following code contains vulnerabilities.,"void AppControllerImpl::LaunchApp(const std::string& app_id) {
   app_service_proxy_->Launch(app_id, ui::EventFlags::EF_NONE,
                              apps::mojom::LaunchSource::kFromAppListGrid,
                              display::kDefaultDisplayId);
 }
",1
Detect whether the following code contains vulnerabilities.,"static int snd_seq_device_dev_free(struct snd_device *device)
 {
 	struct snd_seq_device *dev = device->device_data;
 
 	put_device(&dev->dev);
 	return 0;
 }
",1
Detect whether the following code contains vulnerabilities.,"static void ahci_restart(IDEDMA *dma)
{
    AHCIDevice *ad = DO_UPCAST(AHCIDevice, dma, dma);
    int i;

    for (i = 0; i < AHCI_MAX_CMDS; i++) {
        NCQTransferState *ncq_tfs = &ad->ncq_tfs[i];
        if (ncq_tfs->halt) {
            execute_ncq_command(ncq_tfs);
        }
    }
}
",0
Detect whether the following code contains vulnerabilities.,"bool  PrintWebViewHelper::PrintPreviewContext::IsFinalPageRendered() const {
  return static_cast<size_t>(current_page_index_) == pages_to_render_.size();
}
",0
Detect whether the following code contains vulnerabilities.,"void dm_lock_md_type(struct mapped_device *md)
{
	mutex_lock(&md->type_lock);
}
",0
Detect whether the following code contains vulnerabilities.,"static int hci_sock_getname(struct socket *sock, struct sockaddr *addr,
			    int *addr_len, int peer)
{
	struct sockaddr_hci *haddr = (struct sockaddr_hci *) addr;
	struct sock *sk = sock->sk;
	struct hci_dev *hdev = hci_pi(sk)->hdev;

	BT_DBG(""sock %p sk %p"", sock, sk);

	if (!hdev)
		return -EBADFD;

	lock_sock(sk);

 	*addr_len = sizeof(*haddr);
 	haddr->hci_family = AF_BLUETOOTH;
 	haddr->hci_dev    = hdev->id;
 
 	release_sock(sk);
 	return 0;
}
",1
Detect whether the following code contains vulnerabilities.,"void DraggedTabGtk::SetContainerColorMap() {
  GdkScreen* screen = gtk_widget_get_screen(container_);
  GdkColormap* colormap = gdk_screen_get_rgba_colormap(screen);

  if (!colormap)
    colormap = gdk_screen_get_rgb_colormap(screen);

  gtk_widget_set_colormap(container_, colormap);
}
",0
Detect whether the following code contains vulnerabilities.,"static u64 vmac(unsigned char m[], unsigned int mbytes,
			const unsigned char n[16], u64 *tagl,
			struct vmac_ctx_t *ctx)
{
	u64 *in_n, *out_p;
	u64 p, h;
	int i;

	in_n = ctx->__vmac_ctx.cached_nonce;
	out_p = ctx->__vmac_ctx.cached_aes;

	i = n[15] & 1;
	if ((*(u64 *)(n+8) != in_n[1]) || (*(u64 *)(n) != in_n[0])) {
		in_n[0] = *(u64 *)(n);
		in_n[1] = *(u64 *)(n+8);
		((unsigned char *)in_n)[15] &= 0xFE;
		crypto_cipher_encrypt_one(ctx->child,
			(unsigned char *)out_p, (unsigned char *)in_n);

		((unsigned char *)in_n)[15] |= (unsigned char)(1-i);
	}
	p = be64_to_cpup(out_p + i);
	h = vhash(m, mbytes, (u64 *)0, &ctx->__vmac_ctx);
	return le64_to_cpu(p + h);
}
",0
Detect whether the following code contains vulnerabilities.," void jas_matrix_divpow2(jas_matrix_t *matrix, int n)
 {
	int i;
	int j;
 	jas_seqent_t *rowstart;
	int rowstep;
 	jas_seqent_t *data;
 
 	if (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {
		assert(matrix->rows_);
		rowstep = jas_matrix_rowstep(matrix);
		for (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,
		  rowstart += rowstep) {
			for (j = matrix->numcols_, data = rowstart; j > 0; --j,
			  ++data) {
				*data = (*data >= 0) ? ((*data) >> n) :
				  (-((-(*data)) >> n));
			}
		}
	}
}
",1
Detect whether the following code contains vulnerabilities.,"bool Browser::IsPopup(const TabContents* source) const {
  return !!(type() & TYPE_POPUP);
}
",0
Detect whether the following code contains vulnerabilities.,"static int shutdown_interception(struct vcpu_svm *svm)
{
	struct kvm_run *kvm_run = svm->vcpu.run;

	/*
	 * VMCB is undefined after a SHUTDOWN intercept
	 * so reinitialize it.
	 */
	clear_page(svm->vmcb);
	init_vmcb(svm);

	kvm_run->exit_reason = KVM_EXIT_SHUTDOWN;
	return 0;
}
",0
Detect whether the following code contains vulnerabilities.,"   void AddSimpleRectChunk(TestPaintArtifact& artifact) {
    artifact
        .Chunk(TransformPaintPropertyNode::Root(),
               ClipPaintPropertyNode::Root(), EffectPaintPropertyNode::Root())
         .RectDrawing(FloatRect(100, 100, 200, 100), Color::kBlack);
   }
",1
Detect whether the following code contains vulnerabilities.,"int xt_compat_check_entry_offsets(const void *base,
 				  unsigned int target_offset,
 				  unsigned int next_offset)
 {
 	const struct compat_xt_entry_target *t;
 	const char *e = base;
 
 	if (target_offset + sizeof(*t) > next_offset)
 		return -EINVAL;
 
	t = (void *)(e + target_offset);
	if (t->u.target_size < sizeof(*t))
		return -EINVAL;

	if (target_offset + t->u.target_size > next_offset)
		return -EINVAL;

	if (strcmp(t->u.user.name, XT_STANDARD_TARGET) == 0 &&
	    target_offset + sizeof(struct compat_xt_standard_target) != next_offset)
		return -EINVAL;

	return 0;
}
",1
Detect whether the following code contains vulnerabilities.,"GahpClient::clear_pending()
{
	if ( pending_reqid ) {
		if (server->requestTable->remove(pending_reqid) == 0) {
			server->requestTable->insert(pending_reqid,NULL);
		}
	}
	pending_reqid = 0;
	if (pending_result) delete pending_result;
	pending_result = NULL;
	free(pending_command);
	pending_command = NULL;
	if (pending_args) free(pending_args);
	pending_args = NULL;
	pending_timeout = 0;
	if (pending_submitted_to_gahp) {
		server->num_pending_requests--;
	}
	pending_submitted_to_gahp = false;
	if ( pending_timeout_tid != -1 ) {
		daemonCore->Cancel_Timer(pending_timeout_tid);
		pending_timeout_tid = -1;
	}
}
",0
Detect whether the following code contains vulnerabilities.,"QQuickWebViewPrivate::~QQuickWebViewPrivate()
{
    webPageProxy->close();
}
",0
Detect whether the following code contains vulnerabilities.,"static void ep_rbtree_insert(struct eventpoll *ep, struct epitem *epi)
{
	int kcmp;
	struct rb_node **p = &ep->rbr.rb_node, *parent = NULL;
	struct epitem *epic;

	while (*p) {
		parent = *p;
		epic = rb_entry(parent, struct epitem, rbn);
		kcmp = ep_cmp_ffd(&epi->ffd, &epic->ffd);
		if (kcmp > 0)
			p = &parent->rb_right;
		else
			p = &parent->rb_left;
	}
	rb_link_node(&epi->rbn, parent, p);
	rb_insert_color(&epi->rbn, &ep->rbr);
}
",0
Detect whether the following code contains vulnerabilities.," image_transform_png_set_expand_16_add(image_transform *this,
    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
 {
    UNUSED(colour_type)
 
 this->next = *that;
 *that = this;

 /* expand_16 does something unless the bit depth is already 16. */
 return bit_depth < 16;
}
",1
Detect whether the following code contains vulnerabilities.,"const char* Track::GetLanguage() const
{
    return m_info.language;
}
",1
Detect whether the following code contains vulnerabilities.," void CheckTMPrediction() const {
 for (int p = 0; p < num_planes_; p++)
 for (int y = 0; y < block_size_; y++)
 for (int x = 0; x < block_size_; x++) {
 const int expected = ClipByte(data_ptr_[p][x - stride_]
 + data_ptr_[p][stride_ * y - 1]
 - data_ptr_[p][-1 - stride_]);
          ASSERT_EQ(expected, data_ptr_[p][y * stride_ + x]);
 }
 }
",0
Detect whether the following code contains vulnerabilities.,"void SSLClientSocketOpenSSL::OnSendComplete(int result) {
  if (next_handshake_state_ == STATE_HANDSHAKE) {
    OnHandshakeIOComplete(result);
    return;
  }

  int rv_read = ERR_IO_PENDING;
  int rv_write = ERR_IO_PENDING;
  bool network_moved;
  do {
    if (user_read_buf_.get())
      rv_read = DoPayloadRead();
    if (user_write_buf_.get())
      rv_write = DoPayloadWrite();
    network_moved = DoTransportIO();
  } while (rv_read == ERR_IO_PENDING && rv_write == ERR_IO_PENDING &&
           (user_read_buf_.get() || user_write_buf_.get()) && network_moved);

  base::WeakPtr<SSLClientSocketOpenSSL> guard(weak_factory_.GetWeakPtr());
  if (user_read_buf_.get() && rv_read != ERR_IO_PENDING)
    DoReadCallback(rv_read);

  if (!guard.get())
    return;

  if (user_write_buf_.get() && rv_write != ERR_IO_PENDING)
    DoWriteCallback(rv_write);
}
",0
Detect whether the following code contains vulnerabilities.,"void AppControllerImpl::BindRequest(mojom::AppControllerRequest request) {
   bindings_.AddBinding(this, std::move(request));
 }
",1
Detect whether the following code contains vulnerabilities.,"pgp_free_blob(pgp_blob_t *blob)
{
	if (blob) {
		if (blob->parent) {
			pgp_blob_t **p;

			/* remove blob from list of parent's children */
			for (p = &blob->parent->files; *p != NULL && *p != blob; p = &(*p)->next)
				;
			if (*p == blob)
				*p = blob->next;
		}

		sc_file_free(blob->file);
		if (blob->data)
			free(blob->data);
		free(blob);
	}
}
",0
Detect whether the following code contains vulnerabilities.,"static void rxrpc_destroy(struct key *key)
{
	rxrpc_free_token_list(key->payload.data);
}
",0
Detect whether the following code contains vulnerabilities.," void BrowserPpapiHostImpl::DeleteInstance(PP_Instance instance) {
   auto it = instance_map_.find(instance);
  DCHECK(it != instance_map_.end());
  for (auto& observer : it->second->observer_list)
    observer.OnHostDestroyed();
 
  instance_map_.erase(it);
 }
",1
Detect whether the following code contains vulnerabilities.,"static unsigned long klsi_105_status2linestate(const __u16 status)
{
	unsigned long res = 0;

	res =   ((status & KL5KUSB105A_DSR) ? TIOCM_DSR : 0)
	      | ((status & KL5KUSB105A_CTS) ? TIOCM_CTS : 0)
	      ;

	return res;
}
",0
Detect whether the following code contains vulnerabilities.,"  void SetMetrics(OomInterventionMetrics metrics) {
    metrics_ = std::make_unique<OomInterventionMetrics>();
    *metrics_ = metrics;
  }
",0
Detect whether the following code contains vulnerabilities.," void gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)
 {
 	gdImagePtr pim = 0, tim = im;
 	int interlace, BitsPerPixel;
	interlace = im->interlace;
	if (im->trueColor) {
		/* Expensive, but the only way that produces an
			acceptable result: mix down to a palette
 			based temporary image. */
 		pim = gdImageCreatePaletteFromTrueColor(im, 1, 256);
 		if (!pim) {
			return;
 		}
 		tim = pim;
 	}
	BitsPerPixel = colorstobpp(tim->colorsTotal);
	/* All set, let's do it. */
	GIFEncode(
		out, tim->sx, tim->sy, tim->interlace, 0, tim->transparent, BitsPerPixel,
		tim->red, tim->green, tim->blue, tim);
	if (pim) {
 		/* Destroy palette based temporary image. */
 		gdImageDestroy(	pim);
 	}
 }
",1
Detect whether the following code contains vulnerabilities.," e1000e_ring_empty(E1000ECore *core, const E1000E_RingInfo *r)
 {
    return core->mac[r->dh] == core->mac[r->dt];
 }
",1
Detect whether the following code contains vulnerabilities.,"static void ipgre_tap_setup(struct net_device *dev)
{

	ether_setup(dev);

	dev->netdev_ops		= &ipgre_tap_netdev_ops;
	dev->destructor 	= ipgre_dev_free;

	dev->iflink		= 0;
	dev->features		|= NETIF_F_NETNS_LOCAL;
}
",0
Detect whether the following code contains vulnerabilities.,"int tls1_set_server_sigalgs(SSL *s)
{
    int al;
    size_t i;
    /* Clear any shared sigtnature algorithms */
     if (s->cert->shared_sigalgs) {
         OPENSSL_free(s->cert->shared_sigalgs);
         s->cert->shared_sigalgs = NULL;
     }
     /* Clear certificate digests and validity flags */
     for (i = 0; i < SSL_PKEY_NUM; i++) {
        s->cert->pkeys[i].valid_flags = 0;
    }

    /* If sigalgs received process it. */
    if (s->cert->peer_sigalgs) {
        if (!tls1_process_sigalgs(s)) {
            SSLerr(SSL_F_TLS1_SET_SERVER_SIGALGS, ERR_R_MALLOC_FAILURE);
            al = SSL_AD_INTERNAL_ERROR;
            goto err;
        }
        /* Fatal error is no shared signature algorithms */
        if (!s->cert->shared_sigalgs) {
            SSLerr(SSL_F_TLS1_SET_SERVER_SIGALGS,
                   SSL_R_NO_SHARED_SIGATURE_ALGORITHMS);
            al = SSL_AD_ILLEGAL_PARAMETER;
            goto err;
        }
    } else
        ssl_cert_set_default_md(s->cert);
    return 1;
 err:
    ssl3_send_alert(s, SSL3_AL_FATAL, al);
    return 0;
}
",1
Detect whether the following code contains vulnerabilities.,"static void enforcedRangeByteAttrAttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)
{
    ExceptionState exceptionState(ExceptionState::SetterContext, ""enforcedRangeByteAttr"", ""TestObject"", info.Holder(), info.GetIsolate());
    TestObject* imp = V8TestObject::toNative(info.Holder());
    V8TRYCATCH_EXCEPTION_VOID(int, cppValue, toInt8(jsValue, EnforceRange, exceptionState), exceptionState);
    imp->setEnforcedRangeByteAttr(cppValue);
}
",0
Detect whether the following code contains vulnerabilities.,"static void lsi_bad_selection(LSIState *s, uint32_t id)
{
    trace_lsi_bad_selection(id);
    lsi_script_scsi_interrupt(s, 0, LSI_SIST1_STO);
    lsi_disconnect(s);
}
",0
Detect whether the following code contains vulnerabilities.,"void FragmentPaintPropertyTreeBuilder::UpdateFragmentClip() {
  DCHECK(properties_);

   if (NeedsPaintPropertyUpdate()) {
     if (context_.fragment_clip) {
       OnUpdateClip(properties_->UpdateFragmentClip(
          context_.current.clip,
           ClipPaintPropertyNode::State{context_.current.transform,
                                        ToClipRect(*context_.fragment_clip)}));
     } else {
      OnClearClip(properties_->ClearFragmentClip());
    }
  }

  if (properties_->FragmentClip())
    context_.current.clip = properties_->FragmentClip();
}
",1
Detect whether the following code contains vulnerabilities.," SPL_METHOD(SplFileObject, getMaxLineLen)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}

	RETURN_LONG((long)intern->u.file.max_line_len);
} /* }}} */

/* {{{ proto bool SplFileObject::hasChildren()
",1
Detect whether the following code contains vulnerabilities.,"Document* LocalDOMWindow::InstallNewDocument(const String& mime_type,
                                             const DocumentInit& init,
                                             bool force_xhtml) {
  DCHECK_EQ(init.GetFrame(), GetFrame());

  ClearDocument();

  document_ = CreateDocument(mime_type, init, force_xhtml);
  event_queue_ = DOMWindowEventQueue::Create(document_.Get());
  document_->Initialize();

  if (!GetFrame())
    return document_;

  GetFrame()->GetScriptController().UpdateDocument();
  document_->UpdateViewportDescription();

  if (GetFrame()->GetPage() && GetFrame()->View()) {
    GetFrame()->GetPage()->GetChromeClient().InstallSupplements(*GetFrame());

    if (ScrollingCoordinator* scrolling_coordinator =
            GetFrame()->GetPage()->GetScrollingCoordinator()) {
      scrolling_coordinator->ScrollableAreaScrollbarLayerDidChange(
          GetFrame()->View(), kHorizontalScrollbar);
      scrolling_coordinator->ScrollableAreaScrollbarLayerDidChange(
          GetFrame()->View(), kVerticalScrollbar);
      scrolling_coordinator->ScrollableAreaScrollLayerDidChange(
          GetFrame()->View());
     }
   }
 
  GetFrame()->Selection().UpdateSecureKeyboardEntryIfActive();
   if (GetFrame()->IsCrossOriginSubframe())
     document_->RecordDeferredLoadReason(WouldLoadReason::kCreated);
 
  return document_;
}
",1
Detect whether the following code contains vulnerabilities.,"static void svc_rdma_destroy_maps(struct svcxprt_rdma *xprt)
{
	while (!list_empty(&xprt->sc_maps)) {
		struct svc_rdma_req_map *map;
		map = list_first_entry(&xprt->sc_maps,
				       struct svc_rdma_req_map, free);
		list_del(&map->free);
		kfree(map);
	}
}
",1
Detect whether the following code contains vulnerabilities.,"void* JSArray::subclassData() const
{
    return m_storage->subclassData;
}
",0
Detect whether the following code contains vulnerabilities.,"void RenderFrameDevToolsAgentHost::InspectElement(
    DevToolsSession* session,
    int x,
    int y) {

  if (frame_tree_node_) {
    if (auto* main_view =
            frame_tree_node_->frame_tree()->GetMainFrame()->GetView()) {
      gfx::Point transformed_point = gfx::ToRoundedPoint(
          main_view->TransformRootPointToViewCoordSpace(gfx::PointF(x, y)));
      x = transformed_point.x();
      y = transformed_point.y();
    }
  }

  session->InspectElement(gfx::Point(x, y));
}
",0
Detect whether the following code contains vulnerabilities.,"void bnep_net_setup(struct net_device *dev)
{

	memset(dev->broadcast, 0xff, ETH_ALEN);
 	dev->addr_len = ETH_ALEN;
 
 	ether_setup(dev);
 	dev->netdev_ops = &bnep_netdev_ops;
 
 	dev->watchdog_timeo  = HZ * 2;
}
",1
Detect whether the following code contains vulnerabilities.,"void WorkerThread::shutdown()
{
    ASSERT(isCurrentThread());
    {
        MutexLocker lock(m_threadStateMutex);
        ASSERT(!m_shutdown);
        m_shutdown = true;
    }

    PlatformThreadData::current().threadTimers().setSharedTimer(nullptr);
    workerGlobalScope()->dispose();
    willDestroyIsolate();

    workerReportingProxy().willDestroyWorkerGlobalScope();

#if !ENABLE(OILPAN)
    ASSERT(m_workerGlobalScope->hasOneRef());
#endif
    m_workerGlobalScope->notifyContextDestroyed();
    m_workerGlobalScope = nullptr;

    backingThread().removeTaskObserver(m_microtaskRunner.get());
    backingThread().shutdown();
    destroyIsolate();

    m_microtaskRunner = nullptr;

    workerReportingProxy().workerThreadTerminated();

    m_terminationEvent->signal();

    PlatformThreadData::current().destroy();
}
",0
Detect whether the following code contains vulnerabilities.,"WebContents* TabsCaptureVisibleTabFunction::GetWebContentsForID(
    int window_id,
    std::string* error) {
  Browser* browser = NULL;
  if (!GetBrowserFromWindowID(chrome_details_, window_id, &browser, error))
    return nullptr;

  WebContents* contents = browser->tab_strip_model()->GetActiveWebContents();
  if (!contents) {
    *error = ""No active web contents to capture"";
    return nullptr;
  }
 
   if (!extension()->permissions_data()->CanCaptureVisiblePage(
           contents->GetLastCommittedURL(),
          SessionTabHelper::IdForTab(contents).id(), error)) {
     return nullptr;
   }
   return contents;
}
",1
Detect whether the following code contains vulnerabilities.,"static int mem_resize(jas_stream_memobj_t *m, int bufsize)
 {
 	unsigned char *buf;
 
	assert(bufsize >= 0);
 
	JAS_DBGLOG(100, (""mem_resize(%p, %d)\n"", m, bufsize));
 	if (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&
 	  bufsize) {
 		JAS_DBGLOG(100, (""mem_resize realloc failed\n""));
		return -1;
	}
	JAS_DBGLOG(100, (""mem_resize realloc succeeded\n""));
	m->buf_ = buf;
	m->bufsize_ = bufsize;
	return 0;
}
",1
Detect whether the following code contains vulnerabilities.,"SQLWCHAR* _multi_string_alloc_and_expand( LPCSTR in )
{
    SQLWCHAR *chr;
    int len = 0;
 
     if ( !in )
     {
        return in;
     }
     
     while ( in[ len ] != 0 || in[ len + 1 ] != 0 )
    {
        len ++;
    }

    chr = malloc(sizeof( SQLWCHAR ) * ( len + 2 ));

    len = 0;
    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )
    {
        chr[ len ] = in[ len ];
        len ++;
    }
    chr[ len ++ ] = 0;
    chr[ len ++ ] = 0;

    return chr;
}
",1
Detect whether the following code contains vulnerabilities.,"INST_HANDLER (sleep) {	// SLEEP
	ESIL_A (""BREAK"");
}
",0
Detect whether the following code contains vulnerabilities.,"  virtual void SetImePropertyActivated(const std::string& key,
                                       bool activated) {
    if (!initialized_successfully_)
       return;
 
     DCHECK(!key.empty());
    chromeos::SetImePropertyActivated(
        input_method_status_connection_, key.c_str(), activated);
   }
",1
Detect whether the following code contains vulnerabilities.,"long long BlockGroup::GetNextTimeCode() const
{
    return m_next;
}
",1
Detect whether the following code contains vulnerabilities.,"void InspectorResourceAgent::frameScheduledNavigation(Frame* frame, double)
{
    RefPtr<TypeBuilder::Network::Initiator> initiator = buildInitiatorObject(frame->document(), FetchInitiatorInfo());
    m_frameNavigationInitiatorMap.set(m_pageAgent->frameId(frame), initiator);
}
",0
Detect whether the following code contains vulnerabilities.,"_zip_cdir_new(int nentry, struct zip_error *error)
{
    struct zip_cdir *cd;
    
    if ((cd=(struct zip_cdir *)malloc(sizeof(*cd))) == NULL) {
	_zip_error_set(error, ZIP_ER_MEMORY, 0);
        return NULL;
     }
 
    if ((cd->entry=(struct zip_dirent *)malloc(sizeof(*(cd->entry))*nentry))
        == NULL) {
        _zip_error_set(error, ZIP_ER_MEMORY, 0);
        free(cd);
	return NULL;
    }

    /* entries must be initialized by caller */

    cd->nentry = nentry;
    cd->size = cd->offset = 0;
    cd->comment = NULL;
    cd->comment_len = 0;

    return cd;
}
",1
Detect whether the following code contains vulnerabilities.,"struct sctp_association *sctp_id2assoc(struct sock *sk, sctp_assoc_t id)
{
	struct sctp_association *asoc = NULL;

	/* If this is not a UDP-style socket, assoc id should be ignored. */
	if (!sctp_style(sk, UDP)) {
		/* Return NULL if the socket state is not ESTABLISHED. It
		 * could be a TCP-style listening socket or a socket which
		 * hasn't yet called connect() to establish an association.
		 */
		if (!sctp_sstate(sk, ESTABLISHED) && !sctp_sstate(sk, CLOSING))
			return NULL;

		/* Get the first and the only association from the list. */
		if (!list_empty(&sctp_sk(sk)->ep->asocs))
			asoc = list_entry(sctp_sk(sk)->ep->asocs.next,
					  struct sctp_association, asocs);
		return asoc;
	}

	/* Otherwise this is a UDP-style socket. */
	if (!id || (id == (sctp_assoc_t)-1))
		return NULL;

	spin_lock_bh(&sctp_assocs_id_lock);
	asoc = (struct sctp_association *)idr_find(&sctp_assocs_id, (int)id);
	spin_unlock_bh(&sctp_assocs_id_lock);

	if (!asoc || (asoc->base.sk != sk) || asoc->base.dead)
		return NULL;

	return asoc;
}
",0
Detect whether the following code contains vulnerabilities.,"static int proc_control_compat(struct usb_dev_state *ps,
				struct usbdevfs_ctrltransfer32 __user *p32)
{
	struct usbdevfs_ctrltransfer __user *p;
	__u32 udata;
	p = compat_alloc_user_space(sizeof(*p));
	if (copy_in_user(p, p32, (sizeof(*p32) - sizeof(compat_caddr_t))) ||
	    get_user(udata, &p32->data) ||
	    put_user(compat_ptr(udata), &p->data))
		return -EFAULT;
	return proc_control(ps, p);
}
",0
Detect whether the following code contains vulnerabilities.,"void* NPN_GetJavaEnv() {
  DLOG(INFO) << ""NPN_GetJavaEnv is not implemented."";
  return NULL;
}
",0
Detect whether the following code contains vulnerabilities.," static int hns_xgmac_get_sset_count(int stringset)
 {
	if (stringset == ETH_SS_STATS)
 		return ARRAY_SIZE(g_xgmac_stats_string);
 
 	return 0;
}
",1
Detect whether the following code contains vulnerabilities.,"PHP_FUNCTION(imagecopyresampled)
{
	zval *SIM, *DIM;
	long SX, SY, SW, SH, DX, DY, DW, DH;
	gdImagePtr im_dst, im_src;
	int srcH, srcW, dstH, dstW, srcY, srcX, dstY, dstX;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rrllllllll"", &DIM, &SIM, &DX, &DY, &SX, &SY, &DW, &DH, &SW, &SH) == FAILURE) {
		return;
	}

	ZEND_FETCH_RESOURCE(im_dst, gdImagePtr, &DIM, -1, ""Image"", le_gd);
	ZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, ""Image"", le_gd);

	srcX = SX;
	srcY = SY;
	srcH = SH;
	srcW = SW;
	dstX = DX;
	dstY = DY;
	dstH = DH;
	dstW = DW;

	gdImageCopyResampled(im_dst, im_src, dstX, dstY, srcX, srcY, dstW, dstH, srcW, srcH);

	RETURN_TRUE;
}
",0
Detect whether the following code contains vulnerabilities.," void TestingPlatformSupport::cryptographicallyRandomValues(unsigned char* buffer, size_t length)
 {
 }
",1
Detect whether the following code contains vulnerabilities.,"void FragmentPaintPropertyTreeBuilder::UpdateClipPathClip(
    bool spv1_compositing_specific_pass) {
  bool is_spv1_composited =
      object_.HasLayer() &&
      ToLayoutBoxModelObject(object_).Layer()->GetCompositedLayerMapping();
  if (is_spv1_composited != spv1_compositing_specific_pass)
    return;

  if (NeedsPaintPropertyUpdate()) {
    if (!NeedsClipPathClip(object_)) {
      OnClearClip(properties_->ClearClipPathClip());
    } else {
      ClipPaintPropertyNode::State state;
      state.local_transform_space = context_.current.transform;
       state.clip_rect =
           FloatRoundedRect(FloatRect(*fragment_data_.ClipPathBoundingBox()));
       state.clip_path = fragment_data_.ClipPathPath();
      OnUpdateClip(properties_->UpdateClipPathClip(context_.current.clip,
                                                    std::move(state)));
     }
   }

  if (properties_->ClipPathClip() && !spv1_compositing_specific_pass) {
    context_.current.clip = context_.absolute_position.clip =
        context_.fixed_position.clip = properties_->ClipPathClip();
  }
}
",1
Detect whether the following code contains vulnerabilities.,"int dns_packet_is_reply_for(DnsPacket *p, const DnsResourceKey *key) {
        int r;

        assert(p);
        assert(key);

        /* Checks if the specified packet is a reply for the specified
         * key and the specified key is the only one in the question
         * section. */

        if (DNS_PACKET_QR(p) != 1)
                return 0;

        /* Let's unpack the packet, if that hasn't happened yet. */
        r = dns_packet_extract(p);
         if (r < 0)
                 return r;
 
         if (p->question->n_keys != 1)
                 return 0;
 
        return dns_resource_key_equal(p->question->keys[0], key);
}
",1
Detect whether the following code contains vulnerabilities.,"static inline int rt_scope(int ifa_scope)
{
	if (ifa_scope & IFA_HOST)
		return RT_SCOPE_HOST;
	else if (ifa_scope & IFA_LINK)
		return RT_SCOPE_LINK;
	else if (ifa_scope & IFA_SITE)
		return RT_SCOPE_SITE;
	else
		return RT_SCOPE_UNIVERSE;
}
",0
Detect whether the following code contains vulnerabilities.,"void* ipc_alloc(int size)
 {
	void* out;
 	if(size > PAGE_SIZE)
 		out = vmalloc(size);
 	else
		out = kmalloc(size, GFP_KERNEL);
	return out;
}
",1
Detect whether the following code contains vulnerabilities.,"static void set_rx_flow_off(struct caifsock *cf_sk)
{
	 clear_bit(RX_FLOW_ON_BIT,
		 (void *) &cf_sk->flow_state);
}
",0
Detect whether the following code contains vulnerabilities.,"static void close_table_device(struct table_device *td, struct mapped_device *md)
{
	if (!td->dm_dev.bdev)
		return;

	bd_unlink_disk_holder(td->dm_dev.bdev, dm_disk(md));
	blkdev_put(td->dm_dev.bdev, td->dm_dev.mode | FMODE_EXCL);
	put_dax(td->dm_dev.dax_dev);
	td->dm_dev.bdev = NULL;
	td->dm_dev.dax_dev = NULL;
}
",0
Detect whether the following code contains vulnerabilities.," void EmbeddedWorkerContextClient::OnSendMessageToWorker(
     int thread_id,
     int embedded_worker_id,
    int request_id,
    const IPC::Message& message) {
  if (!script_context_)
    return;
  DCHECK_EQ(embedded_worker_id_, embedded_worker_id);
  script_context_->OnMessageReceived(request_id, message);
}
",0
Detect whether the following code contains vulnerabilities.,"void HeapAllocator::backingFree(void* address) {
  if (!address)
    return;

  ThreadState* state = ThreadState::current();
  if (state->sweepForbidden())
    return;
  ASSERT(!state->isInGC());

  BasePage* page = pageFromObject(address);
  if (page->isLargeObjectPage() || page->arena()->getThreadState() != state)
     return;
 
   HeapObjectHeader* header = HeapObjectHeader::fromPayload(address);
  ASSERT(header->checkHeader());
   NormalPageArena* arena = static_cast<NormalPage*>(page)->arenaForNormalPage();
   state->promptlyFreed(header->gcInfoIndex());
   arena->promptlyFreeObject(header);
}
",1
Detect whether the following code contains vulnerabilities.,"scoped_refptr<PrintBackend> PrintBackend::CreateInstance(
    const base::DictionaryValue* print_backend_settings) {
  return new PrintBackendWin;
}
",0
Detect whether the following code contains vulnerabilities.,"static void copy_asoundrc(void) {
	char *src = RUN_ASOUNDRC_FILE ;
 	char *dest;
 	if (asprintf(&dest, ""%s/.asoundrc"", cfg.homedir) == -1)
 		errExit(""asprintf"");
 	if (is_link(dest)) {
 		fprintf(stderr, ""Error: %s is a symbolic link\n"", dest);
 		exit(1);
 	}
 
	pid_t child = fork();
	if (child < 0)
		errExit(""fork"");
	if (child == 0) {
		drop_privs(0);
		int rv = copy_file(src, dest);
		if (rv)
			fprintf(stderr, ""Warning: cannot transfer .asoundrc in private home directory\n"");
		else {
			fs_logger2(""clone"", dest);
		}
		_exit(0);
	}
	waitpid(child, NULL, 0);
	if (chown(dest, getuid(), getgid()) < 0)
		errExit(""chown"");
	if (chmod(dest, S_IRUSR | S_IWUSR) < 0)
		errExit(""chmod"");
 
 	unlink(src);
}
",1
Detect whether the following code contains vulnerabilities.,"v8::Local<v8::Value> V8Debugger::generatorObjectLocation(v8::Local<v8::Object> object)
 {
     if (!enabled()) {
         NOTREACHED();
         return v8::Null(m_isolate);
     }
     v8::Local<v8::Value> argv[] = { object };
     v8::Local<v8::Value> location = callDebuggerMethod(""getGeneratorObjectLocation"", 1, argv).ToLocalChecked();
    if (!location->IsObject())
         return v8::Null(m_isolate);
    v8::Local<v8::Context> context = m_debuggerContext.Get(m_isolate);
    if (!markAsInternal(context, v8::Local<v8::Object>::Cast(location), V8InternalValueType::kLocation))
         return v8::Null(m_isolate);
    return location;
 }
",1
Detect whether the following code contains vulnerabilities.,"bool AsyncPixelTransfersCompletedQuery::End(
    base::subtle::Atomic32 submit_count) {
  AsyncMemoryParams mem_params;
  Buffer buffer = manager()->decoder()->GetSharedMemoryBuffer(shm_id());
  if (!buffer.shared_memory)
    return false;
  mem_params.shared_memory = buffer.shared_memory;
   mem_params.shm_size = buffer.size;
   mem_params.shm_data_offset = shm_offset();
   mem_params.shm_data_size = sizeof(QuerySync);
 
   observer_ = new AsyncPixelTransferCompletionObserverImpl(submit_count);
 
  manager()->decoder()->GetAsyncPixelTransferManager()
      ->AsyncNotifyCompletion(mem_params, observer_);

  return AddToPendingTransferQueue(submit_count);
}
",1
Detect whether the following code contains vulnerabilities.,"AP_DECLARE(int) ap_some_auth_required(request_rec *r)
{
    /* Is there a require line configured for the type of *this* req? */
    if (ap__authz_ap_some_auth_required) {
        return ap__authz_ap_some_auth_required(r);
    }
    else
        return 0;
}
",0
Detect whether the following code contains vulnerabilities.," PageInfoUI::IdentityInfo::IdentityInfo()
     : identity_status(PageInfo::SITE_IDENTITY_STATUS_UNKNOWN),
      safe_browsing_status(PageInfo::SAFE_BROWSING_STATUS_NONE),
       connection_status(PageInfo::SITE_CONNECTION_STATUS_UNKNOWN),
       show_ssl_decision_revoke_button(false),
       show_change_password_buttons(false) {}
",1
Detect whether the following code contains vulnerabilities.,"check_1_6_dummy(kadm5_principal_ent_t entry, long mask,
                int n_ks_tuple, krb5_key_salt_tuple *ks_tuple, char **passptr)
{
    int i;
     char *password = *passptr;
 
     /* Old-style randkey operations disallowed tickets to start. */
    if (!(mask & KADM5_ATTRIBUTES) ||
         !(entry->attributes & KRB5_KDB_DISALLOW_ALL_TIX))
         return;
 
    /* The 1.6 dummy password was the octets 1..255. */
    for (i = 0; (unsigned char) password[i] == i + 1; i++);
    if (password[i] != '\0' || i != 255)
        return;

    /* This will make the caller use a random password instead. */
    *passptr = NULL;
}
",1
Detect whether the following code contains vulnerabilities.," bool ClipboardUtil::HasFilenames(IDataObject* data_object) {
   DCHECK(data_object);
  return HasData(data_object, Clipboard::GetCFHDropFormatType());
 }
",1
Detect whether the following code contains vulnerabilities.,"R_API int r_flag_rename(RFlag *f, RFlagItem *item, const char *name) {
	if (!f || !item || !name || !*name) {
		return false;
	}
#if 0
	ut64 off = item->offset;
	int size = item->size;
	r_flag_unset (f, item);
	r_flag_set (f, name, off, size);
	return true;
#else
	ht_delete (f->ht_name, item->name);
	if (!set_name (item, name)) {
		return false;
	}
	ht_insert (f->ht_name, item->name, item);
#endif
	return true;
}
",0
Detect whether the following code contains vulnerabilities.,"  _bdf_list_join( _bdf_list_t*    list,
                  int             c,
                  unsigned long  *alen )
  {
    unsigned long  i, j;
    char           *fp, *dp;


    *alen = 0;

    if ( list == 0 || list->used == 0 )
      return 0;

    dp = list->field[0];
    for ( i = j = 0; i < list->used; i++ )
    {
      fp = list->field[i];
      while ( *fp )
        dp[j++] = *fp++;

      if ( i + 1 < list->used )
        dp[j++] = (char)c;
    }
    if ( dp != empty )
      dp[j] = 0;

    *alen = j;
    return dp;
  }
",0
Detect whether the following code contains vulnerabilities.,"  static void UpdatePropertyCallback(IBusPanelService* panel,
                                     IBusProperty* ibus_prop,
                                     gpointer user_data) {
    g_return_if_fail(user_data);
    InputMethodStatusConnection* self
        = static_cast<InputMethodStatusConnection*>(user_data);
    self->UpdateProperty(ibus_prop);
   }
",1
Detect whether the following code contains vulnerabilities.,"  void CheckMaybeActivateDataReductionProxy(bool initially_enabled,
                                            bool request_succeeded,
                                            bool expected_enabled,
                                            bool expected_restricted,
                                            bool expected_fallback_restricted) {
    test_context_->SetDataReductionProxyEnabled(initially_enabled);
    test_context_->config()->UpdateConfigForTesting(initially_enabled,
                                                    request_succeeded, true);
    ExpectSetProxyPrefs(expected_enabled, false);
     settings_->MaybeActivateDataReductionProxy(false);
     test_context_->RunUntilIdle();
   }
",0
Detect whether the following code contains vulnerabilities.,"static int __meminit __add_zone(struct zone *zone, unsigned long phys_start_pfn)
{
	struct pglist_data *pgdat = zone->zone_pgdat;
	int nr_pages = PAGES_PER_SECTION;
	int nid = pgdat->node_id;
	int zone_type;
	unsigned long flags;

	zone_type = zone - pgdat->node_zones;
	if (!zone->wait_table) {
		int ret;

		ret = init_currently_empty_zone(zone, phys_start_pfn,
						nr_pages, MEMMAP_HOTPLUG);
		if (ret)
			return ret;
	}
	pgdat_resize_lock(zone->zone_pgdat, &flags);
	grow_zone_span(zone, phys_start_pfn, phys_start_pfn + nr_pages);
	grow_pgdat_span(zone->zone_pgdat, phys_start_pfn,
			phys_start_pfn + nr_pages);
	pgdat_resize_unlock(zone->zone_pgdat, &flags);
	memmap_init_zone(nr_pages, nid, zone_type,
			 phys_start_pfn, MEMMAP_HOTPLUG);
	return 0;
}
",0
Detect whether the following code contains vulnerabilities.,"  explicit TestWindowObserver(aura::Window* window_to_observe)
      : window_(window_to_observe) {
    window_->AddObserver(this);
  }
",0
Detect whether the following code contains vulnerabilities.,"static int x509_check_wildcard( const char *cn, mbedtls_x509_buf *name )
{
    size_t i;
    size_t cn_idx = 0, cn_len = strlen( cn );

    if( name->len < 3 || name->p[0] != '*' || name->p[1] != '.' )
        return( 0 );

    for( i = 0; i < cn_len; ++i )
    {
        if( cn[i] == '.' )
        {
            cn_idx = i;
            break;
        }
    }

    if( cn_idx == 0 )
        return( -1 );

    if( cn_len - cn_idx == name->len - 1 &&
        x509_memcasecmp( name->p + 1, cn + cn_idx, name->len - 1 ) == 0 )
    {
        return( 0 );
    }

    return( -1 );
}
",0
Detect whether the following code contains vulnerabilities.," static int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)
 {
 	int start = 0;
 	u32 prev_legacy, cur_legacy;
 	mutex_lock(&kvm->arch.vpit->pit_state.lock);
 	prev_legacy = kvm->arch.vpit->pit_state.flags & KVM_PIT_FLAGS_HPET_LEGACY;
	cur_legacy = ps->flags & KVM_PIT_FLAGS_HPET_LEGACY;
	if (!prev_legacy && cur_legacy)
		start = 1;
 	memcpy(&kvm->arch.vpit->pit_state.channels, &ps->channels,
 	       sizeof(kvm->arch.vpit->pit_state.channels));
 	kvm->arch.vpit->pit_state.flags = ps->flags;
	kvm_pit_load_count(kvm, 0, kvm->arch.vpit->pit_state.channels[0].count, start);
 	mutex_unlock(&kvm->arch.vpit->pit_state.lock);
 	return 0;
 }
",1
Detect whether the following code contains vulnerabilities.," bool ChildProcessSecurityPolicyImpl::CanSetAsOriginHeader(int child_id,
                                                           const GURL& url) {
   if (!url.is_valid())
    return false;  // Can't set invalid URLs as origin headers.

  if (url == kAboutSrcDocURL)
    return false;
 
  if (CanCommitURL(child_id, url))
     return true;
 
  {
    base::AutoLock lock(lock_);
    if (base::ContainsKey(schemes_okay_to_appear_as_origin_headers_,
                          url.scheme())) {
      return true;
    }
  }
  return false;
}
",1
Detect whether the following code contains vulnerabilities.," PP_Bool LaunchSelLdr(PP_Instance instance,
                     const char* alleged_url,
                     int socket_count,
                      void* imc_handles) {
   std::vector<nacl::FileDescriptor> sockets;
   IPC::Sender* sender = content::RenderThread::Get();
   if (sender == NULL)
     sender = g_background_thread_sender.Pointer()->get();
 
  IPC::ChannelHandle channel_handle;
   if (!sender->Send(new ChromeViewHostMsg_LaunchNaCl(
          GURL(alleged_url), socket_count, &sockets,
          &channel_handle))) {
     return PP_FALSE;
  }
  bool invalid_handle = channel_handle.name.empty();
#if defined(OS_POSIX)
  if (!invalid_handle)
    invalid_handle = (channel_handle.socket.fd == -1);
#endif
  if (!invalid_handle)
    g_channel_handle_map.Get()[instance] = channel_handle;
 
   CHECK(static_cast<int>(sockets.size()) == socket_count);
   for (int i = 0; i < socket_count; i++) {
    static_cast<nacl::Handle*>(imc_handles)[i] =
        nacl::ToNativeHandle(sockets[i]);
  }

   return PP_TRUE;
 }
",1
Detect whether the following code contains vulnerabilities.,"acpi_os_create_cache(char *name, u16 size, u16 depth, acpi_cache_t ** cache)
{
	*cache = kmem_cache_create(name, size, 0, 0, NULL);
	if (*cache == NULL)
		return AE_ERROR;
	else
		return AE_OK;
}
",0
Detect whether the following code contains vulnerabilities.,"static int muscle_card_extract_key(sc_card_t *card, sc_cardctl_muscle_key_info_t *info)
{
	/* CURRENTLY DONT SUPPORT EXTRACTING PRIVATE KEYS... */
	switch(info->keyType) {
	case 1: /* RSA */
		return msc_extract_rsa_public_key(card,
			info->keyLocation,
			&info->modLength,
			&info->modValue,
			&info->expLength,
			&info->expValue);
	default:
		return SC_ERROR_NOT_SUPPORTED;
	}
}
",0
Detect whether the following code contains vulnerabilities.,"bool xmp_init()
{
     RESET_ERROR;
     try {
         bool result = SXMPFiles::Initialize(kXMPFiles_IgnoreLocalText);
         SXMPMeta::SetDefaultErrorCallback(&_xmp_error_callback, nullptr, 1);
         return result;
        SXMPMeta::SetDefaultErrorCallback(&_xmp_error_callback, nullptr, 1);
        return result;
    }
    catch (const XMP_Error &e) {
        set_error(e);
    }
    return false;
}
",1
Detect whether the following code contains vulnerabilities.,"blink::WebPlugin* RenderFrameImpl::CreatePlugin(
    const blink::WebPluginParams& params) {
  blink::WebPlugin* plugin = nullptr;
  if (GetContentClient()->renderer()->OverrideCreatePlugin(this, params,
                                                           &plugin)) {
    return plugin;
  }

  if (params.mime_type.ContainsOnlyASCII() &&
      params.mime_type.Ascii() == kBrowserPluginMimeType) {
    BrowserPluginDelegate* delegate =
        GetContentClient()->renderer()->CreateBrowserPluginDelegate(
            this, WebPluginInfo(), kBrowserPluginMimeType, GURL(params.url));
    return BrowserPluginManager::Get()->CreateBrowserPlugin(
        this, delegate->GetWeakPtr());
  }

#if BUILDFLAG(ENABLE_PLUGINS)
  WebPluginInfo info;
  std::string mime_type;
  bool found = false;
  Send(new FrameHostMsg_GetPluginInfo(
      routing_id_, params.url, frame_->Top()->GetSecurityOrigin(),
      params.mime_type.Utf8(), &found, &info, &mime_type));
  if (!found)
    return nullptr;

  WebPluginParams params_to_use = params;
  params_to_use.mime_type = WebString::FromUTF8(mime_type);
  return CreatePlugin(info, params_to_use, nullptr /* throttler */);
#else
  return nullptr;
#endif  // BUILDFLAG(ENABLE_PLUGINS)
}
",0
Detect whether the following code contains vulnerabilities.," void SSLManager::OnSSLCertificateError(
    base::WeakPtr<SSLErrorHandler::Delegate> delegate,
     const content::GlobalRequestID& id,
     const ResourceType::Type resource_type,
     const GURL& url,
    int render_process_id,
    int render_view_id,
    const net::SSLInfo& ssl_info,
    bool fatal) {
  DCHECK(delegate);
  DVLOG(1) << ""OnSSLCertificateError() cert_error: ""
           << net::MapCertStatusToNetError(ssl_info.cert_status)
           << "" id: "" << id.child_id << "","" << id.request_id
           << "" resource_type: "" << resource_type
           << "" url: "" << url.spec()
           << "" render_process_id: "" << render_process_id
           << "" render_view_id: "" << render_view_id
           << "" cert_status: "" << std::hex << ssl_info.cert_status;

  BrowserThread::PostTask(
      BrowserThread::UI, FROM_HERE,
      base::Bind(&SSLCertErrorHandler::Dispatch,
                 new SSLCertErrorHandler(delegate,
                                         id,
                                         resource_type,
                                         url,
                                         render_process_id,
                                         render_view_id,
                                         ssl_info,
                                         fatal)));
}
",1
Detect whether the following code contains vulnerabilities.,"void CloseFds(const std::vector<int>& fds) {
  for (const auto& it : fds) {
    PCHECK(0 == IGNORE_EINTR(close(it)));
  }
}
",0
Detect whether the following code contains vulnerabilities.,"krb5_gss_process_context_token(minor_status, context_handle,
                               token_buffer)
    OM_uint32 *minor_status;
    gss_ctx_id_t context_handle;
    gss_buffer_t token_buffer;
{
    krb5_gss_ctx_id_rec *ctx;
    OM_uint32 majerr;
 
     ctx = (krb5_gss_ctx_id_t) context_handle;
 
    if (! ctx->established) {
         *minor_status = KG_CTX_INCOMPLETE;
         return(GSS_S_NO_CONTEXT);
     }
 
     /* ""unseal"" the token */
 
     if (GSS_ERROR(majerr = kg_unseal(minor_status, context_handle,
                                     token_buffer,
                                     GSS_C_NO_BUFFER, NULL, NULL,
                                      KG_TOK_DEL_CTX)))
         return(majerr);
 
    /* that's it.  delete the context */
    return(krb5_gss_delete_sec_context(minor_status, &context_handle,
                                       GSS_C_NO_BUFFER));
 }
",1
Detect whether the following code contains vulnerabilities.,"static void die_if_data_is_missing(GHashTable *problem_info)
{
    gboolean missing_data = FALSE;
    gchar **pstring;
    static const gchar *const needed[] = {
        FILENAME_TYPE,
        FILENAME_REASON,
        /* FILENAME_BACKTRACE, - ECC errors have no such elements */
        /* FILENAME_EXECUTABLE, */
        NULL
    };

    for (pstring = (gchar**) needed; *pstring; pstring++)
    {
        if (!g_hash_table_lookup(problem_info, *pstring))
        {
            error_msg(""Element '%s' is missing"", *pstring);
            missing_data = TRUE;
        }
    }

    if (missing_data)
        error_msg_and_die(""Some data is missing, aborting"");
}
",0
Detect whether the following code contains vulnerabilities.,"get_control(png_const_structrp png_ptr)
{

    /* This just returns the (file*).  The chunk and idat control structures
     * don't always exist.
     */
   struct control *control = png_voidcast(struct control*,
       png_get_error_ptr(png_ptr));
    return &control->file;
 }
",1
Detect whether the following code contains vulnerabilities.,"static int adjust_insn_aux_data(struct bpf_verifier_env *env, u32 prog_len,
				u32 off, u32 cnt)
{
	struct bpf_insn_aux_data *new_data, *old_data = env->insn_aux_data;

	if (cnt == 1)
		return 0;
	new_data = vzalloc(sizeof(struct bpf_insn_aux_data) * prog_len);
	if (!new_data)
		return -ENOMEM;
	memcpy(new_data, old_data, sizeof(struct bpf_insn_aux_data) * off);
	memcpy(new_data + off + cnt - 1, old_data + off,
	       sizeof(struct bpf_insn_aux_data) * (prog_len - off - cnt + 1));
	env->insn_aux_data = new_data;
	vfree(old_data);
	return 0;
}
",0
Detect whether the following code contains vulnerabilities.,"void AXObject::tokenVectorFromAttribute(Vector<String>& tokens,
                                        const QualifiedName& attribute) const {
  Node* node = this->getNode();
  if (!node || !node->isElementNode())
    return;

  String attributeValue = getAttribute(attribute).getString();
  if (attributeValue.isEmpty())
    return;

  attributeValue.simplifyWhiteSpace();
  attributeValue.split(' ', tokens);
}
",0
Detect whether the following code contains vulnerabilities.,"v8::Handle<v8::Value> V8Proxy::throwNotEnoughArgumentsError()
 {
    return throwError(TypeError, ""Not enough arguments"");
 }
",1
Detect whether the following code contains vulnerabilities.,"void QuotaManager::GetUsageAndQuotaForEviction(
    const GetUsageAndQuotaForEvictionCallback& callback) {
  DCHECK(io_thread_->BelongsToCurrentThread());
  GetUsageAndQuotaInternal(
      GURL(), kStorageTypeTemporary, true /* global */, callback);
}
",0
Detect whether the following code contains vulnerabilities.,"dbus_object_create_path_vrrp(void)
{
	return g_strconcat(DBUS_VRRP_OBJECT_ROOT,
#if HAVE_DECL_CLONE_NEWNET
			  global_data->network_namespace ? ""/"" : """", global_data->network_namespace ? global_data->network_namespace : """",
#endif
			  global_data->instance_name ? ""/"" : """", global_data->instance_name ? global_data->instance_name : """",

			  ""/Vrrp"", NULL);
}
",0
Detect whether the following code contains vulnerabilities.," void CachingPermutedEntropyProvider::RegisterPrefs(
     PrefRegistrySimple* registry) {
  registry->RegisterStringPref(prefs::kVariationsPermutedEntropyCache,
                               std::string());
 }
",1
Detect whether the following code contains vulnerabilities.,"void ContentSecurityPolicy::usesStyleHashAlgorithms(uint8_t algorithms) {
  m_styleHashAlgorithmsUsed |= algorithms;
}
",0
Detect whether the following code contains vulnerabilities.,"BGD_DECLARE(gdImagePtr) gdImageCreateFromWebpPtr (int size, void *data)
{
	gdImagePtr im;
	gdIOCtx *in = gdNewDynamicCtxEx(size, data, 0);
	if (!in)
		return 0;
	im = gdImageCreateFromWebpCtx(in);
	in->gd_free(in);
	return im;
}
",0
Detect whether the following code contains vulnerabilities.,"static cJSON *get_object_item(const cJSON * const object, const char * const name, const cJSON_bool case_sensitive)
{
    cJSON *current_element = NULL;

    if ((object == NULL) || (name == NULL))
    {
        return NULL;
    }

     current_element = object->child;
     if (case_sensitive)
     {
        while ((current_element != NULL) && (strcmp(name, current_element->string) != 0))
         {
             current_element = current_element->next;
         }
    }
    else
    {
        while ((current_element != NULL) && (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element->string)) != 0))
        {
            current_element = current_element->next;
         }
     }
 
     return current_element;
 }
",1
Detect whether the following code contains vulnerabilities.,"void ewk_view_scroll(Evas_Object* ewkView, Evas_Coord deltaX, Evas_Coord deltaY, Evas_Coord scrollX, Evas_Coord scrollY, Evas_Coord scrollWidth, Evas_Coord scrollHeight, Evas_Coord centerX, Evas_Coord centerY, Evas_Coord centerWidth, Evas_Coord centerHeight, bool mainFrame)
{
    DBG(""ewkView=%p, delta: %d,%d, scroll: %d,%d+%dx%d, clip: %d,%d+%dx%d"",
        ewkView, deltaX, deltaY, scrollX, scrollY, scrollWidth, scrollHeight, centerX, centerY, centerWidth, centerHeight);

    if ((scrollX != centerX) || (scrollY != centerY) || (scrollWidth != centerWidth) || (scrollHeight != centerHeight))
        WRN(""scroll region and clip are different! %d,%d+%dx%d and %d,%d+%dx%d"",
            scrollX, scrollY, scrollWidth, scrollHeight, centerX, centerY, centerWidth, centerHeight);

    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData);
    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv);
    EINA_SAFETY_ON_TRUE_RETURN(!deltaX && !deltaY);

    _ewk_view_scroll_add(priv, deltaX, deltaY, scrollX, scrollY, scrollWidth, scrollHeight, mainFrame);

    _ewk_view_smart_changed(smartData);
}
",0
Detect whether the following code contains vulnerabilities.,"std::wstring GetChromeChannelName() {
  return InstallDetails::Get().channel();
}
",0
Detect whether the following code contains vulnerabilities.,"int TabStripModel::GetIndexOfTabContents(
    const TabContentsWrapper* contents) const {
  int index = 0;
  TabContentsDataVector::const_iterator iter = contents_data_.begin();
  for (; iter != contents_data_.end(); ++iter, ++index) {
    if ((*iter)->contents == contents)
      return index;
  }
  return kNoTab;
}
",0
Detect whether the following code contains vulnerabilities.,"void ResourceMessageFilter::OnClipboardIsFormatAvailable(
    Clipboard::FormatType format, Clipboard::Buffer buffer,
    IPC::Message* reply) {
  const bool result = GetClipboard()->IsFormatAvailable(format, buffer);
  ViewHostMsg_ClipboardIsFormatAvailable::WriteReplyParams(reply, result);
  Send(reply);
}
",0
Detect whether the following code contains vulnerabilities.,"const char *string_of_NPNVariable(int variable)
{
  const char *str;

  switch (variable) {
#define _(VAL) case VAL: str = #VAL; break;
	_(NPNVxDisplay);
	_(NPNVxtAppContext);
	_(NPNVnetscapeWindow);
	_(NPNVjavascriptEnabledBool);
	_(NPNVasdEnabledBool);
	_(NPNVisOfflineBool);
	_(NPNVserviceManager);
	_(NPNVDOMElement);
	_(NPNVDOMWindow);
	_(NPNVToolkit);
	_(NPNVSupportsXEmbedBool);
 	_(NPNVWindowNPObject);
 	_(NPNVPluginElementNPObject);
 	_(NPNVSupportsWindowless);
 #undef _
   default:
 	switch (variable & 0xff) {
#define _(VAL, VAR) case VAL: str = #VAR; break
	  _(10, NPNVserviceManager);
	  _(11, NPNVDOMElement);
	  _(12, NPNVDOMWindow);
	  _(13, NPNVToolkit);
#undef _
	default:
	  str = ""<unknown variable>"";
	  break;
	}
	break;
  }

  return str;
}
",1
Detect whether the following code contains vulnerabilities.,"static long futex_wait_restart(struct restart_block *restart)
{
	u32 __user *uaddr = (u32 __user *)restart->futex.uaddr;
	int fshared = 0;
	ktime_t t, *tp = NULL;

	if (restart->futex.flags & FLAGS_HAS_TIMEOUT) {
		t.tv64 = restart->futex.time;
		tp = &t;
	}
	restart->fn = do_no_restart_syscall;
	if (restart->futex.flags & FLAGS_SHARED)
		fshared = 1;
	return (long)futex_wait(uaddr, fshared, restart->futex.val, tp,
				restart->futex.bitset,
				restart->futex.flags & FLAGS_CLOCKRT);
}
",0
Detect whether the following code contains vulnerabilities.,"void SyncBackendHost::HandleConnectionStatusChangeOnFrontendLoop(
    sync_api::ConnectionStatus status) {
  if (!frontend_)
    return;

  DCHECK_EQ(MessageLoop::current(), frontend_loop_);

  frontend_->OnConnectionStatusChange(status);
}
",0
Detect whether the following code contains vulnerabilities.,"void PaintLayerScrollableArea::UpdateCompositingLayersAfterScroll() {
  PaintLayerCompositor* compositor = GetLayoutBox()->View()->Compositor();
  if (!compositor->InCompositingMode())
    return;

  if (UsesCompositedScrolling()) {
     DCHECK(Layer()->HasCompositedLayerMapping());
     ScrollingCoordinator* scrolling_coordinator = GetScrollingCoordinator();
     bool handled_scroll =
        Layer()->IsRootLayer() && scrolling_coordinator &&
         scrolling_coordinator->UpdateCompositedScrollOffset(this);
 
     if (!handled_scroll) {
      if (!RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) {
        Layer()->GetCompositedLayerMapping()->SetNeedsGraphicsLayerUpdate(
            kGraphicsLayerUpdateSubtree);
      }
      compositor->SetNeedsCompositingUpdate(
          kCompositingUpdateAfterGeometryChange);
    }

    if (Layer()->IsRootLayer()) {
      LocalFrame* frame = GetLayoutBox()->GetFrame();
      if (frame && frame->View() &&
          frame->View()->HasViewportConstrainedObjects()) {
        Layer()->SetNeedsCompositingInputsUpdate();
      }
    }
  } else {
    Layer()->SetNeedsCompositingInputsUpdate();
  }
}
",1
Detect whether the following code contains vulnerabilities.,"static void cfundecs(JF, js_Ast *list)
{
	while (list) {
		js_Ast *stm = list->a;
		if (stm->type == AST_FUNDEC) {
			emitline(J, F, stm);
			emitfunction(J, F, newfun(J, stm->line, stm->a, stm->b, stm->c, 0, F->strict));
			emitline(J, F, stm);
			emit(J, F, OP_SETLOCAL);
			emitarg(J, F, addlocal(J, F, stm->a, 0));
			emit(J, F, OP_POP);
		}
		list = list->b;
	}
}
",0
Detect whether the following code contains vulnerabilities.,"static int dev_get_valid_name(struct net *net, const char *name, char *buf,
			      bool fmt)
{
	if (!dev_valid_name(name))
		return -EINVAL;

	if (fmt && strchr(name, '%'))
		return __dev_alloc_name(net, name, buf);
	else if (__dev_get_by_name(net, name))
		return -EEXIST;
	else if (buf != name)
		strlcpy(buf, name, IFNAMSIZ);

	return 0;
}
",0
Detect whether the following code contains vulnerabilities.,"void InspectorOverlay::update()
{
    if (isEmpty()) {
        m_client->hideHighlight();
        return;
    }

    FrameView* view = m_page->mainFrame()->view();
    if (!view)
        return;
    IntRect viewRect = view->visibleContentRect();
    FrameView* overlayView = overlayPage()->mainFrame()->view();

    IntSize frameViewFullSize = view->visibleContentRect(ScrollableArea::IncludeScrollbars).size();
    IntSize size = m_size.isEmpty() ? frameViewFullSize : m_size;
    size.scale(m_page->pageScaleFactor());
    overlayView->resize(size);

    reset(size, m_size.isEmpty() ? IntSize() : frameViewFullSize, viewRect.x(), viewRect.y());

    drawGutter();
    drawNodeHighlight();
    drawQuadHighlight();
     if (!m_inspectModeEnabled)
         drawPausedInDebuggerMessage();
     drawViewSize();
    drawOverridesMessage();
 
     overlayPage()->mainFrame()->document()->recalcStyle(Force);
    if (overlayView->needsLayout())
        overlayView->layout();

    m_client->highlight();
}
",1
Detect whether the following code contains vulnerabilities.,"void WebContentsImpl::OnDidDownloadImage(
    int id,
    int http_status_code,
    const GURL& image_url,
    int requested_size,
    const std::vector<SkBitmap>& bitmaps) {
  ImageDownloadMap::iterator iter = image_download_map_.find(id);
  if (iter == image_download_map_.end()) {
    return;
  }
  if (!iter->second.is_null()) {
    iter->second.Run(id, http_status_code, image_url, requested_size, bitmaps);
  }
  image_download_map_.erase(id);
}
",0
Detect whether the following code contains vulnerabilities.," bool IsTraceEventArgsWhitelisted(const char* category_group_name,
                                 const char* event_name) {
   if (base::MatchPattern(category_group_name, ""toplevel"") &&
       base::MatchPattern(event_name, ""*"")) {
     return true;
   }
 
   return false;
 }
",1
Detect whether the following code contains vulnerabilities.," PassRefPtr<DocumentFragment> Range::createContextualFragment(const String& markup, ExceptionCode& ec)
 {
     if (!m_start.container()) {
        ec = INVALID_STATE_ERR;
        return 0;
    }

    Node* element = m_start.container()->isElementNode() ? m_start.container() : m_start.container()->parentNode();
    if (!element || !element->isHTMLElement()) {
        ec = NOT_SUPPORTED_ERR;
         return 0;
     }
 
    RefPtr<DocumentFragment> fragment = createDocumentFragmentForElement(markup, toElement(element), AllowScriptingContentAndDoNotMarkAlreadyStarted);
 
     if (!fragment) {
         ec = NOT_SUPPORTED_ERR;
        return 0;
    }

    return fragment.release();
}
",1
Detect whether the following code contains vulnerabilities.,"uint32 PluginInstance::ScheduleTimer(uint32 interval,
                                     NPBool repeat,
                                     void (*func)(NPP id, uint32 timer_id)) {
  uint32 timer_id;
  timer_id = next_timer_id_;
  ++next_timer_id_;
  DCHECK(next_timer_id_ != 0);

  TimerInfo info;
  info.interval = interval;
  info.repeat = repeat;
   timers_[timer_id] = info;
 
  message_loop_->PostDelayedTask(FROM_HERE,
                                 NewRunnableMethod(this,
                                                   &PluginInstance::OnTimerCall,
                                                   func,
                                                   npp_,
                                                   timer_id),
                                 interval);
   return timer_id;
 }
",1
Detect whether the following code contains vulnerabilities.,"u32 secure_ipv4_port_ephemeral(__be32 saddr, __be32 daddr, __be16 dport)
{
	struct keydata *keyptr = get_keyptr();
	u32 hash[4];
	/*
	 *  Pick a unique starting offset for each ephemeral port search
	 *  (saddr, daddr, dport) and 48bits of random data.
	 */
	hash[0] = (__force u32)saddr;
	hash[1] = (__force u32)daddr;
	hash[2] = (__force u32)dport ^ keyptr->secret[10];
	hash[3] = keyptr->secret[11];
	return half_md4_transform(hash, keyptr->secret);
}
",1
Detect whether the following code contains vulnerabilities.,"int import_iovec(int type, const struct iovec __user * uvector,
		 unsigned nr_segs, unsigned fast_segs,
		 struct iovec **iov, struct iov_iter *i)
{
	ssize_t n;
	struct iovec *p;
	n = rw_copy_check_uvector(type, uvector, nr_segs, fast_segs,
				  *iov, &p);
	if (n < 0) {
		if (p != *iov)
			kfree(p);
		*iov = NULL;
		return n;
	}
	iov_iter_init(i, type, p, nr_segs, n);
	*iov = p == *iov ? NULL : p;
	return 0;
}
",0
Detect whether the following code contains vulnerabilities.,"SampleTable::SampleTable(const sp<DataSource> &source)
 : mDataSource(source),
      mChunkOffsetOffset(-1),
      mChunkOffsetType(0),
      mNumChunkOffsets(0),
      mSampleToChunkOffset(-1),
      mNumSampleToChunkOffsets(0),
      mSampleSizeOffset(-1),

       mSampleSizeFieldSize(0),
       mDefaultSampleSize(0),
       mNumSampleSizes(0),
       mTimeToSampleCount(0),
       mTimeToSample(),
       mSampleTimeEntries(NULL),
      mCompositionTimeDeltaEntries(NULL),
      mNumCompositionTimeDeltaEntries(0),
      mCompositionDeltaLookup(new CompositionDeltaLookup),
      mSyncSampleOffset(-1),
      mNumSyncSamples(0),
      mSyncSamples(NULL),
      mLastSyncSampleIndex(0),
      mSampleToChunkEntries(NULL) {
    mSampleIterator = new SampleIterator(this);
}
",1
Detect whether the following code contains vulnerabilities.," void ChromeContentRendererClient::RenderViewCreated(RenderView* render_view) {
   ContentSettingsObserver* content_settings =
       new ContentSettingsObserver(render_view);
  new DevToolsAgent(render_view);
   new ExtensionHelper(render_view, extension_dispatcher_.get());
   new PageLoadHistograms(render_view, histogram_snapshots_.get());
   new PrintWebViewHelper(render_view);
  new SearchBox(render_view);
  new SpellCheckProvider(render_view, spellcheck_.get());
#if defined(ENABLE_SAFE_BROWSING)
  safe_browsing::MalwareDOMDetails::Create(render_view);
#endif

#if defined(OS_MACOSX)
  new TextInputClientObserver(render_view);
#endif  // defined(OS_MACOSX)

  PasswordAutofillManager* password_autofill_manager =
      new PasswordAutofillManager(render_view);
  AutofillAgent* autofill_agent = new AutofillAgent(render_view,
                                                    password_autofill_manager);
  PageClickTracker* page_click_tracker = new PageClickTracker(render_view);
  page_click_tracker->AddListener(password_autofill_manager);
  page_click_tracker->AddListener(autofill_agent);

  TranslateHelper* translate = new TranslateHelper(render_view, autofill_agent);
  new ChromeRenderViewObserver(
      render_view, content_settings, extension_dispatcher_.get(), translate);

  if (CommandLine::ForCurrentProcess()->HasSwitch(
          switches::kDomAutomationController)) {
    new AutomationRendererHelper(render_view);
  }
}
",1
Detect whether the following code contains vulnerabilities.,"void RenderFrameImpl::FrameFocused() {
  Send(new FrameHostMsg_FrameFocused(routing_id_));
}
",0
Detect whether the following code contains vulnerabilities.,"void BluetoothDeviceChromeOS::RequestPinCode(
    const dbus::ObjectPath& device_path,
    const PinCodeCallback& callback) {
  DCHECK(agent_.get());
  DCHECK(device_path == object_path_);
  VLOG(1) << object_path_.value() << "": RequestPinCode"";
  UMA_HISTOGRAM_ENUMERATION(""Bluetooth.PairingMethod"",
                            UMA_PAIRING_METHOD_REQUEST_PINCODE,
                            UMA_PAIRING_METHOD_COUNT);
  DCHECK(pairing_delegate_);
  DCHECK(pincode_callback_.is_null());
  pincode_callback_ = callback;
  pairing_delegate_->RequestPinCode(this);
  pairing_delegate_used_ = true;
}
",1
Detect whether the following code contains vulnerabilities.,"void PrintPreviewMessageHandler::OnInvalidPrinterSettings(int document_cookie) {
  StopWorker(document_cookie);
  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();
  if (!print_preview_ui)
    return;
  print_preview_ui->OnInvalidPrinterSettings();
}
",0
Detect whether the following code contains vulnerabilities.,"DOMHandler::DOMHandler()
     : DevToolsDomainHandler(DOM::Metainfo::domainName),
      host_(nullptr) {
}
",1
Detect whether the following code contains vulnerabilities.,"bool RenderViewHostManager::ShouldReuseWebUI(
    const NavigationEntry* curr_entry,
    const NavigationEntryImpl* new_entry) const {
  NavigationControllerImpl& controller =
      delegate_->GetControllerForRenderManager();
  return curr_entry && web_ui_.get() &&
      (WebUIControllerFactoryRegistry::GetInstance()->GetWebUIType(
          controller.GetBrowserContext(), curr_entry->GetURL()) ==
       WebUIControllerFactoryRegistry::GetInstance()->GetWebUIType(
          controller.GetBrowserContext(), new_entry->GetURL()));
}
",0
Detect whether the following code contains vulnerabilities.,"void RenderBlock::styleWillChange(StyleDifference diff, const RenderStyle& newStyle)
{
    RenderStyle* oldStyle = style();
 
     setReplaced(newStyle.isDisplayInlineType());
 
    if (oldStyle && parent() && diff == StyleDifferenceLayout && oldStyle->position() != newStyle.position()) {
         if (newStyle.position() == StaticPosition)
            removePositionedObjects(0, NewContainingBlock);
        else if (oldStyle->position() == StaticPosition) {
            RenderObject* cb = parent();
            while (cb && (cb->style()->position() == StaticPosition || (cb->isInline() && !cb->isReplaced())) && !cb->isRenderView()) {
                if (cb->style()->position() == RelativePosition && cb->isInline() && !cb->isReplaced()) {
                    cb = cb->containingBlock();
                    break;
                }
                cb = cb->parent();
            }

            if (cb->isRenderBlock())
                toRenderBlock(cb)->removePositionedObjects(this, NewContainingBlock);
        }
    }

    RenderBox::styleWillChange(diff, newStyle);
}
",1
Detect whether the following code contains vulnerabilities.,"void QQuickWebViewPrivate::setNeedsDisplay()
{
    Q_Q(QQuickWebView);
    if (renderToOffscreenBuffer()) {
        QImage dummyImage(1, 1, QImage::Format_ARGB32);
        QPainter painter(&dummyImage);
        q->page()->d->paint(&painter);
        return;
    }

    q->page()->update();
}
",0
Detect whether the following code contains vulnerabilities.," String InspectorPageAgent::CachedResourceTypeJson(
     const Resource& cached_resource) {
  return ResourceTypeJson(CachedResourceType(cached_resource));
 }
",1
Detect whether the following code contains vulnerabilities.," static __u8 *ch_report_fixup(struct hid_device *hdev, __u8 *rdesc,
 		unsigned int *rsize)
 {
	if (*rsize >= 17 && rdesc[11] == 0x3c && rdesc[12] == 0x02) {
 		hid_info(hdev, ""fixing up Cherry Cymotion report descriptor\n"");
 		rdesc[11] = rdesc[16] = 0xff;
 		rdesc[12] = rdesc[17] = 0x03;
	}
	return rdesc;
}
",1
Detect whether the following code contains vulnerabilities.,"    LineLayoutState(bool fullLayout, LayoutUnit& repaintLogicalTop, LayoutUnit& repaintLogicalBottom, RenderFlowThread* flowThread)
        : m_lastFloat(0)
        , m_endLine(0)
        , m_floatIndex(0)
        , m_endLineLogicalTop(0)
        , m_endLineMatched(false)
        , m_checkForFloatsFromLastLine(false)
        , m_isFullLayout(fullLayout)
        , m_repaintLogicalTop(repaintLogicalTop)
        , m_repaintLogicalBottom(repaintLogicalBottom)
        , m_adjustedLogicalLineTop(0)
        , m_usesRepaintBounds(false)
        , m_flowThread(flowThread)
    { }
",0
Detect whether the following code contains vulnerabilities.,"void OfflinePageModelTaskified::OnTaskQueueIsIdle() {}
",0
Detect whether the following code contains vulnerabilities.,"status_t OMXNodeInstance::allocateBufferWithBackup(
        OMX_U32 portIndex, const sp<IMemory> &params,
        OMX::buffer_id *buffer, OMX_U32 allottedSize) {
 Mutex::Autolock autoLock(mLock);
 if (allottedSize > params->size()) {

         return BAD_VALUE;
     }
 
    BufferMeta *buffer_meta = new BufferMeta(params, true);
 
     OMX_BUFFERHEADERTYPE *header;
 
    OMX_ERRORTYPE err = OMX_AllocateBuffer(
            mHandle, &header, portIndex, buffer_meta, allottedSize);
 if (err != OMX_ErrorNone) {
        CLOG_ERROR(allocateBufferWithBackup, err,
                SIMPLE_BUFFER(portIndex, (size_t)allottedSize, params->pointer()));
 delete buffer_meta;
        buffer_meta = NULL;

 *buffer = 0;

 return StatusFromOMXError(err);
 }

    CHECK_EQ(header->pAppPrivate, buffer_meta);

 *buffer = makeBufferID(header);

    addActiveBuffer(portIndex, *buffer);

    sp<GraphicBufferSource> bufferSource(getGraphicBufferSource());
 if (bufferSource != NULL && portIndex == kPortIndexInput) {
        bufferSource->addCodecBuffer(header);
 }

    CLOG_BUFFER(allocateBufferWithBackup, NEW_BUFFER_FMT(*buffer, portIndex, ""%zu@%p :> %u@%p"",
            params->size(), params->pointer(), allottedSize, header->pBuffer));

 return OK;
}
",1
Detect whether the following code contains vulnerabilities.,"static inline unsigned long perf_ip_adjust(struct pt_regs *regs)
{
	unsigned long mmcra = regs->dsisr;

	if ((mmcra & MMCRA_SAMPLE_ENABLE) && !(ppmu->flags & PPMU_ALT_SIPR)) {
		unsigned long slot = (mmcra & MMCRA_SLOT) >> MMCRA_SLOT_SHIFT;
		if (slot > 1)
			return 4 * (slot - 1);
	}
	return 0;
}
",0
Detect whether the following code contains vulnerabilities.,"   static void TearDownTestCase() {
     vpx_free(input_ - 1);
     input_ = NULL;
     vpx_free(output_);
     output_ = NULL;
   }
",1
Detect whether the following code contains vulnerabilities.,"bool BaseAudioContext::WouldTaintOrigin(const KURL& url) const {
  if (url.ProtocolIsData()) {
    return false;
  }
  Document* document = GetDocument();
  if (document && document->GetSecurityOrigin()) {
    return !document->GetSecurityOrigin()->CanRequest(url);
  }
  return true;
}
",1
Detect whether the following code contains vulnerabilities.,"  virtual void AddObserver(Observer* observer) {
     if (!observers_.size()) {
       observer->FirstObserverIsAdded(this);
     }
     observers_.AddObserver(observer);
   }
",1
Detect whether the following code contains vulnerabilities.,"double json_real_value(const json_t *json)
{
    if(!json_is_real(json))
        return 0;

    return json_to_real(json)->value;
}
",0
Detect whether the following code contains vulnerabilities.," static void toggle_fpga_eeprom_bus(bool cpu_own)
 {
	qrio_gpio_direction_output(GPIO_A, PROM_SEL_L, !cpu_own);
 }
",1
Detect whether the following code contains vulnerabilities.," static void prefetch_dec(void)
 {
   prefetch_table((const void *)&dec_tables, sizeof(dec_tables));
 }
",1
Detect whether the following code contains vulnerabilities.,"static void put_mspel8_mc32_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)
{
    uint8_t halfH[88];
    uint8_t halfV[64];
    uint8_t halfHV[64];
    wmv2_mspel8_h_lowpass(halfH, src-stride, 8, stride, 11);
    wmv2_mspel8_v_lowpass(halfV, src+1, 8, stride, 8);
    wmv2_mspel8_v_lowpass(halfHV, halfH+8, 8, 8, 8);
    put_pixels8_l2_8(dst, halfV, halfHV, stride, 8, 8, 8);
}
",0
Detect whether the following code contains vulnerabilities.,"timeval_to_jiffies(const struct timeval *value)
{
	unsigned long sec = value->tv_sec;
	long usec = value->tv_usec;

	if (sec >= MAX_SEC_IN_JIFFIES){
		sec = MAX_SEC_IN_JIFFIES;
		usec = 0;
	}
	return (((u64)sec * SEC_CONVERSION) +
		(((u64)usec * USEC_CONVERSION + USEC_ROUND) >>
		 (USEC_JIFFIE_SC - SEC_JIFFIE_SC))) >> SEC_JIFFIE_SC;
}
",0
Detect whether the following code contains vulnerabilities.," base::string16 GetApplicationNameForProtocol(const GURL& url) {
  base::string16 application_name;
   if (base::win::GetVersion() >= base::win::VERSION_WIN8) {
    application_name = GetAppForProtocolUsingAssocQuery(url);
     if (!application_name.empty())
       return application_name;
   }

  return GetAppForProtocolUsingRegistry(url);
}
",1
Detect whether the following code contains vulnerabilities.,"MagickExport const PixelPacket *GetVirtualPixelQueue(const Image *image)
{
  CacheInfo
    *restrict cache_info;

  const int
    id = GetOpenMPThreadId();

  assert(image != (const Image *) NULL);
  assert(image->signature == MagickSignature);
  assert(image->cache != (Cache) NULL);
  cache_info=(CacheInfo *) image->cache;
  assert(cache_info->signature == MagickSignature);
  if (cache_info->methods.get_virtual_pixels_handler !=
       (GetVirtualPixelsHandler) NULL)
    return(cache_info->methods.get_virtual_pixels_handler(image));
  assert(id < (int) cache_info->number_threads);
  return(GetVirtualPixelsNexus(cache_info,cache_info->nexus_info[id]));
}
",0
Detect whether the following code contains vulnerabilities.," void DOMStorageContextWrapper::Shutdown() {
  DCHECK(context_.get());
  mojo_task_runner_->PostTask(
      FROM_HERE, base::BindOnce(&LocalStorageContextMojo::ShutdownAndDelete,
                                base::Unretained(mojo_state_)));
  mojo_state_ = nullptr;
   if (mojo_session_state_) {
     mojo_task_runner_->PostTask(
         FROM_HERE, base::BindOnce(&SessionStorageContextMojo::ShutdownAndDelete,
                                   base::Unretained(mojo_session_state_)));
     mojo_session_state_ = nullptr;
   }
   memory_pressure_listener_.reset();
  context_->task_runner()->PostShutdownBlockingTask(
      FROM_HERE, DOMStorageTaskRunner::PRIMARY_SEQUENCE,
      base::BindOnce(&DOMStorageContextImpl::Shutdown, context_));
 }
",1
Detect whether the following code contains vulnerabilities.,"aura::Window* PartialMagnificationController::GetCurrentRootWindow() {
  aura::Window::Windows root_windows = Shell::GetAllRootWindows();
  for (aura::Window::Windows::const_iterator iter = root_windows.begin();
       iter != root_windows.end(); ++iter) {
    aura::Window* root_window = *iter;
    if (root_window->ContainsPointInRoot(
            root_window->GetHost()->dispatcher()->GetLastMouseLocationInRoot()))
      return root_window;
  }
  return NULL;
}
",1
Detect whether the following code contains vulnerabilities.,"v8::Local<v8::Object> V8InjectedScriptHost::create(v8::Local<v8::Context> context, V8InspectorImpl* inspector)
 {
     v8::Isolate* isolate = inspector->isolate();
     v8::Local<v8::Object> injectedScriptHost = v8::Object::New(isolate);
     v8::Local<v8::External> debuggerExternal = v8::External::New(isolate, inspector);
     setFunctionProperty(context, injectedScriptHost, ""internalConstructorName"", V8InjectedScriptHost::internalConstructorNameCallback, debuggerExternal);
     setFunctionProperty(context, injectedScriptHost, ""formatAccessorsAsProperties"", V8InjectedScriptHost::formatAccessorsAsProperties, debuggerExternal);
    setFunctionProperty(context, injectedScriptHost, ""subtype"", V8InjectedScriptHost::subtypeCallback, debuggerExternal);
    setFunctionProperty(context, injectedScriptHost, ""getInternalProperties"", V8InjectedScriptHost::getInternalPropertiesCallback, debuggerExternal);
    setFunctionProperty(context, injectedScriptHost, ""objectHasOwnProperty"", V8InjectedScriptHost::objectHasOwnPropertyCallback, debuggerExternal);
    setFunctionProperty(context, injectedScriptHost, ""bind"", V8InjectedScriptHost::bindCallback, debuggerExternal);
    setFunctionProperty(context, injectedScriptHost, ""proxyTargetValue"", V8InjectedScriptHost::proxyTargetValueCallback, debuggerExternal);
    return injectedScriptHost;
}
",1
Detect whether the following code contains vulnerabilities.," queue_unlock(struct futex_q *q, struct futex_hash_bucket *hb)
 {
 	spin_unlock(&hb->lock);
	drop_futex_key_refs(&q->key);
 }
",1
Detect whether the following code contains vulnerabilities.,"status_t BufferQueueConsumer::disconnect() {
    ATRACE_CALL();

    BQ_LOGV(""disconnect(C)"");

 Mutex::Autolock lock(mCore->mMutex);

 if (mCore->mConsumerListener == NULL) {
        BQ_LOGE(""disconnect(C): no consumer is connected"");
 return BAD_VALUE;
 }

    mCore->mIsAbandoned = true;
    mCore->mConsumerListener = NULL;
    mCore->mQueue.clear();
    mCore->freeAllBuffersLocked();
    mCore->mDequeueCondition.broadcast();
 return NO_ERROR;
}
",0
Detect whether the following code contains vulnerabilities.,"int ssl3_send_alert(SSL *s, int level, int desc)
{
    /* Map tls/ssl alert value to correct one */
    desc = s->method->ssl3_enc->alert_value(desc);
    if (s->version == SSL3_VERSION && desc == SSL_AD_PROTOCOL_VERSION)
        desc = SSL_AD_HANDSHAKE_FAILURE; /* SSL 3.0 does not have
                                          * protocol_version alerts */
                                           * protocol_version alerts */
     if (desc < 0)
         return -1;
    /* If a fatal one, remove from cache */
    if ((level == 2) && (s->session != NULL))
        SSL_CTX_remove_session(s->session_ctx, s->session);
 
     s->s3->alert_dispatch = 1;
     s->s3->send_alert[0] = level;
     * else data is still being written out, we will get written some time in
     * the future
     */
    return -1;
}
",1
Detect whether the following code contains vulnerabilities.,"static void tun_net_init(struct net_device *dev)
{
	struct tun_struct *tun = netdev_priv(dev);

	switch (tun->flags & TUN_TYPE_MASK) {
	case TUN_TUN_DEV:
		dev->netdev_ops = &tun_netdev_ops;

		/* Point-to-Point TUN Device */
		dev->hard_header_len = 0;
		dev->addr_len = 0;
		dev->mtu = 1500;

		/* Zero header length */
		dev->type = ARPHRD_NONE;
		dev->flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;
		dev->tx_queue_len = TUN_READQ_SIZE;  /* We prefer our own queue length */
		break;

	case TUN_TAP_DEV:
 		dev->netdev_ops = &tap_netdev_ops;
 		/* Ethernet TAP Device */
 		ether_setup(dev);
 
 		random_ether_addr(dev->dev_addr);
 
		dev->tx_queue_len = TUN_READQ_SIZE;  /* We prefer our own queue length */
		break;
	}
}
",1
Detect whether the following code contains vulnerabilities.,"ShelfLayoutManager* GetShelfLayoutManager() {
  return AshTestBase::GetPrimaryShelf()->shelf_layout_manager();
}
",0
Detect whether the following code contains vulnerabilities.,"MagickExport void *DetachBlob(BlobInfo *blob_info)
{
  void
    *data;

  assert(blob_info != (BlobInfo *) NULL);
  if (blob_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""..."");
   if (blob_info->mapped != MagickFalse)
     {
       (void) UnmapBlob(blob_info->data,blob_info->length);
       RelinquishMagickResource(MapResource,blob_info->length);
     }
   blob_info->mapped=MagickFalse;
  blob_info->length=0;
  blob_info->offset=0;
  blob_info->eof=MagickFalse;
  blob_info->error=0;
  blob_info->exempt=MagickFalse;
  blob_info->type=UndefinedStream;
  blob_info->file_info.file=(FILE *) NULL;
  data=blob_info->data;
  blob_info->data=(unsigned char *) NULL;
  blob_info->stream=(StreamHandler) NULL;
  blob_info->custom_stream=(CustomStreamInfo *) NULL;
  return(data);
}
",1
Detect whether the following code contains vulnerabilities.,"void cJSON_AddItemReferenceToObject( cJSON *object, const char *string, cJSON *item )
{
	cJSON_AddItemToObject( object, string, create_reference( item ) );
}
",1
Detect whether the following code contains vulnerabilities.,"ProcRenderCreateConicalGradient(ClientPtr client)
{
    PicturePtr pPicture;
    int len;
    int error = 0;
    xFixed *stops;
    xRenderColor *colors;

    REQUEST(xRenderCreateConicalGradientReq);

    REQUEST_AT_LEAST_SIZE(xRenderCreateConicalGradientReq);

    LEGAL_NEW_RESOURCE(stuff->pid, client);

    len = (client->req_len << 2) - sizeof(xRenderCreateConicalGradientReq);
    if (stuff->nStops > UINT32_MAX / (sizeof(xFixed) + sizeof(xRenderColor)))
        return BadLength;
    if (len != stuff->nStops * (sizeof(xFixed) + sizeof(xRenderColor)))
        return BadLength;

    stops = (xFixed *) (stuff + 1);
    colors = (xRenderColor *) (stops + stuff->nStops);

    pPicture =
        CreateConicalGradientPicture(stuff->pid, &stuff->center, stuff->angle,
                                     stuff->nStops, stops, colors, &error);
    if (!pPicture)
        return error;
    /* security creation/labeling check */
    error = XaceHook(XACE_RESOURCE_ACCESS, client, stuff->pid, PictureType,
                     pPicture, RT_NONE, NULL, DixCreateAccess);
    if (error != Success)
        return error;
    if (!AddResource(stuff->pid, PictureType, (void *) pPicture))
        return BadAlloc;
    return Success;
}
",0
Detect whether the following code contains vulnerabilities.,"static enum test_return test_binary_replaceq(void) {
    return test_binary_replace_impl(""test_binary_replaceq"",
                                    PROTOCOL_BINARY_CMD_REPLACEQ);
}
",0
Detect whether the following code contains vulnerabilities.,"Chapters::Chapters(
    Segment* pSegment,
    long long payload_start,
    long long payload_size,
    long long element_start,
    long long element_size) :
    m_pSegment(pSegment),
    m_start(payload_start),
    m_size(payload_size),
    m_element_start(element_start),
    m_element_size(element_size),
    m_editions(NULL),
    m_editions_size(0),
    m_editions_count(0)
{
}
",1
Detect whether the following code contains vulnerabilities.,"static int spl_filesystem_file_is_empty_line(spl_filesystem_object *intern TSRMLS_DC) /* {{{ */
{
	if (intern->u.file.current_line) {
		return intern->u.file.current_line_len == 0;
	} else if (intern->u.file.current_zval) {
		switch(Z_TYPE_P(intern->u.file.current_zval)) {
		case IS_STRING:
			return Z_STRLEN_P(intern->u.file.current_zval) == 0;
		case IS_ARRAY:
 			if (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_CSV)
 			&& zend_hash_num_elements(Z_ARRVAL_P(intern->u.file.current_zval)) == 1) {
 				zval ** first = Z_ARRVAL_P(intern->u.file.current_zval)->pListHead->pData;
 				return Z_TYPE_PP(first) == IS_STRING && Z_STRLEN_PP(first) == 0;
 			}
 			return zend_hash_num_elements(Z_ARRVAL_P(intern->u.file.current_zval)) == 0;
		case IS_NULL:
			return 1;
		default:
			return 0;
		}
	} else {
		return 1;
	}
}
/* }}} */
",1
Detect whether the following code contains vulnerabilities.,"void Document::InitContentSecurityPolicy(
    ContentSecurityPolicy* csp,
    const ContentSecurityPolicy* policy_to_inherit,
    const ContentSecurityPolicy* previous_document_csp) {
   SetContentSecurityPolicy(csp ? csp : ContentSecurityPolicy::Create());
 
   GetContentSecurityPolicy()->BindToExecutionContext(this);
 
  if (policy_to_inherit) {
     GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);
  } else {
    if (frame_) {
       Frame* inherit_from = frame_->Tree().Parent()
                                 ? frame_->Tree().Parent()
                                 : frame_->Client()->Opener();
       if (inherit_from && frame_ != inherit_from) {
         DCHECK(inherit_from->GetSecurityContext() &&
                inherit_from->GetSecurityContext()->GetContentSecurityPolicy());
        policy_to_inherit =
            inherit_from->GetSecurityContext()->GetContentSecurityPolicy();
       }
     }
    if (!policy_to_inherit)
      policy_to_inherit = previous_document_csp;
    if (policy_to_inherit &&
        (url_.IsEmpty() || url_.ProtocolIsAbout() || url_.ProtocolIsData() ||
         url_.ProtocolIs(""blob"") || url_.ProtocolIs(""filesystem"")))
      GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);
  }
  if (policy_to_inherit && IsPluginDocument())
    GetContentSecurityPolicy()->CopyPluginTypesFrom(policy_to_inherit);
 }
",1
Detect whether the following code contains vulnerabilities.," bool BluetoothDeviceChromeOS::ExpectingConfirmation() const {
  return !confirmation_callback_.is_null();
 }
",1
Detect whether the following code contains vulnerabilities.,"static void init_once(void *foo)
{
	struct ext4_inode_info *ei = (struct ext4_inode_info *) foo;

 	INIT_LIST_HEAD(&ei->i_orphan);
 	init_rwsem(&ei->xattr_sem);
 	init_rwsem(&ei->i_data_sem);
 	inode_init_once(&ei->vfs_inode);
 }
",1
Detect whether the following code contains vulnerabilities.,"void HWNDMessageHandler::Init(HWND parent, const gfx::Rect& bounds) {
  TRACE_EVENT0(""views"", ""HWNDMessageHandler::Init"");
  GetMonitorAndRects(bounds.ToRECT(), &last_monitor_, &last_monitor_rect_,
                     &last_work_area_);
 
   WindowImpl::Init(parent, bounds);
 }
",1
Detect whether the following code contains vulnerabilities.,"xdr_dpol_arg(XDR *xdrs, dpol_arg *objp)
{
	if (!xdr_ui_4(xdrs, &objp->api_version)) {
		return (FALSE);
	}
	if (!xdr_nullstring(xdrs, &objp->name)) {
		return (FALSE);
	}
	return (TRUE);
}
",0
Detect whether the following code contains vulnerabilities.,"int x86_set_memory_region(struct kvm *kvm, int id, gpa_t gpa, u32 size)
{
	int r;

	mutex_lock(&kvm->slots_lock);
	r = __x86_set_memory_region(kvm, id, gpa, size);
	mutex_unlock(&kvm->slots_lock);

	return r;
}
",0
Detect whether the following code contains vulnerabilities.,"static EAS_I16 ConvertLFOPhaseIncrement (EAS_I32 pitchCents)
{

 /* check range */
 if (pitchCents > MAX_LFO_FREQUENCY_IN_PITCHCENTS)
        pitchCents = MAX_LFO_FREQUENCY_IN_PITCHCENTS;
 if (pitchCents < MIN_LFO_FREQUENCY_IN_PITCHCENTS)
        pitchCents = MIN_LFO_FREQUENCY_IN_PITCHCENTS;

 /* double the rate and divide by frame rate by subtracting in log domain */
    pitchCents = pitchCents - dlsLFOFrequencyConvert;

 /* convert to phase increment */
 return (EAS_I16) EAS_Calculate2toX(pitchCents);
}
",0
Detect whether the following code contains vulnerabilities.,"static int generate_key(DH *dh)
{
     int ok = 0;
     int generate_new_key = 0;
     unsigned l;
    BN_CTX *ctx;
     BN_MONT_CTX *mont = NULL;
     BIGNUM *pub_key = NULL, *priv_key = NULL;
 
     ctx = BN_CTX_new();
     if (ctx == NULL)
         goto err;
        generate_new_key = 1;
    } else
",1
Detect whether the following code contains vulnerabilities.,"int32_t InputHandler::finishComposition()
{
    if (!isActiveTextEdit())
        return -1;

    if (!compositionActive())
        return 0;

    removeAttributedTextMarker();

    InputLog(LogLevelInfo, ""InputHandler::finishComposition completed"");

    return 0;
}
",0
Detect whether the following code contains vulnerabilities.,"size_t ndp_msg_payload_len(struct ndp_msg *msg)
{
	return msg->len;
}
",0
Detect whether the following code contains vulnerabilities.,"ZEND_API int zend_declare_property_double(zend_class_entry *ce, const char *name, int name_length, double value, int access_type TSRMLS_DC) /* {{{ */
{
	zval *property;

	if (ce->type & ZEND_INTERNAL_CLASS) {
		ALLOC_PERMANENT_ZVAL(property);
	} else {
		ALLOC_ZVAL(property);
	}
	INIT_PZVAL(property);
	ZVAL_DOUBLE(property, value);
	return zend_declare_property(ce, name, name_length, property, access_type TSRMLS_CC);
}
/* }}} */
",0
Detect whether the following code contains vulnerabilities.,"void TabStrip::SetDropArrow(
    const base::Optional<BrowserRootView::DropIndex>& index) {
  if (!index) {
    controller_->OnDropIndexUpdate(-1, false);
    drop_arrow_.reset();
    return;
  }

  controller_->OnDropIndexUpdate(index->value, index->drop_before);

  if (drop_arrow_ && (index == drop_arrow_->index))
    return;

  bool is_beneath;
  gfx::Rect drop_bounds =
      GetDropBounds(index->value, index->drop_before, &is_beneath);

  if (!drop_arrow_) {
    drop_arrow_ = std::make_unique<DropArrow>(*index, !is_beneath, GetWidget());
  } else {
    drop_arrow_->index = *index;
    if (is_beneath == drop_arrow_->point_down) {
      drop_arrow_->point_down = !is_beneath;
      drop_arrow_->arrow_view->SetImage(
          GetDropArrowImage(drop_arrow_->point_down));
    }
  }

  drop_arrow_->arrow_window->SetBounds(drop_bounds);
  drop_arrow_->arrow_window->Show();
}
",0
Detect whether the following code contains vulnerabilities.,"on_unregister_handler(TCMUService1HandlerManager1 *interface,
		      GDBusMethodInvocation *invocation,
		      gchar *subtype,
		      gpointer user_data)
{
	struct tcmur_handler *handler = find_handler_by_subtype(subtype);
	struct dbus_info *info = handler ? handler->opaque : NULL;

	if (!handler) {
		g_dbus_method_invocation_return_value(invocation,
			g_variant_new(""(bs)"", FALSE,
 				      ""unknown subtype""));
 		return TRUE;
 	}
 	dbus_unexport_handler(handler);
	tcmur_unregister_handler(handler);
 	g_bus_unwatch_name(info->watcher_id);
 	g_free(info);
 	g_free(handler);
	g_dbus_method_invocation_return_value(invocation,
		g_variant_new(""(bs)"", TRUE, ""succeeded""));
	return TRUE;
}
",1
Detect whether the following code contains vulnerabilities.," void DistillerNativeJavaScript::EnsureServiceConnected() {
  if (!distiller_js_service_) {
     render_frame_->GetServiceRegistry()->ConnectToRemoteService(
         mojo::GetProxy(&distiller_js_service_));
   }
 }
",1
Detect whether the following code contains vulnerabilities.,"static void calcstepsizes(uint_fast16_t refstepsize, int numrlvls,
  uint_fast16_t *stepsizes)
{
	int bandno;
	int numbands;
	uint_fast16_t expn;
	uint_fast16_t mant;
	expn = JPC_QCX_GETEXPN(refstepsize);
 	mant = JPC_QCX_GETMANT(refstepsize);
 	numbands = 3 * numrlvls - 2;
 	for (bandno = 0; bandno < numbands; ++bandno) {
////jas_eprintf(""DEBUG %d %d %d %d %d\n"", bandno, expn, numrlvls, bandno, ((numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0)))));
 		stepsizes[bandno] = JPC_QCX_MANT(mant) | JPC_QCX_EXPN(expn +
 		  (numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0))));
 	}
}
",1
Detect whether the following code contains vulnerabilities.,"  void VerifyPrintPreviewInvalidPrinterSettings(bool settings_invalid) {
    bool print_preview_invalid_printer_settings =
        (render_thread_->sink().GetUniqueMessageMatching(
            PrintHostMsg_PrintPreviewInvalidPrinterSettings::ID) != NULL);
    EXPECT_EQ(settings_invalid, print_preview_invalid_printer_settings);
  }
",0
Detect whether the following code contains vulnerabilities.,"bool CanUseExistingResource(const net::HttpResponseInfo* http_info) {
  if (!http_info->headers || http_info->headers->RequiresValidation(
                                 http_info->request_time,
                                 http_info->response_time, base::Time::Now())) {
    return false;
  }

  std::string value;
  size_t iter = 0;
  while (http_info->headers->EnumerateHeader(&iter, ""vary"", &value)) {
    if (!base::EqualsCaseInsensitiveASCII(value, ""Accept-Encoding"") &&
        !base::EqualsCaseInsensitiveASCII(value, ""Origin"")) {
      return false;
    }
  }
  return true;
}
",0
Detect whether the following code contains vulnerabilities.,"PHP_FUNCTION(grapheme_strpos)
{
	unsigned char *haystack, *needle;
        int haystack_len, needle_len;
        unsigned char *found;
        long loffset = 0;
       int32_t offset = 0;
        int ret_pos;
 
        if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ss|l"", (char **)&haystack, &haystack_len, (char **)&needle, &needle_len, &loffset) == FAILURE) {

		intl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,
			 ""grapheme_strpos: unable to parse input param"", 0 TSRMLS_CC );

		RETURN_FALSE;
	}

	if ( OUTSIDE_STRING(loffset, haystack_len) ) {

		intl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR, ""grapheme_strpos: Offset not contained in string"", 1 TSRMLS_CC );

		RETURN_FALSE;
	}
 
        /* we checked that it will fit: */
        offset = (int32_t) loffset;
 
        /* the offset is 'grapheme count offset' so it still might be invalid - we'll check it later */
 

		intl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR, ""grapheme_strpos: Empty delimiter"", 1 TSRMLS_CC );

		RETURN_FALSE;
	}
",1
Detect whether the following code contains vulnerabilities.,"MagickExport MagickBooleanType IsMonochromeImage(const Image *image,
  ExceptionInfo *exception)
{
  assert(image != (Image *) NULL);
  assert(image->signature == MagickSignature);
  if (image->type == BilevelType)
    return(MagickTrue);
  return(MagickFalse);
}
",0
Detect whether the following code contains vulnerabilities.,"  void HandleCompleteLogin(const base::ListValue* args) {
#if defined(OS_CHROMEOS)
    oauth2_delegate_.reset(new InlineLoginUIOAuth2Delegate(web_ui()));
    oauth2_token_fetcher_.reset(new chromeos::OAuth2TokenFetcher(
        oauth2_delegate_.get(), profile_->GetRequestContext()));
    oauth2_token_fetcher_->StartExchangeFromCookies();
#elif !defined(OS_ANDROID)
    const base::DictionaryValue* dict = NULL;
    string16 email;
    string16 password;
    if (!args->GetDictionary(0, &dict) || !dict ||
        !dict->GetString(""email"", &email) ||
        !dict->GetString(""password"", &password)) {
      NOTREACHED();
      return;
    }

    new OneClickSigninSyncStarter(
        profile_, NULL, ""0"" /* session_index 0 for the default user */,
         UTF16ToASCII(email), UTF16ToASCII(password),
         OneClickSigninSyncStarter::SYNC_WITH_DEFAULT_SETTINGS,
         true /* force_same_tab_navigation */,
        OneClickSigninSyncStarter::NO_CONFIRMATION);
     web_ui()->CallJavascriptFunction(""inline.login.closeDialog"");
 #endif
   }
",1
Detect whether the following code contains vulnerabilities.,"bool OmniboxViewViews::IsImeShowingPopup() const {
#if defined(OS_CHROMEOS)
  return ime_candidate_window_open_;
#else
  const views::InputMethod* input_method = this->GetInputMethod();
  return input_method && input_method->IsCandidatePopupOpen();
#endif
}
",0
Detect whether the following code contains vulnerabilities.,"xfs_handlereq_to_dentry(
	struct file		*parfilp,
	xfs_fsop_handlereq_t	*hreq)
{
	return xfs_handle_to_dentry(parfilp, hreq->ihandle, hreq->ihandlen);
}
",0
Detect whether the following code contains vulnerabilities.,"void RunCallbacksWithDisabled(LogoCallbacks callbacks) {
  if (callbacks.on_cached_encoded_logo_available) {
    std::move(callbacks.on_cached_encoded_logo_available)
        .Run(LogoCallbackReason::DISABLED, base::nullopt);
  }
  if (callbacks.on_cached_decoded_logo_available) {
    std::move(callbacks.on_cached_decoded_logo_available)
        .Run(LogoCallbackReason::DISABLED, base::nullopt);
  }
  if (callbacks.on_fresh_encoded_logo_available) {
    std::move(callbacks.on_fresh_encoded_logo_available)
        .Run(LogoCallbackReason::DISABLED, base::nullopt);
  }
  if (callbacks.on_fresh_decoded_logo_available) {
    std::move(callbacks.on_fresh_decoded_logo_available)
        .Run(LogoCallbackReason::DISABLED, base::nullopt);
  }
}
",1
Detect whether the following code contains vulnerabilities.," static int sgi_clock_set(clockid_t clockid, struct timespec *tp)
 {
 
 	u64 nsec;
	u64 rem;
 
 	nsec = rtc_time() * sgi_clock_period;
 
	sgi_clock_offset.tv_sec = tp->tv_sec - div_long_long_rem(nsec, NSEC_PER_SEC, &rem);
 
 	if (rem <= tp->tv_nsec)
 		sgi_clock_offset.tv_nsec = tp->tv_sec - rem;
	else {
		sgi_clock_offset.tv_nsec = tp->tv_sec + NSEC_PER_SEC - rem;
		sgi_clock_offset.tv_sec--;
	}
	return 0;
}
",1
Detect whether the following code contains vulnerabilities.,"static int ssl3_read_internal(SSL *s, void *buf, int len, int peek)
	{
	int ret;
	
	clear_sys_error();
	if (s->s3->renegotiate) ssl3_renegotiate_check(s);
	s->s3->in_read_app_data=1;
	ret=s->method->ssl_read_bytes(s,SSL3_RT_APPLICATION_DATA,buf,len,peek);
	if ((ret == -1) && (s->s3->in_read_app_data == 2))
		{
		/* ssl3_read_bytes decided to call s->handshake_func, which
		 * called ssl3_read_bytes to read handshake data.
		 * However, ssl3_read_bytes actually found application data
		 * and thinks that application data makes sense here; so disable
		 * handshake processing and try to read application data again. */
		s->in_handshake++;
		ret=s->method->ssl_read_bytes(s,SSL3_RT_APPLICATION_DATA,buf,len,peek);
		s->in_handshake--;
		}
	else
		s->s3->in_read_app_data=0;

	return(ret);
	}
",0
Detect whether the following code contains vulnerabilities.,"static void withActiveWindowAndFirstWindowAttributeAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE(""Blink"", ""DOMGetter"");
    TestObjectV8Internal::withActiveWindowAndFirstWindowAttributeAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE(""V8"", ""V8Execution"");
}
",0
Detect whether the following code contains vulnerabilities.,"static int unix_accept(struct socket *sock, struct socket *newsock, int flags)
{
	struct sock *sk = sock->sk;
	struct sock *tsk;
	struct sk_buff *skb;
	int err;

	err = -EOPNOTSUPP;
	if (sock->type != SOCK_STREAM && sock->type != SOCK_SEQPACKET)
		goto out;

	err = -EINVAL;
	if (sk->sk_state != TCP_LISTEN)
		goto out;

	/* If socket state is TCP_LISTEN it cannot change (for now...),
	 * so that no locks are necessary.
	 */

	skb = skb_recv_datagram(sk, 0, flags&O_NONBLOCK, &err);
	if (!skb) {
		/* This means receive shutdown. */
		if (err == 0)
			err = -EINVAL;
		goto out;
	}

	tsk = skb->sk;
	skb_free_datagram(sk, skb);
	wake_up_interruptible(&unix_sk(sk)->peer_wait);

	/* attach accepted sock to socket */
	unix_state_lock(tsk);
	newsock->state = SS_CONNECTED;
	sock_graft(tsk, newsock);
	unix_state_unlock(tsk);
	return 0;

out:
	return err;
}
",0
Detect whether the following code contains vulnerabilities.,"static noinline void key_gc_unused_keys(struct list_head *keys)
{
	while (!list_empty(keys)) {
		struct key *key =
			list_entry(keys->next, struct key, graveyard_link);
		list_del(&key->graveyard_link);

		kdebug(""- %u"", key->serial);
		key_check(key);

		security_key_free(key);

		/* deal with the user's key tracking and quota */
		if (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {
			spin_lock(&key->user->lock);
			key->user->qnkeys--;
			key->user->qnbytes -= key->quotalen;
			spin_unlock(&key->user->lock);
		}

		atomic_dec(&key->user->nkeys);
 		if (test_bit(KEY_FLAG_INSTANTIATED, &key->flags))
 			atomic_dec(&key->user->nikeys);
 
		key_user_put(key->user);
 		/* now throw away the key memory */
 		if (key->type->destroy)
 			key->type->destroy(key);
 
 		kfree(key->description);
 
 #ifdef KEY_DEBUGGING
		key->magic = KEY_DEBUG_MAGIC_X;
#endif
		kmem_cache_free(key_jar, key);
	}
}
",1
Detect whether the following code contains vulnerabilities.," InterstitialPage* WebContentsImpl::GetInterstitialPage() const {
  return GetRenderManager()->interstitial_page();
 }
",1
Detect whether the following code contains vulnerabilities.,"void GetIntersection (uint64 start1, uint32 length1, uint64 start2, uint64 end2, uint64 *intersectStart, uint32 *intersectLength)
{
	uint64 end1 = start1 + length1 - 1;
	uint64 intersectEnd = (end1 <= end2) ? end1 : end2;

	*intersectStart = (start1 >= start2) ? start1 : start2;
	*intersectLength = (uint32) ((*intersectStart > intersectEnd) ? 0 : intersectEnd + 1 - *intersectStart);

	if (*intersectLength == 0)
		*intersectStart = start1;
}
",0
Detect whether the following code contains vulnerabilities.,"static v8::Handle<v8::Value> convert4Callback(const v8::Arguments& args)
 {
     INC_STATS(""DOM.TestObj.convert4"");
     if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
     TestObj* imp = V8TestObj::toNative(args.Holder());
     EXCEPTION_BLOCK(d*, , V8d::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8d::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
     imp->convert4();
    return v8::Handle<v8::Value>();
}
",1
Detect whether the following code contains vulnerabilities.," static int sh_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) {
 	ut8 op_MSB,op_LSB;
 	int ret;
	if (!data)
 		return 0;
 	memset (op, '\0', sizeof (RAnalOp));
 	op->addr = addr;
 	op->type = R_ANAL_OP_TYPE_UNK;
	op->jump = op->fail = -1;
	op->ptr = op->val = -1;

	op->size = 2;

	op_MSB = anal->big_endian? data[0]: data[1];
	op_LSB = anal->big_endian? data[1]: data[0];
	ret =  first_nibble_decode[(op_MSB>>4) & 0x0F](anal, op, (ut16)(op_MSB<<8 | op_LSB));
	return ret;
}
",1
Detect whether the following code contains vulnerabilities.," bool InputWindowInfo::frameContainsPoint(int32_t x, int32_t y) const {
    return x >= frameLeft && x <= frameRight
            && y >= frameTop && y <= frameBottom;
 }
",1
Detect whether the following code contains vulnerabilities.,"static int crypto_report_akcipher(struct sk_buff *skb, struct crypto_alg *alg)
 {
 	struct crypto_report_akcipher rakcipher;
 
	strlcpy(rakcipher.type, ""akcipher"", sizeof(rakcipher.type));
 
 	if (nla_put(skb, CRYPTOCFGA_REPORT_AKCIPHER,
 		    sizeof(struct crypto_report_akcipher), &rakcipher))
		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}
",1
Detect whether the following code contains vulnerabilities.,"l2tp_framing_type_print(netdissect_options *ndo, const u_char *dat)
 {
 	const uint32_t *ptr = (const uint32_t *)dat;
 
 	if (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_TYPE_ASYNC_MASK) {
 		ND_PRINT((ndo, ""A""));
 	}
	if (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_TYPE_SYNC_MASK) {
		ND_PRINT((ndo, ""S""));
	}
}
",1
Detect whether the following code contains vulnerabilities.,"static void disk_seqf_stop(struct seq_file *seqf, void *v)
{
	struct class_dev_iter *iter = seqf->private;

	/* stop is called even after start failed :-( */
 	if (iter) {
 		class_dev_iter_exit(iter);
 		kfree(iter);
 	}
 }
",1
Detect whether the following code contains vulnerabilities.,"void GpuCommandBufferStub::OnCreateTransferBuffer(int32 size,
                                                   int32 id_request,
                                                   IPC::Message* reply_message) {
   TRACE_EVENT0(""gpu"", ""GpuCommandBufferStub::OnCreateTransferBuffer"");
  if (command_buffer_.get()) {
    int32 id = command_buffer_->CreateTransferBuffer(size, id_request);
    GpuCommandBufferMsg_CreateTransferBuffer::WriteReplyParams(
        reply_message, id);
  } else {
    reply_message->set_reply_error();
  }
  Send(reply_message);
}
",1
Detect whether the following code contains vulnerabilities.,"void f2fs_wait_discard_bios(struct f2fs_sb_info *sbi)
 {
 	__issue_discard_cmd(sbi, false);
 	__drop_discard_cmd(sbi);
	__wait_discard_cmd(sbi, false);
 }
",1
Detect whether the following code contains vulnerabilities.,"void BluetoothDeviceChromeOS::UnregisterAgent() {
  if (!agent_.get())
    return;
  DCHECK(pairing_delegate_);
  DCHECK(pincode_callback_.is_null());
  DCHECK(passkey_callback_.is_null());
  DCHECK(confirmation_callback_.is_null());
  pairing_delegate_->DismissDisplayOrConfirm();
  pairing_delegate_ = NULL;
  agent_.reset();
  VLOG(1) << object_path_.value() << "": Unregistering pairing agent"";
  DBusThreadManager::Get()->GetBluetoothAgentManagerClient()->
      UnregisterAgent(
          dbus::ObjectPath(kAgentPath),
          base::Bind(&base::DoNothing),
          base::Bind(&BluetoothDeviceChromeOS::OnUnregisterAgentError,
                     weak_ptr_factory_.GetWeakPtr()));
}
",1
Detect whether the following code contains vulnerabilities.,"u32 ip_mtu_from_fib_result(struct fib_result *res, __be32 daddr)
{
	struct fib_info *fi = res->fi;
	struct fib_nh *nh = &fi->fib_nh[res->nh_sel];
	struct net_device *dev = nh->nh_dev;
	u32 mtu = 0;

	if (dev_net(dev)->ipv4.sysctl_ip_fwd_use_pmtu ||
	    fi->fib_metrics->metrics[RTAX_LOCK - 1] & (1 << RTAX_MTU))
		mtu = fi->fib_mtu;

	if (likely(!mtu)) {
		struct fib_nh_exception *fnhe;

		fnhe = find_exception(nh, daddr);
		if (fnhe && !time_after_eq(jiffies, fnhe->fnhe_expires))
			mtu = fnhe->fnhe_pmtu;
	}

	if (likely(!mtu))
		mtu = min(READ_ONCE(dev->mtu), IP_MAX_MTU);

	return mtu - lwtunnel_headroom(nh->nh_lwtstate, mtu);
}
",0
Detect whether the following code contains vulnerabilities.,"my_object_str_hash_len (MyObject *obj, GHashTable *table, guint *len, GError **error)
{
  *len = 0;
  g_hash_table_foreach (table, hash_foreach, len);
  return TRUE;
}
",1
Detect whether the following code contains vulnerabilities.,"RTCVoidRequestImpl::~RTCVoidRequestImpl()
{
}
",0
Detect whether the following code contains vulnerabilities.,"StateChangeReason DiscardReasonToStateChangeReason(DiscardReason reason) {
  switch (reason) {
    case DiscardReason::kExternal:
      return StateChangeReason::EXTENSION_INITIATED;
    case DiscardReason::kProactive:
      return StateChangeReason::BROWSER_INITIATED;
    case DiscardReason::kUrgent:
      return StateChangeReason::SYSTEM_MEMORY_PRESSURE;
   }
 }
",0
Detect whether the following code contains vulnerabilities.,"_exsltDateTruncateDate (exsltDateValPtr dt, exsltDateType type)
{
    if (dt == NULL)
        return 1;

    if ((type & XS_TIME) != XS_TIME) {
        dt->value.date.hour = 0;
        dt->value.date.min  = 0;
        dt->value.date.sec  = 0.0;
     }
 
     if ((type & XS_GDAY) != XS_GDAY)
        dt->value.date.day = 0;
 
     if ((type & XS_GMONTH) != XS_GMONTH)
        dt->value.date.mon = 0;
 
     if ((type & XS_GYEAR) != XS_GYEAR)
         dt->value.date.year = 0;

    dt->type = type;

    return 0;
}
",1
Detect whether the following code contains vulnerabilities.,"void sco_connect_cfm(struct hci_conn *hcon, __u8 status)
{
	BT_DBG(""hcon %p bdaddr %pMR status %d"", hcon, &hcon->dst, status);
	if (!status) {
		struct sco_conn *conn;

		conn = sco_conn_add(hcon);
		if (conn)
			sco_conn_ready(conn);
	} else
		sco_conn_del(hcon, bt_to_errno(status));
}
",0
Detect whether the following code contains vulnerabilities.," void LocalFileSystem::fileSystemNotAllowedInternal(
     PassRefPtrWillBeRawPtr<ExecutionContext> context,
    PassRefPtr<CallbackWrapper> callbacks)
 {
     context->postTask(createCrossThreadTask(&reportFailure, callbacks->release(), FileError::ABORT_ERR));
 }
",1
Detect whether the following code contains vulnerabilities.,"GURL DevToolsWindow::GetDevToolsURL(Profile* profile,
                                    const GURL& base_url,
                                    bool shared_worker_frontend,
                                    bool v8_only_frontend,
                                    const std::string& remote_frontend,
                                    bool can_dock) {
  if (base_url.SchemeIs(""data""))
    return base_url;

  std::string frontend_url(
      !remote_frontend.empty() ?
          remote_frontend :
          base_url.is_empty() ? chrome::kChromeUIDevToolsURL : base_url.spec());
  std::string url_string(
      frontend_url +
      ((frontend_url.find(""?"") == std::string::npos) ? ""?"" : ""&""));
  if (shared_worker_frontend)
    url_string += ""&isSharedWorker=true"";
  if (v8_only_frontend)
    url_string += ""&v8only=true"";
  if (remote_frontend.size()) {
    url_string += ""&remoteFrontend=true"";
  } else {
    url_string += ""&remoteBase="" + DevToolsUI::GetRemoteBaseURL().spec();
   }
   if (can_dock)
     url_string += ""&can_dock=true"";
  return GURL(url_string);
 }
",1
Detect whether the following code contains vulnerabilities.,"void servers_init(void)
{
	settings_add_bool(""server"", ""resolve_prefer_ipv6"", FALSE);
	settings_add_bool(""server"", ""resolve_reverse_lookup"", FALSE);
	lookup_servers = servers = NULL;

	signal_add(""chat protocol deinit"", (SIGNAL_FUNC) sig_chat_protocol_deinit);

	servers_reconnect_init();
	servers_setup_init();
}
",0
Detect whether the following code contains vulnerabilities.,"net::BackoffEntry* DataReductionProxyConfigServiceClient::GetBackoffEntry() {
  DCHECK(thread_checker_.CalledOnValidThread());
  return &backoff_entry_;
}
",0
Detect whether the following code contains vulnerabilities.," void MediaInterfaceProxy::CreateCdm(
     media::mojom::ContentDecryptionModuleRequest request) {
   DCHECK(thread_checker_.CalledOnValidThread());
  GetMediaInterfaceFactory()->CreateCdm(std::move(request));
 }
",1
Detect whether the following code contains vulnerabilities.,"static int des_setkey(struct crypto_tfm *tfm, const u8 *key,
		      unsigned int keylen)
{
	struct des_ctx *dctx = crypto_tfm_ctx(tfm);
	u32 *flags = &tfm->crt_flags;
	u32 tmp[DES_EXPKEY_WORDS];
	int ret;

	/* Expand to tmp */
	ret = des_ekey(tmp, key);

	if (unlikely(ret == 0) && (*flags & CRYPTO_TFM_REQ_WEAK_KEY)) {
		*flags |= CRYPTO_TFM_RES_WEAK_KEY;
		return -EINVAL;
	}

	/* Copy to output */
	memcpy(dctx->expkey, tmp, sizeof(dctx->expkey));

	return 0;
}
",0
Detect whether the following code contains vulnerabilities.,"void OomInterventionImpl::ReportMemoryStats(
    OomInterventionMetrics& current_memory) {
  UMA_HISTOGRAM_MEMORY_MB(
      ""Memory.Experimental.OomIntervention.RendererBlinkUsage"",
      current_memory.current_blink_usage_kb / 1024);
  UMA_HISTOGRAM_MEMORY_LARGE_MB(
      ""Memory.Experimental.OomIntervention.""
      ""RendererPrivateMemoryFootprint"",
      current_memory.current_private_footprint_kb / 1024);
  UMA_HISTOGRAM_MEMORY_MB(
      ""Memory.Experimental.OomIntervention.RendererSwapFootprint"",
      current_memory.current_swap_kb / 1024);
  UMA_HISTOGRAM_MEMORY_LARGE_MB(
      ""Memory.Experimental.OomIntervention.RendererVmSize"",
      current_memory.current_vm_size_kb / 1024);

  CrashMemoryMetricsReporterImpl::Instance().WriteIntoSharedMemory(
      current_memory);
}
",0
Detect whether the following code contains vulnerabilities.,"static inline void account_numa_dequeue(struct rq *rq, struct task_struct *p)
{
}
",0
Detect whether the following code contains vulnerabilities.,"static uint64_t ahci_mem_read_32(void *opaque, hwaddr addr)
{
    AHCIState *s = opaque;
    uint32_t val = 0;

    if (addr < AHCI_GENERIC_HOST_CONTROL_REGS_MAX_ADDR) {
        switch (addr) {
        case HOST_CAP:
            val = s->control_regs.cap;
            break;
        case HOST_CTL:
            val = s->control_regs.ghc;
            break;
        case HOST_IRQ_STAT:
            val = s->control_regs.irqstatus;
            break;
        case HOST_PORTS_IMPL:
            val = s->control_regs.impl;
            break;
        case HOST_VERSION:
            val = s->control_regs.version;
            break;
        }

        DPRINTF(-1, ""(addr 0x%08X), val 0x%08X\n"", (unsigned) addr, val);
    } else if ((addr >= AHCI_PORT_REGS_START_ADDR) &&
               (addr < (AHCI_PORT_REGS_START_ADDR +
                (s->ports * AHCI_PORT_ADDR_OFFSET_LEN)))) {
        val = ahci_port_read(s, (addr - AHCI_PORT_REGS_START_ADDR) >> 7,
                             addr & AHCI_PORT_ADDR_OFFSET_MASK);
    }

    return val;
}
",0
Detect whether the following code contains vulnerabilities.," const CuePoint* Cues::GetLast() const {
  if (m_cue_points == NULL)
     return NULL;
 
  if (m_count <= 0)
    return NULL;
#if 0
    LoadCuePoint();  //init cues
    const size_t count = m_count + m_preload_count;
    if (count == 0)  //weird
        return NULL;
    const size_t index = count - 1;
    CuePoint* const* const pp = m_cue_points;
    assert(pp);
    CuePoint* const pCP = pp[index];
    assert(pCP);
    pCP->Load(m_pSegment->m_pReader);
    assert(pCP->GetTimeCode() >= 0);
#else
   const long index = m_count - 1;
 
   CuePoint* const* const pp = m_cue_points;
  assert(pp);
 
   CuePoint* const pCP = pp[index];
  assert(pCP);
  assert(pCP->GetTimeCode() >= 0);
#endif
 
   return pCP;
 }
",1
Detect whether the following code contains vulnerabilities.," void HTMLImportsController::Dispose() {
  for (const auto& loader : loaders_)
    loader->Dispose();
  loaders_.clear();
 
   if (root_) {
     root_->Dispose();
    root_.Clear();
  }
}
",1
Detect whether the following code contains vulnerabilities.," int mif_validate(jas_stream_t *in)
 {
	uchar buf[MIF_MAGICLEN];
 	uint_fast32_t magic;
 	int i;
 	int n;

	assert(JAS_STREAM_MAXPUTBACK >= MIF_MAGICLEN);

	/* Read the validation data (i.e., the data used for detecting
	  the format). */
	if ((n = jas_stream_read(in, buf, MIF_MAGICLEN)) < 0) {
		return -1;
	}

	/* Put the validation data back onto the stream, so that the
	  stream position will not be changed. */
	for (i = n - 1; i >= 0; --i) {
		if (jas_stream_ungetc(in, buf[i]) == EOF) {
			return -1;
		}
	}

	/* Was enough data read? */
	if (n < MIF_MAGICLEN) {
		return -1;
	}

	/* Compute the signature value. */
	magic = (JAS_CAST(uint_fast32_t, buf[0]) << 24) |
	  (JAS_CAST(uint_fast32_t, buf[1]) << 16) |
	  (JAS_CAST(uint_fast32_t, buf[2]) << 8) |
	  buf[3];

	/* Ensure that the signature is correct for this format. */
	if (magic != MIF_MAGIC) {
		return -1;
	}

	return 0;
}
",1
Detect whether the following code contains vulnerabilities.,"    DictionaryValue* ToValue() const {
      DictionaryValue* value = new DictionaryValue();
      value->SetInteger(""totalCount"", total_count);
      value->SetString(""payload"", payload);
      return value;
    }
",0
