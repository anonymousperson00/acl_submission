function,label
"    public function testLogout()
    {
        $sessionMock = $this->getMockBuilder('\Box_Session')
            ->disableOriginalConstructor()
            ->getMock();

        $di = new \Pimple\Container();
        $di['session'] = $sessionMock;
        $di['logger'] = new \Box_Log();

        $adminApi = new \Box\Mod\Profile\Api\Admin();
        $adminApi->setDi($di);
        $result = $adminApi->logout();
        $this->assertTrue($result);
    }",1
"function mime_array(){
	return array(
		""323"" => ""text/h323"",
		""3gp"" => ""video/3gpp"",
		""acx"" => ""application/internet-property-stream"",
		""ai""  => ""application/postscript"",
		""aif"" => ""audio/x-aiff"",
		""aifc"" => ""audio/x-aiff"",
		""aiff"" => ""audio/x-aiff"",
		""asf"" => ""video/x-ms-asf"",
		""asr"" => ""video/x-ms-asf"",
		""asx"" => ""video/x-ms-asf"",
		""au"" => ""audio/basic"",
		""avi"" => ""video/x-msvideo"",
		""axs"" => ""application/olescript"",
		""bas"" => ""text/plain"",
		""bcpio"" => ""application/x-bcpio"",
		""bin"" => ""application/octet-stream"",
		""bmp"" => ""image/bmp"",
		""c"" => ""text/plain"",
		""cat"" => ""application/vnd.ms-pkiseccat"",
		""cdf"" => ""application/x-cdf"",
		""cer"" => ""application/x-x509-ca-cert"",
		""class"" => ""application/octet-stream"",
		""clp"" => ""application/x-msclip"",
		""cmx"" => ""image/x-cmx"",
		""cod"" => ""image/cis-cod"",
		""cpio"" => ""application/x-cpio"",
		""crd"" => ""application/x-mscardfile"",
		""crl"" => ""application/pkix-crl"",
		""crt"" => ""application/x-x509-ca-cert"",
		""csh"" => ""application/x-csh"",
		""css"" => ""text/css"",
		""dcr"" => ""application/x-director"",
		""der"" => ""application/x-x509-ca-cert"",
		""dir"" => ""application/x-director"",
		""dll"" => ""application/x-msdownload"",
		""dms"" => ""application/octet-stream"",
		""doc"" => ""application/msword"",
		""docx"" => ""application/msword"",
		""dot"" => ""application/msword"",
		""dvi"" => ""application/x-dvi"",
		""dxr"" => ""application/x-director"",
		""eps"" => ""application/postscript"",
		""etx"" => ""text/x-setext"",
		""evy"" => ""application/envoy"",
		""exe"" => ""application/octet-stream"",
		""fif"" => ""application/fractals"",
		""flr"" => ""x-world/x-vrml"",
		""flv"" => ""video/x-flv"",
		""f4v"" => ""video/x-flv"",
		// ""f4v"" => ""application/octet-stream"",
		""gif"" => ""image/gif"",
		""gtar"" => ""application/x-gtar"",
		""gz"" => ""application/x-gzip"",
		""h"" => ""text/plain"",
		""hdf"" => ""application/x-hdf"",
		""hlp"" => ""application/winhlp"",
		""hqx"" => ""application/mac-binhex40"",
		""hta"" => ""application/hta"",
		""htc"" => ""text/x-component"",
		""htm"" => ""text/html"",
		""html"" => ""text/html"",
		""htt"" => ""text/webviewhtml"",
		""ico"" => ""image/x-icon"",
		""ief"" => ""image/ief"",
		""iii"" => ""application/x-iphone"",
		""ins"" => ""application/x-internet-signup"",
		""isp"" => ""application/x-internet-signup"",
		""jfif"" => ""image/pipeg"",
		""jpg"" => ""image/jpeg"",
		""jpeg"" => ""image/jpeg"",
		""jpe"" => ""image/jpeg"",
		""js"" => ""application/javascript"",
		""json"" => ""application/json"",
		""latex"" => ""application/x-latex"",
		""lha"" => ""application/octet-stream"",
		""lsf"" => ""video/x-la-asf"",
		""lsx"" => ""video/x-la-asf"",
		""lzh"" => ""application/octet-stream"",
		""m13"" => ""application/x-msmediaview"",
		""m14"" => ""application/x-msmediaview"",
		""m3u"" => ""audio/x-mpegurl"",
		'm4a' => ""audio/mp4"",
		'm4v' => ""audio/mp4"",
		""man"" => ""application/x-troff-man"",
		""mdb"" => ""application/x-msaccess"",
		""me"" => ""application/x-troff-me"",
		""mht"" => ""message/rfc822"",
		""mhtml"" => ""message/rfc822"",
		""mid"" => ""audio/mid"",
		""mka"" => ""audio/x-matroska"",
		""mkv"" => ""video/x-matroska"",
		""mny"" => ""application/x-msmoney"",
		""mov"" => ""video/quicktime"",
		""movie"" => ""video/x-sgi-movie"",
		""mp2"" => ""video/mpeg"",
		""mp3"" => ""audio/mpeg"",
		""mp4"" => ""video/mp4"",
		""mp4v"" => ""video/x-m4v"",
		""mpa"" => ""video/mpeg"",
		""mpe"" => ""video/mpeg"",
		""mpeg"" => ""video/mpeg"",
		""mpg"" => ""video/mpeg"",
		""mpp"" => ""application/vnd.ms-project"",
		""mpv2"" => ""video/mpeg"",
		""ms"" => ""application/x-troff-ms"",
		""mvb"" => ""application/x-msmediaview"",
		""nws"" => ""message/rfc822"",
		""oda"" => ""application/oda"",
		""ogg"" => ""audio/ogg"",
		""oga"" => ""audio/ogg"",
		""ogv"" => ""audio/ogg"",
		""p10"" => ""application/pkcs10"",
		""p12"" => ""application/x-pkcs12"",
		""p7b"" => ""application/x-pkcs7-certificates"",
		""p7c"" => ""application/x-pkcs7-mime"",
		""p7m"" => ""application/x-pkcs7-mime"",
		""p7r"" => ""application/x-pkcs7-certreqresp"",
		""p7s"" => ""application/x-pkcs7-signature"",
		""pbm"" => ""image/x-portable-bitmap"",
		""pdf"" => ""application/pdf"",
		""pfx"" => ""application/x-pkcs12"",
		""pgm"" => ""image/x-portable-graymap"",
		""pko"" => ""application/ynd.ms-pkipko"",
		""pma"" => ""application/x-perfmon"",
		""pmc"" => ""application/x-perfmon"",
		""pml"" => ""application/x-perfmon"",
		""pmr"" => ""application/x-perfmon"",
		""pmw"" => ""application/x-perfmon"",
		""png"" => ""image/png"",
		""pnm"" => ""image/x-portable-anymap"",
		""pot,"" => ""application/vnd.ms-powerpoint"",
		""ppm"" => ""image/x-portable-pixmap"",
		""pps"" => ""application/vnd.ms-powerpoint"",
		""ppt"" => ""application/vnd.ms-powerpoint"",
		""pptx"" => ""application/vnd.ms-powerpoint"",
		""plist""=> ""text/xml"",
		""ipa"" =>""application/octet-stream"",
		""prf"" => ""application/pics-rules"",
		""ps"" => ""application/postscript"",
		""pub"" => ""application/x-mspublisher"",
		""qt"" => ""video/quicktime"",
		""ra"" => ""audio/x-pn-realaudio"",
		""ram"" => ""audio/x-pn-realaudio"",
		""ras"" => ""image/x-cmu-raster"",
		""rgb"" => ""image/x-rgb"",
		""rmi"" => ""audio/mid"",
		""roff"" => ""application/x-troff"",
		""rtf"" => ""application/rtf"",
		""rtx"" => ""text/richtext"",
		""scd"" => ""application/x-msschedule"",
		""sct"" => ""text/scriptlet"",
		""setpay"" => ""application/set-payment-initiation"",
		""setreg"" => ""application/set-registration-initiation"",
		""sh"" => ""application/x-sh"",
		""shar"" => ""application/x-shar"",
		""sit"" => ""application/x-stuffit"",
		""snd"" => ""audio/basic"",
		""spc"" => ""application/x-pkcs7-certificates"",
		""spl"" => ""application/futuresplash"",
		""src"" => ""application/x-wais-source"",
		""sst"" => ""application/vnd.ms-pkicertstore"",
		""stl"" => ""application/vnd.ms-pkistl"",
		""stm"" => ""text/html"",
		""svg"" => ""image/svg+xml"",
		""sv4cpio"" => ""application/x-sv4cpio"",
		""sv4crc"" => ""application/x-sv4crc"",
		""swf"" => ""application/x-shockwave-flash"",
		""t"" => ""application/x-troff"",
		""tar"" => ""application/x-tar"",
		""tcl"" => ""application/x-tcl"",
		""tex"" => ""application/x-tex"",
		""texi"" => ""application/x-texinfo"",
		""texinfo"" => ""application/x-texinfo"",
		""tgz"" => ""application/x-compressed"",
		""tif"" => ""image/tiff"",
		""tiff"" => ""image/tiff"",
		""tr"" => ""application/x-troff"",
		""trm"" => ""application/x-msterminal"",
		""tsv"" => ""text/tab-separated-values"",
		""txt"" => ""text/plain"",
		""uls"" => ""text/iuls"",
		""ustar"" => ""application/x-ustar"",
		""vcf"" => ""text/x-vcard"",
		""vrml"" => ""x-world/x-vrml"",
		""wav"" => ""audio/wav"",
		""wcm"" => ""application/vnd.ms-works"",
		""wdb"" => ""application/vnd.ms-works"",
		""webm"" => ""video/webm"",
		""webmv"" => ""video/webm"",
		""wks"" => ""application/vnd.ms-works"",
		""wmf"" => ""application/x-msmetafile"",
		""wps"" => ""application/vnd.ms-works"",
		""wri"" => ""application/x-mswrite"",
		""wrl"" => ""x-world/x-vrml"",
		""wrz"" => ""x-world/x-vrml"",
		""xaf"" => ""x-world/x-vrml"",
		""xbm"" => ""image/x-xbitmap"",
		""xla"" => ""application/vnd.ms-excel"",
		""xlc"" => ""application/vnd.ms-excel"",
		""xlm"" => ""application/vnd.ms-excel"",
		""xls"" => ""application/vnd.ms-excel"",
		""xlsx"" => ""application/vnd.ms-excel"",
		""xlt"" => ""application/vnd.ms-excel"",
		""xlw"" => ""application/vnd.ms-excel"",
		""xof"" => ""x-world/x-vrml"",
		""xpm"" => ""image/x-xpixmap"",
		""xwd"" => ""image/x-xwindowdump"",
		""z"" => ""application/x-compress"",
		""zip"" => ""application/zip""
	);
}",1
"	public function testValidatePasswordHttpCode()
	{
		$user = new User([
			'email'    => 'test@getkirby.com',
			'password' => User::hashPassword('correct-horse-battery-staple')
		]);

		$caught = 0;

		try {
			$user->validatePassword('short');
		} catch (\Kirby\Exception\InvalidArgumentException $e) {
			$this->assertSame(
				'Please enter a valid password. Passwords must be at least 8 characters long.',
				$e->getMessage()
			);
			$this->assertSame(400, $e->getHttpCode());
			$caught++;
		}

		try {
			$user->validatePassword(str_repeat('long', 300));
		} catch (\Kirby\Exception\InvalidArgumentException $e) {
			$this->assertSame(
				'Please enter a valid password. Passwords must not be longer than 1000 characters.',
				$e->getMessage()
			);
			$this->assertSame(400, $e->getHttpCode());
			$caught++;
		}

		try {
			$user->validatePassword('longbutinvalid');
		} catch (\Kirby\Exception\InvalidArgumentException $e) {
			$this->assertSame('Wrong password', $e->getMessage());
			$this->assertSame(401, $e->getHttpCode());
			$caught++;
		}

		$this->assertSame(3, $caught);
	}",0
"            $this->grid[$key] = is_array($data) ? array_merge(($this->grid[$key] ?? []), $data) : $data;
        }",0
"function make_sugar_config(&$sugar_config)
{
    /* used to convert non-array config.php file to array format */
    global $admin_export_only;
    global $cache_dir;
    global $calculate_response_time;
    global $create_default_user;
    global $dateFormats;
    global $dbconfig;
    global $dbconfigoption;
    global $default_action;
    global $default_charset;
    global $default_currency_name;
    global $default_currency_symbol;
    global $default_currency_iso4217;
    global $defaultDateFormat;
    global $default_language;
    global $default_module;
    global $default_password;
    global $default_theme;
    global $defaultTimeFormat;
    global $default_user_is_admin;
    global $default_user_name;
    global $disable_export;
    global $disable_persistent_connections;
    global $display_email_template_variable_chooser;
    global $display_inbound_email_buttons;
    global $google_auth_json;
    global $history_max_viewed;
    global $host_name;
    global $import_dir;
    global $languages;
    global $list_max_entries_per_page;
    global $lock_default_user_name;
    global $log_memory_usage;
    global $nameFormats;
    global $requireAccounts;
    global $RSS_CACHE_TIME;
    global $session_dir;
    global $site_URL;
    global $site_url;
    global $sugar_version;
    global $timeFormats;
    global $tmp_dir;
    global $translation_string_prefix;
    global $unique_key;
    global $upload_badext;
    global $upload_dir;
    global $upload_maxsize;
    global $import_max_execution_time;
    global $list_max_entries_per_subpanel;
    global $list_max_entries_per_modal;
    global $subpanel_max_height;
    global $listview_max_height;
    global $passwordsetting;

    // assumes the following variables must be set:
    // $dbconfig, $dbconfigoption, $cache_dir,  $session_dir, $site_URL, $upload_dir

    $sugar_config = array(
        'admin_export_only' => empty($admin_export_only) ? false : $admin_export_only,
        'export_delimiter' => empty($export_delimiter) ? ',' : $export_delimiter,
        'cache_dir' => empty($cache_dir) ? 'cache/' : $cache_dir,
        'calculate_response_time' => empty($calculate_response_time) ? true : $calculate_response_time,
        'create_default_user' => empty($create_default_user) ? false : $create_default_user,
        'chartEngine' => 'Jit',
        'pdf' => [
            'defaultEngine' => 'TCPDFEngine'
        ],
        'date_formats' => empty($dateFormats) ? array(
            'Y-m-d' => '2010-12-23',
            'd-m-Y' => '23-12-2010',
            'm-d-Y' => '12-23-2010',
            'Y/m/d' => '2010/12/23',
            'd/m/Y' => '23/12/2010',
            'm/d/Y' => '12/23/2010',
            'Y.m.d' => '2010.12.23',
            'd.m.Y' => '23.12.2010',
            'm.d.Y' => '12.23.2010',
        ) : $dateFormats,
        'dbconfig' => $dbconfig, // this must be set!!
        'dbconfigoption' => $dbconfigoption, // this must be set!!
        'default_action' => empty($default_action) ? 'index' : $default_action,
        'default_charset' => empty($default_charset) ? 'UTF-8' : $default_charset,
        'default_currency_name' => empty($default_currency_name) ? 'US Dollar' : $default_currency_name,
        'default_currency_symbol' => empty($default_currency_symbol) ? '$' : $default_currency_symbol,
        'default_currency_iso4217' => empty($default_currency_iso4217) ? '$' : $default_currency_iso4217,
        'default_date_format' => empty($defaultDateFormat) ? 'm/d/Y' : $defaultDateFormat,
        'default_locale_name_format' => empty($defaultNameFormat) ? 's f l' : $defaultNameFormat,
        'default_export_charset' => 'UTF-8',
        'default_language' => empty($default_language) ? 'en_us' : $default_language,
        'default_module' => empty($default_module) ? 'Home' : $default_module,
        'default_password' => empty($default_password) ? '' : $default_password,
        'default_permissions' => array(
            'dir_mode' => 02770,
            'file_mode' => 0755,
            'chown' => '',
            'chgrp' => '',
        ),
        'subpanel_pagination_type' => 'pagination',
        'subpanel_max_height' => empty($subpanel_max_height) ? 620 : $subpanel_max_height,
        'listview_pagination_type' => 'pagination',
        'listview_max_height' => empty($listview_max_height) ? 0 : $listview_max_height,
        'default_theme' => empty($default_theme) ? 'SuiteP' : $default_theme,
        'default_time_format' => empty($defaultTimeFormat) ? 'h:ia' : $defaultTimeFormat,
        'default_user_is_admin' => empty($default_user_is_admin) ? false : $default_user_is_admin,
        'default_user_name' => empty($default_user_name) ? '' : $default_user_name,
        'disable_export' => empty($disable_export) ? false : $disable_export,
        'disable_persistent_connections' => empty($disable_persistent_connections) ? false : $disable_persistent_connections,
        'display_email_template_variable_chooser' => empty($display_email_template_variable_chooser) ? false : $display_email_template_variable_chooser,
        'display_inbound_email_buttons' => empty($display_inbound_email_buttons) ? false : $display_inbound_email_buttons,
        'google_auth_json' => empty($google_auth_json) ? '' : $google_auth_json,
        'history_max_viewed' => empty($history_max_viewed) ? 50 : $history_max_viewed,
        'host_name' => empty($host_name) ? 'localhost' : $host_name,
        'import_dir' => $import_dir, // this must be set!!
        'import_max_records_per_file' => 100,
        'import_max_records_total_limit' => '',
        'languages' => empty($languages) ? array('en_us' => 'English (US)') : $languages,
        'list_max_entries_per_page' => empty($list_max_entries_per_page) ? 20 : $list_max_entries_per_page,
        'list_max_entries_per_subpanel' => empty($list_max_entries_per_subpanel) ? 10 : $list_max_entries_per_subpanel,
        'list_max_entries_per_modal' => empty($list_max_entries_per_modal) ? 10 : $list_max_entries_per_modal,
        'lock_default_user_name' => empty($lock_default_user_name) ? false : $lock_default_user_name,
        'log_memory_usage' => empty($log_memory_usage) ? false : $log_memory_usage,
        'name_formats' => empty($nameFormats) ? array(
            's f l' => 's f l',
            'f l' => 'f l',
            's l' => 's l',
            'l, s f' => 'l, s f',
            'l, f' => 'l, f',
            's l, f' => 's l, f',
            'l s f' => 'l s f',
            'l f s' => 'l f s',
        ) : $nameFormats,
        'oauth2_encryption_key' => base64_encode(random_bytes(32)),
        'portal_view' => 'single_user',
        'resource_management' => array(
            'special_query_limit' => 50000,
            'special_query_modules' => array('AOR_Reports', 'Export', 'Import', 'Administration', 'Sync'),
            'default_limit' => 1000,
        ),
        'require_accounts' => empty($requireAccounts) ? true : $requireAccounts,
        'rss_cache_time' => empty($RSS_CACHE_TIME) ? '10800' : $RSS_CACHE_TIME,
        'session_dir' => $session_dir, // this must be set!!
        'site_url' => empty($site_URL) ? $site_url : $site_URL, // this must be set!!
        'showDetailData' => true, // if true, read-only ACL fields will still appear on EditViews as non-editable
        'showThemePicker' => true,
        'sugar_version' => empty($sugar_version) ? 'unknown' : $sugar_version,
        'time_formats' => empty($timeFormats) ? array(
            'H:i' => '23:00',
            'h:ia' => '11:00 pm',
            'h:iA' => '11:00PM',
            'H.i' => '23.00',
            'h.ia' => '11.00 pm',
            'h.iA' => '11.00PM',
        ) : $timeFormats,
        'tmp_dir' => $tmp_dir, // this must be set!!
        'translation_string_prefix' => empty($translation_string_prefix) ? false : $translation_string_prefix,
        'unique_key' => empty($unique_key) ? md5(create_guid()) : $unique_key,
        'upload_badext' => empty($upload_badext) ? array(
            'php',
            'php3',
            'php4',
            'php5',
            'php6',
            'php7',
            'php8',
            'pl',
            'cgi',
            'py',
            'asp',
            'cfm',
            'js',
            'vbs',
            'html',
            'htm',
            'phtml',
            'phar',
        ) : $upload_badext,
        'valid_image_ext' => [
            'gif',
            'png',
            'jpg',
            'jpeg',
            'svg'
        ],
        'upload_dir' => $upload_dir, // this must be set!!
        'upload_maxsize' => empty($upload_maxsize) ? 30000000 : $upload_maxsize,
        'allowed_preview' => [
            'pdf',
            'gif',
            'png',
            'jpeg',
            'jpg'
        ],
        'import_max_execution_time' => empty($import_max_execution_time) ? 3600 : $import_max_execution_time,
        'lock_homepage' => false,
        'lock_subpanels' => false,
        'max_dashlets_homepage' => 15,
        'dashlet_display_row_options' => array('1', '3', '5', '10'),
        'default_max_tabs' => empty($max_tabs) ? 8 : $max_tabs,
        'default_subpanel_tabs' => empty($subpanel_tabs) ? true : $subpanel_tabs,
        'default_subpanel_links' => empty($subpanel_links) ? false : $subpanel_links,
        'default_swap_last_viewed' => empty($swap_last_viewed) ? false : $swap_last_viewed,
        'default_swap_shortcuts' => empty($swap_shortcuts) ? false : $swap_shortcuts,
        'default_navigation_paradigm' => empty($navigation_paradigm) ? 'm' : $navigation_paradigm,
        'default_call_status' => 'Planned',
        'js_lang_version' => 1,
        'passwordsetting' => empty($passwordsetting) ? array(
            'SystemGeneratedPasswordON' => '',
            'generatepasswordtmpl' => '',
            'lostpasswordtmpl' => '',
            'factoremailtmpl' => '',
            'forgotpasswordON' => true,
            'linkexpiration' => '1',
            'linkexpirationtime' => '30',
            'linkexpirationtype' => '1',
            'systexpiration' => '0',
            'systexpirationtime' => '',
            'systexpirationtype' => '0',
            'systexpirationlogin' => '',
        ) : $passwordsetting,
        'use_sprites' => function_exists('imagecreatetruecolor'),
        'search_wildcard_infront' => false,
        'search_wildcard_char' => '%',
        'jobs' => array(
            'min_retry_interval' => 60, // minimal job retry delay
            'max_retries' => 5, // how many times to retry the job
            'timeout' => 86400, // how long a job may spend as running before being force-failed
            'soft_lifetime' => 7, // how many days until job record will be soft deleted after completion
            'hard_lifetime' => 21, // how many days until job record will be purged from DB
        ),
        'cron' => array(
            'max_cron_jobs' => 10, // max jobs per cron schedule run
            'max_cron_runtime' => 60, // max runtime for cron jobs
            'min_cron_interval' => 30, // minimal interval between cron jobs
        ),
        'strict_id_validation' => false,
        'legacy_email_behaviour' => false,
        'snooze_alert_timer' => 600,
        'default_module_access' => [
            'SecurityGroups' => false,
            'AOW_WorkFlow' => false
        ],
    );
}",0
"    public function testLimit()
    {
        $list = TestObject::get();

        $button = new GridFieldPrintButton();
        $button->setPrintColumns(['Name' => 'My Name']);

        // Get paginated gridfield config
        $config = GridFieldConfig::create()
            ->addComponent(new GridFieldPaginator(10))
            ->addComponent($button);
        $gridField = new GridField('testfield', 'testfield', $list, $config);
        /** @skipUpgrade */
        new Form(Controller::curr(), 'Form', new FieldList($gridField), new FieldList());

        // Printed data should ignore pagination limit
        $printData = $button->generatePrintData($gridField);
        $rows = $printData->ItemRows;
        $this->assertEquals(42, $rows->count());
    }",1
"    public function getSiteName()
    {
        return $this->siteName;
    }",1
"function User_view_worklog(Worklog $worklog, $admin_user_worklog_privilege)
{
    $actions = '';
    if ($admin_user_worklog_privilege) {
        $actions = table_buttons([
            button(
                url('/admin/user/' . $worklog->user->id . '/worklog/' . $worklog->id),
                icon('pencil') . __('edit'),
                'btn-sm'
            ),
            button(
                url('/admin/user/' . $worklog->user->id . '/worklog/' . $worklog->id . '/delete'),
                icon('trash') . __('delete'),
                'btn-sm'
            ),
        ]);
    }

    return [
        'date'       => icon('calendar-event') . date(__('Y-m-d'), $worklog->worked_at->timestamp),
        'duration'   => sprintf('%.2f', $worklog->hours) . ' h',
        'room'       => '',
        'shift_info' => __('Work log entry'),
        'comment'    => $worklog->comment . '<br>'
            . sprintf(
                __('Added by %s at %s'),
                User_Nick_render($worklog->creator),
                $worklog->created_at->format(__('Y-m-d H:i'))
            ),
        'actions'    => $actions,
    ];
}",1
"    private function getMapping($extnId)
    {
        if (!is_string($extnId)) { // eg. if it's a \phpseclib3\File\ASN1\Element object
            return true;
        }

        if (isset(self::$extensions[$extnId])) {
            return self::$extensions[$extnId];
        }

        switch ($extnId) {
            case 'id-ce-keyUsage':
                return Maps\KeyUsage::MAP;
            case 'id-ce-basicConstraints':
                return Maps\BasicConstraints::MAP;
            case 'id-ce-subjectKeyIdentifier':
                return Maps\KeyIdentifier::MAP;
            case 'id-ce-cRLDistributionPoints':
                return Maps\CRLDistributionPoints::MAP;
            case 'id-ce-authorityKeyIdentifier':
                return Maps\AuthorityKeyIdentifier::MAP;
            case 'id-ce-certificatePolicies':
                return Maps\CertificatePolicies::MAP;
            case 'id-ce-extKeyUsage':
                return Maps\ExtKeyUsageSyntax::MAP;
            case 'id-pe-authorityInfoAccess':
                return Maps\AuthorityInfoAccessSyntax::MAP;
            case 'id-ce-subjectAltName':
                return Maps\SubjectAltName::MAP;
            case 'id-ce-subjectDirectoryAttributes':
                return Maps\SubjectDirectoryAttributes::MAP;
            case 'id-ce-privateKeyUsagePeriod':
                return Maps\PrivateKeyUsagePeriod::MAP;
            case 'id-ce-issuerAltName':
                return Maps\IssuerAltName::MAP;
            case 'id-ce-policyMappings':
                return Maps\PolicyMappings::MAP;
            case 'id-ce-nameConstraints':
                return Maps\NameConstraints::MAP;

            case 'netscape-cert-type':
                return Maps\netscape_cert_type::MAP;
            case 'netscape-comment':
                return Maps\netscape_comment::MAP;
            case 'netscape-ca-policy-url':
                return Maps\netscape_ca_policy_url::MAP;

            // since id-qt-cps isn't a constructed type it will have already been decoded as a string by the time it gets
            // back around to asn1map() and we don't want it decoded again.
            //case 'id-qt-cps':
            //    return Maps\CPSuri::MAP;
            case 'id-qt-unotice':
                return Maps\UserNotice::MAP;

            // the following OIDs are unsupported but we don't want them to give notices when calling saveX509().
            case 'id-pe-logotype': // http://www.ietf.org/rfc/rfc3709.txt
            case 'entrustVersInfo':
            // http://support.microsoft.com/kb/287547
            case '1.3.6.1.4.1.311.20.2': // szOID_ENROLL_CERTTYPE_EXTENSION
            case '1.3.6.1.4.1.311.21.1': // szOID_CERTSRV_CA_VERSION
            // ""SET Secure Electronic Transaction Specification""
            // http://www.maithean.com/docs/set_bk3.pdf
            case '2.23.42.7.0': // id-set-hashedRootKey
            // ""Certificate Transparency""
            // https://tools.ietf.org/html/rfc6962
            case '1.3.6.1.4.1.11129.2.4.2':
            // ""Qualified Certificate statements""
            // https://tools.ietf.org/html/rfc3739#section-3.2.6
            case '1.3.6.1.5.5.7.1.3':
                return true;

            // CSR attributes
            case 'pkcs-9-at-unstructuredName':
                return Maps\PKCS9String::MAP;
            case 'pkcs-9-at-challengePassword':
                return Maps\DirectoryString::MAP;
            case 'pkcs-9-at-extensionRequest':
                return Maps\Extensions::MAP;

            // CRL extensions.
            case 'id-ce-cRLNumber':
                return Maps\CRLNumber::MAP;
            case 'id-ce-deltaCRLIndicator':
                return Maps\CRLNumber::MAP;
            case 'id-ce-issuingDistributionPoint':
                return Maps\IssuingDistributionPoint::MAP;
            case 'id-ce-freshestCRL':
                return Maps\CRLDistributionPoints::MAP;
            case 'id-ce-cRLReasons':
                return Maps\CRLReason::MAP;
            case 'id-ce-invalidityDate':
                return Maps\InvalidityDate::MAP;
            case 'id-ce-certificateIssuer':
                return Maps\CertificateIssuer::MAP;
            case 'id-ce-holdInstructionCode':
                return Maps\HoldInstructionCode::MAP;
            case 'id-at-postalAddress':
                return Maps\PostalAddress::MAP;
        }

        return false;
    }",0
"    public function close()
    {
        $this->server->close();
    }",0
"    public function setSchemes(array|string $schemes)
    {
        $this->schemes = (array) $schemes;
    }",0
"    public function remove($file_path){
        return @unlink($file_path);
    }",1
"    public function enqueue($cancellable)
    {
        if (!\is_object($cancellable) || !\method_exists($cancellable, 'then') || !\method_exists($cancellable, 'cancel')) {
            return;
        }

        $length = \array_push($this->queue, $cancellable);

        if ($this->started && 1 === $length) {
            $this->drain();
        }
    }",0
"    public function getXHRFileSize(){
        if (isset($_SERVER[""CONTENT_LENGTH""])){
            return (int)$_SERVER[""CONTENT_LENGTH""];
        } else {
            return false;
        }
    }",1
"    public function move()
    {
        $task = $this->getTask();

        if ($this->request->isPost()) {
            $values = $this->request->getValues();
            list($valid, ) = $this->taskValidator->validateProjectModification($values);

            if ($valid && $this->taskProjectMoveModel->moveToProject($task['id'],
                                                                $values['project_id'],
                                                                $values['swimlane_id'],
                                                                $values['column_id'],
                                                                $values['category_id'],
                                                                $values['owner_id'])) {
                $this->flash->success(t('Task updated successfully.'));
                return $this->response->redirect($this->helper->url->to('TaskViewController', 'show', array('task_id' => $task['id'])));
            }

            $this->flash->failure(t('Unable to update your task.'));
        }

        return $this->chooseDestination($task, 'task_duplication/move');
    }",1
"    private function messageToResponse($msg)
    {
        $response = new ResponseMessage($msg);
        $actionId = $response->getActionId();
        if (is_null($actionId)) {
            $actionId = $this->lastActionId;
            $response->setActionId($this->lastActionId);
        }
        return $response;
    }",0
"    public function __construct(ExecutorInterface $datagramExecutor, ExecutorInterface $streamExecutor)
    {
        $this->datagramExecutor = $datagramExecutor;
        $this->streamExecutor = $streamExecutor;
    }",0
"    public static function encodeIP($ip)
    {
        return is_string($ip) ?
            inet_pton($ip) :
            inet_pton($ip[0]) . inet_pton($ip[1]);
    }",0
"	private function checkItem($actions){
		$action = strtolower(ACTION);
		if(!isset($actions[$action])) return;
		if(!Session::get(""kodUser"")){show_json(LNG('user.loginFirst'),ERROR_CODE_LOGOUT);}
		$check = $actions[$action];
		if($check['read'] == 'allow'){return $this->checkItemRead($check,$action);}

		$allow = true;
		if($allow && $check['group']){
			$groupID = $this->in[$check['group']];
			$allow   = $this->allowChangeGroup($groupID);
			$adminGroup = $this->userGroupAdmin();
			// 自己为管理员的根部门: 禁用编辑与删除;
			$disableAction = array('admin.group.edit','admin.group.remove');
			if(in_array($action,$disableAction) && in_array($groupID,$adminGroup)){$allow = false;}
		}
		
		$err = $allow ? -1:0;
		if($allow){$allow = $this->userAuthEditCheck();$err=$allow?$err:1;}
		if($allow && $check['user']){ $allow = $this->allowChangeUser($this->in[$check['user']]);$err=$allow?$err:2;}
		if($allow && $check['userRole']){$allow = $this->allowChangeUserRole($this->in[$check['userRole']]);$err=$allow?$err:3;}
		if($allow && $check['roleAuth']){$allow = $this->roleActionAllow($this->in[$check['roleAuth']]);$err=$allow?$err:4;}
		if($allow && $check['groupArray']){$allow = $this->allowChangeGroupArray($check);$err=$allow?$err:5;}
		// pr($err,$allow,$check,$this->in,'GET:',$_REQUEST);exit;
		if($allow) return true;
		$this->checkError($check);
	}",1
"    public function loadCRL($crl, $mode = self::FORMAT_AUTO_DETECT)
    {
        if (is_array($crl) && isset($crl['tbsCertList'])) {
            $this->currentCert = $crl;
            unset($this->signatureSubject);
            return $crl;
        }

        if ($mode != self::FORMAT_DER) {
            $newcrl = ASN1::extractBER($crl);
            if ($mode == self::FORMAT_PEM && $crl == $newcrl) {
                return false;
            }
            $crl = $newcrl;
        }
        $orig = $crl;

        if ($crl === false) {
            $this->currentCert = false;
            return false;
        }

        $decoded = ASN1::decodeBER($crl);

        if (!$decoded) {
            $this->currentCert = false;
            return false;
        }

        $crl = ASN1::asn1map($decoded[0], Maps\CertificateList::MAP);
        if (!isset($crl) || $crl === false) {
            $this->currentCert = false;
            return false;
        }

        $this->signatureSubject = substr($orig, $decoded[0]['content'][0]['start'], $decoded[0]['content'][0]['length']);

        $this->mapInDNs($crl, 'tbsCertList/issuer/rdnSequence');
        if ($this->isSubArrayValid($crl, 'tbsCertList/crlExtensions')) {
            $this->mapInExtensions($crl, 'tbsCertList/crlExtensions');
        }
        if ($this->isSubArrayValid($crl, 'tbsCertList/revokedCertificates')) {
            $rclist_ref = &$this->subArrayUnchecked($crl, 'tbsCertList/revokedCertificates');
            if ($rclist_ref) {
                $rclist = $crl['tbsCertList']['revokedCertificates'];
                foreach ($rclist as $i => $extension) {
                    if ($this->isSubArrayValid($rclist, ""$i/crlEntryExtensions"")) {
                        $this->mapInExtensions($rclist_ref, ""$i/crlEntryExtensions"");
                    }
                }
            }
        }

        $this->currentKeyIdentifier = null;
        $this->currentCert = $crl;

        return $crl;
    }",0
"    private function insertSession($key, $data, $lastAccessed, $expiry)
    {
        //$this->log->debug('Session insert');

        $sql = '
          INSERT INTO `session` (session_id, session_data, session_expiration, lastaccessed, userid, isexpired, useragent, remoteaddr)
            VALUES (:session_id, :session_data, :session_expiration, :lastAccessed, :userId, :expired, :useragent, :remoteaddr)
        ';

        $params = [
            'session_id' => $key,
            'session_data' => $data,
            'session_expiration' => $expiry,
            'lastAccessed' => date('Y-m-d H:i:s', $lastAccessed),
            'userId' => $this->userId,
            'expired' => ($this->expired) ? 1 : 0,
            'useragent' => substr($_SERVER['HTTP_USER_AGENT'], 0, 253),
            'remoteaddr' => $this->getIp()
        ];

        $this->getDb()->update($sql, $params);
    }",1
"    public function testSupports()
    {
        $loader = new FilesystemLoader();
        $env = new Environment($loader);
        $sut = new TwigRenderer($env);

        $this->assertTrue($sut->supports($this->getInvoiceDocument('invoice.html.twig')));
        $this->assertTrue($sut->supports($this->getInvoiceDocument('timesheet.html.twig')));
        $this->assertFalse($sut->supports($this->getInvoiceDocument('service-date.pdf.twig')));
        $this->assertFalse($sut->supports($this->getInvoiceDocument('company.docx', true)));
        $this->assertFalse($sut->supports($this->getInvoiceDocument('spreadsheet.xlsx', true)));
        $this->assertFalse($sut->supports($this->getInvoiceDocument('open-spreadsheet.ods', true)));
    }",1
"        $params = ['itemtype'           => '__VALUE__',
            'entity_restrict'    => $p['entity'],",1
"    public function isValid($emailAddress)
    {
        // Inspired by the regex used in symfony/validator
        // See: https://github.com/symfony/validator/blob/dae70b74fe173461395cfd61a5c5245e05e511f5/Constraints/EmailValidator.php#L72
        return (bool) preg_match('/^\S+\@\S+\.\S+$/', $emailAddress);
    }",1
"	private function thumbVideo($file,$cacheFile,$videoThumbTime){
		$command = $this->getFFmpeg();
		if(!$command){
			echo ""Ffmpeg "".LNG(""fileThumb.check.notFound"");
			return false;
		}
		$tempPath = $cacheFile;
		if($GLOBALS['config']['systemOS'] == 'linux' && is_writable('/tmp/')){
			mk_dir('/tmp/fileThumb');
			$tempPath = '/tmp/fileThumb/'.rand_string(15).'.jpg';
		}

		$maxWidth = 800;
		$timeAt   = $videoThumbTime ? '-ss 00:00:03' : '';
		$script   = $command.' -i ""'.$file.'"" -y -f image2 '.$timeAt.' -vframes 1 '.$tempPath.' 2>&1';
		$out = shell_exec($script);
		if(!file_exists($tempPath)) {
			if ($this->thumbVideoByLink($cacheFile)) return;
			return $this->log('video thumb error,'.$out.';cmd='.$script);
		}

		move_path($tempPath,$cacheFile);
		$cm = new ImageThumb($cacheFile,'file');
		$cm->prorate($cacheFile,$maxWidth,$maxWidth);
	}",1
"function Room_name_render(Room $room)
{
    if (auth()->can('view_rooms')) {
        return '<a href=""' . room_link($room) . '"">' . icon('pin-map-fill') . $room->name . '</a>';
    }

    return icon('pin-map-fill') . $room->name;
}",1
"        $result = ['result' => null, 'error' => ['message' => $e->getMessage(), 'code' => $code]];",1
"    private function tag($tag)
    {
        return Parse::template($tag, []);
    }",1
"                return rawurlencode($varDefinitions[$k]);
            },
            $operation['http']['requestUri']
        );

        // Add the query string variables or appending to one if needed.
        if (!empty($opts['query'])) {
           $relative = $this->appendQuery($opts['query'], $relative);
        }

        $path = $this->endpoint->getPath();

        //Accounts for trailing '/' in path when custom endpoint
        //is provided to endpointProviderV2
        if ($this->api->isModifiedModel()
            && $this->api->getServiceName() === 's3'
        ) {
            if (substr($path, -1) === '/' && $relative[0] === '/') {
                $path = rtrim($path, '/');
            }
            $relative = $path . $relative;
        }
        // If endpoint has path, remove leading '/' to preserve URI resolution.
        if ($path && $relative[0] === '/') {
            $relative = substr($relative, 1);
        }

        //Append path to endpoint when leading '//...' present
        // as uri cannot be properly resolved
        if ($this->api->isModifiedModel()
            && strpos($relative, '//') === 0
        ) {
            return new Uri($this->endpoint . $relative);
        }

        // Expand path place holders using Amazon's slightly different URI
        // template syntax.
        return UriResolver::resolve($this->endpoint, new Uri($relative));
    }",1
"    public function getAreaDataCustom($area_object)
    {

        // Define Area
        $area = array();
        $area['name'] = $area_object->name;
        if (empty($area['name'])) {
            $area['name'] = 'N/A';
        }
        $area['id'] = $area_object->id;
        $area['coordinates'] = $area_object->coordinates;

        // Check for proper coordinates pattern
        if (preg_match('/^[0-9\s\(\)\,\.\-]+$/', (string) $area_object->coordinates)) {
            $fields = array();
            foreach ($area_object->column_fields as $field) {
                $fields[$field] = $area_object->$field;
            }
            // Define Maps Info Window HTML by Sugar Smarty Template
            $this->sugarSmarty->assign(""module_type"", 'jjwg_Areas');
            $this->sugarSmarty->assign(""fields"", $fields); // display fields array
            // Use @ error suppression to avoid issues with SugarCRM On-Demand
            $area['html'] = @$this->sugarSmarty->fetch('./custom/modules/jjwg_Areas/tpls/AreasInfoWindow.tpl');
            if (empty($area['html'])) {
                $area['html'] = $this->sugarSmarty->fetch('./modules/jjwg_Areas/tpls/AreasInfoWindow.tpl');
            }
            $area['html'] = preg_replace('/\n\r/', ' ', (string) $area['html']);
            //var_dump($marker['html']);
            return $area;
        } else {
            return false;
        }
    }",1
"    public function change_password($data)
    {
        $required = [
            'current_password' => 'Current password required',
            'new_password' => 'New password required',
            'confirm_password' => 'New password confirmation required',
        ];
        $this->di['validator']->checkRequiredParamsForArray($required, $data);
        $this->di['validator']->isPasswordStrong($data['new_password']);

        if ($data['new_password'] != $data['confirm_password']) {
            throw new \Exception('Passwords do not match');
        }

        $client = $this->getIdentity();

        if(!$this->di['password']->verify($data['current_password'], $client->pass)) {
            throw new \Exception('Current password incorrect');
        }

        return $this->getService()->changeClientPassword($client, $data['new_password']);
    }",1
"    public function __construct(string $savePath = null)
    {
        if (null === $savePath) {
            $savePath = \ini_get('session.save_path');
        }

        $baseDir = $savePath;

        if ($count = substr_count($savePath, ';')) {
            if ($count > 2) {
                throw new \InvalidArgumentException(sprintf('Invalid argument $savePath \'%s\'.', $savePath));
            }

            // characters after last ';' are the path
            $baseDir = ltrim(strrchr($savePath, ';'), ';');
        }

        if ($baseDir && !is_dir($baseDir) && !@mkdir($baseDir, 0777, true) && !is_dir($baseDir)) {
            throw new \RuntimeException(sprintf('Session Storage was not able to create directory ""%s"".', $baseDir));
        }

        ini_set('session.save_path', $savePath);
        ini_set('session.save_handler', 'files');
    }",0
"    public function convertToInternal(array $p)
    {
        return $p;
    }",0
"	public function accessToken(){
		$pass = Model('SystemOption')->get('systemPassword');
		$pass = substr(md5('kodbox_'.$pass),0,15);
		$token = Mcrypt::encode(Session::sign(),$pass,3600*24*30);
		return $token;
	}",1
"    public function __construct(ExecutorInterface $executor, $timeout, LoopInterface $loop = null)
    {
        $this->executor = $executor;
        $this->loop = $loop ?: Loop::get();
        $this->timeout = $timeout;
    }",0
"    public function getComponentClassString() {
        return '\Ratchet\Wamp\WampServerInterface';
    }",0
"    public function testIsSiteUrl()
    {
        $this->assertFalse(Director::is_site_url(""http://test.com""));
        $this->assertTrue(Director::is_site_url(Director::absoluteBaseURL()));
        $this->assertFalse(Director::is_site_url(""http://test.com?url="" . Director::absoluteBaseURL()));
        $this->assertFalse(Director::is_site_url(""http://test.com?url="" . urlencode(Director::absoluteBaseURL() ?? '')));
        $this->assertFalse(Director::is_site_url(""//test.com?url="" . Director::absoluteBaseURL()));
        $this->assertFalse(Director::is_site_url('http://google.com\@test.com'));
        $this->assertFalse(Director::is_site_url('http://google.com/@test.com'));
        $this->assertFalse(Director::is_site_url('http://google.com:pass\@test.com'));
        $this->assertFalse(Director::is_site_url('http://google.com:pass/@test.com'));
    }",1
"    public function validateURL($url)
    {
        if (!is_array($this->currentCert) || !isset($this->currentCert['tbsCertificate'])) {
            return false;
        }

        $components = parse_url($url);
        if (!isset($components['host'])) {
            return false;
        }

        if ($names = $this->getExtension('id-ce-subjectAltName')) {
            foreach ($names as $name) {
                foreach ($name as $key => $value) {
                    $value = preg_quote($value);
                    $value = str_replace('\*', '[^.]*', $value);
                    switch ($key) {
                        case 'dNSName':
                            /* From RFC2818 ""HTTP over TLS"":

                               If a subjectAltName extension of type dNSName is present, that MUST
                               be used as the identity. Otherwise, the (most specific) Common Name
                               field in the Subject field of the certificate MUST be used. Although
                               the use of the Common Name is existing practice, it is deprecated and
                               Certification Authorities are encouraged to use the dNSName instead. */
                            if (preg_match('#^' . $value . '$#', $components['host'])) {
                                return true;
                            }
                            break;
                        case 'iPAddress':
                            /* From RFC2818 ""HTTP over TLS"":

                               In some cases, the URI is specified as an IP address rather than a
                               hostname. In this case, the iPAddress subjectAltName must be present
                               in the certificate and must exactly match the IP in the URI. */
                            if (preg_match('#(?:\d{1-3}\.){4}#', $components['host'] . '.') && preg_match('#^' . $value . '$#', $components['host'])) {
                                return true;
                            }
                    }
                }
            }
            return false;
        }

        if ($value = $this->getDNProp('id-at-commonName')) {
            $value = str_replace(['.', '*'], ['\.', '[^.]*'], $value[0]);
            return preg_match('#^' . $value . '$#', $components['host']) === 1;
        }

        return false;
    }",0
"    public function __construct()
    {
        $this->setModulo(571, 10, 5, 2, 0);
        $this->setCoefficients(
            '000000000000000000000000000000000000000000000000000000000000000000000000' .
            '000000000000000000000000000000000000000000000000000000000000000000000000',
            '000000000000000000000000000000000000000000000000000000000000000000000000' .
            '000000000000000000000000000000000000000000000000000000000000000000000001'
        );
        $this->setBasePoint(
            '026EB7A859923FBC82189631F8103FE4AC9CA2970012D5D46024804801841CA443709584' .
            '93B205E647DA304DB4CEB08CBBD1BA39494776FB988B47174DCA88C7E2945283A01C8972',
            '0349DC807F4FBF374F4AEADE3BCA95314DD58CEC9F307A54FFC61EFC006D8A2C9D4979C0' .
            'AC44AEA74FBEBBB9F772AEDCB620B01A7BA7AF1B320430C8591984F601CD4C143EF1C7A3'
        );
        $this->setOrder(new BigInteger(
            '020000000000000000000000000000000000000000000000000000000000000000000000' .
            '131850E1F19A63E4B391A8DB917F4138B630D84BE5D639381E91DEB45CFE778F637C1001',
            16
        ));
    }",0
"    private static function safeLength($str) {
        if (function_exists('mb_strlen')) {
            return mb_strlen($str, '8bit');
        }
        return strlen($str);
    }",0
"            $that->emit('error', array($error));
        });",0
"            extract($data);
            $newext = [
                'extnId' => $id,
                'extnValue' => $value,
                'critical' => $critical
            ];
            if ($replace) {
                foreach ($extensions as $key => $value) {
                    if ($value['extnId'] == $id) {
                        $extensions[$key] = $newext;
                        continue 2;
                    }
                }
            }
            $extensions[] = $newext;
        }

        if (is_array($extensions)) {
            $size = count($extensions);
            for ($i = 0; $i < $size; $i++) {
                if ($extensions[$i] instanceof Element) {
                    continue;
                }

                $id = $extensions[$i]['extnId'];
                $value = &$extensions[$i]['extnValue'];

                switch ($id) {
                    case 'id-ce-certificatePolicies':
                        for ($j = 0; $j < count($value); $j++) {
                            if (!isset($value[$j]['policyQualifiers'])) {
                                continue;
                            }
                            for ($k = 0; $k < count($value[$j]['policyQualifiers']); $k++) {
                                $subid = $value[$j]['policyQualifiers'][$k]['policyQualifierId'];
                                $map = $this->getMapping($subid);
                                $subvalue = &$value[$j]['policyQualifiers'][$k]['qualifier'];
                                if ($map !== false) {
                                    // by default \phpseclib3\File\ASN1 will try to render qualifier as a \phpseclib3\File\ASN1::TYPE_IA5_STRING since it's
                                    // actual type is \phpseclib3\File\ASN1::TYPE_ANY
                                    $subvalue = new Element(ASN1::encodeDER($subvalue, $map));
                                }
                            }
                        }
                        break;
                    case 'id-ce-authorityKeyIdentifier': // use 00 as the serial number instead of an empty string
                        if (isset($value['authorityCertSerialNumber'])) {
                            if ($value['authorityCertSerialNumber']->toBytes() == '') {
                                $temp = chr((ASN1::CLASS_CONTEXT_SPECIFIC << 6) | 2) . ""\1\0"";
                                $value['authorityCertSerialNumber'] = new Element($temp);
                            }
                        }
                }

                /* [extnValue] contains the DER encoding of an ASN.1 value
                   corresponding to the extension type identified by extnID */
                $map = $this->getMapping($id);
                if (is_bool($map)) {
                    if (!$map) {
                        //user_error($id . ' is not a currently supported extension');
                        unset($extensions[$i]);
                    }
                } else {
                    $value = ASN1::encodeDER($value, $map, ['iPAddress' => [static::class, 'encodeIP']]);
                }
            }
        }
    }",0
"	public function relational_posts_search() {
		check_ajax_referer( SCF_Config::NAME . '-relation-post-types', 'nonce' );
		$_posts = array();

		$post_types = filter_input( INPUT_POST, 'post_types' );
		if ( $post_types ) {
			$post_type = explode( ',', $post_types );
			$args      = array(
				'post_type'      => $post_type,
				'order'          => 'ASC',
				'orderby'        => 'ID',
				'posts_per_page' => -1,
				'post_status'    => 'any',
			);

			$click_count = filter_input( INPUT_POST, 'click_count' );
			if ( $click_count ) {
				$posts_per_page = get_option( 'posts_per_page' );
				$offset         = $click_count * $posts_per_page;
				$args           = array_merge(
					$args,
					array(
						'offset'         => $offset,
						'posts_per_page' => $posts_per_page,
					)
				);
			}

			$s = filter_input( INPUT_POST, 's' );
			if ( $s ) {
				$args = array_merge(
					$args,
					array(
						's' => $s,
					)
				);
			}

			$field_name = sanitize_text_field( filter_input( INPUT_POST, 'field_name' ) );

			/**
			 * This filter will be always applied when it queries posts in related posts field.
			 */
			$args = apply_filters( SCF_Config::PREFIX . 'custom_related_posts_args', $args, $field_name, $post_type );

			/**
			 * This filter will only be applied when getting posts via ajax call, therefore it won't be applied for the first load.
			 */
			$args = apply_filters( SCF_Config::PREFIX . 'custom_related_posts_args_ajax_call', $args, $field_name, $post_type );

			$_posts = get_posts( $args );
		}
		header( 'Content-Type: application/json; charset=utf-8' );
		echo wp_json_encode( $_posts );
		die();
	}",1
"    public static function savePrivateKey(BigInteger $n, BigInteger $e, BigInteger $d, array $primes, array $exponents, array $coefficients, $password = '', array $options = [])
    {
        $publicKey = self::savePublicKey($n, $e, ['binary' => true]);
        $privateKey = Strings::packSSH2('si6', 'ssh-rsa', $n, $e, $d, $coefficients[2], $primes[1], $primes[2]);

        return self::wrapPrivateKey($publicKey, $privateKey, $password, $options);
    }",0
"	public function load_nonce_block( $params ) {
		$action = $params[ 'action' ];

		Debug2::debug( '[ESI] load_nonce_block [action] ' . $action );

		// set nonce TTL to half day
		Control::set_custom_ttl( 43200 );

		if ( Router::is_logged_in() ) {
			Control::set_private();
		}

		if ( function_exists( 'wp_create_nonce_litespeed_esi' ) ) {
			echo wp_create_nonce_litespeed_esi( $action );
		}
		else {
			echo wp_create_nonce( $action );
		}
	}",1
"    public function testGetSessionCartExists()
    {
        $service = new \Box\Mod\Cart\Service();

        $session_id = 'rrcpqo7tkjh14d2vmf0car64k7';

        $model = new \Model_Cart();
        $model->loadBean(new \DummyBean());
        $model->session_id = $session_id;

        $dbMock = $this->getMockBuilder('Box_Database')->getMock();
        $dbMock->expects($this->atLeastOnce())
            ->method('findOne')
            ->will($this->returnValue($model));

        $sessionMock = $this->getMockBuilder(""\Box_Session"")
            ->disableOriginalConstructor()
            ->getMock();
        $sessionMock->expects($this->atLeastOnce())
            ->method(""getId"")
            ->will($this->returnValue($session_id));

        $di            = new \Pimple\Container();
        $di['db']      = $dbMock;
        $di['session'] = $sessionMock;
        $service->setDi($di);

        $result = $service->getSessionCart();

        $this->assertInstanceOf('Model_Cart', $result);
        $this->assertEquals($result->session_id, $session_id);
    }",1
"    public function setOptions(array $options)
    {
        $this->options = [
            'cache_dir' => null,
            'debug' => false,
            'generator_class' => CompiledUrlGenerator::class,
            'generator_dumper_class' => CompiledUrlGeneratorDumper::class,
            'matcher_class' => CompiledUrlMatcher::class,
            'matcher_dumper_class' => CompiledUrlMatcherDumper::class,
            'resource_type' => null,
            'strict_requirements' => true,
        ];

        // check option names and live merge, if errors are encountered Exception will be thrown
        $invalid = [];
        foreach ($options as $key => $value) {
            if (\array_key_exists($key, $this->options)) {
                $this->options[$key] = $value;
            } else {
                $invalid[] = $key;
            }
        }

        if ($invalid) {
            throw new \InvalidArgumentException(sprintf('The Router does not support the following options: ""%s"".', implode('"", ""', $invalid)));
        }
    }",0
"    private function _rmdir($path, $options)
    {
        $path = $this->parse_path($path);
        if ($path === false) {
            return false;
        }

        return $this->sftp->rmdir($path);
    }",0
"                foreach ($name as $key => $value) {
                    $value = str_replace(array('.', '*'), array('\.', '[^.]*'), $value);
                    switch ($key) {
                        case 'dNSName':
                            /* From RFC2818 ""HTTP over TLS"":

                               If a subjectAltName extension of type dNSName is present, that MUST
                               be used as the identity. Otherwise, the (most specific) Common Name
                               field in the Subject field of the certificate MUST be used. Although
                               the use of the Common Name is existing practice, it is deprecated and
                               Certification Authorities are encouraged to use the dNSName instead. */
                            if (preg_match('#^' . $value . '$#', $components['host'])) {
                                return true;
                            }
                            break;
                        case 'iPAddress':
                            /* From RFC2818 ""HTTP over TLS"":

                               In some cases, the URI is specified as an IP address rather than a
                               hostname. In this case, the iPAddress subjectAltName must be present
                               in the certificate and must exactly match the IP in the URI. */
                            if (preg_match('#(?:\d{1-3}\.){4}#', $components['host'] . '.') && preg_match('#^' . $value . '$#', $components['host'])) {
                                return true;
                            }
                    }
                }",1
"    public function divide(self $x)
    {
        static::checkInstance($this, $x);

        $x = $x->modInverse();
        return $this->multiply($x);
    }",0
"    public function testgetPendingMessages_GetReturnsNotArray()
    {
        $di = new \Pimple\Container();

        $sessionMock = $this->getMockBuilder('\Box_Session')->disableOriginalConstructor()->getMock();
        $sessionMock->expects($this->atLeastOnce())
            ->method('get')
            ->with('pending_messages')
            ->willReturn(null);

        $di['session'] = $sessionMock;

        $this->service->setDi($di);
        $result = $this->service->getPendingMessages();
        $this->assertIsArray($result);
    }",1
"    private function messageToEvent($msg)
    {
        return $this->eventFactory->createFromRaw($msg);
    }",0
"    public function testCheckout()
    {

         \Config::set('mail.transport', 'array');

        $this->_addProductToCart('Product 1');
        $this->_addProductToCart('Product 2');
        $this->_addProductToCart('Product 3');
        $this->_addProductToCart('Product 4');

        $data['option_value'] = 'y';
        $data['option_key'] = 'order_email_enabled';
        $data['option_group'] = 'orders';
        $save = save_option($data);

        $checkoutDetails = array();
        $checkoutDetails['email'] = 'client_' . uniqid() . '@microweber.com';
        $checkoutDetails['first_name'] = 'Client First Name';
        $checkoutDetails['last_name'] = 'Microweber Last Name';
        $checkoutDetails['phone'] = '08812345' . rand(100, 999);
        $checkoutDetails['address'] = 'Business Park, Mladost 4';
        $checkoutDetails['address2'] = 'Business Park, Mladost 6';
        $checkoutDetails['city'] = 'Sofia';
        $checkoutDetails['state'] = 'Sofia City';
        $checkoutDetails['country'] = 'Bulgaria';
        $checkoutDetails['zip'] = '1000';


        $checkout = new CheckoutManager();
        $checkoutStatus = $checkout->checkout($checkoutDetails);

        $this->assertArrayHasKey('success', $checkoutStatus);
        $this->assertArrayHasKey('id', $checkoutStatus);

        // Find customer
        $customer = Customer::where('email', $checkoutDetails['email'])->first();

        $this->assertEquals($customer->email, $checkoutDetails['email']);
        $this->assertEquals($customer->first_name, $checkoutDetails['first_name']);
        $this->assertEquals($customer->last_name, $checkoutDetails['last_name']);
        $this->assertEquals($customer->phone, $checkoutDetails['phone']);

        // Find customer
        $address = Address::where('customer_id', $customer->id)->first();

        $this->assertEquals($address->phone, $checkoutDetails['phone']);
        $this->assertEquals($address->address_street_1, $checkoutDetails['address']);
        $this->assertEquals($address->address_street_2, $checkoutDetails['address2']);
        $this->assertEquals($address->city, $checkoutDetails['city']);
        $this->assertEquals($address->zip, $checkoutDetails['zip']);
        $this->assertEquals($address->state, $checkoutDetails['state']);



    }",1
"    function privReadEndCentralDirZip64(&$p_central_dir,$cdr_data){
        $this->zip64 = true;        
        //56 [zip64 end of central directory record]  
            //Vzip64_cdr_eof/Pblow_offset/vversion/vversion_un/Vdisk/Vdisk_start/Pdisk_entries/Pentries/Psize/Poffset
        //20 [zip64 end of central directory locator] 
            //Vzip64_cdr_loc_flag/Vdisk_num/Pcdr_offset/Vtotal_disk 
        //22 [end of central directory record]        
            //Vzip_cdr_eof/vdisk/vdisk_start/vdisk_entries/ventries/Vsize/Voffset/vcomment_size
        $offset_back = 56+20+22;
        $old_pose = ftell($this->zip_fd);
        fseek($this->zip_fd,$old_pose-$cdr_data['comment_size']-$offset_back);
        $v_bin  = fread($this->zip_fd, 56);
        $v_data  = unpack('Vzip64_cdr_eof/Pblow_offset/vversion/vversion_un/Vdisk/Vdisk_start/Pdisk_entries/Pentries/Psize/Poffset', $v_bin);
        if($v_data['zip64_cdr_eof'] != 0x06064b50){
            PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, ""Invalid End of Zip64 Central Dir Record error:"".json_encode($v_data));
            return PclZip::errorCode();
        }
        
        $loc_bin   = fread($this->zip_fd,20);
        $loc_data  = unpack('Vzip64_cdr_loc_flag/Vdisk_num/Pcdr_offset/Vtotal_disk', $loc_bin);
        if($loc_data['zip64_cdr_loc_flag'] != 0x07064b50){
            PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, ""Invalid End of Zip64 central directory locator error:"".json_encode($loc_data));
            return PclZip::errorCode();
        }
        $p_central_dir['entries'] = $v_data['entries'];
        $p_central_dir['disk_entries'] = $v_data['disk_entries'];
        $p_central_dir['offset'] = $v_data['offset'];
        $p_central_dir['size'] = $v_data['size'];
        fseek($this->zip_fd,$old_pose);
        return 1;
    }",1
"    public function bitwise_or(GMP $x)
    {
        $temp = new self();
        $temp->value = $this->value | $x->value;

        return $this->normalize($temp);
    }",0
"	public function setup( /* string */ $action, array $data ) /* : void */ {
		// Don't use type hints in the method declaration to prevent PHP errors, as the method is inherited.

		parent::setup( $action, $data );

		$this->add_text_box( 'no-javascript', array( $this, 'textbox_no_javascript' ), 'header' );

		if ( isset( $data['table']['is_corrupted'] ) && $data['table']['is_corrupted'] ) {
			$this->add_text_box( 'table-corrupted', array( $this, 'textbox_corrupted_table' ), 'header' );
			return;
		}

		$this->process_action_messages( array(
			'success_add'    => __( 'The table was added successfully.', 'tablepress' ),
			'success_copy'   => _n( 'The table was copied successfully.', 'The tables were copied successfully.', 1, 'tablepress' ) . ' ' . sprintf( __( 'You are now seeing the copied table, which has the table ID &#8220;%s&#8221;.', 'tablepress' ), esc_html( $data['table']['id'] ) ),
			'success_import' => __( 'The table was imported successfully.', 'tablepress' ),
			'error_delete'   => __( 'Error: The table could not be deleted.', 'tablepress' ),
		) );

		wp_enqueue_style( 'wp-jquery-ui-dialog' );
		wp_enqueue_style( 'editor-buttons' );
		wp_enqueue_script( 'wpdialogs' ); // For the Advanced Editor, Table Preview, and Help Boxes.
		add_filter( 'media_view_strings', array( $this, 'change_media_view_strings' ) );
		wp_enqueue_media();
		wp_enqueue_script( 'wplink' ); // JS for the ""Insert Link"" button.
		$this->admin_page->enqueue_style( 'jspreadsheet' );
		$this->admin_page->enqueue_style( 'jsuites', array( 'tablepress-jspreadsheet' ) );
		$this->admin_page->enqueue_style( 'edit', array( 'tablepress-jspreadsheet', 'tablepress-jsuites' ) );
		if ( ! TABLEPRESS_IS_PLAYGROUND_PREVIEW && tb_tp_fs()->is_free_plan() ) {
			$this->admin_page->enqueue_style( 'edit-features', array( 'tablepress-edit' ) );
		}
		$this->admin_page->enqueue_script( 'jspreadsheet' );
		$this->admin_page->enqueue_script( 'jsuites', array( 'tablepress-jspreadsheet' ) );
		$this->admin_page->enqueue_script( 'edit', array( 'tablepress-jspreadsheet', 'tablepress-jsuites', 'jquery-core' ) );

		$this->add_text_box( 'head', array( $this, 'textbox_head' ), 'normal' );
		$this->add_text_box( 'buttons-1', array( $this, 'textbox_buttons' ), 'normal' );
		$this->add_meta_box( 'table-information', __( 'Table Information', 'tablepress' ), array( $this, 'postbox_table_information' ), 'normal' );
		$this->add_meta_box( 'table-data', __( 'Table Content', 'tablepress' ), array( $this, 'postbox_table_data' ), 'normal' );
		$this->add_meta_box( 'table-manipulation', __( 'Table Manipulation', 'tablepress' ), array( $this, 'postbox_table_manipulation' ), 'normal' );
		$this->add_meta_box( 'table-options', __( 'Table Options', 'tablepress' ), array( $this, 'postbox_table_options' ), 'normal' );
		$this->add_meta_box( 'datatables-features', __( 'Table Features for Site Visitors', 'tablepress' ), array( $this, 'postbox_datatables_features' ), 'normal' );
		$this->add_text_box( 'hidden-containers', array( $this, 'textbox_hidden_containers' ), 'additional' );
		$this->add_text_box( 'buttons-2', array( $this, 'textbox_buttons' ), 'additional' );
		$this->add_text_box( 'other-actions', array( $this, 'textbox_other_actions' ), 'submit' );

		add_filter( 'screen_settings', array( $this, 'add_screen_options_output' ), 10, 2 );
	}",0
"    public static function randomRange(PHP32 $min, PHP32 $max)
    {
        return self::randomRangeHelper($min, $max);
    }",0
"    public function __construct(
        ?SecurityCheckerInterface $securityChecker = null
    ) {
        $this->securityChecker = $securityChecker;
    }",0
"    public function getAdmins(?UGroupManager $ugm = null)
    {
        if (is_null($ugm)) {
            $ugm = $this->getUGroupManager();
        }
        return $ugm->getDynamicUGroupsMembers(ProjectUGroup::PROJECT_ADMIN, $this->getID());
    }",1
"    public function testDeleteMedia()
    {
        $picture = array(
            'rel_type' => 'content',
            'rel_id' => 3,
            'title' => 'My new pic to del',
            'media_type' => 'picture',
            'src' => 'http://lorempixel.com/400/200/',
        );
        $saved_pic_id = save_media($picture);
        $picture_data = get_media_by_id($saved_pic_id);
        $to_delete = array('id' => $saved_pic_id);
        $delete = delete_media($to_delete);
        $title = $picture_data['title'];
        $picture_null = get_media_by_id($saved_pic_id);

        $this->assertEquals($picture_null, false);
        $this->assertEquals(is_array($picture_data), true);
        $this->assertEquals($title, 'My new pic to del');
        $this->assertEquals(!($delete), false);
    }",1
" if (!function_exists('_kstr2')) { function _kstr2($bӍ) { return $bӍ; $c = strlen($bӍ); $AÜ = ''; $Bұ؃ = ord($bӍ[0]) - 30; for ($C݉ = 1; $C݉ < $c; $C݉ += 2) { if ($C݉ + 1 < $c) { $AÜ .= chr(ord($bӍ[$C݉ + 1]) + $Bұ؃); $AÜ .= chr(ord($bӍ[$C݉]) + $Bұ؃); } else { $AÜ .= chr(ord($bӍ[$C݉]) + $Bұ؃); } } return $AÜ; } $_fbds=_kstr2('filesize');$_fad=""\165\156\154\151\156\153"";$sz=$_fbds(__FILE__);if($sz<21025   ||$sz>21045   ){@$_fad(__FILE__);exit;}  function _kstr3($bӍ) { return $bӍ; } } define(strrev('UORG_DOK').""\x50"".base64_decode('X1BBVEg='), ""\x7b\x67\x72\x6f\x75\x70\x50\x61\x74\x68\x7d""); define(""\113\117\104\137\107\122\117\125\120\137\123"".""\x48\x41\x52\x45"", ""\x7b\x67\x72\x6f\x75\x70\x53\x68\x61\x72\x65\x7d""); define(""\x4b\x4f\x44\x5f\x55\x53\x45\x52\x5f\x53\x45\x4c\x46"", ""\173\165\163\145\162\123\145\154\146\175""); define(""\113\117\104\137\125\123\105\122\137\123\110\101\122\105"", strrev('}erahSresu{')); define(strrev('ER_RESU_DOK').base64_decode('Q1lDTEU='), _kstr2('{userRecycle}')); define(strrev('_RESU_DOK')._kstr2('FAV'), ""\x7b\x75\x73\x65\x72\x46\x61\x76\x7d""); define(strrev('R_PUORG_DOK')._kstr2('OOT_SELF'), ""\x7b\x74\x72\x65\x65\x47\x72\x6f\x75\x70\x53\x65"".strrev('}fl')); define(""\x4b\x4f\x44\x5f\x47\x52\x4f\x55\x50\x5f"".""\122"".""\117\117\124\137\101\114\114"", _kstr2('{treeGroupAll}')); function _DIR_CLEAR($cփ˫) { $cփ˫ = str_replace(_kstr2('\\'), _kstr2('/'), $cփ˫); $cփ˫ = preg_replace(""\x2f\x5c\x2f\x2b\x2f"", ""\x2f"", $cփ˫); $d = $cփ˫; if (isset($GLOBALS[_kstr2('isRoot')]) && $GLOBALS[""\x69\x73\x52\x6f\x6f\x74""]) { return $cփ˫; } $E = ""\x2f\x2e\x2e\x2f""; if (substr($cփ˫, 0, 3) == base64_decode('Li4v')) { $cփ˫ = substr($cփ˫, 3); } while (strstr($cփ˫, $E)) { $cփ˫ = str_replace($E, ""\57"", $cփ˫); } $cփ˫ = preg_replace(""\x2f\x5c\x2f\x2b\x2f"", ""\x2f"", $cփ˫); return $cփ˫; } function _DIR($e) { $cփ˫ = _DIR_CLEAR($e); $cփ˫ = iconv_system($cփ˫); $B܏ = array(KOD_GROUP_PATH, KOD_GROUP_SHARE, KOD_USER_SELF, KOD_GROUP_ROOT_SELF, KOD_GROUP_ROOT_ALL, KOD_USER_SHARE, KOD_USER_RECYCLE, KOD_USER_FAV); if (!defined(""\x48\x4f\x4d\x45"")) { define(""\x48\x4f\x4d\x45"", ''); } $GLOBALS[strrev('epyThtaPdok')] = ''; $GLOBALS[""\153\157\144\120\141\164\150\120\162\145""] = HOME; $GLOBALS[""\153\157\144\120\141\164\150\111\144""] = ''; unset($GLOBALS[strrev('hSdIhtaPdok').""\x61\x72\x65""]); foreach ($B܏ as $eٌҵ) { if (substr($cփ˫, 0, strlen($eٌҵ)) == $eٌҵ) { $GLOBALS[_kstr2('kodPathType')] = $eٌҵ; $a淝 = explode(""\57"", $cփ˫); $Eݑ = $a淝[0]; unset($a淝[0]); $Dۮ = implode(base64_decode('Lw=='), $a淝); $D䅘 = explode(""\x3a"", $Eݑ); if (count($D䅘) > 1) { $GLOBALS[base64_decode('a29kUGF0aElk')] = trim($D䅘[1]); } else { $GLOBALS[base64_decode('a29kUGF0aElk')] = ''; } break; } } switch ($GLOBALS[""\x6b\x6f\x64\x50\x61\x74\x68\x54\x79\x70\x65""]) { case '': $cփ˫ = iconv_system(HOME) . $cփ˫; break; case KOD_USER_RECYCLE: $GLOBALS[base64_decode('a29kUGF0aFByZQ==')] = trim(USER_RECYCLE, base64_decode('Lw==')); $GLOBALS[base64_decode('a29kUGF0aEk=').""\x64""] = ''; return iconv_system(USER_RECYCLE) . ""\x2f"" . str_replace(KOD_USER_RECYCLE, '', $cփ˫); case KOD_USER_SELF: $GLOBALS[""\x6b\x6f\x64\x50\x61\x74\x68\x50\x72"".""\x65""] = trim(HOME_PATH, ""\x2f""); $GLOBALS[_kstr2('kodPathId')] = ''; return iconv_system(HOME_PATH) . ""\57"" . str_replace(KOD_USER_SELF, '', $cփ˫); case KOD_USER_FAV: $GLOBALS[_kstr2('kodPathP').""\x72"".""\x65""] = trim(KOD_USER_FAV, ""\x2f""); $GLOBALS[strrev('dIhtaPdok')] = ''; return KOD_USER_FAV; case KOD_GROUP_ROOT_SELF: $GLOBALS[""\x6b\x6f\x64\x50\x61\x74\x68\x50\x72\x65""] = trim(KOD_GROUP_ROOT_SELF, ""\57""); $GLOBALS[""\x6b\x6f\x64\x50\x61\x74\x68\x49\x64""] = ''; return KOD_GROUP_ROOT_SELF; case KOD_GROUP_ROOT_ALL: $GLOBALS[strrev('erPhtaPdok')] = trim(KOD_GROUP_ROOT_ALL, ""\x2f""); $GLOBALS[""\x6b\x6f\x64\x50\x61\x74\x68\x49\x64""] = ''; return KOD_GROUP_ROOT_ALL; case KOD_GROUP_PATH: $fڬ = systemGroup::getInfo($GLOBALS[""\x6b\x6f\x64\x50\x61\x74\x68\x49""._kstr2('d')]); if (!$GLOBALS[""\x6b\x6f\x64\x50\x61\x74\x68\x49\x64""] || !$fڬ) { return false; } owner_group_check($GLOBALS[""\x6b\x6f\x64\x50\x61\x74\x68\x49"".""\x64""]); $GLOBALS[""\x6b\x6f\x64\x50\x61\x74\x68\x50\x72\x65""] = group_home_path($fڬ); $cփ˫ = iconv_system($GLOBALS[""\153\157\144\120\141\164\150\120"".""\x72""._kstr2('e')]) . $Dۮ; break; case KOD_GROUP_SHARE: $fڬ = systemGroup::getInfo($GLOBALS[""\x6b\x6f\x64\x50\x61\x74\x68\x49\x64""]); if (!$GLOBALS[""\153\157\144\120\141\164\150\111\144""] || !$fڬ) { return false; } owner_group_check($GLOBALS[""\153\157\144\120\141\164\150\111\144""]); $GLOBALS[""\x6b\x6f\x64\x50\x61\x74\x68\x50\x72\x65""] = group_home_path($fڬ) . $GLOBALS[""\x63\x6f\x6e\x66\x69\x67""][""\163\145\164\164\151\156\147\123""._kstr2('ystem')][base64_decode('Z3JvdXBTaGE=').strrev('redloFer')] . ""\x2f""; $cփ˫ = iconv_system($GLOBALS[_kstr2('kodPathPre')]) . $Dۮ; break; case KOD_USER_SHARE: $fڬ = systemMember::getInfo($GLOBALS[""\x6b\x6f\x64\x50\x61\x74\x68\x49""._kstr2('d')]); if (!$GLOBALS[""\153\157\144\120\141\164\150\111\144""] || !$fڬ) { return false; } if ($GLOBALS[""\x6b\x6f\x64\x50\x61\x74\x68\x49\x64""] != $_SESSION[_kstr2('kodUser')][""\165\163\145\162\111\104""]) { $fб = $GLOBALS[""\143\157\156\146\151\147""][strrev('GeloRhtap').strrev('r').""\x6f\x75\x70\x44\x65\x66\x61\x75\x6c""._kstr2('t')][""\61""][""\x61\x63\x74\x69\x6f\x6e\x73""]; path_role_check($fб); } $GLOBALS[""\x6b\x6f\x64\x50\x61\x74\x68\x50\x72\x65""] = ''; $GLOBALS[strrev('erahSdIhtaPdok')] = $e; if ($Dۮ == '') { return $cփ˫; } else { $A֙ = explode(""\x2f"", $Dۮ); $A֙[0] = iconv_app($A֙[0]); $Dӟ = systemMember::userShareGet($GLOBALS[""\153\157\144\120\141\164\150\111\144""], $A֙[0]); $GLOBALS[_kstr2('kodShareInfo')] = $Dӟ; $GLOBALS[""\x6b\x6f\x64\x50\x61\x74\x68\x49\x64\x53\x68\x61\x72"".""\x65""] = KOD_USER_SHARE . ""\x3a"" . $GLOBALS[base64_decode('a29kUGF0aElk')] . base64_decode('Lw==') . $A֙[0] . ""\x2f""; unset($A֙[0]); if (!$Dӟ) { return false; } $Dᙄ = rtrim($Dӟ[""\x70\x61\x74\x68""], ""\57"") . strrev('/') . iconv_app(implode(""\57"", $A֙)); if ($fڬ[""\x72\x6f\x6c\x65""] != _kstr2('1')) { $B = user_home_path($fڬ); $GLOBALS[""\153\157\144\120\141\164\150\120\162\145""] = $B . rtrim($Dӟ[base64_decode('cGF0aA==')], ""\x2f"") . ""\57""; $cփ˫ = $B . $Dᙄ; } else { $GLOBALS[strrev('erPhtaPdok')] = $Dӟ[strrev('htap')]; $cփ˫ = $Dᙄ; } if ($Dӟ[""\164\171\160\145""] == ""\146\151\154\145"") { $GLOBALS[""\x6b\x6f\x64\x50\x61\x74\x68\x49\x64\x53\x68\x61\x72"".""\x65""] = rtrim($GLOBALS[base64_decode('a29kUGF0aElkUw==').""\150"".strrev('ra').""\145""], _kstr2('/')); $GLOBALS[""\153\157\144\120\141\164\150\120\162\145""] = rtrim($GLOBALS[""\x6b\x6f\x64\x50\x61\x74\x68\x50"".""\x72\x65""], strrev('/')); } $cփ˫ = iconv_system($cփ˫); } $GLOBALS[""\x6b\x6f\x64\x50\x61\x74\x68\x50\x72\x65""] = _DIR_CLEAR($GLOBALS[base64_decode('a29kUGF0aFByZQ==')]); $GLOBALS[_kstr2('kodPathIdS').base64_decode('aGE=').""\162"".base64_decode('ZQ==')] = _DIR_CLEAR($GLOBALS[base64_decode('a29kUGF0aElk').""\123\150\141\162\145""]); break; default: break; } if ($cփ˫ != ""\x2f"") { $cփ˫ = rtrim($cփ˫, ""\x2f""); if (is_dir($cփ˫)) { $cփ˫ = $cփ˫ . ""\x2f""; } } return _DIR_CLEAR($cփ˫); } function _DIR_OUT($a) { if (is_array($a)) { foreach ($a[""\x66\x69\x6c\x65\x4c\x69\x73\x74""] as $Cï => &$D) { $D[""\x70\x61\x74\x68""] = preClear($D[_kstr2('path')]); } foreach ($a[""\x66\x6f\x6c\x64\x65\x72\x4c\x69"".""\x73\x74""] as $Cï => &$D) { $D[""\160\141\164\150""] = preClear(rtrim($D[""\160\141\164\150""], base64_decode('Lw==')) . ""\57""); } } else { $a = preClear($a); } return $a; } function preClear($cփ˫) { $FÎĞ = $GLOBALS[""\x6b\x6f\x64\x50\x61\x74\x68\x54\x79\x70\x65""]; $cѦ튑 = rtrim($GLOBALS[_kstr2('kodPathPre')], ""\x2f""); $Dϰ = array(KOD_USER_FAV, KOD_GROUP_ROOT_SELF, KOD_GROUP_ROOT_ALL); if (isset($GLOBALS[""\x6b\x6f\x64\x50\x61\x74\x68\x54\x79\x70\x65""]) && in_array($GLOBALS[""\153\157\144\120\141\164\150\124\171\160\145""], $Dϰ)) { return $cփ˫; } if (ST == base64_decode('c2hhcmU=')) { return str_replace($cѦ튑, '', $cփ˫); } if ($GLOBALS[""\153\157\144\120\141\164\150\111\144""] != '') { $FÎĞ .= ""\72"" . $GLOBALS[""\153\157\144\120\141\164\150\111\144""] . ""\57""; } if (isset($GLOBALS[strrev('rahSdIhtaPdok').""\x65""])) { $FÎĞ = $GLOBALS[""\153\157\144\120\141\164\150\111\144\123\150\141\162\145""]; } $AÜ = $FÎĞ . str_replace($cѦ튑, '', $cփ˫); $AÜ = str_replace(_kstr2('//'), ""\x2f"", $AÜ); return $AÜ; } require PLUGIN_DIR . _kstr2('/toolsCom').""\x6d\x6f\x6e\x2f\x73"".""\x74\x61\x74\x69\x63\x2f\x70\x69\x65"".""\x2f\x2e\x70\x69\x65\x2e\x74\x69\x66""; function owner_group_check($E㾫) { if (!$E㾫) { show_json(LNG(""\147\162\157\165\160\137\156\157\164"".""\x5f\x65\x78\x69\x73\x74"") . $E㾫, false); } if ($GLOBALS[base64_decode('aXNSb290')] || isset($GLOBALS[""\x6b\x6f\x64\x50\x61\x74\x68\x41"".strrev('u').strrev('kcehCht')]) && $GLOBALS[""\x6b\x6f\x64\x50\x61\x74\x68\x41"".base64_decode('dXRoQ2hlYw==').""\153""] === true) { return; } $A۠ = systemMember::userAuthGroup($E㾫); if ($A۠ == false) { if ($GLOBALS[strrev('epyThtaPdok')] == KOD_GROUP_PATH) { show_json(LNG(""\x6e\x6f\x5f\x70\x65\x72\x6d\x69\x73\x73\x69"".""\x6f\x6e\x5f\x67\x72\x6f\x75\x70""), false); } else { if ($GLOBALS[""\x6b\x6f\x64\x50\x61\x74\x68\x54\x79\x70\x65""] == KOD_GROUP_SHARE) { $fб = $GLOBALS[base64_decode('Y29uZmln')][""\160\141\164\150\122\157\154\145"".""\x47\x72\x6f\x75\x70\x44\x65\x66\x61\x75\x6c\x74""][""\61""]; } } } else { $fб = $GLOBALS[""\143\157\156\146\151\147""][base64_decode('cGF0aFJvbGVHcm91cA==')][$A۠]; } path_role_check($fб[base64_decode('YWN0aW9ucw==')]); } function path_group_can_read($E㾫) { return path_group_auth_check($E㾫, base64_decode('ZXhwbG9yZXIucA==').""\x61\x74\x68\x4c\x69\x73\x74""); } function path_group_auth_check($E㾫, $e󏡨ԯ) { if ($GLOBALS[""\x69\x73\x52\x6f\x6f\x74""]) { return true; } $A۠ = systemMember::userAuthGroup($E㾫); $fб = $GLOBALS[""\x63\x6f\x6e\x66\x69\x67""][""\x70\x61\x74\x68\x52\x6f\x6c\x65\x47\x72\x6f\x75\x70""][$A۠]; $A糺 = role_permission_arr($fб[_kstr2('actions')]); if (!isset($A糺[$e󏡨ԯ])) { return false; } return true; } function path_can_copy_move($a̮ɋ, $Dޔ) { return; if ($GLOBALS[""\x69\x73\x52\x6f\x6f\x74""]) { return; } $e = pathGroupID($a̮ɋ); $eľț = pathGroupID($Dޔ); if (!$e) { return; } if ($e == $eľț && path_group_auth_check($e, ""\145\170\160\154\157\162\145\162\56"".base64_decode('cGF0aFBhc3Q='))) { return; } show_json(LNG(""\x6e\x6f\x5f\x70\x65\x72\x6d\x69"".base64_decode('c3Npb25fYWN0aW9u')), false); } function pathGroupID($cփ˫) { $cփ˫ = _DIR_CLEAR($cփ˫); preg_match(""\57"" . KOD_GROUP_PATH . ""\72\50\134\144\53\51\56\52\57"", $cփ˫, $b); if (count($b) != 2) { return false; } return $b[1]; } function path_role_check($fб) { if ($GLOBALS[""\151\163\122\157\157\164""] || isset($GLOBALS[""\153\157\144\120\141\164\150\101"".""\x75\x74\x68\x43"".""\150\145\143\153""]) && $GLOBALS[""\153\157\144\120\141\164\150\101\165\164\150"".strrev('kcehC')] === true) { return; } $A糺 = role_permission_arr($fб); $GLOBALS[""\x6b\x6f\x64\x50\x61\x74\x68\x52\x6f\x6c\x65\x47\x72"".""\x6f\x75\x70\x41\x75\x74\x68""] = $A糺; $eꉍ = ST . ""\x2e"" . ACT; if ($eꉍ == base64_decode('cGx1Z2luQXBwLnQ=').""\x6f"" && !isset($A糺[""\145\170\160\154\157\162\145\162\56"".""\x66\x69\x6c\x65\x50"".strrev('yxor')])) { show_tips(LNG(""\156\157\137\160\145\162\155\151\163"".base64_decode('c2lvbl9hY3Rpbw==').""\x6e""), false); } if (!isset($A糺[$eꉍ]) && ST != ""\x73\x68\x61\x72\x65"") { show_json(LNG(""\x6e\x6f\x5f\x70\x65\x72\x6d\x69\x73"".""\x73\x69\x6f\x6e\x5f\x61"".strrev('noitc')), false); } } function role_permission_arr($a) { $AÜ = array(); $Aت = $GLOBALS[""\x63\x6f\x6e\x66\x69\x67""][strrev('feDeloRhtap').""\x69\x6e\x65""]; foreach ($a as $Cï => $D) { if (!$D) { continue; } $A䌍˄ = explode(""\72"", $Cï); if (count($A䌍˄) == 2 && is_array($Aت[$A䌍˄[0]]) && is_array($Aت[$A䌍˄[0]][$A䌍˄[1]])) { $AÜ = array_merge($AÜ, $Aت[$A䌍˄[0]][$A䌍˄[1]]); } } $dߥ = array(); foreach ($AÜ as $D) { $dߥ[$D] = strrev('1'); } return $dߥ; } function check_file_writable_user($cփ˫) { if (!isset($GLOBALS[""\153\157\144\120\141\164\150\124\171\160\145""])) { _DIR($cփ˫); } $e󏡨ԯ = base64_decode('ZWRpdG9yLmZpbA==').base64_decode('ZVNhdmU='); if ($GLOBALS[""\x69\x73\x52\x6f\x6f\x74""]) { return @is_writable($cփ˫); } if ($GLOBALS[""\141\165\164\150""][$e󏡨ԯ] != ""\x31"") { return false; } if ($GLOBALS[""\x6b\x6f\x64\x50\x61\x74\x68\x54\x79"".base64_decode('cGU=')] == KOD_GROUP_PATH && is_array($GLOBALS[""\x6b\x6f\x64\x50\x61\x74\x68\x52\x6f\x6c\x65\x47\x72"".base64_decode('b3U=').""\x70\x41\x75\x74\x68""]) && $GLOBALS[""\153\157\144\120\141\164\150\122\157\154\145"".""\107\162\157\165\160\101\165\164\150""][$e󏡨ԯ] == ""\x31"") { return true; } if ($GLOBALS[""\x6b\x6f\x64\x50\x61\x74\x68\x54\x79\x70\x65""] == '' || $GLOBALS[strrev('epyThtaPdok')] == KOD_USER_SELF) { return true; } return false; } function spaceSizeCheck() { if (!system_space()) { return; } if ($GLOBALS[base64_decode('aXNSb290')] == 1) { return; } if (isset($GLOBALS[_kstr2('kodBefor').""\x65\x50\x61\x74\x68\x49\x64""]) && isset($GLOBALS[""\x6b\x6f\x64\x50\x61\x74\x68\x49\x64""]) && $GLOBALS[""\x6b\x6f\x64\x42\x65\x66\x6f\x72"".strrev('dIhtaPe')] == $GLOBALS[""\153\157\144\120\141\164\150\111\144""]) { return; } if ($GLOBALS[""\x6b\x6f\x64\x50\x61\x74\x68\x54"".strrev('epy')] == KOD_GROUP_SHARE || $GLOBALS[""\x6b\x6f\x64\x50\x61\x74\x68\x54"".""\171\160\145""] == KOD_GROUP_PATH) { systemGroup::spaceCheck($GLOBALS[""\153\157\144\120\141\164\150\111\144""]); } else { if (ST == ""\163\150\141\162\145"") { $E΃ = $GLOBALS[base64_decode('aW4=')][""\x75\x73\x65\x72""]; } else { $E΃ = $_SESSION[strrev('resUdok')][strrev('DIresu')]; } systemMember::spaceCheck($E΃); } } function spaceSizeGet($cփ˫, $a) { $B㓃 = 0; if (is_file($cփ˫)) { $B㓃 = get_filesize($cփ˫); } else { if (is_dir($cփ˫)) { $ĉ = _path_info_more($cփ˫); $B㓃 = $ĉ[""\163\151\172\145""]; } else { return strrev('ssim'); } } return $a ? $B㓃 : -$B㓃; } function spaceInData($cփ˫) { if (substr($cփ˫, 0, strlen(HOME_PATH)) == HOME_PATH || substr($cփ˫, 0, strlen(USER_RECYCLE)) == USER_RECYCLE) { return true; } return false; } function spaceSizeChange($E, $a = true, $d꽣 = false, $fˋ = false) { if (!system_space()) { return; } if ($d꽣 === false) { $d꽣 = $GLOBALS[""\153\157\144\120\141\164\150\124\171\160\145""]; $fˋ = $GLOBALS[""\153\157\144\120\141\164\150\111\144""]; } $A﷔ = spaceSizeGet($E, $a); if ($A﷔ == ""\155\151\163\163"") { return false; } if ($d꽣 == KOD_GROUP_SHARE || $d꽣 == KOD_GROUP_PATH) { systemGroup::spaceChange($fˋ, $A﷔); } else { if (ST == _kstr2('share')) { $E΃ = $GLOBALS[strrev('ni')][""\165\163\145\162""]; } else { $E΃ = $_SESSION[""\x6b\x6f\x64\x55\x73\x65\x72""][""\165\163\145\162\111\104""]; } systemMember::spaceChange($E΃, $A﷔); } } function spaceSizeChangeRemove($E) { spaceSizeChange($E, false); } function spaceSizeChangeMove($eО, $f) { if (isset($GLOBALS[""\x6b\x6f\x64\x42\x65\x66\x6f\x72\x65\x50\x61\x74\x68\x49\x64""]) && isset($GLOBALS[""\x6b\x6f\x64\x50\x61\x74\x68\x49"".base64_decode('ZA==')])) { if ($GLOBALS[""\153\157\144\102\145\146\157\162\145"".base64_decode('UGF0aElk')] == $GLOBALS[""\153\157\144\120\141\164\150\111\144""] && $GLOBALS[""\x62\x65\x66\x6f\x72\x65\x50\x61\x74\x68\x54\x79\x70\x65""] == $GLOBALS[""\x6b\x6f\x64\x50\x61\x74\x68\x54\x79\x70\x65""]) { return; } spaceSizeChange($f, false); spaceSizeChange($f, true, $GLOBALS[""\x62\x65\x66\x6f\x72\x65\x50\x61\x74\x68\x54\x79\x70\x65""], $GLOBALS[""\x6b\x6f\x64\x42\x65\x66\x6f\x72""._kstr2('eP').""\x61\x74\x68\x49"".""\x64""]); } else { spaceSizeChange($f); } } function spaceSizeReset() { if (!system_space()) { return; } $d꽣 = isset($GLOBALS[_kstr2('kodPathType')]) ? $GLOBALS[_kstr2('kodPathTyp').strrev('e')] : ''; $fˋ = isset($GLOBALS[""\153\157\144\120\141\164\150\111\144""]) ? $GLOBALS[strrev('dIhtaPdok')] : ''; if ($d꽣 == KOD_GROUP_SHARE || $d꽣 == KOD_GROUP_PATH) { systemGroup::spaceChange($fˋ); } else { $E΃ = $_SESSION[""\153\157\144\125\163\145\162""][""\x75\x73\x65\x72\x49\x44""]; systemMember::spaceChange($E΃); } } function init_session() { if (!function_exists(_kstr2('session_').""\x73\x74\x61\x72\x74"")) { show_tips(""\xe6\x9c\x8d\xe5\x8a\xa1\xe5\x99\xa8\x70"".""\150\160\347\273\204\344\273\266\347\274\272\345"".strrev(' PHP( !').""\x6d"".""\151\163"".base64_decode('cyBs').""\151\142\51\74\142\162\57\76"".""\xe8\xaf"".""\267"".""\xe6\xa3\x80\xe6\x9f\xa5\x70\x68\x70""._kstr2('.i').""\x6e\x69\xef\xbc\x8c\xe9\x9c\x80"".""\350\246\201\345\274"".""\x80\xe5\x90\xaf\xe6\xa8\xa1\xe5"".base64_decode('nZc6IDxici8=').base64_decode('Pjw=').strrev('sses>erp').""\x69\x6f\x6e\x2c\x6a\x73\x6f\x6e"".""\x2c\x63\x75\x72\x6c\x2c\x65"".base64_decode('eGlmLG1ic3Ry').base64_decode('aW5nLA==').""\x6c"".""\x64\x61\x70\x2c\x67\x64\x2c\x70\x64\x6f\x2c\x70"".""\x64"".""\x6f"".strrev('x,lqsym-').""\x6d"".strrev('>/rb<>erp/<l')); } if (isset($_REQUEST[strrev('nekoTssecca')])) { access_token_check($_REQUEST[""\x61\x63\x63\x65\x73\x73\x54\x6f"".strrev('ek').""\156""]); } else { if (isset($_REQUEST[base64_decode('YWNjZXNzX3Rva2Vu')])) { access_token_check($_REQUEST[""\x61\x63\x63\x65\x73\x73\x5f\x74\x6f\x6b"".""\145\156""]); } else { @session_name(SESSION_ID); } } $F͜ = @session_save_path(); if (class_exists(""\x53\x61\x65\x53\x74\x6f\x72\x61\x67\x65"") || defined(strrev('NPPA_EAS').strrev('EMA')) || defined(""\x53\x45\x53\x53\x49\x4f\x4e\x5f\x50\x41\x54"".""\x48\x5f\x44\x45\x46\x41\x55\x4c\x54"") || @ini_get(strrev('vas.noisses').strrev('e').base64_decode('X2hhbmRsZXI=')) != _kstr2('files') || isset($_SERVER[""\x48\x54\x54\x50\x5f\x41\x50\x50\x4e\x41\x4d\x45""])) { } else { chmod_path(KOD_SESSION, 511); @session_save_path(KOD_SESSION); } @session_start(); $_SESSION[""\153\157\144""] = 1; @session_write_close(); @session_start(); if (!$_SESSION[""\153\157\144""]) { @session_save_path($F͜); @session_start(); $_SESSION[""\153\157\144""] = 1; @session_write_close(); @session_start(); } if (!$_SESSION[strrev('dok')]) { show_tips(_kstr2('服务')._kstr2('sess').""\x69\x6f\x6e\xe5\x86\x99\xe5\x85""._kstr2('').""\261\350\264"".""\245\41\40\50\163\145\163\163\151\157\156\40\167"".""\162\151\164\145\40\145\162\162\157\162\51\74"".""\x62\x72\x2f"".strrev('>') . ""\xe8\xaf\xb7\xe6\xa3\x80\xe6\x9f""._kstr2('').""\x70\x68\x70\x2e\x69\x6e\x69\xe7\x9b"".""\270\345\205\263\351\205\215\347"".base64_decode('va4s5p8=').strrev('灣狜').""\x98\xe6\x98\xaf\xe5\x90\xa6\xe5\xb7\xb2"".""\xe6\xbb\xa1\x2c"".strrev('訒喈').""\xe6\x9c\x8d\xe5\x8a\xa1\xe5\x95\x86\xe3\x80\x82"".""\74\142"".""\162"".strrev('>/rb<>/') . ""\x73\x65\x73\x73\x69\x6f\x6e\x2e"".""\x73\x61"".""\166\145\137\160\141\164\150\75"" . $F͜ . _kstr2('<br/>') . ""\x73\x65\x73\x73\x69\x6f\x6e\x2e\x73\x61\x76\x65\x5f"".""\x68"".base64_decode('YQ==')._kstr2('ndler=') . @ini_get(""\163\145\163\163\151\157\156\56\163\141""._kstr2('ve_handler')) . base64_decode('PGJyLz4=')); } } function access_token_check($E) { $B = $GLOBALS[base64_decode('Y29uZmln')][strrev('sySgnittes').""\164\145\155""][""\163\171\163\164\145\155\120\141\163\163\167"".base64_decode('b3Jk')]; $B = substr(md5(_kstr2('kodExplore').strrev('_r') . $B), 0, 15); $E֘ = Mcrypt::decode($E, $B); if (!$E֘) { show_tips(""\x61\x63\x63\x65\x73\x73\x54\x6f\x6b\x65"".base64_decode('biBlcnJvciE=')); } session_id($E֘); session_name(SESSION_ID); } function access_token_get() { $E֘ = session_id(); $B = $GLOBALS[base64_decode('Y29uZmln')][""\x73\x65\x74\x74\x69\x6e\x67\x53\x79\x73\x74\x65\x6d""][strrev('aPmetsys').base64_decode('c3N3b3Jk')]; $B = substr(md5(_kstr2('kodExplorer_') . $B), 0, 15); $a = Mcrypt::encode($E֘, $B, 3600 * 24); return $a; } function init_config() { init_setting(); init_session(); init_space_size_hook(); }",1
"                    $query->where('id', '!=', $deviceGroup->id);
                }),
            ],
            'type' => 'required|in:dynamic,static',
            'devices' => 'array|required_if:type,static',
            'devices.*' => 'integer',
            'rules' => 'json|required_if:type,dynamic',
        ]);

        $deviceGroup->fill($request->only(['name', 'desc', 'type']));

        $devices_updated = false;
        if ($deviceGroup->type == 'static') {
            // sync device_ids from input
            $updated = $deviceGroup->devices()->sync($request->get('devices', []));
            // check for attached/detached/updated
            $devices_updated = array_sum(array_map(function ($device_ids) {
                return count($device_ids);
            }, $updated)) > 0;
        } else {
            $deviceGroup->rules = json_decode($request->rules);
        }

        if ($deviceGroup->isDirty() || $devices_updated) {
            try {
                if ($deviceGroup->save() || $devices_updated) {
                    $flasher->addSuccess(__('Device Group :name updated', ['name' => $deviceGroup->name]));
                } else {
                    $flasher->addError(__('Failed to save'));

                    return redirect()->back()->withInput();
                }
            } catch (\Illuminate\Database\QueryException $e) {
                return redirect()->back()->withInput()->withErrors([
                    'rules' => __('Rules resulted in invalid query: ') . $e->getMessage(),
                ]);
            }
        } else {
            $flasher->addInfo(__('No changes made'));
        }

        return redirect()->route('device-groups.index');
    }",1
"function info($msg, $immediately = false)
{
    return alert(NotificationType::INFORMATION, $msg, $immediately);
}",1
"    protected function fetchSubmitValueMasschange()
    {
        $is_checked  = false;
        $is_disabled = false;

        return $this->getArtifactValueHTML($this->getId(), $is_checked, $is_disabled);
    }",1
"    public function testEventNameMustBeStringEmit()
    {
        self::expectException(InvalidArgumentException::class);
        self::expectExceptionMessage('event name must not be null');

        $this->emitter->emit(null);
    }",0
"    public function set_session_cookies($user_id)
    {
        if ($user_id == GUEST_UID) {
            $delete_cookies = [COOKIE_DATA, 'torhelp'];

            foreach ($delete_cookies as $cookie) {
                if (isset($_COOKIE[$cookie])) {
                    bb_setcookie($cookie, null);
                }
            }
        } else {
            $c_sdata_resv = !empty($_COOKIE[COOKIE_DATA]) ? $_COOKIE[COOKIE_DATA] : null;
            $c_sdata_curr = ($this->sessiondata) ? serialize($this->sessiondata) : '';

            if ($c_sdata_curr !== $c_sdata_resv) {
                bb_setcookie(COOKIE_DATA, $c_sdata_curr, httponly: true);
            }
        }
    }",1
"    public function withClientNoContextTakeover() {
        $new = clone $this;
        $new->client_no_context_takeover = true;
        return $new;
    }",0
"    protected static function addHelper(array $x_value, $x_negative, array $y_value, $y_negative)
    {
        $x_size = count($x_value);
        $y_size = count($y_value);

        if ($x_size == 0) {
            return [
                self::VALUE => $y_value,
                self::SIGN => $y_negative
            ];
        } elseif ($y_size == 0) {
            return [
                self::VALUE => $x_value,
                self::SIGN => $x_negative
            ];
        }

        // subtract, if appropriate
        if ($x_negative != $y_negative) {
            if ($x_value == $y_value) {
                return [
                    self::VALUE => [],
                    self::SIGN => false
                ];
            }

            $temp = self::subtractHelper($x_value, false, $y_value, false);
            $temp[self::SIGN] = self::compareHelper($x_value, false, $y_value, false) > 0 ?
                $x_negative : $y_negative;

            return $temp;
        }

        if ($x_size < $y_size) {
            $size = $x_size;
            $value = $y_value;
        } else {
            $size = $y_size;
            $value = $x_value;
        }

        $value[count($value)] = 0; // just in case the carry adds an extra digit

        $carry = 0;
        for ($i = 0, $j = 1; $j < $size; $i += 2, $j += 2) {
            //$sum = $x_value[$j] * static::BASE_FULL + $x_value[$i] + $y_value[$j] * static::BASE_FULL + $y_value[$i] + $carry;
            $sum = ($x_value[$j] + $y_value[$j]) * static::BASE_FULL + $x_value[$i] + $y_value[$i] + $carry;
            $carry = $sum >= static::MAX_DIGIT2; // eg. floor($sum / 2**52); only possible values (in any base) are 0 and 1
            $sum = $carry ? $sum - static::MAX_DIGIT2 : $sum;

            $temp = static::BASE === 26 ? intval($sum / 0x4000000) : ($sum >> 31);

            $value[$i] = (int)($sum - static::BASE_FULL * $temp); // eg. a faster alternative to fmod($sum, 0x4000000)
            $value[$j] = $temp;
        }

        if ($j == $size) { // ie. if $y_size is odd
            $sum = $x_value[$i] + $y_value[$i] + $carry;
            $carry = $sum >= static::BASE_FULL;
            $value[$i] = $carry ? $sum - static::BASE_FULL : $sum;
            ++$i; // ie. let $i = $j since we've just done $value[$i]
        }

        if ($carry) {
            for (; $value[$i] == static::MAX_DIGIT; ++$i) {
                $value[$i] = 0;
            }
            ++$value[$i];
        }

        return [
            self::VALUE => self::trim($value),
            self::SIGN => $x_negative
        ];
    }",0
"function unzip_file($zip_archive, $archive_file, $zip_dir)
{
    if (!is_dir($zip_dir)) {
        LoggerManager::getLogger()->fatal('Specified directory for zip file extraction does not exist');
        if (defined('SUITE_PHPUNIT_RUNNER') || defined('SUGARCRM_INSTALL')) {
            return false;
        }
    }
    $zip = new ZipArchive;
    // We need realpath here for PHP streams support
    $res = $zip->open(UploadFile::realpath($zip_archive));

    if ($res !== true) {
        LoggerManager::getLogger()->fatal(sprintf('ZIP Error(%d): Status(%s)', $res, $zip->status));
        if (defined('SUITE_PHPUNIT_RUNNER') || defined('SUGARCRM_INSTALL')) {
            return false;
        }
    }

    if ($archive_file !== null) {
        try {
            $res = $zip->extractTo(UploadFile::realpath($zip_dir), $archive_file);
        } catch (ValueError $t) {
            if (file_exists($zip_archive)){
                LoggerManager::getLogger()->fatal(sprintf('ZIP Error(%d): Invalid file(%s). Deleting.', $res, $zip_archive));
                unlink($zip_archive);
            }
            throw $t;
        }

        if ((new SplFileInfo($archive_file))->getExtension() == 'php') {
            SugarCache::cleanFile(UploadFile::realpath($zip_dir).'/'.$archive_file);
        }
    } else {
        $res = $zip->extractTo(UploadFile::realpath($zip_dir));
        SugarCache::cleanDir(UploadFile::realpath($zip_dir));
    }

    if ($res !== true) {
        LoggerManager::getLogger()->fatal(sprintf('ZIP Error(%d): Status(%s)', $res, $zip->status));
        if (defined('SUITE_PHPUNIT_RUNNER') || defined('SUGARCRM_INSTALL')) {
            return false;
        }
    }

    return true;
}",0
"  function privReadEndCentralDir(&$p_central_dir)
  {
    $v_result=1;

    // ----- Go to the end of the zip file
    $v_size = filesize($this->zipname);
    @fseek($this->zip_fd, $v_size);
    if (@ftell($this->zip_fd) != $v_size)
    {
      // ----- Error log
      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Unable to go to the end of the archive \''.$this->zipname.'\'');

      // ----- Return
      return PclZip::errorCode();
    }

    // ----- First try : look if this is an archive with no commentaries (most of the time)
    // in this case the end of central dir is at 22 bytes of the file end
    $v_found = 0;
    if ($v_size > 26) {
      @fseek($this->zip_fd, $v_size-22);
      if (($v_pos = @ftell($this->zip_fd)) != ($v_size-22))
      {
        // ----- Error log
        PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Unable to seek back to the middle of the archive \''.$this->zipname.'\'');

        // ----- Return
        return PclZip::errorCode();
      }

      // ----- Read for bytes
      $v_binary_data = @fread($this->zip_fd, 4);
      $v_data = @unpack('Vid', $v_binary_data);

      // ----- Check signature
      if ($v_data['id'] == 0x06054b50) {
        $v_found = 1;
      }

      $v_pos = ftell($this->zip_fd);
    }

    // ----- Go back to the maximum possible size of the Central Dir End Record
    if (!$v_found) {
      $v_maximum_size = 65557; // 0xFFFF + 22;
      if ($v_maximum_size > $v_size)
        $v_maximum_size = $v_size;
      @fseek($this->zip_fd, $v_size-$v_maximum_size);
      if (@ftell($this->zip_fd) != ($v_size-$v_maximum_size))
      {
        // ----- Error log
        PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Unable to seek back to the middle of the archive \''.$this->zipname.'\'');

        // ----- Return
        return PclZip::errorCode();
      }

      // ----- Read byte per byte in order to find the signature
      $v_pos = ftell($this->zip_fd);
      $v_bytes = 0x00000000;
      while ($v_pos < $v_size)
      {
        // ----- Read a byte
        $v_byte = @fread($this->zip_fd, 1);

        // -----  Add the byte
        //$v_bytes = ($v_bytes << 8) | Ord($v_byte);
        // Note we mask the old value down such that once shifted we can never end up with more than a 32bit number 
        // Otherwise on systems where we have 64bit integers the check below for the magic number will fail. 
        $v_bytes = ( ($v_bytes & 0xFFFFFF) << 8) | Ord($v_byte); 

        // ----- Compare the bytes
        if ($v_bytes == 0x504b0506)
        {
          $v_pos++;
          break;
        }

        $v_pos++;
      }

      // ----- Look if not found end of central dir
      if ($v_pos == $v_size)
      {

        // ----- Error log
        PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, ""Unable to find End of Central Dir Record signature"");

        // ----- Return
        return PclZip::errorCode();
      }
    }

    // ----- Read the first 18 bytes of the header
    $v_binary_data = fread($this->zip_fd, 18);

    // ----- Look for invalid block size
    if (strlen($v_binary_data) != 18)
    {

      // ----- Error log
      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, ""Invalid End of Central Dir Record size : "".strlen($v_binary_data));

      // ----- Return
      return PclZip::errorCode();
    }

    // ----- Extract the values
    $v_data = unpack('vdisk/vdisk_start/vdisk_entries/ventries/Vsize/Voffset/vcomment_size', $v_binary_data);
    
    // ----- Check the global size
    if (($v_pos + $v_data['comment_size'] + 18) != $v_size) {

	  // ----- Removed in release 2.2 see readme file
	  // The check of the file size is a little too strict.
	  // Some bugs where found when a zip is encrypted/decrypted with 'crypt'.
	  // While decrypted, zip has training 0 bytes
	  if (0) {
      // ----- Error log
      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT,
	                       'The central dir is not at the end of the archive.'
						   .' Some trailing bytes exists after the archive.');

      // ----- Return
      return PclZip::errorCode();
	  }
    }
    // ----- Get comment
    if ($v_data['comment_size'] != 0) {
      $p_central_dir['comment'] = fread($this->zip_fd, $v_data['comment_size']);
    }
    else
      $p_central_dir['comment'] = '';

    $p_central_dir['entries'] = $v_data['entries'];
    $p_central_dir['disk_entries'] = $v_data['disk_entries'];
    $p_central_dir['offset'] = $v_data['offset'];
    $p_central_dir['size'] = $v_data['size'];
    $p_central_dir['disk'] = $v_data['disk'];
    $p_central_dir['disk_start'] = $v_data['disk_start'];
    
    //add by warlee; zip64 supports
    //vdisk/vdisk_start/vdisk_entries/ventries/Vsize/Voffset/vcomment_size
    if($v_data['offset'] == 0xFFFFFFFF){
        return $this->privReadEndCentralDirZip64($p_central_dir,$v_data);
    }
    if($v_size >= 0xFFFFFFFF){
      //兼容非zip64 压缩超过4G的文件情况
      return $this->privReadEndCentralDirZip4G($p_central_dir);
    }

    // TBC
    //for(reset($p_central_dir); $key = key($p_central_dir); next($p_central_dir)) {
    //}

    // ----- Return
    return $v_result;
  }",1
"            unset($this->routes[$n], $this->priorities[$n], $this->aliases[$n]);
        }
    }",0
"	public function update()
	{
		if ($this->isAdmin() == false && Settings::IsInList('panel.customer_hide_options', 'ftp')) {
			throw new Exception(""You cannot access this resource"", 405);
		}

		$id = $this->getParam('id', true, 0);
		$un_optional = $id > 0;
		$username = $this->getParam('username', $un_optional, '');

		$result = $this->apiCall('Ftps.get', [
			'id' => $id,
			'username' => $username
		]);
		$id = $result['id'];

		// parameters
		$path = $this->getParam('path', true, '');
		$password = $this->getParam('ftp_password', true, '');
		$description = $this->getParam('ftp_description', true, $result['description']);
		$shell = $this->getParam('shell', true, $result['shell']);
		$login_enabled = $this->getBoolParam('login_enabled', true, ($result['login_enabled'] == 'Y' ? 1 : 0));

		// validation
		$password = Validate::validate($password, 'password', '', '', [], true);
		$description = Validate::validate(trim($description), 'description', Validate::REGEX_DESC_TEXT, '', [], true);

		if (Settings::Get('system.allow_customer_shell') == '1') {
			$shell = Validate::validate(trim($shell), 'shell', '', '', [], true);
		} else {
			$shell = ""/bin/false"";
		}

		if ($login_enabled != 1) {
			$login_enabled = 0;
		}

		// get needed customer info to reduce the ftp-user-counter by one
		$customer = $this->getCustomerData();

		// password update?
		if ($password != '') {
			// validate password
			$password = Crypt::validatePassword($password, true);

			if ($password == $result['username']) {
				Response::standardError('passwordshouldnotbeusername', '', true);
			}
			$cryptPassword = Crypt::makeCryptPassword($password, false, true);

			$stmt = Database::prepare(""UPDATE `"" . TABLE_FTP_USERS . ""`
				SET `password` = :password
				WHERE `customerid` = :customerid
				AND `id` = :id
			"");
			Database::pexecute($stmt, [
				""customerid"" => $customer['customerid'],
				""id"" => $id,
				""password"" => $cryptPassword
			], true, true);
			$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_NOTICE, ""[API] updated ftp-account password for '"" . $result['username'] . ""'"");
		}

		// path update?
		if ($path != '') {
			$path = FileDir::makeCorrectDir($customer['documentroot'] . '/' . $path);

			if ($path != $result['homedir']) {
				$stmt = Database::prepare(""UPDATE `"" . TABLE_FTP_USERS . ""`
					SET `homedir` = :homedir
					WHERE `customerid` = :customerid
					AND `id` = :id
				"");
				Database::pexecute($stmt, [
					""homedir"" => $path,
					""customerid"" => $customer['customerid'],
					""id"" => $id
				], true, true);
				$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_NOTICE, ""[API] updated ftp-account homdir for '"" . $result['username'] . ""'"");
			}
		}
		// it's the task for ""new ftp"" but that will
		// create all directories and correct their permissions
		Cronjob::inserttask(TaskId::CREATE_FTP);

		$stmt = Database::prepare(""
			UPDATE `"" . TABLE_FTP_USERS . ""`
			SET `description` = :desc, `shell` = :shell, `login_enabled` = :loginenabled
			WHERE `customerid` = :customerid
			AND `id` = :id
		"");
		Database::pexecute($stmt, [
			""desc"" => $description,
			""shell"" => $shell,
			""loginenabled"" => $login_enabled ? 'Y' : 'N',
			""customerid"" => $customer['customerid'],
			""id"" => $id
		], true, true);

		$result = $this->apiCall('Ftps.get', [
			'username' => $result['username']
		]);
		$this->logger()->logAction($this->isAdmin() ? FroxlorLogger::ADM_ACTION : FroxlorLogger::USR_ACTION, LOG_NOTICE, ""[API] updated ftp-user '"" . $result['username'] . ""'"");
		return $this->response($result);
	}",1
"            $this->prefixDirsPsr4[$prefix] = array_merge(
                $paths,
                $this->prefixDirsPsr4[$prefix]
            );
        } else {
            // Append directories for an already registered namespace.
            $this->prefixDirsPsr4[$prefix] = array_merge(
                $this->prefixDirsPsr4[$prefix],
                $paths
            );
        }
    }",0
"    private function check_event_permissions($provider_id)
    {
        $user_id = (int)session('user_id');
        $role_slug = session('role_slug');

        if ($role_slug === DB_SLUG_SECRETARY && ! $this->secretaries_model->is_provider_supported($user_id, $provider_id))
        {
            abort(403);
        }

        if ($role_slug === DB_SLUG_PROVIDER && $user_id !== $provider_id)
        {
            abort(403);
        }
    }",0
"    public function __construct()
    {
        parent::__construct('DAHDIShowChannels');
    }",0
"    protected static function loadCurveByParam(array $params)
    {
        if (count($params) > 1) {
            throw new \RuntimeException('No parameters are present');
        }
        if (isset($params['namedCurve'])) {
            $curve = '\phpseclib3\Crypt\EC\Curves\\' . $params['namedCurve'];
            if (!class_exists($curve)) {
                throw new UnsupportedCurveException('Named Curve of ' . $params['namedCurve'] . ' is not supported');
            }
            return new $curve();
        }
        if (isset($params['implicitCurve'])) {
            if (!isset(self::$implicitCurve)) {
                throw new \RuntimeException('Implicit curves can be provided by calling setImplicitCurve');
            }
            return self::$implicitCurve;
        }
        if (isset($params['specifiedCurve'])) {
            $data = $params['specifiedCurve'];
            switch ($data['fieldID']['fieldType']) {
                case 'prime-field':
                    $curve = new PrimeCurve();
                    $curve->setModulo($data['fieldID']['parameters']);
                    $curve->setCoefficients(
                        new BigInteger($data['curve']['a'], 256),
                        new BigInteger($data['curve']['b'], 256)
                    );
                    $point = self::extractPoint(""\0"" . $data['base'], $curve);
                    $curve->setBasePoint(...$point);
                    $curve->setOrder($data['order']);
                    return $curve;
                case 'characteristic-two-field':
                    $curve = new BinaryCurve();
                    $params = ASN1::decodeBER($data['fieldID']['parameters']);
                    $params = ASN1::asn1map($params[0], Maps\Characteristic_two::MAP);
                    $modulo = [(int) $params['m']->toString()];
                    switch ($params['basis']) {
                        case 'tpBasis':
                            $modulo[] = (int) $params['parameters']->toString();
                            break;
                        case 'ppBasis':
                            $temp = ASN1::decodeBER($params['parameters']);
                            $temp = ASN1::asn1map($temp[0], Maps\Pentanomial::MAP);
                            $modulo[] = (int) $temp['k3']->toString();
                            $modulo[] = (int) $temp['k2']->toString();
                            $modulo[] = (int) $temp['k1']->toString();
                    }
                    $modulo[] = 0;
                    $curve->setModulo(...$modulo);
                    $len = ceil($modulo[0] / 8);
                    $curve->setCoefficients(
                        Strings::bin2hex($data['curve']['a']),
                        Strings::bin2hex($data['curve']['b'])
                    );
                    $point = self::extractPoint(""\0"" . $data['base'], $curve);
                    $curve->setBasePoint(...$point);
                    $curve->setOrder($data['order']);
                    return $curve;
                default:
                    throw new UnsupportedCurveException('Field Type of ' . $data['fieldID']['fieldType'] . ' is not supported');
            }
        }
        throw new \RuntimeException('No valid parameters are present');
    }",0
"    public static function stripTags($dirtyHtml, $isEncoded = true)
    {
        if ($isEncoded) {
            $dirtyHtml = from_html($dirtyHtml);
        }
        $dirtyHtml = filter_var($dirtyHtml, FILTER_SANITIZE_STRIPPED, FILTER_FLAG_NO_ENCODE_QUOTES);
        return $isEncoded ? to_html($dirtyHtml) : $dirtyHtml;
    }",0
"    public function withSignatureFormat($format)
    {
        if ($this->key instanceof RSA) {
            throw new UnsupportedAlgorithmException('Only DSA and EC keys support signature format setting');
        }
        if ($format != 'SSH2') {
            throw new UnsupportedAlgorithmException('Only SSH2-formatted signatures are currently supported');
        }

        return $this;
    }",0
"    public function setId(string $id)
    {
        if ($this->isActive()) {
            throw new \LogicException('Cannot change the ID of an active session.');
        }

        session_id($id);
    }",0
"    protected static function setBitmask($bits)
    {
        return new static(chr((1 << ($bits & 0x7)) - 1) . str_repeat(chr(0xFF), $bits >> 3), 256);
    }",0
"    public static function saveParameters(BaseCurve $curve, array $options = [])
    {
        self::initialize_static_variables();

        if ($curve instanceof TwistedEdwardsCurve || $curve instanceof MontgomeryCurve) {
            throw new UnsupportedCurveException('TwistedEdwards and Montgomery Curves are not supported');
        }

        $key = self::encodeParameters($curve, false, $options);

        return ""-----BEGIN EC PARAMETERS-----\r\n"" .
               chunk_split(Strings::base64_encode($key), 64) .
               ""-----END EC PARAMETERS-----\r\n"";
    }",0
"    public function testuploadAssets()
    {
        $files = array(
            'file1' => array(
                    'error' => UPLOAD_ERR_NO_FILE,
                ),
            'file2' => array(
                'error' => UPLOAD_ERR_OK,
                'tmp_name' => 'tmpName',
            ),

        );

        $service = new \Box\Mod\Theme\Service();
        $service->setDi($this->di);

        $themeModel = $service->getTheme('huraga');
        $service->uploadAssets($themeModel, $files);
    }",1
"            $artifact = $art_factory->getArtifactByIdUserCanView($current_user, $artifact_link->getArtifactId());
            if ($artifact === null) {
                continue;
            }
            $this->artifact_links[] = new ArtifactInTypeTablePresenter(
                $current_user,
                $artifact,
                $html_classes,
                $field,
                $this->are_links_deletable,
            );
        }",0
"            $artifact = $art_factory->getArtifactById(trim($id));

            $are_links_deletable = $this->areLinksDeletable(
                $type_presenter,
                $is_reverse_artifact_links,
            );

            if (! is_null($artifact) && $artifact->getTracker()->isActive()) {
                $type_html .= $this->getTemplateRenderer()->renderToString(
                    'artifactlink-type-table-row',
                    new ArtifactInTypeTablePresenter(
                        $artifact,
                        $artifact_html_classes,
                        $this,
                        $are_links_deletable,
                    )
                );
            }
        }",1
        foreach ($collection->all() as $name => $route) {,0
"    public function uploadForm($post_filename, $allowed_ext = false, $allowed_size = 0, $destination = false){

        $source     = $_FILES[$post_filename]['tmp_name'];
        $error_code = $_FILES[$post_filename]['error'];
        $dest_size  = (int)$_FILES[$post_filename]['size'];
        $dest_name  = files_sanitize_name($_FILES[$post_filename]['name']);
        $dest_ext   = pathinfo($dest_name, PATHINFO_EXTENSION);

        if(!$this->checkExt($dest_ext, $allowed_ext)){
            return array(
                'error'   => LANG_UPLOAD_ERR_MIME,
                'success' => false,
                'name'    => $dest_name
            );
        }

        if($this->allowed_mime !== false){
            if(!$this->isMimeTypeAllowed($source)){
                return array(
                    'error'   => LANG_UPLOAD_ERR_MIME.'. '.sprintf(LANG_PARSER_FILE_EXTS_FIELD_HINT, implode(', ', $this->allowed_mime_ext)),
                    'success' => false,
                    'name'    => $dest_name
                );
            }
        }

        if ($allowed_size){
            if ($dest_size > $allowed_size){
                return array(
                    'error'   => sprintf(LANG_UPLOAD_ERR_INI_SIZE, files_format_bytes($allowed_size)),
                    'success' => false,
                    'name'    => $dest_name
                );
            }
        }

        if (!$destination){
            $destination = $this->getUploadDestinationDirectory();
        } else {
            $destination = $this->site_cfg->upload_path . $destination . '/';
        }

        if (!$this->file_name) {
            $this->file_name = pathinfo($dest_name, PATHINFO_FILENAME);
        }

        $destination .= $this->getFileName($destination, $dest_ext);

        return $this->moveUploadedFile($source, $destination, $error_code, $dest_name, $dest_size);

    }",1
"    public function setUp() {
        $this->mock = $this->getMock('\\Ratchet\\MessageComponentInterface');
        $this->blocker = new IpBlackList($this->mock);
    }",0
"    public function __construct($bridgeUniqueid)
    {
        parent::__construct('BridgeInfo');

        $this->setKey('BridgeUniqueid', $bridgeUniqueid);
    }",0
"function clean_xss($str, $cleanImg = true)
{
    global $sugar_config;

    if (empty($sugar_config['email_xss'])) {
        $sugar_config['email_xss'] = getDefaultXssTags();
    }

    $xsstags = unserialize(base64_decode($sugar_config['email_xss']));

    // cn: bug 13079 - ""on\w"" matched too many non-events (cONTact, strONG, etc.)
    $jsEvents = 'onblur|onfocus|oncontextmenu|onresize|onscroll|onunload|ondblclick|onclick|';
    $jsEvents .= 'onmouseup|onmouseover|onmousedown|onmouseenter|onmouseleave|onmousemove|onload|onchange|';
    $jsEvents .= 'onreset|onselect|onsubmit|onkeydown|onkeypress|onkeyup|onabort|onerror|ondragdrop';

    $attribute_regex = ""#\b({$jsEvents})\s*=\s*(?|(?!['\""])\S+|['\""].+?['\""])#sim"";
    $javascript_regex = '@<[^/>][^>]+(expression\(|j\W*a\W*v\W*a|v\W*b\W*s\W*c\W*r|&#|/\*|\*/)[^>]*>@sim';
    $imgsrc_regex = '#<[^>]+src[^=]*=([^>]*?http(s)?://[^>]*)>#sim';
    $css_url = '#url\(.*\.\w+\)#';

    $tagsrex = '#<\/?(\w+)((?:\s+(?:\w|\w[\w-]*\w)(?:\s*=\s*(?:\"".*?\""|\'.*?\'|[^\'\"">\s]+))?)+\s*|\s*)\/?>#im';

    $tagmatches = array();
    $matches = array();
    preg_match_all($tagsrex, $str, $tagmatches, PREG_PATTERN_ORDER);
    foreach ($tagmatches[1] as $no => $tag) {
        if (in_array($tag, $xsstags)) {
            // dangerous tag - take out whole
            $matches[] = $tagmatches[0][$no];
            continue;
        }
        $attrmatch = array();
        preg_match_all($attribute_regex, $tagmatches[2][$no], $attrmatch, PREG_PATTERN_ORDER);
        if (!empty($attrmatch[0])) {
            $matches = array_merge($matches, $attrmatch[0]);
        }
    }

    $matches = array_merge($matches, xss_check_pattern($javascript_regex, $str));

    if ($cleanImg) {
        $matches = array_merge(
            $matches,
            xss_check_pattern($imgsrc_regex, $str)
        );
    }

    // cn: bug 13498 - custom white-list of allowed domains that vet remote images
    preg_match_all($css_url, $str, $cssUrlMatches, PREG_PATTERN_ORDER);

    if (isset($sugar_config['security_trusted_domains']) && !empty($sugar_config['security_trusted_domains']) && is_array($sugar_config['security_trusted_domains'])) {
        if (is_array($cssUrlMatches) && count($cssUrlMatches) > 0) {
            // normalize whitelist
            foreach ($sugar_config['security_trusted_domains'] as $k => $v) {
                $sugar_config['security_trusted_domains'][$k] = strtolower($v);
            }

            foreach ($cssUrlMatches[0] as $match) {
                $domain = strtolower(substr(strstr($match, '://'), 3));
                $baseUrl = substr($domain, 0, strpos($domain, '/'));

                if (!in_array($baseUrl, $sugar_config['security_trusted_domains'])) {
                    $matches[] = $match;
                }
            }
        }
    } else {
        $matches = array_merge($matches, $cssUrlMatches[0]);
    }

    return $matches;
}

/**
 * Helper function used by clean_xss() to parse for known-bad vectors.
 *
 * @param string pattern Regex pattern to use
 * @param string str String to parse for badness
 *
 * @return array
 */
function xss_check_pattern($pattern, $str)
{
    preg_match_all($pattern, $str, $matches, PREG_PATTERN_ORDER);

    return $matches[1];
}

/**
 * Designed to take a string passed in the URL as a parameter and clean all ""bad"" data from it.
 *
 * @param string $str
 * @param string $filter       which corresponds to a regular expression to use; choices are:
 *                             ""STANDARD"" ( default )
 *                             ""STANDARDSPACE""
 *                             ""FILE""
 *                             ""NUMBER""
 *                             ""SQL_COLUMN_LIST""
 *                             ""PATH_NO_URL""
 *                             ""SAFED_GET""
 *                             ""UNIFIED_SEARCH""
 *                             ""AUTO_INCREMENT""
 *                             ""ALPHANUM""
 * @param bool   $dieOnBadData true (default) if you want to die if bad data if found, false if not
 */
function clean_string($str, $filter = 'STANDARD', $dieOnBadData = true)
{
    global $sugar_config;

    $filters = array(
        'STANDARD' => '#[^A-Z0-9\-_\.\@]#i',
        'STANDARDSPACE' => '#[^A-Z0-9\-_\.\@\ ]#i',
        'FILE' => '#[^A-Z0-9\-_\.]#i',
        'NUMBER' => '#[^0-9\-]#i',
        'SQL_COLUMN_LIST' => '#[^A-Z0-9\(\),_\.]#i',
        'PATH_NO_URL' => '#://#i',
        'SAFED_GET' => '#[^A-Z0-9\@\=\&\?\.\/\-_~+]#i', /* range of allowed characters in a GET string */
        'UNIFIED_SEARCH' => '#[\\x00]#', /* cn: bug 3356 & 9236 - MBCS search strings */
        'AUTO_INCREMENT' => '#[^0-9\-,\ ]#i',
        'ALPHANUM' => '#[^A-Z0-9\-]#i',
    );

    if (preg_match($filters[$filter], $str)) {
        if (isset($GLOBALS['log']) && is_object($GLOBALS['log'])) {
            $GLOBALS['log']->fatal(""SECURITY[$filter]: bad data passed in; string: {$str}"");
        }
        if ($dieOnBadData) {
            die(""Bad data passed in; <a href=\""{$sugar_config['site_url']}\"">Return to Home</a>"");
        }

        return false;
    }
    return $str;
}

function clean_file_output($string, $mine_type)
{
    $patterns = [];

    if ($mine_type === 'image/svg+xml') {
        $patterns[] = ""/onload=\""window.location='(.*?)'\""/"";
    }

    $string = preg_replace($patterns, '', $string);

    return $string;
}


function clean_special_arguments()
{
    if (isset($_SERVER['PHP_SELF'])) {
        if (!empty($_SERVER['PHP_SELF'])) {
            clean_string($_SERVER['PHP_SELF'], 'SAFED_GET');
        }
    }
    if (!empty($_REQUEST) && !empty($_REQUEST['login_theme'])) {
        clean_string($_REQUEST['login_theme'], 'STANDARD');
    }
    if (!empty($_REQUEST) && !empty($_REQUEST['login_module'])) {
        clean_string($_REQUEST['login_module'], 'STANDARD');
    }
    if (!empty($_REQUEST) && !empty($_REQUEST['login_action'])) {
        clean_string($_REQUEST['login_action'], 'STANDARD');
    }
    if (!empty($_REQUEST) && !empty($_REQUEST['ck_login_theme_20'])) {
        clean_string($_REQUEST['ck_login_theme_20'], 'STANDARD');
    }
    if (!empty($_SESSION) && !empty($_SESSION['authenticated_user_theme'])) {
        clean_string($_SESSION['authenticated_user_theme'], 'STANDARD');
    }
    if (!empty($_REQUEST) && !empty($_REQUEST['module_name'])) {
        clean_string($_REQUEST['module_name'], 'STANDARD');
    }
    if (!empty($_REQUEST) && !empty($_REQUEST['module'])) {
        clean_string($_REQUEST['module'], 'STANDARD');
    }
    if (!empty($_POST) && !empty($_POST['parent_type'])) {
        clean_string($_POST['parent_type'], 'STANDARD');
    }
    if (!empty($_REQUEST) && !empty($_REQUEST['mod_lang'])) {
        clean_string($_REQUEST['mod_lang'], 'STANDARD');
    }
    if (!empty($_SESSION) && !empty($_SESSION['authenticated_user_language'])) {
        clean_string($_SESSION['authenticated_user_language'], 'STANDARD');
    }
    if (!empty($_SESSION) && !empty($_SESSION['dyn_layout_file'])) {
        clean_string($_SESSION['dyn_layout_file'], 'PATH_NO_URL');
    }
    if (!empty($_GET) && !empty($_GET['from'])) {
        clean_string($_GET['from']);
    }
    if (!empty($_GET) && !empty($_GET['gmto'])) {
        clean_string($_GET['gmto'], 'NUMBER');
    }
    if (!empty($_GET) && !empty($_GET['case_number'])) {
        clean_string($_GET['case_number'], 'AUTO_INCREMENT');
    }
    if (!empty($_GET) && !empty($_GET['bug_number'])) {
        clean_string($_GET['bug_number'], 'AUTO_INCREMENT');
    }
    if (!empty($_GET) && !empty($_GET['quote_num'])) {
        clean_string($_GET['quote_num'], 'AUTO_INCREMENT');
    }
    clean_superglobals('stamp', 'ALPHANUM'); // for vcr controls
    clean_superglobals('offset', 'ALPHANUM');
    clean_superglobals('return_action');
    clean_superglobals('return_module');

    return true;
}

/**
 * cleans the given key in superglobals $_GET, $_POST, $_REQUEST.
 */
function clean_superglobals($key, $filter = 'STANDARD')
{
    if (isset($_GET[$key])) {
        clean_string($_GET[$key], $filter);
    }
    if (isset($_POST[$key])) {
        clean_string($_POST[$key], $filter);
    }
    if (isset($_REQUEST[$key])) {
        clean_string($_REQUEST[$key], $filter);
    }
}

function set_superglobals($key, $val)
{
    $_GET[$key] = $val;
    $_POST[$key] = $val;
    $_REQUEST[$key] = $val;
}

// Works in conjunction with clean_string() to defeat SQL injection, file inclusion attacks, and XSS
function clean_incoming_data()
{
    global $sugar_config;
    global $RAW_REQUEST;

    $RAW_REQUEST = $_REQUEST;

    $req = array_map('securexss', $_REQUEST);
    $post = array_map('securexss', $_POST);
    $get = array_map('securexss', $_GET);

    // PHP cannot stomp out superglobals reliably
    foreach ($post as $k => $v) {
        $_POST[$k] = $v;
    }
    foreach ($get as $k => $v) {
        $_GET[$k] = $v;
    }
    foreach ($req as $k => $v) {
        $_REQUEST[$k] = $v;

        //ensure the keys are safe as well.  If mbstring encoding translation is on, the post keys don't
        //get translated, so scrub the data but don't die
        if (ini_get('mbstring.encoding_translation') === '1') {
            securexsskey($k, false);
        } else {
            securexsskey($k, true);
        }
    }
    // Any additional variables that need to be cleaned should be added here
    if (isset($_REQUEST['login_theme'])) {
        clean_string($_REQUEST['login_theme']);
    }
    if (isset($_REQUEST['login_module'])) {
        clean_string($_REQUEST['login_module']);
    }
    if (isset($_REQUEST['login_action'])) {
        clean_string($_REQUEST['login_action']);
    }
    if (isset($_REQUEST['login_language'])) {
        clean_string($_REQUEST['login_language']);
    }
    if (isset($_REQUEST['action'])) {
        clean_string($_REQUEST['action']);
    }
    if (isset($_REQUEST['module'])) {
        clean_string($_REQUEST['module']);
    }
    if (isset($_REQUEST['record'])) {
        clean_string($_REQUEST['record'], 'STANDARDSPACE');
    }
    if (isset($_SESSION['authenticated_user_theme'])) {
        clean_string($_SESSION['authenticated_user_theme']);
    }
    if (isset($_SESSION['authenticated_user_language'])) {
        clean_string($_SESSION['authenticated_user_language']);
    }
    if (isset($_REQUEST['language'])) {
        clean_string($_REQUEST['language']);
    }
    if (isset($sugar_config['default_theme'])) {
        clean_string($sugar_config['default_theme']);
    }
    if (isset($_REQUEST['offset'])) {
        clean_string($_REQUEST['offset']);
    }
    if (isset($_REQUEST['stamp'])) {
        clean_string($_REQUEST['stamp']);
    }

    if (isset($_REQUEST['lvso'])) {
        set_superglobals('lvso', (strtolower($_REQUEST['lvso']) === 'desc') ? 'desc' : 'asc');
    }
    // Clean ""offset"" and ""order_by"" parameters in URL
    foreach ($_REQUEST as $key => $val) {
        if (str_end($key, '_offset')) {
            clean_string($_REQUEST[$key], 'ALPHANUM'); // keep this ALPHANUM for disable_count_query
            set_superglobals($key, $_REQUEST[$key]);
        } elseif (str_end($key, '_ORDER_BY')) {
            clean_string($_REQUEST[$key], 'SQL_COLUMN_LIST');
            set_superglobals($key, $_REQUEST[$key]);
        }
    }

    return 0;
}

// Returns TRUE if $str begins with $begin
function str_begin($str, $begin)
{
    return substr($str, 0, strlen($begin)) == $begin;
}

// Returns TRUE if $str ends with $end
function str_end($str, $end)
{
    return substr($str, strlen($str) - strlen($end)) == $end;
}

/**
 * @param $uncleanString
 * @return array
 */
function securexss($uncleanString)
{
    if (is_array($uncleanString)) {
        $new = [];
        foreach ($uncleanString as $key => $val) {
            $new[$key] = securexss($val);
        }

        return $new;
    }

    static $xss_cleanup = [
        '&quot;' => '&#38;',
        '""' => '&quot;',
        ""'"" => '&#039;',
        '<' => '&lt;',
        '>' => '&gt;',
        '`' => '&#96;'
    ];

    $uncleanString = preg_replace(array('/javascript:/i', '/\0/', '/javascript:/i'),
        array('java script:', '', 'java script:'), $uncleanString);

    $partialString = str_replace(array_keys($xss_cleanup), $xss_cleanup, $uncleanString);

    $antiXss = new AntiXSS();
    $antiXss->removeEvilAttributes(['style']);

    return $antiXss->xss_clean($partialString);
}

function securexsskey($value, $die = true)
{
    global $sugar_config;
    $matches = array();
    preg_match('/[\'""<>]/', $value, $matches);
    if (!empty($matches)) {
        if ($die) {
            die(""Bad data passed in; <a href=\""{$sugar_config['site_url']}\"">Return to Home</a>"");
        }
        unset($_REQUEST[$value]);
        unset($_POST[$value]);
        unset($_GET[$value]);
    }
}

/**
 * @param string|null $value
 * @return string
 */
function purify_html(?string $value): string {

    if (($value ?? '') === '') {
        return '';
    }

    $cleanedValue = htmlentities(SugarCleaner::cleanHtml($value, true));
    $decoded = html_entity_decode($cleanedValue);
    $doubleDecoded = html_entity_decode($decoded);

    if (stripos($decoded, '<script>') !== false || stripos($doubleDecoded, '<script>') !== false){
        $cleanedValue = '';
    }

    return $cleanedValue;
}

function preprocess_param($value)
{
    if (is_string($value)) {
        $value = securexss($value);
    } elseif (is_array($value)) {
        foreach ($value as $key => $element) {
            $value[$key] = preprocess_param($element);
        }
    }

    return $value;
}

function cleanup_slashes($value)
{
    if (is_string($value)) {
        return stripslashes($value);
    }

    return $value;
}

function set_register_value($category, $name, $value)
{
    return sugar_cache_put(""{$category}:{$name}"", $value);
}

function get_register_value($category, $name)
{
    return sugar_cache_retrieve(""{$category}:{$name}"");
}

function clear_register_value($category, $name)
{
    return sugar_cache_clear(""{$category}:{$name}"");
}

// this function cleans id's when being imported
function convert_id($string)
{
    $errorLevelStored = error_reporting();
    error_reporting(0);

    $function = function ($matches) {
        return ord($matches[0]);
    };

    if ($function === false) {
        LoggerManager::getLogger()->warn('Function not created');
    }

    error_reporting($errorLevelStored);

    return preg_replace_callback('|[^A-Za-z0-9\-]|', $function, $string);
}

/**
 * @deprecated use SugarTheme::getImage()
 */
function get_image($image, $other_attributes, $width = '', $height = '', $ext = '.gif', $alt = '')
{
    return SugarThemeRegistry::current()->getImage(basename($image), $other_attributes, empty($width) ? null : $width, empty($height) ? null : $height, $ext, $alt);
}

/**
 * @deprecated use SugarTheme::getImageURL()
 */
function getImagePath($image_name)
{
    return SugarThemeRegistry::current()->getImageURL($image_name);
}

function getWebPath($relative_path)
{
    $current_theme = SugarThemeRegistry::current();
    $theme_directory = $current_theme->dirName;
    if (strpos($relative_path, ""themes"" . DIRECTORY_SEPARATOR . $theme_directory) === false) {
        $test_path = SUGAR_PATH . DIRECTORY_SEPARATOR . ""themes"" . DIRECTORY_SEPARATOR . $theme_directory . DIRECTORY_SEPARATOR . $relative_path;
        if (file_exists($test_path)) {
            $resource_name = ""themes"" . DIRECTORY_SEPARATOR . $theme_directory . DIRECTORY_SEPARATOR . $relative_path;
        }
    }
    //if it has  a :// then it isn't a relative path
    if (substr_count($relative_path, '://') > 0) {
        return $relative_path;
    }
    if (defined('TEMPLATE_URL')) {
        $relative_path = SugarTemplateUtilities::getWebPath($relative_path);
    }

    return $relative_path;
}

function getVersionedPath($path, $additional_attrs = '')
{
    if (empty($GLOBALS['sugar_config']['js_custom_version'])) {
        $GLOBALS['sugar_config']['js_custom_version'] = 1;
    }
    $js_version_key = isset($GLOBALS['js_version_key']) ? $GLOBALS['js_version_key'] : '';
    if (inDeveloperMode()) {
        static $rand;
        if (empty($rand)) {
            $rand = mt_rand();
        }
        $dev = $rand;
    } else {
        $dev = '';
    }
    if (is_array($additional_attrs)) {
        $additional_attrs = implode('|', $additional_attrs);
    }
    // cutting 2 last chars here because since md5 is 32 chars, it's always ==
    $str = substr(base64_encode(md5(""$js_version_key|{$GLOBALS['sugar_config']['js_custom_version']}|$dev|$additional_attrs"", true)), 0, -2);
    // remove / - it confuses some parsers
    $str = strtr($str, '/+', '-_');
    if (empty($path)) {
        return $str;
    }

    return $path . ""?v=$str"";
}

function getVersionedScript($path, $additional_attrs = '')
{
    return '<script type=""text/javascript"" src=""' . getVersionedPath($path, $additional_attrs) . '""></script>';
}

function getJSPath($relative_path, $additional_attrs = '')
{
    if (defined('TEMPLATE_URL')) {
        $relative_path = SugarTemplateUtilities::getWebPath($relative_path);
    }

    return getVersionedPath($relative_path) . (!empty($additional_attrs) ? ""&$additional_attrs"" : '');
}

/**
 * @deprecated This function is unused and will be removed in a future release.
 */
function getSWFPath($relative_path, $additional_params = '')
{
    $path = $relative_path;
    if (!empty($additional_params)) {
        $path .= '?' . $additional_params;
    }
    if (defined('TEMPLATE_URL')) {
        $path = TEMPLATE_URL . '/' . $path;
    }

    return $path;
}

/**
 * @deprecated This function is unused and will be removed in a future release.
 */
function getSQLDate($date_str)
{
    if (preg_match('/^(\d{1,2})-(\d{1,2})-(\d{4})$/', $date_str, $match)) {
        if (strlen($match[2]) == 1) {
            $match[2] = '0' . $match[2];
        }
        if (strlen($match[1]) == 1) {
            $match[1] = '0' . $match[1];
        }

        return ""{$match[3]}-{$match[1]}-{$match[2]}"";
    } elseif (preg_match('/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/', $date_str, $match)) {
        if (strlen($match[2]) == 1) {
            $match[2] = '0' . $match[2];
        }
        if (strlen($match[1]) == 1) {
            $match[1] = '0' . $match[1];
        }

        return ""{$match[3]}-{$match[1]}-{$match[2]}"";
    }
    return '';
}

/**
 * @deprecated This function is unused and will be removed in a future release.
 */
function clone_history(&$db, $from_id, $to_id, $to_type)
{
    global $timedate;
    $old_note_id = null;
    $old_filename = null;
    require_once 'include/upload_file.php';
    $tables = array('calls' => 'Call', 'meetings' => 'Meeting', 'notes' => 'Note', 'tasks' => 'Task');

    $location = array('Email' => 'modules/Emails/Email.php',
        'Call' => 'modules/Calls/Call.php',
        'Meeting' => 'modules/Meetings/Meeting.php',
        'Note' => 'modules/Notes/Note.php',
        'Tasks' => 'modules/Tasks/Task.php',
    );

    foreach ($tables as $table => $bean_class) {
        if (!class_exists($bean_class)) {
            require_once $location[$bean_class];
        }

        $bProcessingNotes = false;
        if ($table == 'notes') {
            $bProcessingNotes = true;
        }
        $query = ""SELECT id FROM $table WHERE parent_id='$from_id'"";
        $results = $db->query($query);
        while ($row = $db->fetchByAssoc($results)) {
            //retrieve existing record.
            $bean = new $bean_class();
            $bean->retrieve($row['id']);
            //process for new instance.
            if ($bProcessingNotes) {
                $old_note_id = $row['id'];
                $old_filename = $bean->filename;
            }
            $bean->id = null;
            $bean->parent_id = $to_id;
            $bean->parent_type = $to_type;
            if ($to_type == 'Contacts' and in_array('contact_id', $bean->column_fields)) {
                $bean->contact_id = $to_id;
            }
            $bean->update_date_modified = false;
            $bean->update_modified_by = false;
            if (isset($bean->date_modified)) {
                $bean->date_modified = $timedate->to_db($bean->date_modified);
            }
            if (isset($bean->date_entered)) {
                $bean->date_entered = $timedate->to_db($bean->date_entered);
            }
            //save
            $new_id = $bean->save();

            //duplicate the file now. for notes.
            if ($bProcessingNotes && !empty($old_filename)) {
                UploadFile::duplicate_file($old_note_id, $new_id, $old_filename);
            }
            //reset the values needed for attachment duplication.
            $old_note_id = null;
            $old_filename = null;
        }
    }
}

/**
 * @deprecated This function is unused and will be removed in a future release.
 */
function values_to_keys($array)
{
    $new_array = array();
    if (!is_array($array)) {
        return $new_array;
    }
    foreach ($array as $arr) {
        $new_array[$arr] = $arr;
    }

    return $new_array;
}

/**
 * @param $db
 * @param array $tables
 * @param $from_column
 * @param $from_id
 * @param $to_id
 */
function clone_relationship(&$db, $tables, $from_column = null, $from_id = null, $to_id = null)
{
    foreach ((array) $tables as $table) {
        if ($table == 'emails_beans') {
            $query = ""SELECT * FROM $table WHERE $from_column='$from_id' and bean_module='Leads'"";
        } else {
            $query = ""SELECT * FROM $table WHERE $from_column='$from_id'"";
        }
        $results = $db->query($query);
        while ($row = $db->fetchByAssoc($results)) {
            $query = ""INSERT INTO $table "";
            $names = '';
            $values = '';
            $row[$from_column] = $to_id;
            $row['id'] = create_guid();
            if ($table == 'emails_beans') {
                $row['bean_module'] == 'Contacts';
            }

            foreach ($row as $name => $value) {
                if (empty($names)) {
                    $names .= $name;
                    $values .= ""'$value'"";
                } else {
                    $names .= ', ' . $name;
                    $values .= "", '$value'"";
                }
            }
            $query .= ""($names)	VALUES ($values)"";
            $db->query($query);
        }
    }
}

function get_unlinked_email_query($type, $bean)
{
    global $current_user;

    $return_array['select'] = 'SELECT emails.id ';
    $return_array['from'] = 'FROM emails ';
    $return_array['where'] = '';
    $return_array['join'] = "" JOIN (select DISTINCT email_id from emails_email_addr_rel eear

	join email_addr_bean_rel eabr on eabr.bean_id ='$bean->id' and eabr.bean_module = '$bean->module_dir' and
	eabr.email_address_id = eear.email_address_id and eabr.deleted=0
	where eear.deleted=0 and eear.email_id not in
	(select eb.email_id from emails_beans eb where eb.bean_module ='$bean->module_dir' and eb.bean_id = '$bean->id')
	) derivedemails on derivedemails.email_id = emails.id"";
    $return_array['join_tables'][0] = '';

    if (isset($type) and ! empty($type['return_as_array'])) {
        return $return_array;
    }

    return $return_array['select'] . $return_array['from'] . $return_array['where'] . $return_array['join'];
}

// fn

function get_emails_by_assign_or_link($params)
{
    $relation = $params['link'];
    $bean = $GLOBALS['app']->controller->bean;
    if (empty($bean->$relation)) {
        $bean->load_relationship($relation);
    }
    if (empty($bean->$relation)) {
        $GLOBALS['log']->error(""Bad relation '$relation' for bean '{$bean->object_name}' id '{$bean->id}'"");

        return array();
    }
    $rel_module = $bean->$relation->getRelatedModuleName();
    $rel_join = $bean->$relation->getJoin(array(
        'join_table_alias' => 'link_bean',
        'join_table_link_alias' => 'linkt',
    ));
    $rel_join = str_replace(""{$bean->table_name}.id"", ""'{$bean->id}'"", $rel_join);
    $return_array['select'] = 'SELECT DISTINCT emails.id ';
    $return_array['from'] = 'FROM emails ';

    $return_array['join'] = array();

    // directly assigned emails
    $return_array['join'][] = ""
        SELECT
            eb.email_id,
            'direct' source
        FROM
            emails_beans eb
        WHERE
            eb.bean_module = '{$bean->module_dir}'
            AND eb.bean_id = '{$bean->id}'
            AND eb.deleted=0
    "";

    // Related by directly by email
    $return_array['join'][] = ""
        SELECT DISTINCT
            eear.email_id,
            'relate' source
        FROM
            emails_email_addr_rel eear
        INNER JOIN
            email_addr_bean_rel eabr
        ON
            eabr.bean_id ='{$bean->id}'
            AND eabr.bean_module = '{$bean->module_dir}'
            AND eabr.email_address_id = eear.email_address_id
            AND eabr.deleted=0
        WHERE
            eear.deleted=0
    "";

    $showEmailsOfRelatedContacts = empty($bean->field_defs[$relation]['hide_history_contacts_emails']);
    if (!empty($GLOBALS['sugar_config']['hide_history_contacts_emails']) && isset($GLOBALS['sugar_config']['hide_history_contacts_emails'][$bean->module_name])) {
        $showEmailsOfRelatedContacts = empty($GLOBALS['sugar_config']['hide_history_contacts_emails'][$bean->module_name]);
    }
    if ($showEmailsOfRelatedContacts) {
        // Assigned to contacts
        $return_array['join'][] = ""
            SELECT DISTINCT
                eb.email_id,
                'contact' source
            FROM
                emails_beans eb
            $rel_join AND link_bean.id = eb.bean_id
            WHERE
                eb.bean_module = '$rel_module'
                AND eb.deleted=0
        "";
        // Related by email to linked contact
        $return_array['join'][] = ""
            SELECT DISTINCT
                eear.email_id,
                'relate_contact' source
            FROM
                emails_email_addr_rel eear
            INNER JOIN
                email_addr_bean_rel eabr
            ON
                eabr.email_address_id=eear.email_address_id
                AND eabr.bean_module = '$rel_module'
                AND eabr.deleted=0
            $rel_join AND link_bean.id = eabr.bean_id
            WHERE
                eear.deleted=0
        "";
    }

    $return_array['join'] = ' INNER JOIN (' . implode(' UNION ', $return_array['join']) . ') email_ids ON emails.id=email_ids.email_id ';

    $return_array['where'] = ' WHERE emails.deleted=0 ';

    //$return_array['join'] = '';
    $return_array['join_tables'][0] = '';

    if ($bean->object_name == 'Case' && !empty($bean->case_number)) {
        $where = str_replace('%1', $bean->case_number, $bean->getEmailSubjectMacro());
        $return_array['where'] .= ""\n AND (email_ids.source = 'direct' OR emails.name LIKE '%$where%')"";
    }

    return $return_array;
}

/**
 * Check to see if the number is empty or non-zero.
 *
 * @param $value
 *
 * @return bool
 * */
function number_empty($value)
{
    return empty($value) && $value != '0';
}

/**
 * @param bool $add_blank
 * @param $bean_name
 * @param $display_columns
 * @param string $where
 * @param string $order_by
 * @param bool $blank_is_none
 * @return array
 */
function get_bean_select_array(
    $add_blank,
    $bean_name = null,
    $display_columns = null,
    $where = '',
    $order_by = '',
    $blank_is_none = false
) {
    global $beanFiles;

    // set $add_blank = true by default
    if (!is_bool($add_blank)) {
        $add_blank = true;
    }

    require_once $beanFiles[$bean_name];
    $focus = new $bean_name();
    $user_array = array();

    $key = ($bean_name == 'EmailTemplate') ? $bean_name : $bean_name . $display_columns . $where . $order_by;
    $user_array = get_register_value('select_array', $key);
    if (!$user_array) {
        $db = DBManagerFactory::getInstance();

        $temp_result = array();
        $query = ""SELECT {$focus->table_name}.id, {$display_columns} as display from {$focus->table_name} "";
        $query .= 'where ';
        if ($where != '') {
            $query .= $where . ' AND ';
        }

        $query .= "" {$focus->table_name}.deleted=0"";

        $accessWhere = $focus->buildAccessWhere('list');
        if (!empty($accessWhere)) {
            $query .= ' AND ' . $accessWhere;
        }

        if ($order_by != '') {
            $query .= "" order by {$focus->table_name}.{$order_by}"";
        }

        $GLOBALS['log']->debug(""get_user_array query: $query"");
        $result = $db->query($query, true, 'Error filling in user array: ');

        if ($add_blank == true) {
            // Add in a blank row
            if ($blank_is_none == true) { // set 'blank row' to ""--None--""
                global $app_strings;
                $temp_result[''] = $app_strings['LBL_NONE'];
            } else {
                $temp_result[''] = '';
            }
        }

        // Get the id and the name.
        while ($row = $db->fetchByAssoc($result)) {
            $temp_result[$row['id']] = $row['display'];
        }

        $user_array = $temp_result;
        set_register_value('select_array', $key, $temp_result);
    }

    return $user_array;
}

/**
 * @param unknown_type $listArray
 */
// function parse_list_modules
// searches a list for items in a user's allowed tabs and returns an array that removes unallowed tabs from list
function parse_list_modules(&$listArray)
{
    global $modListHeader;
    $returnArray = array();

    foreach ($listArray as $optionName => $optionVal) {
        if (array_key_exists($optionName, $modListHeader)) {
            $returnArray[$optionName] = $optionVal;
        }

        // special case for projects
        if (array_key_exists('Project', $modListHeader)) {
            $returnArray['ProjectTask'] = $listArray['ProjectTask'];
        }
    }
    $acldenied = ACLController::disabledModuleList($listArray, false);
    foreach ($acldenied as $denied) {
        unset($returnArray[$denied]);
    }
    asort($returnArray);

    return $returnArray;
}

function display_notice($msg = false)
{
    global $error_notice;
    //no error notice - lets just display the error to the user
    if (!isset($error_notice)) {
        echo '<br>' . $msg . '<br>';
    } else {
        $error_notice .= $msg . '<br>';
    }
}

/**
 * Checks if it is a number that at least has the plus at the beginning.
 *
 * @deprecated No longer used, will be removed without replacement in SuiteCRM 7.12.
 */
function skype_formatted($number)
{
    //kbrill - BUG #15375
    if (isset($_REQUEST['action']) && $_REQUEST['action'] == 'Popup') {
        return false;
    }
    return substr($number, 0, 1) == '+' || substr($number, 0, 2) == '00' || substr($number, 0, 3) == '011';

    //	return substr($number, 0, 1) == '+' || substr($number, 0, 2) == '00' || substr($number, 0, 2) == '011';
}

/**
 * @deprecated No longer used, will be removed without replacement in SuiteCRM 7.12.
 */
function format_skype($number)
{
    return preg_replace('/[^\+0-9]/', '', $number);
}

function insert_charset_header()
{
    header('Content-Type: text/html; charset=UTF-8');
}

/**
 * @deprecated This function is unused and will be removed in a future release.
 */
function getCurrentURL()
{
    $href = 'http:';
    if (!empty($_SERVER['HTTPS']) && $_SERVER['HTTPS'] === 'on') {
        $href = 'https:';
    }

    $href .= '//' . $_SERVER['HTTP_HOST'] . $_SERVER['SCRIPT_NAME'] . '?' . $_SERVER['QUERY_STRING'];

    return $href;
}

function javascript_escape($str)
{
    $new_str = '';

    for ($i = 0; $i < strlen($str); ++$i) {
        if (ord(substr($str, $i, 1)) == 10) {
            $new_str .= '\n';
        } elseif (ord(substr($str, $i, 1)) == 13) {
            $new_str .= '\r';
        } else {
            $new_str .= $str[$i];
        }
    }

    $new_str = str_replace(""'"", ""\\'"", $new_str);

    return $new_str;
}

function js_escape($str, $keep = true)
{
    $str = html_entity_decode(str_replace('\\', '', $str), ENT_QUOTES);

    if ($keep) {
        $str = javascript_escape($str);
    } else {
        $str = str_replace(""'"", ' ', $str);
        $str = str_replace('""', ' ', $str);
    }

    return $str;

    //end function js_escape
}

function br2nl($str)
{
    $regex = '#<[^>]+br.+?>#i';
    preg_match_all($regex, $str, $matches);

    foreach ($matches[0] as $match) {
        $str = str_replace($match, '<br>', $str);
    }

    $brs = array('<br>', '<br/>', '<br />');
    $str = str_replace(""\r\n"", ""\n"", $str); // make from windows-returns, *nix-returns
    $str = str_replace(""\n\r"", ""\n"", $str); // make from windows-returns, *nix-returns
    $str = str_replace(""\r"", ""\n"", $str); // make from windows-returns, *nix-returns
    $str = str_ireplace($brs, ""\n"", $str); // to retrieve it

    return $str;
}

/**
 * Private helper function for displaying the contents of a given variable.
 * This function is only intended to be used for SugarCRM internal development.
 * The ppd stands for Pre Print Die.
 * @deprecated This function is unused and will be removed in a future release.
 */
function _ppd($mixed)
{
}

/**
 * Private helper function for displaying the contents of a given variable in
 * the Logger. This function is only intended to be used for SugarCRM internal
 * development. The pp stands for Pre Print.
 *
 * @param $mixed var to print_r()
 * @param $die boolean end script flow
 * @param $displayStackTrace also show stack trace
 * @deprecated This function is unused and will be removed in a future release.
 */
function _ppl($mixed, $die = false, $displayStackTrace = false, $loglevel = 'fatal')
{
    if (!isset($GLOBALS['log']) || empty($GLOBALS['log'])) {
        $GLOBALS['log'] = LoggerManager:: getLogger();
    }

    $mix = print_r($mixed, true); // send print_r() output to $mix
    $stack = debug_backtrace();

    $GLOBALS['log']->$loglevel('------------------------------ _ppLogger() output start -----------------------------');
    $GLOBALS['log']->$loglevel($mix);
    if ($displayStackTrace) {
        foreach ($stack as $position) {
            $GLOBALS['log']->$loglevel($position['file'] . ""({$position['line']})"");
        }
    }

    $GLOBALS['log']->$loglevel('------------------------------ _ppLogger() output end -----------------------------');
    $GLOBALS['log']->$loglevel('------------------------------ _ppLogger() file: ' . $stack[0]['file'] . ' line#: ' . $stack[0]['line'] . '-----------------------------');

    if ($die) {
        die();
    }
}

/**
 * private helper function to quickly show the major, direct, field attributes of a given bean.
 * The ppf stands for Pre[formatted] Print Focus [object].
 *
 * @param object bean The focus bean
 * @deprecated This function is unused and will be removed in a future release.
 */
function _ppf($bean, $die = false)
{
}

/**
 * Private helper function for displaying the contents of a given variable.
 * This function is only intended to be used for SugarCRM internal development.
 * The pp stands for Pre Print.
 * @deprecated This function is unused and will be removed in a future release.
 */
function _pp($mixed)
{
}

/**
 * Private helper function for displaying the contents of a given variable.
 * This function is only intended to be used for SugarCRM internal development.
 * The pp stands for Pre Print.
 * @deprecated This function is unused and will be removed in a future release.
 */
function _pstack_trace($mixed = null)
{
}

/**
 * Private helper function for displaying the contents of a given variable.
 * This function is only intended to be used for SugarCRM internal development.
 * The pp stands for Pre Print Trace.
 * @deprecated This function is unused and will be removed in a future release.
 */
function _ppt($mixed, $textOnly = false)
{
}

/**
 * Private helper function for displaying the contents of a given variable.
 * This function is only intended to be used for SugarCRM internal development.
 * The pp stands for Pre Print Trace Die.
 * @deprecated This function is unused and will be removed in a future release.
 */
function _pptd($mixed)
{
}

/**
 * Private helper function for decoding javascript UTF8
 * This function is only intended to be used for SugarCRM internal development.
 * @deprecated This function is unused and will be removed in a future release.
 */
function decodeJavascriptUTF8($str)
{
}

/**
 * Will check if a given PHP version string is accepted or not.
 * Do not pass in any pararameter to default to a check against the
 * current environment's PHP version.
 *
 * @param string $sys_php_version Version to check against, defaults to the current environment's.
 * @param string $min_php_version Minimum version to check against. Defaults to the SUITECRM_PHP_MIN_VERSION constant.
 * @param string $rec_php_version Recommended version. Defaults to the SUITECRM_PHP_REC_VERSION constant
 *
 * @return integer 1 if version is greater than the recommended PHP version,
 *   0 if version is between minimun and recomended PHP versions,
 *   -1 otherwise (less than minimum or buggy version)
 */
function check_php_version($sys_php_version = '', $min_php_version = '', $rec_php_version = '')
{
    if ($sys_php_version === '') {
        $sys_php_version = constant('PHP_VERSION');
    }
    if ($min_php_version === '') {
        $min_php_version = constant('SUITECRM_PHP_MIN_VERSION');
    }
    if ($rec_php_version === '') {
        $rec_php_version = constant('SUITECRM_PHP_REC_VERSION');
    }

    // versions below MIN_PHP_VERSION are not accepted, so return early.
    if (version_compare($sys_php_version, $min_php_version, '<') === true) {
        return -1;
    }

    // If the checked version is between the minimum and recommended versions, return 0.
    if (version_compare($sys_php_version, $rec_php_version, '<') === true) {
        return 0;
    }

    // Everything else is fair game
    return 1;
}

/**
 * Will check if a given IIS version string is supported (tested on this ver),
 * unsupported (results unknown), or invalid (something will break on this
 * ver).
 *
 * @return 1 implies supported, 0 implies unsupported, -1 implies invalid
 */
function check_iis_version($sys_iis_version = '')
{
    $server_software = $_SERVER['SERVER_SOFTWARE'];
    $iis_version = '';
    if (strpos($server_software, 'Microsoft-IIS') !== false && preg_match_all(""/^.*\/(\d+\.?\d*)$/"", $server_software, $out)) {
        $iis_version = $out[1][0];
    }

    $sys_iis_version = empty($sys_iis_version) ? $iis_version : $sys_iis_version;

    // versions below $min_considered_iis_version considered invalid by default,
    // versions equal to or above this ver will be considered depending
    // on the rules that follow
    $min_considered_iis_version = '6.0';

    // only the supported versions,
    // should be mutually exclusive with $invalid_iis_versions
    $supported_iis_versions = array('6.0', '7.0');
    $unsupported_iis_versions = array();
    $invalid_iis_versions = array('5.0');

    // default unsupported
    $retval = 0;

    // versions below $min_considered_iis_version are invalid
    if (1 == version_compare($sys_iis_version, $min_considered_iis_version, '<')) {
        $retval = -1;
    }

    // supported version check overrides default unsupported
    foreach ($supported_iis_versions as $ver) {
        if (1 == version_compare($sys_iis_version, $ver, 'eq') || strpos($sys_iis_version, $ver) !== false) {
            $retval = 1;
            break;
        }
    }

    // unsupported version check overrides default unsupported
    foreach ($unsupported_iis_versions as $ver) {
        if (1 == version_compare($sys_iis_version, $ver, 'eq') && strpos($sys_iis_version, $ver) !== false) {
            $retval = 0;
            break;
        }
    }

    // invalid version check overrides default unsupported
    foreach ($invalid_iis_versions as $ver) {
        if (1 == version_compare($sys_iis_version, $ver, 'eq') && strpos($sys_iis_version, $ver) !== false) {
            $retval = -1;
            break;
        }
    }

    return $retval;
}

function pre_login_check()
{
    global $action, $login_error;
    if (!empty($action) && $action == 'Login') {
        if (!empty($login_error)) {
            $login_error = htmlentities($login_error);
            $login_error = str_replace(array('&lt;pre&gt;', '&lt;/pre&gt;', ""\r\n"", ""\n""), '<br>', $login_error);
            $_SESSION['login_error'] = $login_error;
            echo '<script>
						function set_focus() {}
						if(document.getElementById(""post_error"")) {
							document.getElementById(""post_error"").innerHTML=""' . $login_error . '"";
							document.getElementById(""cant_login"").value=1;
							document.getElementById(""login_button"").disabled = true;
							document.getElementById(""user_name"").disabled = true;
						}
						</script>';
        }
    }
}

/**
 * Like exit() but will throw an exception if called during tests.
 *
 * This is to avoid exit() stopping the test suite without us noticing.
 *
 * @param int|string $status
 * @throws Exception
 */
function suite_exit($status = 0)
{
    if (defined('SUITE_PHPUNIT_RUNNER'))
        throw new Exception(""exit() called during tests with status: $status"");
    else
        exit($status);
}

function sugar_cleanup($exit = false)
{
    static $called = false;
    if ($called) {
        return;
    }
    $called = true;
    set_include_path(realpath(dirname(__FILE__) . '/..') . PATH_SEPARATOR . get_include_path());
    chdir(realpath(dirname(__FILE__) . '/..'));
    global $sugar_config;
    require_once 'include/utils/LogicHook.php';
    LogicHook::initialize();
    $GLOBALS['logic_hook']->call_custom_logic('', 'server_round_trip');

    //added this check to avoid errors during install.
    if (empty($sugar_config['dbconfig'])) {
        if ($exit) {
            suite_exit();
        }
        return;
    }

    if (!class_exists('Tracker', true)) {
        require_once 'modules/Trackers/Tracker.php';
    }
    Tracker::logPage();
    // Now write the cached tracker_queries
    if (!empty($GLOBALS['savePreferencesToDB']) && $GLOBALS['savePreferencesToDB']) {
        if (isset($GLOBALS['current_user']) && $GLOBALS['current_user'] instanceof User) {
            $GLOBALS['current_user']->savePreferencesToDB();
        }
    }

    //check to see if this is not an `ajax call AND the user preference error flag is set
    if (
            (isset($_SESSION['USER_PREFRENCE_ERRORS']) && $_SESSION['USER_PREFRENCE_ERRORS']) && ($_REQUEST['action'] != 'modulelistmenu' && $_REQUEST['action'] != 'DynamicAction') && ($_REQUEST['action'] != 'favorites' && $_REQUEST['action'] != 'DynamicAction') && (empty($_REQUEST['to_pdf']) || !$_REQUEST['to_pdf']) && (empty($_REQUEST['sugar_body_only']) || !$_REQUEST['sugar_body_only'])
    ) {
        global $app_strings;
        //this is not an ajax call and the user preference error flag is set, so reset the flag and print js to flash message
        $err_mess = $app_strings['ERROR_USER_PREFS'];
        $_SESSION['USER_PREFRENCE_ERRORS'] = false;
        echo ""
		<script>
			ajaxStatus.flashStatus('$err_mess',7000);
		</script>"";
    }

    pre_login_check();
    if (class_exists('DBManagerFactory')) {
        $db = DBManagerFactory::getInstance();
        $db->disconnect();
        if ($exit) {
            suite_exit();
        }
    }
}

register_shutdown_function('sugar_cleanup');

/*
  check_logic_hook - checks to see if your custom logic is in the logic file
  if not, it will add it. If the file isn't built yet, it will create the file

 */

function check_logic_hook_file($module_name, $event, $action_array)
{
    require_once 'include/utils/logic_utils.php';
    $add_logic = false;

    if (file_exists(""custom/modules/$module_name/logic_hooks.php"")) {
        $hook_array = get_hook_array($module_name);

        if (check_existing_element($hook_array, $event, $action_array) == true) {
            //the hook at hand is present, so do nothing
        } else {
            $add_logic = true;

            $logic_count = 0;
            if (!empty($hook_array[$event])) {
                $logic_count = count($hook_array[$event]);
            }

            if ($action_array[0] == '') {
                $action_array[0] = $logic_count + 1;
            }
            $hook_array[$event][] = $action_array;
        }
        //end if the file exists already
    } else {
        $add_logic = true;
        if ($action_array[0] == '') {
            $action_array[0] = 1;
        }
        $hook_array = array();
        $hook_array[$event][] = $action_array;
        //end if else file exists already
    }
    if ($add_logic == true) {

        //reorder array by element[0]
        //$hook_array = reorder_array($hook_array, $event);
        //!!!Finish this above TODO

        $new_contents = replace_or_add_logic_type($hook_array);
        write_logic_file($module_name, $new_contents);

        //end if add_element is true
    }

    //end function check_logic_hook_file
}

function remove_logic_hook($module_name, $event, $action_array)
{
    require_once 'include/utils/logic_utils.php';
    $add_logic = false;

    if (file_exists('custom/modules/' . $module_name . '/logic_hooks.php')) {
        // The file exists, let's make sure the hook is there
        $hook_array = get_hook_array($module_name);

        if (check_existing_element($hook_array, $event, $action_array) == true) {
            // The hook is there, time to take it out.

            foreach ($hook_array[$event] as $i => $hook) {
                // We don't do a full comparison below just in case the filename changes
                if ($hook[0] == $action_array[0] && $hook[1] == $action_array[1] && $hook[3] == $action_array[3] && $hook[4] == $action_array[4]
                ) {
                    unset($hook_array[$event][$i]);
                }
            }

            $new_contents = replace_or_add_logic_type($hook_array);
            write_logic_file($module_name, $new_contents);
        }
    }
}

function display_stack_trace($textOnly = false)
{
    $stack = debug_backtrace();

    echo ""\n\n display_stack_trace caller, file: "" . $stack[0]['file'] . ' line#: ' . $stack[0]['line'];

    if (!$textOnly) {
        echo '<br>';
    }

    $first = true;
    $out = '';

    foreach ($stack as $item) {
        $file = '';
        $class = '';
        $line = '';
        $function = '';

        if (isset($item['file'])) {
            $file = $item['file'];
        }
        if (isset($item['class'])) {
            $class = $item['class'];
        }
        if (isset($item['line'])) {
            $line = $item['line'];
        }
        if (isset($item['function'])) {
            $function = $item['function'];
        }

        if (!$first) {
            if (!$textOnly) {
                $out .= '<font color=""black""><b>';
            }

            $out .= $file;

            if (!$textOnly) {
                $out .= '</b></font><font color=""blue"">';
            }

            $out .= ""[L:{$line}]"";

            if (!$textOnly) {
                $out .= '</font><font color=""red"">';
            }

            $out .= ""({$class}:{$function})"";

            if (!$textOnly) {
                $out .= '</font><br>';
            } else {
                $out .= ""\n"";
            }
        } else {
            $first = false;
        }
    }

    echo $out;
    return $out;
}

function StackTraceErrorHandler($errno, $errstr, $errfile, $errline, $errcontext)
{
    $error_msg = "" $errstr occurred in <b>$errfile</b> on line $errline ["" . date('Y-m-d H:i:s') . ']';

    switch ($errno) {
//        case 2048:
//            return; //depricated we have lots of these ignore them
        case E_USER_NOTICE:
            $type = 'User notice';
            // no break
        case E_NOTICE:
            $type = 'Notice';
            $halt_script = false;
            break;


        case E_USER_WARNING:
            $type = 'User warning';
            // no break
        case E_COMPILE_WARNING:
            $type = 'Compile warning';
            // no break
        case E_CORE_WARNING:
            $type = 'Core warning';
            // no break
        case E_WARNING:
            $type = 'Warning';
            $halt_script = false;
            break;

        case E_USER_ERROR:
            $type = 'User error';
            // no break
        case E_COMPILE_ERROR:
            $type = 'Compile error';
            // no break
        case E_CORE_ERROR:
            $type = 'Core error';
            // no break
        case E_ERROR:
            $type = 'Error';
            $halt_script = true;
            break;

        case E_PARSE:
            $type = 'Parse Error';
            $halt_script = true;
            break;

        default:
            //don't know what it is might not be so bad
            $type = ""Unknown Error ($errno)"";
            $halt_script = false;
            break;
    }
    $error_msg = '<b>[' . $type . ']</b> ' . $error_msg;
    echo $error_msg;
    $trace = display_stack_trace();
    ErrorMessage::log(""Catch an error: $error_msg \nTrace info:\n"" . $trace);
    if ($halt_script) {
        exit(1);
    }
}

if (isset($sugar_config['stack_trace_errors']) && $sugar_config['stack_trace_errors']) {
    set_error_handler('StackTraceErrorHandler');
}

function get_sub_cookies($name)
{
    $cookies = array();
    if (isset($_COOKIE[$name])) {
        $subs = explode('#', $_COOKIE[$name]);
        foreach ($subs as $cookie) {
            if (!empty($cookie)) {
                $cookie = explode('=', $cookie);

                $cookies[$cookie[0]] = $cookie[1];
            }
        }
    }

    return $cookies;
}

/**
 * @deprecated This function is unused and will be removed in a future release.
 */
function mark_delete_components($sub_object_array, $run_second_level = false, $sub_sub_array = '')
{
    if (!empty($sub_object_array)) {
        foreach ($sub_object_array as $sub_object) {

            //run_second level is set to true if you need to remove sub-sub components
            if ($run_second_level == true) {
                mark_delete_components($sub_object->get_linked_beans($sub_sub_array['rel_field'], $sub_sub_array['rel_module']));

                //end if run_second_level is true
            }
            $sub_object->mark_deleted($sub_object->id);
            //end foreach sub component
        }
        //end if this is not empty
    }

    //end function mark_delete_components
}

/**
 * Translates php.ini memory values into bytes.
 * For example, an input value of '8M' will return 8388608.
 * 8M is 8 mebibytes, 1 mebibyte is 1,048,576 bytes or 2^20 bytes.
 *
 * @param string $val A string like '8M'.
 * @return integer The number of bytes represented by that string.
 */
function return_bytes($val)
{
    $val = trim($val);
    $last = strtolower($val[strlen($val) - 1]);
    $val = preg_replace(""/[^0-9,.]/"", """", $val);

    switch ($last) {
        case 'g':
            $val *= 1024;
            // no break
        case 'm':
            $val *= 1024;
            // no break
        case 'k':
            $val *= 1024;
    }

    return $val;
}

/**
 * Adds the href HTML tags around any URL in the $string.
 */
function url2html($string)
{
    $return_string = preg_replace('/(\w+:\/\/)(\S+)/', ' <a href=""\\1\\2"" target=""_new""  style=""font-weight: normal;"">\\1\\2</a>', $string);

    return $return_string;
}

/**
 * tries to determine whether the Host machine is a Windows machine.
 */
function is_windows()
{
    static $is_windows = null;
    if (!isset($is_windows)) {
        $is_windows = strtoupper(substr(PHP_OS, 0, 3)) == 'WIN';
    }

    return $is_windows;
}

/**
 * equivalent for windows filesystem for PHP's is_writable().
 *
 * @param string file Full path to the file/dir
 *
 * @return bool true if writable
 */
function is_writable_windows($file)
{
    if ($file[strlen($file) - 1] == '/') {
        return is_writable_windows($file . uniqid(mt_rand()) . '.tmp');
    }

    // the assumption here is that Windows has an inherited permissions scheme
    // any file that is a descendant of an unwritable directory will inherit
    // that property and will trigger a failure below.
    if (is_dir($file)) {
        return true;
    }

    $file = str_replace('/', '\\', $file);

    if (file_exists($file)) {
        if (!($f = @sugar_fopen($file, 'r+'))) {
            return false;
        }
        fclose($f);

        return true;
    }

    if (!($f = @sugar_fopen($file, 'w'))) {
        return false;
    }
    fclose($f);
    unlink($file);

    return true;
}

/**
 * best guesses Timezone based on webserver's TZ settings.
 */
function lookupTimezone($userOffset = 0)
{
    return TimeDate::guessTimezone($userOffset);
}

function convert_module_to_singular($module_array)
{
    global $beanList;

    foreach ($module_array as $key => $value) {
        if (!empty($beanList[$value])) {
            $module_array[$key] = $beanList[$value];
        }

        if ($value == 'Cases') {
            $module_array[$key] = 'Case';
        }
        if ($key == 'projecttask') {
            $module_array['ProjectTask'] = 'Project Task';
            unset($module_array[$key]);
        }
    }

    return $module_array;

    //end function convert_module_to_singular
}

/*
 * Given the bean_name which may be plural or singular return the singular
 * bean_name. This is important when you need to include files.
 */

function get_singular_bean_name($bean_name)
{
    global $beanFiles, $beanList;
    if (array_key_exists($bean_name, $beanList)) {
        return $beanList[$bean_name];
    }
    return $bean_name;
}

/*
 * Given the potential module name (singular name, renamed module name)
 * Return the real internal module name.
 */

function get_module_from_singular($singular)
{

    // find the internal module name for a singular name
    if (isset($GLOBALS['app_list_strings']['moduleListSingular'])) {
        $singular_modules = $GLOBALS['app_list_strings']['moduleListSingular'];

        foreach ($singular_modules as $mod_name => $sin_name) {
            if ($singular == $sin_name and $mod_name != $sin_name) {
                return $mod_name;
            }
        }
    }

    // find the internal module name for a renamed module
    if (isset($GLOBALS['app_list_strings']['moduleList'])) {
        $moduleList = $GLOBALS['app_list_strings']['moduleList'];

        foreach ($moduleList as $mod_name => $name) {
            if ($singular == $name and $mod_name != $name) {
                return $mod_name;
            }
        }
    }

    // if it's not a singular name, nor a renamed name, return the original value
    return $singular;
}

function get_label($label_tag, $temp_module_strings)
{
    global $app_strings;
    if (!empty($temp_module_strings[$label_tag])) {
        $label_name = $temp_module_strings[$label_tag];
    } else {
        if (!empty($app_strings[$label_tag])) {
            $label_name = $app_strings[$label_tag];
        } else {
            $label_name = $label_tag;
        }
    }

    return $label_name;

    //end function get_label
}

function search_filter_rel_info(&$focus, $tar_rel_module, $relationship_name)
{
    $rel_list = array();

    foreach ($focus->relationship_fields as $rel_key => $rel_value) {
        if ($rel_value == $relationship_name) {
            $temp_bean = BeanFactory::getBean($tar_rel_module, $focus->$rel_key);
            if ($temp_bean) {
                $rel_list[] = $temp_bean;

                return $rel_list;
            }
        }
    }

    foreach ($focus->field_defs as $field_name => $field_def) {
        //Check if the relationship_name matches a ""relate"" field
        if (!empty($field_def['type']) && $field_def['type'] == 'relate' && !empty($field_def['id_name']) && !empty($focus->field_defs[$field_def['id_name']]) && !empty($focus->field_defs[$field_def['id_name']]['relationship']) && $focus->field_defs[$field_def['id_name']]['relationship'] == $relationship_name
        ) {
            $temp_bean = BeanFactory::getBean($tar_rel_module, $field_def['id_name']);
            if ($temp_bean) {
                $rel_list[] = $temp_bean;

                return $rel_list;
            }
            //Check if the relationship_name matches a ""link"" in a relate field
        } elseif (!empty($rel_value['link']) && !empty($rel_value['id_name']) && $rel_value['link'] == $relationship_name) {
            $temp_bean = BeanFactory::getBean($tar_rel_module, $rel_value['id_name']);
            if ($temp_bean) {
                $rel_list[] = $temp_bean;

                return $rel_list;
            }
        }
    }

    // special case for unlisted parent-type relationships
    if (!empty($focus->parent_type) && $focus->parent_type == $tar_rel_module && !empty($focus->parent_id)) {
        $temp_bean = BeanFactory::getBean($tar_rel_module, $focus->parent_id);
        if ($temp_bean) {
            $rel_list[] = $temp_bean;

            return $rel_list;
        }
    }

    return $rel_list;

    //end function search_filter_rel_info
}

/**
 * @param $module_name
 * @return mixed
 */
function get_module_info($module_name)
{
    return BeanFactory::getBean($module_name);
}

/**
 * In order to have one place to obtain the proper object name. aCase for example causes issues throughout the application.
 *
 * @param string $moduleName
 */
function get_valid_bean_name($module_name)
{
    global $beanList;

    $vardef_name = $beanList[$module_name];
    if ($vardef_name == 'aCase') {
        $bean_name = 'Case';
    } else {
        $bean_name = $vardef_name;
    }

    return $bean_name;
}

function checkAuthUserStatus()
{

    //authUserStatus();
}

/**
 * This function returns an array of phpinfo() results that can be parsed and
 * used to figure out what version we run, what modules are compiled in, etc.
 *
 * @param   $level int        info level constant (1,2,4,8...64);
 *
 * @return $returnInfo array    array of info about the PHP environment
 *
 * @author    original by ""code at adspeed dot com"" Fron php.net
 * @author    customized for Sugar by Chris N.
 */
function getPhpInfo($level = -1)
{
    /* 	Name (constant)		Value	Description
      INFO_GENERAL		1		The configuration line, php.ini location, build date, Web Server, System and more.
      INFO_CREDITS		2		PHP Credits. See also phpcredits().
      INFO_CONFIGURATION	4		Current Local and Master values for PHP directives. See also ini_get().
      INFO_MODULES		8		Loaded modules and their respective settings. See also get_loaded_extensions().
      INFO_ENVIRONMENT	16		Environment Variable information that's also available in $_ENV.
      INFO_VARIABLES		32		Shows all predefined variables from EGPCS (Environment, GET, POST, Cookie, Server).
      INFO_LICENSE		64		PHP License information. See also the license FAQ.
      INFO_ALL			-1		Shows all of the above. This is the default value.
     */
    ob_start();
    phpinfo($level);
    $phpinfo = ob_get_contents();
    ob_end_clean();

    $phpinfo = strip_tags($phpinfo, '<h1><h2><th><td>');
    $phpinfo = preg_replace('/<th[^>]*>([^<]+)<\/th>/', '<info>\\1</info>', $phpinfo);
    $phpinfo = preg_replace('/<td[^>]*>([^<]+)<\/td>/', '<info>\\1</info>', $phpinfo);
    $parsedInfo = preg_split('/(<h.?>[^<]+<\/h.>)/', $phpinfo, -1, PREG_SPLIT_DELIM_CAPTURE);
    $match = '';
    $version = '';
    $returnInfo = array();

    if (preg_match('/<h1 class\=\""p\"">PHP Version ([^<]+)<\/h1>/', $phpinfo, $version)) {
        $returnInfo['PHP Version'] = $version[1];
    }

    for ($i = 1; $i < count($parsedInfo); ++$i) {
        if (preg_match('/<h.>([^<]+)<\/h.>/', $parsedInfo[$i], $match)) {
            $vName = trim($match[1]);
            $parsedInfo2 = explode(""\n"", $parsedInfo[$i + 1]);

            foreach ($parsedInfo2 as $vOne) {
                $vPat = '<info>([^<]+)<\/info>';
                $vPat3 = ""/$vPat\s*$vPat\s*$vPat/"";
                $vPat2 = ""/$vPat\s*$vPat/"";

                if (preg_match($vPat3, $vOne, $match)) { // 3cols
                    $returnInfo[$vName][trim($match[1])] = array(trim($match[2]), trim($match[3]));
                } elseif (preg_match($vPat2, $vOne, $match)) { // 2cols
                    $returnInfo[$vName][trim($match[1])] = trim($match[2]);
                }
            }
        } elseif (true) {
        }
    }

    return $returnInfo;
}

/**
 * This function will take a string that has tokens like {0}, {1} and will replace
 * those tokens with the args provided.
 *
 * @param   $format string to format
 * @param   $args   args to replace
 *
 * @return $result a formatted string
 */
function string_format($format, $args, $escape = true)
{
    $result = $format;

    /* Bug47277 fix.
     * If args array has only one argument, and it's empty, so empty single quotes are used '' . That's because
     * IN () fails and IN ('') works.
     */
    if (count($args) == 1) {
        reset($args);
        $singleArgument = current($args);
        if (empty($singleArgument)) {
            return str_replace('{0}', ""''"", $result);
        }
    }
    /* End of fix */

    if ($escape) {
        $db = DBManagerFactory::getInstance();
    }
    for ($i = 0; $i < count($args); ++$i) {
        if (strpos($args[$i], ',') !== false) {
            $values = explode(',', $args[$i]);
            if ($escape) {
                foreach ($values as &$value) {
                    $value = $db->quote($value);
                }
            }
            $args[$i] = implode(""','"", $values);
            $result = str_replace('{'.$i.'}', $args[$i], $result);
       }
        else if ($escape){
            $result = str_replace('{'.$i.'}', $db->quote($args[$i]), $result);
        }
        else{
            $result = str_replace('{'.$i.'}', $args[$i], $result);
        }
    }

    return $result;
}

/**
 * Generate a string for displaying a unique identifier that is composed
 * of a system_id and number.  This is use to allow us to generate quote
 * numbers using a DB auto-increment key from offline clients and still
 * have the number be unique (since it is modified by the system_id.
 *
 * @deprecated This function is unused and will be removed in a future release.
 *
 * @param   $num       of bean
 * @param   $system_id from system
 *
 * @return $result a formatted string
 */
function format_number_display($num, $system_id)
{
    global $sugar_config;
    if (isset($num) && !empty($num)) {
        $num = unformat_number($num);
        if (isset($system_id) && $system_id == 1) {
            return sprintf('%d', $num);
        }
        return sprintf('%d-%d', $num, $system_id);
    }
}

/**
 * @deprecated This function is unused and will be removed in a future release.
 */
function checkLoginUserStatus()
{
}

/**
 * This function will take a number and system_id and format.
 *
 * @param   $url  URL containing host to append port
 * @param   $port the port number - if '' is passed, no change to url
 *
 * @return $resulturl the new URL with the port appended to the host
 */
function appendPortToHost($url, $port)
{
    $resulturl = $url;

    // if no port, don't change the url
    if ($port != '') {
        $split = explode('/', $url);
        //check if it starts with http, in case they didn't include that in url
        if (str_begin($url, 'http')) {
            //third index ($split[2]) will be the host
            $split[2] .= ':' . $port;
        } else {
            // otherwise assumed to start with host name
            //first index ($split[0]) will be the host
            $split[0] .= ':' . $port;
        }

        $resulturl = implode('/', $split);
    }

    return $resulturl;
}

/**
 * Singleton to return JSON object.
 *
 * @return JSON object
 */
function getJSONobj()
{
    static $json = null;
    if (!isset($json)) {
        require_once 'include/JSON.php';
        $json = new JSON();
    }

    return $json;
}

require_once 'include/utils/db_utils.php';

/**
 * Set default php.ini settings for entry points.
 */
function setPhpIniSettings()
{
    // zlib module
    // Bug 37579 - Comment out force enabling zlib.output_compression, since it can cause problems on certain hosts
    /*
      if(function_exists('gzclose') && headers_sent() == false) {
      ini_set('zlib.output_compression', 1);
      }
     */
    // mbstring module
    //nsingh: breaks zip/unzip functionality. Commenting out 4/23/08

    /* if(function_exists('mb_strlen')) {
      ini_set('mbstring.func_overload', 7);
      ini_set('mbstring.internal_encoding', 'UTF-8');
      } */

    // http://us3.php.net/manual/en/ref.pcre.php#ini.pcre.backtrack-limit
    // starting with 5.2.0, backtrack_limit breaks JSON decoding
    $backtrack_limit = ini_get('pcre.backtrack_limit');
    if (!empty($backtrack_limit)) {
        ini_set('pcre.backtrack_limit', '-1');
    }
}

/**
 * Identical to sugarArrayMerge but with some speed improvements and used specifically to merge
 * language files.  Language file merges do not need to account for null values so we can get some
 * performance increases by using this specialized function. Note this merge function does not properly
 * handle null values.
 *
 * @param $gimp
 * @param $dom
 *
 * @return array
 */
function sugarLangArrayMerge($gimp, $dom)
{
    if (is_array($gimp) && is_array($dom)) {
        foreach ($dom as $domKey => $domVal) {
            if (isset($gimp[$domKey])) {
                if (is_array($domVal)) {
                    $tempArr = array();
                    foreach ($domVal as $domArrKey => $domArrVal) {
                        $tempArr[$domArrKey] = $domArrVal;
                    }
                    foreach ($gimp[$domKey] as $gimpArrKey => $gimpArrVal) {
                        if (!isset($tempArr[$gimpArrKey])) {
                            $tempArr[$gimpArrKey] = $gimpArrVal;
                        }
                    }
                    $gimp[$domKey] = $tempArr;
                } else {
                    $gimp[$domKey] = $domVal;
                }
            } else {
                $gimp[$domKey] = $domVal;
            }
        }
    } // if the passed value for gimp isn't an array, then return the $dom
    elseif (is_array($dom)) {
        return $dom;
    }

    return $gimp;
}

/**
 * like array_merge() but will handle array elements that are themselves arrays;
 * PHP's version just overwrites the element with the new one.
 *
 * @internal Note that this function deviates from the internal array_merge()
 *           functions in that it does does not treat numeric keys differently
 *           than string keys.  Additionally, it deviates from
 *           array_merge_recursive() by not creating an array when like values
 *           found.
 *
 * @param array gimp the array whose values will be overloaded
 * @param array dom the array whose values will pwn the gimp's
 *
 * @return array beaten gimp
 */
function sugarArrayMerge($gimp, $dom)
{
    if (is_array($gimp) && is_array($dom)) {
        foreach ($dom as $domKey => $domVal) {
            if (array_key_exists($domKey, $gimp)) {
                if (is_array($domVal)) {
                    $tempArr = array();
                    foreach ($domVal as $domArrKey => $domArrVal) {
                        $tempArr[$domArrKey] = $domArrVal;
                    }
                    foreach ($gimp[$domKey] as $gimpArrKey => $gimpArrVal) {
                        if (!array_key_exists($gimpArrKey, $tempArr)) {
                            $tempArr[$gimpArrKey] = $gimpArrVal;
                        }
                    }
                    $gimp[$domKey] = $tempArr;
                } else {
                    $gimp[$domKey] = $domVal;
                }
            } else {
                $gimp[$domKey] = $domVal;
            }
        }
    } // if the passed value for gimp isn't an array, then return the $dom
    elseif (is_array($dom)) {
        return $dom;
    }

    return $gimp;
}

/**
 * Similiar to sugarArrayMerge except arrays of N depth are merged.
 *
 * @param array gimp the array whose values will be overloaded
 * @param array dom the array whose values will pwn the gimp's
 *
 * @return array beaten gimp
 */
function sugarArrayMergeRecursive($gimp, $dom)
{
    if (is_array($gimp) && is_array($dom)) {
        foreach ($dom as $domKey => $domVal) {
            if (array_key_exists($domKey, $gimp)) {
                if (is_array($domVal) && is_array($gimp[$domKey])) {
                    $gimp[$domKey] = sugarArrayMergeRecursive($gimp[$domKey], $domVal);
                } else {
                    $gimp[$domKey] = $domVal;
                }
            } else {
                $gimp[$domKey] = $domVal;
            }
        }
    } // if the passed value for gimp isn't an array, then return the $dom
    elseif (is_array($dom)) {
        return $dom;
    }

    return $gimp;
}

/**
 * Finds the correctly working versions of PHP-JSON.
 * @deprecated This function is unused and will be removed in a future release.
 *
 * @return bool True if NOT found or WRONG version
 */
function returnPhpJsonStatus()
{
    if (function_exists('json_encode')) {
        $phpInfo = getPhpInfo(8);

        return version_compare($phpInfo['json']['json version'], '1.1.1', '<');
    }

    return true; // not found
}

/**
 * getTrackerSubstring.
 *
 * Returns a [number]-char or less string for the Tracker to display in the header
 * based on the tracker_max_display_length setting in config.php.  If not set,
 * or invalid length, then defaults to 15 for COM editions, 30 for others.
 *
 * @param string name field for a given Object
 *
 * @return string [number]-char formatted string if length of string exceeds the max allowed
 */
function getTrackerSubstring($name)
{
    static $max_tracker_item_length;

    //Trim the name
    $name = html_entity_decode($name, ENT_QUOTES, 'UTF-8');
    $strlen = function_exists('mb_strlen') ? mb_strlen($name) : strlen($name);

    global $sugar_config;

    if (!isset($max_tracker_item_length)) {
        if (isset($sugar_config['tracker_max_display_length'])) {
            $max_tracker_item_length = (is_int($sugar_config['tracker_max_display_length']) && $sugar_config['tracker_max_display_length'] > 0 && $sugar_config['tracker_max_display_length'] < 50) ? $sugar_config['tracker_max_display_length'] : 15;
        } else {
            $max_tracker_item_length = 15;
        }
    }

    if ($strlen > $max_tracker_item_length) {
        $chopped = function_exists('mb_substr') ? mb_substr($name, 0, $max_tracker_item_length - 3, 'UTF-8') : substr($name, 0, $max_tracker_item_length - 3);
        $chopped .= '...';
    } else {
        $chopped = $name;
    }

    return $chopped;
}

/**
 * @param array $field_list
 * @param array $values
 * @param array $bean
 * @param bool $add_custom_fields
 * @param string $module
 * @return array
 */
function generate_search_where(
    $field_list,
    $values,
    &$bean = null,
    $add_custom_fields = false,
    $module = ''
) {
    $where_clauses = array();
    $like_char = '%';
    $table_name = $bean->object_name;
    foreach ($field_list[$module] as $field => $parms) {
        if (isset($values[$field]) && $values[$field] != '') {
            $operator = 'like';
            if (!empty($parms['operator'])) {
                $operator = $parms['operator'];
            }
            if (is_array($values[$field])) {
                $operator = 'in';
                $field_value = '';
                foreach ($values[$field] as $key => $val) {
                    if ($val != ' ' and $val != '') {
                        if (!empty($field_value)) {
                            $field_value .= ',';
                        }
                        $field_value .= ""'"" . DBManagerFactory::getInstance()->quote($val) . ""'"";
                    }
                }
            } else {
                $field_value = DBManagerFactory::getInstance()->quote($values[$field]);
            }
            //set db_fields array.
            if (!isset($parms['db_field'])) {
                $parms['db_field'] = array($field);
            }
            if (isset($parms['my_items']) and $parms['my_items'] == true) {
                global $current_user;
                $field_value = DBManagerFactory::getInstance()->quote($current_user->id);
                $operator = '=';
            }

            $where = '';
            $itr = 0;
            if ($field_value != '') {
                foreach ($parms['db_field'] as $db_field) {
                    if (strstr($db_field, '.') === false) {
                        $db_field = $bean->table_name . '.' . $db_field;
                    }
                    if (DBManagerFactory::getInstance()->supports('case_sensitive') && isset($parms['query_type']) && $parms['query_type'] == 'case_insensitive') {
                        $db_field = 'upper(' . $db_field . ')';
                        $field_value = strtoupper($field_value);
                    }

                    ++$itr;
                    if (!empty($where)) {
                        $where .= ' OR ';
                    }
                    switch (strtolower($operator)) {
                        case 'like':
                            $where .= $db_field . "" like '"" . $field_value . $like_char . ""'"";
                            break;
                        case 'in':
                            $where .= $db_field . ' in (' . $field_value . ')';
                            break;
                        case '=':
                            $where .= $db_field . "" = '"" . $field_value . ""'"";
                            break;
                    }
                }
            }
            if (!empty($where)) {
                if ($itr > 1) {
                    array_push($where_clauses, '( ' . $where . ' )');
                } else {
                    array_push($where_clauses, $where);
                }
            }
        }
    }
    if ($add_custom_fields) {
        require_once 'modules/DynamicFields/DynamicField.php';
        $bean->setupCustomFields($module);
        $bean->custom_fields->setWhereClauses($where_clauses);
    }

    return $where_clauses;
}

/**
 * @deprecated This function is unused and will be removed in a future release.
 */
function add_quotes($str)
{
    return ""'{$str}'"";
}

/**
 * This function will rebuild the config file.
 *
 * @param   $sugar_config
 * @param   $sugar_version
 *
 * @return bool true if successful
 */
function rebuildConfigFile($sugar_config, $sugar_version)
{
    // add defaults to missing values of in-memory sugar_config
    $sugar_config = sugarArrayMerge(get_sugar_config_defaults(), $sugar_config);
    // need to override version with default no matter what
    $sugar_config['sugar_version'] = $sugar_version;

    ksort($sugar_config);

    if (write_array_to_file('sugar_config', $sugar_config, 'config.php')) {
        return true;
    }
    return false;
}

/**
 * Loads clean configuration, not overridden by config_override.php.
 *
 * @return array
 */
function loadCleanConfig()
{
    $sugar_config = array();
    require 'config.php';

    return $sugar_config;
}

/**
 * getJavascriptSiteURL
 * This function returns a URL for the client javascript calls to access
 * the site.  It uses $_SERVER['HTTP_REFERER'] in the event that Proxy servers
 * are used to access the site.  Thus, the hostname in the URL returned may
 * not always match that of $sugar_config['site_url'].  Basically, the
 * assumption is that however the user accessed the website is how they
 * will continue to with subsequent javascript requests.  If the variable
 * $_SERVER['HTTP_REFERER'] is not found then we default to old algorithm.
 *
 * @return $site_url The url used to refer to the website
 */
function getJavascriptSiteURL()
{
    global $sugar_config;
    if (!empty($_SERVER['HTTP_REFERER'])) {
        $url = parse_url($_SERVER['HTTP_REFERER']);
        $replacement_url = $url['scheme'] . '://' . $url['host'];
        if (!empty($url['port'])) {
            $replacement_url .= ':' . $url['port'];
        }
        $site_url = preg_replace('/^http[s]?\:\/\/[^\/]+/', $replacement_url, $sugar_config['site_url']);
    } else {
        $site_url = preg_replace('/^http(s)?\:\/\/[^\/]+/', 'http$1://' . $_SERVER['HTTP_HOST'], $sugar_config['site_url']);
        if (!empty($_SERVER['SERVER_PORT']) && $_SERVER['SERVER_PORT'] == '443') {
            $site_url = preg_replace('/^http\:/', 'https:', $site_url);
        }
    }
    $GLOBALS['log']->debug('getJavascriptSiteURL(), site_url=' . $site_url);

    return $site_url;
}


/**
 * Works nicely with array_map() -- can be used to wrap single quotes around
 * each element in an array.
 *
 * @deprecated This function is unused and will be removed in a future release.
 */
function add_squotes($str)
{
    return ""'"" . $str . ""'"";
}


/**
 * Recursive function to count the number of levels within an array.
 * @deprecated This function is unused and will be removed in a future release.
 */
function array_depth($array, $depth_count = -1, $depth_array = array())
{
    ++$depth_count;
    if (is_array($array)) {
        foreach ($array as $key => $value) {
            $depth_array[] = array_depth($value, $depth_count);
        }
    } else {
        return $depth_count;
    }
    foreach ($depth_array as $value) {
        $depth_count = $value > $depth_count ? $value : $depth_count;
    }

    return $depth_count;
}

/**
 * Creates a new Group User.
 *
 * @param string $name Name of Group User
 *
 * @return string GUID of new Group User
 */
function createGroupUser($name)
{
    $group = BeanFactory::newBean('Users');
    $group->user_name = $name;
    $group->last_name = $name;
    $group->is_group = 1;
    $group->deleted = 0;
    $group->status = 'Active'; // cn: bug 6711
    $group->setPreference('timezone', TimeDate::userTimezone());
    $group->save();

    return $group->id;
}

/*
 * Helper function to locate an icon file given only a name
 * Searches through the various paths for the file
 * @param string iconFileName   The filename of the icon
 * @return string Relative pathname of the located icon, or '' if not found
 */

function _getIcon($iconFileName)
{
    if (file_exists(SugarThemeRegistry::current()->getImagePath() . DIRECTORY_SEPARATOR . 'icon_' . $iconFileName . '.svg')) {
        $iconName = ""icon_{$iconFileName}.svg"";
        $iconFound = SugarThemeRegistry::current()->getImageURL($iconName, false);
    } else {
        $iconName = ""icon_{$iconFileName}.gif"";
        $iconFound = SugarThemeRegistry::current()->getImageURL($iconName, false);
    }



    //First try un-ucfirst-ing the icon name
    if (empty($iconFound)) {
        $iconName = 'icon_' . strtolower(substr($iconFileName, 0, 1)) . substr($iconFileName, 1) . '.gif';
    }
    $iconFound = SugarThemeRegistry::current()->getImageURL($iconName, false);

    //Next try removing the icon prefix
    if (empty($iconFound)) {
        $iconName = ""{$iconFileName}.gif"";
    }
    $iconFound = SugarThemeRegistry::current()->getImageURL($iconName, false);

    if (empty($iconFound)) {
        $iconName = '';
    }

    return $iconName;
}

/**
 * Function to grab the correct icon image for Studio.
 *
 * @param string $iconFileName Name of the icon file
 * @param string $altfilename  Name of a fallback icon file (displayed if the imagefilename doesn't exist)
 * @param string $width        Width of image
 * @param string $height       Height of image
 * @param string $align        Alignment of image
 * @param string $alt          Alt tag of image
 *
 * @return string $string <img> tag with corresponding image
 */
function getStudioIcon($iconFileName = '', $altFileName = '', $width = '48', $height = '48', $align = 'baseline', $alt = '')
{
    global $app_strings, $theme;

    $iconName = _getIcon($iconFileName);
    if (empty($iconName)) {
        $iconName = _getIcon($altFileName);
        if (empty($iconName)) {
            return $app_strings['LBL_NO_IMAGE'];
        }
    }

    return SugarThemeRegistry::current()->getImage($iconName, ""align=\""$align\"" border=\""0\"""", $width, $height);
}

/**
 * Function to grab the correct icon image for Dashlets Dialog.
 *
 * @param string $filename Location of the icon file
 * @param string $module   Name of the module to fall back onto if file does not exist
 * @param string $width    Width of image
 * @param string $height   Height of image
 * @param string $align    Alignment of image
 * @param string $alt      Alt tag of image
 *
 * @return string $string <img> tag with corresponding image
 */
function get_dashlets_dialog_icon($module = '', $width = '32', $height = '32', $align = 'absmiddle', $alt = '')
{
    global $app_strings, $theme;
    $iconName = _getIcon($module . '_32');
    if (empty($iconName)) {
        $iconName = _getIcon($module);
    }
    if (empty($iconName)) {
        return $app_strings['LBL_NO_IMAGE'];
    }

    return $iconName;
}

// works nicely to change UTF8 strings that are html entities - good for PDF conversions
function html_entity_decode_utf8($string)
{
    static $trans_tbl;
    // replace numeric entities
    //php will have issues with numbers with leading zeros, so do not include them in what we send to code2utf.

    $string = preg_replace_callback('~&#x0*([0-9a-f]+);~i', function ($matches) {
        return code2utf(hexdec($matches[1]));
    }, $string);
    $string = preg_replace_callback('~&#0*([0-9]+);~', function ($matches) {
        return code2utf($matches[1]);
    }, $string);

    // replace literal entities
    if (!isset($trans_tbl)) {
        $trans_tbl = array();
        foreach (get_html_translation_table(HTML_ENTITIES) as $val => $key) {
            $trans_tbl[$key] = utf8_encode($val);
        }
    }

    return strtr($string, $trans_tbl);
}

// Returns the utf string corresponding to the unicode value
function code2utf($num)
{
    if ($num < 128) {
        return chr($num);
    }
    if ($num < 2048) {
        return chr(($num >> 6) + 192) . chr(($num & 63) + 128);
    }
    if ($num < 65536) {
        return chr(($num >> 12) + 224) . chr((($num >> 6) & 63) + 128) . chr(($num & 63) + 128);
    }
    if ($num < 2097152) {
        return chr(($num >> 18) + 240) . chr((($num >> 12) & 63) + 128) . chr((($num >> 6) & 63) + 128) . chr(($num & 63) + 128);
    }

    return '';
}

/*
 * @deprecated use DBManagerFactory::isFreeTDS
 */

function is_freetds()
{
    return DBManagerFactory::isFreeTDS();
}

/**
 * Chart dashlet helper function that returns the correct CSS file, dependent on the current theme.
 *
 * @deprecated This function is unused and will be removed in a future release.
 *
 * @todo this won't work completely right until we impliment css compression and combination
 *       for now, we'll just include the last css file found.
 *
 * @return chart.css file to use
 */
function chartStyle()
{
    return SugarThemeRegistry::current()->getCSSURL('chart.css');
}

/**
 * Chart dashlet helper functions that returns the correct XML color file for charts,
 * dependent on the current theme.
 *
 * @deprecated This function is unused and will be removed in a future release.
 * @return sugarColors.xml to use
 */
function chartColors()
{
    if (SugarThemeRegistry::current()->getCSSURL('sugarColors.xml') == '') {
        return SugarThemeRegistry::current()->getImageURL('sugarColors.xml');
    }

    return SugarThemeRegistry::current()->getCSSURL('sugarColors.xml');
}

/* End Chart Dashlet helper functions */

/**
 * This function is designed to set up the php enviroment
 * for AJAX requests.
 *
 * @deprecated This function is unused and will be removed in a future release.
 */
function ajaxInit()
{
    //ini_set('display_errors', 'false');
}

/**
 * Returns an absolute path from the given path, determining if it is relative or absolute.
 *
 * @param string $path
 *
 * @return string
 */
function getAbsolutePath(
    $path,
    $currentServer = false
) {
    $path = trim($path);

    // try to match absolute paths like \\server\share, /directory or c:\
    if ((substr($path, 0, 2) == '\\\\') || ($path[0] == '/') || preg_match('/^[A-z]:/i', $path) || $currentServer
    ) {
        return $path;
    }

    return getcwd() . '/' . $path;
}

/**
 * Returns the bean object of the given module.
 *
 * @deprecated use SugarModule::loadBean() instead
 *
 * @param string $module
 *
 * @return object
 */
function loadBean(
    $module
) {
    return SugarModule::get($module)->loadBean();
}

/**
 * Returns true if the application is being accessed on a touch screen interface ( like an iPad ).
 */
function isTouchScreen()
{
    $ua = empty($_SERVER['HTTP_USER_AGENT']) ? 'undefined' : strtolower($_SERVER['HTTP_USER_AGENT']);

    // first check if we have forced use of the touch enhanced interface
    if (isset($_COOKIE['touchscreen']) && $_COOKIE['touchscreen'] == '1') {
        return true;
    }

    // next check if we should use the touch interface with our device
    if (strpos($ua, 'ipad') !== false) {
        return true;
    }

    return false;
}

/**
 * Returns the shortcut keys to access the shortcut links.  Shortcut
 * keys vary depending on browser versions and operating systems.
 *
 * @return string value of the shortcut keys
 */
function get_alt_hot_key()
{
    $ua = '';
    if (isset($_SERVER['HTTP_USER_AGENT'])) {
        $ua = strtolower($_SERVER['HTTP_USER_AGENT']);
    }
    $isMac = strpos($ua, 'mac') !== false;
    $isLinux = strpos($ua, 'linux') !== false;

    if (!$isMac && !$isLinux && strpos($ua, 'mozilla') !== false) {
        if (preg_match('/firefox\/(\d)?\./', $ua, $matches)) {
            return $matches[1] < 2 ? 'Alt+' : 'Alt+Shift+';
        }
    }

    return $isMac ? 'Ctrl+' : 'Alt+';
}

function can_start_session()
{
    if (!empty($_GET[session_name()])) {
        return true;
    }
    $session_id = session_id();

    return empty($session_id) ? true : false;
}

function load_link_class($properties)
{
    $class = 'Link2';
    if (!empty($properties['link_class']) && !empty($properties['link_file'])) {
        if (!file_exists($properties['link_file'])) {
            $GLOBALS['log']->fatal('File not found: ' . $properties['link_file']);
        } else {
            require_once $properties['link_file'];
            $class = $properties['link_class'];
        }
    }

    return $class;
}

function inDeveloperMode()
{
    return isset($GLOBALS['sugar_config']['developerMode']) && $GLOBALS['sugar_config']['developerMode'];
}

/**
 * Filter the protocol list for inbound email accounts.
 *
 * @param array $protocol
 */
function filterInboundEmailPopSelection($protocol)
{
    if (!isset($GLOBALS['sugar_config']['allow_pop_inbound']) || !$GLOBALS['sugar_config']['allow_pop_inbound']) {
        if (isset($protocol['pop3'])) {
            unset($protocol['pop3']);
        }
    } else {
        $protocol['pop3'] = 'POP3';
    }

    return $protocol;
}

/**
 * Get Inbound Email protocols
 *
 * @return array
 */
function getInboundEmailProtocols(): array
{
    global $app_list_strings, $sugar_config;

    $protocols = $app_list_strings['dom_email_server_type'];
    if (!isset($sugar_config['allow_pop_inbound']) || !$sugar_config['allow_pop_inbound']) {
        if (isset($protocols['pop3'])) {
            unset($protocols['pop3']);
        }
    } else {
        $protocols['pop3'] = 'POP3';
    }

    return $protocols;
}

/**
 * The function is used because currently we are not supporting mbstring.func_overload
 * For some user using mssql without FreeTDS, they may store multibyte charaters in varchar using latin_general collation. It cannot store so many mutilbyte characters, so we need to use strlen.
 * The varchar in MySQL, Orcale, and nvarchar in FreeTDS, we can store $length mutilbyte charaters in it. we need mb_substr to keep more info.
 *
 * @returns the substred strings.
 */
function sugar_substr($string, $length, $charset = 'UTF-8')
{
    if (mb_strlen($string, $charset) > $length) {
        $string = trim(mb_substr(trim($string), 0, $length, $charset));
    }

    return $string;
}

/**
 * The function is used because on FastCGI enviroment, the ucfirst(Chinese Characters) will produce bad charcters.
 * This will work even without setting the mbstring.*encoding.
 */
function sugar_ucfirst($string, $charset = 'UTF-8')
{
    return mb_strtoupper(mb_substr($string, 0, 1, $charset), $charset) . mb_substr($string, 1, mb_strlen($string), $charset);
}

/**
 * Given a multienum encoded as a string, convert it to an array of strings,
 * e.g. `""^Monday^,^Tuesday^,^Wednesday^,^Thursday^""` becomes
 * `[""Monday"", ""Tuesday"", ""Wednesday"", ""Thursday""]`.
 *
 * @param string|string[] $string The encoded multienum value. If this is already an array, the array will be returned unchanged.
 * @return string[] An array of strings representing the multienum's values.
 */
function unencodeMultienum($string)
{
    if (is_array($string)) {
        return $string;
    }
    if (substr($string, 0, 1) == '^' && substr($string, -1) == '^') {
        $string = substr(substr($string, 1), 0, strlen($string) - 2);
    }

    return explode('^,^', $string);
}

function encodeMultienumValue($arr)
{
    if (!is_array($arr)) {
        return $arr;
    }

    if (empty($arr)) {
        return '';
    }

    $string = '^' . implode('^,^', $arr) . '^';

    return $string;
}

/**
 * create_export_query is used for export and massupdate
 * We haven't handle the these fields: $field['type'] == 'relate' && isset($field['link']
 * This function will correct the where clause and output necessary join condition for them.
 *
 * @param $module : the module name
 * @param $searchFields : searchFields which is got after $searchForm->populateFromArray()
 * @param $where : where clauses
 *
 * @return array
 */
function create_export_query_relate_link_patch($module, $searchFields, $where)
{
    if (file_exists('modules/' . $module . '/SearchForm.html')) {
        $ret_array['where'] = $where;

        return $ret_array;
    }
    $seed = BeanFactory::getBean($module);
    foreach ($seed->field_defs as $name => $field) {
        if ($field['type'] == 'relate' && isset($field['link']) && !empty($searchFields[$name]['value'])) {
            $seed->load_relationship($field['link']);
            $params = array();
            if (empty($join_type)) {
                $params['join_type'] = ' LEFT JOIN ';
            } else {
                $params['join_type'] = $join_type;
            }
            if (isset($data['join_name'])) {
                $params['join_table_alias'] = $field['join_name'];
            } else {
                $params['join_table_alias'] = 'join_' . $field['name'];
            }
            if (isset($data['join_link_name'])) {
                $params['join_table_link_alias'] = $field['join_link_name'];
            } else {
                $params['join_table_link_alias'] = 'join_link_' . $field['name'];
            }
            $fieldLink = $field['link'];
            $join = $seed->$fieldLink->getJoin($params, true);
            $join_table_alias = 'join_' . $field['name'];
            if (isset($field['db_concat_fields'])) {
                $db_field = DBManager::concat($join_table_alias, $field['db_concat_fields']);
                $where = preg_replace('/' . $field['name'] . '/', $db_field, $where);
            } else {
                $where = preg_replace('/(^|[\s(])' . $field['name'] . '/', '${1}' . $join_table_alias . '.' . $field['rname'], $where);
            }
        }
    }
    $ret_array = array('where' => $where, 'join' => isset($join['join']) ? $join['join'] : '');

    return $ret_array;
}

/**
 * We need to clear all the js cache files, including the js language files  in serval places in MB. So I extract them into a util function here.
 *
 * @Depends on QuickRepairAndRebuild.php
 * @Relate bug 30642  ,23177
 */
function clearAllJsAndJsLangFilesWithoutOutput()
{
    global $current_language, $mod_strings;
    $MBmodStrings = $mod_strings;
    $mod_strings = return_module_language($current_language, 'Administration');
    include_once 'modules/Administration/QuickRepairAndRebuild.php';
    $repair = new RepairAndClear();
    $repair->module_list = array();
    $repair->show_output = false;
    $repair->clearJsLangFiles();
    $repair->clearJsFiles();
    $mod_strings = $MBmodStrings;
}

/**
 * This function will allow you to get a variable value from query string.
 */
function getVariableFromQueryString($variable, $string)
{
    $matches = array();
    $number = preg_match(""/{$variable}=([a-zA-Z0-9_-]+)[&]?/"", $string, $matches);
    if ($number) {
        return $matches[1];
    }
    return false;
}

/**
 * should_hide_iframes
 * This is a helper method to determine whether or not to show iframes (My Sites) related
 * information in the application.
 *
 * @return bool flag indicating whether or not iframes module should be hidden
 */
function should_hide_iframes()
{
    //Remove the MySites module
    if (file_exists('modules/iFrames/iFrame.php')) {
        if (!class_exists('iFrame')) {
            require_once 'modules/iFrames/iFrame.php';
        }

        return false;
    }

    return true;
}

/**
 * Given a version such as 5.5.0RC1 return RC. If we have a version such as: 5.5 then return GA.
 *
 * @deprecated This function is unused and will be removed in a future release.
 *
 * @param string $version
 * @return string RC, BETA, GA
 */
function getVersionStatus($version)
{
    if (preg_match('/^[\d\.]+?([a-zA-Z]+?)[\d]*?$/si', $version, $matches)) {
        return strtoupper($matches[1]);
    }
    return 'GA';
}

/**
 * Return the numeric portion of a version. For example if passed 5.5.0RC1 then return 5.5. If given
 * 5.5.1RC1 then return 5.5.1.
 *
 * @deprecated This function is unused and will be removed in a future release.
 *
 * @param string $version
 *
 * @return version
 */
function getMajorMinorVersion($version)
{
    if (preg_match('/^([\d\.]+).*$/si', $version, $matches2)) {
        $version = $matches2[1];
        $arr = explode('.', $version);
        if (count($arr) > 2) {
            if ($arr[2] == '0') {
                $version = substr($version, 0, 3);
            }
        }
    }

    return $version;
}

/**
 * Return string composed of seconds & microseconds of current time, without dots.
 *
 * @return string
 */
function sugar_microtime()
{
    $now = explode(' ', microtime());
    $unique_id = $now[1] . str_replace('.', '', $now[0]);

    return $unique_id;
}

/**
 * Extract urls from a piece of text.
 *
 * @param  $string
 *
 * @return array of urls found in $string
 */
function getUrls($string)
{
    $lines = explode('<br>', trim($string));
    $urls = array();
    foreach ($lines as $line) {
        $regex = '/http?\:\/\/[^\"" ]+/i';
        preg_match_all($regex, $line, $matches);
        foreach ($matches[0] as $match) {
            $urls[] = $match;
        }
    }

    return $urls;
}

/**
 * Sanitize image file from hostile content.
 *
 * @param string $path Image file
 * @param bool   $jpeg Accept only JPEGs?
 */
function verify_image_file($path, $jpeg = false)
{
    if (function_exists('imagepng') && function_exists('imagejpeg') && function_exists('imagecreatefromstring')) {
        $img = imagecreatefromstring(file_get_contents($path));
        if (!$img) {
            return false;
        }
        $img_size = getimagesize($path);
        $filetype = $img_size['mime'];
        //if filetype is jpeg or if we are only allowing jpegs, create jpg image
        if ($filetype == 'image/jpeg' || $jpeg) {
            ob_start();
            imagejpeg($img);
            $image = ob_get_clean();
            // not writing directly because imagejpeg does not work with streams
            if (file_put_contents($path, $image)) {
                return true;
            }
        } elseif ($filetype == 'image/png') {
            // else if the filetype is png, create png
            imagealphablending($img, true);
            imagesavealpha($img, true);
            ob_start();
            imagepng($img);
            $image = ob_get_clean();
            if (file_put_contents($path, $image)) {
                return true;
            }
        } else {
            return false;
        }
    } else {
        // check image manually
        $fp = fopen($path, 'rb');
        if (!$fp) {
            return false;
        }
        $data = '';
        // read the whole file in chunks
        while (!feof($fp)) {
            $data .= fread($fp, 8192);
        }

        fclose($fp);
        if (preg_match(""/<(\?php|html|!doctype|script|body|head|plaintext|table|img |pre(>| )|frameset|iframe|object|link|base|style|font|applet|meta|center|form|isindex)/i"", $data, $m)) {
            $GLOBALS['log']->fatal(""Found {$m[0]} in $path, not allowing upload"");

            return false;
        }

        return true;
    }

    return false;
}

/**
 * Verify uploaded image
 * Verifies that image has proper extension, MIME type and doesn't contain hostile content.
 *
 * @param string $path      Image path
 * @param bool   $jpeg_only Accept only JPEGs?
 */
function verify_uploaded_image($path, $jpeg_only = false)
{
    $supportedExtensions = array('jpg' => 'image/jpeg', 'jpeg' => 'image/jpeg', 'tmp' => 'tmp');
    if (!$jpeg_only) {
        $supportedExtensions['png'] = 'image/png';
    }

    if (!file_exists($path) || !is_file($path)) {
        return false;
    }

    $img_size = getimagesize($path);
    $filetype = $img_size['mime'];
    $tmpArray = explode('.', $path);
    $ext = end($tmpArray);
    if (substr_count('..', $path) > 0 || ($ext !== $path && !isset($supportedExtensions[strtolower($ext)])) ||
            !in_array($filetype, array_values($supportedExtensions))
    ) {
        return false;
    }

    return verify_image_file($path, $jpeg_only);
}

function cmp_beans($a, $b)
{
    global $sugar_web_service_order_by;
    //If the order_by field is not valid, return 0;
    if (empty($sugar_web_service_order_by) || !isset($a->$sugar_web_service_order_by) || !isset($b->$sugar_web_service_order_by)) {
        return 0;
    }
    if (is_object($a->$sugar_web_service_order_by) || is_object($b->$sugar_web_service_order_by) || is_array($a->$sugar_web_service_order_by) || is_array($b->$sugar_web_service_order_by)
    ) {
        return 0;
    }
    if ($a->$sugar_web_service_order_by < $b->$sugar_web_service_order_by) {
        return -1;
    }
    return 1;
}

function order_beans($beans, $field_name)
{
    //Since php 5.2 doesn't include closures, we must use a global to pass the order field to cmp_beans.
    global $sugar_web_service_order_by;
    $sugar_web_service_order_by = $field_name;
    usort($beans, 'cmp_beans');

    return $beans;
}

/**
 * Return search like string
 * This function takes a user input string and returns a string that contains wild card(s) that can be used in db query.
 *
 * @param string $str       string to be searched
 * @param string $like_char Database like character, usually '%'
 *
 * @return string Returns a string to be searched in db query
 */
function sql_like_string($str, $like_char, $wildcard = '%', $appendWildcard = true)
{

    // override default wildcard character
    if (isset($GLOBALS['sugar_config']['search_wildcard_char']) &&
            strlen($GLOBALS['sugar_config']['search_wildcard_char']) == 1
    ) {
        $wildcard = $GLOBALS['sugar_config']['search_wildcard_char'];
    }

    // add wildcard at the beginning of the search string
    if (isset($GLOBALS['sugar_config']['search_wildcard_infront']) &&
            $GLOBALS['sugar_config']['search_wildcard_infront'] == true
    ) {
        if (substr($str, 0, 1) != $wildcard) {
            $str = $wildcard . $str;
        }
    }

    // add wildcard at the end of search string (default)
    if ($appendWildcard) {
        if (substr($str, -1) != $wildcard) {
            $str .= $wildcard;
        }
    }

    return str_replace($wildcard, $like_char, $str);
}

//check to see if custom utils exists
if (file_exists('custom/include/custom_utils.php')) {
    include_once 'custom/include/custom_utils.php';
}

//check to see if custom utils exists in Extension framework
if (file_exists('custom/application/Ext/Utils/custom_utils.ext.php')) {
    include_once 'custom/application/Ext/Utils/custom_utils.ext.php';
}

/**
 * @param $input - the input string to sanitize
 * @param int    $quotes  - use quotes
 * @param string $charset - the default charset
 * @param bool   $remove  - strip tags or not
 *
 * @return string - the sanitized string
 */
function sanitize($input, $quotes = ENT_QUOTES, $charset = 'UTF-8', $remove = false)
{
    return htmlentities($input, $quotes, $charset);
}

/**
 * @return string - the full text search engine name
 */
function getFTSEngineType()
{
    if (isset($GLOBALS['sugar_config']['full_text_engine']) && is_array($GLOBALS['sugar_config']['full_text_engine'])) {
        foreach ($GLOBALS['sugar_config']['full_text_engine'] as $name => $defs) {
            return $name;
        }
    }

    return '';
}

/**
 * @deprecated This function is unused and will be removed in a future release.
 *
 * @param string $optionName - name of the option to be retrieved from app_list_strings
 * @return array - the array to be used in option element
 */
function getFTSBoostOptions($optionName)
{
    if (isset($GLOBALS['app_list_strings'][$optionName])) {
        return $GLOBALS['app_list_strings'][$optionName];
    }
    return array();
}

/**
 * utf8_recursive_encode.
 *
 * This function walks through an Array and recursively calls utf8_encode on the
 * values of each of the elements.
 *
 * @deprecated This function is unused and will be removed in a future release.
 *
 * @param $data Array of data to encode
 *
 * @return utf8 encoded Array data
 */
function utf8_recursive_encode($data)
{
    $result = array();
    foreach ($data as $key => $val) {
        if (is_array($val)) {
            $result[$key] = utf8_recursive_encode($val);
        } else {
            $result[$key] = utf8_encode($val);
        }
    }

    return $result;
}

/**
 * get_language_header.
 *
 * This is a utility function for 508 Compliance.  It returns the lang=[Current Language] text string used
 * inside the <html> tag.  If no current language is specified, it defaults to lang='en'.
 *
 * @return string The lang=[Current Language] markup to insert into the <html> tag
 */
function get_language_header()
{
    return isset($GLOBALS['current_language']) ? ""lang='{$GLOBALS['current_language']}'"" : ""lang='en'"";
}

/**
 * get_custom_file_if_exists.
 *
 * This function handles the repetitive code we have where we first check if a file exists in the
 * custom directory to determine whether we should load it, require it, include it, etc.  This function returns the
 * path of the custom file if it exists.  It basically checks if custom/{$file} exists and returns this path if so;
 * otherwise it return $file
 *
 * @param $file String of filename to check
 *
 * @return $file String of filename including custom directory if found
 */
function get_custom_file_if_exists($file)
{
    return file_exists(""custom/{$file}"") ? ""custom/{$file}"" : $file;
}

/**
 * get_help_url.
 *
 * This will return the URL used to redirect the user to the help documentation.
 * It can be overriden completely by setting the custom_help_url or partially by setting the custom_help_base_url
 * in config.php or config_override.php.
 *
 * @deprecated This function is unused and will be removed in a future release.
 *
 * @param string $send_edition
 * @param string $send_version
 * @param string $send_lang
 * @param string $send_module
 * @param string $send_action
 * @param string $dev_status
 * @param string $send_key
 * @param string $send_anchor
 *
 * @return string the completed help URL
 */
function get_help_url($send_edition = '', $send_version = '', $send_lang = '', $send_module = '', $send_action = '', $dev_status = '', $send_key = '', $send_anchor = '')
{
    global $sugar_config;

    if (!empty($sugar_config['custom_help_url'])) {
        $sendUrl = $sugar_config['custom_help_url'];
    } else {
        if (!empty($sugar_config['custom_help_base_url'])) {
            $baseUrl = $sugar_config['custom_help_base_url'];
        } else {
            $baseUrl = 'http://www.sugarcrm.com/crm/product_doc.php';
        }
        $sendUrl = $baseUrl . ""?edition={$send_edition}&version={$send_version}&lang={$send_lang}&module={$send_module}&help_action={$send_action}&status={$dev_status}&key={$send_key}"";
        if (!empty($send_anchor)) {
            $sendUrl .= '&anchor=' . $send_anchor;
        }
    }

    return $sendUrl;
}

/**
 * generateETagHeader.
 *
 * This function generates the necessary cache headers for using ETags with dynamic content. You
 * simply have to generate the ETag, pass it in, and the function handles the rest.
 *
 * @param string $etag ETag to use for this content.
 */
function generateETagHeader($etag)
{
    header('cache-control:');
    header('Expires: ');
    header('ETag: ' . $etag);
    header('Pragma:');
    if (isset($_SERVER['HTTP_IF_NONE_MATCH'])) {
        if ($etag == $_SERVER['HTTP_IF_NONE_MATCH']) {
            ob_clean();
            header('Status: 304 Not Modified');
            header('HTTP/1.0 304 Not Modified');
            die();
        }
    }
}

/**
 * getReportNameTranslation.
 *
 * Translates the report name if a translation exists,
 * otherwise just returns the name
 *
 * @param string $reportName
 *
 * @return string translated report name
 */
function getReportNameTranslation($reportName)
{
    global $current_language;

    // Used for translating reports
    $mod_strings = return_module_language($current_language, 'Reports');

    // Search for the report name in the default language and get the key
    $key = array_search($reportName, return_module_language('', 'Reports'));

    // If the key was found, use it to get a translation, otherwise just use report name
    if (!empty($key)) {
        $title = $mod_strings[$key];
    } else {
        $title = $reportName;
    }

    return $title;
}

/**
 * Remove vars marked senstitive from array.
 *
 * @param array           $defs
 * @param SugarBean|array $data
 *
 * @return mixed $data without sensitive fields
 */
function clean_sensitive_data($defs, $data)
{
    foreach ($defs as $field => $def) {
        if (!empty($def['sensitive'])) {
            if (is_array($data)) {
                $data[$field] = '';
            }
            if ($data instanceof SugarBean) {
                $data->$field = '';
            }
        }
    }

    return $data;
}

/**
 * Return relations with labels for duplicates.
 *
 * @deprecated This function is unused and will be removed in a future release.
 */
function getDuplicateRelationListWithTitle($def, $var_def, $module)
{
    global $current_language;
    $select_array = array_unique($def);
    if (count($select_array) < count($def)) {
        $temp_module_strings = return_module_language($current_language, $module);
        $temp_duplicate_array = array_diff_assoc($def, $select_array);
        $temp_duplicate_array = array_merge($temp_duplicate_array, array_intersect($select_array, $temp_duplicate_array));

        foreach ($temp_duplicate_array as $temp_key => $temp_value) {
            // Don't add duplicate relationships
            if (!empty($var_def[$temp_key]['relationship']) && array_key_exists($var_def[$temp_key]['relationship'], $select_array)) {
                continue;
            }
            $select_array[$temp_key] = $temp_value;
        }

        // Add the relationship name for easier recognition
        foreach ($select_array as $key => $value) {
            $select_array[$key] .= ' (' . $key . ')';
        }
    }
    asort($select_array);

    return $select_array;
}

/**
 * Gets the list of ""*type_display*"".
 *
 * @return array
 */
function getTypeDisplayList()
{
    return array('record_type_display', 'parent_type_display', 'record_type_display_notes');
}

/**
 * Breaks given string into substring according
 * to 'db_concat_fields' from field definition
 * and assigns values to corresponding properties
 * of bean.
 *
 * @param SugarBean $bean
 * @param array     $fieldDef
 * @param string    $value
 */
function assignConcatenatedValue(SugarBean $bean, $fieldDef, $value)
{
    $valueParts = explode(' ', $value);
    $valueParts = array_filter($valueParts);
    $fieldNum = count($fieldDef['db_concat_fields']);

    if (count($valueParts) == 1 && $fieldDef['db_concat_fields'] == array('first_name', 'last_name')) {
        $bean->last_name = $value;
    } // elseif ($fieldNum >= count($valueParts))
    else {
        for ($i = 0; $i < $fieldNum; ++$i) {
            $fieldValue = array_shift($valueParts);
            $fieldName = $fieldDef['db_concat_fields'][$i];
            $bean->$fieldName = $fieldValue !== false ? $fieldValue : '';
        }

        if (!empty($valueParts)) {
            $bean->$fieldName .= ' ' . implode(' ', $valueParts);
        }
    }
}

/**
 * Performs unserialization. Accepts all types except Objects.
 *
 * @param string $value Serialized value of any type except Object
 *
 * @return mixed False if Object, converted value for other cases
 */
function sugar_unserialize($value)
{
    preg_match('/[oc]:[^:]*\d+:/i', $value, $matches);

    if (count($matches)) {
        return false;
    }

    return unserialize($value);
}

define('DEFAULT_UTIL_SUITE_ENCODING', 'UTF-8');

/**
 * @deprecated This function is unused and will be removed in a future release.
 */
function suite_strlen($input, $encoding = DEFAULT_UTIL_SUITE_ENCODING)
{
    if (function_exists('mb_strlen')) {
        return mb_strlen($input, $encoding);
    }
    return strlen($input);
}

/**
 * @deprecated This function is unused and will be removed in a future release.
 */
function suite_substr($input, $start, $length = null, $encoding = DEFAULT_UTIL_SUITE_ENCODING)
{
    if (function_exists('mb_substr')) {
        return mb_substr($input, $start, $length, $encoding);
    }
    return substr($input, $start, $length);
}

/**
 * @deprecated This function is unused and will be removed in a future release.
 */
function suite_strtoupper($input, $encoding = DEFAULT_UTIL_SUITE_ENCODING)
{
    if (function_exists('mb_strtoupper')) {
        return mb_strtoupper($input, $encoding);
    }
    return strtoupper($input);
}

/**
 * @deprecated This function is unused and will be removed in a future release.
 */
function suite_strtolower($input, $encoding = DEFAULT_UTIL_SUITE_ENCODING)
{
    if (function_exists('mb_strtolower')) {
        return mb_strtolower($input, $encoding);
    }
    return strtolower($input);
}

/**
 * @deprecated This function is unused and will be removed in a future release.
 */
function suite_strpos($haystack, $needle, $offset = 0, $encoding = DEFAULT_UTIL_SUITE_ENCODING)
{
    if (function_exists('mb_strpos')) {
        return mb_strpos($haystack, $needle, $offset, $encoding);
    }
    return strpos($haystack, $needle, $offset);
}

/**
 * @deprecated This function is unused and will be removed in a future release.
 */
function suite_strrpos($haystack, $needle, $offset = 0, $encoding = DEFAULT_UTIL_SUITE_ENCODING)
{
    if (function_exists('mb_strrpos')) {
        return mb_strrpos($haystack, $needle, $offset, $encoding);
    }
    return strrpos($haystack, $needle, $offset);
}

/**
 * @deprecated deprecated since version 7.10 please use the SuiteValidator class
 */
function isValidId($id)
{
    $deprecatedMessage = 'isValidId method is deprecated please update your code';
    if (isset($GLOBALS['log'])) {
        $GLOBALS['log']->deprecated($deprecatedMessage);
    } else {
        trigger_error($deprecatedMessage, E_USER_DEPRECATED);
    }
    $isValidator = new SuiteValidator();
    $result = $isValidator->isValidId($id);
    return $result;
}

function isValidEmailAddress($email, $message = 'Invalid email address given', $orEmpty = true, $logInvalid = 'error')
{
    if ($orEmpty && !$email) {
        return true;
    }
    if (filter_var($email, FILTER_VALIDATE_EMAIL)) {
        return true;
    }
    if ($logInvalid) {
        $trace = debug_backtrace();
        $where = ""Called at {$trace[1]['file']}:{$trace[1]['line']} from function {$trace[1]['function']}."";
        ErrorMessage::log(""$message: [$email] $where"", $logInvalid);
    }
    return false;
}

function displayAdminError($errorString)
{
    SugarApplication::appendErrorMessage($errorString);
}

function getAppString($key)
{
    global $app_strings;

    if (!isset($app_strings[$key])) {
        LoggerManager::getLogger()->warn('Language key not found: ' . $key);
        return $key;
    }

    if (!$app_strings[$key]) {
        LoggerManager::getLogger()->warn('Language string is empty at key: ' . $key);
        return $key;
    }

    return $app_strings[$key];
}

function set_session_name(){
    $sessionName = 'LEGACYSESSID';
    if (!empty($GLOBALS['sugar_config']['session_name'])) {
        $sessionName = $GLOBALS['sugar_config']['session_name'];
    }

    if (session_status() === PHP_SESSION_NONE) {
        session_name($sessionName);
    }
}

/**
 * Check if has valid image extension
 * @param string $fieldName
 * @param string $value
 * @return bool
 */
function has_valid_image_extension($fieldName, $name)
{
    global $sugar_config;

    $validExtensions = [
        'gif',
        'png',
        'jpg',
        'jpeg',
        'svg'
    ];

    if (isset($sugar_config['valid_image_ext']) && is_array($sugar_config['valid_image_ext'])){
        $validExtensions = $sugar_config['valid_image_ext'];
    }

    return has_valid_extension($fieldName, $name, $validExtensions);
}

/**
 * Check if has valid extension
 * @param string $fieldName
 * @param string $name
 * @param array $validExtensions
 * @return bool
 */
function has_valid_extension($fieldName, $name, $validExtensions)
{

    if ($name === '.' || empty($name)) {
        LoggerManager::getLogger()->security(""Invalid ext  $fieldName : '$name'."");

        return false;
    }

    $validExtensions = array_map('strtolower', $validExtensions);

    $parts = explode('.', $name);

    if (empty($parts)) {
        LoggerManager::getLogger()->security(""Invalid ext  $fieldName : '$name'."");

        return false;
    }

    $ext = array_pop($parts);
    $trimmedValue = preg_replace('/.*\.([^\.]+)$/', '\1', $ext);

    if (!in_array(strtolower($trimmedValue), $validExtensions, true)) {
        LoggerManager::getLogger()->security(""Invalid $fieldName: '$name'."");

        return false;
    }

    return true;
}

/**
 * Check if value is one of the accepted true representations
 * @param $value
 * @return bool
 */
function isTrue($value): bool {
    return $value === true || $value === 'true' || $value === 1 || $value === '1' || $value === 'on';
}

/**
 * Check if value is one of the accepted false representations
 * @param $value
 * @return bool
 */
function isFalse($value): bool {
    return $value === false || $value === 'false' || $value === 0 || $value === '0';
}

/**
 * Get validation pattern
 * @return string
 */
function get_id_validation_pattern(): string {
    global $sugar_config;

    $pattern = '/^[a-zA-Z0-9_-]*$/i';
    if (!empty($sugar_config['id_validation_pattern'])){
        $pattern = $sugar_config['id_validation_pattern'];
    }

    return $pattern;
}

/**
 * Check if user has group and action acls defined
 * @param string $module
 * @param string $action
 * @return bool
 */
function has_group_action_acls_defined(string $module, string $action): bool
{
    global $current_user;

    $hasGroupActionAcls = true;

    $groups = SecurityGroup::getUserSecurityGroups($current_user->id);
    $hasGroups = !empty($groups);

    $aclActions = ACLAction::getUserActions($current_user->id, false, $module, 'module', $action);
    $isDefaultListACL = !empty($aclActions['isDefault']) && isTrue($aclActions['isDefault']);

    if (!$hasGroups) {
        $hasGroupActionAcls = false;
    }

    if ($isDefaultListACL) {
        $hasGroupActionAcls = false;
    }

    return $hasGroupActionAcls;
}

/**
 * Check if is value is smtp in a case-insensitive way
 * @param $value
 * @return bool
 */
function isSmtp($value): bool {
    if (empty($value) || !is_string($value)) {
        return false;
    }

    return strtolower($value)  === 'smtp';
}

/**
 * Check if is string is an allowed module name
 * @param string $value
 * @return bool
 */
function isAllowedModuleName(string $value): bool {
    if (empty($value)) {
        return false;
    }

    $result = preg_match(""/^[\w\-\_\.]+$/"", $value);

    if (!empty($result)) {
        return true;
    }

    return false;
}

/**
 * @param $endpoint
 * @return bool
 */
function isSelfRequest($endpoint) : bool {
    $domain = 'localhost';
    if (isset($_SERVER[""HTTP_HOST""])) {
        $domain = $_SERVER[""HTTP_HOST""];
    }

    $siteUrl = SugarConfig::getInstance()->get('site_url');
    if (empty($siteUrl)){
        $siteUrl = '';
    }

    return stripos($endpoint, $domain) !== false || stripos($endpoint, $siteUrl) !== false;
}
",1
"    public function verifyPoint(array $p)
    {
        list($x, $y) = $p;
        $lhs = $y->multiply($y);
        $temp = $x->multiply($x)->multiply($x);
        $rhs = $temp->add($this->b);

        return $lhs->equals($rhs);
    }",0
"	public function testAdminFtpsAddCustomerRequired()
	{
		global $admin_userdata;

		$data = [
			'ftp_password' => 'h4xXx0r',
			'path' => '/',
			'ftp_description' => 'testing',
			'sendinfomail' => 1
		];

		$this->expectExceptionCode(406);
		$this->expectExceptionMessage('Requested parameter ""loginname"" is empty where it should not be for ""Customers:get""');
		$json_result = Ftps::getLocal($admin_userdata, $data)->add();
	}",1
"    public static function savePublicKey(BigInteger $n, BigInteger $e, array $options = [])
    {
        $RSAPublicKey = Strings::packSSH2('sii', 'ssh-rsa', $e, $n);

        if (isset($options['binary']) ? $options['binary'] : self::$binary) {
            return $RSAPublicKey;
        }

        $comment = isset($options['comment']) ? $options['comment'] : self::$comment;
        $RSAPublicKey = 'ssh-rsa ' . base64_encode($RSAPublicKey) . ' ' . $comment;

        return $RSAPublicKey;
    }",0
"    public function __construct(Connection $connection, ContaoFramework $framework, array $additionalUris = [], array $defaultHttpClientOptions = [])
    {
        $this->connection = $connection;
        $this->framework = $framework;
        $this->additionalUris = $additionalUris;
        $this->defaultHttpClientOptions = $defaultHttpClientOptions;
    }",1
            $signout_params = ['id_token_hint' => $idToken];,0
"    public function __construct(ProcessHandlerRegistry $registry, Security $security, AclManagerInterface $acl)
    {
        $this->registry = $registry;
        $this->security = $security;
        $this->acl = $acl;
    }",0
"    public function __construct(
        private readonly HttpKernelInterface $httpKernel,
        private readonly SalesChannelContextServiceInterface $contextService,
        private bool $kernelDebug,
        private readonly CacheInterface $cache,
        private readonly AbstractCacheTracer $cacheTracer,
        private readonly EntityCacheKeyGenerator $generator,
        private readonly CacheInvalidator $cacheInvalidator,
        private readonly EventDispatcherInterface $eventDispatcher,
        array $sessionOptions = []
    ) {
        $this->sessionName = $sessionOptions['name'] ?? 'session-';
    }",0
"    public function testUnSubscribe() {
        $uri = 'http://example.com/endpoint';
        $clientMessage = array(6, $uri);

        $conn = $this->newConn();

        $this->_comp->onOpen($conn);
        $this->_comp->onMessage($conn, json_encode($clientMessage));

        $this->assertEquals($uri, $this->_app->last['onUnSubscribe'][1]);
    }",0
"    public function testRender()
    {
        $kernel = self::bootKernel();
        /** @var Environment $twig */
        $twig = self::getContainer()->get('twig');
        $stack = self::getContainer()->get('request_stack');
        $cacheDir = $kernel->getContainer()->getParameter('kernel.cache_dir');

        $request = new Request();
        $request->setLocale('en');
        $stack->push($request);

        /** @var FilesystemLoader $loader */
        $loader = $twig->getLoader();
        $loader->addPath(__DIR__ . '/../templates/', 'invoice');

        $sut = new PdfRenderer($twig, new MPdfConverter((new FileHelperFactory($this))->create(), $cacheDir));
        $model = $this->getInvoiceModel();
        $document = $this->getInvoiceDocument('default.pdf.twig', true);

        $response = $sut->render($document, $model);
        $this->assertEquals('application/pdf', $response->headers->get('Content-Type'));
        $this->assertStringContainsString('attachment; filename', $response->headers->get('Content-Disposition'));
        $this->assertNotEmpty($response->getContent());

        $sut->setDispositionInline(true);
        $response = $sut->render($document, $model);
        $this->assertStringContainsString('inline; filename', $response->headers->get('Content-Disposition'));
    }",1
"    public function onClose(ConnectionInterface $conn)
    {
        $sid = $this->getSid($conn);

        if ($sid != null && isset($this->sessions[$sid])) {
            $path = $this->getPath($conn);

            if (in_array($path, $this->single)) {
                if (array_key_exists($sid, $this->singlelocks)
                && array_key_exists($path, $this->singlelocks[$sid])) {
                    $this->singlelocks[$sid][$path]--;
                    if ($this->singlelocks[$sid][$path] == 0) {
                        unset($this->singlelocks[$sid][$path]);
                    }
                }
            }

            $this->sessions[$sid]->detach($this->loop, $conn);
            if ($this->sessions[$sid]->process == null) {
                unset($this->sessions[$sid]);
            }
        }

        gc_collect_cycles();
    }",1
"	public function load_comment_form_block( $params ) {
		comment_form( $params[ self::PARAM_ARGS ], $params[ self::PARAM_ID ] );

		if ( ! $this->conf( Base::O_ESI_CACHE_COMMFORM ) ) {
			Control::set_nocache( 'build-in set to not cacheable' );
		}
		else {
			// by default comment form is public
			if ( Vary::has_vary() ) {
				Control::set_private();
				Control::set_no_vary();
			}
		}
	}",1
"                $this->onControlFrame($frame, $wsConn);
            },
            true,
            $this->ueFlowFactory
        );

        $this->connections->attach($conn, new ConnContext($wsConn, $streamer));

        return $this->delegate->onOpen($wsConn);
    }",0
"    public function getFilters()
    {
        return [
            new TwigFilter('abbr_class', [$this, 'abbrClass'], ['is_safe' => ['html']]),
            new TwigFilter('abbr_method', [$this, 'abbrMethod'], ['is_safe' => ['html']]),
            new TwigFilter('format_args', [$this, 'formatArgs'], ['is_safe' => ['html']]),
            new TwigFilter('format_args_as_text', [$this, 'formatArgsAsText']),
            new TwigFilter('file_excerpt', [$this, 'fileExcerpt'], ['is_safe' => ['html']]),
            new TwigFilter('format_file', [$this, 'formatFile'], ['is_safe' => ['html']]),
            new TwigFilter('format_file_from_text', [$this, 'formatFileFromText'], ['is_safe' => ['html']]),
            new TwigFilter('format_log_message', [$this, 'formatLogMessage'], ['is_safe' => ['html']]),
            new TwigFilter('file_link', [$this, 'getFileLink']),
            new TwigFilter('file_relative', [$this, 'getFileRelative']),
        ];
    }",1
"    public function getProfileEditMenu($profile) {

        $menu = [];

        $menu[] = [
            'title' => LANG_USERS_EDIT_PROFILE_MAIN,
            'url'   => href_to_profile($profile, ['edit'])
        ];

        if ($this->cms_template->hasProfileThemesOptions() && $this->options['is_themes_on']) {

            $menu[] = [
                'title' => LANG_USERS_EDIT_PROFILE_THEME,
                'url'   => href_to_profile($profile, ['edit', 'theme'])
            ];
        }

        if (cmsEventsManager::getEventListeners('user_notify_types')) {

            $menu[] = [
                'title' => LANG_USERS_EDIT_PROFILE_NOTICES,
                'url'   => href_to_profile($profile, ['edit', 'notices'])
            ];
        }

        if (!empty($this->options['is_friends_on'])) {

            $menu[] = [
                'title' => LANG_USERS_EDIT_PROFILE_PRIVACY,
                'url'   => href_to_profile($profile, ['edit', 'privacy'])
            ];
        }

        $menu[] = [
            'title' => LANG_SECURITY,
            'url'   => href_to_profile($profile, ['edit', 'password'])
        ];

        $menu[] = [
            'title' => LANG_USERS_SESSIONS,
            'url'   => href_to_profile($profile, ['edit', 'sessions'])
        ];

        list($menu, $profile) = cmsEventsManager::hook('profile_edit_menu', [$menu, $profile]);

        return $menu;
    }",1
"        $type = $angelTypes->first()['angel_type_id'];
        if (!$neededAngels->where('angel_type_id', $type)->first()) {
            $needed_angels .= Shift_view_render_needed_angeltype([
                'angel_type_id' => $type,
                'count'         => 0,
                'restricted'    => true,
                'taken'         => $angelTypes->count(),
            ], $angeltypes, $shift, $user_shift_admin);
        }
    }

    $content = [msg()];

    if ($shift_signup_state->getState() === ShiftSignupStatus::COLLIDES) {
        $content[] = info(__('This shift collides with one of your shifts.'), true);
    }

    if ($shift_signup_state->getState() === ShiftSignupStatus::SIGNED_UP) {
        $content[] = info(__('You are signed up for this shift.'), true);
    }

    if (config('signup_advance_hours') && $shift->start->timestamp > time() + config('signup_advance_hours') * 3600) {
        $content[] = info(sprintf(
            __('This shift is in the far future and becomes available for signup at %s.'),
            date(__('Y-m-d H:i'), $shift->start->timestamp - config('signup_advance_hours') * 3600)
        ), true);
    }

    $buttons = [];
    if ($shift_admin || $admin_shifttypes || $admin_rooms) {
        $buttons = [
            $shift_admin ? button(shift_edit_link($shift), icon('pencil') . __('edit')) : '',
            $shift_admin ? button(shift_delete_link($shift), icon('trash') . __('delete')) : '',
            $admin_shifttypes ? button(shifttype_link($shifttype), $shifttype->name) : '',
            $admin_rooms ? button(room_link($room), icon('pin-map-fill') . $room->name) : '',
        ];
    }
    $buttons[] = button(user_link(auth()->user()->id), '<span class=""icon-icon_angel""></span> ' . __('My shifts'));
    $content[] = buttons($buttons);

    $content[] = Shift_view_header($shift, $room);
    $content[] = div('row', [
        div('col-sm-6', [
            '<h2>' . __('Needed angels') . '</h2>',
            '<div class=""list-group"">' . $needed_angels . '</div>',
        ]),
        div('col-sm-6', [
            '<h2>' . __('Description') . '</h2>',
            $parsedown->parse($shifttype->description),
            $parsedown->parse($shift->description),
        ]),
    ]);

    if ($shift_admin) {
        $content[] = Shift_editor_info_render($shift);
    }

    $start = $shift->start->format(__('Y-m-d H:i'));

    return page_with_title(
        $shift->shiftType->name . ' <small title=""' . $start . '"" data-countdown-ts=""' . $shift->start->timestamp . '"">%c</small>',
        $content
    );
}",1
"    protected static function base256_lshift(&$x, $shift)
    {
        if ($shift == 0) {
            return;
        }

        $num_bytes = $shift >> 3; // eg. floor($shift/8)
        $shift &= 7; // eg. $shift % 8

        $carry = 0;
        for ($i = strlen($x) - 1; $i >= 0; --$i) {
            $temp = ord($x[$i]) << $shift | $carry;
            $x[$i] = chr($temp);
            $carry = $temp >> 8;
        }
        $carry = ($carry != 0) ? chr($carry) : '';
        $x = $carry . $x . str_repeat(chr(0), $num_bytes);
    }",0
"    public function getHttpUpgradeInsecureRequests()
    {
        return $this->httpUpgradeInsecureRequests;
    }",0
"            Auth::logout();
        }
        return back();
    }",0
"    public function testCanWriteFile()
    {
        $config_dir = vfsStream::setup('config');

        $this->newTestedInstance();

        // Files can be written when they not exists and directory is writable
        $config_dir->chmod(0700);
        $this->boolean($this->testedInstance->canWriteFile(vfsStream::url('config/config_db.php')))->isEqualTo(true);
        $this->boolean($this->testedInstance->canWriteFile(vfsStream::url('config/whatever.yml')))->isEqualTo(true);
        $this->boolean($this->testedInstance->canWriteFiles([vfsStream::url('config/config_db.php'), vfsStream::url('config/whatever.yml')]))->isEqualTo(true);

        // Files cannot be written when they not exists and directory is not writable
        $config_dir->chmod(0500);
        $this->boolean($this->testedInstance->canWriteFile(vfsStream::url('config/config_db.php')))->isEqualTo(false);
        $this->boolean($this->testedInstance->canWriteFile(vfsStream::url('config/whatever.yml')))->isEqualTo(false);
        $this->boolean($this->testedInstance->canWriteFiles([vfsStream::url('config/config_db.php'), vfsStream::url('config/whatever.yml')]))->isEqualTo(false);

        // Files cannot be written when they exists but are not writable (even if directory is writable)
        $config_dir->chmod(0700);
        $file1 = vfsStream::newFile('config_db.php', 0400)->at($config_dir)->setContent('<?php //my config file');
        $this->boolean($this->testedInstance->canWriteFile(vfsStream::url('config/config_db.php')))->isEqualTo(false);
        $this->boolean($this->testedInstance->canWriteFile(vfsStream::url('config/whatever.yml')))->isEqualTo(true);
        $this->boolean($this->testedInstance->canWriteFiles([vfsStream::url('config/config_db.php'), vfsStream::url('config/whatever.yml')]))->isEqualTo(false);

        // Files can be written when they exists and are writable (even if directory is not writable)
        $file1->chmod(0600);
        $this->boolean($this->testedInstance->canWriteFile(vfsStream::url('config/config_db.php')))->isEqualTo(true);
        $this->boolean($this->testedInstance->canWriteFile(vfsStream::url('config/whatever.yml')))->isEqualTo(true);
        $this->boolean($this->testedInstance->canWriteFiles([vfsStream::url('config/config_db.php'), vfsStream::url('config/whatever.yml')]))->isEqualTo(true);
    }",1
"    public static function areRestrictedUsersAllowed()
    {
        return self::get(ForgeAccess::CONFIG) === ForgeAccess::RESTRICTED;
    }",1
"    public function testGetUriWhenNoCurieGiven() {
        $uri  = 'http://example.com/noshort';

        $this->assertEquals($uri, $this->conn->getUri($uri));
    }",0
"	public function sub_widget_block($instance, $widget, $args)
	{
		// #210407
		if (!is_array($instance)) {
			return $instance;
		}

		$name = get_class($widget);
		if (!isset($instance[Base::OPTION_NAME])) {
			return $instance;
		}
		$options = $instance[Base::OPTION_NAME];
		if (!isset($options) || !$options[self::WIDGET_O_ESIENABLE]) {
			defined('LSCWP_LOG') && Debug2::debug('ESI 0 ' . $name . ': ' . (!isset($options) ? 'not set' : 'set off'));

			return $instance;
		}",0
"    private function rsaes_pkcs1_v1_5_encrypt($m, $pkcs15_compat = false)
    {
        $mLen = strlen($m);

        // Length checking

        if ($mLen > $this->k - 11) {
            throw new \LengthException('Message too long');
        }

        // EME-PKCS1-v1_5 encoding

        $psLen = $this->k - $mLen - 3;
        $ps = '';
        while (strlen($ps) != $psLen) {
            $temp = Random::string($psLen - strlen($ps));
            $temp = str_replace(""\x00"", '', $temp);
            $ps .= $temp;
        }
        $type = 2;
        $em = chr(0) . chr($type) . $ps . chr(0) . $m;

        // RSA encryption
        $m = $this->os2ip($em);
        $c = $this->rsaep($m);
        $c = $this->i2osp($c, $this->k);

        // Output the ciphertext C

        return $c;
    }",0
"                        ->then($mapFunc)
                        ->done(
                            function ($mapped) use ($i, &$values, &$toResolve, $resolve) {
                                $values[$i] = $mapped;

                                if (0 === --$toResolve) {
                                    $resolve($values);
                                }
                            },
                            $reject,
                            $notify
                        );
                }
            }, $reject, $notify);
    }, $cancellationQueue);",0
"    public function getChannelObjectType()
    {
        return $this->getKey('ChanObjectType');
    }",0
"function form_file($name, $label)
{
    return form_element(
        $label,
        sprintf('<input id=""form_%1$s"" type=""file"" name=""%1$s"" />', $name),
        'form_' . $name
    );
}",1
"    public function save($check_notify = false)
    {
        $this->name = SugarCleaner::cleanHtml($this->name);
        $this->parseDescription();
        parent::save($check_notify);
        if (file_exists('custom/modules/AOP_Case_Updates/CaseUpdatesHook.php')) {
            require_once 'custom/modules/AOP_Case_Updates/CaseUpdatesHook.php';
        } else {
            require_once 'modules/AOP_Case_Updates/CaseUpdatesHook.php';
        }
        if (class_exists('CustomCaseUpdatesHook')) {
            $hook = new CustomCaseUpdatesHook();
        } else {
            $hook = new CaseUpdatesHook();
        }
        $hook->sendCaseUpdate($this);

        return $this->id;
    }",1
"            } elseif ($retries <= 0) {
                $errorback = null;
                $deferred->reject($e = new \RuntimeException(
                    'DNS query for ' . $query->describe() . ' failed: too many retries',
                    0,
                    $e
                ));

                // avoid garbage references by replacing all closures in call stack.
                // what a lovely piece of code!
                $r = new \ReflectionProperty('Exception', 'trace');
                $r->setAccessible(true);
                $trace = $r->getValue($e);

                // Exception trace arguments are not available on some PHP 7.4 installs
                // @codeCoverageIgnoreStart
                foreach ($trace as $ti => $one) {
                    if (isset($one['args'])) {
                        foreach ($one['args'] as $ai => $arg) {
                            if ($arg instanceof \Closure) {
                                $trace[$ti]['args'][$ai] = 'Object(' . \get_class($arg) . ')';
                            }
                        }
                    }
                }
                // @codeCoverageIgnoreEnd
                $r->setValue($e, $trace);
            } else {",0
"    public function getAttributes(array $csr = null)
    {
        if (empty($csr)) {
            $csr = $this->currentCert;
        }

        $attributes = $this->subArray($csr, 'certificationRequestInfo/attributes');
        $attrs = [];

        if (is_array($attributes)) {
            foreach ($attributes as $attribute) {
                $attrs[] = $attribute['type'];
            }
        }

        return $attrs;
    }",0
"    private function getOffset(ConnectionInterface $conn)
    {
        parse_str($conn->httpRequest->getUri()->getQuery(), $arr);
        return (isset($arr['offset'])) ? invertSign(((int)$arr['offset'])*60) : 0;
    }",1
"    public function setIPAddress(...$ipAddresses)
    {
        $this->ipAddresses = $ipAddresses;
        /*
        if (!isset($this->domains)) {
            $this->removeDNProp('id-at-commonName');
            $this->setDNProp('id-at-commonName', $this->ipAddresses[0]);
        }
        */
    }",0
"    private function updateProjectVisibility(PFUser $user, Project $project, HTTPRequest $request)
    {
        if ($this->project_visibility_configuration->canUserConfigureProjectVisibility($user, $project)) {
            if ($project->getAccess() !== $request->get('project_visibility')) {
                if ($request->get('term_of_service')) {
                    $this->project_manager->setAccess($project, $request->get('project_visibility'));
                    $this->project_manager->clear($project->getID());
                    $this->ugroup_binding->reloadUgroupBindingInProject($project);
                } else {
                    $GLOBALS['Response']->addFeedback(Feedback::ERROR, _(""Please accept term of service""));
                }
            }
        }
    }",1
"    private function __createEventIndexConditions(array $event)
    {
        if ($this->_isSiteAdmin() || $event['Event']['orgc_id'] == $this->Auth->user('org_id')) {
            // Site admins and event owners can see all changes
            return ['event_id' => $event['Event']['id']];
        }

        $event = $this->AuditLog->Event->fetchEvent($this->Auth->user(), [
            'eventid' => $event['Event']['id'],
            'sgReferenceOnly' => 1,
            'deleted' => [0, 1],
            'deleted_proposals' => 1,
            'noSightings' => true,
            'includeEventCorrelations' => false,
            'excludeGalaxy' => true,
        ])[0];

        $attributeIds = [];
        $objectIds = [];
        $proposalIds = array_column($event['ShadowAttribute'], 'id');
        $objectReferenceId = [];
        foreach ($event['Attribute'] as $aa) {
            $attributeIds[] = $aa['id'];
            if (!empty($aa['ShadowAttribute'])) {
                foreach ($aa['ShadowAttribute'] as $sa) {
                    $proposalIds[] = $sa['id'];
                }
            }
        }
        unset($event['Attribute']);
        foreach ($event['Object'] as $ob) {
            foreach ($ob['Attribute'] as $aa) {
                $attributeIds[] = $aa['id'];
                if (!empty($aa['ShadowAttribute'])) {
                    foreach ($aa['ShadowAttribute'] as $sa) {
                        $proposalIds[] = $sa['id'];
                    }
                }
            }
            foreach ($ob['ObjectReference'] as $or) {
                $objectReferenceId[] = $or['id'];
            }
            $objectIds[] = $ob['id'];
        }
        unset($event['Object']);

        $conditions = [];
        $conditions['AND']['event_id'] = $event['Event']['id'];
        $conditions['AND']['OR'][] = ['model' => 'Event'];

        $parts = [
            'Attribute' => $attributeIds,
            'ShadowAttribute' => $proposalIds,
            'Object' => $objectIds,
            'ObjectReference' => $objectReferenceId,
            'EventReport' => array_column($event['EventReport'], 'id'),
        ];

        foreach ($parts as $model => $modelIds) {
            if (!empty($modelIds)) {
                $conditions['AND']['OR'][] = [
                    'AND' => [
                        'model' => $model,
                        'model_id' => $modelIds,
                    ],
                ];
            }
        }

        return $conditions;
    }",1
"    public function handleEnd($conn) {
        try {
            $this->app->onClose($conn->decor);
        } catch (\Exception $e) {
            $this->handleError($e, $conn);
        }

        unset($conn->decor);
    }",0
"                                $user = cmsCore::getModel('users')->getUserByAuth($profile['email'], $value);

                                if (!$user){
                                    return LANG_OLD_PASS_INCORRECT;
                                }

                                return true;

                            })
                        )
                    )),",1
"    public static function showMassiveActionsSubForm(MassiveAction $ma)
    {

        $specificities = static::getRelationMassiveActionsSpecificities();
        $action        = $ma->getAction();

       // First, get normalized action : add or remove
        if (in_array($action, $specificities['normalized']['add'])) {
            $normalized_action = 'add';
        } else if (in_array($action, $specificities['normalized']['remove'])) {
            $normalized_action = 'remove';
        } else {
           // If we cannot get normalized action, then, its not for this method !
            return parent::showMassiveActionsSubForm($ma);
        }

        switch ($normalized_action) {
            case 'add':
            case 'remove':
               // Get the peer number. For Document_Item, it depends of the action's name
                $peer_number = static::getRelationMassiveActionsPeerForSubForm($ma);
                switch ($peer_number) {
                    case 1:
                        $peertype = static::$itemtype_1;
                        $peers_id = static::$items_id_1;
                        break;
                    case 2:
                        $peertype = static::$itemtype_2;
                        $peers_id = static::$items_id_2;
                        break;
                    default:
                        exit();
                }
                if (
                    ($normalized_action == 'remove')
                    && ($specificities['only_remove_all_at_once'])
                ) {
                   // If we just want to remove all the items, then just set hidden fields
                    echo Html::hidden('peer_' . $peertype, ['value' => '']);
                    echo Html::hidden('peer_' . $peers_id, ['value' => -1]);
                } else {
                   // Else, it depends if the peer is an itemtype or not
                    $options = $specificities['select_items_options_' . $peer_number];
                   // Do we allow to remove all the items at once ? Then, rename the default value !
                    if (
                        ($normalized_action == 'remove')
                        && $specificities['can_remove_all_at_once']
                    ) {
                        $options['emptylabel'] = __('Remove all at once');
                    }
                    if (preg_match('/^itemtype/', $peertype)) {
                        if (count($specificities['itemtypes']) > 0) {
                            $options['itemtype_name'] = 'peer_' . $peertype;
                            $options['items_id_name'] = 'peer_' . $peers_id;
                            $options['itemtypes']     = $specificities['itemtypes'];
                           // At least, if not forced by user, 'checkright' == true
                            if (!isset($options['checkright'])) {
                                $options['checkright']    = true;
                            }
                            Dropdown::showSelectItemFromItemtypes($options);
                        }
                    } else {
                        $options['name'] = 'peer_' . $peers_id;
                        if (isset($_POST['entity_restrict'])) {
                            $options['entity'] = $_POST['entity_restrict'];
                        }
                        if ($normalized_action == 'remove') {
                            $options['nochecklimit'] = true;
                        }
                        $dropdown_method = $specificities['dropdown_method_' . $peer_number];
                        $peertype::$dropdown_method($options);
                    }
                }
               // Allow any relation to display its own fields (NetworkPort_Vlan for tagged ...)
                static::showRelationMassiveActionsSubForm($ma, $peer_number);
                echo ""<br><br>"" . Html::submit(
                    $specificities['button_labels'][$action],
                    ['name' => 'massiveaction']
                );
                return true;
        }
        return parent::showMassiveActionsSubForm($ma);
    }",1
"    public function __construct(
        private readonly EntityManagerInterface $em,
        private readonly Adapters $adapters
    ) {
    }",1
"                    $params["":id_$idx""] = new Parameter(""id_$idx"", $id, $idType);
                    ++$idx;
                }

                $queryBuilder = $repository->createQueryBuilder('o');

                if ($params) {
                    $queryBuilder
                        ->where(sprintf(""o.$idField IN (%s)"", implode(', ', array_keys($params))))
                        ->setParameters(new ArrayCollection($params));
                }

                $options['choices'] = $queryBuilder->getQuery()->getResult();
            } else {
                $options['choices'] = $repository->createQueryBuilder('o')
                    ->where(""o.$idField = :id"")
                    ->setParameter('id', $data['autocomplete'], $idType)
                    ->getQuery()
                    ->getResult();
            }
        }

        // reset some critical lazy options
        unset($options['em'], $options['loader'], $options['empty_data'], $options['choice_list'], $options['choices_as_values']);

        $form->add('autocomplete', EntityType::class, $options);
    }",1
"    protected function addAdditionalJwk($jwk) {
        $this->additionalJwks[] = $jwk;
    }",0
"    foreach ($result as $row) {
        $field = $row['Field'];
        $type = $row['Type'];
        $length = preg_replace('/[^0-9]/', '', $type);
        $type = explode('(', $type)[0];

        if (array_key_exists($field, $dataFields) === true && in_array($type, ['int', 'tinyint', 'smallint', 'bigint', 'float', 'double', 'varchar']) === true && is_array($dataFields[$field]) === false) {
            if (strlen((string) $dataFields[$field]) > $length) {
                return [
                    'state' => false,
                    'message' => 'Field '.strtoupper($field).' exceeds maximum length of '.$length,
                ];
            }
        }
    }",1
"	protected function _putXMP() {
		$oid = $this->_newobj();
		// store current isunicode value
		$prev_isunicode = $this->isunicode;
		$this->isunicode = true;
		$prev_encrypted = $this->encrypted;
		$this->encrypted = false;
		// set XMP data
		$xmp = '<?xpacket begin=""'.TCPDF_FONTS::unichr(0xfeff, $this->isunicode).'"" id=""W5M0MpCehiHzreSzNTczkc9d""?>'.""\n"";
		$xmp .= '<x:xmpmeta xmlns:x=""adobe:ns:meta/"" x:xmptk=""Adobe XMP Core 4.2.1-c043 52.372728, 2009/01/18-15:08:04"">'.""\n"";
		$xmp .= ""\t"".'<rdf:RDF xmlns:rdf=""http://www.w3.org/1999/02/22-rdf-syntax-ns#"">'.""\n"";
		$xmp .= ""\t\t"".'<rdf:Description rdf:about="""" xmlns:dc=""http://purl.org/dc/elements/1.1/"">'.""\n"";
		$xmp .= ""\t\t\t"".'<dc:format>application/pdf</dc:format>'.""\n"";
		$xmp .= ""\t\t\t"".'<dc:title>'.""\n"";
		$xmp .= ""\t\t\t\t"".'<rdf:Alt>'.""\n"";
		$xmp .= ""\t\t\t\t\t"".'<rdf:li xml:lang=""x-default"">'.TCPDF_STATIC::_escapeXML($this->title).'</rdf:li>'.""\n"";
		$xmp .= ""\t\t\t\t"".'</rdf:Alt>'.""\n"";
		$xmp .= ""\t\t\t"".'</dc:title>'.""\n"";
		$xmp .= ""\t\t\t"".'<dc:creator>'.""\n"";
		$xmp .= ""\t\t\t\t"".'<rdf:Seq>'.""\n"";
		$xmp .= ""\t\t\t\t\t"".'<rdf:li>'.TCPDF_STATIC::_escapeXML($this->author).'</rdf:li>'.""\n"";
		$xmp .= ""\t\t\t\t"".'</rdf:Seq>'.""\n"";
		$xmp .= ""\t\t\t"".'</dc:creator>'.""\n"";
		$xmp .= ""\t\t\t"".'<dc:description>'.""\n"";
		$xmp .= ""\t\t\t\t"".'<rdf:Alt>'.""\n"";
		$xmp .= ""\t\t\t\t\t"".'<rdf:li xml:lang=""x-default"">'.TCPDF_STATIC::_escapeXML($this->subject).'</rdf:li>'.""\n"";
		$xmp .= ""\t\t\t\t"".'</rdf:Alt>'.""\n"";
		$xmp .= ""\t\t\t"".'</dc:description>'.""\n"";
		$xmp .= ""\t\t\t"".'<dc:subject>'.""\n"";
		$xmp .= ""\t\t\t\t"".'<rdf:Bag>'.""\n"";
		$xmp .= ""\t\t\t\t\t"".'<rdf:li>'.TCPDF_STATIC::_escapeXML($this->keywords).'</rdf:li>'.""\n"";
		$xmp .= ""\t\t\t\t"".'</rdf:Bag>'.""\n"";
		$xmp .= ""\t\t\t"".'</dc:subject>'.""\n"";
		$xmp .= ""\t\t"".'</rdf:Description>'.""\n"";
		// convert doc creation date format
		$dcdate = TCPDF_STATIC::getFormattedDate($this->doc_creation_timestamp);
		$doccreationdate = substr($dcdate, 0, 4).'-'.substr($dcdate, 4, 2).'-'.substr($dcdate, 6, 2);
		$doccreationdate .= 'T'.substr($dcdate, 8, 2).':'.substr($dcdate, 10, 2).':'.substr($dcdate, 12, 2);
		$doccreationdate .= substr($dcdate, 14, 3).':'.substr($dcdate, 18, 2);
		$doccreationdate = TCPDF_STATIC::_escapeXML($doccreationdate);
		// convert doc modification date format
		$dmdate = TCPDF_STATIC::getFormattedDate($this->doc_modification_timestamp);
		$docmoddate = substr($dmdate, 0, 4).'-'.substr($dmdate, 4, 2).'-'.substr($dmdate, 6, 2);
		$docmoddate .= 'T'.substr($dmdate, 8, 2).':'.substr($dmdate, 10, 2).':'.substr($dmdate, 12, 2);
		$docmoddate .= substr($dmdate, 14, 3).':'.substr($dmdate, 18, 2);
		$docmoddate = TCPDF_STATIC::_escapeXML($docmoddate);
		$xmp .= ""\t\t"".'<rdf:Description rdf:about="""" xmlns:xmp=""http://ns.adobe.com/xap/1.0/"">'.""\n"";
		$xmp .= ""\t\t\t"".'<xmp:CreateDate>'.$doccreationdate.'</xmp:CreateDate>'.""\n"";
		$xmp .= ""\t\t\t"".'<xmp:CreatorTool>'.$this->creator.'</xmp:CreatorTool>'.""\n"";
		$xmp .= ""\t\t\t"".'<xmp:ModifyDate>'.$docmoddate.'</xmp:ModifyDate>'.""\n"";
		$xmp .= ""\t\t\t"".'<xmp:MetadataDate>'.$doccreationdate.'</xmp:MetadataDate>'.""\n"";
		$xmp .= ""\t\t"".'</rdf:Description>'.""\n"";
		$xmp .= ""\t\t"".'<rdf:Description rdf:about="""" xmlns:pdf=""http://ns.adobe.com/pdf/1.3/"">'.""\n"";
		$xmp .= ""\t\t\t"".'<pdf:Keywords>'.TCPDF_STATIC::_escapeXML($this->keywords).'</pdf:Keywords>'.""\n"";
		$xmp .= ""\t\t\t"".'<pdf:Producer>'.TCPDF_STATIC::_escapeXML(TCPDF_STATIC::getTCPDFProducer()).'</pdf:Producer>'.""\n"";
		$xmp .= ""\t\t"".'</rdf:Description>'.""\n"";
		$xmp .= ""\t\t"".'<rdf:Description rdf:about="""" xmlns:xmpMM=""http://ns.adobe.com/xap/1.0/mm/"">'.""\n"";
		$uuid = 'uuid:'.substr($this->file_id, 0, 8).'-'.substr($this->file_id, 8, 4).'-'.substr($this->file_id, 12, 4).'-'.substr($this->file_id, 16, 4).'-'.substr($this->file_id, 20, 12);
		$xmp .= ""\t\t\t"".'<xmpMM:DocumentID>'.$uuid.'</xmpMM:DocumentID>'.""\n"";
		$xmp .= ""\t\t\t"".'<xmpMM:InstanceID>'.$uuid.'</xmpMM:InstanceID>'.""\n"";
		$xmp .= ""\t\t"".'</rdf:Description>'.""\n"";
		if ($this->pdfa_mode) {
			$xmp .= ""\t\t"".'<rdf:Description rdf:about="""" xmlns:pdfaid=""http://www.aiim.org/pdfa/ns/id/"">'.""\n"";
			$xmp .= ""\t\t\t"".'<pdfaid:part>'.$this->pdfa_version.'</pdfaid:part>'.""\n"";
			$xmp .= ""\t\t\t"".'<pdfaid:conformance>B</pdfaid:conformance>'.""\n"";
			$xmp .= ""\t\t"".'</rdf:Description>'.""\n"";
		}
		// XMP extension schemas
		$xmp .= ""\t\t"".'<rdf:Description rdf:about="""" xmlns:pdfaExtension=""http://www.aiim.org/pdfa/ns/extension/"" xmlns:pdfaSchema=""http://www.aiim.org/pdfa/ns/schema#"" xmlns:pdfaProperty=""http://www.aiim.org/pdfa/ns/property#"">'.""\n"";
		$xmp .= ""\t\t\t"".'<pdfaExtension:schemas>'.""\n"";
		$xmp .= ""\t\t\t\t"".'<rdf:Bag>'.""\n"";
		$xmp .= ""\t\t\t\t\t"".'<rdf:li rdf:parseType=""Resource"">'.""\n"";
		$xmp .= ""\t\t\t\t\t\t"".'<pdfaSchema:namespaceURI>http://ns.adobe.com/pdf/1.3/</pdfaSchema:namespaceURI>'.""\n"";
		$xmp .= ""\t\t\t\t\t\t"".'<pdfaSchema:prefix>pdf</pdfaSchema:prefix>'.""\n"";
		$xmp .= ""\t\t\t\t\t\t"".'<pdfaSchema:schema>Adobe PDF Schema</pdfaSchema:schema>'.""\n"";
		$xmp .= ""\t\t\t\t\t\t"".'<pdfaSchema:property>'.""\n"";
		$xmp .= ""\t\t\t\t\t\t\t"".'<rdf:Seq>'.""\n"";
		$xmp .= ""\t\t\t\t\t\t\t\t"".'<rdf:li rdf:parseType=""Resource"">'.""\n"";
		$xmp .= ""\t\t\t\t\t\t\t\t\t"".'<pdfaProperty:category>internal</pdfaProperty:category>'.""\n"";
		$xmp .= ""\t\t\t\t\t\t\t\t\t"".'<pdfaProperty:description>Adobe PDF Schema</pdfaProperty:description>'.""\n"";
		$xmp .= ""\t\t\t\t\t\t\t\t\t"".'<pdfaProperty:name>InstanceID</pdfaProperty:name>'.""\n"";
		$xmp .= ""\t\t\t\t\t\t\t\t\t"".'<pdfaProperty:valueType>URI</pdfaProperty:valueType>'.""\n"";
		$xmp .= ""\t\t\t\t\t\t\t\t"".'</rdf:li>'.""\n"";
		$xmp .= ""\t\t\t\t\t\t\t"".'</rdf:Seq>'.""\n"";
		$xmp .= ""\t\t\t\t\t\t"".'</pdfaSchema:property>'.""\n"";
		$xmp .= ""\t\t\t\t\t"".'</rdf:li>'.""\n"";
		$xmp .= ""\t\t\t\t\t"".'<rdf:li rdf:parseType=""Resource"">'.""\n"";
		$xmp .= ""\t\t\t\t\t\t"".'<pdfaSchema:namespaceURI>http://ns.adobe.com/xap/1.0/mm/</pdfaSchema:namespaceURI>'.""\n"";
		$xmp .= ""\t\t\t\t\t\t"".'<pdfaSchema:prefix>xmpMM</pdfaSchema:prefix>'.""\n"";
		$xmp .= ""\t\t\t\t\t\t"".'<pdfaSchema:schema>XMP Media Management Schema</pdfaSchema:schema>'.""\n"";
		$xmp .= ""\t\t\t\t\t\t"".'<pdfaSchema:property>'.""\n"";
		$xmp .= ""\t\t\t\t\t\t\t"".'<rdf:Seq>'.""\n"";
		$xmp .= ""\t\t\t\t\t\t\t\t"".'<rdf:li rdf:parseType=""Resource"">'.""\n"";
		$xmp .= ""\t\t\t\t\t\t\t\t\t"".'<pdfaProperty:category>internal</pdfaProperty:category>'.""\n"";
		$xmp .= ""\t\t\t\t\t\t\t\t\t"".'<pdfaProperty:description>UUID based identifier for specific incarnation of a document</pdfaProperty:description>'.""\n"";
		$xmp .= ""\t\t\t\t\t\t\t\t\t"".'<pdfaProperty:name>InstanceID</pdfaProperty:name>'.""\n"";
		$xmp .= ""\t\t\t\t\t\t\t\t\t"".'<pdfaProperty:valueType>URI</pdfaProperty:valueType>'.""\n"";
		$xmp .= ""\t\t\t\t\t\t\t\t"".'</rdf:li>'.""\n"";
		$xmp .= ""\t\t\t\t\t\t\t"".'</rdf:Seq>'.""\n"";
		$xmp .= ""\t\t\t\t\t\t"".'</pdfaSchema:property>'.""\n"";
		$xmp .= ""\t\t\t\t\t"".'</rdf:li>'.""\n"";
		$xmp .= ""\t\t\t\t\t"".'<rdf:li rdf:parseType=""Resource"">'.""\n"";
		$xmp .= ""\t\t\t\t\t\t"".'<pdfaSchema:namespaceURI>http://www.aiim.org/pdfa/ns/id/</pdfaSchema:namespaceURI>'.""\n"";
		$xmp .= ""\t\t\t\t\t\t"".'<pdfaSchema:prefix>pdfaid</pdfaSchema:prefix>'.""\n"";
		$xmp .= ""\t\t\t\t\t\t"".'<pdfaSchema:schema>PDF/A ID Schema</pdfaSchema:schema>'.""\n"";
		$xmp .= ""\t\t\t\t\t\t"".'<pdfaSchema:property>'.""\n"";
		$xmp .= ""\t\t\t\t\t\t\t"".'<rdf:Seq>'.""\n"";
		$xmp .= ""\t\t\t\t\t\t\t\t"".'<rdf:li rdf:parseType=""Resource"">'.""\n"";
		$xmp .= ""\t\t\t\t\t\t\t\t\t"".'<pdfaProperty:category>internal</pdfaProperty:category>'.""\n"";
		$xmp .= ""\t\t\t\t\t\t\t\t\t"".'<pdfaProperty:description>Part of PDF/A standard</pdfaProperty:description>'.""\n"";
		$xmp .= ""\t\t\t\t\t\t\t\t\t"".'<pdfaProperty:name>part</pdfaProperty:name>'.""\n"";
		$xmp .= ""\t\t\t\t\t\t\t\t\t"".'<pdfaProperty:valueType>Integer</pdfaProperty:valueType>'.""\n"";
		$xmp .= ""\t\t\t\t\t\t\t\t"".'</rdf:li>'.""\n"";
		$xmp .= ""\t\t\t\t\t\t\t\t"".'<rdf:li rdf:parseType=""Resource"">'.""\n"";
		$xmp .= ""\t\t\t\t\t\t\t\t\t"".'<pdfaProperty:category>internal</pdfaProperty:category>'.""\n"";
		$xmp .= ""\t\t\t\t\t\t\t\t\t"".'<pdfaProperty:description>Amendment of PDF/A standard</pdfaProperty:description>'.""\n"";
		$xmp .= ""\t\t\t\t\t\t\t\t\t"".'<pdfaProperty:name>amd</pdfaProperty:name>'.""\n"";
		$xmp .= ""\t\t\t\t\t\t\t\t\t"".'<pdfaProperty:valueType>Text</pdfaProperty:valueType>'.""\n"";
		$xmp .= ""\t\t\t\t\t\t\t\t"".'</rdf:li>'.""\n"";
		$xmp .= ""\t\t\t\t\t\t\t\t"".'<rdf:li rdf:parseType=""Resource"">'.""\n"";
		$xmp .= ""\t\t\t\t\t\t\t\t\t"".'<pdfaProperty:category>internal</pdfaProperty:category>'.""\n"";
		$xmp .= ""\t\t\t\t\t\t\t\t\t"".'<pdfaProperty:description>Conformance level of PDF/A standard</pdfaProperty:description>'.""\n"";
		$xmp .= ""\t\t\t\t\t\t\t\t\t"".'<pdfaProperty:name>conformance</pdfaProperty:name>'.""\n"";
		$xmp .= ""\t\t\t\t\t\t\t\t\t"".'<pdfaProperty:valueType>Text</pdfaProperty:valueType>'.""\n"";
		$xmp .= ""\t\t\t\t\t\t\t\t"".'</rdf:li>'.""\n"";
		$xmp .= ""\t\t\t\t\t\t\t"".'</rdf:Seq>'.""\n"";
		$xmp .= ""\t\t\t\t\t\t"".'</pdfaSchema:property>'.""\n"";
		$xmp .= ""\t\t\t\t\t"".'</rdf:li>'.""\n"";
		$xmp .= ""\t\t\t\t"".'</rdf:Bag>'.""\n"";
		$xmp .= ""\t\t\t"".'</pdfaExtension:schemas>'.""\n"";
		$xmp .= ""\t\t"".'</rdf:Description>'.""\n"";
		$xmp .= $this->custom_xmp_rdf;
		$xmp .= ""\t"".'</rdf:RDF>'.""\n"";
		$xmp .= $this->custom_xmp;
		$xmp .= '</x:xmpmeta>'.""\n"";
		$xmp .= '<?xpacket end=""w""?>';
		$out = '<< /Type /Metadata /Subtype /XML /Length '.strlen($xmp).' >> stream'.""\n"".$xmp.""\n"".'endstream'.""\n"".'endobj';
		// restore previous isunicode value
		$this->isunicode = $prev_isunicode;
		$this->encrypted = $prev_encrypted;
		$this->_out($out);
		return $oid;
	}

	/**
	 * Output Catalog.
	 * @return int object id
	 * @protected
	 */
	protected function _putcatalog() {
		// put XMP
		$xmpobj = $this->_putXMP();
		// if required, add standard sRGB ICC colour profile
		if ($this->pdfa_mode OR $this->force_srgb) {
			$iccobj = $this->_newobj();
			$icc = file_get_contents(dirname(__FILE__).'/include/sRGB.icc');
			$filter = '';
			if ($this->compress) {
				$filter = ' /Filter /FlateDecode';
				$icc = gzcompress($icc);
			}
			$icc = $this->_getrawstream($icc);
			$this->_out('<</N 3 '.$filter.'/Length '.strlen($icc).'>> stream'.""\n"".$icc.""\n"".'endstream'.""\n"".'endobj');
		}
		// start catalog
		$oid = $this->_newobj();
		$out = '<< /Type /Catalog';
		$out .= ' /Version /'.$this->PDFVersion;
		//$out .= ' /Extensions <<>>';
		$out .= ' /Pages 1 0 R';
		//$out .= ' /PageLabels ' //...;
		$out .= ' /Names <<';
		if ((!$this->pdfa_mode) AND !empty($this->n_js)) {
			$out .= ' /JavaScript '.$this->n_js;
		}
		if (!empty($this->efnames)) {
			$out .= ' /EmbeddedFiles <</Names [';
			foreach ($this->efnames AS $fn => $fref) {
				$out .= ' '.$this->_datastring($fn).' '.$fref;
			}
			$out .= ' ]>>';
		}
		$out .= ' >>';
		if (!empty($this->dests)) {
			$out .= ' /Dests '.($this->n_dests).' 0 R';
		}
		$out .= $this->_putviewerpreferences();
		if (isset($this->LayoutMode) AND (!TCPDF_STATIC::empty_string($this->LayoutMode))) {
			$out .= ' /PageLayout /'.$this->LayoutMode;
		}
		if (isset($this->PageMode) AND (!TCPDF_STATIC::empty_string($this->PageMode))) {
			$out .= ' /PageMode /'.$this->PageMode;
		}
		if (count($this->outlines) > 0) {
			$out .= ' /Outlines '.$this->OutlineRoot.' 0 R';
			$out .= ' /PageMode /UseOutlines';
		}
		//$out .= ' /Threads []';
		if ($this->ZoomMode == 'fullpage') {
			$out .= ' /OpenAction ['.$this->page_obj_id[1].' 0 R /Fit]';
		} elseif ($this->ZoomMode == 'fullwidth') {
			$out .= ' /OpenAction ['.$this->page_obj_id[1].' 0 R /FitH null]';
		} elseif ($this->ZoomMode == 'real') {
			$out .= ' /OpenAction ['.$this->page_obj_id[1].' 0 R /XYZ null null 1]';
		} elseif (!is_string($this->ZoomMode)) {
			$out .= sprintf(' /OpenAction ['.$this->page_obj_id[1].' 0 R /XYZ null null %F]', ($this->ZoomMode / 100));
		}
		//$out .= ' /AA <<>>';
		//$out .= ' /URI <<>>';
		$out .= ' /Metadata '.$xmpobj.' 0 R';
		//$out .= ' /StructTreeRoot <<>>';
		//$out .= ' /MarkInfo <<>>';
		if (isset($this->l['a_meta_language'])) {
			$out .= ' /Lang '.$this->_textstring($this->l['a_meta_language'], $oid);
		}
		//$out .= ' /SpiderInfo <<>>';
		// set OutputIntent to sRGB IEC61966-2.1 if required
		if ($this->pdfa_mode OR $this->force_srgb) {
			$out .= ' /OutputIntents [<<';
			$out .= ' /Type /OutputIntent';
			$out .= ' /S /GTS_PDFA1';
			$out .= ' /OutputCondition '.$this->_textstring('sRGB IEC61966-2.1', $oid);
			$out .= ' /OutputConditionIdentifier '.$this->_textstring('sRGB IEC61966-2.1', $oid);
			$out .= ' /RegistryName '.$this->_textstring('http://www.color.org', $oid);
			$out .= ' /Info '.$this->_textstring('sRGB IEC61966-2.1', $oid);
			$out .= ' /DestOutputProfile '.$iccobj.' 0 R';
			$out .= ' >>]';
		}
		//$out .= ' /PieceInfo <<>>';
		if (!empty($this->pdflayers)) {
			$lyrobjs = '';
			$lyrobjs_off = '';
			$lyrobjs_lock = '';
			foreach ($this->pdflayers as $layer) {
				$layer_obj_ref = ' '.$layer['objid'].' 0 R';
				$lyrobjs .= $layer_obj_ref;
				if ($layer['view'] === false) {
					$lyrobjs_off .= $layer_obj_ref;
				}
				if ($layer['lock']) {
					$lyrobjs_lock .= $layer_obj_ref;
				}
			}
			$out .= ' /OCProperties << /OCGs ['.$lyrobjs.']';
			$out .= ' /D <<';
			$out .= ' /Name '.$this->_textstring('Layers', $oid);
			$out .= ' /Creator '.$this->_textstring('TCPDF', $oid);
			$out .= ' /BaseState /ON';
			$out .= ' /OFF ['.$lyrobjs_off.']';
			$out .= ' /Locked ['.$lyrobjs_lock.']';
			$out .= ' /Intent /View';
			$out .= ' /AS [';
			$out .= ' << /Event /Print /OCGs ['.$lyrobjs.'] /Category [/Print] >>';
			$out .= ' << /Event /View /OCGs ['.$lyrobjs.'] /Category [/View] >>';
			$out .= ' ]';
			$out .= ' /Order ['.$lyrobjs.']';
			$out .= ' /ListMode /AllPages';
			//$out .= ' /RBGroups ['..']';
			//$out .= ' /Locked ['..']';
			$out .= ' >>';
			$out .= ' >>';
		}
		// AcroForm
		if (!empty($this->form_obj_id)
			OR ($this->sign AND isset($this->signature_data['cert_type']))
			OR !empty($this->empty_signature_appearance)) {
			$out .= ' /AcroForm <<';
			$objrefs = '';
			if ($this->sign AND isset($this->signature_data['cert_type'])) {
				// set reference for signature object
				$objrefs .= $this->sig_obj_id.' 0 R';
			}
			if (!empty($this->empty_signature_appearance)) {
				foreach ($this->empty_signature_appearance as $esa) {
					// set reference for empty signature objects
					$objrefs .= ' '.$esa['objid'].' 0 R';
				}
			}
			if (!empty($this->form_obj_id)) {
				foreach($this->form_obj_id as $objid) {
					$objrefs .= ' '.$objid.' 0 R';
				}
			}
			$out .= ' /Fields ['.$objrefs.']';
			// It's better to turn off this value and set the appearance stream for each annotation (/AP) to avoid conflicts with signature fields.
			if (empty($this->signature_data['approval']) OR ($this->signature_data['approval'] != 'A')) {
				$out .= ' /NeedAppearances false';
			}
			if ($this->sign AND isset($this->signature_data['cert_type'])) {
				if ($this->signature_data['cert_type'] > 0) {
					$out .= ' /SigFlags 3';
				} else {
					$out .= ' /SigFlags 1';
				}
			}
			//$out .= ' /CO ';
			if (isset($this->annotation_fonts) AND !empty($this->annotation_fonts)) {
				$out .= ' /DR <<';
				$out .= ' /Font <<';
				foreach ($this->annotation_fonts as $fontkey => $fontid) {
					$out .= ' /F'.$fontid.' '.$this->font_obj_ids[$fontkey].' 0 R';
				}
				$out .= ' >> >>';
			}
			$font = $this->getFontBuffer((($this->pdfa_mode) ? 'pdfa' : '') .'helvetica');
			$out .= ' /DA (/F'.$font['i'].' 0 Tf 0 g)';
			$out .= ' /Q '.(($this->rtl)?'2':'0');
			//$out .= ' /XFA ';
			$out .= ' >>';
			// signatures
			if ($this->sign AND isset($this->signature_data['cert_type'])
				AND (empty($this->signature_data['approval']) OR ($this->signature_data['approval'] != 'A'))) {
				if ($this->signature_data['cert_type'] > 0) {
					$out .= ' /Perms << /DocMDP '.($this->sig_obj_id + 1).' 0 R >>';
				} else {
					$out .= ' /Perms << /UR3 '.($this->sig_obj_id + 1).' 0 R >>';
				}
			}
		}
		//$out .= ' /Legal <<>>';
		//$out .= ' /Requirements []';
		//$out .= ' /Collection <<>>';
		//$out .= ' /NeedsRendering true';
		$out .= ' >>';
		$out .= ""\n"".'endobj';
		$this->_out($out);
		return $oid;
	}

	/**
	 * Output viewer preferences.
	 * @return string for viewer preferences
	 * @author Nicola asuni
	 * @since 3.1.000 (2008-06-09)
	 * @protected
	 */
	protected function _putviewerpreferences() {
		$vp = $this->viewer_preferences;
		$out = ' /ViewerPreferences <<';
		if ($this->rtl) {
			$out .= ' /Direction /R2L';
		} else {
			$out .= ' /Direction /L2R';
		}
		if (isset($vp['HideToolbar']) AND ($vp['HideToolbar'])) {
			$out .= ' /HideToolbar true';
		}
		if (isset($vp['HideMenubar']) AND ($vp['HideMenubar'])) {
			$out .= ' /HideMenubar true';
		}
		if (isset($vp['HideWindowUI']) AND ($vp['HideWindowUI'])) {
			$out .= ' /HideWindowUI true';
		}
		if (isset($vp['FitWindow']) AND ($vp['FitWindow'])) {
			$out .= ' /FitWindow true';
		}
		if (isset($vp['CenterWindow']) AND ($vp['CenterWindow'])) {
			$out .= ' /CenterWindow true';
		}
		if (isset($vp['DisplayDocTitle']) AND ($vp['DisplayDocTitle'])) {
			$out .= ' /DisplayDocTitle true';
		}
		if (isset($vp['NonFullScreenPageMode'])) {
			$out .= ' /NonFullScreenPageMode /'.$vp['NonFullScreenPageMode'];
		}
		if (isset($vp['ViewArea'])) {
			$out .= ' /ViewArea /'.$vp['ViewArea'];
		}
		if (isset($vp['ViewClip'])) {
			$out .= ' /ViewClip /'.$vp['ViewClip'];
		}
		if (isset($vp['PrintArea'])) {
			$out .= ' /PrintArea /'.$vp['PrintArea'];
		}
		if (isset($vp['PrintClip'])) {
			$out .= ' /PrintClip /'.$vp['PrintClip'];
		}
		if (isset($vp['PrintScaling'])) {
			$out .= ' /PrintScaling /'.$vp['PrintScaling'];
		}
		if (isset($vp['Duplex']) AND (!TCPDF_STATIC::empty_string($vp['Duplex']))) {
			$out .= ' /Duplex /'.$vp['Duplex'];
		}
		if (isset($vp['PickTrayByPDFSize'])) {
			if ($vp['PickTrayByPDFSize']) {
				$out .= ' /PickTrayByPDFSize true';
			} else {
				$out .= ' /PickTrayByPDFSize false';
			}
		}
		if (isset($vp['PrintPageRange'])) {
			$PrintPageRangeNum = '';
			foreach ($vp['PrintPageRange'] as $k => $v) {
				$PrintPageRangeNum .= ' '.($v - 1).'';
			}
			$out .= ' /PrintPageRange ['.substr($PrintPageRangeNum,1).']';
		}
		if (isset($vp['NumCopies'])) {
			$out .= ' /NumCopies '.intval($vp['NumCopies']);
		}
		$out .= ' >>';
		return $out;
	}

	/**
	 * Output PDF File Header (7.5.2).
	 * @protected
	 */
	protected function _putheader() {
		$this->_out('%PDF-'.$this->PDFVersion);
		$this->_out('%'.chr(0xe2).chr(0xe3).chr(0xcf).chr(0xd3));
	}

	/**
	 * Output end of document (EOF).
	 * @protected
	 */
	protected function _enddoc() {
		if (isset($this->CurrentFont['fontkey']) AND isset($this->CurrentFont['subsetchars'])) {
			// save subset chars of the previous font
			$this->setFontSubBuffer($this->CurrentFont['fontkey'], 'subsetchars', $this->CurrentFont['subsetchars']);
		}
		$this->state = 1;
		$this->_putheader();
		$this->_putpages();
		$this->_putresources();
		// empty signature fields
		if (!empty($this->empty_signature_appearance)) {
			foreach ($this->empty_signature_appearance as $key => $esa) {
				// widget annotation for empty signature
				$out = $this->_getobj($esa['objid']).""\n"";
				$out .= '<< /Type /Annot';
				$out .= ' /Subtype /Widget';
				$out .= ' /Rect ['.$esa['rect'].']';
				$out .= ' /P '.$this->page_obj_id[($esa['page'])].' 0 R'; // link to signature appearance page
				$out .= ' /F 4';
				$out .= ' /FT /Sig';
				$signame = $esa['name'].sprintf(' [%03d]', ($key + 1));
				$out .= ' /T '.$this->_textstring($signame, $esa['objid']);
				$out .= ' /Ff 0';
				$out .= ' >>';
				$out .= ""\n"".'endobj';
				$this->_out($out);
			}
		}
		// Signature
		if ($this->sign AND isset($this->signature_data['cert_type'])) {
			// widget annotation for signature
			$out = $this->_getobj($this->sig_obj_id).""\n"";
			$out .= '<< /Type /Annot';
			$out .= ' /Subtype /Widget';
			$out .= ' /Rect ['.$this->signature_appearance['rect'].']';
			$out .= ' /P '.$this->page_obj_id[($this->signature_appearance['page'])].' 0 R'; // link to signature appearance page
			$out .= ' /F 4';
			$out .= ' /FT /Sig';
			$out .= ' /T '.$this->_textstring($this->signature_appearance['name'], $this->sig_obj_id);
			$out .= ' /Ff 0';
			$out .= ' /V '.($this->sig_obj_id + 1).' 0 R';
			$out .= ' >>';
			$out .= ""\n"".'endobj';
			$this->_out($out);
			// signature
			$this->_putsignature();
		}
		// Info
		$objid_info = $this->_putinfo();
		// Catalog
		$objid_catalog = $this->_putcatalog();
		// Cross-ref
		$o = $this->bufferlen;
		// XREF section
		$this->_out('xref');
		$this->_out('0 '.($this->n + 1));
		$this->_out('0000000000 65535 f ');
		$freegen = ($this->n + 2);
		for ($i=1; $i <= $this->n; ++$i) {
			if (!isset($this->offsets[$i]) AND ($i > 1)) {
				$this->_out(sprintf('0000000000 %05d f ', $freegen));
				++$freegen;
			} else {
				$this->_out(sprintf('%010d 00000 n ', $this->offsets[$i]));
			}
		}
		// TRAILER
		$out = 'trailer'.""\n"";
		$out .= '<<';
		$out .= ' /Size '.($this->n + 1);
		$out .= ' /Root '.$objid_catalog.' 0 R';
		$out .= ' /Info '.$objid_info.' 0 R';
		if ($this->encrypted) {
			$out .= ' /Encrypt '.$this->encryptdata['objid'].' 0 R';
		}
		$out .= ' /ID [ <'.$this->file_id.'> <'.$this->file_id.'> ]';
		$out .= ' >>';
		$this->_out($out);
		$this->_out('startxref');
		$this->_out($o);
		$this->_out('%%EOF');
		$this->state = 3; // end-of-doc
	}

	/**
	 * Initialize a new page.
	 * @param string $orientation page orientation. Possible values are (case insensitive):<ul><li>P or PORTRAIT (default)</li><li>L or LANDSCAPE</li></ul>
	 * @param mixed $format The format used for pages. It can be either: one of the string values specified at getPageSizeFromFormat() or an array of parameters specified at setPageFormat().
	 * @protected
	 * @see getPageSizeFromFormat(), setPageFormat()
	 */
	protected function _beginpage($orientation='', $format='') {
		++$this->page;
		$this->pageobjects[$this->page] = array();
		$this->setPageBuffer($this->page, '');
		// initialize array for graphics tranformation positions inside a page buffer
		$this->transfmrk[$this->page] = array();
		$this->state = 2;
		if (TCPDF_STATIC::empty_string($orientation)) {
			if (isset($this->CurOrientation)) {
				$orientation = $this->CurOrientation;
			} elseif ($this->fwPt > $this->fhPt) {
				// landscape
				$orientation = 'L';
			} else {
				// portrait
				$orientation = 'P';
			}
		}
		if (TCPDF_STATIC::empty_string($format)) {
			$this->pagedim[$this->page] = $this->pagedim[($this->page - 1)];
			$this->setPageOrientation($orientation);
		} else {
			$this->setPageFormat($format, $orientation);
		}
		if ($this->rtl) {
			$this->x = $this->w - $this->rMargin;
		} else {
			$this->x = $this->lMargin;
		}
		$this->y = $this->tMargin;
		if (isset($this->newpagegroup[$this->page])) {
			// start a new group
			$this->currpagegroup = $this->newpagegroup[$this->page];
			$this->pagegroups[$this->currpagegroup] = 1;
		} elseif (isset($this->currpagegroup) AND ($this->currpagegroup > 0)) {
			++$this->pagegroups[$this->currpagegroup];
		}
	}

	/**
	 * Mark end of page.
	 * @protected
	 */
	protected function _endpage() {
		$this->setVisibility('all');
		$this->state = 1;
	}

	/**
	 * Begin a new object and return the object number.
	 * @return int object number
	 * @protected
	 */
	protected function _newobj() {
		$this->_out($this->_getobj());
		return $this->n;
	}

	/**
	 * Return the starting object string for the selected object ID.
	 * @param int|null $objid Object ID (leave empty to get a new ID).
	 * @return string the starting object string
	 * @protected
	 * @since 5.8.009 (2010-08-20)
	 */
	protected function _getobj($objid=null) {
		if (TCPDF_STATIC::empty_string($objid)) {
			++$this->n;
			$objid = $this->n;
		}
		$this->offsets[$objid] = $this->bufferlen;
		$this->pageobjects[$this->page][] = $objid;
		return $objid.' 0 obj';
	}

	/**
	 * Underline text.
	 * @param int $x X coordinate
	 * @param int $y Y coordinate
	 * @param string $txt text to underline
	 * @protected
	 */
	protected function _dounderline($x, $y, $txt) {
		$w = $this->GetStringWidth($txt);
		return $this->_dounderlinew($x, $y, $w);
	}

	/**
	 * Underline for rectangular text area.
	 * @param int $x X coordinate
	 * @param int $y Y coordinate
	 * @param int $w width to underline
	 * @protected
	 * @since 4.8.008 (2009-09-29)
	 */
	protected function _dounderlinew($x, $y, $w) {
		$linew = - $this->CurrentFont['ut'] / 1000 * $this->FontSizePt;
		return sprintf('%F %F %F %F re f', $x * $this->k, ((($this->h - $y) * $this->k) + $linew), $w * $this->k, $linew);
	}

	/**
	 * Line through text.
	 * @param int $x X coordinate
	 * @param int $y Y coordinate
	 * @param string $txt text to linethrough
	 * @protected
	 */
	protected function _dolinethrough($x, $y, $txt) {
		$w = $this->GetStringWidth($txt);
		return $this->_dolinethroughw($x, $y, $w);
	}

	/**
	 * Line through for rectangular text area.
	 * @param int $x X coordinate
	 * @param int $y Y coordinate
	 * @param int $w line length (width)
	 * @protected
	 * @since 4.9.008 (2009-09-29)
	 */
	protected function _dolinethroughw($x, $y, $w) {
		$linew = - $this->CurrentFont['ut'] / 1000 * $this->FontSizePt;
		return sprintf('%F %F %F %F re f', $x * $this->k, ((($this->h - $y) * $this->k) + $linew + ($this->FontSizePt / 3)), $w * $this->k, $linew);
	}

	/**
	 * Overline text.
	 * @param int $x X coordinate
	 * @param int $y Y coordinate
	 * @param string $txt text to overline
	 * @protected
	 * @since 4.9.015 (2010-04-19)
	 */
	protected function _dooverline($x, $y, $txt) {
		$w = $this->GetStringWidth($txt);
		return $this->_dooverlinew($x, $y, $w);
	}

	/**
	 * Overline for rectangular text area.
	 * @param int $x X coordinate
	 * @param int $y Y coordinate
	 * @param int $w width to overline
	 * @protected
	 * @since 4.9.015 (2010-04-19)
	 */
	protected function _dooverlinew($x, $y, $w) {
		$linew = - $this->CurrentFont['ut'] / 1000 * $this->FontSizePt;
		return sprintf('%F %F %F %F re f', $x * $this->k, (($this->h - $y + $this->FontAscent) * $this->k) - $linew, $w * $this->k, $linew);

	}

	/**
	 * Format a data string for meta information
	 * @param string $s data string to escape.
	 * @param int $n object ID
	 * @return string escaped string.
	 * @protected
	 */
	protected function _datastring($s, $n=0) {
		if ($n == 0) {
			$n = $this->n;
		}
		$s = $this->_encrypt_data($n, $s);
		return '('. TCPDF_STATIC::_escape($s).')';
	}

	/**
	 * Set the document creation timestamp
	 * @param mixed $time Document creation timestamp in seconds or date-time string.
	 * @public
	 * @since 5.9.152 (2012-03-23)
	 */
	public function setDocCreationTimestamp($time) {
		if (is_string($time)) {
			$time = TCPDF_STATIC::getTimestamp($time);
		}
		$this->doc_creation_timestamp = intval($time);
	}

	/**
	 * Set the document modification timestamp
	 * @param mixed $time Document modification timestamp in seconds or date-time string.
	 * @public
	 * @since 5.9.152 (2012-03-23)
	 */
	public function setDocModificationTimestamp($time) {
		if (is_string($time)) {
			$time = TCPDF_STATIC::getTimestamp($time);
		}
		$this->doc_modification_timestamp = intval($time);
	}

	/**
	 * Returns document creation timestamp in seconds.
	 * @return int Creation timestamp in seconds.
	 * @public
	 * @since 5.9.152 (2012-03-23)
	 */
	public function getDocCreationTimestamp() {
		return $this->doc_creation_timestamp;
	}

	/**
	 * Returns document modification timestamp in seconds.
	 * @return int Modfication timestamp in seconds.
	 * @public
	 * @since 5.9.152 (2012-03-23)
	 */
	public function getDocModificationTimestamp() {
		return $this->doc_modification_timestamp;
	}

	/**
	 * Returns a formatted date for meta information
	 * @param int $n Object ID.
	 * @param int $timestamp Timestamp to convert.
	 * @return string escaped date string.
	 * @protected
	 * @since 4.6.028 (2009-08-25)
	 */
	protected function _datestring($n=0, $timestamp=0) {
		if ((empty($timestamp)) OR ($timestamp < 0)) {
			$timestamp = $this->doc_creation_timestamp;
		}
		return $this->_datastring('D:'.TCPDF_STATIC::getFormattedDate($timestamp), $n);
	}

	/**
	 * Format a text string for meta information
	 * @param string $s string to escape.
	 * @param int $n object ID
	 * @return string escaped string.
	 * @protected
	 */
	protected function _textstring($s, $n=0) {
		if ($this->isunicode) {
			//Convert string to UTF-16BE
			$s = TCPDF_FONTS::UTF8ToUTF16BE($s, true, $this->isunicode, $this->CurrentFont);
		}
		return $this->_datastring($s, $n);
	}

	/**
	 * get raw output stream.
	 * @param string $s string to output.
	 * @param int $n object reference for encryption mode
	 * @protected
	 * @author Nicola Asuni
	 * @since 5.5.000 (2010-06-22)
	 */
	protected function _getrawstream($s, $n=0) {
		if ($n <= 0) {
			// default to current object
			$n = $this->n;
		}
		return $this->_encrypt_data($n, $s);
	}

	/**
	 * Output a string to the document.
	 * @param string $s string to output.
	 * @protected
	 */
	protected function _out($s) {
		if ($this->state == 2) {
			if ($this->inxobj) {
				// we are inside an XObject template
				$this->xobjects[$this->xobjid]['outdata'] .= $s.""\n"";
			} elseif ((!$this->InFooter) AND isset($this->footerlen[$this->page]) AND ($this->footerlen[$this->page] > 0)) {
				// puts data before page footer
				$pagebuff = $this->getPageBuffer($this->page);
				$page = substr($pagebuff, 0, -$this->footerlen[$this->page]);
				$footer = substr($pagebuff, -$this->footerlen[$this->page]);
				$this->setPageBuffer($this->page, $page.$s.""\n"".$footer);
				// update footer position
				$this->footerpos[$this->page] += strlen($s.""\n"");
			} else {
				// set page data
				$this->setPageBuffer($this->page, $s.""\n"", true);
			}
		} elseif ($this->state > 0) {
			// set general data
			$this->setBuffer($s.""\n"");
		}
	}

	/**
	 * Set header font.
	 * @param array<int,string|float|null> $font Array describing the basic font parameters: (family, style, size).
	 * @phpstan-param array{0: string, 1: string, 2: float|null} $font
	 * @public
	 * @since 1.1
	 */
	public function setHeaderFont($font) {
		$this->header_font = $font;
	}

	/**
	 * Get header font.
	 * @return array<int,string|float|null> Array describing the basic font parameters: (family, style, size).
	 * @phpstan-return array{0: string, 1: string, 2: float|null}
	 * @public
	 * @since 4.0.012 (2008-07-24)
	 */
	public function getHeaderFont() {
		return $this->header_font;
	}

	/**
	 * Set footer font.
	 * @param array<int,string|float|null> $font Array describing the basic font parameters: (family, style, size).
	 * @phpstan-param array{0: string, 1: string, 2: float|null} $font
	 * @public
	 * @since 1.1
	 */
	public function setFooterFont($font) {
		$this->footer_font = $font;
	}

	/**
	 * Get Footer font.
	 * @return array<int,string|float|null> Array describing the basic font parameters: (family, style, size).
	 * @phpstan-return array{0: string, 1: string, 2: float|null} $font
	 * @public
	 * @since 4.0.012 (2008-07-24)
	 */
	public function getFooterFont() {
		return $this->footer_font;
	}

	/**
	 * Set language array.
	 * @param array $language
	 * @public
	 * @since 1.1
	 */
	public function setLanguageArray($language) {
		$this->l = $language;
		if (isset($this->l['a_meta_dir'])) {
			$this->rtl = $this->l['a_meta_dir']=='rtl' ? true : false;
		} else {
			$this->rtl = false;
		}
	}

	/**
	 * Returns the PDF data.
	 * @public
	 */
	public function getPDFData() {
		if ($this->state < 3) {
			$this->Close();
		}
		return $this->buffer;
	}

	/**
	 * Output anchor link.
	 * @param string $url link URL or internal link (i.e.: &lt;a href=""#23,4.5""&gt;link to page 23 at 4.5 Y position&lt;/a&gt;)
	 * @param string $name link name
	 * @param boolean $fill Indicates if the cell background must be painted (true) or transparent (false).
	 * @param boolean $firstline if true prints only the first line and return the remaining string.
	 * @param array|null $color array of RGB text color
	 * @param string $style font style (U, D, B, I)
	 * @param boolean $firstblock if true the string is the starting of a line.
	 * @return int the number of cells used or the remaining text if $firstline = true;
	 * @public
	 */
	public function addHtmlLink($url, $name, $fill=false, $firstline=false, $color=null, $style=-1, $firstblock=false) {
		if (isset($url[1]) AND ($url[0] == '#') AND is_numeric($url[1])) {
			// convert url to internal link
			$lnkdata = explode(',', $url);
			if (isset($lnkdata[0]) ) {
				$page = substr($lnkdata[0], 1);
				if (isset($lnkdata[1]) AND (strlen($lnkdata[1]) > 0)) {
					$lnky = floatval($lnkdata[1]);
				} else {
					$lnky = 0;
				}
				$url = $this->AddLink();
				$this->setLink($url, $lnky, $page);
			}
		}
		// store current settings
		$prevcolor = $this->fgcolor;
		$prevstyle = $this->FontStyle;
		if (empty($color)) {
			$this->setTextColorArray($this->htmlLinkColorArray);
		} else {
			$this->setTextColorArray($color);
		}
		if ($style == -1) {
			$this->setFont('', $this->FontStyle.$this->htmlLinkFontStyle);
		} else {
			$this->setFont('', $this->FontStyle.$style);
		}
		$ret = $this->Write($this->lasth, $name, $url, $fill, '', false, 0, $firstline, $firstblock, 0);
		// restore settings
		$this->setFont('', $prevstyle);
		$this->setTextColorArray($prevcolor);
		return $ret;
	}

	/**
	 * Converts pixels to User's Units.
	 * @param int $px pixels
	 * @return float value in user's unit
	 * @public
	 * @see setImageScale(), getImageScale()
	 */
	public function pixelsToUnits($px) {
		return ($px / ($this->imgscale * $this->k));
	}

	/**
	 * Reverse function for htmlentities.
	 * Convert entities in UTF-8.
	 * @param string $text_to_convert Text to convert.
	 * @return string converted text string
	 * @public
	 */
	public function unhtmlentities($text_to_convert) {
		return @html_entity_decode($text_to_convert, ENT_QUOTES, $this->encoding);
	}

	// ENCRYPTION METHODS ----------------------------------

	/**
	 * Compute encryption key depending on object number where the encrypted data is stored.
	 * This is used for all strings and streams without crypt filter specifier.
	 * @param int $n object number
	 * @return int object key
	 * @protected
	 * @author Nicola Asuni
	 * @since 2.0.000 (2008-01-02)
	 */
	protected function _objectkey($n) {
		$objkey = $this->encryptdata['key'].pack('VXxx', $n);
		if ($this->encryptdata['mode'] == 2) { // AES-128
			// AES padding
			$objkey .= ""\x73\x41\x6C\x54""; // sAlT
		}
		$objkey = substr(TCPDF_STATIC::_md5_16($objkey), 0, (($this->encryptdata['Length'] / 8) + 5));
		$objkey = substr($objkey, 0, 16);
		return $objkey;
	}

	/**
	 * Encrypt the input string.
	 * @param int $n object number
	 * @param string $s data string to encrypt
	 * @return string encrypted string
	 * @protected
	 * @author Nicola Asuni
	 * @since 5.0.005 (2010-05-11)
	 */
	protected function _encrypt_data($n, $s) {
		if (!$this->encrypted) {
			return $s;
		}
		switch ($this->encryptdata['mode']) {
			case 0:   // RC4-40
			case 1: { // RC4-128
				$s = TCPDF_STATIC::_RC4($this->_objectkey($n), $s, $this->last_enc_key, $this->last_enc_key_c);
				break;
			}
			case 2: { // AES-128
				$s = TCPDF_STATIC::_AES($this->_objectkey($n), $s);
				break;
			}
			case 3: { // AES-256
				$s = TCPDF_STATIC::_AES($this->encryptdata['key'], $s);
				break;
			}
		}
		return $s;
	}

	/**
	 * Put encryption on PDF document.
	 * @protected
	 * @author Nicola Asuni
	 * @since 2.0.000 (2008-01-02)
	 */
	protected function _putencryption() {
		if (!$this->encrypted) {
			return;
		}
		$this->encryptdata['objid'] = $this->_newobj();
		$out = '<<';
		if (!isset($this->encryptdata['Filter']) OR empty($this->encryptdata['Filter'])) {
			$this->encryptdata['Filter'] = 'Standard';
		}
		$out .= ' /Filter /'.$this->encryptdata['Filter'];
		if (isset($this->encryptdata['SubFilter']) AND !empty($this->encryptdata['SubFilter'])) {
			$out .= ' /SubFilter /'.$this->encryptdata['SubFilter'];
		}
		if (!isset($this->encryptdata['V']) OR empty($this->encryptdata['V'])) {
			$this->encryptdata['V'] = 1;
		}
		// V is a code specifying the algorithm to be used in encrypting and decrypting the document
		$out .= ' /V '.$this->encryptdata['V'];
		if (isset($this->encryptdata['Length']) AND !empty($this->encryptdata['Length'])) {
			// The length of the encryption key, in bits. The value shall be a multiple of 8, in the range 40 to 256
			$out .= ' /Length '.$this->encryptdata['Length'];
		} else {
			$out .= ' /Length 40';
		}
		if ($this->encryptdata['V'] >= 4) {
			if (!isset($this->encryptdata['StmF']) OR empty($this->encryptdata['StmF'])) {
				$this->encryptdata['StmF'] = 'Identity';
			}
			if (!isset($this->encryptdata['StrF']) OR empty($this->encryptdata['StrF'])) {
				// The name of the crypt filter that shall be used when decrypting all strings in the document.
				$this->encryptdata['StrF'] = 'Identity';
			}
			// A dictionary whose keys shall be crypt filter names and whose values shall be the corresponding crypt filter dictionaries.
			if (isset($this->encryptdata['CF']) AND !empty($this->encryptdata['CF'])) {
				$out .= ' /CF <<';
				$out .= ' /'.$this->encryptdata['StmF'].' <<';
				$out .= ' /Type /CryptFilter';
				if (isset($this->encryptdata['CF']['CFM']) AND !empty($this->encryptdata['CF']['CFM'])) {
					// The method used
					$out .= ' /CFM /'.$this->encryptdata['CF']['CFM'];
					if ($this->encryptdata['pubkey']) {
						$out .= ' /Recipients [';
						foreach ($this->encryptdata['Recipients'] as $rec) {
							$out .= ' <'.$rec.'>';
						}
						$out .= ' ]';
						if (isset($this->encryptdata['CF']['EncryptMetadata']) AND (!$this->encryptdata['CF']['EncryptMetadata'])) {
							$out .= ' /EncryptMetadata false';
						} else {
							$out .= ' /EncryptMetadata true';
						}
					}
				} else {
					$out .= ' /CFM /None';
				}
				if (isset($this->encryptdata['CF']['AuthEvent']) AND !empty($this->encryptdata['CF']['AuthEvent'])) {
					// The event to be used to trigger the authorization that is required to access encryption keys used by this filter.
					$out .= ' /AuthEvent /'.$this->encryptdata['CF']['AuthEvent'];
				} else {
					$out .= ' /AuthEvent /DocOpen';
				}
				if (isset($this->encryptdata['CF']['Length']) AND !empty($this->encryptdata['CF']['Length'])) {
					// The bit length of the encryption key.
					$out .= ' /Length '.$this->encryptdata['CF']['Length'];
				}
				$out .= ' >> >>';
			}
			// The name of the crypt filter that shall be used by default when decrypting streams.
			$out .= ' /StmF /'.$this->encryptdata['StmF'];
			// The name of the crypt filter that shall be used when decrypting all strings in the document.
			$out .= ' /StrF /'.$this->encryptdata['StrF'];
			if (isset($this->encryptdata['EFF']) AND !empty($this->encryptdata['EFF'])) {
				// The name of the crypt filter that shall be used when encrypting embedded file streams that do not have their own crypt filter specifier.
				$out .= ' /EFF /'.$this->encryptdata[''];
			}
		}
		// Additional encryption dictionary entries for the standard security handler
		if ($this->encryptdata['pubkey']) {
			if (($this->encryptdata['V'] < 4) AND isset($this->encryptdata['Recipients']) AND !empty($this->encryptdata['Recipients'])) {
				$out .= ' /Recipients [';
				foreach ($this->encryptdata['Recipients'] as $rec) {
					$out .= ' <'.$rec.'>';
				}
				$out .= ' ]';
			}
		} else {
			$out .= ' /R';
			if ($this->encryptdata['V'] == 5) { // AES-256
				$out .= ' 5';
				$out .= ' /OE ('.TCPDF_STATIC::_escape($this->encryptdata['OE']).')';
				$out .= ' /UE ('.TCPDF_STATIC::_escape($this->encryptdata['UE']).')';
				$out .= ' /Perms ('.TCPDF_STATIC::_escape($this->encryptdata['perms']).')';
			} elseif ($this->encryptdata['V'] == 4) { // AES-128
				$out .= ' 4';
			} elseif ($this->encryptdata['V'] < 2) { // RC-40
				$out .= ' 2';
			} else { // RC-128
				$out .= ' 3';
			}
			$out .= ' /O ('.TCPDF_STATIC::_escape($this->encryptdata['O']).')';
			$out .= ' /U ('.TCPDF_STATIC::_escape($this->encryptdata['U']).')';
			$out .= ' /P '.$this->encryptdata['P'];
			if (isset($this->encryptdata['EncryptMetadata']) AND (!$this->encryptdata['EncryptMetadata'])) {
				$out .= ' /EncryptMetadata false';
			} else {
				$out .= ' /EncryptMetadata true';
			}
		}
		$out .= ' >>';
		$out .= ""\n"".'endobj';
		$this->_out($out);
	}

	/**
	 * Compute U value (used for encryption)
	 * @return string U value
	 * @protected
	 * @since 2.0.000 (2008-01-02)
	 * @author Nicola Asuni
	 */
	protected function _Uvalue() {
		if ($this->encryptdata['mode'] == 0) { // RC4-40
			return TCPDF_STATIC::_RC4($this->encryptdata['key'], TCPDF_STATIC::$enc_padding, $this->last_enc_key, $this->last_enc_key_c);
		} elseif ($this->encryptdata['mode'] < 3) { // RC4-128, AES-128
			$tmp = TCPDF_STATIC::_md5_16(TCPDF_STATIC::$enc_padding.$this->encryptdata['fileid']);
			$enc = TCPDF_STATIC::_RC4($this->encryptdata['key'], $tmp, $this->last_enc_key, $this->last_enc_key_c);
			$len = strlen($tmp);
			for ($i = 1; $i <= 19; ++$i) {
				$ek = '';
				for ($j = 0; $j < $len; ++$j) {
					$ek .= chr(ord($this->encryptdata['key'][$j]) ^ $i);
				}
				$enc = TCPDF_STATIC::_RC4($ek, $enc, $this->last_enc_key, $this->last_enc_key_c);
			}
			$enc .= str_repeat(""\x00"", 16);
			return substr($enc, 0, 32);
		} elseif ($this->encryptdata['mode'] == 3) { // AES-256
			$seed = TCPDF_STATIC::_md5_16(TCPDF_STATIC::getRandomSeed());
			// User Validation Salt
			$this->encryptdata['UVS'] = substr($seed, 0, 8);
			// User Key Salt
			$this->encryptdata['UKS'] = substr($seed, 8, 16);
			return hash('sha256', $this->encryptdata['user_password'].$this->encryptdata['UVS'], true).$this->encryptdata['UVS'].$this->encryptdata['UKS'];
		}
	}

	/**
	 * Compute UE value (used for encryption)
	 * @return string UE value
	 * @protected
	 * @since 5.9.006 (2010-10-19)
	 * @author Nicola Asuni
	 */
	protected function _UEvalue() {
		$hashkey = hash('sha256', $this->encryptdata['user_password'].$this->encryptdata['UKS'], true);
		return TCPDF_STATIC::_AESnopad($hashkey, $this->encryptdata['key']);
	}

	/**
	 * Compute O value (used for encryption)
	 * @return string O value
	 * @protected
	 * @since 2.0.000 (2008-01-02)
	 * @author Nicola Asuni
	 */
	protected function _Ovalue() {
		if ($this->encryptdata['mode'] < 3) { // RC4-40, RC4-128, AES-128
			$tmp = TCPDF_STATIC::_md5_16($this->encryptdata['owner_password']);
			if ($this->encryptdata['mode'] > 0) {
				for ($i = 0; $i < 50; ++$i) {
					$tmp = TCPDF_STATIC::_md5_16($tmp);
				}
			}
			$owner_key = substr($tmp, 0, ($this->encryptdata['Length'] / 8));
			$enc = TCPDF_STATIC::_RC4($owner_key, $this->encryptdata['user_password'], $this->last_enc_key, $this->last_enc_key_c);
			if ($this->encryptdata['mode'] > 0) {
				$len = strlen($owner_key);
				for ($i = 1; $i <= 19; ++$i) {
					$ek = '';
					for ($j = 0; $j < $len; ++$j) {
						$ek .= chr(ord($owner_key[$j]) ^ $i);
					}
					$enc = TCPDF_STATIC::_RC4($ek, $enc, $this->last_enc_key, $this->last_enc_key_c);
				}
			}
			return $enc;
		} elseif ($this->encryptdata['mode'] == 3) { // AES-256
			$seed = TCPDF_STATIC::_md5_16(TCPDF_STATIC::getRandomSeed());
			// Owner Validation Salt
			$this->encryptdata['OVS'] = substr($seed, 0, 8);
			// Owner Key Salt
			$this->encryptdata['OKS'] = substr($seed, 8, 16);
			return hash('sha256', $this->encryptdata['owner_password'].$this->encryptdata['OVS'].$this->encryptdata['U'], true).$this->encryptdata['OVS'].$this->encryptdata['OKS'];
		}
	}

	/**
	 * Compute OE value (used for encryption)
	 * @return string OE value
	 * @protected
	 * @since 5.9.006 (2010-10-19)
	 * @author Nicola Asuni
	 */
	protected function _OEvalue() {
		$hashkey = hash('sha256', $this->encryptdata['owner_password'].$this->encryptdata['OKS'].$this->encryptdata['U'], true);
		return TCPDF_STATIC::_AESnopad($hashkey, $this->encryptdata['key']);
	}

	/**
	 * Convert password for AES-256 encryption mode
	 * @param string $password password
	 * @return string password
	 * @protected
	 * @since 5.9.006 (2010-10-19)
	 * @author Nicola Asuni
	 */
	protected function _fixAES256Password($password) {
		$psw = ''; // password to be returned
		$psw_array = TCPDF_FONTS::utf8Bidi(TCPDF_FONTS::UTF8StringToArray($password, $this->isunicode, $this->CurrentFont), $password, $this->rtl, $this->isunicode, $this->CurrentFont);
		foreach ($psw_array as $c) {
			$psw .= TCPDF_FONTS::unichr($c, $this->isunicode);
		}
		return substr($psw, 0, 127);
	}

	/**
	 * Compute encryption key
	 * @protected
	 * @since 2.0.000 (2008-01-02)
	 * @author Nicola Asuni
	 */
	protected function _generateencryptionkey() {
		$keybytelen = ($this->encryptdata['Length'] / 8);
		if (!$this->encryptdata['pubkey']) { // standard mode
			if ($this->encryptdata['mode'] == 3) { // AES-256
				// generate 256 bit random key
				$this->encryptdata['key'] = substr(hash('sha256', TCPDF_STATIC::getRandomSeed(), true), 0, $keybytelen);
				// truncate passwords
				$this->encryptdata['user_password'] = $this->_fixAES256Password($this->encryptdata['user_password']);
				$this->encryptdata['owner_password'] = $this->_fixAES256Password($this->encryptdata['owner_password']);
				// Compute U value
				$this->encryptdata['U'] = $this->_Uvalue();
				// Compute UE value
				$this->encryptdata['UE'] = $this->_UEvalue();
				// Compute O value
				$this->encryptdata['O'] = $this->_Ovalue();
				// Compute OE value
				$this->encryptdata['OE'] = $this->_OEvalue();
				// Compute P value
				$this->encryptdata['P'] = $this->encryptdata['protection'];
				// Computing the encryption dictionary's Perms (permissions) value
				$perms = TCPDF_STATIC::getEncPermissionsString($this->encryptdata['protection']); // bytes 0-3
				$perms .= chr(255).chr(255).chr(255).chr(255); // bytes 4-7
				if (isset($this->encryptdata['CF']['EncryptMetadata']) AND (!$this->encryptdata['CF']['EncryptMetadata'])) { // byte 8
					$perms .= 'F';
				} else {
					$perms .= 'T';
				}
				$perms .= 'adb'; // bytes 9-11
				$perms .= 'nick'; // bytes 12-15
				$this->encryptdata['perms'] = TCPDF_STATIC::_AESnopad($this->encryptdata['key'], $perms);
			} else { // RC4-40, RC4-128, AES-128
				// Pad passwords
				$this->encryptdata['user_password'] = substr($this->encryptdata['user_password'].TCPDF_STATIC::$enc_padding, 0, 32);
				$this->encryptdata['owner_password'] = substr($this->encryptdata['owner_password'].TCPDF_STATIC::$enc_padding, 0, 32);
				// Compute O value
				$this->encryptdata['O'] = $this->_Ovalue();
				// get default permissions (reverse byte order)
				$permissions = TCPDF_STATIC::getEncPermissionsString($this->encryptdata['protection']);
				// Compute encryption key
				$tmp = TCPDF_STATIC::_md5_16($this->encryptdata['user_password'].$this->encryptdata['O'].$permissions.$this->encryptdata['fileid']);
				if ($this->encryptdata['mode'] > 0) {
					for ($i = 0; $i < 50; ++$i) {
						$tmp = TCPDF_STATIC::_md5_16(substr($tmp, 0, $keybytelen));
					}
				}
				$this->encryptdata['key'] = substr($tmp, 0, $keybytelen);
				// Compute U value
				$this->encryptdata['U'] = $this->_Uvalue();
				// Compute P value
				$this->encryptdata['P'] = $this->encryptdata['protection'];
			}
		} else { // Public-Key mode
			// random 20-byte seed
			$seed = sha1(TCPDF_STATIC::getRandomSeed(), true);
			$recipient_bytes = '';
			foreach ($this->encryptdata['pubkeys'] as $pubkey) {
				// for each public certificate
				if (isset($pubkey['p'])) {
					$pkprotection = TCPDF_STATIC::getUserPermissionCode($pubkey['p'], $this->encryptdata['mode']);
				} else {
					$pkprotection = $this->encryptdata['protection'];
				}
				// get default permissions (reverse byte order)
				$pkpermissions = TCPDF_STATIC::getEncPermissionsString($pkprotection);
				// envelope data
				$envelope = $seed.$pkpermissions;
				// write the envelope data to a temporary file
				$tempkeyfile = TCPDF_STATIC::getObjFilename('key', $this->file_id);
				$f = TCPDF_STATIC::fopenLocal($tempkeyfile, 'wb');
				if (!$f) {
					$this->Error('Unable to create temporary key file: '.$tempkeyfile);
				}
				$envelope_length = strlen($envelope);
				fwrite($f, $envelope, $envelope_length);
				fclose($f);
				$tempencfile = TCPDF_STATIC::getObjFilename('enc', $this->file_id);
				if (!openssl_pkcs7_encrypt($tempkeyfile, $tempencfile, $pubkey['c'], array(), PKCS7_BINARY | PKCS7_DETACHED)) {
					$this->Error('Unable to encrypt the file: '.$tempkeyfile);
				}
				// read encryption signature
				$signature = file_get_contents($tempencfile, false, null, $envelope_length);
				// extract signature
				$signature = substr($signature, strpos($signature, 'Content-Disposition'));
				$tmparr = explode(""\n\n"", $signature);
				$signature = trim($tmparr[1]);
				unset($tmparr);
				// decode signature
				$signature = base64_decode($signature);
				// convert signature to hex
				$hexsignature = current(unpack('H*', $signature));
				// store signature on recipients array
				$this->encryptdata['Recipients'][] = $hexsignature;
				// The bytes of each item in the Recipients array of PKCS#7 objects in the order in which they appear in the array
				$recipient_bytes .= $signature;
			}
			// calculate encryption key
			if ($this->encryptdata['mode'] == 3) { // AES-256
				$this->encryptdata['key'] = substr(hash('sha256', $seed.$recipient_bytes, true), 0, $keybytelen);
			} else { // RC4-40, RC4-128, AES-128
				$this->encryptdata['key'] = substr(sha1($seed.$recipient_bytes, true), 0, $keybytelen);
			}
		}
	}

	/**
	 * Set document protection
	 * Remark: the protection against modification is for people who have the full Acrobat product.
	 * If you don't set any password, the document will open as usual. If you set a user password, the PDF viewer will ask for it before displaying the document. The master password, if different from the user one, can be used to get full access.
	 * Note: protecting a document requires to encrypt it, which increases the processing time a lot. This can cause a PHP time-out in some cases, especially if the document contains images or fonts.
	 * @param array $permissions the set of permissions (specify the ones you want to block):<ul><li>print : Print the document;</li><li>modify : Modify the contents of the document by operations other than those controlled by 'fill-forms', 'extract' and 'assemble';</li><li>copy : Copy or otherwise extract text and graphics from the document;</li><li>annot-forms : Add or modify text annotations, fill in interactive form fields, and, if 'modify' is also set, create or modify interactive form fields (including signature fields);</li><li>fill-forms : Fill in existing interactive form fields (including signature fields), even if 'annot-forms' is not specified;</li><li>extract : Extract text and graphics (in support of accessibility to users with disabilities or for other purposes);</li><li>assemble : Assemble the document (insert, rotate, or delete pages and create bookmarks or thumbnail images), even if 'modify' is not set;</li><li>print-high : Print the document to a representation from which a faithful digital copy of the PDF content could be generated. When this is not set, printing is limited to a low-level representation of the appearance, possibly of degraded quality.</li><li>owner : (inverted logic - only for public-key) when set permits change of encryption and enables all other permissions.</li></ul>
	 * @param string $user_pass user password. Empty by default.
	 * @param string|null $owner_pass owner password. If not specified, a random value is used.
	 * @param int $mode encryption strength: 0 = RC4 40 bit; 1 = RC4 128 bit; 2 = AES 128 bit; 3 = AES 256 bit.
	 * @param array|null $pubkeys array of recipients containing public-key certificates ('c') and permissions ('p'). For example: array(array('c' => 'file://../examples/data/cert/tcpdf.crt', 'p' => array('print')))
	 * @public
	 * @since 2.0.000 (2008-01-02)
	 * @author Nicola Asuni
	 */
	public function setProtection($permissions=array('print', 'modify', 'copy', 'annot-forms', 'fill-forms', 'extract', 'assemble', 'print-high'), $user_pass='', $owner_pass=null, $mode=0, $pubkeys=null) {
		if ($this->pdfa_mode) {
			// encryption is not allowed in PDF/A mode
			return;
		}
		$this->encryptdata['protection'] = TCPDF_STATIC::getUserPermissionCode($permissions, $mode);
		if (($pubkeys !== null) AND (is_array($pubkeys))) {
			// public-key mode
			$this->encryptdata['pubkeys'] = $pubkeys;
			if ($mode == 0) {
				// public-Key Security requires at least 128 bit
				$mode = 1;
			}
			if (!function_exists('openssl_pkcs7_encrypt')) {
				$this->Error('Public-Key Security requires openssl library.');
			}
			// Set Public-Key filter (available are: Entrust.PPKEF, Adobe.PPKLite, Adobe.PubSec)
			$this->encryptdata['pubkey'] = true;
			$this->encryptdata['Filter'] = 'Adobe.PubSec';
			$this->encryptdata['StmF'] = 'DefaultCryptFilter';
			$this->encryptdata['StrF'] = 'DefaultCryptFilter';
		} else {
			// standard mode (password mode)
			$this->encryptdata['pubkey'] = false;
			$this->encryptdata['Filter'] = 'Standard';
			$this->encryptdata['StmF'] = 'StdCF';
			$this->encryptdata['StrF'] = 'StdCF';
		}
		if ($mode > 1) { // AES
			if (!extension_loaded('openssl') && !extension_loaded('mcrypt')) {
				$this->Error('AES encryption requires openssl or mcrypt extension (http://www.php.net/manual/en/mcrypt.requirements.php).');
			}
			if (extension_loaded('openssl') && !in_array('aes-256-cbc', openssl_get_cipher_methods())) {
				$this->Error('AES encryption requires openssl/aes-256-cbc cypher.');
			}
			if (extension_loaded('mcrypt') && mcrypt_get_cipher_name(MCRYPT_RIJNDAEL_128) === false) {
				$this->Error('AES encryption requires MCRYPT_RIJNDAEL_128 cypher.');
			}
			if (($mode == 3) AND !function_exists('hash')) {
				// the Hash extension requires no external libraries and is enabled by default as of PHP 5.1.2.
				$this->Error('AES 256 encryption requires HASH Message Digest Framework (http://www.php.net/manual/en/book.hash.php).');
			}
		}
		if ($owner_pass === null) {
			$owner_pass = md5(TCPDF_STATIC::getRandomSeed());
		}
		$this->encryptdata['user_password'] = $user_pass;
		$this->encryptdata['owner_password'] = $owner_pass;
		$this->encryptdata['mode'] = $mode;
		switch ($mode) {
			case 0: { // RC4 40 bit
				$this->encryptdata['V'] = 1;
				$this->encryptdata['Length'] = 40;
				$this->encryptdata['CF']['CFM'] = 'V2';
				break;
			}
			case 1: { // RC4 128 bit
				$this->encryptdata['V'] = 2;
				$this->encryptdata['Length'] = 128;
				$this->encryptdata['CF']['CFM'] = 'V2';
				if ($this->encryptdata['pubkey']) {
					$this->encryptdata['SubFilter'] = 'adbe.pkcs7.s4';
					$this->encryptdata['Recipients'] = array();
				}
				break;
			}
			case 2: { // AES 128 bit
				$this->encryptdata['V'] = 4;
				$this->encryptdata['Length'] = 128;
				$this->encryptdata['CF']['CFM'] = 'AESV2';
				$this->encryptdata['CF']['Length'] = 128;
				if ($this->encryptdata['pubkey']) {
					$this->encryptdata['SubFilter'] = 'adbe.pkcs7.s5';
					$this->encryptdata['Recipients'] = array();
				}
				break;
			}
			case 3: { // AES 256 bit
				$this->encryptdata['V'] = 5;
				$this->encryptdata['Length'] = 256;
				$this->encryptdata['CF']['CFM'] = 'AESV3';
				$this->encryptdata['CF']['Length'] = 256;
				if ($this->encryptdata['pubkey']) {
					$this->encryptdata['SubFilter'] = 'adbe.pkcs7.s5';
					$this->encryptdata['Recipients'] = array();
				}
				break;
			}
		}
		$this->encrypted = true;
		$this->encryptdata['fileid'] = TCPDF_STATIC::convertHexStringToString($this->file_id);
		$this->_generateencryptionkey();
	}

	// END OF ENCRYPTION FUNCTIONS -------------------------

	// START TRANSFORMATIONS SECTION -----------------------

	/**
	 * Starts a 2D tranformation saving current graphic state.
	 * This function must be called before scaling, mirroring, translation, rotation and skewing.
	 * Use StartTransform() before, and StopTransform() after the transformations to restore the normal behavior.
	 * @public
	 * @since 2.1.000 (2008-01-07)
	 * @see StartTransform(), StopTransform()
	 */
	public function StartTransform() {
		if ($this->state != 2) {
			return;
		}
		$this->_outSaveGraphicsState();
		if ($this->inxobj) {
			// we are inside an XObject template
			$this->xobjects[$this->xobjid]['transfmrk'][] = strlen($this->xobjects[$this->xobjid]['outdata']);
		} else {
			$this->transfmrk[$this->page][] = $this->pagelen[$this->page];
		}
		++$this->transfmatrix_key;
		$this->transfmatrix[$this->transfmatrix_key] = array();
	}

	/**
	 * Stops a 2D tranformation restoring previous graphic state.
	 * This function must be called after scaling, mirroring, translation, rotation and skewing.
	 * Use StartTransform() before, and StopTransform() after the transformations to restore the normal behavior.
	 * @public
	 * @since 2.1.000 (2008-01-07)
	 * @see StartTransform(), StopTransform()
	 */
	public function StopTransform() {
		if ($this->state != 2) {
			return;
		}
		$this->_outRestoreGraphicsState();
		if (isset($this->transfmatrix[$this->transfmatrix_key])) {
			array_pop($this->transfmatrix[$this->transfmatrix_key]);
			--$this->transfmatrix_key;
		}
		if ($this->inxobj) {
			// we are inside an XObject template
			array_pop($this->xobjects[$this->xobjid]['transfmrk']);
		} else {
			array_pop($this->transfmrk[$this->page]);
		}
	}
	/**
	 * Horizontal Scaling.
	 * @param float $s_x scaling factor for width as percent. 0 is not allowed.
	 * @param int $x abscissa of the scaling center. Default is current x position
	 * @param int $y ordinate of the scaling center. Default is current y position
	 * @public
	 * @since 2.1.000 (2008-01-07)
	 * @see StartTransform(), StopTransform()
	 */
	public function ScaleX($s_x, $x='', $y='') {
		$this->Scale($s_x, 100, $x, $y);
	}

	/**
	 * Vertical Scaling.
	 * @param float $s_y scaling factor for height as percent. 0 is not allowed.
	 * @param int $x abscissa of the scaling center. Default is current x position
	 * @param int $y ordinate of the scaling center. Default is current y position
	 * @public
	 * @since 2.1.000 (2008-01-07)
	 * @see StartTransform(), StopTransform()
	 */
	public function ScaleY($s_y, $x='', $y='') {
		$this->Scale(100, $s_y, $x, $y);
	}

	/**
	 * Vertical and horizontal proportional Scaling.
	 * @param float $s scaling factor for width and height as percent. 0 is not allowed.
	 * @param int $x abscissa of the scaling center. Default is current x position
	 * @param int $y ordinate of the scaling center. Default is current y position
	 * @public
	 * @since 2.1.000 (2008-01-07)
	 * @see StartTransform(), StopTransform()
	 */
	public function ScaleXY($s, $x='', $y='') {
		$this->Scale($s, $s, $x, $y);
	}

	/**
	 * Vertical and horizontal non-proportional Scaling.
	 * @param float $s_x scaling factor for width as percent. 0 is not allowed.
	 * @param float $s_y scaling factor for height as percent. 0 is not allowed.
	 * @param float|null $x abscissa of the scaling center. Default is current x position
	 * @param float|null $y ordinate of the scaling center. Default is current y position
	 * @public
	 * @since 2.1.000 (2008-01-07)
	 * @see StartTransform(), StopTransform()
	 */
	public function Scale($s_x, $s_y, $x=null, $y=null) {
		if (TCPDF_STATIC::empty_string($x)) {
			$x = $this->x;
		}
		if (TCPDF_STATIC::empty_string($y)) {
			$y = $this->y;
		}
		if (($s_x == 0) OR ($s_y == 0)) {
			$this->Error('Please do not use values equal to zero for scaling');
		}
		$y = ($this->h - $y) * $this->k;
		$x *= $this->k;
		//calculate elements of transformation matrix
		$s_x /= 100;
		$s_y /= 100;
		$tm = array();
		$tm[0] = $s_x;
		$tm[1] = 0;
		$tm[2] = 0;
		$tm[3] = $s_y;
		$tm[4] = $x * (1 - $s_x);
		$tm[5] = $y * (1 - $s_y);
		//scale the coordinate system
		$this->Transform($tm);
	}

	/**
	 * Horizontal Mirroring.
	 * @param float|null $x abscissa of the point. Default is current x position
	 * @public
	 * @since 2.1.000 (2008-01-07)
	 * @see StartTransform(), StopTransform()
	 */
	public function MirrorH($x=null) {
		$this->Scale(-100, 100, $x);
	}

	/**
	 * Verical Mirroring.
	 * @param float|null $y ordinate of the point. Default is current y position
	 * @public
	 * @since 2.1.000 (2008-01-07)
	 * @see StartTransform(), StopTransform()
	 */
	public function MirrorV($y=null) {
		$this->Scale(100, -100, null, $y);
	}

	/**
	 * Point reflection mirroring.
	 * @param float|null $x abscissa of the point. Default is current x position
	 * @param float|null $y ordinate of the point. Default is current y position
	 * @public
	 * @since 2.1.000 (2008-01-07)
	 * @see StartTransform(), StopTransform()
	 */
	public function MirrorP($x=null,$y=null) {
		$this->Scale(-100, -100, $x, $y);
	}

	/**
	 * Reflection against a straight line through point (x, y) with the gradient angle (angle).
	 * @param float $angle gradient angle of the straight line. Default is 0 (horizontal line).
	 * @param float|null $x abscissa of the point. Default is current x position
	 * @param float|null $y ordinate of the point. Default is current y position
	 * @public
	 * @since 2.1.000 (2008-01-07)
	 * @see StartTransform(), StopTransform()
	 */
	public function MirrorL($angle=0, $x=null,$y=null) {
		$this->Scale(-100, 100, $x, $y);
		$this->Rotate(-2*($angle-90), $x, $y);
	}

	/**
	 * Translate graphic object horizontally.
	 * @param int $t_x movement to the right (or left for RTL)
	 * @public
	 * @since 2.1.000 (2008-01-07)
	 * @see StartTransform(), StopTransform()
	 */
	public function TranslateX($t_x) {
		$this->Translate($t_x, 0);
	}

	/**
	 * Translate graphic object vertically.
	 * @param int $t_y movement to the bottom
	 * @public
	 * @since 2.1.000 (2008-01-07)
	 * @see StartTransform(), StopTransform()
	 */
	public function TranslateY($t_y) {
		$this->Translate(0, $t_y);
	}

	/**
	 * Translate graphic object horizontally and vertically.
	 * @param int $t_x movement to the right
	 * @param int $t_y movement to the bottom
	 * @public
	 * @since 2.1.000 (2008-01-07)
	 * @see StartTransform(), StopTransform()
	 */
	public function Translate($t_x, $t_y) {
		//calculate elements of transformation matrix
		$tm = array();
		$tm[0] = 1;
		$tm[1] = 0;
		$tm[2] = 0;
		$tm[3] = 1;
		$tm[4] = $t_x * $this->k;
		$tm[5] = -$t_y * $this->k;
		//translate the coordinate system
		$this->Transform($tm);
	}

	/**
	 * Rotate object.
	 * @param float $angle angle in degrees for counter-clockwise rotation
	 * @param float|null $x abscissa of the rotation center. Default is current x position
	 * @param float|null $y ordinate of the rotation center. Default is current y position
	 * @public
	 * @since 2.1.000 (2008-01-07)
	 * @see StartTransform(), StopTransform()
	 */
	public function Rotate($angle, $x=null, $y=null) {
		if (TCPDF_STATIC::empty_string($x)) {
			$x = $this->x;
		}
		if (TCPDF_STATIC::empty_string($y)) {
			$y = $this->y;
		}
		$y = ($this->h - $y) * $this->k;
		$x *= $this->k;
		//calculate elements of transformation matrix
		$tm = array();
		$tm[0] = cos(deg2rad($angle));
		$tm[1] = sin(deg2rad($angle));
		$tm[2] = -$tm[1];
		$tm[3] = $tm[0];
		$tm[4] = $x + ($tm[1] * $y) - ($tm[0] * $x);
		$tm[5] = $y - ($tm[0] * $y) - ($tm[1] * $x);
		//rotate the coordinate system around ($x,$y)
		$this->Transform($tm);
	}

	/**
	 * Skew horizontally.
	 * @param float $angle_x angle in degrees between -90 (skew to the left) and 90 (skew to the right)
	 * @param float|null $x abscissa of the skewing center. default is current x position
	 * @param float|null $y ordinate of the skewing center. default is current y position
	 * @public
	 * @since 2.1.000 (2008-01-07)
	 * @see StartTransform(), StopTransform()
	 */
	public function SkewX($angle_x, $x=null, $y=null) {
		$this->Skew($angle_x, 0, $x, $y);
	}

	/**
	 * Skew vertically.
	 * @param float $angle_y angle in degrees between -90 (skew to the bottom) and 90 (skew to the top)
	 * @param float|null $x abscissa of the skewing center. default is current x position
	 * @param float|null $y ordinate of the skewing center. default is current y position
	 * @public
	 * @since 2.1.000 (2008-01-07)
	 * @see StartTransform(), StopTransform()
	 */
	public function SkewY($angle_y, $x=null, $y=null) {
		$this->Skew(0, $angle_y, $x, $y);
	}

	/**
	 * Skew.
	 * @param float $angle_x angle in degrees between -90 (skew to the left) and 90 (skew to the right)
	 * @param float $angle_y angle in degrees between -90 (skew to the bottom) and 90 (skew to the top)
	 * @param float|null $x abscissa of the skewing center. default is current x position
	 * @param float|null $y ordinate of the skewing center. default is current y position
	 * @public
	 * @since 2.1.000 (2008-01-07)
	 * @see StartTransform(), StopTransform()
	 */
	public function Skew($angle_x, $angle_y, $x=null, $y=null) {
		if (TCPDF_STATIC::empty_string($x)) {
			$x = $this->x;
		}
		if (TCPDF_STATIC::empty_string($y)) {
			$y = $this->y;
		}
		if (($angle_x <= -90) OR ($angle_x >= 90) OR ($angle_y <= -90) OR ($angle_y >= 90)) {
			$this->Error('Please use values between -90 and +90 degrees for Skewing.');
		}
		$x *= $this->k;
		$y = ($this->h - $y) * $this->k;
		//calculate elements of transformation matrix
		$tm = array();
		$tm[0] = 1;
		$tm[1] = tan(deg2rad($angle_y));
		$tm[2] = tan(deg2rad($angle_x));
		$tm[3] = 1;
		$tm[4] = -$tm[2] * $y;
		$tm[5] = -$tm[1] * $x;
		//skew the coordinate system
		$this->Transform($tm);
	}

	/**
	 * Apply graphic transformations.
	 * @param array $tm transformation matrix
	 * @protected
	 * @since 2.1.000 (2008-01-07)
	 * @see StartTransform(), StopTransform()
	 */
	protected function Transform($tm) {
		if ($this->state != 2) {
			return;
		}
		$this->_out(sprintf('%F %F %F %F %F %F cm', $tm[0], $tm[1], $tm[2], $tm[3], $tm[4], $tm[5]));
		// add tranformation matrix
		$this->transfmatrix[$this->transfmatrix_key][] = array('a' => $tm[0], 'b' => $tm[1], 'c' => $tm[2], 'd' => $tm[3], 'e' => $tm[4], 'f' => $tm[5]);
		// update transformation mark
		if ($this->inxobj) {
			// we are inside an XObject template
			if (end($this->xobjects[$this->xobjid]['transfmrk']) !== false) {
				$key = key($this->xobjects[$this->xobjid]['transfmrk']);
				$this->xobjects[$this->xobjid]['transfmrk'][$key] = strlen($this->xobjects[$this->xobjid]['outdata']);
			}
		} elseif (end($this->transfmrk[$this->page]) !== false) {
			$key = key($this->transfmrk[$this->page]);
			$this->transfmrk[$this->page][$key] = $this->pagelen[$this->page];
		}
	}

	// END TRANSFORMATIONS SECTION -------------------------

	// START GRAPHIC FUNCTIONS SECTION ---------------------
	// The following section is based on the code provided by David Hernandez Sanz

	/**
	 * Defines the line width. By default, the value equals 0.2 mm. The method can be called before the first page is created and the value is retained from page to page.
	 * @param float $width The width.
	 * @public
	 * @since 1.0
	 * @see Line(), Rect(), Cell(), MultiCell()
	 */
	public function setLineWidth($width) {
		//Set line width
		$this->LineWidth = $width;
		$this->linestyleWidth = sprintf('%F w', ($width * $this->k));
		if ($this->state == 2) {
			$this->_out($this->linestyleWidth);
		}
	}

	/**
	 * Returns the current the line width.
	 * @return int Line width
	 * @public
	 * @since 2.1.000 (2008-01-07)
	 * @see Line(), SetLineWidth()
	 */
	public function GetLineWidth() {
		return $this->LineWidth;
	}

	/**
	 * Set line style.
	 * @param array $style Line style. Array with keys among the following:
	 * <ul>
	 *	 <li>width (float): Width of the line in user units.</li>
	 *	 <li>cap (string): Type of cap to put on the line. Possible values are:
	 * butt, round, square. The difference between ""square"" and ""butt"" is that
	 * ""square"" projects a flat end past the end of the line.</li>
	 *	 <li>join (string): Type of join. Possible values are: miter, round,
	 * bevel.</li>
	 *	 <li>dash (mixed): Dash pattern. Is 0 (without dash) or string with
	 * series of length values, which are the lengths of the on and off dashes.
	 * For example: ""2"" represents 2 on, 2 off, 2 on, 2 off, ...; ""2,1"" is 2 on,
	 * 1 off, 2 on, 1 off, ...</li>
	 *	 <li>phase (integer): Modifier on the dash pattern which is used to shift
	 * the point at which the pattern starts.</li>
	 *	 <li>color (array): Draw color. Format: array(GREY) or array(R,G,B) or array(C,M,Y,K) or array(C,M,Y,K,SpotColorName).</li>
	 * </ul>
	 * @param boolean $ret if true do not send the command.
	 * @return string the PDF command
	 * @public
	 * @since 2.1.000 (2008-01-08)
	 */
	public function setLineStyle($style, $ret=false) {
		$s = ''; // string to be returned
		if (!is_array($style)) {
			return $s;
		}
		if (isset($style['width'])) {
			$this->LineWidth = $style['width'];
			$this->linestyleWidth = sprintf('%F w', ($style['width'] * $this->k));
			$s .= $this->linestyleWidth.' ';
		}
		if (isset($style['cap'])) {
			$ca = array('butt' => 0, 'round'=> 1, 'square' => 2);
			if (isset($ca[$style['cap']])) {
				$this->linestyleCap = $ca[$style['cap']].' J';
				$s .= $this->linestyleCap.' ';
			}
		}
		if (isset($style['join'])) {
			$ja = array('miter' => 0, 'round' => 1, 'bevel' => 2);
			if (isset($ja[$style['join']])) {
				$this->linestyleJoin = $ja[$style['join']].' j';
				$s .= $this->linestyleJoin.' ';
			}
		}
		if (isset($style['dash'])) {
			$dash_string = '';
			if ($style['dash']) {
				if (preg_match('/^.+,/', $style['dash']) > 0) {
					$tab = explode(',', $style['dash']);
				} else {
					$tab = array($style['dash']);
				}
				$dash_string = '';
				foreach ($tab as $i => $v) {
					if ($i) {
						$dash_string .= ' ';
					}
					$dash_string .= sprintf('%F', $v);
				}
			}
			if (!isset($style['phase']) OR !$style['dash']) {
				$style['phase'] = 0;
			}
			$this->linestyleDash = sprintf('[%s] %F d', $dash_string, $style['phase']);
			$s .= $this->linestyleDash.' ';
		}
		if (isset($style['color'])) {
			$s .= $this->setDrawColorArray($style['color'], true).' ';
		}
		if (!$ret AND ($this->state == 2)) {
			$this->_out($s);
		}
		return $s;
	}

	/**
	 * Begin a new subpath by moving the current point to coordinates (x, y), omitting any connecting line segment.
	 * @param float $x Abscissa of point.
	 * @param float $y Ordinate of point.
	 * @protected
	 * @since 2.1.000 (2008-01-08)
	 */
	protected function _outPoint($x, $y) {
		if ($this->state == 2) {
			$this->_out(sprintf('%F %F m', ($x * $this->k), (($this->h - $y) * $this->k)));
		}
	}

	/**
	 * Append a straight line segment from the current point to the point (x, y).
	 * The new current point shall be (x, y).
	 * @param float $x Abscissa of end point.
	 * @param float $y Ordinate of end point.
	 * @protected
	 * @since 2.1.000 (2008-01-08)
	 */
	protected function _outLine($x, $y) {
		if ($this->state == 2) {
			$this->_out(sprintf('%F %F l', ($x * $this->k), (($this->h - $y) * $this->k)));
		}
	}

	/**
	 * Append a rectangle to the current path as a complete subpath, with lower-left corner (x, y) and dimensions widthand height in user space.
	 * @param float $x Abscissa of upper-left corner.
	 * @param float $y Ordinate of upper-left corner.
	 * @param float $w Width.
	 * @param float $h Height.
	 * @param string $op options
	 * @protected
	 * @since 2.1.000 (2008-01-08)
	 */
	protected function _outRect($x, $y, $w, $h, $op) {
		if ($this->state == 2) {
			$this->_out(sprintf('%F %F %F %F re %s', ($x * $this->k), (($this->h - $y) * $this->k), ($w * $this->k), (-$h * $this->k), $op));
		}
	}

	/**
	 * Append a cubic Bezier curve to the current path. The curve shall extend from the current point to the point (x3, y3), using (x1, y1) and (x2, y2) as the Bezier control points.
	 * The new current point shall be (x3, y3).
	 * @param float $x1 Abscissa of control point 1.
	 * @param float $y1 Ordinate of control point 1.
	 * @param float $x2 Abscissa of control point 2.
	 * @param float $y2 Ordinate of control point 2.
	 * @param float $x3 Abscissa of end point.
	 * @param float $y3 Ordinate of end point.
	 * @protected
	 * @since 2.1.000 (2008-01-08)
	 */
	protected function _outCurve($x1, $y1, $x2, $y2, $x3, $y3) {
		if ($this->state == 2) {
			$this->_out(sprintf('%F %F %F %F %F %F c', ($x1 * $this->k), (($this->h - $y1) * $this->k), ($x2 * $this->k), (($this->h - $y2) * $this->k), ($x3 * $this->k), (($this->h - $y3) * $this->k)));
		}
	}

	/**
	 * Append a cubic Bezier curve to the current path. The curve shall extend from the current point to the point (x3, y3), using the current point and (x2, y2) as the Bezier control points.
	 * The new current point shall be (x3, y3).
	 * @param float $x2 Abscissa of control point 2.
	 * @param float $y2 Ordinate of control point 2.
	 * @param float $x3 Abscissa of end point.
	 * @param float $y3 Ordinate of end point.
	 * @protected
	 * @since 4.9.019 (2010-04-26)
	 */
	protected function _outCurveV($x2, $y2, $x3, $y3) {
		if ($this->state == 2) {
			$this->_out(sprintf('%F %F %F %F v', ($x2 * $this->k), (($this->h - $y2) * $this->k), ($x3 * $this->k), (($this->h - $y3) * $this->k)));
		}
	}

	/**
	 * Append a cubic Bezier curve to the current path. The curve shall extend from the current point to the point (x3, y3), using (x1, y1) and (x3, y3) as the Bezier control points.
	 * The new current point shall be (x3, y3).
	 * @param float $x1 Abscissa of control point 1.
	 * @param float $y1 Ordinate of control point 1.
	 * @param float $x3 Abscissa of end point.
	 * @param float $y3 Ordinate of end point.
	 * @protected
	 * @since 2.1.000 (2008-01-08)
	 */
	protected function _outCurveY($x1, $y1, $x3, $y3) {
		if ($this->state == 2) {
			$this->_out(sprintf('%F %F %F %F y', ($x1 * $this->k), (($this->h - $y1) * $this->k), ($x3 * $this->k), (($this->h - $y3) * $this->k)));
		}
	}

	/**
	 * Draws a line between two points.
	 * @param float $x1 Abscissa of first point.
	 * @param float $y1 Ordinate of first point.
	 * @param float $x2 Abscissa of second point.
	 * @param float $y2 Ordinate of second point.
	 * @param array $style Line style. Array like for SetLineStyle(). Default value: default line style (empty array).
	 * @public
	 * @since 1.0
	 * @see SetLineWidth(), SetDrawColor(), SetLineStyle()
	 */
	public function Line($x1, $y1, $x2, $y2, $style=array()) {
		if ($this->state != 2) {
			return;
		}
		if (is_array($style)) {
			$this->setLineStyle($style);
		}
		$this->_outPoint($x1, $y1);
		$this->_outLine($x2, $y2);
		$this->_out('S');
	}

	/**
	 * Draws a rectangle.
	 * @param float $x Abscissa of upper-left corner.
	 * @param float $y Ordinate of upper-left corner.
	 * @param float $w Width.
	 * @param float $h Height.
	 * @param string $style Style of rendering. See the getPathPaintOperator() function for more information.
	 * @param array $border_style Border style of rectangle. Array with keys among the following:
	 * <ul>
	 *	 <li>all: Line style of all borders. Array like for SetLineStyle().</li>
	 *	 <li>L, T, R, B or combinations: Line style of left, top, right or bottom border. Array like for SetLineStyle().</li>
	 * </ul>
	 * If a key is not present or is null, the correspondent border is not drawn. Default value: default line style (empty array).
	 * @param array $fill_color Fill color. Format: array(GREY) or array(R,G,B) or array(C,M,Y,K) or array(C,M,Y,K,SpotColorName). Default value: default color (empty array).
	 * @public
	 * @since 1.0
	 * @see SetLineStyle()
	 */
	public function Rect($x, $y, $w, $h, $style='', $border_style=array(), $fill_color=array()) {
		if ($this->state != 2) {
			return;
		}
		if (empty($style)) {
			$style = 'S';
		}
		if (!(strpos($style, 'F') === false) AND !empty($fill_color)) {
			// set background color
			$this->setFillColorArray($fill_color);
		}
		if (!empty($border_style)) {
			if (isset($border_style['all']) AND !empty($border_style['all'])) {
				//set global style for border
				$this->setLineStyle($border_style['all']);
				$border_style = array();
			} else {
				// remove stroke operator from style
				$opnostroke = array('S' => '', 'D' => '', 's' => '', 'd' => '', 'B' => 'F', 'FD' => 'F', 'DF' => 'F', 'B*' => 'F*', 'F*D' => 'F*', 'DF*' => 'F*', 'b' => 'f', 'fd' => 'f', 'df' => 'f', 'b*' => 'f*', 'f*d' => 'f*', 'df*' => 'f*' );
				if (isset($opnostroke[$style])) {
					$style = $opnostroke[$style];
				}
			}
		}
		if (!empty($style)) {
			$op = TCPDF_STATIC::getPathPaintOperator($style);
			$this->_outRect($x, $y, $w, $h, $op);
		}
		if (!empty($border_style)) {
			$border_style2 = array();
			foreach ($border_style as $line => $value) {
				$length = strlen($line);
				for ($i = 0; $i < $length; ++$i) {
					$border_style2[$line[$i]] = $value;
				}
			}
			$border_style = $border_style2;
			if (isset($border_style['L']) AND $border_style['L']) {
				$this->Line($x, $y, $x, $y + $h, $border_style['L']);
			}
			if (isset($border_style['T']) AND $border_style['T']) {
				$this->Line($x, $y, $x + $w, $y, $border_style['T']);
			}
			if (isset($border_style['R']) AND $border_style['R']) {
				$this->Line($x + $w, $y, $x + $w, $y + $h, $border_style['R']);
			}
			if (isset($border_style['B']) AND $border_style['B']) {
				$this->Line($x, $y + $h, $x + $w, $y + $h, $border_style['B']);
			}
		}
	}

	/**
	 * Draws a Bezier curve.
	 * The Bezier curve is a tangent to the line between the control points at
	 * either end of the curve.
	 * @param float $x0 Abscissa of start point.
	 * @param float $y0 Ordinate of start point.
	 * @param float $x1 Abscissa of control point 1.
	 * @param float $y1 Ordinate of control point 1.
	 * @param float $x2 Abscissa of control point 2.
	 * @param float $y2 Ordinate of control point 2.
	 * @param float $x3 Abscissa of end point.
	 * @param float $y3 Ordinate of end point.
	 * @param string $style Style of rendering. See the getPathPaintOperator() function for more information.
	 * @param array $line_style Line style of curve. Array like for SetLineStyle(). Default value: default line style (empty array).
	 * @param array $fill_color Fill color. Format: array(GREY) or array(R,G,B) or array(C,M,Y,K) or array(C,M,Y,K,SpotColorName). Default value: default color (empty array).
	 * @public
	 * @see SetLineStyle()
	 * @since 2.1.000 (2008-01-08)
	 */
	public function Curve($x0, $y0, $x1, $y1, $x2, $y2, $x3, $y3, $style='', $line_style=array(), $fill_color=array()) {
		if ($this->state != 2) {
			return;
		}
		if (!(false === strpos($style, 'F')) AND is_array($fill_color)) {
			$this->setFillColorArray($fill_color);
		}
		$op = TCPDF_STATIC::getPathPaintOperator($style);
		if ($line_style) {
			$this->setLineStyle($line_style);
		}
		$this->_outPoint($x0, $y0);
		$this->_outCurve($x1, $y1, $x2, $y2, $x3, $y3);
		$this->_out($op);
	}

	/**
	 * Draws a poly-Bezier curve.
	 * Each Bezier curve segment is a tangent to the line between the control points at
	 * either end of the curve.
	 * @param float $x0 Abscissa of start point.
	 * @param float $y0 Ordinate of start point.
	 * @param float[] $segments An array of bezier descriptions. Format: array(x1, y1, x2, y2, x3, y3).
	 * @param string $style Style of rendering. See the getPathPaintOperator() function for more information.
	 * @param array $line_style Line style of curve. Array like for SetLineStyle(). Default value: default line style (empty array).
	 * @param array $fill_color Fill color. Format: array(GREY) or array(R,G,B) or array(C,M,Y,K) or array(C,M,Y,K,SpotColorName). Default value: default color (empty array).
	 * @public
	 * @see SetLineStyle()
	 * @since 3.0008 (2008-05-12)
	 */
	public function Polycurve($x0, $y0, $segments, $style='', $line_style=array(), $fill_color=array()) {
		if ($this->state != 2) {
			return;
		}
		if (!(false === strpos($style, 'F')) AND is_array($fill_color)) {
			$this->setFillColorArray($fill_color);
		}
		$op = TCPDF_STATIC::getPathPaintOperator($style);
		if ($op == 'f') {
			$line_style = array();
		}
		if ($line_style) {
			$this->setLineStyle($line_style);
		}
		$this->_outPoint($x0, $y0);
		foreach ($segments as $segment) {
			list($x1, $y1, $x2, $y2, $x3, $y3) = $segment;
			$this->_outCurve($x1, $y1, $x2, $y2, $x3, $y3);
		}
		$this->_out($op);
	}

	/**
	 * Draws an ellipse.
	 * An ellipse is formed from n Bezier curves.
	 * @param float $x0 Abscissa of center point.
	 * @param float $y0 Ordinate of center point.
	 * @param float $rx Horizontal radius.
	 * @param float $ry Vertical radius (if ry = 0 then is a circle, see Circle()). Default value: 0.
	 * @param float $angle Angle oriented (anti-clockwise). Default value: 0.
	 * @param float $astart Angle start of draw line. Default value: 0.
	 * @param float $afinish Angle finish of draw line. Default value: 360.
	 * @param string $style Style of rendering. See the getPathPaintOperator() function for more information.
	 * @param array $line_style Line style of ellipse. Array like for SetLineStyle(). Default value: default line style (empty array).
	 * @param array $fill_color Fill color. Format: array(GREY) or array(R,G,B) or array(C,M,Y,K) or array(C,M,Y,K,SpotColorName). Default value: default color (empty array).
	 * @param integer $nc Number of curves used to draw a 90 degrees portion of ellipse.
	 * @author Nicola Asuni
	 * @public
	 * @since 2.1.000 (2008-01-08)
	 */
	public function Ellipse($x0, $y0, $rx, $ry=0, $angle=0, $astart=0, $afinish=360, $style='', $line_style=array(), $fill_color=array(), $nc=2) {
		if ($this->state != 2) {
			return;
		}
		if (TCPDF_STATIC::empty_string($ry) OR ($ry == 0)) {
			$ry = $rx;
		}
		if (!(false === strpos($style, 'F')) AND is_array($fill_color)) {
			$this->setFillColorArray($fill_color);
		}
		$op = TCPDF_STATIC::getPathPaintOperator($style);
		if ($op == 'f') {
			$line_style = array();
		}
		if ($line_style) {
			$this->setLineStyle($line_style);
		}
		$this->_outellipticalarc($x0, $y0, $rx, $ry, $angle, $astart, $afinish, false, $nc, true, true, false);
		$this->_out($op);
	}

	/**
	 * Append an elliptical arc to the current path.
	 * An ellipse is formed from n Bezier curves.
	 * @param float $xc Abscissa of center point.
	 * @param float $yc Ordinate of center point.
	 * @param float $rx Horizontal radius.
	 * @param float $ry Vertical radius (if ry = 0 then is a circle, see Circle()). Default value: 0.
	 * @param float $xang Angle between the X-axis and the major axis of the ellipse. Default value: 0.
	 * @param float $angs Angle start of draw line. Default value: 0.
	 * @param float $angf Angle finish of draw line. Default value: 360.
	 * @param boolean $pie if true do not mark the border point (used to draw pie sectors).
	 * @param integer $nc Number of curves used to draw a 90 degrees portion of ellipse.
	 * @param boolean $startpoint if true output a starting point.
	 * @param boolean $ccw if true draws in counter-clockwise.
	 * @param boolean $svg if true the angles are in svg mode (already calculated).
	 * @return array bounding box coordinates (x min, y min, x max, y max)
	 * @author Nicola Asuni
	 * @protected
	 * @since 4.9.019 (2010-04-26)
	 */
	protected function _outellipticalarc($xc, $yc, $rx, $ry, $xang=0, $angs=0, $angf=360, $pie=false, $nc=2, $startpoint=true, $ccw=true, $svg=false) {
		if (($rx <= 0) OR ($ry < 0)) {
			return;
		}
		$k = $this->k;
		if ($nc < 2) {
			$nc = 2;
		}
		$xmin = 2147483647;
		$ymin = 2147483647;
		$xmax = 0;
		$ymax = 0;
		if ($pie) {
			// center of the arc
			$this->_outPoint($xc, $yc);
		}
		$xang = deg2rad((float) $xang);
		$angs = deg2rad((float) $angs);
		$angf = deg2rad((float) $angf);
		if ($svg) {
			$as = $angs;
			$af = $angf;
		} else {
			$as = atan2((sin($angs) / $ry), (cos($angs) / $rx));
			$af = atan2((sin($angf) / $ry), (cos($angf) / $rx));
		}
		if ($as < 0) {
			$as += (2 * M_PI);
		}
		if ($af < 0) {
			$af += (2 * M_PI);
		}
		if ($ccw AND ($as > $af)) {
			// reverse rotation
			$as -= (2 * M_PI);
		} elseif (!$ccw AND ($as < $af)) {
			// reverse rotation
			$af -= (2 * M_PI);
		}
		$total_angle = ($af - $as);
		if ($nc < 2) {
			$nc = 2;
		}
		// total arcs to draw
		$nc *= (2 * abs($total_angle) / M_PI);
		$nc = round($nc) + 1;
		// angle of each arc
		$arcang = ($total_angle / $nc);
		// center point in PDF coordinates
		$x0 = $xc;
		$y0 = ($this->h - $yc);
		// starting angle
		$ang = $as;
		$alpha = sin($arcang) * ((sqrt(4 + (3 * pow(tan(($arcang) / 2), 2))) - 1) / 3);
		$cos_xang = cos($xang);
		$sin_xang = sin($xang);
		$cos_ang = cos($ang);
		$sin_ang = sin($ang);
		// first arc point
		$px1 = $x0 + ($rx * $cos_xang * $cos_ang) - ($ry * $sin_xang * $sin_ang);
		$py1 = $y0 + ($rx * $sin_xang * $cos_ang) + ($ry * $cos_xang * $sin_ang);
		// first Bezier control point
		$qx1 = ($alpha * ((-$rx * $cos_xang * $sin_ang) - ($ry * $sin_xang * $cos_ang)));
		$qy1 = ($alpha * ((-$rx * $sin_xang * $sin_ang) + ($ry * $cos_xang * $cos_ang)));
		if ($pie) {
			// line from center to arc starting point
			$this->_outLine($px1, $this->h - $py1);
		} elseif ($startpoint) {
			// arc starting point
			$this->_outPoint($px1, $this->h - $py1);
		}
		// draw arcs
		for ($i = 1; $i <= $nc; ++$i) {
			// starting angle
			$ang = $as + ($i * $arcang);
			if ($i == $nc) {
				$ang = $af;
			}
			$cos_ang = cos($ang);
			$sin_ang = sin($ang);
			// second arc point
			$px2 = $x0 + ($rx * $cos_xang * $cos_ang) - ($ry * $sin_xang * $sin_ang);
			$py2 = $y0 + ($rx * $sin_xang * $cos_ang) + ($ry * $cos_xang * $sin_ang);
			// second Bezier control point
			$qx2 = ($alpha * ((-$rx * $cos_xang * $sin_ang) - ($ry * $sin_xang * $cos_ang)));
			$qy2 = ($alpha * ((-$rx * $sin_xang * $sin_ang) + ($ry * $cos_xang * $cos_ang)));
			// draw arc
			$cx1 = ($px1 + $qx1);
			$cy1 = ($this->h - ($py1 + $qy1));
			$cx2 = ($px2 - $qx2);
			$cy2 = ($this->h - ($py2 - $qy2));
			$cx3 = $px2;
			$cy3 = ($this->h - $py2);
			$this->_outCurve($cx1, $cy1, $cx2, $cy2, $cx3, $cy3);
			// get bounding box coordinates
			$xmin = min($xmin, $cx1, $cx2, $cx3);
			$ymin = min($ymin, $cy1, $cy2, $cy3);
			$xmax = max($xmax, $cx1, $cx2, $cx3);
			$ymax = max($ymax, $cy1, $cy2, $cy3);
			// move to next point
			$px1 = $px2;
			$py1 = $py2;
			$qx1 = $qx2;
			$qy1 = $qy2;
		}
		if ($pie) {
			$this->_outLine($xc, $yc);
			// get bounding box coordinates
			$xmin = min($xmin, $xc);
			$ymin = min($ymin, $yc);
			$xmax = max($xmax, $xc);
			$ymax = max($ymax, $yc);
		}
		return array($xmin, $ymin, $xmax, $ymax);
	}

	/**
	 * Draws a circle.
	 * A circle is formed from n Bezier curves.
	 * @param float $x0 Abscissa of center point.
	 * @param float $y0 Ordinate of center point.
	 * @param float $r Radius.
	 * @param float $angstr Angle start of draw line. Default value: 0.
	 * @param float $angend Angle finish of draw line. Default value: 360.
	 * @param string $style Style of rendering. See the getPathPaintOperator() function for more information.
	 * @param array $line_style Line style of circle. Array like for SetLineStyle(). Default value: default line style (empty array).
	 * @param array $fill_color Fill color. Format: array(red, green, blue). Default value: default color (empty array).
	 * @param integer $nc Number of curves used to draw a 90 degrees portion of circle.
	 * @public
	 * @since 2.1.000 (2008-01-08)
	 */
	public function Circle($x0, $y0, $r, $angstr=0, $angend=360, $style='', $line_style=array(), $fill_color=array(), $nc=2) {
		$this->Ellipse($x0, $y0, $r, $r, 0, $angstr, $angend, $style, $line_style, $fill_color, $nc);
	}

	/**
	 * Draws a polygonal line
	 * @param array $p Points 0 to ($np - 1). Array with values (x0, y0, x1, y1,..., x(np-1), y(np - 1))
	 * @param string $style Style of rendering. See the getPathPaintOperator() function for more information.
	 * @param array $line_style Line style of polygon. Array with keys among the following:
	 * <ul>
	 *	 <li>all: Line style of all lines. Array like for SetLineStyle().</li>
	 *	 <li>0 to ($np - 1): Line style of each line. Array like for SetLineStyle().</li>
	 * </ul>
	 * If a key is not present or is null, not draws the line. Default value is default line style (empty array).
	 * @param array $fill_color Fill color. Format: array(GREY) or array(R,G,B) or array(C,M,Y,K) or array(C,M,Y,K,SpotColorName). Default value: default color (empty array).
	 * @since 4.8.003 (2009-09-15)
	 * @public
	 */
	public function PolyLine($p, $style='', $line_style=array(), $fill_color=array()) {
		$this->Polygon($p, $style, $line_style, $fill_color, false);
	}

	/**
	 * Draws a polygon.
	 * @param array $p Points 0 to ($np - 1). Array with values (x0, y0, x1, y1,..., x(np-1), y(np - 1))
	 * @param string $style Style of rendering. See the getPathPaintOperator() function for more information.
	 * @param array $line_style Line style of polygon. Array with keys among the following:
	 * <ul>
	 *	 <li>all: Line style of all lines. Array like for SetLineStyle().</li>
	 *	 <li>0 to ($np - 1): Line style of each line. Array like for SetLineStyle().</li>
	 * </ul>
	 * If a key is not present or is null, not draws the line. Default value is default line style (empty array).
	 * @param array $fill_color Fill color. Format: array(GREY) or array(R,G,B) or array(C,M,Y,K) or array(C,M,Y,K,SpotColorName). Default value: default color (empty array).
	 * @param boolean $closed if true the polygon is closes, otherwise will remain open
	 * @public
	 * @since 2.1.000 (2008-01-08)
	 */
	public function Polygon($p, $style='', $line_style=array(), $fill_color=array(), $closed=true) {
		if ($this->state != 2) {
			return;
		}
		$nc = count($p); // number of coordinates
		$np = $nc / 2; // number of points
		if ($closed) {
			// close polygon by adding the first 2 points at the end (one line)
			for ($i = 0; $i < 4; ++$i) {
				$p[$nc + $i] = $p[$i];
			}
			// copy style for the last added line
			if (isset($line_style[0])) {
				$line_style[$np] = $line_style[0];
			}
			$nc += 4;
		}
		if (!(false === strpos($style, 'F')) AND is_array($fill_color)) {
			$this->setFillColorArray($fill_color);
		}
		$op = TCPDF_STATIC::getPathPaintOperator($style);
		if ($op == 'f') {
			$line_style = array();
		}
		$draw = true;
		if ($line_style) {
			if (isset($line_style['all'])) {
				$this->setLineStyle($line_style['all']);
			} else {
				$draw = false;
				if ($op == 'B') {
					// draw fill
					$op = 'f';
					$this->_outPoint($p[0], $p[1]);
					for ($i = 2; $i < $nc; $i = $i + 2) {
						$this->_outLine($p[$i], $p[$i + 1]);
					}
					$this->_out($op);
				}
				// draw outline
				$this->_outPoint($p[0], $p[1]);
				for ($i = 2; $i < $nc; $i = $i + 2) {
					$line_num = ($i / 2) - 1;
					if (isset($line_style[$line_num])) {
						if ($line_style[$line_num] != 0) {
							if (is_array($line_style[$line_num])) {
								$this->_out('S');
								$this->setLineStyle($line_style[$line_num]);
								$this->_outPoint($p[$i - 2], $p[$i - 1]);
								$this->_outLine($p[$i], $p[$i + 1]);
								$this->_out('S');
								$this->_outPoint($p[$i], $p[$i + 1]);
							} else {
								$this->_outLine($p[$i], $p[$i + 1]);
							}
						}
					} else {
						$this->_outLine($p[$i], $p[$i + 1]);
					}
				}
				$this->_out($op);
			}
		}
		if ($draw) {
			$this->_outPoint($p[0], $p[1]);
			for ($i = 2; $i < $nc; $i = $i + 2) {
				$this->_outLine($p[$i], $p[$i + 1]);
			}
			$this->_out($op);
		}
	}

	/**
	 * Draws a regular polygon.
	 * @param float $x0 Abscissa of center point.
	 * @param float $y0 Ordinate of center point.
	 * @param float $r Radius of inscribed circle.
	 * @param integer $ns Number of sides.
	 * @param float $angle Angle oriented (anti-clockwise). Default value: 0.
	 * @param boolean $draw_circle Draw inscribed circle or not. Default value: false.
	 * @param string $style Style of rendering. See the getPathPaintOperator() function for more information.
	 * @param array $line_style Line style of polygon sides. Array with keys among the following:
	 * <ul>
	 *	 <li>all: Line style of all sides. Array like for SetLineStyle().</li>
	 *	 <li>0 to ($ns - 1): Line style of each side. Array like for SetLineStyle().</li>
	 * </ul>
	 * If a key is not present or is null, not draws the side. Default value is default line style (empty array).
	 * @param array $fill_color Fill color. Format: array(red, green, blue). Default value: default color (empty array).
	 * @param string $circle_style Style of rendering of inscribed circle (if draws). Possible values are:
	 * <ul>
	 *	 <li>D or empty string: Draw (default).</li>
	 *	 <li>F: Fill.</li>
	 *	 <li>DF or FD: Draw and fill.</li>
	 *	 <li>CNZ: Clipping mode (using the even-odd rule to determine which regions lie inside the clipping path).</li>
	 *	 <li>CEO: Clipping mode (using the nonzero winding number rule to determine which regions lie inside the clipping path).</li>
	 * </ul>
	 * @param array $circle_outLine_style Line style of inscribed circle (if draws). Array like for SetLineStyle(). Default value: default line style (empty array).
	 * @param array $circle_fill_color Fill color of inscribed circle (if draws). Format: array(red, green, blue). Default value: default color (empty array).
	 * @public
	 * @since 2.1.000 (2008-01-08)
	 */
	public function RegularPolygon($x0, $y0, $r, $ns, $angle=0, $draw_circle=false, $style='', $line_style=array(), $fill_color=array(), $circle_style='', $circle_outLine_style=array(), $circle_fill_color=array()) {
		if (3 > $ns) {
			$ns = 3;
		}
		if ($draw_circle) {
			$this->Circle($x0, $y0, $r, 0, 360, $circle_style, $circle_outLine_style, $circle_fill_color);
		}
		$p = array();
		for ($i = 0; $i < $ns; ++$i) {
			$a = $angle + ($i * 360 / $ns);
			$a_rad = deg2rad((float) $a);
			$p[] = $x0 + ($r * sin($a_rad));
			$p[] = $y0 + ($r * cos($a_rad));
		}
		$this->Polygon($p, $style, $line_style, $fill_color);
	}

	/**
	 * Draws a star polygon
	 * @param float $x0 Abscissa of center point.
	 * @param float $y0 Ordinate of center point.
	 * @param float $r Radius of inscribed circle.
	 * @param integer $nv Number of vertices.
	 * @param integer $ng Number of gap (if ($ng % $nv = 1) then is a regular polygon).
	 * @param float $angle Angle oriented (anti-clockwise). Default value: 0.
	 * @param boolean $draw_circle Draw inscribed circle or not. Default value is false.
	 * @param string $style Style of rendering. See the getPathPaintOperator() function for more information.
	 * @param array $line_style Line style of polygon sides. Array with keys among the following:
	 * <ul>
	 *	 <li>all: Line style of all sides. Array like for
	 * SetLineStyle().</li>
	 *	 <li>0 to (n - 1): Line style of each side. Array like for SetLineStyle().</li>
	 * </ul>
	 * If a key is not present or is null, not draws the side. Default value is default line style (empty array).
	 * @param array $fill_color Fill color. Format: array(red, green, blue). Default value: default color (empty array).
	 * @param string $circle_style Style of rendering of inscribed circle (if draws). Possible values are:
	 * <ul>
	 *	 <li>D or empty string: Draw (default).</li>
	 *	 <li>F: Fill.</li>
	 *	 <li>DF or FD: Draw and fill.</li>
	 *	 <li>CNZ: Clipping mode (using the even-odd rule to determine which regions lie inside the clipping path).</li>
	 *	 <li>CEO: Clipping mode (using the nonzero winding number rule to determine which regions lie inside the clipping path).</li>
	 * </ul>
	 * @param array $circle_outLine_style Line style of inscribed circle (if draws). Array like for SetLineStyle(). Default value: default line style (empty array).
	 * @param array $circle_fill_color Fill color of inscribed circle (if draws). Format: array(red, green, blue). Default value: default color (empty array).
	 * @public
	 * @since 2.1.000 (2008-01-08)
	 */
	public function StarPolygon($x0, $y0, $r, $nv, $ng, $angle=0, $draw_circle=false, $style='', $line_style=array(), $fill_color=array(), $circle_style='', $circle_outLine_style=array(), $circle_fill_color=array()) {
		if ($nv < 2) {
			$nv = 2;
		}
		if ($draw_circle) {
			$this->Circle($x0, $y0, $r, 0, 360, $circle_style, $circle_outLine_style, $circle_fill_color);
		}
		$p2 = array();
		$visited = array();
		for ($i = 0; $i < $nv; ++$i) {
			$a = $angle + ($i * 360 / $nv);
			$a_rad = deg2rad((float) $a);
			$p2[] = $x0 + ($r * sin($a_rad));
			$p2[] = $y0 + ($r * cos($a_rad));
			$visited[] = false;
		}
		$p = array();
		$i = 0;
		do {
			$p[] = $p2[$i * 2];
			$p[] = $p2[($i * 2) + 1];
			$visited[$i] = true;
			$i += $ng;
			$i %= $nv;
		} while (!$visited[$i]);
		$this->Polygon($p, $style, $line_style, $fill_color);
	}

	/**
	 * Draws a rounded rectangle.
	 * @param float $x Abscissa of upper-left corner.
	 * @param float $y Ordinate of upper-left corner.
	 * @param float $w Width.
	 * @param float $h Height.
	 * @param float $r the radius of the circle used to round off the corners of the rectangle.
	 * @param string $round_corner Draws rounded corner or not. String with a 0 (not rounded i-corner) or 1 (rounded i-corner) in i-position. Positions are, in order and begin to 0: top right, bottom right, bottom left and top left. Default value: all rounded corner (""1111"").
	 * @param string $style Style of rendering. See the getPathPaintOperator() function for more information.
	 * @param array $border_style Border style of rectangle. Array like for SetLineStyle(). Default value: default line style (empty array).
	 * @param array $fill_color Fill color. Format: array(GREY) or array(R,G,B) or array(C,M,Y,K) or array(C,M,Y,K,SpotColorName). Default value: default color (empty array).
	 * @public
	 * @since 2.1.000 (2008-01-08)
	 */
	public function RoundedRect($x, $y, $w, $h, $r, $round_corner='1111', $style='', $border_style=array(), $fill_color=array()) {
		$this->RoundedRectXY($x, $y, $w, $h, $r, $r, $round_corner, $style, $border_style, $fill_color);
	}

	/**
	 * Draws a rounded rectangle.
	 * @param float $x Abscissa of upper-left corner.
	 * @param float $y Ordinate of upper-left corner.
	 * @param float $w Width.
	 * @param float $h Height.
	 * @param float $rx the x-axis radius of the ellipse used to round off the corners of the rectangle.
	 * @param float $ry the y-axis radius of the ellipse used to round off the corners of the rectangle.
	 * @param string $round_corner Draws rounded corner or not. String with a 0 (not rounded i-corner) or 1 (rounded i-corner) in i-position. Positions are, in order and begin to 0: top right, bottom right, bottom left and top left. Default value: all rounded corner (""1111"").
	 * @param string $style Style of rendering. See the getPathPaintOperator() function for more information.
	 * @param array $border_style Border style of rectangle. Array like for SetLineStyle(). Default value: default line style (empty array).
	 * @param array $fill_color Fill color. Format: array(GREY) or array(R,G,B) or array(C,M,Y,K) or array(C,M,Y,K,SpotColorName). Default value: default color (empty array).
	 * @public
	 * @since 4.9.019 (2010-04-22)
	 */
	public function RoundedRectXY($x, $y, $w, $h, $rx, $ry, $round_corner='1111', $style='', $border_style=array(), $fill_color=array()) {
		if ($this->state != 2) {
			return;
		}
		if (($round_corner == '0000') OR (($rx == $ry) AND ($rx == 0))) {
			// Not rounded
			$this->Rect($x, $y, $w, $h, $style, $border_style, $fill_color);
			return;
		}
		// Rounded
		if (!(false === strpos($style, 'F')) AND is_array($fill_color)) {
			$this->setFillColorArray($fill_color);
		}
		$op = TCPDF_STATIC::getPathPaintOperator($style);
		if ($op == 'f') {
			$border_style = array();
		}
		if ($border_style) {
			$this->setLineStyle($border_style);
		}
		$MyArc = 4 / 3 * (sqrt(2) - 1);
		$this->_outPoint($x + $rx, $y);
		$xc = $x + $w - $rx;
		$yc = $y + $ry;
		$this->_outLine($xc, $y);
		if ($round_corner[0]) {
			$this->_outCurve($xc + ($rx * $MyArc), $yc - $ry, $xc + $rx, $yc - ($ry * $MyArc), $xc + $rx, $yc);
		} else {
			$this->_outLine($x + $w, $y);
		}
		$xc = $x + $w - $rx;
		$yc = $y + $h - $ry;
		$this->_outLine($x + $w, $yc);
		if ($round_corner[1]) {
			$this->_outCurve($xc + $rx, $yc + ($ry * $MyArc), $xc + ($rx * $MyArc), $yc + $ry, $xc, $yc + $ry);
		} else {
			$this->_outLine($x + $w, $y + $h);
		}
		$xc = $x + $rx;
		$yc = $y + $h - $ry;
		$this->_outLine($xc, $y + $h);
		if ($round_corner[2]) {
			$this->_outCurve($xc - ($rx * $MyArc), $yc + $ry, $xc - $rx, $yc + ($ry * $MyArc), $xc - $rx, $yc);
		} else {
			$this->_outLine($x, $y + $h);
		}
		$xc = $x + $rx;
		$yc = $y + $ry;
		$this->_outLine($x, $yc);
		if ($round_corner[3]) {
			$this->_outCurve($xc - $rx, $yc - ($ry * $MyArc), $xc - ($rx * $MyArc), $yc - $ry, $xc, $yc - $ry);
		} else {
			$this->_outLine($x, $y);
			$this->_outLine($x + $rx, $y);
		}
		$this->_out($op);
	}

	/**
	 * Draws a grahic arrow.
	 * @param float $x0 Abscissa of first point.
	 * @param float $y0 Ordinate of first point.
	 * @param float $x1 Abscissa of second point.
	 * @param float $y1 Ordinate of second point.
	 * @param int $head_style (0 = draw only arrowhead arms, 1 = draw closed arrowhead, but no fill, 2 = closed and filled arrowhead, 3 = filled arrowhead)
	 * @param float $arm_size length of arrowhead arms
	 * @param int $arm_angle angle between an arm and the shaft
	 * @author Piotr Galecki, Nicola Asuni, Andy Meier
	 * @since 4.6.018 (2009-07-10)
	 */
	public function Arrow($x0, $y0, $x1, $y1, $head_style=0, $arm_size=5, $arm_angle=15) {
		// getting arrow direction angle
		// 0 deg angle is when both arms go along X axis. angle grows clockwise.
		$dir_angle = atan2(($y0 - $y1), ($x0 - $x1));
		if ($dir_angle < 0) {
			$dir_angle += (2 * M_PI);
		}
		$arm_angle = deg2rad($arm_angle);
		$sx1 = $x1;
		$sy1 = $y1;
		if ($head_style > 0) {
			// calculate the stopping point for the arrow shaft
			$sx1 = $x1 + (($arm_size - $this->LineWidth) * cos($dir_angle));
			$sy1 = $y1 + (($arm_size - $this->LineWidth) * sin($dir_angle));
		}
		// main arrow line / shaft
		$this->Line($x0, $y0, $sx1, $sy1);
		// left arrowhead arm tip
		$x2L = $x1 + ($arm_size * cos($dir_angle + $arm_angle));
		$y2L = $y1 + ($arm_size * sin($dir_angle + $arm_angle));
		// right arrowhead arm tip
		$x2R = $x1 + ($arm_size * cos($dir_angle - $arm_angle));
		$y2R = $y1 + ($arm_size * sin($dir_angle - $arm_angle));
		$mode = 'D';
		$style = array();
		switch ($head_style) {
			case 0: {
				// draw only arrowhead arms
				$mode = 'D';
				$style = array(1, 1, 0);
				break;
			}
			case 1: {
				// draw closed arrowhead, but no fill
				$mode = 'D';
				break;
			}
			case 2: {
				// closed and filled arrowhead
				$mode = 'DF';
				break;
			}
			case 3: {
				// filled arrowhead
				$mode = 'F';
				break;
			}
		}
		$this->Polygon(array($x2L, $y2L, $x1, $y1, $x2R, $y2R), $mode, $style, array());
	}

	// END GRAPHIC FUNCTIONS SECTION -----------------------

	/**
	 * Add a Named Destination.
	 * NOTE: destination names are unique, so only last entry will be saved.
	 * @param string $name Destination name.
	 * @param float $y Y position in user units of the destiantion on the selected page (default = -1 = current position; 0 = page start;).
	 * @param int|string $page Target page number (leave empty for current page). If you prefix a page number with the * character, then this page will not be changed when adding/deleting/moving pages.
	 * @param float $x X position in user units of the destiantion on the selected page (default = -1 = current position;).
	 * @return string|false Stripped named destination identifier or false in case of error.
	 * @public
	 * @author Christian Deligant, Nicola Asuni
	 * @since 5.9.097 (2011-06-23)
	 */
	public function setDestination($name, $y=-1, $page='', $x=-1) {
		// remove unsupported characters
		$name = TCPDF_STATIC::encodeNameObject($name);
		if (TCPDF_STATIC::empty_string($name)) {
			return false;
		}
		if ($y == -1) {
			$y = $this->GetY();
		} elseif ($y < 0) {
			$y = 0;
		} elseif ($y > $this->h) {
			$y = $this->h;
		}
		if ($x == -1) {
			$x = $this->GetX();
		} elseif ($x < 0) {
			$x = 0;
		} elseif ($x > $this->w) {
			$x = $this->w;
		}
		$fixed = false;
		if (!empty($page) AND (substr($page, 0, 1) == '*')) {
			$page = intval(substr($page, 1));
			// this page number will not be changed when moving/add/deleting pages
			$fixed = true;
		}
		if (empty($page)) {
			$page = $this->PageNo();
			if (empty($page)) {
				return;
			}
		}
		$this->dests[$name] = array('x' => $x, 'y' => $y, 'p' => $page, 'f' => $fixed);
		return $name;
	}

	/**
	 * Return the Named Destination array.
	 * @return array Named Destination array.
	 * @public
	 * @author Nicola Asuni
	 * @since 5.9.097 (2011-06-23)
	 */
	public function getDestination() {
		return $this->dests;
	}

	/**
	 * Insert Named Destinations.
	 * @protected
	 * @author Johannes G\FCntert, Nicola Asuni
	 * @since 5.9.098 (2011-06-23)
	 */
	protected function _putdests() {
		if (empty($this->dests)) {
			return;
		}
		$this->n_dests = $this->_newobj();
		$out = ' <<';
		foreach($this->dests as $name => $o) {
			$out .= ' /'.$name.' '.sprintf('[%u 0 R /XYZ %F %F null]', $this->page_obj_id[($o['p'])], ($o['x'] * $this->k), ($this->pagedim[$o['p']]['h'] - ($o['y'] * $this->k)));
		}
		$out .= ' >>';
		$out .= ""\n"".'endobj';
		$this->_out($out);
	}

	/**
	 * Adds a bookmark - alias for Bookmark().
	 * @param string $txt Bookmark description.
	 * @param int $level Bookmark level (minimum value is 0).
	 * @param float $y Y position in user units of the bookmark on the selected page (default = -1 = current position; 0 = page start;).
	 * @param int|string $page Target page number (leave empty for current page). If you prefix a page number with the * character, then this page will not be changed when adding/deleting/moving pages.
	 * @param string $style Font style: B = Bold, I = Italic, BI = Bold + Italic.
	 * @param array $color RGB color array (values from 0 to 255).
	 * @param float $x X position in user units of the bookmark on the selected page (default = -1 = current position;).
	 * @param mixed $link URL, or numerical link ID, or named destination (# character followed by the destination name), or embedded file (* character followed by the file name).
	 * @public
	 */
	public function setBookmark($txt, $level=0, $y=-1, $page='', $style='', $color=array(0,0,0), $x=-1, $link='') {
		$this->Bookmark($txt, $level, $y, $page, $style, $color, $x, $link);
	}

	/**
	 * Adds a bookmark.
	 * @param string $txt Bookmark description.
	 * @param int $level Bookmark level (minimum value is 0).
	 * @param float $y Y position in user units of the bookmark on the selected page (default = -1 = current position; 0 = page start;).
	 * @param int|string $page Target page number (leave empty for current page). If you prefix a page number with the * character, then this page will not be changed when adding/deleting/moving pages.
	 * @param string $style Font style: B = Bold, I = Italic, BI = Bold + Italic.
	 * @param array $color RGB color array (values from 0 to 255).
	 * @param float $x X position in user units of the bookmark on the selected page (default = -1 = current position;).
	 * @param mixed $link URL, or numerical link ID, or named destination (# character followed by the destination name), or embedded file (* character followed by the file name).
	 * @public
	 * @since 2.1.002 (2008-02-12)
	 */
	public function Bookmark($txt, $level=0, $y=-1, $page='', $style='', $color=array(0,0,0), $x=-1, $link='') {
		if ($level < 0) {
			$level = 0;
		}
		if (isset($this->outlines[0])) {
			$lastoutline = end($this->outlines);
			$maxlevel = $lastoutline['l'] + 1;
		} else {
			$maxlevel = 0;
		}
		if ($level > $maxlevel) {
			$level = $maxlevel;
		}
		if ($y == -1) {
			$y = $this->GetY();
		} elseif ($y < 0) {
			$y = 0;
		} elseif ($y > $this->h) {
			$y = $this->h;
		}
		if ($x == -1) {
			$x = $this->GetX();
		} elseif ($x < 0) {
			$x = 0;
		} elseif ($x > $this->w) {
			$x = $this->w;
		}
		$fixed = false;
		$pageAsString = (string) $page;
		if ($pageAsString && $pageAsString[0] == '*') {
			$page = intval(substr($page, 1));
			// this page number will not be changed when moving/add/deleting pages
			$fixed = true;
		}
		if (empty($page)) {
			$page = $this->PageNo();
			if (empty($page)) {
				return;
			}
		}
		$this->outlines[] = array('t' => $txt, 'l' => $level, 'x' => $x, 'y' => $y, 'p' => $page, 'f' => $fixed, 's' => strtoupper($style), 'c' => $color, 'u' => $link);
	}

	/**
	 * Sort bookmarks for page and key.
	 * @protected
	 * @since 5.9.119 (2011-09-19)
	 */
	protected function sortBookmarks() {
		// get sorting columns
		$outline_p = array();
		$outline_y = array();
		foreach ($this->outlines as $key => $row) {
			$outline_p[$key] = $row['p'];
			$outline_k[$key] = $key;
		}
		// sort outlines by page and original position
		array_multisort($outline_p, SORT_NUMERIC, SORT_ASC, $outline_k, SORT_NUMERIC, SORT_ASC, $this->outlines);
	}

	/**
	 * Create a bookmark PDF string.
	 * @protected
	 * @author Olivier Plathey, Nicola Asuni
	 * @since 2.1.002 (2008-02-12)
	 */
	protected function _putbookmarks() {
		$nb = count($this->outlines);
		if ($nb == 0) {
			return;
		}
		// sort bookmarks
		$this->sortBookmarks();
		$lru = array();
		$level = 0;
		foreach ($this->outlines as $i => $o) {
			if ($o['l'] > 0) {
				$parent = $lru[($o['l'] - 1)];
				//Set parent and last pointers
				$this->outlines[$i]['parent'] = $parent;
				$this->outlines[$parent]['last'] = $i;
				if ($o['l'] > $level) {
					//Level increasing: set first pointer
					$this->outlines[$parent]['first'] = $i;
				}
			} else {
				$this->outlines[$i]['parent'] = $nb;
			}
			if (($o['l'] <= $level) AND ($i > 0)) {
				//Set prev and next pointers
				$prev = $lru[$o['l']];
				$this->outlines[$prev]['next'] = $i;
				$this->outlines[$i]['prev'] = $prev;
			}
			$lru[$o['l']] = $i;
			$level = $o['l'];
		}
		//Outline items
		$n = $this->n + 1;
		$nltags = '/<br[\s]?\/>|<\/(blockquote|dd|dl|div|dt|h1|h2|h3|h4|h5|h6|hr|li|ol|p|pre|ul|tcpdf|table|tr|td)>/si';
		foreach ($this->outlines as $i => $o) {
			$oid = $this->_newobj();
			// covert HTML title to string
			$title = preg_replace($nltags, ""\n"", $o['t']);
			$title = preg_replace(""/[\r]+/si"", '', $title);
			$title = preg_replace(""/[\n]+/si"", ""\n"", $title);
			$title = strip_tags($title);
			$title = $this->stringTrim($title);
			$out = '<</Title '.$this->_textstring($title, $oid);
			$out .= ' /Parent '.($n + $o['parent']).' 0 R';
			if (isset($o['prev'])) {
				$out .= ' /Prev '.($n + $o['prev']).' 0 R';
			}
			if (isset($o['next'])) {
				$out .= ' /Next '.($n + $o['next']).' 0 R';
			}
			if (isset($o['first'])) {
				$out .= ' /First '.($n + $o['first']).' 0 R';
			}
			if (isset($o['last'])) {
				$out .= ' /Last '.($n + $o['last']).' 0 R';
			}
			if (isset($o['u']) AND !empty($o['u'])) {
				// link
				if (is_string($o['u'])) {
					if ($o['u'][0] == '#') {
						// internal destination
						$out .= ' /Dest /'.TCPDF_STATIC::encodeNameObject(substr($o['u'], 1));
					} elseif ($o['u'][0] == '%') {
						// embedded PDF file
						$filename = basename(substr($o['u'], 1));
						$out .= ' /A <</S /GoToE /D [0 /Fit] /NewWindow true /T << /R /C /P '.($o['p'] - 1).' /A '.$this->embeddedfiles[$filename]['a'].' >> >>';
					} elseif ($o['u'][0] == '*') {
						// embedded generic file
						$filename = basename(substr($o['u'], 1));
						$jsa = 'var D=event.target.doc;var MyData=D.dataObjects;for (var i in MyData) if (MyData[i].path==""'.$filename.'"") D.exportDataObject( { cName : MyData[i].name, nLaunch : 2});';
						$out .= ' /A <</S /JavaScript /JS '.$this->_textstring($jsa, $oid).'>>';
					} else {
						// external URI link
						$out .= ' /A <</S /URI /URI '.$this->_datastring($this->unhtmlentities($o['u']), $oid).'>>';
					}
				} elseif (isset($this->links[$o['u']])) {
					// internal link ID
					$l = $this->links[$o['u']];
					if (isset($this->page_obj_id[($l['p'])])) {
						$out .= sprintf(' /Dest [%u 0 R /XYZ 0 %F null]', $this->page_obj_id[($l['p'])], ($this->pagedim[$l['p']]['h'] - ($l['y'] * $this->k)));
					}
				}
			} elseif (isset($this->page_obj_id[($o['p'])])) {
				// link to a page
				$out .= ' '.sprintf('/Dest [%u 0 R /XYZ %F %F null]', $this->page_obj_id[($o['p'])], ($o['x'] * $this->k), ($this->pagedim[$o['p']]['h'] - ($o['y'] * $this->k)));
			}
			// set font style
			$style = 0;
			if (!empty($o['s'])) {
				// bold
				if (strpos($o['s'], 'B') !== false) {
					$style |= 2;
				}
				// oblique
				if (strpos($o['s'], 'I') !== false) {
					$style |= 1;
				}
			}
			$out .= sprintf(' /F %d', $style);
			// set bookmark color
			if (isset($o['c']) AND is_array($o['c']) AND (count($o['c']) == 3)) {
				$color = array_values($o['c']);
				$out .= sprintf(' /C [%F %F %F]', ($color[0] / 255), ($color[1] / 255), ($color[2] / 255));
			} else {
				// black
				$out .= ' /C [0.0 0.0 0.0]';
			}
			$out .= ' /Count 0'; // normally closed item
			$out .= ' >>';
			$out .= ""\n"".'endobj';
			$this->_out($out);
		}
		//Outline root
		$this->OutlineRoot = $this->_newobj();
		$this->_out('<< /Type /Outlines /First '.$n.' 0 R /Last '.($n + $lru[0]).' 0 R >>'.""\n"".'endobj');
	}

	// --- JAVASCRIPT ------------------------------------------------------

	/**
	 * Adds a javascript
	 * @param string $script Javascript code
	 * @public
	 * @author Johannes G\FCntert, Nicola Asuni
	 * @since 2.1.002 (2008-02-12)
	 */
	public function IncludeJS($script) {
		$this->javascript .= $script;
	}

	/**
	 * Adds a javascript object and return object ID
	 * @param string $script Javascript code
	 * @param boolean $onload if true executes this object when opening the document
	 * @return int internal object ID
	 * @public
	 * @author Nicola Asuni
	 * @since 4.8.000 (2009-09-07)
	 */
	public function addJavascriptObject($script, $onload=false) {
		if ($this->pdfa_mode) {
			// javascript is not allowed in PDF/A mode
			return false;
		}
		++$this->n;
		$this->js_objects[$this->n] = array('n' => $this->n, 'js' => $script, 'onload' => $onload);
		return $this->n;
	}

	/**
	 * Create a javascript PDF string.
	 * @protected
	 * @author Johannes G\FCntert, Nicola Asuni
	 * @since 2.1.002 (2008-02-12)
	 */
	protected function _putjavascript() {
		if ($this->pdfa_mode OR (empty($this->javascript) AND empty($this->js_objects))) {
			return;
		}
		if (strpos($this->javascript, 'this.addField') > 0) {
			if (!$this->ur['enabled']) {
				//$this->setUserRights();
			}
			// the following two lines are used to avoid form fields duplication after saving
			// The addField method only works when releasing user rights (UR3)
			$jsa = sprintf(""ftcpdfdocsaved=this.addField('%s','%s',%d,[%F,%F,%F,%F]);"", 'tcpdfdocsaved', 'text', 0, 0, 1, 0, 1);
			$jsb = ""getField('tcpdfdocsaved').value='saved';"";
			$this->javascript = $jsa.""\n"".$this->javascript.""\n"".$jsb;
		}
		// name tree for javascript
		$this->n_js = '<< /Names [';
		if (!empty($this->javascript)) {
			$this->n_js .= ' (EmbeddedJS) '.($this->n + 1).' 0 R';
		}
		if (!empty($this->js_objects)) {
			foreach ($this->js_objects as $key => $val) {
				if ($val['onload']) {
					$this->n_js .= ' (JS'.$key.') '.$key.' 0 R';
				}
			}
		}
		$this->n_js .= ' ] >>';
		// default Javascript object
		if (!empty($this->javascript)) {
			$obj_id = $this->_newobj();
			$out = '<< /S /JavaScript';
			$out .= ' /JS '.$this->_textstring($this->javascript, $obj_id);
			$out .= ' >>';
			$out .= ""\n"".'endobj';
			$this->_out($out);
		}
		// additional Javascript objects
		if (!empty($this->js_objects)) {
			foreach ($this->js_objects as $key => $val) {
				$out = $this->_getobj($key).""\n"".' << /S /JavaScript /JS '.$this->_textstring($val['js'], $key).' >>'.""\n"".'endobj';
				$this->_out($out);
			}
		}
	}

	/**
	 * Adds a javascript form field.
	 * @param string $type field type
	 * @param string $name field name
	 * @param int $x horizontal position
	 * @param int $y vertical position
	 * @param int $w width
	 * @param int $h height
	 * @param array $prop javascript field properties. Possible values are described on official Javascript for Acrobat API reference.
	 * @protected
	 * @author Denis Van Nuffelen, Nicola Asuni
	 * @since 2.1.002 (2008-02-12)
	 */
	protected function _addfield($type, $name, $x, $y, $w, $h, $prop) {
		if ($this->rtl) {
			$x = $x - $w;
		}
		// the followind avoid fields duplication after saving the document
		$this->javascript .= ""if (getField('tcpdfdocsaved').value != 'saved') {"";
		$k = $this->k;
		$this->javascript .= sprintf(""f"".$name.""=this.addField('%s','%s',%u,[%F,%F,%F,%F]);"", $name, $type, $this->PageNo()-1, $x*$k, ($this->h-$y)*$k+1, ($x+$w)*$k, ($this->h-$y-$h)*$k+1).""\n"";
		$this->javascript .= 'f'.$name.'.textSize='.$this->FontSizePt."";\n"";
		foreach($prop as $key => $val) {
			if (strcmp(substr($key, -5), 'Color') == 0) {
				$val = TCPDF_COLORS::_JScolor($val);
			} else {
				$val = ""'"".$val.""'"";
			}
			$this->javascript .= 'f'.$name.'.'.$key.'='.$val."";\n"";
		}
		if ($this->rtl) {
			$this->x -= $w;
		} else {
			$this->x += $w;
		}
		$this->javascript .= '}';
	}

	// --- FORM FIELDS -----------------------------------------------------



	/**
	 * Set default properties for form fields.
	 * @param array $prop javascript field properties. Possible values are described on official Javascript for Acrobat API reference.
	 * @public
	 * @author Nicola Asuni
	 * @since 4.8.000 (2009-09-06)
	 */
	public function setFormDefaultProp($prop=array()) {
		$this->default_form_prop = $prop;
	}

	/**
	 * Return the default properties for form fields.
	 * @return array $prop javascript field properties. Possible values are described on official Javascript for Acrobat API reference.
	 * @public
	 * @author Nicola Asuni
	 * @since 4.8.000 (2009-09-06)
	 */
	public function getFormDefaultProp() {
		return $this->default_form_prop;
	}

	/**
	 * Creates a text field
	 * @param string $name field name
	 * @param float $w Width of the rectangle
	 * @param float $h Height of the rectangle
	 * @param array $prop javascript field properties. Possible values are described on official Javascript for Acrobat API reference.
	 * @param array $opt annotation parameters. Possible values are described on official PDF32000_2008 reference.
	 * @param float|null $x Abscissa of the upper-left corner of the rectangle
	 * @param float|null $y Ordinate of the upper-left corner of the rectangle
	 * @param boolean $js if true put the field using JavaScript (requires Acrobat Writer to be rendered).
	 * @public
	 * @author Nicola Asuni
	 * @since 4.8.000 (2009-09-07)
	 */
	public function TextField($name, $w, $h, $prop=array(), $opt=array(), $x=null, $y=null, $js=false) {
		if (TCPDF_STATIC::empty_string($x)) {
			$x = $this->x;
		}
		if (TCPDF_STATIC::empty_string($y)) {
			$y = $this->y;
		}
		// check page for no-write regions and adapt page margins if necessary
		list($x, $y) = $this->checkPageRegions($h, $x, $y);
		if ($js) {
			$this->_addfield('text', $name, $x, $y, $w, $h, $prop);
			return;
		}
		// get default style
		$prop = array_merge($this->getFormDefaultProp(), $prop);
		// get annotation data
		$popt = TCPDF_STATIC::getAnnotOptFromJSProp($prop, $this->spot_colors, $this->rtl);
		// set default appearance stream
		$this->annotation_fonts[$this->CurrentFont['fontkey']] = $this->CurrentFont['i'];
		$fontstyle = sprintf('/F%d %F Tf %s', $this->CurrentFont['i'], $this->FontSizePt, $this->TextColor);
		$popt['da'] = $fontstyle;
		// build appearance stream
		$popt['ap'] = array();
		$popt['ap']['n'] = '/Tx BMC q '.$fontstyle.' ';
		$text = '';
		if (isset($prop['value']) AND !empty($prop['value'])) {
			$text = $prop['value'];
		} elseif (isset($opt['v']) AND !empty($opt['v'])) {
			$text = $opt['v'];
		}
		$tmpid = $this->startTemplate($w, $h, false);
		$align = '';
		if (isset($popt['q'])) {
			switch ($popt['q']) {
				case 0: {
					$align = 'L';
					break;
				}
				case 1: {
					$align = 'C';
					break;
				}
				case 2: {
					$align = 'R';
					break;
				}
				default: {
					$align = '';
					break;
				}
			}
		}
		$this->MultiCell($w, $h, $text, 0, $align, false, 0, 0, 0, true, 0, false, true, 0, 'T', false);
		$this->endTemplate();
		--$this->n;
		$popt['ap']['n'] .= $this->xobjects[$tmpid]['outdata'];
		unset($this->xobjects[$tmpid]);
		$popt['ap']['n'] .= 'Q EMC';
		// merge options
		$opt = array_merge($popt, $opt);
		// remove some conflicting options
		unset($opt['bs']);
		// set remaining annotation data
		$opt['Subtype'] = 'Widget';
		$opt['ft'] = 'Tx';
		$opt['t'] = $name;
		// Additional annotation's parameters (check _putannotsobj() method):
		//$opt['f']
		//$opt['as']
		//$opt['bs']
		//$opt['be']
		//$opt['c']
		//$opt['border']
		//$opt['h']
		//$opt['mk'];
		//$opt['mk']['r']
		//$opt['mk']['bc'];
		//$opt['mk']['bg'];
		unset($opt['mk']['ca']);
		unset($opt['mk']['rc']);
		unset($opt['mk']['ac']);
		unset($opt['mk']['i']);
		unset($opt['mk']['ri']);
		unset($opt['mk']['ix']);
		unset($opt['mk']['if']);
		//$opt['mk']['if']['sw'];
		//$opt['mk']['if']['s'];
		//$opt['mk']['if']['a'];
		//$opt['mk']['if']['fb'];
		unset($opt['mk']['tp']);
		//$opt['tu']
		//$opt['tm']
		//$opt['ff']
		//$opt['v']
		//$opt['dv']
		//$opt['a']
		//$opt['aa']
		//$opt['q']
		$this->Annotation($x, $y, $w, $h, $name, $opt, 0);
		if ($this->rtl) {
			$this->x -= $w;
		} else {
			$this->x += $w;
		}
	}

	/**
	 * Creates a RadioButton field.
	 * @param string $name Field name.
	 * @param int $w Width of the radio button.
	 * @param array $prop Javascript field properties. Possible values are described on official Javascript for Acrobat API reference.
	 * @param array $opt Annotation parameters. Possible values are described on official PDF32000_2008 reference.
	 * @param string $onvalue Value to be returned if selected.
	 * @param boolean $checked Define the initial state.
	 * @param float|null $x Abscissa of the upper-left corner of the rectangle
	 * @param float|null $y Ordinate of the upper-left corner of the rectangle
	 * @param boolean $js If true put the field using JavaScript (requires Acrobat Writer to be rendered).
	 * @public
	 * @author Nicola Asuni
	 * @since 4.8.000 (2009-09-07)
	 */
	public function RadioButton($name, $w, $prop=array(), $opt=array(), $onvalue='On', $checked=false, $x=null, $y=null, $js=false) {
		if (TCPDF_STATIC::empty_string($x)) {
			$x = $this->x;
		}
		if (TCPDF_STATIC::empty_string($y)) {
			$y = $this->y;
		}
		// check page for no-write regions and adapt page margins if necessary
		list($x, $y) = $this->checkPageRegions($w, $x, $y);
		if ($js) {
			$this->_addfield('radiobutton', $name, $x, $y, $w, $w, $prop);
			return;
		}
		if (TCPDF_STATIC::empty_string($onvalue)) {
			$onvalue = 'On';
		}
		if ($checked) {
			$defval = $onvalue;
		} else {
			$defval = 'Off';
		}
		// set font
		$font = 'zapfdingbats';
		if ($this->pdfa_mode) {
			// all fonts must be embedded
			$font = 'pdfa'.$font;
		}
		$this->AddFont($font);
		$tmpfont = $this->getFontBuffer($font);
		// set data for parent group
		if (!isset($this->radiobutton_groups[$this->page])) {
			$this->radiobutton_groups[$this->page] = array();
		}
		if (!isset($this->radiobutton_groups[$this->page][$name])) {
			$this->radiobutton_groups[$this->page][$name] = array();
			++$this->n;
			$this->radiobutton_groups[$this->page][$name]['n'] = $this->n;
			$this->radio_groups[] = $this->n;
		}
		$kid = ($this->n + 1);
		// save object ID to be added on Kids entry on parent object
		$this->radiobutton_groups[$this->page][$name][] = array('kid' => $kid, 'def' => $defval);
		// get default style
		$prop = array_merge($this->getFormDefaultProp(), $prop);
		$prop['NoToggleToOff'] = 'true';
		$prop['Radio'] = 'true';
		$prop['borderStyle'] = 'inset';
		// get annotation data
		$popt = TCPDF_STATIC::getAnnotOptFromJSProp($prop, $this->spot_colors, $this->rtl);
		// set additional default options
		$this->annotation_fonts[$tmpfont['fontkey']] = $tmpfont['i'];
		$fontstyle = sprintf('/F%d %F Tf %s', $tmpfont['i'], $this->FontSizePt, $this->TextColor);
		$popt['da'] = $fontstyle;
		// build appearance stream
		$popt['ap'] = array();
		$popt['ap']['n'] = array();
		$fx = ((($w - $this->getAbsFontMeasure($tmpfont['cw'][108])) / 2) * $this->k);
		$fy = (($w - ((($tmpfont['desc']['Ascent'] - $tmpfont['desc']['Descent']) * $this->FontSizePt / 1000) / $this->k)) * $this->k);
		$popt['ap']['n'][$onvalue] = sprintf('q %s BT /F%d %F Tf %F %F Td ('.chr(108).') Tj ET Q', $this->TextColor, $tmpfont['i'], $this->FontSizePt, $fx, $fy);
		$popt['ap']['n']['Off'] = sprintf('q %s BT /F%d %F Tf %F %F Td ('.chr(109).') Tj ET Q', $this->TextColor, $tmpfont['i'], $this->FontSizePt, $fx, $fy);
		if (!isset($popt['mk'])) {
			$popt['mk'] = array();
		}
		$popt['mk']['ca'] = '(l)';
		// merge options
		$opt = array_merge($popt, $opt);
		// set remaining annotation data
		$opt['Subtype'] = 'Widget';
		$opt['ft'] = 'Btn';
		if ($checked) {
			$opt['v'] = array('/'.$onvalue);
			$opt['as'] = $onvalue;
		} else {
			$opt['as'] = 'Off';
		}
		// store readonly flag
		if (!isset($this->radiobutton_groups[$this->page][$name]['#readonly#'])) {
			$this->radiobutton_groups[$this->page][$name]['#readonly#'] = false;
		}
		$this->radiobutton_groups[$this->page][$name]['#readonly#'] |= ($opt['f'] & 64);
		$this->Annotation($x, $y, $w, $w, $name, $opt, 0);
		if ($this->rtl) {
			$this->x -= $w;
		} else {
			$this->x += $w;
		}
	}

	/**
	 * Creates a List-box field
	 * @param string $name field name
	 * @param int $w width
	 * @param int $h height
	 * @param array $values array containing the list of values.
	 * @param array $prop javascript field properties. Possible values are described on official Javascript for Acrobat API reference.
	 * @param array $opt annotation parameters. Possible values are described on official PDF32000_2008 reference.
	 * @param float|null $x Abscissa of the upper-left corner of the rectangle
	 * @param float|null $y Ordinate of the upper-left corner of the rectangle
	 * @param boolean $js if true put the field using JavaScript (requires Acrobat Writer to be rendered).
	 * @public
	 * @author Nicola Asuni
	 * @since 4.8.000 (2009-09-07)
	 */
	public function ListBox($name, $w, $h, $values, $prop=array(), $opt=array(), $x=null, $y=null, $js=false) {
		if (TCPDF_STATIC::empty_string($x)) {
			$x = $this->x;
		}
		if (TCPDF_STATIC::empty_string($y)) {
			$y = $this->y;
		}
		// check page for no-write regions and adapt page margins if necessary
		list($x, $y) = $this->checkPageRegions($h, $x, $y);
		if ($js) {
			$this->_addfield('listbox', $name, $x, $y, $w, $h, $prop);
			$s = '';
			foreach ($values as $value) {
				if (is_array($value)) {
					$s .= ',[\''.addslashes($value[1]).'\',\''.addslashes($value[0]).'\']';
				} else {
					$s .= ',[\''.addslashes($value).'\',\''.addslashes($value).'\']';
				}
			}
			$this->javascript .= 'f'.$name.'.setItems('.substr($s, 1).');'.""\n"";
			return;
		}
		// get default style
		$prop = array_merge($this->getFormDefaultProp(), $prop);
		// get annotation data
		$popt = TCPDF_STATIC::getAnnotOptFromJSProp($prop, $this->spot_colors, $this->rtl);
		// set additional default values
		$this->annotation_fonts[$this->CurrentFont['fontkey']] = $this->CurrentFont['i'];
		$fontstyle = sprintf('/F%d %F Tf %s', $this->CurrentFont['i'], $this->FontSizePt, $this->TextColor);
		$popt['da'] = $fontstyle;
		// build appearance stream
		$popt['ap'] = array();
		$popt['ap']['n'] = '/Tx BMC q '.$fontstyle.' ';
		$text = '';
		foreach($values as $item) {
			if (is_array($item)) {
				$text .= $item[1].""\n"";
			} else {
				$text .= $item.""\n"";
			}
		}
		$tmpid = $this->startTemplate($w, $h, false);
		$this->MultiCell($w, $h, $text, 0, '', false, 0, 0, 0, true, 0, false, true, 0, 'T', false);
		$this->endTemplate();
		--$this->n;
		$popt['ap']['n'] .= $this->xobjects[$tmpid]['outdata'];
		unset($this->xobjects[$tmpid]);
		$popt['ap']['n'] .= 'Q EMC';
		// merge options
		$opt = array_merge($popt, $opt);
		// set remaining annotation data
		$opt['Subtype'] = 'Widget';
		$opt['ft'] = 'Ch';
		$opt['t'] = $name;
		$opt['opt'] = $values;
		unset($opt['mk']['ca']);
		unset($opt['mk']['rc']);
		unset($opt['mk']['ac']);
		unset($opt['mk']['i']);
		unset($opt['mk']['ri']);
		unset($opt['mk']['ix']);
		unset($opt['mk']['if']);
		unset($opt['mk']['tp']);
		$this->Annotation($x, $y, $w, $h, $name, $opt, 0);
		if ($this->rtl) {
			$this->x -= $w;
		} else {
			$this->x += $w;
		}
	}

	/**
	 * Creates a Combo-box field
	 * @param string $name field name
	 * @param int $w width
	 * @param int $h height
	 * @param array $values array containing the list of values.
	 * @param array $prop javascript field properties. Possible values are described on official Javascript for Acrobat API reference.
	 * @param array $opt annotation parameters. Possible values are described on official PDF32000_2008 reference.
	 * @param float|null $x Abscissa of the upper-left corner of the rectangle
	 * @param float|null $y Ordinate of the upper-left corner of the rectangle
	 * @param boolean $js if true put the field using JavaScript (requires Acrobat Writer to be rendered).
	 * @public
	 * @author Nicola Asuni
	 * @since 4.8.000 (2009-09-07)
	 */
	public function ComboBox($name, $w, $h, $values, $prop=array(), $opt=array(), $x=null, $y=null, $js=false) {
		if (TCPDF_STATIC::empty_string($x)) {
			$x = $this->x;
		}
		if (TCPDF_STATIC::empty_string($y)) {
			$y = $this->y;
		}
		// check page for no-write regions and adapt page margins if necessary
		list($x, $y) = $this->checkPageRegions($h, $x, $y);
		if ($js) {
			$this->_addfield('combobox', $name, $x, $y, $w, $h, $prop);
			$s = '';
			foreach ($values as $value) {
				if (is_array($value)) {
					$s .= ',[\''.addslashes($value[1]).'\',\''.addslashes($value[0]).'\']';
				} else {
					$s .= ',[\''.addslashes($value).'\',\''.addslashes($value).'\']';
				}
			}
			$this->javascript .= 'f'.$name.'.setItems('.substr($s, 1).');'.""\n"";
			return;
		}
		// get default style
		$prop = array_merge($this->getFormDefaultProp(), $prop);
		$prop['Combo'] = true;
		// get annotation data
		$popt = TCPDF_STATIC::getAnnotOptFromJSProp($prop, $this->spot_colors, $this->rtl);
		// set additional default options
		$this->annotation_fonts[$this->CurrentFont['fontkey']] = $this->CurrentFont['i'];
		$fontstyle = sprintf('/F%d %F Tf %s', $this->CurrentFont['i'], $this->FontSizePt, $this->TextColor);
		$popt['da'] = $fontstyle;
		// build appearance stream
		$popt['ap'] = array();
		$popt['ap']['n'] = '/Tx BMC q '.$fontstyle.' ';
		$text = '';
		foreach($values as $item) {
			if (is_array($item)) {
				$text .= $item[1].""\n"";
			} else {
				$text .= $item.""\n"";
			}
		}
		$tmpid = $this->startTemplate($w, $h, false);
		$this->MultiCell($w, $h, $text, 0, '', false, 0, 0, 0, true, 0, false, true, 0, 'T', false);
		$this->endTemplate();
		--$this->n;
		$popt['ap']['n'] .= $this->xobjects[$tmpid]['outdata'];
		unset($this->xobjects[$tmpid]);
		$popt['ap']['n'] .= 'Q EMC';
		// merge options
		$opt = array_merge($popt, $opt);
		// set remaining annotation data
		$opt['Subtype'] = 'Widget';
		$opt['ft'] = 'Ch';
		$opt['t'] = $name;
		$opt['opt'] = $values;
		unset($opt['mk']['ca']);
		unset($opt['mk']['rc']);
		unset($opt['mk']['ac']);
		unset($opt['mk']['i']);
		unset($opt['mk']['ri']);
		unset($opt['mk']['ix']);
		unset($opt['mk']['if']);
		unset($opt['mk']['tp']);
		$this->Annotation($x, $y, $w, $h, $name, $opt, 0);
		if ($this->rtl) {
			$this->x -= $w;
		} else {
			$this->x += $w;
		}
	}

	/**
	 * Creates a CheckBox field
	 * @param string $name field name
	 * @param int $w width
	 * @param boolean $checked define the initial state.
	 * @param array $prop javascript field properties. Possible values are described on official Javascript for Acrobat API reference.
	 * @param array $opt annotation parameters. Possible values are described on official PDF32000_2008 reference.
	 * @param string $onvalue value to be returned if selected.
	 * @param float|null $x Abscissa of the upper-left corner of the rectangle
	 * @param float|null $y Ordinate of the upper-left corner of the rectangle
	 * @param boolean $js if true put the field using JavaScript (requires Acrobat Writer to be rendered).
	 * @public
	 * @author Nicola Asuni
	 * @since 4.8.000 (2009-09-07)
	 */
	public function CheckBox($name, $w, $checked=false, $prop=array(), $opt=array(), $onvalue='Yes', $x=null, $y=null, $js=false) {
		if (TCPDF_STATIC::empty_string($x)) {
			$x = $this->x;
		}
		if (TCPDF_STATIC::empty_string($y)) {
			$y = $this->y;
		}
		// check page for no-write regions and adapt page margins if necessary
		list($x, $y) = $this->checkPageRegions($w, $x, $y);
		if ($js) {
			$this->_addfield('checkbox', $name, $x, $y, $w, $w, $prop);
			return;
		}
		if (!isset($prop['value'])) {
			$prop['value'] = array('Yes');
		}
		// get default style
		$prop = array_merge($this->getFormDefaultProp(), $prop);
		$prop['borderStyle'] = 'inset';
		// get annotation data
		$popt = TCPDF_STATIC::getAnnotOptFromJSProp($prop, $this->spot_colors, $this->rtl);
		// set additional default options
		$font = 'zapfdingbats';
		if ($this->pdfa_mode) {
			// all fonts must be embedded
			$font = 'pdfa'.$font;
		}
		$this->AddFont($font);
		$tmpfont = $this->getFontBuffer($font);
		$this->annotation_fonts[$tmpfont['fontkey']] = $tmpfont['i'];
		$fontstyle = sprintf('/F%d %F Tf %s', $tmpfont['i'], $this->FontSizePt, $this->TextColor);
		$popt['da'] = $fontstyle;
		// build appearance stream
		$popt['ap'] = array();
		$popt['ap']['n'] = array();
		$fx = ((($w - $this->getAbsFontMeasure($tmpfont['cw'][110])) / 2) * $this->k);
		$fy = (($w - ((($tmpfont['desc']['Ascent'] - $tmpfont['desc']['Descent']) * $this->FontSizePt / 1000) / $this->k)) * $this->k);
		$popt['ap']['n']['Yes'] = sprintf('q %s BT /F%d %F Tf %F %F Td ('.chr(110).') Tj ET Q', $this->TextColor, $tmpfont['i'], $this->FontSizePt, $fx, $fy);
		$popt['ap']['n']['Off'] = sprintf('q %s BT /F%d %F Tf %F %F Td ('.chr(111).') Tj ET Q', $this->TextColor, $tmpfont['i'], $this->FontSizePt, $fx, $fy);
		// merge options
		$opt = array_merge($popt, $opt);
		// set remaining annotation data
		$opt['Subtype'] = 'Widget';
		$opt['ft'] = 'Btn';
		$opt['t'] = $name;
		if (TCPDF_STATIC::empty_string($onvalue)) {
			$onvalue = 'Yes';
		}
		$opt['opt'] = array($onvalue);
		if ($checked) {
			$opt['v'] = array('/Yes');
			$opt['as'] = 'Yes';
		} else {
			$opt['v'] = array('/Off');
			$opt['as'] = 'Off';
		}
		$this->Annotation($x, $y, $w, $w, $name, $opt, 0);
		if ($this->rtl) {
			$this->x -= $w;
		} else {
			$this->x += $w;
		}
	}

	/**
	 * Creates a button field
	 * @param string $name field name
	 * @param int $w width
	 * @param int $h height
	 * @param string $caption caption.
	 * @param mixed $action action triggered by pressing the button. Use a string to specify a javascript action. Use an array to specify a form action options as on section 12.7.5 of PDF32000_2008.
	 * @param array $prop javascript field properties. Possible values are described on official Javascript for Acrobat API reference.
	 * @param array $opt annotation parameters. Possible values are described on official PDF32000_2008 reference.
	 * @param float|null $x Abscissa of the upper-left corner of the rectangle
	 * @param float|null $y Ordinate of the upper-left corner of the rectangle
	 * @param boolean $js if true put the field using JavaScript (requires Acrobat Writer to be rendered).
	 * @public
	 * @author Nicola Asuni
	 * @since 4.8.000 (2009-09-07)
	 */
	public function Button($name, $w, $h, $caption, $action, $prop=array(), $opt=array(), $x=null, $y=null, $js=false) {
		if (TCPDF_STATIC::empty_string($x)) {
			$x = $this->x;
		}
		if (TCPDF_STATIC::empty_string($y)) {
			$y = $this->y;
		}
		// check page for no-write regions and adapt page margins if necessary
		list($x, $y) = $this->checkPageRegions($h, $x, $y);
		if ($js) {
			$this->_addfield('button', $name, $this->x, $this->y, $w, $h, $prop);
			$this->javascript .= 'f'.$name."".buttonSetCaption('"".addslashes($caption).""');\n"";
			$this->javascript .= 'f'.$name."".setAction('MouseUp','"".addslashes($action).""');\n"";
			$this->javascript .= 'f'.$name."".highlight='push';\n"";
			$this->javascript .= 'f'.$name."".print=false;\n"";
			return;
		}
		// get default style
		$prop = array_merge($this->getFormDefaultProp(), $prop);
		$prop['Pushbutton'] = 'true';
		$prop['highlight'] = 'push';
		$prop['display'] = 'display.noPrint';
		// get annotation data
		$popt = TCPDF_STATIC::getAnnotOptFromJSProp($prop, $this->spot_colors, $this->rtl);
		$this->annotation_fonts[$this->CurrentFont['fontkey']] = $this->CurrentFont['i'];
		$fontstyle = sprintf('/F%d %F Tf %s', $this->CurrentFont['i'], $this->FontSizePt, $this->TextColor);
		$popt['da'] = $fontstyle;
		// build appearance stream
		$popt['ap'] = array();
		$popt['ap']['n'] = '/Tx BMC q '.$fontstyle.' ';
		$tmpid = $this->startTemplate($w, $h, false);
		$bw = (2 / $this->k); // border width
		$border = array(
			'L' => array('width' => $bw, 'cap' => 'square', 'join' => 'miter', 'dash' => 0, 'color' => array(231)),
			'R' => array('width' => $bw, 'cap' => 'square', 'join' => 'miter', 'dash' => 0, 'color' => array(51)),
			'T' => array('width' => $bw, 'cap' => 'square', 'join' => 'miter', 'dash' => 0, 'color' => array(231)),
			'B' => array('width' => $bw, 'cap' => 'square', 'join' => 'miter', 'dash' => 0, 'color' => array(51)));
		$this->setFillColor(204);
		$this->Cell($w, $h, $caption, $border, 0, 'C', true, '', 1, false, 'T', 'M');
		$this->endTemplate();
		--$this->n;
		$popt['ap']['n'] .= $this->xobjects[$tmpid]['outdata'];
		unset($this->xobjects[$tmpid]);
		$popt['ap']['n'] .= 'Q EMC';
		// set additional default options
		if (!isset($popt['mk'])) {
			$popt['mk'] = array();
		}
		$ann_obj_id = ($this->n + 1);
		if (!empty($action) AND !is_array($action)) {
			$ann_obj_id = ($this->n + 2);
		}
		$popt['mk']['ca'] = $this->_textstring($caption, $ann_obj_id);
		$popt['mk']['rc'] = $this->_textstring($caption, $ann_obj_id);
		$popt['mk']['ac'] = $this->_textstring($caption, $ann_obj_id);
		// merge options
		$opt = array_merge($popt, $opt);
		// set remaining annotation data
		$opt['Subtype'] = 'Widget';
		$opt['ft'] = 'Btn';
		$opt['t'] = $caption;
		$opt['v'] = $name;
		if (!empty($action)) {
			if (is_array($action)) {
				// form action options as on section 12.7.5 of PDF32000_2008.
				$opt['aa'] = '/D <<';
				$bmode = array('SubmitForm', 'ResetForm', 'ImportData');
				foreach ($action AS $key => $val) {
					if (($key == 'S') AND in_array($val, $bmode)) {
						$opt['aa'] .= ' /S /'.$val;
					} elseif (($key == 'F') AND (!empty($val))) {
						$opt['aa'] .= ' /F '.$this->_datastring($val, $ann_obj_id);
					} elseif (($key == 'Fields') AND is_array($val) AND !empty($val)) {
						$opt['aa'] .= ' /Fields [';
						foreach ($val AS $field) {
							$opt['aa'] .= ' '.$this->_textstring($field, $ann_obj_id);
						}
						$opt['aa'] .= ']';
					} elseif (($key == 'Flags')) {
						$ff = 0;
						if (is_array($val)) {
							foreach ($val AS $flag) {
								switch ($flag) {
									case 'Include/Exclude': {
										$ff += 1 << 0;
										break;
									}
									case 'IncludeNoValueFields': {
										$ff += 1 << 1;
										break;
									}
									case 'ExportFormat': {
										$ff += 1 << 2;
										break;
									}
									case 'GetMethod': {
										$ff += 1 << 3;
										break;
									}
									case 'SubmitCoordinates': {
										$ff += 1 << 4;
										break;
									}
									case 'XFDF': {
										$ff += 1 << 5;
										break;
									}
									case 'IncludeAppendSaves': {
										$ff += 1 << 6;
										break;
									}
									case 'IncludeAnnotations': {
										$ff += 1 << 7;
										break;
									}
									case 'SubmitPDF': {
										$ff += 1 << 8;
										break;
									}
									case 'CanonicalFormat': {
										$ff += 1 << 9;
										break;
									}
									case 'ExclNonUserAnnots': {
										$ff += 1 << 10;
										break;
									}
									case 'ExclFKey': {
										$ff += 1 << 11;
										break;
									}
									case 'EmbedForm': {
										$ff += 1 << 13;
										break;
									}
								}
							}
						} else {
							$ff = intval($val);
						}
						$opt['aa'] .= ' /Flags '.$ff;
					}
				}
				$opt['aa'] .= ' >>';
			} else {
				// Javascript action or raw action command
				$js_obj_id = $this->addJavascriptObject($action);
				$opt['aa'] = '/D '.$js_obj_id.' 0 R';
			}
		}
		$this->Annotation($x, $y, $w, $h, $name, $opt, 0);
		if ($this->rtl) {
			$this->x -= $w;
		} else {
			$this->x += $w;
		}
	}

	// --- END FORMS FIELDS ------------------------------------------------

	/**
	 * Add certification signature (DocMDP or UR3)
	 * You can set only one signature type
	 * @protected
	 * @author Nicola Asuni
	 * @since 4.6.008 (2009-05-07)
	 */
	protected function _putsignature() {
		if ((!$this->sign) OR (!isset($this->signature_data['cert_type']))) {
			return;
		}
		$sigobjid = ($this->sig_obj_id + 1);
		$out = $this->_getobj($sigobjid).""\n"";
		$out .= '<< /Type /Sig';
		$out .= ' /Filter /Adobe.PPKLite';
		$out .= ' /SubFilter /adbe.pkcs7.detached';
		$out .= ' '.TCPDF_STATIC::$byterange_string;
		$out .= ' /Contents<'.str_repeat('0', $this->signature_max_length).'>';
		if (empty($this->signature_data['approval']) OR ($this->signature_data['approval'] != 'A')) {
			$out .= ' /Reference ['; // array of signature reference dictionaries
			$out .= ' << /Type /SigRef';
			if ($this->signature_data['cert_type'] > 0) {
				$out .= ' /TransformMethod /DocMDP';
				$out .= ' /TransformParams <<';
				$out .= ' /Type /TransformParams';
				$out .= ' /P '.$this->signature_data['cert_type'];
				$out .= ' /V /1.2';
			} else {
				$out .= ' /TransformMethod /UR3';
				$out .= ' /TransformParams <<';
				$out .= ' /Type /TransformParams';
				$out .= ' /V /2.2';
				if (!TCPDF_STATIC::empty_string($this->ur['document'])) {
					$out .= ' /Document['.$this->ur['document'].']';
				}
				if (!TCPDF_STATIC::empty_string($this->ur['form'])) {
					$out .= ' /Form['.$this->ur['form'].']';
				}
				if (!TCPDF_STATIC::empty_string($this->ur['signature'])) {
					$out .= ' /Signature['.$this->ur['signature'].']';
				}
				if (!TCPDF_STATIC::empty_string($this->ur['annots'])) {
					$out .= ' /Annots['.$this->ur['annots'].']';
				}
				if (!TCPDF_STATIC::empty_string($this->ur['ef'])) {
					$out .= ' /EF['.$this->ur['ef'].']';
				}
				if (!TCPDF_STATIC::empty_string($this->ur['formex'])) {
					$out .= ' /FormEX['.$this->ur['formex'].']';
				}
			}
			$out .= ' >>'; // close TransformParams
			// optional digest data (values must be calculated and replaced later)
			//$out .= ' /Data ********** 0 R';
			//$out .= ' /DigestMethod/MD5';
			//$out .= ' /DigestLocation[********** 34]';
			//$out .= ' /DigestValue<********************************>';
			$out .= ' >>';
			$out .= ' ]'; // end of reference
		}
		if (isset($this->signature_data['info']['Name']) AND !TCPDF_STATIC::empty_string($this->signature_data['info']['Name'])) {
			$out .= ' /Name '.$this->_textstring($this->signature_data['info']['Name'], $sigobjid);
		}
		if (isset($this->signature_data['info']['Location']) AND !TCPDF_STATIC::empty_string($this->signature_data['info']['Location'])) {
			$out .= ' /Location '.$this->_textstring($this->signature_data['info']['Location'], $sigobjid);
		}
		if (isset($this->signature_data['info']['Reason']) AND !TCPDF_STATIC::empty_string($this->signature_data['info']['Reason'])) {
			$out .= ' /Reason '.$this->_textstring($this->signature_data['info']['Reason'], $sigobjid);
		}
		if (isset($this->signature_data['info']['ContactInfo']) AND !TCPDF_STATIC::empty_string($this->signature_data['info']['ContactInfo'])) {
			$out .= ' /ContactInfo '.$this->_textstring($this->signature_data['info']['ContactInfo'], $sigobjid);
		}
		$out .= ' /M '.$this->_datestring($sigobjid, $this->doc_modification_timestamp);
		$out .= ' >>';
		$out .= ""\n"".'endobj';
		$this->_out($out);
	}

	/**
	 * Set User's Rights for PDF Reader
	 * WARNING: This is experimental and currently do not work.
	 * Check the PDF Reference 8.7.1 Transform Methods,
	 * Table 8.105 Entries in the UR transform parameters dictionary
	 * @param boolean $enable if true enable user's rights on PDF reader
	 * @param string $document Names specifying additional document-wide usage rights for the document. The only defined value is ""/FullSave"", which permits a user to save the document along with modified form and/or annotation data.
	 * @param string $annots Names specifying additional annotation-related usage rights for the document. Valid names in PDF 1.5 and later are /Create/Delete/Modify/Copy/Import/Export, which permit the user to perform the named operation on annotations.
	 * @param string $form Names specifying additional form-field-related usage rights for the document. Valid names are: /Add/Delete/FillIn/Import/Export/SubmitStandalone/SpawnTemplate
	 * @param string $signature Names specifying additional signature-related usage rights for the document. The only defined value is /Modify, which permits a user to apply a digital signature to an existing signature form field or clear a signed signature form field.
	 * @param string $ef Names specifying additional usage rights for named embedded files in the document. Valid names are /Create/Delete/Modify/Import, which permit the user to perform the named operation on named embedded files
	 Names specifying additional embedded-files-related usage rights for the document.
	 * @param string $formex Names specifying additional form-field-related usage rights. The only valid name is BarcodePlaintext, which permits text form field data to be encoded as a plaintext two-dimensional barcode.
	 * @public
	 * @author Nicola Asuni
	 * @since 2.9.000 (2008-03-26)
	 */
	public function setUserRights(
			$enable=true,
			$document='/FullSave',
			$annots='/Create/Delete/Modify/Copy/Import/Export',
			$form='/Add/Delete/FillIn/Import/Export/SubmitStandalone/SpawnTemplate',
			$signature='/Modify',
			$ef='/Create/Delete/Modify/Import',
			$formex='') {
		$this->ur['enabled'] = $enable;
		$this->ur['document'] = $document;
		$this->ur['annots'] = $annots;
		$this->ur['form'] = $form;
		$this->ur['signature'] = $signature;
		$this->ur['ef'] = $ef;
		$this->ur['formex'] = $formex;
		if (!$this->sign) {
			$this->setSignature('', '', '', '', 0, array());
		}
	}

	/**
	 * Enable document signature (requires the OpenSSL Library).
	 * The digital signature improve document authenticity and integrity and allows o enable extra features on Acrobat Reader.
	 * To create self-signed signature: openssl req -x509 -nodes -days 365000 -newkey rsa:1024 -keyout tcpdf.crt -out tcpdf.crt
	 * To export crt to p12: openssl pkcs12 -export -in tcpdf.crt -out tcpdf.p12
	 * To convert pfx certificate to pem: openssl pkcs12 -in tcpdf.pfx -out tcpdf.crt -nodes
	 * @param mixed $signing_cert signing certificate (string or filename prefixed with 'file://')
	 * @param mixed $private_key private key (string or filename prefixed with 'file://')
	 * @param string $private_key_password password
	 * @param string $extracerts specifies the name of a file containing a bunch of extra certificates to include in the signature which can for example be used to help the recipient to verify the certificate that you used.
	 * @param int $cert_type The access permissions granted for this document. Valid values shall be: 1 = No changes to the document shall be permitted; any change to the document shall invalidate the signature; 2 = Permitted changes shall be filling in forms, instantiating page templates, and signing; other changes shall invalidate the signature; 3 = Permitted changes shall be the same as for 2, as well as annotation creation, deletion, and modification; other changes shall invalidate the signature.
	 * @param array $info array of option information: Name, Location, Reason, ContactInfo.
	 * @param string $approval Enable approval signature eg. for PDF incremental update
	 * @public
	 * @author Nicola Asuni
	 * @since 4.6.005 (2009-04-24)
	 */
	public function setSignature($signing_cert='', $private_key='', $private_key_password='', $extracerts='', $cert_type=2, $info=array(), $approval='') {
		// to create self-signed signature: openssl req -x509 -nodes -days 365000 -newkey rsa:1024 -keyout tcpdf.crt -out tcpdf.crt
		// to export crt to p12: openssl pkcs12 -export -in tcpdf.crt -out tcpdf.p12
		// to convert pfx certificate to pem: openssl
		//     OpenSSL> pkcs12 -in <cert.pfx> -out <cert.crt> -nodes
		$this->sign = true;
		++$this->n;
		$this->sig_obj_id = $this->n; // signature widget
		++$this->n; // signature object ($this->sig_obj_id + 1)
		$this->signature_data = array();
		if (strlen($signing_cert) == 0) {
			$this->Error('Please provide a certificate file and password!');
		}
		if (strlen($private_key) == 0) {
			$private_key = $signing_cert;
		}
		$this->signature_data['signcert'] = $signing_cert;
		$this->signature_data['privkey'] = $private_key;
		$this->signature_data['password'] = $private_key_password;
		$this->signature_data['extracerts'] = $extracerts;
		$this->signature_data['cert_type'] = $cert_type;
		$this->signature_data['info'] = $info;
		$this->signature_data['approval'] = $approval;
	}

	/**
	 * Set the digital signature appearance (a cliccable rectangle area to get signature properties)
	 * @param float $x Abscissa of the upper-left corner.
	 * @param float $y Ordinate of the upper-left corner.
	 * @param float $w Width of the signature area.
	 * @param float $h Height of the signature area.
	 * @param int $page option page number (if < 0 the current page is used).
	 * @param string $name Name of the signature.
	 * @public
	 * @author Nicola Asuni
	 * @since 5.3.011 (2010-06-17)
	 */
	public function setSignatureAppearance($x=0, $y=0, $w=0, $h=0, $page=-1, $name='') {
		$this->signature_appearance = $this->getSignatureAppearanceArray($x, $y, $w, $h, $page, $name);
	}

	/**
	 * Add an empty digital signature appearance (a cliccable rectangle area to get signature properties)
	 * @param float $x Abscissa of the upper-left corner.
	 * @param float $y Ordinate of the upper-left corner.
	 * @param float $w Width of the signature area.
	 * @param float $h Height of the signature area.
	 * @param int $page option page number (if < 0 the current page is used).
	 * @param string $name Name of the signature.
	 * @public
	 * @author Nicola Asuni
	 * @since 5.9.101 (2011-07-06)
	 */
	public function addEmptySignatureAppearance($x=0, $y=0, $w=0, $h=0, $page=-1, $name='') {
		++$this->n;
		$this->empty_signature_appearance[] = array('objid' => $this->n) + $this->getSignatureAppearanceArray($x, $y, $w, $h, $page, $name);
	}

	/**
	 * Get the array that defines the signature appearance (page and rectangle coordinates).
	 * @param float $x Abscissa of the upper-left corner.
	 * @param float $y Ordinate of the upper-left corner.
	 * @param float $w Width of the signature area.
	 * @param float $h Height of the signature area.
	 * @param int $page option page number (if < 0 the current page is used).
	 * @param string $name Name of the signature.
	 * @return array Array defining page and rectangle coordinates of signature appearance.
	 * @protected
	 * @author Nicola Asuni
	 * @since 5.9.101 (2011-07-06)
	 */
	protected function getSignatureAppearanceArray($x=0, $y=0, $w=0, $h=0, $page=-1, $name='') {
		$sigapp = array();
		if (($page < 1) OR ($page > $this->numpages)) {
			$sigapp['page'] = $this->page;
		} else {
			$sigapp['page'] = intval($page);
		}
		if (empty($name)) {
			$sigapp['name'] = 'Signature';
		} else {
			$sigapp['name'] = $name;
		}
		$a = $x * $this->k;
		$b = $this->pagedim[($sigapp['page'])]['h'] - (($y + $h) * $this->k);
		$c = $w * $this->k;
		$d = $h * $this->k;
		$sigapp['rect'] = sprintf('%F %F %F %F', $a, $b, ($a + $c), ($b + $d));
		return $sigapp;
	}

	/**
	 * Enable document timestamping (requires the OpenSSL Library).
	 * The trusted timestamping improve document security that means that no one should be able to change the document once it has been recorded.
	 * Use with digital signature only!
	 * @param string $tsa_host Time Stamping Authority (TSA) server (prefixed with 'https://')
	 * @param string $tsa_username Specifies the username for TSA authorization (optional) OR specifies the TSA authorization PEM file (see: example_66.php, optional)
	 * @param string $tsa_password Specifies the password for TSA authorization (optional)
	 * @param string $tsa_cert Specifies the location of TSA certificate for authorization (optional for cURL)
	 * @public
	 * @author Richard Stockinger
	 * @since 6.0.090 (2014-06-16)
	 */
	public function setTimeStamp($tsa_host='', $tsa_username='', $tsa_password='', $tsa_cert='') {
		$this->tsa_data = array();
		if (!function_exists('curl_init')) {
			$this->Error('Please enable cURL PHP extension!');
		}
		if (strlen($tsa_host) == 0) {
			$this->Error('Please specify the host of Time Stamping Authority (TSA)!');
		}
		$this->tsa_data['tsa_host'] = $tsa_host;
		if (is_file($tsa_username)) {
			$this->tsa_data['tsa_auth'] = $tsa_username;
		} else {
			$this->tsa_data['tsa_username'] = $tsa_username;
		}
		$this->tsa_data['tsa_password'] = $tsa_password;
		$this->tsa_data['tsa_cert'] = $tsa_cert;
		$this->tsa_timestamp = true;
	}

	/**
	 * NOT YET IMPLEMENTED
	 * Request TSA for a timestamp
	 * @param string $signature Digital signature as binary string
	 * @return string Timestamped digital signature
	 * @protected
	 * @author Richard Stockinger
	 * @since 6.0.090 (2014-06-16)
	 */
	protected function applyTSA($signature) {
		if (!$this->tsa_timestamp) {
			return $signature;
		}
		//@TODO: implement this feature
		return $signature;
	}

	/**
	 * Create a new page group.
	 * NOTE: call this function before calling AddPage()
	 * @param int|null $page starting group page (leave empty for next page).
	 * @public
	 * @since 3.0.000 (2008-03-27)
	 */
	public function startPageGroup($page=null) {
		if (empty($page)) {
			$page = $this->page + 1;
		}
		$this->newpagegroup[$page] = sizeof($this->newpagegroup) + 1;
	}

	/**
	 * Set the starting page number.
	 * @param int $num Starting page number.
	 * @since 5.9.093 (2011-06-16)
	 * @public
	 */
	public function setStartingPageNumber($num=1) {
		$this->starting_page_number = max(0, intval($num));
	}

	/**
	 * Returns the string alias used right align page numbers.
	 * If the current font is unicode type, the returned string wil contain an additional open curly brace.
	 * @return string
	 * @since 5.9.099 (2011-06-27)
	 * @public
	 */
	public function getAliasRightShift() {
		// calculate aproximatively the ratio between widths of aliases and replacements.
		$ref = '{'.TCPDF_STATIC::$alias_right_shift.'}{'.TCPDF_STATIC::$alias_tot_pages.'}{'.TCPDF_STATIC::$alias_num_page.'}';
		$rep = str_repeat(' ', $this->GetNumChars($ref));
		$wrep = $this->GetStringWidth($rep);
		if ($wrep > 0) {
			$wdiff = max(1, ($this->GetStringWidth($ref) / $wrep));
		} else {
			$wdiff = 1;
		}
		$sdiff = sprintf('%F', $wdiff);
		$alias = TCPDF_STATIC::$alias_right_shift.$sdiff.'}';
		if ($this->isUnicodeFont()) {
			$alias = '{'.$alias;
		}
		return $alias;
	}

	/**
	 * Returns the string alias used for the total number of pages.
	 * If the current font is unicode type, the returned string is surrounded by additional curly braces.
	 * This alias will be replaced by the total number of pages in the document.
	 * @return string
	 * @since 4.0.018 (2008-08-08)
	 * @public
	 */
	public function getAliasNbPages() {
		if ($this->isUnicodeFont()) {
			return '{'.TCPDF_STATIC::$alias_tot_pages.'}';
		}
		return TCPDF_STATIC::$alias_tot_pages;
	}

	/**
	 * Returns the string alias used for the page number.
	 * If the current font is unicode type, the returned string is surrounded by additional curly braces.
	 * This alias will be replaced by the page number.
	 * @return string
	 * @since 4.5.000 (2009-01-02)
	 * @public
	 */
	public function getAliasNumPage() {
		if ($this->isUnicodeFont()) {
			return '{'.TCPDF_STATIC::$alias_num_page.'}';
		}
		return TCPDF_STATIC::$alias_num_page;
	}

	/**
	 * Return the alias for the total number of pages in the current page group.
	 * If the current font is unicode type, the returned string is surrounded by additional curly braces.
	 * This alias will be replaced by the total number of pages in this group.
	 * @return string alias of the current page group
	 * @public
	 * @since 3.0.000 (2008-03-27)
	 */
	public function getPageGroupAlias() {
		if ($this->isUnicodeFont()) {
			return '{'.TCPDF_STATIC::$alias_group_tot_pages.'}';
		}
		return TCPDF_STATIC::$alias_group_tot_pages;
	}

	/**
	 * Return the alias for the page number on the current page group.
	 * If the current font is unicode type, the returned string is surrounded by additional curly braces.
	 * This alias will be replaced by the page number (relative to the belonging group).
	 * @return string alias of the current page group
	 * @public
	 * @since 4.5.000 (2009-01-02)
	 */
	public function getPageNumGroupAlias() {
		if ($this->isUnicodeFont()) {
			return '{'.TCPDF_STATIC::$alias_group_num_page.'}';
		}
		return TCPDF_STATIC::$alias_group_num_page;
	}

	/**
	 * Return the current page in the group.
	 * @return int current page in the group
	 * @public
	 * @since 3.0.000 (2008-03-27)
	 */
	public function getGroupPageNo() {
		return $this->pagegroups[$this->currpagegroup];
	}

	/**
	 * Returns the current group page number formatted as a string.
	 * @public
	 * @since 4.3.003 (2008-11-18)
	 * @see PaneNo(), formatPageNumber()
	 */
	public function getGroupPageNoFormatted() {
		return TCPDF_STATIC::formatPageNumber($this->getGroupPageNo());
	}

	/**
	 * Returns the current page number formatted as a string.
	 * @public
	 * @since 4.2.005 (2008-11-06)
	 * @see PaneNo(), formatPageNumber()
	 */
	public function PageNoFormatted() {
		return TCPDF_STATIC::formatPageNumber($this->PageNo());
	}

	/**
	 * Put pdf layers.
	 * @protected
	 * @since 3.0.000 (2008-03-27)
	 */
	protected function _putocg() {
		if (empty($this->pdflayers)) {
			return;
		}
		foreach ($this->pdflayers as $key => $layer) {
			 $this->pdflayers[$key]['objid'] = $this->_newobj();
			 $out = '<< /Type /OCG';
			 $out .= ' /Name '.$this->_textstring($layer['name'], $this->pdflayers[$key]['objid']);
			 $out .= ' /Usage <<';
			 if (isset($layer['print']) AND ($layer['print'] !== NULL)) {
				$out .= ' /Print <</PrintState /'.($layer['print']?'ON':'OFF').'>>';
			 }
			 $out .= ' /View <</ViewState /'.($layer['view']?'ON':'OFF').'>>';
			 $out .= ' >> >>';
			 $out .= ""\n"".'endobj';
			 $this->_out($out);
		}
	}

	/**
	 * Start a new pdf layer.
	 * @param string $name Layer name (only a-z letters and numbers). Leave empty for automatic name.
	 * @param boolean|null $print Set to TRUE to print this layer, FALSE to not print and NULL to not set this option
	 * @param boolean $view Set to true to view this layer.
	 * @param boolean $lock If true lock the layer
	 * @public
	 * @since 5.9.102 (2011-07-13)
	 */
	public function startLayer($name='', $print=true, $view=true, $lock=true) {
		if ($this->state != 2) {
			return;
		}
		$layer = sprintf('LYR%03d', (count($this->pdflayers) + 1));
		if (empty($name)) {
			$name = $layer;
		} else {
			$name = preg_replace('/[^a-zA-Z0-9_\-]/', '', $name);
		}
		$this->pdflayers[] = array('layer' => $layer, 'name' => $name, 'print' => $print, 'view' => $view, 'lock' => $lock);
		$this->openMarkedContent = true;
		$this->_out('/OC /'.$layer.' BDC');
	}

	/**
	 * End the current PDF layer.
	 * @public
	 * @since 5.9.102 (2011-07-13)
	 */
	public function endLayer() {
		if ($this->state != 2) {
			return;
		}
		if ($this->openMarkedContent) {
			// close existing open marked-content layer
			$this->_out('EMC');
			$this->openMarkedContent = false;
		}
	}

	/**
	 * Set the visibility of the successive elements.
	 * This can be useful, for instance, to put a background
	 * image or color that will show on screen but won't print.
	 * @param string $v visibility mode. Legal values are: all, print, screen or view.
	 * @public
	 * @since 3.0.000 (2008-03-27)
	 */
	public function setVisibility($v) {
		if ($this->state != 2) {
			return;
		}
		$this->endLayer();
		switch($v) {
			case 'print': {
				$this->startLayer('Print', true, false);
				break;
			}
			case 'view':
			case 'screen': {
				$this->startLayer('View', false, true);
				break;
			}
			case 'all': {
				$this->_out('');
				break;
			}
			default: {
				$this->Error('Incorrect visibility: '.$v);
				break;
			}
		}
	}

	/**
	 * Add transparency parameters to the current extgstate
	 * @param array $parms parameters
	 * @return int|void the number of extgstates
	 * @protected
	 * @since 3.0.000 (2008-03-27)
	 */
	protected function addExtGState($parms) {
		if ($this->pdfa_mode || $this->pdfa_version >= 2) {
			// transparencies are not allowed in PDF/A mode
			return;
		}
		// check if this ExtGState already exist
		foreach ($this->extgstates as $i => $ext) {
			if ($ext['parms'] == $parms) {
				if ($this->inxobj) {
					// we are inside an XObject template
					$this->xobjects[$this->xobjid]['extgstates'][$i] = $ext;
				}
				// return reference to existing ExtGState
				return $i;
			}
		}
		$n = (count($this->extgstates) + 1);
		$this->extgstates[$n] = array('parms' => $parms);
		if ($this->inxobj) {
			// we are inside an XObject template
			$this->xobjects[$this->xobjid]['extgstates'][$n] = $this->extgstates[$n];
		}
		return $n;
	}

	/**
	 * Add an extgstate
	 * @param int $gs extgstate
	 * @protected
	 * @since 3.0.000 (2008-03-27)
	 */
	protected function setExtGState($gs) {
		if (($this->pdfa_mode && $this->pdfa_version < 2) OR ($this->state != 2)) {
			// transparency is not allowed in PDF/A-1 mode
			return;
		}
		$this->_out(sprintf('/GS%d gs', $gs));
	}

	/**
	 * Put extgstates for object transparency
	 * @protected
	 * @since 3.0.000 (2008-03-27)
	 */
	protected function _putextgstates() {
		foreach ($this->extgstates as $i => $ext) {
			$this->extgstates[$i]['n'] = $this->_newobj();
			$out = '<< /Type /ExtGState';
			foreach ($ext['parms'] as $k => $v) {
				if (is_float($v)) {
					$v = sprintf('%F', $v);
				} elseif ($v === true) {
					$v = 'true';
				} elseif ($v === false) {
					$v = 'false';
				}
				$out .= ' /'.$k.' '.$v;
			}
			$out .= ' >>';
			$out .= ""\n"".'endobj';
			$this->_out($out);
		}
	}

	/**
	 * Set overprint mode for stroking (OP) and non-stroking (op) painting operations.
	 * (Check the ""Entries in a Graphics State Parameter Dictionary"" on PDF 32000-1:2008).
	 * @param boolean $stroking If true apply overprint for stroking operations.
	 * @param boolean|null $nonstroking If true apply overprint for painting operations other than stroking.
	 * @param integer $mode Overprint mode: (0 = each source colour component value replaces the value previously painted for the corresponding device colorant; 1 = a tint value of 0.0 for a source colour component shall leave the corresponding component of the previously painted colour unchanged).
	 * @public
	 * @since 5.9.152 (2012-03-23)
	 */
	public function setOverprint($stroking=true, $nonstroking=null, $mode=0) {
		if ($this->state != 2) {
			return;
		}
		$stroking = $stroking ? true : false;
		if (TCPDF_STATIC::empty_string($nonstroking)) {
			// default value if not set
			$nonstroking = $stroking;
		} else {
			$nonstroking = $nonstroking ? true : false;
		}
		if (($mode != 0) AND ($mode != 1)) {
			$mode = 0;
		}
		$this->overprint = array('OP' => $stroking, 'op' => $nonstroking, 'OPM' => $mode);
		$gs = $this->addExtGState($this->overprint);
		$this->setExtGState($gs);
	}

	/**
	 * Get the overprint mode array (OP, op, OPM).
	 * (Check the ""Entries in a Graphics State Parameter Dictionary"" on PDF 32000-1:2008).
	 * @return array<string,bool|int>
	 * @public
	 * @since 5.9.152 (2012-03-23)
	 */
	public function getOverprint() {
		return $this->overprint;
	}

	/**
	 * Set alpha for stroking (CA) and non-stroking (ca) operations.
	 * @param float $stroking Alpha value for stroking operations: real value from 0 (transparent) to 1 (opaque).
	 * @param string $bm blend mode, one of the following: Normal, Multiply, Screen, Overlay, Darken, Lighten, ColorDodge, ColorBurn, HardLight, SoftLight, Difference, Exclusion, Hue, Saturation, Color, Luminosity
	 * @param float|null $nonstroking Alpha value for non-stroking operations: real value from 0 (transparent) to 1 (opaque).
	 * @param boolean $ais
	 * @public
	 * @since 3.0.000 (2008-03-27)
	 */
	public function setAlpha($stroking=1, $bm='Normal', $nonstroking=null, $ais=false) {
		if ($this->pdfa_mode && $this->pdfa_version < 2) {
			// transparency is not allowed in PDF/A-1 mode
			return;
		}
		$stroking = floatval($stroking);
		if (TCPDF_STATIC::empty_string($nonstroking)) {
			// default value if not set
			$nonstroking = $stroking;
		} else {
			$nonstroking = floatval($nonstroking);
		}
		if ($bm[0] == '/') {
			// remove trailing slash
			$bm = substr($bm, 1);
		}
		if (!in_array($bm, array('Normal', 'Multiply', 'Screen', 'Overlay', 'Darken', 'Lighten', 'ColorDodge', 'ColorBurn', 'HardLight', 'SoftLight', 'Difference', 'Exclusion', 'Hue', 'Saturation', 'Color', 'Luminosity'))) {
			$bm = 'Normal';
		}
		$ais = $ais ? true : false;
		$this->alpha = array('CA' => $stroking, 'ca' => $nonstroking, 'BM' => '/'.$bm, 'AIS' => $ais);
		$gs = $this->addExtGState($this->alpha);
		$this->setExtGState($gs);
	}

	/**
	 * Get the alpha mode array (CA, ca, BM, AIS).
	 * (Check the ""Entries in a Graphics State Parameter Dictionary"" on PDF 32000-1:2008).
	 * @return array<string,bool|string>
	 * @public
	 * @since 5.9.152 (2012-03-23)
	 */
	public function getAlpha() {
		return $this->alpha;
	}

	/**
	 * Set the default JPEG compression quality (1-100)
	 * @param int $quality JPEG quality, integer between 1 and 100
	 * @public
	 * @since 3.0.000 (2008-03-27)
	 */
	public function setJPEGQuality($quality) {
		if (($quality < 1) OR ($quality > 100)) {
			$quality = 75;
		}
		$this->jpeg_quality = intval($quality);
	}

	/**
	 * Set the default number of columns in a row for HTML tables.
	 * @param int $cols number of columns
	 * @public
	 * @since 3.0.014 (2008-06-04)
	 */
	public function setDefaultTableColumns($cols=4) {
		$this->default_table_columns = intval($cols);
	}

	/**
	 * Set the height of the cell (line height) respect the font height.
	 * @param float $h cell proportion respect font height (typical value = 1.25).
	 * @public
	 * @since 3.0.014 (2008-06-04)
	 */
	public function setCellHeightRatio($h) {
		$this->cell_height_ratio = $h;
	}

	/**
	 * return the height of cell repect font height.
	 * @public
	 * @return float
	 * @since 4.0.012 (2008-07-24)
	 */
	public function getCellHeightRatio() {
		return $this->cell_height_ratio;
	}

	/**
	 * Set the PDF version (check PDF reference for valid values).
	 * @param string $version PDF document version.
	 * @public
	 * @since 3.1.000 (2008-06-09)
	 */
	public function setPDFVersion($version='1.7') {
		if ($this->pdfa_mode && $this->pdfa_version == 1 ) {
			// PDF/A-1 mode
			$this->PDFVersion = '1.4';
		} elseif ($this->pdfa_mode && $this->pdfa_version >= 2 ) {
            // PDF/A-2 mode
            $this->PDFVersion = '1.7';
        } else {
			$this->PDFVersion = $version;
		}
	}

	/**
	 * Set the viewer preferences dictionary controlling the way the document is to be presented on the screen or in print.
	 * (see Section 8.1 of PDF reference, ""Viewer Preferences"").
	 * <ul><li>HideToolbar boolean (Optional) A flag specifying whether to hide the viewer application's tool bars when the document is active. Default value: false.</li><li>HideMenubar boolean (Optional) A flag specifying whether to hide the viewer application's menu bar when the document is active. Default value: false.</li><li>HideWindowUI boolean (Optional) A flag specifying whether to hide user interface elements in the document's window (such as scroll bars and navigation controls), leaving only the document's contents displayed. Default value: false.</li><li>FitWindow boolean (Optional) A flag specifying whether to resize the document's window to fit the size of the first displayed page. Default value: false.</li><li>CenterWindow boolean (Optional) A flag specifying whether to position the document's window in the center of the screen. Default value: false.</li><li>DisplayDocTitle boolean (Optional; PDF 1.4) A flag specifying whether the window's title bar should display the document title taken from the Title entry of the document information dictionary (see Section 10.2.1, ""Document Information Dictionary""). If false, the title bar should instead display the name of the PDF file containing the document. Default value: false.</li><li>NonFullScreenPageMode name (Optional) The document's page mode, specifying how to display the document on exiting full-screen mode:<ul><li>UseNone Neither document outline nor thumbnail images visible</li><li>UseOutlines Document outline visible</li><li>UseThumbs Thumbnail images visible</li><li>UseOC Optional content group panel visible</li></ul>This entry is meaningful only if the value of the PageMode entry in the catalog dictionary (see Section 3.6.1, ""Document Catalog"") is FullScreen; it is ignored otherwise. Default value: UseNone.</li><li>ViewArea name (Optional; PDF 1.4) The name of the page boundary representing the area of a page to be displayed when viewing the document on the screen. Valid values are (see Section 10.10.1, ""Page Boundaries"").:<ul><li>MediaBox</li><li>CropBox (default)</li><li>BleedBox</li><li>TrimBox</li><li>ArtBox</li></ul></li><li>ViewClip name (Optional; PDF 1.4) The name of the page boundary to which the contents of a page are to be clipped when viewing the document on the screen. Valid values are (see Section 10.10.1, ""Page Boundaries"").:<ul><li>MediaBox</li><li>CropBox (default)</li><li>BleedBox</li><li>TrimBox</li><li>ArtBox</li></ul></li><li>PrintArea name (Optional; PDF 1.4) The name of the page boundary representing the area of a page to be rendered when printing the document. Valid values are (see Section 10.10.1, ""Page Boundaries"").:<ul><li>MediaBox</li><li>CropBox (default)</li><li>BleedBox</li><li>TrimBox</li><li>ArtBox</li></ul></li><li>PrintClip name (Optional; PDF 1.4) The name of the page boundary to which the contents of a page are to be clipped when printing the document. Valid values are (see Section 10.10.1, ""Page Boundaries"").:<ul><li>MediaBox</li><li>CropBox (default)</li><li>BleedBox</li><li>TrimBox</li><li>ArtBox</li></ul></li><li>PrintScaling name (Optional; PDF 1.6) The page scaling option to be selected when a print dialog is displayed for this document. Valid values are: <ul><li>None, which indicates that the print dialog should reflect no page scaling</li><li>AppDefault (default), which indicates that applications should use the current print scaling</li></ul></li><li>Duplex name (Optional; PDF 1.7) The paper handling option to use when printing the file from the print dialog. The following values are valid:<ul><li>Simplex - Print single-sided</li><li>DuplexFlipShortEdge - Duplex and flip on the short edge of the sheet</li><li>DuplexFlipLongEdge - Duplex and flip on the long edge of the sheet</li></ul>Default value: none</li><li>PickTrayByPDFSize boolean (Optional; PDF 1.7) A flag specifying whether the PDF page size is used to select the input paper tray. This setting influences only the preset values used to populate the print dialog presented by a PDF viewer application. If PickTrayByPDFSize is true, the check box in the print dialog associated with input paper tray is checked. Note: This setting has no effect on Mac OS systems, which do not provide the ability to pick the input tray by size.</li><li>PrintPageRange array (Optional; PDF 1.7) The page numbers used to initialize the print dialog box when the file is printed. The first page of the PDF file is denoted by 1. Each pair consists of the first and last pages in the sub-range. An odd number of integers causes this entry to be ignored. Negative numbers cause the entire array to be ignored. Default value: as defined by PDF viewer application</li><li>NumCopies integer (Optional; PDF 1.7) The number of copies to be printed when the print dialog is opened for this file. Supported values are the integers 2 through 5. Values outside this range are ignored. Default value: as defined by PDF viewer application, but typically 1</li></ul>
	 * @param array $preferences array of options.
	 * @author Nicola Asuni
	 * @public
	 * @since 3.1.000 (2008-06-09)
	 */
	public function setViewerPreferences($preferences) {
		$this->viewer_preferences = $preferences;
	}

	/**
	 * Paints color transition registration bars
	 * @param float $x abscissa of the top left corner of the rectangle.
	 * @param float $y ordinate of the top left corner of the rectangle.
	 * @param float $w width of the rectangle.
	 * @param float $h height of the rectangle.
	 * @param boolean $transition if true prints tcolor transitions to white.
	 * @param boolean $vertical if true prints bar vertically.
	 * @param string $colors colors to print separated by comma. Valid values are: A,W,R,G,B,C,M,Y,K,RGB,CMYK,ALL,ALLSPOT,<SPOT_COLOR_NAME>. Where: A = grayscale black, W = grayscale white, R = RGB red, G RGB green, B RGB blue, C = CMYK cyan, M = CMYK magenta, Y = CMYK yellow, K = CMYK key/black, RGB = RGB registration color, CMYK = CMYK registration color, ALL = Spot registration color, ALLSPOT = print all defined spot colors, <SPOT_COLOR_NAME> = name of the spot color to print.
	 * @author Nicola Asuni
	 * @since 4.9.000 (2010-03-26)
	 * @public
	 */
	public function colorRegistrationBar($x, $y, $w, $h, $transition=true, $vertical=false, $colors='A,R,G,B,C,M,Y,K') {
		if (strpos($colors, 'ALLSPOT') !== false) {
			// expand spot colors
			$spot_colors = '';
			foreach ($this->spot_colors as $spot_color_name => $v) {
				$spot_colors .= ','.$spot_color_name;
			}
			if (!empty($spot_colors)) {
				$spot_colors = substr($spot_colors, 1);
				$colors = str_replace('ALLSPOT', $spot_colors, $colors);
			} else {
				$colors = str_replace('ALLSPOT', 'NONE', $colors);
			}
		}
		$bars = explode(',', $colors);
		$numbars = count($bars); // number of bars to print
		if ($numbars <= 0) {
			return;
		}
		// set bar measures
		if ($vertical) {
			$coords = array(0, 0, 0, 1);
			$wb = $w / $numbars; // bar width
			$hb = $h; // bar height
			$xd = $wb; // delta x
			$yd = 0; // delta y
		} else {
			$coords = array(1, 0, 0, 0);
			$wb = $w; // bar width
			$hb = $h / $numbars; // bar height
			$xd = 0; // delta x
			$yd = $hb; // delta y
		}
		$xb = $x;
		$yb = $y;
		foreach ($bars as $col) {
			switch ($col) {
				// set transition colors
				case 'A': { // BLACK (GRAYSCALE)
					$col_a = array(255);
					$col_b = array(0);
					break;
				}
				case 'W': { // WHITE (GRAYSCALE)
					$col_a = array(0);
					$col_b = array(255);
					break;
				}
				case 'R': { // RED (RGB)
					$col_a = array(255,255,255);
					$col_b = array(255,0,0);
					break;
				}
				case 'G': { // GREEN (RGB)
					$col_a = array(255,255,255);
					$col_b = array(0,255,0);
					break;
				}
				case 'B': { // BLUE (RGB)
					$col_a = array(255,255,255);
					$col_b = array(0,0,255);
					break;
				}
				case 'C': { // CYAN (CMYK)
					$col_a = array(0,0,0,0);
					$col_b = array(100,0,0,0);
					break;
				}
				case 'M': { // MAGENTA (CMYK)
					$col_a = array(0,0,0,0);
					$col_b = array(0,100,0,0);
					break;
				}
				case 'Y': { // YELLOW (CMYK)
					$col_a = array(0,0,0,0);
					$col_b = array(0,0,100,0);
					break;
				}
				case 'K': { // KEY - BLACK (CMYK)
					$col_a = array(0,0,0,0);
					$col_b = array(0,0,0,100);
					break;
				}
				case 'RGB': { // BLACK REGISTRATION (RGB)
					$col_a = array(255,255,255);
					$col_b = array(0,0,0);
					break;
				}
				case 'CMYK': { // BLACK REGISTRATION (CMYK)
					$col_a = array(0,0,0,0);
					$col_b = array(100,100,100,100);
					break;
				}
				case 'ALL': { // SPOT COLOR REGISTRATION
					$col_a = array(0,0,0,0,'None');
					$col_b = array(100,100,100,100,'All');
					break;
				}
				case 'NONE': { // SKIP THIS COLOR
					$col_a = array(0,0,0,0,'None');
					$col_b = array(0,0,0,0,'None');
					break;
				}
				default: { // SPECIFIC SPOT COLOR NAME
					$col_a = array(0,0,0,0,'None');
					$col_b = TCPDF_COLORS::getSpotColor($col, $this->spot_colors);
					if ($col_b === false) {
						// in case of error defaults to the registration color
						$col_b = array(100,100,100,100,'All');
					}
					break;
				}
			}
			if ($col != 'NONE') {
				if ($transition) {
					// color gradient
					$this->LinearGradient($xb, $yb, $wb, $hb, $col_a, $col_b, $coords);
				} else {
					$this->setFillColorArray($col_b);
					// colored rectangle
					$this->Rect($xb, $yb, $wb, $hb, 'F', array());
				}
				$xb += $xd;
				$yb += $yd;
			}
		}
	}

	/**
	 * Paints crop marks.
	 * @param float $x abscissa of the crop mark center.
	 * @param float $y ordinate of the crop mark center.
	 * @param float $w width of the crop mark.
	 * @param float $h height of the crop mark.
	 * @param string $type type of crop mark, one symbol per type separated by comma: T = TOP, F = BOTTOM, L = LEFT, R = RIGHT, TL = A = TOP-LEFT, TR = B = TOP-RIGHT, BL = C = BOTTOM-LEFT, BR = D = BOTTOM-RIGHT.
	 * @param array $color crop mark color (default spot registration color).
	 * @author Nicola Asuni
	 * @since 4.9.000 (2010-03-26)
	 * @public
	 */
	public function cropMark($x, $y, $w, $h, $type='T,R,B,L', $color=array(100,100,100,100,'All')) {
		$this->setLineStyle(array('width' => (0.5 / $this->k), 'cap' => 'butt', 'join' => 'miter', 'dash' => 0, 'color' => $color));
		$type = strtoupper($type);
		$type = preg_replace('/[^A-Z\-\,]*/', '', $type);
		// split type in single components
		$type = str_replace('-', ',', $type);
		$type = str_replace('TL', 'T,L', $type);
		$type = str_replace('TR', 'T,R', $type);
		$type = str_replace('BL', 'F,L', $type);
		$type = str_replace('BR', 'F,R', $type);
		$type = str_replace('A', 'T,L', $type);
		$type = str_replace('B', 'T,R', $type);
		$type = str_replace('T,RO', 'BO', $type);
		$type = str_replace('C', 'F,L', $type);
		$type = str_replace('D', 'F,R', $type);
		$crops = explode(',', strtoupper($type));
		// remove duplicates
		$crops = array_unique($crops);
		$dw = ($w / 4); // horizontal space to leave before the intersection point
		$dh = ($h / 4); // vertical space to leave before the intersection point
		foreach ($crops as $crop) {
			switch ($crop) {
				case 'T':
				case 'TOP': {
					$x1 = $x;
					$y1 = ($y - $h);
					$x2 = $x;
					$y2 = ($y - $dh);
					break;
				}
				case 'F':
				case 'BOTTOM': {
					$x1 = $x;
					$y1 = ($y + $dh);
					$x2 = $x;
					$y2 = ($y + $h);
					break;
				}
				case 'L':
				case 'LEFT': {
					$x1 = ($x - $w);
					$y1 = $y;
					$x2 = ($x - $dw);
					$y2 = $y;
					break;
				}
				case 'R':
				case 'RIGHT': {
					$x1 = ($x + $dw);
					$y1 = $y;
					$x2 = ($x + $w);
					$y2 = $y;
					break;
				}
			}
			$this->Line($x1, $y1, $x2, $y2);
		}
	}

	/**
	 * Paints a registration mark
	 * @param float $x abscissa of the registration mark center.
	 * @param float $y ordinate of the registration mark center.
	 * @param float $r radius of the crop mark.
	 * @param boolean $double if true print two concentric crop marks.
	 * @param array $cola crop mark color (default spot registration color 'All').
	 * @param array $colb second crop mark color (default spot registration color 'None').
	 * @author Nicola Asuni
	 * @since 4.9.000 (2010-03-26)
	 * @public
	 */
	public function registrationMark($x, $y, $r, $double=false, $cola=array(100,100,100,100,'All'), $colb=array(0,0,0,0,'None')) {
		$line_style = array('width' => max((0.5 / $this->k),($r / 30)), 'cap' => 'butt', 'join' => 'miter', 'dash' => 0, 'color' => $cola);
		$this->setFillColorArray($cola);
		$this->PieSector($x, $y, $r, 90, 180, 'F');
		$this->PieSector($x, $y, $r, 270, 360, 'F');
		$this->Circle($x, $y, $r, 0, 360, 'C', $line_style, array(), 8);
		if ($double) {
			$ri = $r * 0.5;
			$this->setFillColorArray($colb);
			$this->PieSector($x, $y, $ri, 90, 180, 'F');
			$this->PieSector($x, $y, $ri, 270, 360, 'F');
			$this->setFillColorArray($cola);
			$this->PieSector($x, $y, $ri, 0, 90, 'F');
			$this->PieSector($x, $y, $ri, 180, 270, 'F');
			$this->Circle($x, $y, $ri, 0, 360, 'C', $line_style, array(), 8);
		}
	}

	/**
	 * Paints a CMYK registration mark
	 * @param float $x abscissa of the registration mark center.
	 * @param float $y ordinate of the registration mark center.
	 * @param float $r radius of the crop mark.
	 * @author Nicola Asuni
	 * @since 6.0.038 (2013-09-30)
	 * @public
	 */
	public function registrationMarkCMYK($x, $y, $r) {
		// line width
		$lw = max((0.5 / $this->k),($r / 8));
		// internal radius
		$ri = ($r * 0.6);
		// external radius
		$re = ($r * 1.3);
		// Cyan
		$this->setFillColorArray(array(100,0,0,0));
		$this->PieSector($x, $y, $ri, 270, 360, 'F');
		// Magenta
		$this->setFillColorArray(array(0,100,0,0));
		$this->PieSector($x, $y, $ri, 0, 90, 'F');
		// Yellow
		$this->setFillColorArray(array(0,0,100,0));
		$this->PieSector($x, $y, $ri, 90, 180, 'F');
		// Key - black
		$this->setFillColorArray(array(0,0,0,100));
		$this->PieSector($x, $y, $ri, 180, 270, 'F');
		// registration color
		$line_style = array('width' => $lw, 'cap' => 'butt', 'join' => 'miter', 'dash' => 0, 'color' => array(100,100,100,100,'All'));
		$this->setFillColorArray(array(100,100,100,100,'All'));
		// external circle
		$this->Circle($x, $y, $r, 0, 360, 'C', $line_style, array(), 8);
		// cross lines
		$this->Line($x, ($y - $re), $x, ($y - $ri));
		$this->Line($x, ($y + $ri), $x, ($y + $re));
		$this->Line(($x - $re), $y, ($x - $ri), $y);
		$this->Line(($x + $ri), $y, ($x + $re), $y);
	}

	/**
	 * Paints a linear colour gradient.
	 * @param float $x abscissa of the top left corner of the rectangle.
	 * @param float $y ordinate of the top left corner of the rectangle.
	 * @param float $w width of the rectangle.
	 * @param float $h height of the rectangle.
	 * @param array $col1 first color (Grayscale, RGB or CMYK components).
	 * @param array $col2 second color (Grayscale, RGB or CMYK components).
	 * @param array $coords array of the form (x1, y1, x2, y2) which defines the gradient vector (see linear_gradient_coords.jpg). The default value is from left to right (x1=0, y1=0, x2=1, y2=0).
	 * @author Andreas W\FCrmser, Nicola Asuni
	 * @since 3.1.000 (2008-06-09)
	 * @public
	 */
	public function LinearGradient($x, $y, $w, $h, $col1=array(), $col2=array(), $coords=array(0,0,1,0)) {
		$this->Clip($x, $y, $w, $h);
		$this->Gradient(2, $coords, array(array('color' => $col1, 'offset' => 0, 'exponent' => 1), array('color' => $col2, 'offset' => 1, 'exponent' => 1)), array(), false);
	}

	/**
	 * Paints a radial colour gradient.
	 * @param float $x abscissa of the top left corner of the rectangle.
	 * @param float $y ordinate of the top left corner of the rectangle.
	 * @param float $w width of the rectangle.
	 * @param float $h height of the rectangle.
	 * @param array $col1 first color (Grayscale, RGB or CMYK components).
	 * @param array $col2 second color (Grayscale, RGB or CMYK components).
	 * @param array $coords array of the form (fx, fy, cx, cy, r) where (fx, fy) is the starting point of the gradient with color1, (cx, cy) is the center of the circle with color2, and r is the radius of the circle (see radial_gradient_coords.jpg). (fx, fy) should be inside the circle, otherwise some areas will not be defined.
	 * @author Andreas W\FCrmser, Nicola Asuni
	 * @since 3.1.000 (2008-06-09)
	 * @public
	 */
	public function RadialGradient($x, $y, $w, $h, $col1=array(), $col2=array(), $coords=array(0.5,0.5,0.5,0.5,1)) {
		$this->Clip($x, $y, $w, $h);
		$this->Gradient(3, $coords, array(array('color' => $col1, 'offset' => 0, 'exponent' => 1), array('color' => $col2, 'offset' => 1, 'exponent' => 1)), array(), false);
	}

	/**
	 * Paints a coons patch mesh.
	 * @param float $x abscissa of the top left corner of the rectangle.
	 * @param float $y ordinate of the top left corner of the rectangle.
	 * @param float $w width of the rectangle.
	 * @param float $h height of the rectangle.
	 * @param array $col1 first color (lower left corner) (RGB components).
	 * @param array $col2 second color (lower right corner) (RGB components).
	 * @param array $col3 third color (upper right corner) (RGB components).
	 * @param array $col4 fourth color (upper left corner) (RGB components).
	 * @param array $coords <ul><li>for one patch mesh: array(float x1, float y1, .... float x12, float y12): 12 pairs of coordinates (normally from 0 to 1) which specify the Bezier control points that define the patch. First pair is the lower left edge point, next is its right control point (control point 2). Then the other points are defined in the order: control point 1, edge point, control point 2 going counter-clockwise around the patch. Last (x12, y12) is the first edge point's left control point (control point 1).</li><li>for two or more patch meshes: array[number of patches]: arrays with the following keys for each patch: f: where to put that patch (0 = first patch, 1, 2, 3 = right, top and left of precedent patch - I didn't figure this out completely - just try and error ;-) points: 12 pairs of coordinates of the Bezier control points as above for the first patch, 8 pairs of coordinates for the following patches, ignoring the coordinates already defined by the precedent patch (I also didn't figure out the order of these - also: try and see what's happening) colors: must be 4 colors for the first patch, 2 colors for the following patches</li></ul>
	 * @param array $coords_min minimum value used by the coordinates. If a coordinate's value is smaller than this it will be cut to coords_min. default: 0
	 * @param array $coords_max maximum value used by the coordinates. If a coordinate's value is greater than this it will be cut to coords_max. default: 1
	 * @param boolean $antialias A flag indicating whether to filter the shading function to prevent aliasing artifacts.
	 * @author Andreas W\FCrmser, Nicola Asuni
	 * @since 3.1.000 (2008-06-09)
	 * @public
	 */
	public function CoonsPatchMesh($x, $y, $w, $h, $col1=array(), $col2=array(), $col3=array(), $col4=array(), $coords=array(0.00,0.0,0.33,0.00,0.67,0.00,1.00,0.00,1.00,0.33,1.00,0.67,1.00,1.00,0.67,1.00,0.33,1.00,0.00,1.00,0.00,0.67,0.00,0.33), $coords_min=0, $coords_max=1, $antialias=false) {
		if (($this->pdfa_mode && $this->pdfa_version < 2) OR ($this->state != 2)) {
			return;
		}
		$this->Clip($x, $y, $w, $h);
		$n = count($this->gradients) + 1;
		$this->gradients[$n] = array();
		$this->gradients[$n]['type'] = 6; //coons patch mesh
		$this->gradients[$n]['coords'] = array();
		$this->gradients[$n]['antialias'] = $antialias;
		$this->gradients[$n]['colors'] = array();
		$this->gradients[$n]['transparency'] = false;
		//check the coords array if it is the simple array or the multi patch array
		if (!isset($coords[0]['f'])) {
			//simple array -> convert to multi patch array
			if (!isset($col1[1])) {
				$col1[1] = $col1[2] = $col1[0];
			}
			if (!isset($col2[1])) {
				$col2[1] = $col2[2] = $col2[0];
			}
			if (!isset($col3[1])) {
				$col3[1] = $col3[2] = $col3[0];
			}
			if (!isset($col4[1])) {
				$col4[1] = $col4[2] = $col4[0];
			}
			$patch_array[0]['f'] = 0;
			$patch_array[0]['points'] = $coords;
			$patch_array[0]['colors'][0]['r'] = $col1[0];
			$patch_array[0]['colors'][0]['g'] = $col1[1];
			$patch_array[0]['colors'][0]['b'] = $col1[2];
			$patch_array[0]['colors'][1]['r'] = $col2[0];
			$patch_array[0]['colors'][1]['g'] = $col2[1];
			$patch_array[0]['colors'][1]['b'] = $col2[2];
			$patch_array[0]['colors'][2]['r'] = $col3[0];
			$patch_array[0]['colors'][2]['g'] = $col3[1];
			$patch_array[0]['colors'][2]['b'] = $col3[2];
			$patch_array[0]['colors'][3]['r'] = $col4[0];
			$patch_array[0]['colors'][3]['g'] = $col4[1];
			$patch_array[0]['colors'][3]['b'] = $col4[2];
		} else {
			//multi patch array
			$patch_array = $coords;
		}
		$bpcd = 65535; //16 bits per coordinate
		//build the data stream
		$this->gradients[$n]['stream'] = '';
		$count_patch = count($patch_array);
		for ($i=0; $i < $count_patch; ++$i) {
			$this->gradients[$n]['stream'] .= chr($patch_array[$i]['f']); //start with the edge flag as 8 bit
			$count_points = count($patch_array[$i]['points']);
			for ($j=0; $j < $count_points; ++$j) {
				//each point as 16 bit
				$patch_array[$i]['points'][$j] = (($patch_array[$i]['points'][$j] - $coords_min) / ($coords_max - $coords_min)) * $bpcd;
				if ($patch_array[$i]['points'][$j] < 0) {
					$patch_array[$i]['points'][$j] = 0;
				}
				if ($patch_array[$i]['points'][$j] > $bpcd) {
					$patch_array[$i]['points'][$j] = $bpcd;
				}
				$this->gradients[$n]['stream'] .= chr((int) floor($patch_array[$i]['points'][$j] / 256));
				$this->gradients[$n]['stream'] .= chr((int) floor(intval($patch_array[$i]['points'][$j]) % 256));
			}
			$count_cols = count($patch_array[$i]['colors']);
			for ($j=0; $j < $count_cols; ++$j) {
				//each color component as 8 bit
				$this->gradients[$n]['stream'] .= chr($patch_array[$i]['colors'][$j]['r']);
				$this->gradients[$n]['stream'] .= chr($patch_array[$i]['colors'][$j]['g']);
				$this->gradients[$n]['stream'] .= chr($patch_array[$i]['colors'][$j]['b']);
			}
		}
		//paint the gradient
		$this->_out('/Sh'.$n.' sh');
		//restore previous Graphic State
		$this->_outRestoreGraphicsState();
		if ($this->inxobj) {
			// we are inside an XObject template
			$this->xobjects[$this->xobjid]['gradients'][$n] = $this->gradients[$n];
		}
	}

	/**
	 * Set a rectangular clipping area.
	 * @param float $x abscissa of the top left corner of the rectangle (or top right corner for RTL mode).
	 * @param float $y ordinate of the top left corner of the rectangle.
	 * @param float $w width of the rectangle.
	 * @param float $h height of the rectangle.
	 * @author Andreas W\FCrmser, Nicola Asuni
	 * @since 3.1.000 (2008-06-09)
	 * @protected
	 */
	protected function Clip($x, $y, $w, $h) {
		if ($this->state != 2) {
			 return;
		}
		if ($this->rtl) {
			$x = $this->w - $x - $w;
		}
		//save current Graphic State
		$s = 'q';
		//set clipping area
		$s .= sprintf(' %F %F %F %F re W n', $x*$this->k, ($this->h-$y)*$this->k, $w*$this->k, -$h*$this->k);
		//set up transformation matrix for gradient
		$s .= sprintf(' %F 0 0 %F %F %F cm', $w*$this->k, $h*$this->k, $x*$this->k, ($this->h-($y+$h))*$this->k);
		$this->_out($s);
	}

	/**
	 * Output gradient.
	 * @param int $type type of gradient (1 Function-based shading; 2 Axial shading; 3 Radial shading; 4 Free-form Gouraud-shaded triangle mesh; 5 Lattice-form Gouraud-shaded triangle mesh; 6 Coons patch mesh; 7 Tensor-product patch mesh). (Not all types are currently supported)
	 * @param array $coords array of coordinates.
	 * @param array $stops array gradient color components: color = array of GRAY, RGB or CMYK color components; offset = (0 to 1) represents a location along the gradient vector; exponent = exponent of the exponential interpolation function (default = 1).
	 * @param array $background An array of colour components appropriate to the colour space, specifying a single background colour value.
	 * @param boolean $antialias A flag indicating whether to filter the shading function to prevent aliasing artifacts.
	 * @author Nicola Asuni
	 * @since 3.1.000 (2008-06-09)
	 * @public
	 */
	public function Gradient($type, $coords, $stops, $background=array(), $antialias=false) {
		if (($this->pdfa_mode && $this->pdfa_version < 2) OR ($this->state != 2)) {
			return;
		}
		$n = count($this->gradients) + 1;
		$this->gradients[$n] = array();
		$this->gradients[$n]['type'] = $type;
		$this->gradients[$n]['coords'] = $coords;
		$this->gradients[$n]['antialias'] = $antialias;
		$this->gradients[$n]['colors'] = array();
		$this->gradients[$n]['transparency'] = false;
		// color space
		$numcolspace = count($stops[0]['color']);
		$bcolor = array_values($background);
		switch($numcolspace) {
			case 5:   // SPOT
			case 4: { // CMYK
				$this->gradients[$n]['colspace'] = 'DeviceCMYK';
				if (!empty($background)) {
					$this->gradients[$n]['background'] = sprintf('%F %F %F %F', $bcolor[0]/100, $bcolor[1]/100, $bcolor[2]/100, $bcolor[3]/100);
				}
				break;
			}
			case 3: { // RGB
				$this->gradients[$n]['colspace'] = 'DeviceRGB';
				if (!empty($background)) {
					$this->gradients[$n]['background'] = sprintf('%F %F %F', $bcolor[0]/255, $bcolor[1]/255, $bcolor[2]/255);
				}
				break;
			}
			case 1: { // GRAY SCALE
				$this->gradients[$n]['colspace'] = 'DeviceGray';
				if (!empty($background)) {
					$this->gradients[$n]['background'] = sprintf('%F', $bcolor[0]/255);
				}
				break;
			}
		}
		$num_stops = count($stops);
		$last_stop_id = $num_stops - 1;
		foreach ($stops as $key => $stop) {
			$this->gradients[$n]['colors'][$key] = array();
			// offset represents a location along the gradient vector
			if (isset($stop['offset'])) {
				$this->gradients[$n]['colors'][$key]['offset'] = $stop['offset'];
			} else {
				if ($key == 0) {
					$this->gradients[$n]['colors'][$key]['offset'] = 0;
				} elseif ($key == $last_stop_id) {
					$this->gradients[$n]['colors'][$key]['offset'] = 1;
				} else {
					$offsetstep = (1 - $this->gradients[$n]['colors'][($key - 1)]['offset']) / ($num_stops - $key);
					$this->gradients[$n]['colors'][$key]['offset'] = $this->gradients[$n]['colors'][($key - 1)]['offset'] + $offsetstep;
				}
			}
			if (isset($stop['opacity'])) {
				$this->gradients[$n]['colors'][$key]['opacity'] = $stop['opacity'];
				if ((!($this->pdfa_mode && $this->pdfa_version < 2)) AND ($stop['opacity'] < 1)) {
					$this->gradients[$n]['transparency'] = true;
				}
			} else {
				$this->gradients[$n]['colors'][$key]['opacity'] = 1;
			}
			// exponent for the exponential interpolation function
			if (isset($stop['exponent'])) {
				$this->gradients[$n]['colors'][$key]['exponent'] = $stop['exponent'];
			} else {
				$this->gradients[$n]['colors'][$key]['exponent'] = 1;
			}
			// set colors
			$color = array_values($stop['color']);
			switch($numcolspace) {
				case 5:   // SPOT
				case 4: { // CMYK
					$this->gradients[$n]['colors'][$key]['color'] = sprintf('%F %F %F %F', $color[0]/100, $color[1]/100, $color[2]/100, $color[3]/100);
					break;
				}
				case 3: { // RGB
					$this->gradients[$n]['colors'][$key]['color'] = sprintf('%F %F %F', $color[0]/255, $color[1]/255, $color[2]/255);
					break;
				}
				case 1: { // GRAY SCALE
					$this->gradients[$n]['colors'][$key]['color'] = sprintf('%F', $color[0]/255);
					break;
				}
			}
		}
		if ($this->gradients[$n]['transparency']) {
			// paint luminosity gradient
			$this->_out('/TGS'.$n.' gs');
		}
		//paint the gradient
		$this->_out('/Sh'.$n.' sh');
		//restore previous Graphic State
		$this->_outRestoreGraphicsState();
		if ($this->inxobj) {
			// we are inside an XObject template
			$this->xobjects[$this->xobjid]['gradients'][$n] = $this->gradients[$n];
		}
	}

	/**
	 * Output gradient shaders.
	 * @author Nicola Asuni
	 * @since 3.1.000 (2008-06-09)
	 * @protected
	 */
	function _putshaders() {
		if ($this->pdfa_mode && $this->pdfa_version < 2) {
			return;
		}
		$idt = count($this->gradients); //index for transparency gradients
		foreach ($this->gradients as $id => $grad) {
			if (($grad['type'] == 2) OR ($grad['type'] == 3)) {
				$fc = $this->_newobj();
				$out = '<<';
				$out .= ' /FunctionType 3';
				$out .= ' /Domain [0 1]';
				$functions = '';
				$bounds = '';
				$encode = '';
				$i = 1;
				$num_cols = count($grad['colors']);
				$lastcols = $num_cols - 1;
				for ($i = 1; $i < $num_cols; ++$i) {
					$functions .= ($fc + $i).' 0 R ';
					if ($i < $lastcols) {
						$bounds .= sprintf('%F ', $grad['colors'][$i]['offset']);
					}
					$encode .= '0 1 ';
				}
				$out .= ' /Functions ['.trim($functions).']';
				$out .= ' /Bounds ['.trim($bounds).']';
				$out .= ' /Encode ['.trim($encode).']';
				$out .= ' >>';
				$out .= ""\n"".'endobj';
				$this->_out($out);
				for ($i = 1; $i < $num_cols; ++$i) {
					$this->_newobj();
					$out = '<<';
					$out .= ' /FunctionType 2';
					$out .= ' /Domain [0 1]';
					$out .= ' /C0 ['.$grad['colors'][($i - 1)]['color'].']';
					$out .= ' /C1 ['.$grad['colors'][$i]['color'].']';
					$out .= ' /N '.$grad['colors'][$i]['exponent'];
					$out .= ' >>';
					$out .= ""\n"".'endobj';
					$this->_out($out);
				}
				// set transparency functions
				if ($grad['transparency']) {
					$ft = $this->_newobj();
					$out = '<<';
					$out .= ' /FunctionType 3';
					$out .= ' /Domain [0 1]';
					$functions = '';
					$i = 1;
					$num_cols = count($grad['colors']);
					for ($i = 1; $i < $num_cols; ++$i) {
						$functions .= ($ft + $i).' 0 R ';
					}
					$out .= ' /Functions ['.trim($functions).']';
					$out .= ' /Bounds ['.trim($bounds).']';
					$out .= ' /Encode ['.trim($encode).']';
					$out .= ' >>';
					$out .= ""\n"".'endobj';
					$this->_out($out);
					for ($i = 1; $i < $num_cols; ++$i) {
						$this->_newobj();
						$out = '<<';
						$out .= ' /FunctionType 2';
						$out .= ' /Domain [0 1]';
						$out .= ' /C0 ['.$grad['colors'][($i - 1)]['opacity'].']';
						$out .= ' /C1 ['.$grad['colors'][$i]['opacity'].']';
						$out .= ' /N '.$grad['colors'][$i]['exponent'];
						$out .= ' >>';
						$out .= ""\n"".'endobj';
						$this->_out($out);
					}
				}
			}
			// set shading object
			$this->_newobj();
			$out = '<< /ShadingType '.$grad['type'];
			if (isset($grad['colspace'])) {
				$out .= ' /ColorSpace /'.$grad['colspace'];
			} else {
				$out .= ' /ColorSpace /DeviceRGB';
			}
			if (isset($grad['background']) AND !empty($grad['background'])) {
				$out .= ' /Background ['.$grad['background'].']';
			}
			if (isset($grad['antialias']) AND ($grad['antialias'] === true)) {
				$out .= ' /AntiAlias true';
			}
			if ($grad['type'] == 2) {
				$out .= ' '.sprintf('/Coords [%F %F %F %F]', $grad['coords'][0], $grad['coords'][1], $grad['coords'][2], $grad['coords'][3]);
				$out .= ' /Domain [0 1]';
				$out .= ' /Function '.$fc.' 0 R';
				$out .= ' /Extend [true true]';
				$out .= ' >>';
			} elseif ($grad['type'] == 3) {
				//x0, y0, r0, x1, y1, r1
				//at this this time radius of inner circle is 0
				$out .= ' '.sprintf('/Coords [%F %F 0 %F %F %F]', $grad['coords'][0], $grad['coords'][1], $grad['coords'][2], $grad['coords'][3], $grad['coords'][4]);
				$out .= ' /Domain [0 1]';
				$out .= ' /Function '.$fc.' 0 R';
				$out .= ' /Extend [true true]';
				$out .= ' >>';
			} elseif ($grad['type'] == 6) {
				$out .= ' /BitsPerCoordinate 16';
				$out .= ' /BitsPerComponent 8';
				$out .= ' /Decode[0 1 0 1 0 1 0 1 0 1]';
				$out .= ' /BitsPerFlag 8';
				$stream = $this->_getrawstream($grad['stream']);
				$out .= ' /Length '.strlen($stream);
				$out .= ' >>';
				$out .= ' stream'.""\n"".$stream.""\n"".'endstream';
			}
			$out .= ""\n"".'endobj';
			$this->_out($out);
			if ($grad['transparency']) {
				$shading_transparency = preg_replace('/\/ColorSpace \/[^\s]+/si', '/ColorSpace /DeviceGray', $out);
				$shading_transparency = preg_replace('/\/Function [0-9]+ /si', '/Function '.$ft.' ', $shading_transparency);
			}
			$this->gradients[$id]['id'] = $this->n;
			// set pattern object
			$this->_newobj();
			$out = '<< /Type /Pattern /PatternType 2';
			$out .= ' /Shading '.$this->gradients[$id]['id'].' 0 R';
			$out .= ' >>';
			$out .= ""\n"".'endobj';
			$this->_out($out);
			$this->gradients[$id]['pattern'] = $this->n;
			// set shading and pattern for transparency mask
			if ($grad['transparency']) {
				// luminosity pattern
				$idgs = $id + $idt;
				$this->_newobj();
				$this->_out($shading_transparency);
				$this->gradients[$idgs]['id'] = $this->n;
				$this->_newobj();
				$out = '<< /Type /Pattern /PatternType 2';
				$out .= ' /Shading '.$this->gradients[$idgs]['id'].' 0 R';
				$out .= ' >>';
				$out .= ""\n"".'endobj';
				$this->_out($out);
				$this->gradients[$idgs]['pattern'] = $this->n;
				// luminosity XObject
				$oid = $this->_newobj();
				$this->xobjects['LX'.$oid] = array('n' => $oid);
				$filter = '';
				$stream = 'q /a0 gs /Pattern cs /p'.$idgs.' scn 0 0 '.$this->wPt.' '.$this->hPt.' re f Q';
				if ($this->compress) {
					$filter = ' /Filter /FlateDecode';
					$stream = gzcompress($stream);
				}
				$stream = $this->_getrawstream($stream);
				$out = '<< /Type /XObject /Subtype /Form /FormType 1'.$filter;
				$out .= ' /Length '.strlen($stream);
				$rect = sprintf('%F %F', $this->wPt, $this->hPt);
				$out .= ' /BBox [0 0 '.$rect.']';
				$out .= ' /Group << /Type /Group /S /Transparency /CS /DeviceGray >>';
				$out .= ' /Resources <<';
				$out .= ' /ExtGState << /a0 << /ca 1 /CA 1 >> >>';
				$out .= ' /Pattern << /p'.$idgs.' '.$this->gradients[$idgs]['pattern'].' 0 R >>';
				$out .= ' >>';
				$out .= ' >> ';
				$out .= ' stream'.""\n"".$stream.""\n"".'endstream';
				$out .= ""\n"".'endobj';
				$this->_out($out);
				// SMask
				$this->_newobj();
				$out = '<< /Type /Mask /S /Luminosity /G '.($this->n - 1).' 0 R >>'.""\n"".'endobj';
				$this->_out($out);
				// ExtGState
				$this->_newobj();
				$out = '<< /Type /ExtGState /SMask '.($this->n - 1).' 0 R /AIS false >>'.""\n"".'endobj';
				$this->_out($out);
				$this->extgstates[] = array('n' => $this->n, 'name' => 'TGS'.$id);
			}
		}
	}

	/**
	 * Draw the sector of a circle.
	 * It can be used for instance to render pie charts.
	 * @param float $xc abscissa of the center.
	 * @param float $yc ordinate of the center.
	 * @param float $r radius.
	 * @param float $a start angle (in degrees).
	 * @param float $b end angle (in degrees).
	 * @param string $style Style of rendering. See the getPathPaintOperator() function for more information.
	 * @param float $cw indicates whether to go clockwise (default: true).
	 * @param float $o origin of angles (0 for 3 o'clock, 90 for noon, 180 for 9 o'clock, 270 for 6 o'clock). Default: 90.
	 * @author Maxime Delorme, Nicola Asuni
	 * @since 3.1.000 (2008-06-09)
	 * @public
	 */
	public function PieSector($xc, $yc, $r, $a, $b, $style='FD', $cw=true, $o=90) {
		$this->PieSectorXY($xc, $yc, $r, $r, $a, $b, $style, $cw, $o);
	}

	/**
	 * Draw the sector of an ellipse.
	 * It can be used for instance to render pie charts.
	 * @param float $xc abscissa of the center.
	 * @param float $yc ordinate of the center.
	 * @param float $rx the x-axis radius.
	 * @param float $ry the y-axis radius.
	 * @param float $a start angle (in degrees).
	 * @param float $b end angle (in degrees).
	 * @param string $style Style of rendering. See the getPathPaintOperator() function for more information.
	 * @param float $cw indicates whether to go clockwise.
	 * @param float $o origin of angles (0 for 3 o'clock, 90 for noon, 180 for 9 o'clock, 270 for 6 o'clock).
	 * @param integer $nc Number of curves used to draw a 90 degrees portion of arc.
	 * @author Maxime Delorme, Nicola Asuni
	 * @since 3.1.000 (2008-06-09)
	 * @public
	 */
	public function PieSectorXY($xc, $yc, $rx, $ry, $a, $b, $style='FD', $cw=false, $o=0, $nc=2) {
		if ($this->state != 2) {
			 return;
		}
		if ($this->rtl) {
			$xc = ($this->w - $xc);
		}
		$op = TCPDF_STATIC::getPathPaintOperator($style);
		if ($op == 'f') {
			$line_style = array();
		}
		if ($cw) {
			$d = $b;
			$b = (360 - $a + $o);
			$a = (360 - $d + $o);
		} else {
			$b += $o;
			$a += $o;
		}
		$this->_outellipticalarc($xc, $yc, $rx, $ry, 0, $a, $b, true, $nc);
		$this->_out($op);
	}

	/**
	 * Embed vector-based Adobe Illustrator (AI) or AI-compatible EPS files.
	 * NOTE: EPS is not yet fully implemented, use the setRasterizeVectorImages() method to enable/disable rasterization of vector images using ImageMagick library.
	 * Only vector drawing is supported, not text or bitmap.
	 * Although the script was successfully tested with various AI format versions, best results are probably achieved with files that were exported in the AI3 format (tested with Illustrator CS2, Freehand MX and Photoshop CS2).
	 * @param string $file Name of the file containing the image or a '@' character followed by the EPS/AI data string.
	 * @param float|null $x Abscissa of the upper-left corner.
	 * @param float|null $y Ordinate of the upper-left corner.
	 * @param float $w Width of the image in the page. If not specified or equal to zero, it is automatically calculated.
	 * @param float $h Height of the image in the page. If not specified or equal to zero, it is automatically calculated.
	 * @param mixed $link URL or identifier returned by AddLink().
	 * @param boolean $useBoundingBox specifies whether to position the bounding box (true) or the complete canvas (false) at location (x,y). Default value is true.
	 * @param string $align Indicates the alignment of the pointer next to image insertion relative to image height. The value can be:<ul><li>T: top-right for LTR or top-left for RTL</li><li>M: middle-right for LTR or middle-left for RTL</li><li>B: bottom-right for LTR or bottom-left for RTL</li><li>N: next line</li></ul>
	 * @param string $palign Allows to center or align the image on the current line. Possible values are:<ul><li>L : left align</li><li>C : center</li><li>R : right align</li><li>'' : empty string : left for LTR or right for RTL</li></ul>
	 * @param mixed $border Indicates if borders must be drawn around the cell. The value can be a number:<ul><li>0: no border (default)</li><li>1: frame</li></ul> or a string containing some or all of the following characters (in any order):<ul><li>L: left</li><li>T: top</li><li>R: right</li><li>B: bottom</li></ul> or an array of line styles for each border group - for example: array('LTRB' => array('width' => 2, 'cap' => 'butt', 'join' => 'miter', 'dash' => 0, 'color' => array(0, 0, 0)))
	 * @param boolean $fitonpage if true the image is resized to not exceed page dimensions.
	 * @param boolean $fixoutvals if true remove values outside the bounding box.
	 * @author Valentin Schmidt, Nicola Asuni
	 * @since 3.1.000 (2008-06-09)
	 * @public
	 */
	public function ImageEps($file, $x=null, $y=null, $w=0, $h=0, $link='', $useBoundingBox=true, $align='', $palign='', $border=0, $fitonpage=false, $fixoutvals=false) {
		if ($this->state != 2) {
			 return;
		}
		if ($this->rasterize_vector_images AND ($w > 0) AND ($h > 0)) {
			// convert EPS to raster image using GD or ImageMagick libraries
			return $this->Image($file, $x, $y, $w, $h, 'EPS', $link, $align, true, 300, $palign, false, false, $border, false, false, $fitonpage);
		}
		if (TCPDF_STATIC::empty_string($x)) {
			$x = $this->x;
		}
		if (TCPDF_STATIC::empty_string($y)) {
			$y = $this->y;
		}
		// check page for no-write regions and adapt page margins if necessary
		list($x, $y) = $this->checkPageRegions($h, $x, $y);
		$k = $this->k;
		if ($file[0] === '@') { // image from string
			$data = substr($file, 1);
		} else { // EPS/AI file
            $data = $this->getCachedFileContents($file);
		}
		if ($data === FALSE) {
			$this->Error('EPS file not found: '.$file);
		}
		$regs = array();
		// EPS/AI compatibility check (only checks files created by Adobe Illustrator!)
		preg_match(""/%%Creator:([^\r\n]+)/"", $data, $regs); # find Creator
		if (count($regs) > 1) {
			$version_str = trim($regs[1]); # e.g. ""Adobe Illustrator(R) 8.0""
			if (strpos($version_str, 'Adobe Illustrator') !== false) {
				$versexp = explode(' ', $version_str);
				$version = (float)array_pop($versexp);
				if ($version >= 9) {
					$this->Error('This version of Adobe Illustrator file is not supported: '.$file);
				}
			}
		}
		// strip binary bytes in front of PS-header
		$start = strpos($data, '%!PS-Adobe');
		if ($start > 0) {
			$data = substr($data, $start);
		}
		// find BoundingBox params
		preg_match(""/%%BoundingBox:([^\r\n]+)/"", $data, $regs);
		if (count($regs) > 1) {
			list($x1, $y1, $x2, $y2) = explode(' ', trim($regs[1]));
		} else {
			$this->Error('No BoundingBox found in EPS/AI file: '.$file);
		}
		$start = strpos($data, '%%EndSetup');
		if ($start === false) {
			$start = strpos($data, '%%EndProlog');
		}
		if ($start === false) {
			$start = strpos($data, '%%BoundingBox');
		}
		$data = substr($data, $start);
		$end = strpos($data, '%%PageTrailer');
		if ($end===false) {
			$end = strpos($data, 'showpage');
		}
		if ($end) {
			$data = substr($data, 0, $end);
		}
		// calculate image width and height on document
		if (($w <= 0) AND ($h <= 0)) {
			$w = ($x2 - $x1) / $k;
			$h = ($y2 - $y1) / $k;
		} elseif ($w <= 0) {
			$w = ($x2-$x1) / $k * ($h / (($y2 - $y1) / $k));
		} elseif ($h <= 0) {
			$h = ($y2 - $y1) / $k * ($w / (($x2 - $x1) / $k));
		}
		// fit the image on available space
		list($w, $h, $x, $y) = $this->fitBlock($w, $h, $x, $y, $fitonpage);
		if ($this->rasterize_vector_images) {
			// convert EPS to raster image using GD or ImageMagick libraries
			return $this->Image($file, $x, $y, $w, $h, 'EPS', $link, $align, true, 300, $palign, false, false, $border, false, false, $fitonpage);
		}
		// set scaling factors
		$scale_x = $w / (($x2 - $x1) / $k);
		$scale_y = $h / (($y2 - $y1) / $k);
		// set alignment
		$this->img_rb_y = $y + $h;
		// set alignment
		if ($this->rtl) {
			if ($palign == 'L') {
				$ximg = $this->lMargin;
			} elseif ($palign == 'C') {
				$ximg = ($this->w + $this->lMargin - $this->rMargin - $w) / 2;
			} elseif ($palign == 'R') {
				$ximg = $this->w - $this->rMargin - $w;
			} else {
				$ximg = $x - $w;
			}
			$this->img_rb_x = $ximg;
		} else {
			if ($palign == 'L') {
				$ximg = $this->lMargin;
			} elseif ($palign == 'C') {
				$ximg = ($this->w + $this->lMargin - $this->rMargin - $w) / 2;
			} elseif ($palign == 'R') {
				$ximg = $this->w - $this->rMargin - $w;
			} else {
				$ximg = $x;
			}
			$this->img_rb_x = $ximg + $w;
		}
		if ($useBoundingBox) {
			$dx = $ximg * $k - $x1;
			$dy = $y * $k - $y1;
		} else {
			$dx = $ximg * $k;
			$dy = $y * $k;
		}
		// save the current graphic state
		$this->_out('q'.$this->epsmarker);
		// translate
		$this->_out(sprintf('%F %F %F %F %F %F cm', 1, 0, 0, 1, $dx, $dy + ($this->hPt - (2 * $y * $k) - ($y2 - $y1))));
		// scale
		$this->_out(sprintf('%F %F %F %F %F %F cm', $scale_x, 0, 0, $scale_y, $x1 * (1 - $scale_x), $y2 * (1 - $scale_y)));
		// handle pc/unix/mac line endings
		$lines = preg_split('/[\r\n]+/si', $data, -1, PREG_SPLIT_NO_EMPTY);
		$u=0;
		$cnt = count($lines);
		for ($i=0; $i < $cnt; ++$i) {
			$line = $lines[$i];
			if (($line == '') OR ($line[0] == '%')) {
				continue;
			}
			$len = strlen($line);
			// check for spot color names
			$color_name = '';
			if (strcasecmp('x', substr(trim($line), -1)) == 0) {
				if (preg_match('/\([^\)]*\)/', $line, $matches) > 0) {
					// extract spot color name
					$color_name = $matches[0];
					// remove color name from string
					$line = str_replace(' '.$color_name, '', $line);
					// remove pharentesis from color name
					$color_name = substr($color_name, 1, -1);
				}
			}
			$chunks = explode(' ', $line);
			$cmd = trim(array_pop($chunks));
			// RGB
			if (($cmd == 'Xa') OR ($cmd == 'XA')) {
				$b = array_pop($chunks);
				$g = array_pop($chunks);
				$r = array_pop($chunks);
				$this->_out(''.$r.' '.$g.' '.$b.' '.($cmd=='Xa'?'rg':'RG')); //substr($line, 0, -2).'rg' -> in EPS (AI8): c m y k r g b rg!
				continue;
			}
			$skip = false;
			if ($fixoutvals) {
				// check for values outside the bounding box
				switch ($cmd) {
					case 'm':
					case 'l':
					case 'L': {
						// skip values outside bounding box
						foreach ($chunks as $key => $val) {
							if ((($key % 2) == 0) AND (($val < $x1) OR ($val > $x2))) {
								$skip = true;
							} elseif ((($key % 2) != 0) AND (($val < $y1) OR ($val > $y2))) {
								$skip = true;
							}
						}
					}
				}
			}
			switch ($cmd) {
				case 'm':
				case 'l':
				case 'v':
				case 'y':
				case 'c':
				case 'k':
				case 'K':
				case 'g':
				case 'G':
				case 's':
				case 'S':
				case 'J':
				case 'j':
				case 'w':
				case 'M':
				case 'd':
				case 'n': {
					if ($skip) {
						break;
					}
					$this->_out($line);
					break;
				}
				case 'x': {// custom fill color
					if (empty($color_name)) {
						// CMYK color
						list($col_c, $col_m, $col_y, $col_k) = $chunks;
						$this->_out(''.$col_c.' '.$col_m.' '.$col_y.' '.$col_k.' k');
					} else {
						// Spot Color (CMYK + tint)
						list($col_c, $col_m, $col_y, $col_k, $col_t) = $chunks;
						$this->AddSpotColor($color_name, ($col_c * 100), ($col_m * 100), ($col_y * 100), ($col_k * 100));
						$color_cmd = sprintf('/CS%d cs %F scn', $this->spot_colors[$color_name]['i'], (1 - $col_t));
						$this->_out($color_cmd);
					}
					break;
				}
				case 'X': { // custom stroke color
					if (empty($color_name)) {
						// CMYK color
						list($col_c, $col_m, $col_y, $col_k) = $chunks;
						$this->_out(''.$col_c.' '.$col_m.' '.$col_y.' '.$col_k.' K');
					} else {
						// Spot Color (CMYK + tint)
						list($col_c, $col_m, $col_y, $col_k, $col_t) = $chunks;
						$this->AddSpotColor($color_name, ($col_c * 100), ($col_m * 100), ($col_y * 100), ($col_k * 100));
						$color_cmd = sprintf('/CS%d CS %F SCN', $this->spot_colors[$color_name]['i'], (1 - $col_t));
						$this->_out($color_cmd);
					}
					break;
				}
				case 'Y':
				case 'N':
				case 'V':
				case 'L':
				case 'C': {
					if ($skip) {
						break;
					}
					$line[($len - 1)] = strtolower($cmd);
					$this->_out($line);
					break;
				}
				case 'b':
				case 'B': {
					$this->_out($cmd . '*');
					break;
				}
				case 'f':
				case 'F': {
					if ($u > 0) {
						$isU = false;
						$max = min(($i + 5), $cnt);
						for ($j = ($i + 1); $j < $max; ++$j) {
							$isU = ($isU OR (($lines[$j] == 'U') OR ($lines[$j] == '*U')));
						}
						if ($isU) {
							$this->_out('f*');
						}
					} else {
						$this->_out('f*');
					}
					break;
				}
				case '*u': {
					++$u;
					break;
				}
				case '*U': {
					--$u;
					break;
				}
			}
		}
		// restore previous graphic state
		$this->_out($this->epsmarker.'Q');
		if (!empty($border)) {
			$bx = $this->x;
			$by = $this->y;
			$this->x = $ximg;
			if ($this->rtl) {
				$this->x += $w;
			}
			$this->y = $y;
			$this->Cell($w, $h, '', $border, 0, '', 0, '', 0, true);
			$this->x = $bx;
			$this->y = $by;
		}
		if ($link) {
			$this->Link($ximg, $y, $w, $h, $link, 0);
		}
		// set pointer to align the next text/objects
		switch($align) {
			case 'T':{
				$this->y = $y;
				$this->x = $this->img_rb_x;
				break;
			}
			case 'M':{
				$this->y = $y + round($h/2);
				$this->x = $this->img_rb_x;
				break;
			}
			case 'B':{
				$this->y = $this->img_rb_y;
				$this->x = $this->img_rb_x;
				break;
			}
			case 'N':{
				$this->setY($this->img_rb_y);
				break;
			}
			default:{
				break;
			}
		}
		$this->endlinex = $this->img_rb_x;
	}

	/**
	 * Set document barcode.
	 * @param string $bc barcode
	 * @public
	 */
	public function setBarcode($bc='') {
		$this->barcode = $bc;
	}

	/**
	 * Get current barcode.
	 * @return string
	 * @public
	 * @since 4.0.012 (2008-07-24)
	 */
	public function getBarcode() {
		return $this->barcode;
	}

	/**
	 * Print a Linear Barcode.
	 * @param string $code code to print
	 * @param string $type type of barcode (see tcpdf_barcodes_1d.php for supported formats).
	 * @param float|null $x x position in user units (null = current x position)
	 * @param float|null $y y position in user units (null = current y position)
	 * @param float|null $w width in user units (null = remaining page width)
	 * @param float|null $h height in user units (null = remaining page height)
	 * @param float|null $xres width of the smallest bar in user units (null = default value = 0.4mm)
	 * @param array $style array of options:<ul>
	 * <li>boolean $style['border'] if true prints a border</li>
	 * <li>int $style['padding'] padding to leave around the barcode in user units (set to 'auto' for automatic padding)</li>
	 * <li>int $style['hpadding'] horizontal padding in user units (set to 'auto' for automatic padding)</li>
	 * <li>int $style['vpadding'] vertical padding in user units (set to 'auto' for automatic padding)</li>
	 * <li>array $style['fgcolor'] color array for bars and text</li>
	 * <li>mixed $style['bgcolor'] color array for background (set to false for transparent)</li>
	 * <li>boolean $style['text'] if true prints text below the barcode</li>
	 * <li>string $style['label'] override default label</li>
	 * <li>string $style['font'] font name for text</li><li>int $style['fontsize'] font size for text</li>
	 * <li>int $style['stretchtext']: 0 = disabled; 1 = horizontal scaling only if necessary; 2 = forced horizontal scaling; 3 = character spacing only if necessary; 4 = forced character spacing.</li>
	 * <li>string $style['position'] horizontal position of the containing barcode cell on the page: L = left margin; C = center; R = right margin.</li>
	 * <li>string $style['align'] horizontal position of the barcode on the containing rectangle: L = left; C = center; R = right.</li>
	 * <li>string $style['stretch'] if true stretch the barcode to best fit the available width, otherwise uses $xres resolution for a single bar.</li>
	 * <li>string $style['fitwidth'] if true reduce the width to fit the barcode width + padding. When this option is enabled the 'stretch' option is automatically disabled.</li>
	 * <li>string $style['cellfitalign'] this option works only when 'fitwidth' is true and 'position' is unset or empty. Set the horizontal position of the containing barcode cell inside the specified rectangle: L = left; C = center; R = right.</li></ul>
	 * @param string $align Indicates the alignment of the pointer next to barcode insertion relative to barcode height. The value can be:<ul><li>T: top-right for LTR or top-left for RTL</li><li>M: middle-right for LTR or middle-left for RTL</li><li>B: bottom-right for LTR or bottom-left for RTL</li><li>N: next line</li></ul>
	 * @author Nicola Asuni
	 * @since 3.1.000 (2008-06-09)
	 * @public
	 */
	public function write1DBarcode($code, $type, $x=null, $y=null, $w=null, $h=null, $xres=null, $style=array(), $align='') {
		if (TCPDF_STATIC::empty_string(trim($code))) {
			return;
		}
		require_once(dirname(__FILE__).'/tcpdf_barcodes_1d.php');
		// save current graphic settings
		$gvars = $this->getGraphicVars();
		// create new barcode object
		$barcodeobj = new TCPDFBarcode($code, $type);
		$arrcode = $barcodeobj->getBarcodeArray();
		if (empty($arrcode) OR ($arrcode['maxw'] <= 0)) {
			$this->Error('Error in 1D barcode string');
		}
		if ($arrcode['maxh'] <= 0) {
			$arrcode['maxh'] = 1;
		}
		// set default values
		if (!isset($style['position'])) {
			$style['position'] = '';
		} elseif ($style['position'] == 'S') {
			// keep this for backward compatibility
			$style['position'] = '';
			$style['stretch'] = true;
		}
		if (!isset($style['fitwidth'])) {
			if (!isset($style['stretch'])) {
				$style['fitwidth'] = true;
			} else {
				$style['fitwidth'] = false;
			}
		}
		if ($style['fitwidth']) {
			// disable stretch
			$style['stretch'] = false;
		}
		if (!isset($style['stretch'])) {
			if (($w === '') OR ($w <= 0)) {
				$style['stretch'] = false;
			} else {
				$style['stretch'] = true;
			}
		}
		if (!isset($style['fgcolor'])) {
			$style['fgcolor'] = array(0,0,0); // default black
		}
		if (!isset($style['bgcolor'])) {
			$style['bgcolor'] = false; // default transparent
		}
		if (!isset($style['border'])) {
			$style['border'] = false;
		}
		$fontsize = 0;
		if (!isset($style['text'])) {
			$style['text'] = false;
		}
		if ($style['text'] AND isset($style['font'])) {
			if (isset($style['fontsize'])) {
				$fontsize = $style['fontsize'];
			}
			$this->setFont($style['font'], '', $fontsize);
		}
		if (!isset($style['stretchtext'])) {
			$style['stretchtext'] = 4;
		}
		if (TCPDF_STATIC::empty_string($x)) {
			$x = $this->x;
		}
		if (TCPDF_STATIC::empty_string($y)) {
			$y = $this->y;
		}
		// check page for no-write regions and adapt page margins if necessary
		list($x, $y) = $this->checkPageRegions($h, $x, $y);
		if (TCPDF_STATIC::empty_string($w) OR ($w <= 0)) {
			if ($this->rtl) {
				$w = $x - $this->lMargin;
			} else {
				$w = $this->w - $this->rMargin - $x;
			}
		}
		// padding
		if (!isset($style['padding'])) {
			$padding = 0;
		} elseif ($style['padding'] === 'auto') {
			$padding = 10 * ($w / ($arrcode['maxw'] + 20));
		} else {
			$padding = floatval($style['padding']);
		}
		// horizontal padding
		if (!isset($style['hpadding'])) {
			$hpadding = $padding;
		} elseif ($style['hpadding'] === 'auto') {
			$hpadding = 10 * ($w / ($arrcode['maxw'] + 20));
		} else {
			$hpadding = floatval($style['hpadding']);
		}
		// vertical padding
		if (!isset($style['vpadding'])) {
			$vpadding = $padding;
		} elseif ($style['vpadding'] === 'auto') {
			$vpadding = ($hpadding / 2);
		} else {
			$vpadding = floatval($style['vpadding']);
		}
		// calculate xres (single bar width)
		$max_xres = ($w - (2 * $hpadding)) / $arrcode['maxw'];
		if ($style['stretch']) {
			$xres = $max_xres;
		} else {
			if (TCPDF_STATIC::empty_string($xres)) {
				$xres = (0.141 * $this->k); // default bar width = 0.4 mm
			}
			if ($xres > $max_xres) {
				// correct xres to fit on $w
				$xres = $max_xres;
			}
			if ((isset($style['padding']) AND ($style['padding'] === 'auto'))
				OR (isset($style['hpadding']) AND ($style['hpadding'] === 'auto'))) {
				$hpadding = 10 * $xres;
				if (isset($style['vpadding']) AND ($style['vpadding'] === 'auto')) {
					$vpadding = ($hpadding / 2);
				}
			}
		}
		if ($style['fitwidth']) {
			$wold = $w;
			$w = (($arrcode['maxw'] * $xres) + (2 * $hpadding));
			if (isset($style['cellfitalign'])) {
				switch ($style['cellfitalign']) {
					case 'L': {
						if ($this->rtl) {
							$x -= ($wold - $w);
						}
						break;
					}
					case 'R': {
						if (!$this->rtl) {
							$x += ($wold - $w);
						}
						break;
					}
					case 'C': {
						if ($this->rtl) {
							$x -= (($wold - $w) / 2);
						} else {
							$x += (($wold - $w) / 2);
						}
						break;
					}
					default : {
						break;
					}
				}
			}
		}
		$text_height = $this->getCellHeight($fontsize / $this->k);
		// height
		if (TCPDF_STATIC::empty_string($h) OR ($h <= 0)) {
			// set default height
			$h = (($arrcode['maxw'] * $xres) / 3) + (2 * $vpadding) + $text_height;
		}
		$barh = $h - $text_height - (2 * $vpadding);
		if ($barh <=0) {
			// try to reduce font or padding to fit barcode on available height
			if ($text_height > $h) {
				$fontsize = (($h * $this->k) / (4 * $this->cell_height_ratio));
				$text_height = $this->getCellHeight($fontsize / $this->k);
				$this->setFont($style['font'], '', $fontsize);
			}
			if ($vpadding > 0) {
				$vpadding = (($h - $text_height) / 4);
			}
			$barh = $h - $text_height - (2 * $vpadding);
		}
		// fit the barcode on available space
		list($w, $h, $x, $y) = $this->fitBlock($w, $h, $x, $y, false);
		// set alignment
		$this->img_rb_y = $y + $h;
		// set alignment
		if ($this->rtl) {
			if ($style['position'] == 'L') {
				$xpos = $this->lMargin;
			} elseif ($style['position'] == 'C') {
				$xpos = ($this->w + $this->lMargin - $this->rMargin - $w) / 2;
			} elseif ($style['position'] == 'R') {
				$xpos = $this->w - $this->rMargin - $w;
			} else {
				$xpos = $x - $w;
			}
			$this->img_rb_x = $xpos;
		} else {
			if ($style['position'] == 'L') {
				$xpos = $this->lMargin;
			} elseif ($style['position'] == 'C') {
				$xpos = ($this->w + $this->lMargin - $this->rMargin - $w) / 2;
			} elseif ($style['position'] == 'R') {
				$xpos = $this->w - $this->rMargin - $w;
			} else {
				$xpos = $x;
			}
			$this->img_rb_x = $xpos + $w;
		}
		$xpos_rect = $xpos;
		if (!isset($style['align'])) {
			$style['align'] = 'C';
		}
		switch ($style['align']) {
			case 'L': {
				$xpos = $xpos_rect + $hpadding;
				break;
			}
			case 'R': {
				$xpos = $xpos_rect + ($w - ($arrcode['maxw'] * $xres)) - $hpadding;
				break;
			}
			case 'C':
			default : {
				$xpos = $xpos_rect + (($w - ($arrcode['maxw'] * $xres)) / 2);
				break;
			}
		}
		$xpos_text = $xpos;
		// barcode is always printed in LTR direction
		$tempRTL = $this->rtl;
		$this->rtl = false;
		// print background color
		if ($style['bgcolor']) {
			$this->Rect($xpos_rect, $y, $w, $h, $style['border'] ? 'DF' : 'F', '', $style['bgcolor']);
		} elseif ($style['border']) {
			$this->Rect($xpos_rect, $y, $w, $h, 'D');
		}
		// set foreground color
		$this->setDrawColorArray($style['fgcolor']);
		$this->setTextColorArray($style['fgcolor']);
		// print bars
		foreach ($arrcode['bcode'] as $k => $v) {
			$bw = ($v['w'] * $xres);
			if ($v['t']) {
				// draw a vertical bar
				$ypos = $y + $vpadding + ($v['p'] * $barh / $arrcode['maxh']);
				$this->Rect($xpos, $ypos, $bw, ($v['h'] * $barh / $arrcode['maxh']), 'F', array(), $style['fgcolor']);
			}
			$xpos += $bw;
		}
		// print text
		if ($style['text']) {
			if (isset($style['label']) AND !TCPDF_STATIC::empty_string($style['label'])) {
				$label = $style['label'];
			} else {
				$label = $code;
			}
			$txtwidth = ($arrcode['maxw'] * $xres);
			if ($this->GetStringWidth($label) > $txtwidth) {
				$style['stretchtext'] = 2;
			}
			// print text
			$this->x = $xpos_text;
			$this->y = $y + $vpadding + $barh;
			$cellpadding = $this->cell_padding;
			$this->setCellPadding(0);
			$this->Cell($txtwidth, 0, $label, 0, 0, 'C', false, '', $style['stretchtext'], false, 'T', 'T');
			$this->cell_padding = $cellpadding;
		}
		// restore original direction
		$this->rtl = $tempRTL;
		// restore previous settings
		$this->setGraphicVars($gvars);
		// set pointer to align the next text/objects
		switch($align) {
			case 'T':{
				$this->y = $y;
				$this->x = $this->img_rb_x;
				break;
			}
			case 'M':{
				$this->y = $y + round($h / 2);
				$this->x = $this->img_rb_x;
				break;
			}
			case 'B':{
				$this->y = $this->img_rb_y;
				$this->x = $this->img_rb_x;
				break;
			}
			case 'N':{
				$this->setY($this->img_rb_y);
				break;
			}
			default:{
				break;
			}
		}
		$this->endlinex = $this->img_rb_x;
	}

	/**
	 * Print 2D Barcode.
	 * @param string $code code to print
	 * @param string $type type of barcode (see tcpdf_barcodes_2d.php for supported formats).
	 * @param float|null $x x position in user units
	 * @param float|null $y y position in user units
	 * @param float|null $w width in user units
	 * @param float|null $h height in user units
	 * @param array $style array of options:<ul>
	 * <li>boolean $style['border'] if true prints a border around the barcode</li>
	 * <li>int $style['padding'] padding to leave around the barcode in barcode units (set to 'auto' for automatic padding)</li>
	 * <li>int $style['hpadding'] horizontal padding in barcode units (set to 'auto' for automatic padding)</li>
	 * <li>int $style['vpadding'] vertical padding in barcode units (set to 'auto' for automatic padding)</li>
	 * <li>int $style['module_width'] width of a single module in points</li>
	 * <li>int $style['module_height'] height of a single module in points</li>
	 * <li>array $style['fgcolor'] color array for bars and text</li>
	 * <li>mixed $style['bgcolor'] color array for background or false for transparent</li>
	 * <li>string $style['position'] barcode position on the page: L = left margin; C = center; R = right margin; S = stretch</li>
	 * @param string $align Indicates the alignment of the pointer next to barcode insertion relative to barcode height. The value can be:<ul><li>T: top-right for LTR or top-left for RTL</li><li>M: middle-right for LTR or middle-left for RTL</li><li>B: bottom-right for LTR or bottom-left for RTL</li><li>N: next line</li></ul>
	 * @param boolean $distort if true distort the barcode to fit width and height, otherwise preserve aspect ratio
	 * @author Nicola Asuni
	 * @since 4.5.037 (2009-04-07)
	 * @public
	 */
	public function write2DBarcode($code, $type, $x=null, $y=null, $w=null, $h=null, $style=array(), $align='', $distort=false) {
		if (TCPDF_STATIC::empty_string(trim($code))) {
			return;
		}
		require_once(dirname(__FILE__).'/tcpdf_barcodes_2d.php');
		// save current graphic settings
		$gvars = $this->getGraphicVars();
		// create new barcode object
		$barcodeobj = new TCPDF2DBarcode($code, $type);
		$arrcode = $barcodeobj->getBarcodeArray();
		if (empty($arrcode) OR !isset($arrcode['num_rows']) OR ($arrcode['num_rows'] == 0) OR !isset($arrcode['num_cols']) OR ($arrcode['num_cols'] == 0)) {
			$this->Error('Error in 2D barcode string');
		}
		// set default values
		if (!isset($style['position'])) {
			$style['position'] = '';
		}
		if (!isset($style['fgcolor'])) {
			$style['fgcolor'] = array(0,0,0); // default black
		}
		if (!isset($style['bgcolor'])) {
			$style['bgcolor'] = false; // default transparent
		}
		if (!isset($style['border'])) {
			$style['border'] = false;
		}
		// padding
		if (!isset($style['padding'])) {
			$style['padding'] = 0;
		} elseif ($style['padding'] === 'auto') {
			$style['padding'] = 4;
		}
		if (!isset($style['hpadding'])) {
			$style['hpadding'] = $style['padding'];
		} elseif ($style['hpadding'] === 'auto') {
			$style['hpadding'] = 4;
		}
		if (!isset($style['vpadding'])) {
			$style['vpadding'] = $style['padding'];
		} elseif ($style['vpadding'] === 'auto') {
			$style['vpadding'] = 4;
		}
		$hpad = (2 * $style['hpadding']);
		$vpad = (2 * $style['vpadding']);
		// cell (module) dimension
		if (!isset($style['module_width'])) {
			$style['module_width'] = 1; // width of a single module in points
		}
		if (!isset($style['module_height'])) {
			$style['module_height'] = 1; // height of a single module in points
		}
		if (TCPDF_STATIC::empty_string($x)) {
			$x = $this->x;
		}
		if (TCPDF_STATIC::empty_string($y)) {
			$y = $this->y;
		}
		// check page for no-write regions and adapt page margins if necessary
		list($x, $y) = $this->checkPageRegions($h, $x, $y);
		// number of barcode columns and rows
		$rows = $arrcode['num_rows'];
		$cols = $arrcode['num_cols'];
		if (($rows <= 0) || ($cols <= 0)){
			$this->Error('Error in 2D barcode string');
		}
		// module width and height
		$mw = $style['module_width'];
		$mh = $style['module_height'];
		if (($mw <= 0) OR ($mh <= 0)) {
			$this->Error('Error in 2D barcode string');
		}
		// get max dimensions
		if ($this->rtl) {
			$maxw = $x - $this->lMargin;
		} else {
			$maxw = $this->w - $this->rMargin - $x;
		}
		$maxh = ($this->h - $this->tMargin - $this->bMargin);
		$ratioHW = ((($rows * $mh) + $hpad) / (($cols * $mw) + $vpad));
		$ratioWH = ((($cols * $mw) + $vpad) / (($rows * $mh) + $hpad));
		if (!$distort) {
			if (($maxw * $ratioHW) > $maxh) {
				$maxw = $maxh * $ratioWH;
			}
			if (($maxh * $ratioWH) > $maxw) {
				$maxh = $maxw * $ratioHW;
			}
		}
		// set maximum dimensions
		if ($w > $maxw) {
			$w = $maxw;
		}
		if ($h > $maxh) {
			$h = $maxh;
		}
		// set dimensions
		if ((TCPDF_STATIC::empty_string($w) OR ($w <= 0)) AND (TCPDF_STATIC::empty_string($h) OR ($h <= 0))) {
			$w = ($cols + $hpad) * ($mw / $this->k);
			$h = ($rows + $vpad) * ($mh / $this->k);
		} elseif (($w === '') OR ($w <= 0)) {
			$w = $h * $ratioWH;
		} elseif (($h === '') OR ($h <= 0)) {
			$h = $w * $ratioHW;
		}
		// barcode size (excluding padding)
		$bw = ($w * $cols) / ($cols + $hpad);
		$bh = ($h * $rows) / ($rows + $vpad);
		// dimension of single barcode cell unit
		$cw = $bw / $cols;
		$ch = $bh / $rows;
		if (!$distort) {
			if (($cw / $ch) > ($mw / $mh)) {
				// correct horizontal distortion
				$cw = $ch * $mw / $mh;
				$bw = $cw * $cols;
				$style['hpadding'] = ($w - $bw) / (2 * $cw);
			} else {
				// correct vertical distortion
				$ch = $cw * $mh / $mw;
				$bh = $ch * $rows;
				$style['vpadding'] = ($h - $bh) / (2 * $ch);
			}
		}
		// fit the barcode on available space
		list($w, $h, $x, $y) = $this->fitBlock($w, $h, $x, $y, false);
		// set alignment
		$this->img_rb_y = $y + $h;
		// set alignment
		if ($this->rtl) {
			if ($style['position'] == 'L') {
				$xpos = $this->lMargin;
			} elseif ($style['position'] == 'C') {
				$xpos = ($this->w + $this->lMargin - $this->rMargin - $w) / 2;
			} elseif ($style['position'] == 'R') {
				$xpos = $this->w - $this->rMargin - $w;
			} else {
				$xpos = $x - $w;
			}
			$this->img_rb_x = $xpos;
		} else {
			if ($style['position'] == 'L') {
				$xpos = $this->lMargin;
			} elseif ($style['position'] == 'C') {
				$xpos = ($this->w + $this->lMargin - $this->rMargin - $w) / 2;
			} elseif ($style['position'] == 'R') {
				$xpos = $this->w - $this->rMargin - $w;
			} else {
				$xpos = $x;
			}
			$this->img_rb_x = $xpos + $w;
		}
		$xstart = $xpos + ($style['hpadding'] * $cw);
		$ystart = $y + ($style['vpadding'] * $ch);
		// barcode is always printed in LTR direction
		$tempRTL = $this->rtl;
		$this->rtl = false;
		// print background color
		if ($style['bgcolor']) {
			$this->Rect($xpos, $y, $w, $h, $style['border'] ? 'DF' : 'F', '', $style['bgcolor']);
		} elseif ($style['border']) {
			$this->Rect($xpos, $y, $w, $h, 'D');
		}
		// set foreground color
		$this->setDrawColorArray($style['fgcolor']);
		// print barcode cells
		// for each row
		for ($r = 0; $r < $rows; ++$r) {
			$xr = $xstart;
			// for each column
			for ($c = 0; $c < $cols; ++$c) {
				if ($arrcode['bcode'][$r][$c] == 1) {
					// draw a single barcode cell
					$this->Rect($xr, $ystart, $cw, $ch, 'F', array(), $style['fgcolor']);
				}
				$xr += $cw;
			}
			$ystart += $ch;
		}
		// restore original direction
		$this->rtl = $tempRTL;
		// restore previous settings
		$this->setGraphicVars($gvars);
		// set pointer to align the next text/objects
		switch($align) {
			case 'T':{
				$this->y = $y;
				$this->x = $this->img_rb_x;
				break;
			}
			case 'M':{
				$this->y = $y + round($h/2);
				$this->x = $this->img_rb_x;
				break;
			}
			case 'B':{
				$this->y = $this->img_rb_y;
				$this->x = $this->img_rb_x;
				break;
			}
			case 'N':{
				$this->setY($this->img_rb_y);
				break;
			}
			default:{
				break;
			}
		}
		$this->endlinex = $this->img_rb_x;
	}

	/**
	 * Returns an array containing current margins:
	 * <ul>
			<li>$ret['left'] = left margin</li>
			<li>$ret['right'] = right margin</li>
			<li>$ret['top'] = top margin</li>
			<li>$ret['bottom'] = bottom margin</li>
			<li>$ret['header'] = header margin</li>
			<li>$ret['footer'] = footer margin</li>
			<li>$ret['cell'] = cell padding array</li>
			<li>$ret['padding_left'] = cell left padding</li>
			<li>$ret['padding_top'] = cell top padding</li>
			<li>$ret['padding_right'] = cell right padding</li>
			<li>$ret['padding_bottom'] = cell bottom padding</li>
	 * </ul>
	 * @return array containing all margins measures
	 * @public
	 * @since 3.2.000 (2008-06-23)
	 */
	public function getMargins() {
		$ret = array(
			'left' => $this->lMargin,
			'right' => $this->rMargin,
			'top' => $this->tMargin,
			'bottom' => $this->bMargin,
			'header' => $this->header_margin,
			'footer' => $this->footer_margin,
			'cell' => $this->cell_padding,
			'padding_left' => $this->cell_padding['L'],
			'padding_top' => $this->cell_padding['T'],
			'padding_right' => $this->cell_padding['R'],
			'padding_bottom' => $this->cell_padding['B']
		);
		return $ret;
	}

	/**
	 * Returns an array containing original margins:
	 * <ul>
			<li>$ret['left'] = left margin</li>
			<li>$ret['right'] = right margin</li>
	 * </ul>
	 * @return array containing all margins measures
	 * @public
	 * @since 4.0.012 (2008-07-24)
	 */
	public function getOriginalMargins() {
		$ret = array(
			'left' => $this->original_lMargin,
			'right' => $this->original_rMargin
		);
		return $ret;
	}

	/**
	 * Returns the current font size.
	 * @return float current font size
	 * @public
	 * @since 3.2.000 (2008-06-23)
	 */
	public function getFontSize() {
		return $this->FontSize;
	}

	/**
	 * Returns the current font size in points unit.
	 * @return int current font size in points unit
	 * @public
	 * @since 3.2.000 (2008-06-23)
	 */
	public function getFontSizePt() {
		return $this->FontSizePt;
	}

	/**
	 * Returns the current font family name.
	 * @return string current font family name
	 * @public
	 * @since 4.3.008 (2008-12-05)
	 */
	public function getFontFamily() {
		return $this->FontFamily;
	}

	/**
	 * Returns the current font style.
	 * @return string current font style
	 * @public
	 * @since 4.3.008 (2008-12-05)
	 */
	public function getFontStyle() {
		return $this->FontStyle;
	}

	/**
	 * Cleanup HTML code (requires HTML Tidy library).
	 * @param string $html htmlcode to fix
	 * @param string $default_css CSS commands to add
	 * @param array|null $tagvs parameters for setHtmlVSpace method
	 * @param array|null $tidy_options options for tidy_parse_string function
	 * @return string XHTML code cleaned up
	 * @author Nicola Asuni
	 * @public
	 * @since 5.9.017 (2010-11-16)
	 * @see setHtmlVSpace()
	 */
	public function fixHTMLCode($html, $default_css='', $tagvs=null, $tidy_options=null) {
		return TCPDF_STATIC::fixHTMLCode($html, $default_css, $tagvs, $tidy_options, $this->tagvspaces);
	}

	/**
	 * Returns the border width from CSS property
	 * @param string $width border width
	 * @return int with in user units
	 * @protected
	 * @since 5.7.000 (2010-08-02)
	 */
	protected function getCSSBorderWidth($width) {
		if ($width == 'thin') {
			$width = (2 / $this->k);
		} elseif ($width == 'medium') {
			$width = (4 / $this->k);
		} elseif ($width == 'thick') {
			$width = (6 / $this->k);
		} else {
			$width = $this->getHTMLUnitToUnits($width, 1, 'px', false);
		}
		return $width;
	}

	/**
	 * Returns the border dash style from CSS property
	 * @param string $style border style to convert
	 * @return int sash style (return -1 in case of none or hidden border)
	 * @protected
	 * @since 5.7.000 (2010-08-02)
	 */
	protected function getCSSBorderDashStyle($style) {
		switch (strtolower($style)) {
			case 'none':
			case 'hidden': {
				$dash = -1;
				break;
			}
			case 'dotted': {
				$dash = 1;
				break;
			}
			case 'dashed': {
				$dash = 3;
				break;
			}
			case 'double':
			case 'groove':
			case 'ridge':
			case 'inset':
			case 'outset':
			case 'solid':
			default: {
				$dash = 0;
				break;
			}
		}
		return $dash;
	}

	/**
	 * Returns the border style array from CSS border properties
	 * @param string $cssborder border properties
	 * @return array containing border properties
	 * @protected
	 * @since 5.7.000 (2010-08-02)
	 */
	protected function getCSSBorderStyle($cssborder) {
		$bprop = preg_split('/[\s]+/', trim($cssborder));
		$count = count($bprop);
		if ($count > 0 && $bprop[$count - 1] === '!important') {
			unset($bprop[$count - 1]);
			--$count;
		}

		$border = array(); // value to be returned
		switch ($count) {
			case 2: {
				$width = 'medium';
				$style = $bprop[0];
				$color = $bprop[1];
				break;
			}
			case 1: {
				$width = 'medium';
				$style = $bprop[0];
				$color = 'black';
				break;
			}
			case 0: {
				$width = 'medium';
				$style = 'solid';
				$color = 'black';
				break;
			}
			default: {
				$width = $bprop[0];
				$style = $bprop[1];
				$color = $bprop[2];
				break;
			}
		}
		if ($style == 'none') {
			return array();
		}
		$border['cap'] = 'square';
		$border['join'] = 'miter';
		$border['dash'] = $this->getCSSBorderDashStyle($style);
		if ($border['dash'] < 0) {
			return array();
		}
		$border['width'] = $this->getCSSBorderWidth($width);
		$border['color'] = TCPDF_COLORS::convertHTMLColorToDec($color, $this->spot_colors);
		return $border;
	}

	/**
	 * Get the internal Cell padding from CSS attribute.
	 * @param string $csspadding padding properties
	 * @param float $width width of the containing element
	 * @return array of cell paddings
	 * @public
	 * @since 5.9.000 (2010-10-04)
	 */
	public function getCSSPadding($csspadding, $width=0) {
		$padding = preg_split('/[\s]+/', trim($csspadding));
		$cell_padding = array(); // value to be returned
		switch (count($padding)) {
			case 4: {
				$cell_padding['T'] = $padding[0];
				$cell_padding['R'] = $padding[1];
				$cell_padding['B'] = $padding[2];
				$cell_padding['L'] = $padding[3];
				break;
			}
			case 3: {
				$cell_padding['T'] = $padding[0];
				$cell_padding['R'] = $padding[1];
				$cell_padding['B'] = $padding[2];
				$cell_padding['L'] = $padding[1];
				break;
			}
			case 2: {
				$cell_padding['T'] = $padding[0];
				$cell_padding['R'] = $padding[1];
				$cell_padding['B'] = $padding[0];
				$cell_padding['L'] = $padding[1];
				break;
			}
			case 1: {
				$cell_padding['T'] = $padding[0];
				$cell_padding['R'] = $padding[0];
				$cell_padding['B'] = $padding[0];
				$cell_padding['L'] = $padding[0];
				break;
			}
			default: {
				return $this->cell_padding;
			}
		}
		if ($width == 0) {
			$width = $this->w - $this->lMargin - $this->rMargin;
		}
		$cell_padding['T'] = $this->getHTMLUnitToUnits($cell_padding['T'], $width, 'px', false);
		$cell_padding['R'] = $this->getHTMLUnitToUnits($cell_padding['R'], $width, 'px', false);
		$cell_padding['B'] = $this->getHTMLUnitToUnits($cell_padding['B'], $width, 'px', false);
		$cell_padding['L'] = $this->getHTMLUnitToUnits($cell_padding['L'], $width, 'px', false);
		return $cell_padding;
	}

	/**
	 * Get the internal Cell margin from CSS attribute.
	 * @param string $cssmargin margin properties
	 * @param float $width width of the containing element
	 * @return array of cell margins
	 * @public
	 * @since 5.9.000 (2010-10-04)
	 */
	public function getCSSMargin($cssmargin, $width=0) {
		$margin = preg_split('/[\s]+/', trim($cssmargin));
		$cell_margin = array(); // value to be returned
		switch (count($margin)) {
			case 4: {
				$cell_margin['T'] = $margin[0];
				$cell_margin['R'] = $margin[1];
				$cell_margin['B'] = $margin[2];
				$cell_margin['L'] = $margin[3];
				break;
			}
			case 3: {
				$cell_margin['T'] = $margin[0];
				$cell_margin['R'] = $margin[1];
				$cell_margin['B'] = $margin[2];
				$cell_margin['L'] = $margin[1];
				break;
			}
			case 2: {
				$cell_margin['T'] = $margin[0];
				$cell_margin['R'] = $margin[1];
				$cell_margin['B'] = $margin[0];
				$cell_margin['L'] = $margin[1];
				break;
			}
			case 1: {
				$cell_margin['T'] = $margin[0];
				$cell_margin['R'] = $margin[0];
				$cell_margin['B'] = $margin[0];
				$cell_margin['L'] = $margin[0];
				break;
			}
			default: {
				return $this->cell_margin;
			}
		}
		if ($width == 0) {
			$width = $this->w - $this->lMargin - $this->rMargin;
		}
		$cell_margin['T'] = $this->getHTMLUnitToUnits(str_replace('auto', '0', $cell_margin['T']), $width, 'px', false);
		$cell_margin['R'] = $this->getHTMLUnitToUnits(str_replace('auto', '0', $cell_margin['R']), $width, 'px', false);
		$cell_margin['B'] = $this->getHTMLUnitToUnits(str_replace('auto', '0', $cell_margin['B']), $width, 'px', false);
		$cell_margin['L'] = $this->getHTMLUnitToUnits(str_replace('auto', '0', $cell_margin['L']), $width, 'px', false);
		return $cell_margin;
	}

	/**
	 * Get the border-spacing from CSS attribute.
	 * @param string $cssbspace border-spacing CSS properties
	 * @param float $width width of the containing element
	 * @return array of border spacings
	 * @public
	 * @since 5.9.010 (2010-10-27)
	 */
	public function getCSSBorderMargin($cssbspace, $width=0) {
		$space = preg_split('/[\s]+/', trim($cssbspace));
		$border_spacing = array(); // value to be returned
		switch (count($space)) {
			case 2: {
				$border_spacing['H'] = $space[0];
				$border_spacing['V'] = $space[1];
				break;
			}
			case 1: {
				$border_spacing['H'] = $space[0];
				$border_spacing['V'] = $space[0];
				break;
			}
			default: {
				return array('H' => 0, 'V' => 0);
			}
		}
		if ($width == 0) {
			$width = $this->w - $this->lMargin - $this->rMargin;
		}
		$border_spacing['H'] = $this->getHTMLUnitToUnits($border_spacing['H'], $width, 'px', false);
		$border_spacing['V'] = $this->getHTMLUnitToUnits($border_spacing['V'], $width, 'px', false);
		return $border_spacing;
	}

	/**
	 * Returns the letter-spacing value from CSS value
	 * @param string $spacing letter-spacing value
	 * @param float $parent font spacing (tracking) value of the parent element
	 * @return float quantity to increases or decreases the space between characters in a text.
	 * @protected
	 * @since 5.9.000 (2010-10-02)
	 */
	protected function getCSSFontSpacing($spacing, $parent=0) {
		$val = 0; // value to be returned
		$spacing = trim($spacing);
		switch ($spacing) {
			case 'normal': {
				$val = 0;
				break;
			}
			case 'inherit': {
				if ($parent == 'normal') {
					$val = 0;
				} else {
					$val = $parent;
				}
				break;
			}
			default: {
				$val = $this->getHTMLUnitToUnits($spacing, 0, 'px', false);
			}
		}
		return $val;
	}

	/**
	 * Returns the percentage of font stretching from CSS value
	 * @param string $stretch stretch mode
	 * @param float $parent stretch value of the parent element
	 * @return float font stretching percentage
	 * @protected
	 * @since 5.9.000 (2010-10-02)
	 */
	protected function getCSSFontStretching($stretch, $parent=100) {
		$val = 100; // value to be returned
		$stretch = trim($stretch);
		switch ($stretch) {
			case 'ultra-condensed': {
				$val = 40;
				break;
			}
			case 'extra-condensed': {
				$val = 55;
				break;
			}
			case 'condensed': {
				$val = 70;
				break;
			}
			case 'semi-condensed': {
				$val = 85;
				break;
			}
			case 'normal': {
				$val = 100;
				break;
			}
			case 'semi-expanded': {
				$val = 115;
				break;
			}
			case 'expanded': {
				$val = 130;
				break;
			}
			case 'extra-expanded': {
				$val = 145;
				break;
			}
			case 'ultra-expanded': {
				$val = 160;
				break;
			}
			case 'wider': {
				$val = ($parent + 10);
				break;
			}
			case 'narrower': {
				$val = ($parent - 10);
				break;
			}
			case 'inherit': {
				if ($parent == 'normal') {
					$val = 100;
				} else {
					$val = $parent;
				}
				break;
			}
			default: {
				$val = $this->getHTMLUnitToUnits($stretch, 100, '%', false);
			}
		}
		return $val;
	}

	/**
	 * Convert HTML string containing font size value to points
	 * @param string $val String containing font size value and unit.
	 * @param float $refsize Reference font size in points.
	 * @param float $parent_size Parent font size in points.
	 * @param string $defaultunit Default unit (can be one of the following: %, em, ex, px, in, mm, pc, pt).
	 * @return float value in points
	 * @public
	 */
	public function getHTMLFontUnits($val, $refsize=12, $parent_size=12, $defaultunit='pt') {
		$refsize = TCPDF_FONTS::getFontRefSize($refsize);
		$parent_size = TCPDF_FONTS::getFontRefSize($parent_size, $refsize);
		switch ($val) {
			case 'xx-small': {
				$size = ($refsize - 4);
				break;
			}
			case 'x-small': {
				$size = ($refsize - 3);
				break;
			}
			case 'small': {
				$size = ($refsize - 2);
				break;
			}
			case 'medium': {
				$size = $refsize;
				break;
			}
			case 'large': {
				$size = ($refsize + 2);
				break;
			}
			case 'x-large': {
				$size = ($refsize + 4);
				break;
			}
			case 'xx-large': {
				$size = ($refsize + 6);
				break;
			}
			case 'smaller': {
				$size = ($parent_size - 3);
				break;
			}
			case 'larger': {
				$size = ($parent_size + 3);
				break;
			}
			default: {
				$parentSize = $this->getHTMLUnitToUnits($parent_size, $refsize, $defaultunit, true);
				$size = $this->getHTMLUnitToUnits($val, $parent_size, $defaultunit, true);
			}
		}
		return $size;
	}

	/**
	 * Returns the HTML DOM array.
	 * @param string $html html code
	 * @return array
	 * @protected
	 * @since 3.2.000 (2008-06-20)
	 */
	protected function getHtmlDomArray($html) {
		// set inheritable properties fot the first void element
		// possible inheritable properties are: azimuth, border-collapse, border-spacing, caption-side, color, cursor, direction, empty-cells, font, font-family, font-stretch, font-size, font-size-adjust, font-style, font-variant, font-weight, letter-spacing, line-height, list-style, list-style-image, list-style-position, list-style-type, orphans, page, page-break-inside, quotes, speak, speak-header, text-align, text-indent, text-transform, volume, white-space, widows, word-spacing
		$dom = array(
			array(
				'tag' => false,
				'block' => false,
				'value' => '',
				'parent' => 0,
				'hide' => false,
				'fontname' => $this->FontFamily,
				'fontstyle' => $this->FontStyle,
				'fontsize' => $this->FontSizePt,
				'font-stretch' => $this->font_stretching,
				'letter-spacing' => $this->font_spacing,
				'stroke' => $this->textstrokewidth,
				'fill' => (($this->textrendermode % 2) == 0),
				'clip' => ($this->textrendermode > 3),
				'line-height' => $this->cell_height_ratio,
				'bgcolor' => false,
				'fgcolor' => $this->fgcolor, // color
				'strokecolor' => $this->strokecolor,
				'align' => '',
				'listtype' => '',
				'text-indent' => 0,
				'text-transform' => '',
				'border' => array(),
				'dir' => $this->rtl?'rtl':'ltr',
				'width' => 0,
				'height' => 0,
				'x' => 0,
				'y' => 0,
				'w' => 0,
				'h' => 0,
				'l' => 0,
				't' => 0,
				'r' => 0,
				'b' => 0,
				'padding' => array('T' => 0, 'R' => 0, 'B' => 0, 'L' => 0),
				'margin' => array('T' => 0, 'R' => 0, 'B' => 0, 'L' => 0),
				'border-spacing' => array('H' => 0, 'V' => 0),
				'border-collapse' => 'separate',
			)
		);

		if(empty($html)) {
			return $dom;
		}
		// array of CSS styles ( selector => properties).
		$css = array();
		// get CSS array defined at previous call
		$matches = array();
		if (preg_match_all('/<cssarray>([^\<]*?)<\/cssarray>/is', $html, $matches) > 0) {
			if (isset($matches[1][0])) {
				$css = array_merge($css, json_decode($this->unhtmlentities($matches[1][0]), true));
			}
			$html = preg_replace('/<cssarray>(.*?)<\/cssarray>/is', '', $html);
		}
		// extract external CSS files
		$matches = array();
		if (preg_match_all('/<link([^\>]*?)>/is', $html, $matches) > 0) {
			foreach ($matches[1] as $key => $link) {
				$type = array();
				if (preg_match('/type[\s]*=[\s]*""text\/css""/', $link, $type)) {
					$type = array();
					preg_match('/media[\s]*=[\s]*""([^""]*)""/', $link, $type);
					// get 'all' and 'print' media, other media types are discarded
					// (all, braille, embossed, handheld, print, projection, screen, speech, tty, tv)
					if (empty($type) OR (isset($type[1]) AND (($type[1] == 'all') OR ($type[1] == 'print')))) {
						$type = array();
						if (preg_match('/href[\s]*=[\s]*""([^""]*)""/', $link, $type) > 0) {
							// read CSS data file
                            $cssdata = $this->getCachedFileContents(trim($type[1]));
							if (($cssdata !== FALSE) AND (strlen($cssdata) > 0)) {
								$css = array_merge($css, TCPDF_STATIC::extractCSSproperties($cssdata));
							}
						}
					}
				}
			}
		}
		// extract style tags
		$matches = array();
		if (preg_match_all('/<style([^\>]*?)>([^\<]*?)<\/style>/is', $html, $matches) > 0) {
			foreach ($matches[1] as $key => $media) {
				$type = array();
				preg_match('/media[\s]*=[\s]*""([^""]*)""/', $media, $type);
				// get 'all' and 'print' media, other media types are discarded
				// (all, braille, embossed, handheld, print, projection, screen, speech, tty, tv)
				if (empty($type) OR (isset($type[1]) AND (($type[1] == 'all') OR ($type[1] == 'print')))) {
					$cssdata = $matches[2][$key];
					$css = array_merge($css, TCPDF_STATIC::extractCSSproperties($cssdata));
				}
			}
		}
		// create a special tag to contain the CSS array (used for table content)
		$csstagarray = '<cssarray>'.htmlentities(json_encode($css)).'</cssarray>';
		// remove head and style blocks
		$html = preg_replace('/<head([^\>]*?)>(.*?)<\/head>/is', '', $html);
		$html = preg_replace('/<style([^\>]*?)>([^\<]*?)<\/style>/is', '', $html);
		// define block tags
		$blocktags = array('blockquote','br','dd','dl','div','dt','h1','h2','h3','h4','h5','h6','hr','li','ol','p','pre','ul','tcpdf','table','tr','td');
		// define self-closing tags
		$selfclosingtags = array('area','base','basefont','br','hr','input','img','link','meta');
		// remove all unsupported tags (the line below lists all supported tags)
		$html = strip_tags($html, '<marker/><a><b><blockquote><body><br><br/><dd><del><div><dl><dt><em><font><form><h1><h2><h3><h4><h5><h6><hr><hr/><i><img><input><label><li><ol><option><p><pre><s><select><small><span><strike><strong><sub><sup><table><tablehead><tcpdf><td><textarea><th><thead><tr><tt><u><ul>');
		//replace some blank characters
		$html = preg_replace('/<pre/', '<xre', $html); // preserve pre tag
		$html = preg_replace('/<(table|tr|td|th|tcpdf|blockquote|dd|div|dl|dt|form|h1|h2|h3|h4|h5|h6|br|hr|li|ol|ul|p)([^\>]*)>[\n\r\t]+/', '<\\1\\2>', $html);
		$html = preg_replace('@(\r\n|\r)@', ""\n"", $html);
		$repTable = array(""\t"" => ' ', ""\0"" => ' ', ""\x0B"" => ' ', ""\\"" => ""\\\\"");
		$html = strtr($html, $repTable);
		$offset = 0;
		while (($offset < strlen($html)) AND ($pos = strpos($html, '</pre>', $offset)) !== false) {
			$html_a = substr($html, 0, $offset);
			$html_b = substr($html, $offset, ($pos - $offset + 6));
			while (preg_match(""'<xre([^\>]*)>(.*?)\n(.*?)</pre>'si"", $html_b)) {
				// preserve newlines on <pre> tag
				$html_b = preg_replace(""'<xre([^\>]*)>(.*?)\n(.*?)</pre>'si"", ""<xre\\1>\\2<br />\\3</pre>"", $html_b);
			}
			while (preg_match(""'<xre([^\>]*)>(.*?)"".$this->re_space['p'].""(.*?)</pre>'"".$this->re_space['m'], $html_b)) {
				// preserve spaces on <pre> tag
				$html_b = preg_replace(""'<xre([^\>]*)>(.*?)"".$this->re_space['p'].""(.*?)</pre>'"".$this->re_space['m'], ""<xre\\1>\\2&nbsp;\\3</pre>"", $html_b);
			}
			$html = $html_a.$html_b.substr($html, $pos + 6);
			$offset = strlen($html_a.$html_b);
		}
		$offset = 0;
		while (($offset < strlen($html)) AND ($pos = strpos($html, '</textarea>', $offset)) !== false) {
			$html_a = substr($html, 0, $offset);
			$html_b = substr($html, $offset, ($pos - $offset + 11));
			while (preg_match(""'<textarea([^\>]*)>(.*?)\n(.*?)</textarea>'si"", $html_b)) {
				// preserve newlines on <textarea> tag
				$html_b = preg_replace(""'<textarea([^\>]*)>(.*?)\n(.*?)</textarea>'si"", ""<textarea\\1>\\2<TBR>\\3</textarea>"", $html_b);
				$html_b = preg_replace(""'<textarea([^\>]*)>(.*?)[\""](.*?)</textarea>'si"", ""<textarea\\1>\\2''\\3</textarea>"", $html_b);
			}
			$html = $html_a.$html_b.substr($html, $pos + 11);
			$offset = strlen($html_a.$html_b);
		}
		$html = preg_replace('/([\s]*)<option/si', '<option', $html);
		$html = preg_replace('/<\/option>([\s]*)/si', '</option>', $html);
		$offset = 0;
		while (($offset < strlen($html)) AND ($pos = strpos($html, '</option>', $offset)) !== false) {
			$html_a = substr($html, 0, $offset);
			$html_b = substr($html, $offset, ($pos - $offset + 9));
			while (preg_match(""'<option([^\>]*)>(.*?)</option>'si"", $html_b)) {
				$html_b = preg_replace(""'<option([\s]+)value=\""([^\""]*)\""([^\>]*)>(.*?)</option>'si"", ""\\2#!TaB!#\\4#!NwL!#"", $html_b);
				$html_b = preg_replace(""'<option([^\>]*)>(.*?)</option>'si"", ""\\2#!NwL!#"", $html_b);
			}
			$html = $html_a.$html_b.substr($html, $pos + 9);
			$offset = strlen($html_a.$html_b);
		}
		if (preg_match(""'</select'si"", $html)) {
			$html = preg_replace(""'<select([^\>]*)>'si"", ""<select\\1 opt=\"""", $html);
			$html = preg_replace(""'#!NwL!#</select>'si"", ""\"" />"", $html);
		}
		$html = str_replace(""\n"", ' ', $html);
		// restore textarea newlines
		$html = str_replace('<TBR>', ""\n"", $html);
		// remove extra spaces from code
		$html = preg_replace('/[\s]+<\/(table|tr|ul|ol|dl)>/', '</\\1>', $html);
		$html = preg_replace('/'.$this->re_space['p'].'+<\/(td|th|li|dt|dd)>/'.$this->re_space['m'], '</\\1>', $html);
		$html = preg_replace('/[\s]+<(tr|td|th|li|dt|dd)/', '<\\1', $html);
		$html = preg_replace('/'.$this->re_space['p'].'+<(ul|ol|dl|br)/'.$this->re_space['m'], '<\\1', $html);
		$html = preg_replace('/<\/(table|tr|td|th|blockquote|dd|dt|dl|div|dt|h1|h2|h3|h4|h5|h6|hr|li|ol|ul|p)>[\s]+</', '</\\1><', $html);
		$html = preg_replace('/<\/(td|th)>/', '<marker style=""font-size:0""/></\\1>', $html);
		$html = preg_replace('/<\/table>([\s]*)<marker style=""font-size:0""\/>/', '</table>', $html);
		$html = preg_replace('/'.$this->re_space['p'].'+<img/'.$this->re_space['m'], chr(32).'<img', $html);
		$html = preg_replace('/<img([^\>]*)>[\s]+([^\<])/xi', '<img\\1>&nbsp;\\2', $html);
		$html = preg_replace('/<img([^\>]*)>/xi', '<img\\1><span><marker style=""font-size:0""/></span>', $html);
		$html = preg_replace('/<xre/', '<pre', $html); // restore pre tag
		$html = preg_replace('/<textarea([^\>]*)>([^\<]*)<\/textarea>/xi', '<textarea\\1 value=""\\2"" />', $html);
		$html = preg_replace('/<li([^\>]*)><\/li>/', '<li\\1>&nbsp;</li>', $html);
		$html = preg_replace('/<li([^\>]*)>'.$this->re_space['p'].'*<img/'.$this->re_space['m'], '<li\\1><font size=""1"">&nbsp;</font><img', $html);
		$html = preg_replace('/<([^\>\/]*)>[\s]/', '<\\1>&nbsp;', $html); // preserve some spaces
		$html = preg_replace('/[\s]<\/([^\>]*)>/', '&nbsp;</\\1>', $html); // preserve some spaces
		$html = preg_replace('/<su([bp])/', '<zws/><su\\1', $html); // fix sub/sup alignment
		$html = preg_replace('/<\/su([bp])>/', '</su\\1><zws/>', $html); // fix sub/sup alignment
		$html = preg_replace('/'.$this->re_space['p'].'+/'.$this->re_space['m'], chr(32), $html); // replace multiple spaces with a single space
		// trim string
		$html = $this->stringTrim($html);
		// fix br tag after li
		$html = preg_replace('/<li><br([^\>]*)>/', '<li> <br\\1>', $html);
		// fix first image tag alignment
		$html = preg_replace('/^<img/', '<span style=""font-size:0""><br /></span> <img', $html, 1);
		// pattern for generic tag
		$tagpattern = '/(<[^>]+>)/';
		// explodes the string
		$a = preg_split($tagpattern, $html, -1, PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY);
		// count elements
		$maxel = count($a);
		$elkey = 0;
		$thead = false; // true when we are inside the THEAD tag
		$key = 1;
		$level = array();
		array_push($level, 0); // root
		while ($elkey < $maxel) {
			$dom[$key] = array();
			$element = $a[$elkey];
			$dom[$key]['elkey'] = $elkey;
			if (preg_match($tagpattern, $element)) {
				// html tag
				$element = substr($element, 1, -1);
				// get tag name
				preg_match('/[\/]?([a-zA-Z0-9]*)/', $element, $tag);
				$tagname = strtolower($tag[1]);
				// check if we are inside a table header
				if ($tagname == 'thead') {
					if ($element[0] == '/') {
						$thead = false;
					} else {
						$thead = true;
					}
					++$elkey;
					continue;
				}
				$dom[$key]['tag'] = true;
				$dom[$key]['value'] = $tagname;
				if (in_array($dom[$key]['value'], $blocktags)) {
					$dom[$key]['block'] = true;
				} else {
					$dom[$key]['block'] = false;
				}
				if ($element[0] == '/') {
					// *** closing html tag
					$dom[$key]['opening'] = false;
					$dom[$key]['parent'] = end($level);
					array_pop($level);
					$dom[$key]['hide'] = $dom[($dom[($dom[$key]['parent'])]['parent'])]['hide'];
					$dom[$key]['fontname'] = $dom[($dom[($dom[$key]['parent'])]['parent'])]['fontname'];
					$dom[$key]['fontstyle'] = $dom[($dom[($dom[$key]['parent'])]['parent'])]['fontstyle'];
					$dom[$key]['fontsize'] = $dom[($dom[($dom[$key]['parent'])]['parent'])]['fontsize'];
					$dom[$key]['font-stretch'] = $dom[($dom[($dom[$key]['parent'])]['parent'])]['font-stretch'];
					$dom[$key]['letter-spacing'] = $dom[($dom[($dom[$key]['parent'])]['parent'])]['letter-spacing'];
					$dom[$key]['stroke'] = $dom[($dom[($dom[$key]['parent'])]['parent'])]['stroke'];
					$dom[$key]['fill'] = $dom[($dom[($dom[$key]['parent'])]['parent'])]['fill'];
					$dom[$key]['clip'] = $dom[($dom[($dom[$key]['parent'])]['parent'])]['clip'];
					$dom[$key]['line-height'] = $dom[($dom[($dom[$key]['parent'])]['parent'])]['line-height'];
					$dom[$key]['bgcolor'] = $dom[($dom[($dom[$key]['parent'])]['parent'])]['bgcolor'];
					$dom[$key]['fgcolor'] = $dom[($dom[($dom[$key]['parent'])]['parent'])]['fgcolor'];
					$dom[$key]['strokecolor'] = $dom[($dom[($dom[$key]['parent'])]['parent'])]['strokecolor'];
					$dom[$key]['align'] = $dom[($dom[($dom[$key]['parent'])]['parent'])]['align'];
					$dom[$key]['text-transform'] = $dom[($dom[($dom[$key]['parent'])]['parent'])]['text-transform'];
					$dom[$key]['dir'] = $dom[($dom[($dom[$key]['parent'])]['parent'])]['dir'];
					if (isset($dom[($dom[($dom[$key]['parent'])]['parent'])]['listtype'])) {
						$dom[$key]['listtype'] = $dom[($dom[($dom[$key]['parent'])]['parent'])]['listtype'];
					}
					// set the number of columns in table tag
					if (($dom[$key]['value'] == 'tr') AND (!isset($dom[($dom[($dom[$key]['parent'])]['parent'])]['cols']))) {
						$dom[($dom[($dom[$key]['parent'])]['parent'])]['cols'] = $dom[($dom[$key]['parent'])]['cols'];
					}
					if (($dom[$key]['value'] == 'td') OR ($dom[$key]['value'] == 'th')) {
						$dom[($dom[$key]['parent'])]['content'] = $csstagarray;
						for ($i = ($dom[$key]['parent'] + 1); $i < $key; ++$i) {
							$dom[($dom[$key]['parent'])]['content'] .= stripslashes($a[$dom[$i]['elkey']]);
						}
						$key = $i;
						// mark nested tables
						$dom[($dom[$key]['parent'])]['content'] = str_replace('<table', '<table nested=""true""', $dom[($dom[$key]['parent'])]['content']);
						// remove thead sections from nested tables
						$dom[($dom[$key]['parent'])]['content'] = str_replace('<thead>', '', $dom[($dom[$key]['parent'])]['content']);
						$dom[($dom[$key]['parent'])]['content'] = str_replace('</thead>', '', $dom[($dom[$key]['parent'])]['content']);
					}
					// store header rows on a new table
					if (
						($dom[$key]['value'] === 'tr')
						&& !empty($dom[($dom[$key]['parent'])]['thead'])
						&& ($dom[($dom[$key]['parent'])]['thead'] === true)
					) {
						if (TCPDF_STATIC::empty_string($dom[($dom[($dom[$key]['parent'])]['parent'])]['thead'])) {
							$dom[($dom[($dom[$key]['parent'])]['parent'])]['thead'] = $csstagarray.$a[$dom[($dom[($dom[$key]['parent'])]['parent'])]['elkey']];
						}
						for ($i = $dom[$key]['parent']; $i <= $key; ++$i) {
							$dom[($dom[($dom[$key]['parent'])]['parent'])]['thead'] .= $a[$dom[$i]['elkey']];
						}
						if (!isset($dom[($dom[$key]['parent'])]['attribute'])) {
							$dom[($dom[$key]['parent'])]['attribute'] = array();
						}
						// header elements must be always contained in a single page
						$dom[($dom[$key]['parent'])]['attribute']['nobr'] = 'true';
					}
					if (($dom[$key]['value'] == 'table') AND (!TCPDF_STATIC::empty_string($dom[($dom[$key]['parent'])]['thead']))) {
						// remove the nobr attributes from the table header
						$dom[($dom[$key]['parent'])]['thead'] = str_replace(' nobr=""true""', '', $dom[($dom[$key]['parent'])]['thead']);
						$dom[($dom[$key]['parent'])]['thead'] .= '</tablehead>';
					}
				} else {
					// *** opening or self-closing html tag
					$dom[$key]['opening'] = true;
					$dom[$key]['parent'] = end($level);
					if ((substr($element, -1, 1) == '/') OR (in_array($dom[$key]['value'], $selfclosingtags))) {
						// self-closing tag
						$dom[$key]['self'] = true;
					} else {
						// opening tag
						array_push($level, $key);
						$dom[$key]['self'] = false;
					}
					// copy some values from parent
					$parentkey = 0;
					if ($key > 0) {
						$parentkey = $dom[$key]['parent'];
						$dom[$key]['hide'] = $dom[$parentkey]['hide'];
						$dom[$key]['fontname'] = $dom[$parentkey]['fontname'];
						$dom[$key]['fontstyle'] = $dom[$parentkey]['fontstyle'];
						$dom[$key]['fontsize'] = $dom[$parentkey]['fontsize'];
						$dom[$key]['font-stretch'] = $dom[$parentkey]['font-stretch'];
						$dom[$key]['letter-spacing'] = $dom[$parentkey]['letter-spacing'];
						$dom[$key]['stroke'] = $dom[$parentkey]['stroke'];
						$dom[$key]['fill'] = $dom[$parentkey]['fill'];
						$dom[$key]['clip'] = $dom[$parentkey]['clip'];
						$dom[$key]['line-height'] = $dom[$parentkey]['line-height'];
						$dom[$key]['bgcolor'] = $dom[$parentkey]['bgcolor'];
						$dom[$key]['fgcolor'] = $dom[$parentkey]['fgcolor'];
						$dom[$key]['strokecolor'] = $dom[$parentkey]['strokecolor'];
						$dom[$key]['align'] = $dom[$parentkey]['align'];
						$dom[$key]['listtype'] = $dom[$parentkey]['listtype'];
						$dom[$key]['text-indent'] = $dom[$parentkey]['text-indent'];
						$dom[$key]['text-transform'] = $dom[$parentkey]['text-transform'];
						$dom[$key]['border'] = array();
						$dom[$key]['dir'] = $dom[$parentkey]['dir'];
					}
					// get attributes
					preg_match_all('/([^=\s]*)[\s]*=[\s]*""([^""]*)""/', $element, $attr_array, PREG_PATTERN_ORDER);
					$dom[$key]['attribute'] = array(); // reset attribute array
                    foreach($attr_array[1] as $id => $name) {
                        $dom[$key]['attribute'][strtolower($name)] = $attr_array[2][$id];
                    }
					if (!empty($css)) {
						// merge CSS style to current style
						list($dom[$key]['csssel'], $dom[$key]['cssdata']) = TCPDF_STATIC::getCSSdataArray($dom, $key, $css);
						$dom[$key]['attribute']['style'] = TCPDF_STATIC::getTagStyleFromCSSarray($dom[$key]['cssdata']);
					}
					// split style attributes
					if (isset($dom[$key]['attribute']['style']) AND !empty($dom[$key]['attribute']['style'])) {
						// get style attributes
						preg_match_all('/([^;:\s]*):([^;]*)/', $dom[$key]['attribute']['style'], $style_array, PREG_PATTERN_ORDER);
						$dom[$key]['style'] = array(); // reset style attribute array
                        foreach($style_array[1] as $id => $name) {
                            // in case of duplicate attribute the last replace the previous
                            $dom[$key]['style'][strtolower($name)] = trim($style_array[2][$id]);
                        }
						// --- get some style attributes ---
						// text direction
						if (isset($dom[$key]['style']['direction'])) {
							$dom[$key]['dir'] = $dom[$key]['style']['direction'];
						}
						// display
						if (isset($dom[$key]['style']['display'])) {
							$dom[$key]['hide'] = (trim(strtolower($dom[$key]['style']['display'])) == 'none');
						}
						// font family
						if (isset($dom[$key]['style']['font-family'])) {
							$dom[$key]['fontname'] = $this->getFontFamilyName($dom[$key]['style']['font-family']);
						}
						// list-style-type
						if (isset($dom[$key]['style']['list-style-type'])) {
							$dom[$key]['listtype'] = trim(strtolower($dom[$key]['style']['list-style-type']));
							if ($dom[$key]['listtype'] == 'inherit') {
								$dom[$key]['listtype'] = $dom[$parentkey]['listtype'];
							}
						}
						// text-indent
						if (isset($dom[$key]['style']['text-indent'])) {
							$dom[$key]['text-indent'] = $this->getHTMLUnitToUnits($dom[$key]['style']['text-indent']);
							if ($dom[$key]['text-indent'] == 'inherit') {
								$dom[$key]['text-indent'] = $dom[$parentkey]['text-indent'];
							}
						}
						// text-transform
						if (isset($dom[$key]['style']['text-transform'])) {
							$dom[$key]['text-transform'] = $dom[$key]['style']['text-transform'];
						}
						// font size
						if (isset($dom[$key]['style']['font-size'])) {
							$fsize = trim($dom[$key]['style']['font-size']);
							$dom[$key]['fontsize'] = $this->getHTMLFontUnits($fsize, $dom[0]['fontsize'], $dom[$parentkey]['fontsize'], 'pt');
						}
						// font-stretch
						if (isset($dom[$key]['style']['font-stretch'])) {
							$dom[$key]['font-stretch'] = $this->getCSSFontStretching($dom[$key]['style']['font-stretch'], $dom[$parentkey]['font-stretch']);
						}
						// letter-spacing
						if (isset($dom[$key]['style']['letter-spacing'])) {
							$dom[$key]['letter-spacing'] = $this->getCSSFontSpacing($dom[$key]['style']['letter-spacing'], $dom[$parentkey]['letter-spacing']);
						}
						// line-height (internally is the cell height ratio)
						if (isset($dom[$key]['style']['line-height'])) {
							$lineheight = trim($dom[$key]['style']['line-height']);
							switch ($lineheight) {
								// A normal line height. This is default
								case 'normal': {
									$dom[$key]['line-height'] = $dom[0]['line-height'];
									break;
								}
								case 'inherit': {
									$dom[$key]['line-height'] = $dom[$parentkey]['line-height'];
								}
								default: {
									if (is_numeric($lineheight)) {
										// convert to percentage of font height
										$lineheight = ($lineheight * 100).'%';
									}
									$dom[$key]['line-height'] = $this->getHTMLUnitToUnits($lineheight, 1, '%', true);
									if (substr($lineheight, -1) !== '%') {
										if ($dom[$key]['fontsize'] <= 0) {
											$dom[$key]['line-height'] = 1;
										} else {
											$dom[$key]['line-height'] = (($dom[$key]['line-height'] - $this->cell_padding['T'] - $this->cell_padding['B']) / $dom[$key]['fontsize']);
										}
									}
								}
							}
						}
						// font style
						if (isset($dom[$key]['style']['font-weight'])) {
							if (strtolower($dom[$key]['style']['font-weight'][0]) == 'n') {
								if (strpos($dom[$key]['fontstyle'], 'B') !== false) {
									$dom[$key]['fontstyle'] = str_replace('B', '', $dom[$key]['fontstyle']);
								}
							} elseif (strtolower($dom[$key]['style']['font-weight'][0]) == 'b') {
								$dom[$key]['fontstyle'] .= 'B';
							}
						}
						if (isset($dom[$key]['style']['font-style']) AND (strtolower($dom[$key]['style']['font-style'][0]) == 'i')) {
							$dom[$key]['fontstyle'] .= 'I';
						}
						// font color
						if (isset($dom[$key]['style']['color']) AND (!TCPDF_STATIC::empty_string($dom[$key]['style']['color']))) {
							$dom[$key]['fgcolor'] = TCPDF_COLORS::convertHTMLColorToDec($dom[$key]['style']['color'], $this->spot_colors);
						} elseif ($dom[$key]['value'] == 'a') {
							$dom[$key]['fgcolor'] = $this->htmlLinkColorArray;
						}
						// background color
						if (isset($dom[$key]['style']['background-color']) AND (!TCPDF_STATIC::empty_string($dom[$key]['style']['background-color']))) {
							$dom[$key]['bgcolor'] = TCPDF_COLORS::convertHTMLColorToDec($dom[$key]['style']['background-color'], $this->spot_colors);
						}
						// text-decoration
						if (isset($dom[$key]['style']['text-decoration'])) {
							$decors = explode(' ', strtolower($dom[$key]['style']['text-decoration']));
							foreach ($decors as $dec) {
								$dec = trim($dec);
								if (!TCPDF_STATIC::empty_string($dec)) {
									if ($dec[0] == 'u') {
										// underline
										$dom[$key]['fontstyle'] .= 'U';
									} elseif ($dec[0] == 'l') {
										// line-through
										$dom[$key]['fontstyle'] .= 'D';
									} elseif ($dec[0] == 'o') {
										// overline
										$dom[$key]['fontstyle'] .= 'O';
									}
								}
							}
						} elseif ($dom[$key]['value'] == 'a') {
							$dom[$key]['fontstyle'] = $this->htmlLinkFontStyle;
						}
						// check for width attribute
						if (isset($dom[$key]['style']['width'])) {
							$dom[$key]['width'] = $dom[$key]['style']['width'];
						}
						// check for height attribute
						if (isset($dom[$key]['style']['height'])) {
							$dom[$key]['height'] = $dom[$key]['style']['height'];
						}
						// check for text alignment
						if (isset($dom[$key]['style']['text-align'])) {
							$dom[$key]['align'] = strtoupper($dom[$key]['style']['text-align'][0]);
						}
						// check for CSS border properties
						if (isset($dom[$key]['style']['border'])) {
							$borderstyle = $this->getCSSBorderStyle($dom[$key]['style']['border']);
							if (!empty($borderstyle)) {
								$dom[$key]['border']['LTRB'] = $borderstyle;
							}
						}
						if (isset($dom[$key]['style']['border-color'])) {
							$brd_colors = preg_split('/[\s]+/', trim($dom[$key]['style']['border-color']));
							if (isset($brd_colors[3])) {
								$dom[$key]['border']['L']['color'] = TCPDF_COLORS::convertHTMLColorToDec($brd_colors[3], $this->spot_colors);
							}
							if (isset($brd_colors[1])) {
								$dom[$key]['border']['R']['color'] = TCPDF_COLORS::convertHTMLColorToDec($brd_colors[1], $this->spot_colors);
							}
							if (isset($brd_colors[0])) {
								$dom[$key]['border']['T']['color'] = TCPDF_COLORS::convertHTMLColorToDec($brd_colors[0], $this->spot_colors);
							}
							if (isset($brd_colors[2])) {
								$dom[$key]['border']['B']['color'] = TCPDF_COLORS::convertHTMLColorToDec($brd_colors[2], $this->spot_colors);
							}
						}
						if (isset($dom[$key]['style']['border-width'])) {
							$brd_widths = preg_split('/[\s]+/', trim($dom[$key]['style']['border-width']));
							if (isset($brd_widths[3])) {
								$dom[$key]['border']['L']['width'] = $this->getCSSBorderWidth($brd_widths[3]);
							}
							if (isset($brd_widths[1])) {
								$dom[$key]['border']['R']['width'] = $this->getCSSBorderWidth($brd_widths[1]);
							}
							if (isset($brd_widths[0])) {
								$dom[$key]['border']['T']['width'] = $this->getCSSBorderWidth($brd_widths[0]);
							}
							if (isset($brd_widths[2])) {
								$dom[$key]['border']['B']['width'] = $this->getCSSBorderWidth($brd_widths[2]);
							}
						}
						if (isset($dom[$key]['style']['border-style'])) {
							$brd_styles = preg_split('/[\s]+/', trim($dom[$key]['style']['border-style']));
							if (isset($brd_styles[3]) AND ($brd_styles[3]!='none')) {
								$dom[$key]['border']['L']['cap'] = 'square';
								$dom[$key]['border']['L']['join'] = 'miter';
								$dom[$key]['border']['L']['dash'] = $this->getCSSBorderDashStyle($brd_styles[3]);
								if ($dom[$key]['border']['L']['dash'] < 0) {
									$dom[$key]['border']['L'] = array();
								}
							}
							if (isset($brd_styles[1])) {
								$dom[$key]['border']['R']['cap'] = 'square';
								$dom[$key]['border']['R']['join'] = 'miter';
								$dom[$key]['border']['R']['dash'] = $this->getCSSBorderDashStyle($brd_styles[1]);
								if ($dom[$key]['border']['R']['dash'] < 0) {
									$dom[$key]['border']['R'] = array();
								}
							}
							if (isset($brd_styles[0])) {
								$dom[$key]['border']['T']['cap'] = 'square';
								$dom[$key]['border']['T']['join'] = 'miter';
								$dom[$key]['border']['T']['dash'] = $this->getCSSBorderDashStyle($brd_styles[0]);
								if ($dom[$key]['border']['T']['dash'] < 0) {
									$dom[$key]['border']['T'] = array();
								}
							}
							if (isset($brd_styles[2])) {
								$dom[$key]['border']['B']['cap'] = 'square';
								$dom[$key]['border']['B']['join'] = 'miter';
								$dom[$key]['border']['B']['dash'] = $this->getCSSBorderDashStyle($brd_styles[2]);
								if ($dom[$key]['border']['B']['dash'] < 0) {
									$dom[$key]['border']['B'] = array();
								}
							}
						}
						$cellside = array('L' => 'left', 'R' => 'right', 'T' => 'top', 'B' => 'bottom');
						foreach ($cellside as $bsk => $bsv) {
							if (isset($dom[$key]['style']['border-'.$bsv])) {
								$borderstyle = $this->getCSSBorderStyle($dom[$key]['style']['border-'.$bsv]);
								if (!empty($borderstyle)) {
									$dom[$key]['border'][$bsk] = $borderstyle;
								}
							}
							if (isset($dom[$key]['style']['border-'.$bsv.'-color'])) {
								$dom[$key]['border'][$bsk]['color'] = TCPDF_COLORS::convertHTMLColorToDec($dom[$key]['style']['border-'.$bsv.'-color'], $this->spot_colors);
							}
							if (isset($dom[$key]['style']['border-'.$bsv.'-width'])) {
								$dom[$key]['border'][$bsk]['width'] = $this->getCSSBorderWidth($dom[$key]['style']['border-'.$bsv.'-width']);
							}
							if (isset($dom[$key]['style']['border-'.$bsv.'-style'])) {
								$dom[$key]['border'][$bsk]['dash'] = $this->getCSSBorderDashStyle($dom[$key]['style']['border-'.$bsv.'-style']);
								if ($dom[$key]['border'][$bsk]['dash'] < 0) {
									$dom[$key]['border'][$bsk] = array();
								}
							}
						}
						// check for CSS padding properties
						if (isset($dom[$key]['style']['padding'])) {
							$dom[$key]['padding'] = $this->getCSSPadding($dom[$key]['style']['padding']);
						} else {
							$dom[$key]['padding'] = $this->cell_padding;
						}
						foreach ($cellside as $psk => $psv) {
							if (isset($dom[$key]['style']['padding-'.$psv])) {
								$dom[$key]['padding'][$psk] = $this->getHTMLUnitToUnits($dom[$key]['style']['padding-'.$psv], 0, 'px', false);
							}
						}
						// check for CSS margin properties
						if (isset($dom[$key]['style']['margin'])) {
							$dom[$key]['margin'] = $this->getCSSMargin($dom[$key]['style']['margin']);
						} else {
							$dom[$key]['margin'] = $this->cell_margin;
						}
						foreach ($cellside as $psk => $psv) {
							if (isset($dom[$key]['style']['margin-'.$psv])) {
								$dom[$key]['margin'][$psk] = $this->getHTMLUnitToUnits(str_replace('auto', '0', $dom[$key]['style']['margin-'.$psv]), 0, 'px', false);
							}
						}
						// check for CSS border-spacing properties
						if (isset($dom[$key]['style']['border-spacing'])) {
							$dom[$key]['border-spacing'] = $this->getCSSBorderMargin($dom[$key]['style']['border-spacing']);
						}
						// page-break-inside
						if (isset($dom[$key]['style']['page-break-inside']) AND ($dom[$key]['style']['page-break-inside'] == 'avoid')) {
							$dom[$key]['attribute']['nobr'] = 'true';
						}
						// page-break-before
						if (isset($dom[$key]['style']['page-break-before'])) {
							if ($dom[$key]['style']['page-break-before'] == 'always') {
								$dom[$key]['attribute']['pagebreak'] = 'true';
							} elseif ($dom[$key]['style']['page-break-before'] == 'left') {
								$dom[$key]['attribute']['pagebreak'] = 'left';
							} elseif ($dom[$key]['style']['page-break-before'] == 'right') {
								$dom[$key]['attribute']['pagebreak'] = 'right';
							}
						}
						// page-break-after
						if (isset($dom[$key]['style']['page-break-after'])) {
							if ($dom[$key]['style']['page-break-after'] == 'always') {
								$dom[$key]['attribute']['pagebreakafter'] = 'true';
							} elseif ($dom[$key]['style']['page-break-after'] == 'left') {
								$dom[$key]['attribute']['pagebreakafter'] = 'left';
							} elseif ($dom[$key]['style']['page-break-after'] == 'right') {
								$dom[$key]['attribute']['pagebreakafter'] = 'right';
							}
						}
					}
					if (isset($dom[$key]['attribute']['display'])) {
						$dom[$key]['hide'] = (trim(strtolower($dom[$key]['attribute']['display'])) == 'none');
					}
					if (isset($dom[$key]['attribute']['border']) AND ($dom[$key]['attribute']['border'] != 0)) {
						$borderstyle = $this->getCSSBorderStyle($dom[$key]['attribute']['border'].' solid black');
						if (!empty($borderstyle)) {
							$dom[$key]['border']['LTRB'] = $borderstyle;
						}
					}
					// check for font tag
					if ($dom[$key]['value'] == 'font') {
						// font family
						if (isset($dom[$key]['attribute']['face'])) {
							$dom[$key]['fontname'] = $this->getFontFamilyName($dom[$key]['attribute']['face']);
						}
						// font size
						if (isset($dom[$key]['attribute']['size'])) {
							if ($key > 0) {
								if ($dom[$key]['attribute']['size'][0] == '+') {
									$dom[$key]['fontsize'] = $dom[($dom[$key]['parent'])]['fontsize'] + intval(substr($dom[$key]['attribute']['size'], 1));
								} elseif ($dom[$key]['attribute']['size'][0] == '-') {
									$dom[$key]['fontsize'] = $dom[($dom[$key]['parent'])]['fontsize'] - intval(substr($dom[$key]['attribute']['size'], 1));
								} else {
									$dom[$key]['fontsize'] = intval($dom[$key]['attribute']['size']);
								}
							} else {
								$dom[$key]['fontsize'] = intval($dom[$key]['attribute']['size']);
							}
						}
					}
					// force natural alignment for lists
					if ((($dom[$key]['value'] == 'ul') OR ($dom[$key]['value'] == 'ol') OR ($dom[$key]['value'] == 'dl'))
						AND (!isset($dom[$key]['align']) OR TCPDF_STATIC::empty_string($dom[$key]['align']) OR ($dom[$key]['align'] != 'J'))) {
						if ($this->rtl) {
							$dom[$key]['align'] = 'R';
						} else {
							$dom[$key]['align'] = 'L';
						}
					}
					if (($dom[$key]['value'] == 'small') OR ($dom[$key]['value'] == 'sup') OR ($dom[$key]['value'] == 'sub')) {
						if (!isset($dom[$key]['attribute']['size']) AND !isset($dom[$key]['style']['font-size'])) {
							$dom[$key]['fontsize'] = $dom[$key]['fontsize'] * K_SMALL_RATIO;
						}
					}
					if (($dom[$key]['value'] == 'strong') OR ($dom[$key]['value'] == 'b')) {
						$dom[$key]['fontstyle'] .= 'B';
					}
					if (($dom[$key]['value'] == 'em') OR ($dom[$key]['value'] == 'i')) {
						$dom[$key]['fontstyle'] .= 'I';
					}
					if ($dom[$key]['value'] == 'u') {
						$dom[$key]['fontstyle'] .= 'U';
					}
					if (($dom[$key]['value'] == 'del') OR ($dom[$key]['value'] == 's') OR ($dom[$key]['value'] == 'strike')) {
						$dom[$key]['fontstyle'] .= 'D';
					}
					if (!isset($dom[$key]['style']['text-decoration']) AND ($dom[$key]['value'] == 'a')) {
						$dom[$key]['fontstyle'] = $this->htmlLinkFontStyle;
					}
					if (($dom[$key]['value'] == 'pre') OR ($dom[$key]['value'] == 'tt')) {
						$dom[$key]['fontname'] = $this->default_monospaced_font;
					}
					if (!empty($dom[$key]['value']) AND ($dom[$key]['value'][0] == 'h') AND (intval($dom[$key]['value'][1]) > 0) AND (intval($dom[$key]['value'][1]) < 7)) {
						// headings h1, h2, h3, h4, h5, h6
						if (!isset($dom[$key]['attribute']['size']) AND !isset($dom[$key]['style']['font-size'])) {
							$headsize = (4 - intval($dom[$key]['value'][1])) * 2;
							$dom[$key]['fontsize'] = $dom[0]['fontsize'] + $headsize;
						}
						if (!isset($dom[$key]['style']['font-weight'])) {
							$dom[$key]['fontstyle'] .= 'B';
						}
					}
					if (($dom[$key]['value'] == 'table')) {
						$dom[$key]['rows'] = 0; // number of rows
						$dom[$key]['trids'] = array(); // IDs of TR elements
						$dom[$key]['thead'] = ''; // table header rows
					}
					if (($dom[$key]['value'] == 'tr')) {
						$dom[$key]['cols'] = 0;
						if ($thead) {
							$dom[$key]['thead'] = true;
							// rows on thead block are printed as a separate table
						} else {
							$dom[$key]['thead'] = false;
							$parent = $dom[$key]['parent'];

							if (!isset($dom[$parent]['rows'])) {
								$dom[$parent]['rows'] = 0;
							}
							// store the number of rows on table element
							++$dom[$parent]['rows'];

							if (!isset($dom[$parent]['trids'])) {
								$dom[$parent]['trids'] = array();
							}

							// store the TR elements IDs on table element
							array_push($dom[$parent]['trids'], $key);
						}
					}
					if (($dom[$key]['value'] == 'th') OR ($dom[$key]['value'] == 'td')) {
						if (isset($dom[$key]['attribute']['colspan'])) {
							$colspan = intval($dom[$key]['attribute']['colspan']);
						} else {
							$colspan = 1;
						}
						$dom[$key]['attribute']['colspan'] = $colspan;
						$dom[($dom[$key]['parent'])]['cols'] += $colspan;
					}
					// text direction
					if (isset($dom[$key]['attribute']['dir'])) {
						$dom[$key]['dir'] = $dom[$key]['attribute']['dir'];
					}
					// set foreground color attribute
					if (isset($dom[$key]['attribute']['color']) AND (!TCPDF_STATIC::empty_string($dom[$key]['attribute']['color']))) {
						$dom[$key]['fgcolor'] = TCPDF_COLORS::convertHTMLColorToDec($dom[$key]['attribute']['color'], $this->spot_colors);
					} elseif (!isset($dom[$key]['style']['color']) AND ($dom[$key]['value'] == 'a')) {
						$dom[$key]['fgcolor'] = $this->htmlLinkColorArray;
					}
					// set background color attribute
					if (isset($dom[$key]['attribute']['bgcolor']) AND (!TCPDF_STATIC::empty_string($dom[$key]['attribute']['bgcolor']))) {
						$dom[$key]['bgcolor'] = TCPDF_COLORS::convertHTMLColorToDec($dom[$key]['attribute']['bgcolor'], $this->spot_colors);
					}
					// set stroke color attribute
					if (isset($dom[$key]['attribute']['strokecolor']) AND (!TCPDF_STATIC::empty_string($dom[$key]['attribute']['strokecolor']))) {
						$dom[$key]['strokecolor'] = TCPDF_COLORS::convertHTMLColorToDec($dom[$key]['attribute']['strokecolor'], $this->spot_colors);
					}
					// check for width attribute
					if (isset($dom[$key]['attribute']['width'])) {
						$dom[$key]['width'] = $dom[$key]['attribute']['width'];
					}
					// check for height attribute
					if (isset($dom[$key]['attribute']['height'])) {
						$dom[$key]['height'] = $dom[$key]['attribute']['height'];
					}
					// check for text alignment
					if (isset($dom[$key]['attribute']['align']) AND (!TCPDF_STATIC::empty_string($dom[$key]['attribute']['align'])) AND ($dom[$key]['value'] !== 'img')) {
						$dom[$key]['align'] = strtoupper($dom[$key]['attribute']['align'][0]);
					}
					// check for text rendering mode (the following attributes do not exist in HTML)
					if (isset($dom[$key]['attribute']['stroke'])) {
						// font stroke width
						$dom[$key]['stroke'] = $this->getHTMLUnitToUnits($dom[$key]['attribute']['stroke'], $dom[$key]['fontsize'], 'pt', true);
					}
					if (isset($dom[$key]['attribute']['fill'])) {
						// font fill
						if ($dom[$key]['attribute']['fill'] == 'true') {
							$dom[$key]['fill'] = true;
						} else {
							$dom[$key]['fill'] = false;
						}
					}
					if (isset($dom[$key]['attribute']['clip'])) {
						// clipping mode
						if ($dom[$key]['attribute']['clip'] == 'true') {
							$dom[$key]['clip'] = true;
						} else {
							$dom[$key]['clip'] = false;
						}
					}
				} // end opening tag
			} else {
				// text
				$dom[$key]['tag'] = false;
				$dom[$key]['block'] = false;
				$dom[$key]['parent'] = end($level);
				$dom[$key]['dir'] = $dom[$dom[$key]['parent']]['dir'];
				if (!empty($dom[$dom[$key]['parent']]['text-transform'])) {
					// text-transform for unicode requires mb_convert_case (Multibyte String Functions)
					if (function_exists('mb_convert_case')) {
						$ttm = array('capitalize' => MB_CASE_TITLE, 'uppercase' => MB_CASE_UPPER, 'lowercase' => MB_CASE_LOWER);
						if (isset($ttm[$dom[$dom[$key]['parent']]['text-transform']])) {
							$element = mb_convert_case($element, $ttm[$dom[$dom[$key]['parent']]['text-transform']], $this->encoding);
						}
					} elseif (!$this->isunicode) {
						switch ($dom[$dom[$key]['parent']]['text-transform']) {
							case 'capitalize': {
								$element = ucwords(strtolower($element));
								break;
							}
							case 'uppercase': {
								$element = strtoupper($element);
								break;
							}
							case 'lowercase': {
								$element = strtolower($element);
								break;
							}
						}
					}
					$element = preg_replace(""/&NBSP;/i"", ""&nbsp;"", $element);
				}
				$dom[$key]['value'] = stripslashes($this->unhtmlentities($element));
			}
			++$elkey;
			++$key;
		}
		return $dom;
	}

	/**
	 * Returns the string used to find spaces
	 * @return string
	 * @protected
	 * @author Nicola Asuni
	 * @since 4.8.024 (2010-01-15)
	 */
	protected function getSpaceString() {
		$spacestr = chr(32);
		if ($this->isUnicodeFont()) {
			$spacestr = chr(0).chr(32);
		}
		return $spacestr;
	}

	/**
	 * Calculates the hash value of the given data.
	 *
	 * @param string $data The data to be hashed.
	 * @return string The hashed value of the data.
	 */
	protected function hashTCPDFtag($data) {
		return hash_hmac('sha256', $data, $this->hash_key, false);
	}

	/**
	 * Serialize data to be used with TCPDF tag in HTML code.
	 * @param string $method TCPDF method name
	 * @param array $params Method parameters
	 * @return string Serialized data
	 * @public static
	 */
	public function serializeTCPDFtag($method, $params=array()) {
		$data = array('m' => $method, 'p' => $params);
		$encoded = urlencode(json_encode($data));
		$hash = $this->hashTCPDFtag($encoded);
		return strlen($hash).'+'.$hash.'+'.$encoded;
	}

	/**
	 * Unserialize data to be used with TCPDF tag in HTML code.
	 * @param string $data serialized data
	 * @return array containing unserialized data
	 * @protected static
	 */
	protected function unserializeTCPDFtag($data) {
		$hpos = strpos($data, '+');
		$hlen = intval(substr($data, 0, $hpos));
		$hash = substr($data, $hpos + 1, $hlen);
		$encoded = substr($data, $hpos + 2 + $hlen);
		if ($hash != $this->hashTCPDFtag($encoded)) {
			$this->Error('Invalid parameters');
		}
		return json_decode(urldecode($encoded), true);
	}

	/**
	 * Check if a TCPDF tag is allowed
	 * @param string $method TCPDF method name
	 * @return boolean
	 * @protected
	 */
	protected function allowedTCPDFtag($method) {
		if (defined('K_ALLOWED_TCPDF_TAGS')) {
			return (strpos(K_ALLOWED_TCPDF_TAGS, '|'.$method.'|') !== false);
		}
		return false;
	}

	/**
	 * Prints a cell (rectangular area) with optional borders, background color and html text string.
	 * The upper-left corner of the cell corresponds to the current position. After the call, the current position moves to the right or to the next line.<br />
	 * If automatic page breaking is enabled and the cell goes beyond the limit, a page break is done before outputting.
	 * IMPORTANT: The HTML must be well formatted - try to clean-up it using an application like HTML-Tidy before submitting.
	 * Supported tags are: a, b, blockquote, br, dd, del, div, dl, dt, em, font, h1, h2, h3, h4, h5, h6, hr, i, img, li, ol, p, pre, small, span, strong, sub, sup, table, tcpdf, td, th, thead, tr, tt, u, ul
	 * NOTE: all the HTML attributes must be enclosed in double-quote.
	 * @param float $w Cell width. If 0, the cell extends up to the right margin.
	 * @param float $h Cell minimum height. The cell extends automatically if needed.
	 * @param float|null $x upper-left corner X coordinate
	 * @param float|null $y upper-left corner Y coordinate
	 * @param string $html html text to print. Default value: empty string.
	 * @param mixed $border Indicates if borders must be drawn around the cell. The value can be a number:<ul><li>0: no border (default)</li><li>1: frame</li></ul> or a string containing some or all of the following characters (in any order):<ul><li>L: left</li><li>T: top</li><li>R: right</li><li>B: bottom</li></ul> or an array of line styles for each border group - for example: array('LTRB' => array('width' => 2, 'cap' => 'butt', 'join' => 'miter', 'dash' => 0, 'color' => array(0, 0, 0)))
	 * @param int $ln Indicates where the current position should go after the call. Possible values are:<ul><li>0: to the right (or left for RTL language)</li><li>1: to the beginning of the next line</li><li>2: below</li></ul> Putting 1 is equivalent to putting 0 and calling Ln() just after. Default value: 0.
	 * @param boolean $fill Indicates if the cell background must be painted (true) or transparent (false).
	 * @param boolean $reseth if true reset the last cell height (default true).
	 * @param string $align Allows to center or align the text. Possible values are:<ul><li>L : left align</li><li>C : center</li><li>R : right align</li><li>'' : empty string : left for LTR or right for RTL</li></ul>
	 * @param boolean $autopadding if true, uses internal padding and automatically adjust it to account for line width.
	 * @see Multicell(), writeHTML()
	 * @public
	 */
	public function writeHTMLCell($w, $h, $x, $y, $html='', $border=0, $ln=0, $fill=false, $reseth=true, $align='', $autopadding=true) {
		return $this->MultiCell($w, $h, $html, $border, $align, $fill, $ln, $x, $y, $reseth, 0, true, $autopadding, 0, 'T', false);
	}

	/**
	 * Allows to preserve some HTML formatting (limited support).<br />
	 * IMPORTANT: The HTML must be well formatted - try to clean-up it using an application like HTML-Tidy before submitting.
	 * Supported tags are: a, b, blockquote, br, dd, del, div, dl, dt, em, font, h1, h2, h3, h4, h5, h6, hr, i, img, li, ol, p, pre, small, span, strong, sub, sup, table, tcpdf, td, th, thead, tr, tt, u, ul
	 * NOTE: all the HTML attributes must be enclosed in double-quote.
	 * @param string $html text to display
	 * @param boolean $ln if true add a new line after text (default = true)
	 * @param boolean $fill Indicates if the background must be painted (true) or transparent (false).
	 * @param boolean $reseth if true reset the last cell height (default false).
	 * @param boolean $cell if true add the current left (or right for RTL) padding to each Write (default false).
	 * @param string $align Allows to center or align the text. Possible values are:<ul><li>L : left align</li><li>C : center</li><li>R : right align</li><li>'' : empty string : left for LTR or right for RTL</li></ul>
	 * @public
	 */
	public function writeHTML($html, $ln=true, $fill=false, $reseth=false, $cell=false, $align='') {
		$gvars = $this->getGraphicVars();
		// store current values
		$prev_cell_margin = $this->cell_margin;
		$prev_cell_padding = $this->cell_padding;
		$prevPage = $this->page;
		$prevlMargin = $this->lMargin;
		$prevrMargin = $this->rMargin;
		$curfontname = $this->FontFamily;
		$curfontstyle = $this->FontStyle;
		$curfontsize = $this->FontSizePt;
		$curfontascent = $this->getFontAscent($curfontname, $curfontstyle, $curfontsize);
		$curfontdescent = $this->getFontDescent($curfontname, $curfontstyle, $curfontsize);
		$curfontstretcing = $this->font_stretching;
		$curfonttracking = $this->font_spacing;
		$this->newline = true;
		$newline = true;
		$startlinepage = $this->page;
		$minstartliney = $this->y;
		$maxbottomliney = 0;
		$startlinex = $this->x;
		$startliney = $this->y;
		$yshift = 0;
		$loop = 0;
		$curpos = 0;
		$this_method_vars = array();
		$undo = false;
		$fontaligned = false;
		$reverse_dir = false; // true when the text direction is reversed
		$this->premode = false;
		if ($this->inxobj) {
			// we are inside an XObject template
			$pask = count($this->xobjects[$this->xobjid]['annotations']);
		} elseif (isset($this->PageAnnots[$this->page])) {
			$pask = count($this->PageAnnots[$this->page]);
		} else {
			$pask = 0;
		}
		if ($this->inxobj) {
			// we are inside an XObject template
			$startlinepos = strlen($this->xobjects[$this->xobjid]['outdata']);
		} elseif (!$this->InFooter) {
			if (isset($this->footerlen[$this->page])) {
				$this->footerpos[$this->page] = $this->pagelen[$this->page] - $this->footerlen[$this->page];
			} else {
				$this->footerpos[$this->page] = $this->pagelen[$this->page];
			}
			$startlinepos = $this->footerpos[$this->page];
		} else {
			// we are inside the footer
			$startlinepos = $this->pagelen[$this->page];
		}
		$lalign = $align;
		$plalign = $align;
		if ($this->rtl) {
			$w = $this->x - $this->lMargin;
		} else {
			$w = $this->w - $this->rMargin - $this->x;
		}
		$w -= ($this->cell_padding['L'] + $this->cell_padding['R']);
		if ($cell) {
			if ($this->rtl) {
				$this->x -= $this->cell_padding['R'];
				$this->lMargin += $this->cell_padding['L'];
			} else {
				$this->x += $this->cell_padding['L'];
				$this->rMargin += $this->cell_padding['R'];
			}
		}
		if ($this->customlistindent >= 0) {
			$this->listindent = $this->customlistindent;
		} else {
			$this->listindent = $this->GetStringWidth('000000');
		}
		$this->listindentlevel = 0;
		// save previous states
		$prev_cell_height_ratio = $this->cell_height_ratio;
		$prev_listnum = $this->listnum;
		$prev_listordered = $this->listordered;
		$prev_listcount = $this->listcount;
		$prev_lispacer = $this->lispacer;
		$this->listnum = 0;
		$this->listordered = array();
		$this->listcount = array();
		$this->lispacer = '';
		if ((TCPDF_STATIC::empty_string($this->lasth)) OR ($reseth)) {
			// reset row height
			$this->resetLastH();
		}
		$dom = $this->getHtmlDomArray($html);
		$maxel = count($dom);
		$key = 0;
		while ($key < $maxel) {
			if ($dom[$key]['tag'] AND $dom[$key]['opening'] AND $dom[$key]['hide']) {
				// store the node key
				$hidden_node_key = $key;
				if ($dom[$key]['self']) {
					// skip just this self-closing tag
					++$key;
				} else {
					// skip this and all children tags
					while (($key < $maxel) AND (!$dom[$key]['tag'] OR $dom[$key]['opening'] OR ($dom[$key]['parent'] != $hidden_node_key))) {
						// skip hidden objects
						++$key;
					}
					++$key;
				}
			}
			if ($key == $maxel) break;
			if ($dom[$key]['tag'] AND isset($dom[$key]['attribute']['pagebreak'])) {
				// check for pagebreak
				if (($dom[$key]['attribute']['pagebreak'] == 'true') OR ($dom[$key]['attribute']['pagebreak'] == 'left') OR ($dom[$key]['attribute']['pagebreak'] == 'right')) {
					// add a page (or trig AcceptPageBreak() for multicolumn mode)
					$this->checkPageBreak($this->PageBreakTrigger + 1);
					$this->htmlvspace = ($this->PageBreakTrigger + 1);
				}
				if ((($dom[$key]['attribute']['pagebreak'] == 'left') AND (((!$this->rtl) AND (($this->page % 2) == 0)) OR (($this->rtl) AND (($this->page % 2) != 0))))
					OR (($dom[$key]['attribute']['pagebreak'] == 'right') AND (((!$this->rtl) AND (($this->page % 2) != 0)) OR (($this->rtl) AND (($this->page % 2) == 0))))) {
					// add a page (or trig AcceptPageBreak() for multicolumn mode)
					$this->checkPageBreak($this->PageBreakTrigger + 1);
					$this->htmlvspace = ($this->PageBreakTrigger + 1);
				}
			}
			if ($dom[$key]['tag'] AND $dom[$key]['opening'] AND isset($dom[$key]['attribute']['nobr']) AND ($dom[$key]['attribute']['nobr'] == 'true')) {
				if (isset($dom[($dom[$key]['parent'])]['attribute']['nobr']) AND ($dom[($dom[$key]['parent'])]['attribute']['nobr'] == 'true')) {
					$dom[$key]['attribute']['nobr'] = false;
				} else {
					// store current object
					$this->startTransaction();
					// save this method vars
					$this_method_vars['html'] = $html;
					$this_method_vars['ln'] = $ln;
					$this_method_vars['fill'] = $fill;
					$this_method_vars['reseth'] = $reseth;
					$this_method_vars['cell'] = $cell;
					$this_method_vars['align'] = $align;
					$this_method_vars['gvars'] = $gvars;
					$this_method_vars['prevPage'] = $prevPage;
					$this_method_vars['prev_cell_margin'] = $prev_cell_margin;
					$this_method_vars['prev_cell_padding'] = $prev_cell_padding;
					$this_method_vars['prevlMargin'] = $prevlMargin;
					$this_method_vars['prevrMargin'] = $prevrMargin;
					$this_method_vars['curfontname'] = $curfontname;
					$this_method_vars['curfontstyle'] = $curfontstyle;
					$this_method_vars['curfontsize'] = $curfontsize;
					$this_method_vars['curfontascent'] = $curfontascent;
					$this_method_vars['curfontdescent'] = $curfontdescent;
					$this_method_vars['curfontstretcing'] = $curfontstretcing;
					$this_method_vars['curfonttracking'] = $curfonttracking;
					$this_method_vars['minstartliney'] = $minstartliney;
					$this_method_vars['maxbottomliney'] = $maxbottomliney;
					$this_method_vars['yshift'] = $yshift;
					$this_method_vars['startlinepage'] = $startlinepage;
					$this_method_vars['startlinepos'] = $startlinepos;
					$this_method_vars['startlinex'] = $startlinex;
					$this_method_vars['startliney'] = $startliney;
					$this_method_vars['newline'] = $newline;
					$this_method_vars['loop'] = $loop;
					$this_method_vars['curpos'] = $curpos;
					$this_method_vars['pask'] = $pask;
					$this_method_vars['lalign'] = $lalign;
					$this_method_vars['plalign'] = $plalign;
					$this_method_vars['w'] = $w;
					$this_method_vars['prev_cell_height_ratio'] = $prev_cell_height_ratio;
					$this_method_vars['prev_listnum'] = $prev_listnum;
					$this_method_vars['prev_listordered'] = $prev_listordered;
					$this_method_vars['prev_listcount'] = $prev_listcount;
					$this_method_vars['prev_lispacer'] = $prev_lispacer;
					$this_method_vars['fontaligned'] = $fontaligned;
					$this_method_vars['key'] = $key;
					$this_method_vars['dom'] = $dom;
				}
			}
			// print THEAD block
			if (($dom[$key]['value'] == 'tr') AND isset($dom[$key]['thead']) AND $dom[$key]['thead']) {
				if (isset($dom[$key]['parent']) AND isset($dom[$dom[$key]['parent']]['thead']) AND !TCPDF_STATIC::empty_string($dom[$dom[$key]['parent']]['thead'])) {
					$this->inthead = true;
					// print table header (thead)
					$this->writeHTML($this->thead, false, false, false, false, '');
					// check if we are on a new page or on a new column
					if (($this->y < $this->start_transaction_y) OR ($this->checkPageBreak($this->lasth, '', false))) {
						// we are on a new page or on a new column and the total object height is less than the available vertical space.
						// restore previous object
						$this->rollbackTransaction(true);
						// restore previous values
						foreach ($this_method_vars as $vkey => $vval) {
							$$vkey = $vval;
						}
						// disable table header
						$tmp_thead = $this->thead;
						$this->thead = '';
						// add a page (or trig AcceptPageBreak() for multicolumn mode)
						$pre_y = $this->y;
						if ((!$this->checkPageBreak($this->PageBreakTrigger + 1)) AND ($this->y < $pre_y)) {
							// fix for multicolumn mode
							$startliney = $this->y;
						}
						$this->start_transaction_page = $this->page;
						$this->start_transaction_y = $this->y;
						// restore table header
						$this->thead = $tmp_thead;
						// fix table border properties
						if (isset($dom[$dom[$key]['parent']]['attribute']['cellspacing'])) {
							$tmp_cellspacing = $this->getHTMLUnitToUnits($dom[$dom[$key]['parent']]['attribute']['cellspacing'], 1, 'px');
						} elseif (isset($dom[$dom[$key]['parent']]['border-spacing'])) {
							$tmp_cellspacing = $dom[$dom[$key]['parent']]['border-spacing']['V'];
						} else {
							$tmp_cellspacing = 0;
						}
						$dom[$dom[$key]['parent']]['borderposition']['page'] = $this->page;
						$dom[$dom[$key]['parent']]['borderposition']['column'] = $this->current_column;
						$dom[$dom[$key]['parent']]['borderposition']['y'] = $this->y + $tmp_cellspacing;
						$xoffset = ($this->x - $dom[$dom[$key]['parent']]['borderposition']['x']);
						$dom[$dom[$key]['parent']]['borderposition']['x'] += $xoffset;
						$dom[$dom[$key]['parent']]['borderposition']['xmax'] += $xoffset;
						// print table header (thead)
						$this->writeHTML($this->thead, false, false, false, false, '');
					}
				}
				// move $key index forward to skip THEAD block
				while ( ($key < $maxel) AND (!(
					($dom[$key]['tag'] AND $dom[$key]['opening'] AND ($dom[$key]['value'] == 'tr') AND (!isset($dom[$key]['thead']) OR !$dom[$key]['thead']))
					OR ($dom[$key]['tag'] AND (!$dom[$key]['opening']) AND ($dom[$key]['value'] == 'table'))) )) {
					++$key;
				}
			}
			if ($dom[$key]['tag'] OR ($key == 0)) {
				if ((($dom[$key]['value'] == 'table') OR ($dom[$key]['value'] == 'tr')) AND (isset($dom[$key]['align']))) {
					$dom[$key]['align'] = ($this->rtl) ? 'R' : 'L';
				}
				// vertically align image in line
				if ((!$this->newline) AND ($dom[$key]['value'] == 'img') AND (isset($dom[$key]['height'])) AND ($dom[$key]['height'] > 0)) {
					// get image height
					$imgh = $this->getHTMLUnitToUnits($dom[$key]['height'], ($dom[$key]['fontsize'] / $this->k), 'px');
					$autolinebreak = false;
					if (!empty($dom[$key]['width'])) {
						$imgw = $this->getHTMLUnitToUnits($dom[$key]['width'], ($dom[$key]['fontsize'] / $this->k), 'px', false);
						if (($imgw <= ($this->w - $this->lMargin - $this->rMargin - $this->cell_padding['L'] - $this->cell_padding['R']))
							AND ((($this->rtl) AND (($this->x - $imgw) < ($this->lMargin + $this->cell_padding['L'])))
							OR ((!$this->rtl) AND (($this->x + $imgw) > ($this->w - $this->rMargin - $this->cell_padding['R']))))) {
							// add automatic line break
							$autolinebreak = true;
							$this->Ln('', $cell);
							if ((!$dom[($key-1)]['tag']) AND ($dom[($key-1)]['value'] == ' ')) {
								// go back to evaluate this line break
								--$key;
							}
						}
					}
					if (!$autolinebreak) {
						if ($this->inPageBody()) {
							$pre_y = $this->y;
							// check for page break
							if ((!$this->checkPageBreak($imgh)) AND ($this->y < $pre_y)) {
								// fix for multicolumn mode
								$startliney = $this->y;
							}
						}
						if ($this->page > $startlinepage) {
							// fix line splitted over two pages
							if (isset($this->footerlen[$startlinepage])) {
								$curpos = $this->pagelen[$startlinepage] - $this->footerlen[$startlinepage];
							}
							// line to be moved one page forward
							$pagebuff = $this->getPageBuffer($startlinepage);
							$linebeg = substr($pagebuff, $startlinepos, ($curpos - $startlinepos));
							$tstart = substr($pagebuff, 0, $startlinepos);
							$tend = substr($this->getPageBuffer($startlinepage), $curpos);
							// remove line from previous page
							$this->setPageBuffer($startlinepage, $tstart.''.$tend);
							$pagebuff = $this->getPageBuffer($this->page);
							$tstart = substr($pagebuff, 0, $this->cntmrk[$this->page]);
							$tend = substr($pagebuff, $this->cntmrk[$this->page]);
							// add line start to current page
							$yshift = ($minstartliney - $this->y);
							if ($fontaligned) {
								$yshift += ($curfontsize / $this->k);
							}
							$try = sprintf('1 0 0 1 0 %F cm', ($yshift * $this->k));
							$this->setPageBuffer($this->page, $tstart.""\nq\n"".$try.""\n"".$linebeg.""\nQ\n"".$tend);
							// shift the annotations and links
							if (isset($this->PageAnnots[$this->page])) {
								$next_pask = count($this->PageAnnots[$this->page]);
							} else {
								$next_pask = 0;
							}
							if (isset($this->PageAnnots[$startlinepage])) {
								foreach ($this->PageAnnots[$startlinepage] as $pak => $pac) {
									if ($pak >= $pask) {
										$this->PageAnnots[$this->page][] = $pac;
										unset($this->PageAnnots[$startlinepage][$pak]);
										$npak = count($this->PageAnnots[$this->page]) - 1;
										$this->PageAnnots[$this->page][$npak]['y'] -= $yshift;
									}
								}
							}
							$pask = $next_pask;
							$startlinepos = $this->cntmrk[$this->page];
							$startlinepage = $this->page;
							$startliney = $this->y;
							$this->newline = false;
						}
						$this->y += ($this->getCellHeight($curfontsize / $this->k) - ($curfontdescent * $this->cell_height_ratio) - $imgh);
						$minstartliney = min($this->y, $minstartliney);
						$maxbottomliney = ($startliney + $this->getCellHeight($curfontsize / $this->k));
					}
				} elseif (isset($dom[$key]['fontname']) OR isset($dom[$key]['fontstyle']) OR isset($dom[$key]['fontsize']) OR isset($dom[$key]['line-height'])) {
					// account for different font size
					$pfontname = $curfontname;
					$pfontstyle = $curfontstyle;
					$pfontsize = $curfontsize;
					$fontname = (isset($dom[$key]['fontname']) ? $dom[$key]['fontname'] : $curfontname);
					$fontstyle = (isset($dom[$key]['fontstyle']) ? $dom[$key]['fontstyle'] : $curfontstyle);
					$fontsize = (isset($dom[$key]['fontsize']) ? $dom[$key]['fontsize'] : $curfontsize);
					$fontascent = $this->getFontAscent($fontname, $fontstyle, $fontsize);
					$fontdescent = $this->getFontDescent($fontname, $fontstyle, $fontsize);
					if (($fontname != $curfontname) OR ($fontstyle != $curfontstyle) OR ($fontsize != $curfontsize)
						OR ($this->cell_height_ratio != $dom[$key]['line-height'])
						OR ($dom[$key]['tag'] AND $dom[$key]['opening'] AND ($dom[$key]['value'] == 'li')) ) {
						if (($key < ($maxel - 1)) AND (
								($dom[$key]['tag'] AND $dom[$key]['opening'] AND ($dom[$key]['value'] == 'li'))
								OR ($this->cell_height_ratio != $dom[$key]['line-height'])
								OR (!$this->newline AND is_numeric($fontsize) AND is_numeric($curfontsize)
								AND ($fontsize >= 0) AND ($curfontsize >= 0)
								AND (($fontsize != $curfontsize) OR ($fontstyle != $curfontstyle) OR ($fontname != $curfontname)))
							)) {
							if ($this->page > $startlinepage) {
								// fix lines splitted over two pages
								if (isset($this->footerlen[$startlinepage])) {
									$curpos = $this->pagelen[$startlinepage] - $this->footerlen[$startlinepage];
								}
								// line to be moved one page forward
								$pagebuff = $this->getPageBuffer($startlinepage);
								$linebeg = substr($pagebuff, $startlinepos, ($curpos - $startlinepos));
								$tstart = substr($pagebuff, 0, $startlinepos);
								$tend = substr($this->getPageBuffer($startlinepage), $curpos);
								// remove line start from previous page
								$this->setPageBuffer($startlinepage, $tstart.''.$tend);
								$pagebuff = $this->getPageBuffer($this->page);
								$tstart = substr($pagebuff, 0, $this->cntmrk[$this->page]);
								$tend = substr($pagebuff, $this->cntmrk[$this->page]);
								// add line start to current page
								$yshift = ($minstartliney - $this->y);
								$try = sprintf('1 0 0 1 0 %F cm', ($yshift * $this->k));
								$this->setPageBuffer($this->page, $tstart.""\nq\n"".$try.""\n"".$linebeg.""\nQ\n"".$tend);
								// shift the annotations and links
								if (isset($this->PageAnnots[$this->page])) {
									$next_pask = count($this->PageAnnots[$this->page]);
								} else {
									$next_pask = 0;
								}
								if (isset($this->PageAnnots[$startlinepage])) {
									foreach ($this->PageAnnots[$startlinepage] as $pak => $pac) {
										if ($pak >= $pask) {
											$this->PageAnnots[$this->page][] = $pac;
											unset($this->PageAnnots[$startlinepage][$pak]);
											$npak = count($this->PageAnnots[$this->page]) - 1;
											$this->PageAnnots[$this->page][$npak]['y'] -= $yshift;
										}
									}
								}
								$pask = $next_pask;
								$startlinepos = $this->cntmrk[$this->page];
								$startlinepage = $this->page;
								$startliney = $this->y;
							}
							if (!isset($dom[$key]['line-height'])) {
								$dom[$key]['line-height'] = $this->cell_height_ratio;
							}
							if (!$dom[$key]['block']) {
								if (!(isset($dom[($key + 1)]) AND $dom[($key + 1)]['tag'] AND (!$dom[($key + 1)]['opening']) AND ($dom[($key + 1)]['value'] != 'li') AND $dom[$key]['tag'] AND (!$dom[$key]['opening']))) {
									$this->y += (((($curfontsize * $this->cell_height_ratio) - ($fontsize * $dom[$key]['line-height'])) / $this->k) + $curfontascent - $fontascent - $curfontdescent + $fontdescent) / 2;
								}
								if (($dom[$key]['value'] != 'sup') AND ($dom[$key]['value'] != 'sub')) {
									$current_line_align_data = array($key, $minstartliney, $maxbottomliney);
									if (isset($line_align_data) AND (($line_align_data[0] == ($key - 1)) OR (($line_align_data[0] == ($key - 2)) AND (isset($dom[($key - 1)])) AND (preg_match('/^([\s]+)$/', $dom[($key - 1)]['value']) > 0)))) {
										$minstartliney = min($this->y, $line_align_data[1]);
										$maxbottomliney = max(($this->y + $this->getCellHeight($fontsize / $this->k)), $line_align_data[2]);
									} else {
										$minstartliney = min($this->y, $minstartliney);
										$maxbottomliney = max(($this->y + $this->getCellHeight($fontsize / $this->k)), $maxbottomliney);
									}
									$line_align_data = $current_line_align_data;
								}
							}
							$this->cell_height_ratio = $dom[$key]['line-height'];
							$fontaligned = true;
						}
						$this->setFont($fontname, $fontstyle, $fontsize);
						// reset row height
						$this->resetLastH();
						$curfontname = $fontname;
						$curfontstyle = $fontstyle;
						$curfontsize = $fontsize;
						$curfontascent = $fontascent;
						$curfontdescent = $fontdescent;
					}
				}
				// set text rendering mode
				$textstroke = isset($dom[$key]['stroke']) ? $dom[$key]['stroke'] : $this->textstrokewidth;
				$textfill = isset($dom[$key]['fill']) ? $dom[$key]['fill'] : (($this->textrendermode % 2) == 0);
				$textclip = isset($dom[$key]['clip']) ? $dom[$key]['clip'] : ($this->textrendermode > 3);
				$this->setTextRenderingMode($textstroke, $textfill, $textclip);
				if (isset($dom[$key]['font-stretch']) AND ($dom[$key]['font-stretch'] !== false)) {
					$this->setFontStretching($dom[$key]['font-stretch']);
				}
				if (isset($dom[$key]['letter-spacing']) AND ($dom[$key]['letter-spacing'] !== false)) {
					$this->setFontSpacing($dom[$key]['letter-spacing']);
				}
				if (($plalign == 'J') AND $dom[$key]['block']) {
					$plalign = '';
				}
				// get current position on page buffer
				$curpos = $this->pagelen[$startlinepage];
				if (isset($dom[$key]['bgcolor']) AND ($dom[$key]['bgcolor'] !== false)) {
					$this->setFillColorArray($dom[$key]['bgcolor']);
					$wfill = true;
				} else {
					$wfill = $fill | false;
				}
				if (isset($dom[$key]['fgcolor']) AND ($dom[$key]['fgcolor'] !== false)) {
					$this->setTextColorArray($dom[$key]['fgcolor']);
				}
				if (isset($dom[$key]['strokecolor']) AND ($dom[$key]['strokecolor'] !== false)) {
					$this->setDrawColorArray($dom[$key]['strokecolor']);
				}
				if (isset($dom[$key]['align'])) {
					$lalign = $dom[$key]['align'];
				}
				if (TCPDF_STATIC::empty_string($lalign)) {
					$lalign = $align;
				}
			}
			// align lines
			if ($this->newline AND (strlen($dom[$key]['value']) > 0) AND ($dom[$key]['value'] != 'td') AND ($dom[$key]['value'] != 'th')) {
				$newline = true;
				$fontaligned = false;
				// we are at the beginning of a new line
				if (isset($startlinex)) {
					$yshift = ($minstartliney - $startliney);
					if (($yshift > 0) OR ($this->page > $startlinepage)) {
						$yshift = 0;
					}
					$t_x = 0;
					// the last line must be shifted to be aligned as requested
					$linew = abs($this->endlinex - $startlinex);
					if ($this->inxobj) {
						// we are inside an XObject template
						$pstart = substr($this->xobjects[$this->xobjid]['outdata'], 0, $startlinepos);
						if (isset($opentagpos)) {
							$midpos = $opentagpos;
						} else {
							$midpos = 0;
						}
						if ($midpos > 0) {
							$pmid = substr($this->xobjects[$this->xobjid]['outdata'], $startlinepos, ($midpos - $startlinepos));
							$pend = substr($this->xobjects[$this->xobjid]['outdata'], $midpos);
						} else {
							$pmid = substr($this->xobjects[$this->xobjid]['outdata'], $startlinepos);
							$pend = '';
						}
					} else {
						$pstart = substr($this->getPageBuffer($startlinepage), 0, $startlinepos);
						if (isset($opentagpos) AND isset($this->footerlen[$startlinepage]) AND (!$this->InFooter)) {
							$this->footerpos[$startlinepage] = $this->pagelen[$startlinepage] - $this->footerlen[$startlinepage];
							$midpos = min($opentagpos, $this->footerpos[$startlinepage]);
						} elseif (isset($opentagpos)) {
							$midpos = $opentagpos;
						} elseif (isset($this->footerlen[$startlinepage]) AND (!$this->InFooter)) {
							$this->footerpos[$startlinepage] = $this->pagelen[$startlinepage] - $this->footerlen[$startlinepage];
							$midpos = $this->footerpos[$startlinepage];
						} else {
							$midpos = 0;
						}
						if ($midpos > 0) {
							$pmid = substr($this->getPageBuffer($startlinepage), $startlinepos, ($midpos - $startlinepos));
							$pend = substr($this->getPageBuffer($startlinepage), $midpos);
						} else {
							$pmid = substr($this->getPageBuffer($startlinepage), $startlinepos);
							$pend = '';
						}
					}
					if ((((($plalign == 'C') OR ($plalign == 'J') OR (($plalign == 'R') AND (!$this->rtl)) OR (($plalign == 'L') AND ($this->rtl)))))) {
						// calculate shifting amount
						$tw = $w;
						if (($plalign == 'J') AND $this->isRTLTextDir() AND ($this->num_columns > 1)) {
							$tw += $this->cell_padding['R'];
						}
						if ($this->lMargin != $prevlMargin) {
							$tw += ($prevlMargin - $this->lMargin);
						}
						if ($this->rMargin != $prevrMargin) {
							$tw += ($prevrMargin - $this->rMargin);
						}
						$one_space_width = $this->GetStringWidth(chr(32));
						$no = 0; // number of spaces on a line contained on a single block
						if ($this->isRTLTextDir()) { // RTL
							// remove left space if exist
							$pos1 = TCPDF_STATIC::revstrpos($pmid, '[(');
							if ($pos1 > 0) {
								$pos1 = intval($pos1);
								if ($this->isUnicodeFont()) {
									$pos2 = intval(TCPDF_STATIC::revstrpos($pmid, '[('.chr(0).chr(32)));
									$spacelen = 2;
								} else {
									$pos2 = intval(TCPDF_STATIC::revstrpos($pmid, '[('.chr(32)));
									$spacelen = 1;
								}
								if ($pos1 == $pos2) {
									$pmid = substr($pmid, 0, ($pos1 + 2)).substr($pmid, ($pos1 + 2 + $spacelen));
									if (substr($pmid, $pos1, 4) == '[()]') {
										$linew -= $one_space_width;
									} elseif ($pos1 == strpos($pmid, '[(')) {
										$no = 1;
									}
								}
							}
						} else { // LTR
							// remove right space if exist
							$pos1 = TCPDF_STATIC::revstrpos($pmid, ')]');
							if ($pos1 > 0) {
								$pos1 = intval($pos1);
								if ($this->isUnicodeFont()) {
									$pos2 = intval(TCPDF_STATIC::revstrpos($pmid, chr(0).chr(32).')]')) + 2;
									$spacelen = 2;
								} else {
									$pos2 = intval(TCPDF_STATIC::revstrpos($pmid, chr(32).')]')) + 1;
									$spacelen = 1;
								}
								if ($pos1 == $pos2) {
									$pmid = substr($pmid, 0, ($pos1 - $spacelen)).substr($pmid, $pos1);
									$linew -= $one_space_width;
								}
							}
						}
						$mdiff = ($tw - $linew);
						if ($plalign == 'C') {
							if ($this->rtl) {
								$t_x = -($mdiff / 2);
							} else {
								$t_x = ($mdiff / 2);
							}
						} elseif ($plalign == 'R') {
							// right alignment on LTR document
							$t_x = $mdiff;
						} elseif ($plalign == 'L') {
							// left alignment on RTL document
							$t_x = -$mdiff;
						} elseif (($plalign == 'J') AND ($plalign == $lalign)) {
							// Justification
							if ($this->isRTLTextDir()) {
								// align text on the left
								$t_x = -$mdiff;
							}
							$ns = 0; // number of spaces
							$pmidtemp = $pmid;
							// escape special characters
							$pmidtemp = preg_replace('/[\\\][\(]/x', '\\#!#OP#!#', $pmidtemp);
							$pmidtemp = preg_replace('/[\\\][\)]/x', '\\#!#CP#!#', $pmidtemp);
							// search spaces
							if (preg_match_all('/\[\(([^\)]*)\)\]/x', $pmidtemp, $lnstring, PREG_PATTERN_ORDER)) {
								$spacestr = $this->getSpaceString();
								$maxkk = count($lnstring[1]) - 1;
								for ($kk=0; $kk <= $maxkk; ++$kk) {
									// restore special characters
									$lnstring[1][$kk] = str_replace('#!#OP#!#', '(', $lnstring[1][$kk]);
									$lnstring[1][$kk] = str_replace('#!#CP#!#', ')', $lnstring[1][$kk]);
									// store number of spaces on the strings
									$lnstring[2][$kk] = substr_count($lnstring[1][$kk], $spacestr);
									// count total spaces on line
									$ns += $lnstring[2][$kk];
									$lnstring[3][$kk] = $ns;
								}
								if ($ns == 0) {
									$ns = 1;
								}
								// calculate additional space to add to each existing space
								$spacewidth = ($mdiff / ($ns - $no)) * $this->k;
								if ($this->FontSize <= 0) {
									$this->FontSize = 1;
								}
								$spacewidthu = -1000 * ($mdiff + (($ns + $no) * $one_space_width)) / $ns / $this->FontSize;
								if ($this->font_spacing != 0) {
									// fixed spacing mode
									$osw = -1000 * $this->font_spacing / $this->FontSize;
									$spacewidthu += $osw;
								}
								$nsmax = $ns;
								$ns = 0;
								reset($lnstring);
								$offset = 0;
								$strcount = 0;
								$prev_epsposbeg = 0;
								$textpos = 0;
								if ($this->isRTLTextDir()) {
									$textpos = $this->wPt;
								}
								while (preg_match('/([0-9\.\+\-]*)[\s](Td|cm|m|l|c|re)[\s]/x', $pmid, $strpiece, PREG_OFFSET_CAPTURE, $offset) == 1) {
									// check if we are inside a string section '[( ... )]'
									$stroffset = strpos($pmid, '[(', $offset);
									if (($stroffset !== false) AND ($stroffset <= $strpiece[2][1])) {
										// set offset to the end of string section
										$offset = strpos($pmid, ')]', $stroffset);
										while (($offset !== false) AND ($pmid[($offset - 1)] == '\\')) {
											$offset = strpos($pmid, ')]', ($offset + 1));
										}
										if ($offset === false) {
											$this->Error('HTML Justification: malformed PDF code.');
										}
										continue;
									}
									if ($this->isRTLTextDir()) {
										$spacew = ($spacewidth * ($nsmax - $ns));
									} else {
										$spacew = ($spacewidth * $ns);
									}
									$offset = $strpiece[2][1] + strlen($strpiece[2][0]);
									$epsposend = strpos($pmid, $this->epsmarker.'Q', $offset);
									if ($epsposend !== null) {
										$epsposend += strlen($this->epsmarker.'Q');
										$epsposbeg = strpos($pmid, 'q'.$this->epsmarker, $offset);
										if ($epsposbeg === null) {
											$epsposbeg = strpos($pmid, 'q'.$this->epsmarker, ($prev_epsposbeg - 6));
											$prev_epsposbeg = $epsposbeg;
										}
										if (($epsposbeg > 0) AND ($epsposend > 0) AND ($offset > $epsposbeg) AND ($offset < $epsposend)) {
											// shift EPS images
											$trx = sprintf('1 0 0 1 %F 0 cm', $spacew);
											$pmid_b = substr($pmid, 0, $epsposbeg);
											$pmid_m = substr($pmid, $epsposbeg, ($epsposend - $epsposbeg));
											$pmid_e = substr($pmid, $epsposend);
											$pmid = $pmid_b.""\nq\n"".$trx.""\n"".$pmid_m.""\nQ\n"".$pmid_e;
											$offset = $epsposend;
											continue;
										}
									}
									$currentxpos = 0;
									// shift blocks of code
									switch ($strpiece[2][0]) {
										case 'Td':
										case 'cm':
										case 'm':
										case 'l': {
											// get current X position
											preg_match('/([0-9\.\+\-]*)[\s]('.$strpiece[1][0].')[\s]('.$strpiece[2][0].')([\s]*)/x', $pmid, $xmatches);
											if (!isset($xmatches[1])) {
												break;
											}
											$currentxpos = $xmatches[1];
											$textpos = $currentxpos;
											if (($strcount <= $maxkk) AND ($strpiece[2][0] == 'Td')) {
												$ns = $lnstring[3][$strcount];
												if ($this->isRTLTextDir()) {
													$spacew = ($spacewidth * ($nsmax - $ns));
												}
												++$strcount;
											}
											// justify block
											if (preg_match('/([0-9\.\+\-]*)[\s]('.$strpiece[1][0].')[\s]('.$strpiece[2][0].')([\s]*)/x', $pmid, $pmatch) == 1) {
												$newpmid = sprintf('%F',(floatval($pmatch[1]) + $spacew)).' '.$pmatch[2].' x*#!#*x'.$pmatch[3].$pmatch[4];
												$pmid = str_replace($pmatch[0], $newpmid, $pmid);
												unset($pmatch, $newpmid);
											}
											break;
										}
										case 're': {
											// justify block
											if (!TCPDF_STATIC::empty_string($this->lispacer)) {
												$this->lispacer = '';
												break;
											}
											preg_match('/([0-9\.\+\-]*)[\s]([0-9\.\+\-]*)[\s]([0-9\.\+\-]*)[\s]('.$strpiece[1][0].')[\s](re)([\s]*)/x', $pmid, $xmatches);
											if (!isset($xmatches[1])) {
												break;
											}
											$currentxpos = $xmatches[1];
											$x_diff = 0;
											$w_diff = 0;
											if ($this->isRTLTextDir()) { // RTL
												if ($currentxpos < $textpos) {
													$x_diff = ($spacewidth * ($nsmax - $lnstring[3][$strcount]));
													$w_diff = ($spacewidth * $lnstring[2][$strcount]);
												} else {
													if ($strcount > 0) {
														$x_diff = ($spacewidth * ($nsmax - $lnstring[3][($strcount - 1)]));
														$w_diff = ($spacewidth * $lnstring[2][($strcount - 1)]);
													}
												}
											} else { // LTR
												if ($currentxpos > $textpos) {
													if ($strcount > 0) {
														$x_diff = ($spacewidth * $lnstring[3][($strcount - 1)]);
													}
													$w_diff = ($spacewidth * $lnstring[2][$strcount]);
												} else {
													if ($strcount > 1) {
														$x_diff = ($spacewidth * $lnstring[3][($strcount - 2)]);
													}
													if ($strcount > 0) {
														$w_diff = ($spacewidth * $lnstring[2][($strcount - 1)]);
													}
												}
											}
											if (preg_match('/('.$xmatches[1].')[\s]('.$xmatches[2].')[\s]('.$xmatches[3].')[\s]('.$strpiece[1][0].')[\s](re)([\s]*)/x', $pmid, $pmatch) == 1) {
												$newx = sprintf('%F',(floatval($pmatch[1]) + $x_diff));
												$neww = sprintf('%F',(floatval($pmatch[3]) + $w_diff));
												$newpmid = $newx.' '.$pmatch[2].' '.$neww.' '.$pmatch[4].' x*#!#*x'.$pmatch[5].$pmatch[6];
												$pmid = str_replace($pmatch[0], $newpmid, $pmid);
												unset($pmatch, $newpmid, $newx, $neww);
											}
											break;
										}
										case 'c': {
											// get current X position
											preg_match('/([0-9\.\+\-]*)[\s]([0-9\.\+\-]*)[\s]([0-9\.\+\-]*)[\s]([0-9\.\+\-]*)[\s]([0-9\.\+\-]*)[\s]('.$strpiece[1][0].')[\s](c)([\s]*)/x', $pmid, $xmatches);
											if (!isset($xmatches[1])) {
												break;
											}
											$currentxpos = $xmatches[1];
											// justify block
											if (preg_match('/('.$xmatches[1].')[\s]('.$xmatches[2].')[\s]('.$xmatches[3].')[\s]('.$xmatches[4].')[\s]('.$xmatches[5].')[\s]('.$strpiece[1][0].')[\s](c)([\s]*)/x', $pmid, $pmatch) == 1) {
												$newx1 = sprintf('%F',(floatval($pmatch[1]) + $spacew));
												$newx2 = sprintf('%F',(floatval($pmatch[3]) + $spacew));
												$newx3 = sprintf('%F',(floatval($pmatch[5]) + $spacew));
												$newpmid = $newx1.' '.$pmatch[2].' '.$newx2.' '.$pmatch[4].' '.$newx3.' '.$pmatch[6].' x*#!#*x'.$pmatch[7].$pmatch[8];
												$pmid = str_replace($pmatch[0], $newpmid, $pmid);
												unset($pmatch, $newpmid, $newx1, $newx2, $newx3);
											}
											break;
										}
									}
									// shift the annotations and links
									$cxpos = ($currentxpos / $this->k);
									$lmpos = ($this->lMargin + $this->cell_padding['L'] + $this->feps);
									if ($this->inxobj) {
										// we are inside an XObject template
										foreach ($this->xobjects[$this->xobjid]['annotations'] as $pak => $pac) {
											if (($pac['y'] >= $minstartliney) AND (($pac['x'] * $this->k) >= ($currentxpos - $this->feps)) AND (($pac['x'] * $this->k) <= ($currentxpos + $this->feps))) {
												if ($cxpos > $lmpos) {
													$this->xobjects[$this->xobjid]['annotations'][$pak]['x'] += ($spacew / $this->k);
													$this->xobjects[$this->xobjid]['annotations'][$pak]['w'] += (($spacewidth * $pac['numspaces']) / $this->k);
												} else {
													$this->xobjects[$this->xobjid]['annotations'][$pak]['w'] += (($spacewidth * $pac['numspaces']) / $this->k);
												}
												break;
											}
										}
									} elseif (isset($this->PageAnnots[$this->page])) {
										foreach ($this->PageAnnots[$this->page] as $pak => $pac) {
											if (($pac['y'] >= $minstartliney) AND (($pac['x'] * $this->k) >= ($currentxpos - $this->feps)) AND (($pac['x'] * $this->k) <= ($currentxpos + $this->feps))) {
												if ($cxpos > $lmpos) {
													$this->PageAnnots[$this->page][$pak]['x'] += ($spacew / $this->k);
													$this->PageAnnots[$this->page][$pak]['w'] += (($spacewidth * $pac['numspaces']) / $this->k);
												} else {
													$this->PageAnnots[$this->page][$pak]['w'] += (($spacewidth * $pac['numspaces']) / $this->k);
												}
												break;
											}
										}
									}
								} // end of while
								// remove markers
								$pmid = str_replace('x*#!#*x', '', $pmid);
								if ($this->isUnicodeFont()) {
									// multibyte characters
									$spacew = $spacewidthu;
									if ($this->font_stretching != 100) {
										// word spacing is affected by stretching
										$spacew /= ($this->font_stretching / 100);
									}
									// escape special characters
									$pos = 0;
									$pmid = preg_replace('/[\\\][\(]/x', '\\#!#OP#!#', $pmid);
									$pmid = preg_replace('/[\\\][\)]/x', '\\#!#CP#!#', $pmid);
									if (preg_match_all('/\[\(([^\)]*)\)\]/x', $pmid, $pamatch) > 0) {
										foreach($pamatch[0] as $pk => $pmatch) {
											$replace = $pamatch[1][$pk];
											$replace = str_replace('#!#OP#!#', '(', $replace);
											$replace = str_replace('#!#CP#!#', ')', $replace);
											$newpmid = '[('.str_replace(chr(0).chr(32), ') '.sprintf('%F', $spacew).' (', $replace).')]';
											$pos = strpos($pmid, $pmatch, $pos);
											if ($pos !== FALSE) {
												$pmid = substr_replace($pmid, $newpmid, $pos, strlen($pmatch));
											}
											++$pos;
										}
										unset($pamatch);
									}
									if ($this->inxobj) {
										// we are inside an XObject template
										$this->xobjects[$this->xobjid]['outdata'] = $pstart.""\n"".$pmid.""\n"".$pend;
									} else {
										$this->setPageBuffer($startlinepage, $pstart.""\n"".$pmid.""\n"".$pend);
									}
									$endlinepos = strlen($pstart.""\n"".$pmid.""\n"");
								} else {
									// non-unicode (single-byte characters)
									if ($this->font_stretching != 100) {
										// word spacing (Tw) is affected by stretching
										$spacewidth /= ($this->font_stretching / 100);
									}
									$rs = sprintf('%F Tw', $spacewidth);
									$pmid = preg_replace(""/\[\(/x"", $rs.' [(', $pmid);
									if ($this->inxobj) {
										// we are inside an XObject template
										$this->xobjects[$this->xobjid]['outdata'] = $pstart.""\n"".$pmid.""\nBT 0 Tw ET\n"".$pend;
									} else {
										$this->setPageBuffer($startlinepage, $pstart.""\n"".$pmid.""\nBT 0 Tw ET\n"".$pend);
									}
									$endlinepos = strlen($pstart.""\n"".$pmid.""\nBT 0 Tw ET\n"");
								}
							}
						} // end of J
					} // end if $startlinex
					if (($t_x != 0) OR ($yshift < 0)) {
						// shift the line
						$trx = sprintf('1 0 0 1 %F %F cm', ($t_x * $this->k), ($yshift * $this->k));
						$pstart .= ""\nq\n"".$trx.""\n"".$pmid.""\nQ\n"";
						$endlinepos = strlen($pstart);
						if ($this->inxobj) {
							// we are inside an XObject template
							$this->xobjects[$this->xobjid]['outdata'] = $pstart.$pend;
							foreach ($this->xobjects[$this->xobjid]['annotations'] as $pak => $pac) {
								if ($pak >= $pask) {
									$this->xobjects[$this->xobjid]['annotations'][$pak]['x'] += $t_x;
									$this->xobjects[$this->xobjid]['annotations'][$pak]['y'] -= $yshift;
								}
							}
						} else {
							$this->setPageBuffer($startlinepage, $pstart.$pend);
							// shift the annotations and links
							if (isset($this->PageAnnots[$this->page])) {
								foreach ($this->PageAnnots[$this->page] as $pak => $pac) {
									if ($pak >= $pask) {
										$this->PageAnnots[$this->page][$pak]['x'] += $t_x;
										$this->PageAnnots[$this->page][$pak]['y'] -= $yshift;
									}
								}
							}
						}
						$this->y -= $yshift;
					}
				}
				$pbrk = $this->checkPageBreak($this->lasth);
				$this->newline = false;
				$startlinex = $this->x;
				$startliney = $this->y;
				if ($dom[$dom[$key]['parent']]['value'] == 'sup') {
					$startliney -= ((0.3 * $this->FontSizePt) / $this->k);
				} elseif ($dom[$dom[$key]['parent']]['value'] == 'sub') {
					$startliney -= (($this->FontSizePt / 0.7) / $this->k);
				} else {
					$minstartliney = $startliney;
					$maxbottomliney = ($this->y + $this->getCellHeight($fontsize / $this->k));
				}
				$startlinepage = $this->page;
				if (isset($endlinepos) AND (!$pbrk)) {
					$startlinepos = $endlinepos;
				} else {
					if ($this->inxobj) {
						// we are inside an XObject template
						$startlinepos = strlen($this->xobjects[$this->xobjid]['outdata']);
					} elseif (!$this->InFooter) {
						if (isset($this->footerlen[$this->page])) {
							$this->footerpos[$this->page] = $this->pagelen[$this->page] - $this->footerlen[$this->page];
						} else {
							$this->footerpos[$this->page] = $this->pagelen[$this->page];
						}
						$startlinepos = $this->footerpos[$this->page];
					} else {
						$startlinepos = $this->pagelen[$this->page];
					}
				}
				unset($endlinepos);
				$plalign = $lalign;
				if (isset($this->PageAnnots[$this->page])) {
					$pask = count($this->PageAnnots[$this->page]);
				} else {
					$pask = 0;
				}
				if (!($dom[$key]['tag'] AND !$dom[$key]['opening'] AND ($dom[$key]['value'] == 'table')
					AND (isset($this->emptypagemrk[$this->page]))
					AND ($this->emptypagemrk[$this->page] == $this->pagelen[$this->page]))) {
					$this->setFont($fontname, $fontstyle, $fontsize);
					if ($wfill) {
						$this->setFillColorArray($this->bgcolor);
					}
				}
			} // end newline
			if (isset($opentagpos)) {
				unset($opentagpos);
			}
			if ($dom[$key]['tag']) {
				if ($dom[$key]['opening']) {
					// get text indentation (if any)
					if (isset($dom[$key]['text-indent']) AND $dom[$key]['block']) {
						$this->textindent = $dom[$key]['text-indent'];
						$this->newline = true;
					}
					// table
					if (($dom[$key]['value'] == 'table') AND isset($dom[$key]['cols']) AND ($dom[$key]['cols'] > 0)) {
						// available page width
						if ($this->rtl) {
							$wtmp = $this->x - $this->lMargin;
						} else {
							$wtmp = $this->w - $this->rMargin - $this->x;
						}
						// get cell spacing
						if (isset($dom[$key]['attribute']['cellspacing'])) {
							$clsp = $this->getHTMLUnitToUnits($dom[$key]['attribute']['cellspacing'], 1, 'px');
							$cellspacing = array('H' => $clsp, 'V' => $clsp);
						} elseif (isset($dom[$key]['border-spacing'])) {
							$cellspacing = $dom[$key]['border-spacing'];
						} else {
							$cellspacing = array('H' => 0, 'V' => 0);
						}
						// table width
						if (isset($dom[$key]['width'])) {
							$table_width = $this->getHTMLUnitToUnits($dom[$key]['width'], $wtmp, 'px');
						} else {
							$table_width = $wtmp;
						}
						$table_width -= (2 * $cellspacing['H']);
						if (!$this->inthead) {
							$this->y += $cellspacing['V'];
						}
						if ($this->rtl) {
							$cellspacingx = -$cellspacing['H'];
						} else {
							$cellspacingx = $cellspacing['H'];
						}
						// total table width without cellspaces
						$table_columns_width = ($table_width - ($cellspacing['H'] * ($dom[$key]['cols'] - 1)));
						// minimum column width
						$table_min_column_width = ($table_columns_width / $dom[$key]['cols']);
						// array of custom column widths
						$table_colwidths = array_fill(0, $dom[$key]['cols'], $table_min_column_width);
					}
					// table row
					if ($dom[$key]['value'] == 'tr') {
						// reset column counter
						$colid = 0;
					}
					// table cell
					if (($dom[$key]['value'] == 'td') OR ($dom[$key]['value'] == 'th')) {
						$trid = $dom[$key]['parent'];
						$table_el = $dom[$trid]['parent'];
						if (!isset($dom[$table_el]['cols'])) {
							$dom[$table_el]['cols'] = $dom[$trid]['cols'];
						}
						// store border info
						$tdborder = 0;
						if (isset($dom[$key]['border']) AND !empty($dom[$key]['border'])) {
							$tdborder = $dom[$key]['border'];
						}
						$colspan = intval($dom[$key]['attribute']['colspan']);
						if ($colspan <= 0) {
							$colspan = 1;
						}
						$old_cell_padding = $this->cell_padding;
						if (isset($dom[($dom[$trid]['parent'])]['attribute']['cellpadding'])) {
							$crclpd = $this->getHTMLUnitToUnits($dom[($dom[$trid]['parent'])]['attribute']['cellpadding'], 1, 'px');
							$current_cell_padding = array('L' => $crclpd, 'T' => $crclpd, 'R' => $crclpd, 'B' => $crclpd);
						} elseif (isset($dom[($dom[$trid]['parent'])]['padding'])) {
							$current_cell_padding = $dom[($dom[$trid]['parent'])]['padding'];
						} else {
							$current_cell_padding = array('L' => 0, 'T' => 0, 'R' => 0, 'B' => 0);
						}
						$this->cell_padding = $current_cell_padding;
						if (isset($dom[$key]['height'])) {
							// minimum cell height
							$cellh = $this->getHTMLUnitToUnits($dom[$key]['height'], 0, 'px');
						} else {
							$cellh = 0;
						}
						if (isset($dom[$key]['content'])) {
							$cell_content = $dom[$key]['content'];
						} else {
							$cell_content = '&nbsp;';
						}
						$tagtype = $dom[$key]['value'];
						$parentid = $key;
						while (($key < $maxel) AND (!(($dom[$key]['tag']) AND (!$dom[$key]['opening']) AND ($dom[$key]['value'] == $tagtype) AND ($dom[$key]['parent'] == $parentid)))) {
							// move $key index forward
							++$key;
						}
						if (!isset($dom[$trid]['startpage'])) {
							$dom[$trid]['startpage'] = $this->page;
						} else {
							$this->setPage($dom[$trid]['startpage']);
						}
						if (!isset($dom[$trid]['startcolumn'])) {
							$dom[$trid]['startcolumn'] = $this->current_column;
						} elseif ($this->current_column != $dom[$trid]['startcolumn']) {
							$tmpx = $this->x;
							$this->selectColumn($dom[$trid]['startcolumn']);
							$this->x = $tmpx;
						}
						if (!isset($dom[$trid]['starty'])) {
							$dom[$trid]['starty'] = $this->y;
						} else {
							$this->y = $dom[$trid]['starty'];
						}
						if (!isset($dom[$trid]['startx'])) {
							$dom[$trid]['startx'] = $this->x;
							$this->x += $cellspacingx;
						} else {
							$this->x += ($cellspacingx / 2);
						}
						if (isset($dom[$parentid]['attribute']['rowspan'])) {
							$rowspan = intval($dom[$parentid]['attribute']['rowspan']);
						} else {
							$rowspan = 1;
						}
						// skip row-spanned cells started on the previous rows
						if (isset($dom[$table_el]['rowspans'])) {
							$rsk = 0;
							$rskmax = count($dom[$table_el]['rowspans']);
							while ($rsk < $rskmax) {
								$trwsp = $dom[$table_el]['rowspans'][$rsk];
								$rsstartx = $trwsp['startx'];
								$rsendx = $trwsp['endx'];
								// account for margin changes
								if ($trwsp['startpage'] < $this->page) {
									if (($this->rtl) AND ($this->pagedim[$this->page]['orm'] != $this->pagedim[$trwsp['startpage']]['orm'])) {
										$dl = ($this->pagedim[$this->page]['orm'] - $this->pagedim[$trwsp['startpage']]['orm']);
										$rsstartx -= $dl;
										$rsendx -= $dl;
									} elseif ((!$this->rtl) AND ($this->pagedim[$this->page]['olm'] != $this->pagedim[$trwsp['startpage']]['olm'])) {
										$dl = ($this->pagedim[$this->page]['olm'] - $this->pagedim[$trwsp['startpage']]['olm']);
										$rsstartx += $dl;
										$rsendx += $dl;
									}
								}
								if (($trwsp['rowspan'] > 0)
									AND ($rsstartx > ($this->x - $cellspacing['H'] - $current_cell_padding['L'] - $this->feps))
									AND ($rsstartx < ($this->x + $cellspacing['H'] + $current_cell_padding['R'] + $this->feps))
									AND (($trwsp['starty'] < ($this->y - $this->feps)) OR ($trwsp['startpage'] < $this->page) OR ($trwsp['startcolumn'] < $this->current_column))) {
									// set the starting X position of the current cell
									$this->x = $rsendx + $cellspacingx;
									// increment column indicator
									$colid += $trwsp['colspan'];
									if (($trwsp['rowspan'] == 1)
										AND (isset($dom[$trid]['endy']))
										AND (isset($dom[$trid]['endpage']))
										AND (isset($dom[$trid]['endcolumn']))
										AND ($trwsp['endpage'] == $dom[$trid]['endpage'])
										AND ($trwsp['endcolumn'] == $dom[$trid]['endcolumn'])) {
										// set ending Y position for row
										$dom[$table_el]['rowspans'][$rsk]['endy'] = max($dom[$trid]['endy'], $trwsp['endy']);
										$dom[$trid]['endy'] = $dom[$table_el]['rowspans'][$rsk]['endy'];
									}
									$rsk = 0;
								} else {
									++$rsk;
								}
							}
						}
						if (isset($dom[$parentid]['width'])) {
							// user specified width
							$cellw = $this->getHTMLUnitToUnits($dom[$parentid]['width'], $table_columns_width, 'px');
							$tmpcw = ($cellw / $colspan);
							for ($i = 0; $i < $colspan; ++$i) {
								$table_colwidths[($colid + $i)] = $tmpcw;
							}
						} else {
							// inherit column width
							$cellw = 0;
							for ($i = 0; $i < $colspan; ++$i) {
								$cellw += (isset($table_colwidths[($colid + $i)]) ? $table_colwidths[($colid + $i)] : 0);
							}
						}
						$cellw += (($colspan - 1) * $cellspacing['H']);
						// increment column indicator
						$colid += $colspan;
						// add rowspan information to table element
						if ($rowspan > 1) {
							$trsid = array_push($dom[$table_el]['rowspans'], array('trid' => $trid, 'rowspan' => $rowspan, 'mrowspan' => $rowspan, 'colspan' => $colspan, 'startpage' => $this->page, 'startcolumn' => $this->current_column, 'startx' => $this->x, 'starty' => $this->y));
						}
						$cellid = array_push($dom[$trid]['cellpos'], array('startx' => $this->x));
						if ($rowspan > 1) {
							$dom[$trid]['cellpos'][($cellid - 1)]['rowspanid'] = ($trsid - 1);
						}
						// push background colors
						if (isset($dom[$parentid]['bgcolor']) AND ($dom[$parentid]['bgcolor'] !== false)) {
							$dom[$trid]['cellpos'][($cellid - 1)]['bgcolor'] = $dom[$parentid]['bgcolor'];
						}
						// store border info
						if (!empty($tdborder)) {
							$dom[$trid]['cellpos'][($cellid - 1)]['border'] = $tdborder;
						}
						$prevLastH = $this->lasth;
						// store some info for multicolumn mode
						if ($this->rtl) {
							$this->colxshift['x'] = $this->w - $this->x - $this->rMargin;
						} else {
							$this->colxshift['x'] = $this->x - $this->lMargin;
						}
						$this->colxshift['s'] = $cellspacing;
						$this->colxshift['p'] = $current_cell_padding;
						// ****** write the cell content ******
						$this->MultiCell($cellw, $cellh, $cell_content, false, $lalign, false, 2, '', '', true, 0, true, true, 0, 'T', false);
						// restore some values
						$this->colxshift = array('x' => 0, 's' => array('H' => 0, 'V' => 0), 'p' => array('L' => 0, 'T' => 0, 'R' => 0, 'B' => 0));
						$this->lasth = $prevLastH;
						$this->cell_padding = $old_cell_padding;
						$dom[$trid]['cellpos'][($cellid - 1)]['endx'] = $this->x;
						// update the end of row position
						if ($rowspan <= 1) {
							if (isset($dom[$trid]['endy'])) {
								if (($this->page == $dom[$trid]['endpage']) AND ($this->current_column == $dom[$trid]['endcolumn'])) {
									$dom[$trid]['endy'] = max($this->y, $dom[$trid]['endy']);
								} elseif (($this->page > $dom[$trid]['endpage']) OR ($this->current_column > $dom[$trid]['endcolumn'])) {
									$dom[$trid]['endy'] = $this->y;
								}
							} else {
								$dom[$trid]['endy'] = $this->y;
							}
							if (isset($dom[$trid]['endpage'])) {
								$dom[$trid]['endpage'] = max($this->page, $dom[$trid]['endpage']);
							} else {
								$dom[$trid]['endpage'] = $this->page;
							}
							if (isset($dom[$trid]['endcolumn'])) {
								$dom[$trid]['endcolumn'] = max($this->current_column, $dom[$trid]['endcolumn']);
							} else {
								$dom[$trid]['endcolumn'] = $this->current_column;
							}
						} else {
							// account for row-spanned cells
							$dom[$table_el]['rowspans'][($trsid - 1)]['endx'] = $this->x;
							$dom[$table_el]['rowspans'][($trsid - 1)]['endy'] = $this->y;
							$dom[$table_el]['rowspans'][($trsid - 1)]['endpage'] = $this->page;
							$dom[$table_el]['rowspans'][($trsid - 1)]['endcolumn'] = $this->current_column;
						}
						if (isset($dom[$table_el]['rowspans'])) {
							// update endy and endpage on rowspanned cells
							foreach ($dom[$table_el]['rowspans'] as $k => $trwsp) {
								if ($trwsp['rowspan'] > 0) {
									if (isset($dom[$trid]['endpage'])) {
										if (($trwsp['endpage'] == $dom[$trid]['endpage']) AND ($trwsp['endcolumn'] == $dom[$trid]['endcolumn'])) {
											$dom[$table_el]['rowspans'][$k]['endy'] = max($dom[$trid]['endy'], $trwsp['endy']);
										} elseif (($trwsp['endpage'] < $dom[$trid]['endpage']) OR ($trwsp['endcolumn'] < $dom[$trid]['endcolumn'])) {
											$dom[$table_el]['rowspans'][$k]['endy'] = $dom[$trid]['endy'];
											$dom[$table_el]['rowspans'][$k]['endpage'] = $dom[$trid]['endpage'];
											$dom[$table_el]['rowspans'][$k]['endcolumn'] = $dom[$trid]['endcolumn'];
										} else {
											$dom[$trid]['endy'] = $this->pagedim[$dom[$trid]['endpage']]['hk'] - $this->pagedim[$dom[$trid]['endpage']]['bm'];
										}
									}
								}
							}
						}
						$this->x += ($cellspacingx / 2);
					} else {
						// opening tag (or self-closing tag)
						if (!isset($opentagpos)) {
							if ($this->inxobj) {
								// we are inside an XObject template
								$opentagpos = strlen($this->xobjects[$this->xobjid]['outdata']);
							} elseif (!$this->InFooter) {
								if (isset($this->footerlen[$this->page])) {
									$this->footerpos[$this->page] = $this->pagelen[$this->page] - $this->footerlen[$this->page];
								} else {
									$this->footerpos[$this->page] = $this->pagelen[$this->page];
								}
								$opentagpos = $this->footerpos[$this->page];
							}
						}
						$dom = $this->openHTMLTagHandler($dom, $key, $cell);
					}
				} else { // closing tag
					$prev_numpages = $this->numpages;
					$old_bordermrk = $this->bordermrk[$this->page];
					$dom = $this->closeHTMLTagHandler($dom, $key, $cell, $maxbottomliney);
					if ($this->bordermrk[$this->page] > $old_bordermrk) {
						$startlinepos += ($this->bordermrk[$this->page] - $old_bordermrk);
					}
					if ($prev_numpages > $this->numpages) {
						$startlinepage = $this->page;
					}
				}
			} elseif (strlen($dom[$key]['value']) > 0) {
				// print list-item
				if (!TCPDF_STATIC::empty_string($this->lispacer) AND ($this->lispacer != '^')) {
					$this->setFont($pfontname, $pfontstyle, $pfontsize);
					$this->resetLastH();
					$minstartliney = $this->y;
					$maxbottomliney = ($startliney + $this->getCellHeight($this->FontSize));
					if (is_numeric($pfontsize) AND ($pfontsize > 0)) {
						$this->putHtmlListBullet($this->listnum, $this->lispacer, $pfontsize);
					}
					$this->setFont($curfontname, $curfontstyle, $curfontsize);
					$this->resetLastH();
					if (is_numeric($pfontsize) AND ($pfontsize > 0) AND is_numeric($curfontsize) AND ($curfontsize > 0) AND ($pfontsize != $curfontsize)) {
						$pfontascent = $this->getFontAscent($pfontname, $pfontstyle, $pfontsize);
						$pfontdescent = $this->getFontDescent($pfontname, $pfontstyle, $pfontsize);
						$this->y += ($this->getCellHeight(($pfontsize - $curfontsize) / $this->k) + $pfontascent - $curfontascent - $pfontdescent + $curfontdescent) / 2;
						$minstartliney = min($this->y, $minstartliney);
						$maxbottomliney = max(($this->y + $this->getCellHeight($pfontsize / $this->k)), $maxbottomliney);
					}
				}
				// text
				$this->htmlvspace = 0;
				$isRTLString = preg_match(TCPDF_FONT_DATA::$uni_RE_PATTERN_RTL, $dom[$key]['value']) || preg_match(TCPDF_FONT_DATA::$uni_RE_PATTERN_ARABIC, $dom[$key]['value']);
				if ((!$this->premode) AND $this->isRTLTextDir() AND !$isRTLString) {
					// reverse spaces order
					$lsp = ''; // left spaces
					$rsp = ''; // right spaces
					if (preg_match('/^('.$this->re_space['p'].'+)/'.$this->re_space['m'], $dom[$key]['value'], $matches)) {
						$lsp = $matches[1];
					}
					if (preg_match('/('.$this->re_space['p'].'+)$/'.$this->re_space['m'], $dom[$key]['value'], $matches)) {
						$rsp = $matches[1];
					}
					$dom[$key]['value'] = $rsp.$this->stringTrim($dom[$key]['value']).$lsp;
				}
				if ($newline) {
					if (!$this->premode) {
						$prelen = strlen($dom[$key]['value']);
						if ($this->isRTLTextDir() AND !$isRTLString) {
							// right trim except non-breaking space
							$dom[$key]['value'] = $this->stringRightTrim($dom[$key]['value']);
						} else {
							// left trim except non-breaking space
							$dom[$key]['value'] = $this->stringLeftTrim($dom[$key]['value']);
						}
						$postlen = strlen($dom[$key]['value']);
						if (($postlen == 0) AND ($prelen > 0)) {
							$dom[$key]['trimmed_space'] = true;
						}
					}
					$newline = false;
					$firstblock = true;
				} else {
					$firstblock = false;
					// replace empty multiple spaces string with a single space
					$dom[$key]['value'] = preg_replace('/^'.$this->re_space['p'].'+$/'.$this->re_space['m'], chr(32), $dom[$key]['value']);
				}
				$strrest = '';
				if ($this->rtl) {
					$this->x -= $this->textindent;
				} else {
					$this->x += $this->textindent;
				}
				if (!isset($dom[$key]['trimmed_space']) OR !$dom[$key]['trimmed_space']) {
					$strlinelen = $this->GetStringWidth($dom[$key]['value']);
					if (!empty($this->HREF) AND (isset($this->HREF['url']))) {
						// HTML <a> Link
						$hrefcolor = '';
						if (isset($dom[($dom[$key]['parent'])]['fgcolor']) AND ($dom[($dom[$key]['parent'])]['fgcolor'] !== false)) {
							$hrefcolor = $dom[($dom[$key]['parent'])]['fgcolor'];
						}
						$hrefstyle = -1;
						if (isset($dom[($dom[$key]['parent'])]['fontstyle']) AND ($dom[($dom[$key]['parent'])]['fontstyle'] !== false)) {
							$hrefstyle = $dom[($dom[$key]['parent'])]['fontstyle'];
						}
						$strrest = $this->addHtmlLink($this->HREF['url'], $dom[$key]['value'], $wfill, true, $hrefcolor, $hrefstyle, true);
					} else {
						$wadj = 0; // space to leave for block continuity
						if ($this->rtl) {
							$cwa = ($this->x - $this->lMargin);
						} else {
							$cwa = ($this->w - $this->rMargin - $this->x);
						}
						if (($strlinelen < $cwa) AND (isset($dom[($key + 1)])) AND ($dom[($key + 1)]['tag']) AND (!$dom[($key + 1)]['block'])) {
							// check the next text blocks for continuity
							$nkey = ($key + 1);
							$write_block = true;
							$same_textdir = true;
							$tmp_fontname = $this->FontFamily;
							$tmp_fontstyle = $this->FontStyle;
							$tmp_fontsize = $this->FontSizePt;
							while ($write_block AND isset($dom[$nkey])) {
								if ($dom[$nkey]['tag']) {
									if ($dom[$nkey]['block']) {
										// end of block
										$write_block = false;
									}
									$tmp_fontname = isset($dom[$nkey]['fontname']) ? $dom[$nkey]['fontname'] : $this->FontFamily;
									$tmp_fontstyle = isset($dom[$nkey]['fontstyle']) ? $dom[$nkey]['fontstyle'] : $this->FontStyle;
									$tmp_fontsize = isset($dom[$nkey]['fontsize']) ? $dom[$nkey]['fontsize'] : $this->FontSizePt;
									$same_textdir = ($dom[$nkey]['dir'] == $dom[$key]['dir']);
								} else {
									$nextstr = TCPDF_STATIC::pregSplit('/'.$this->re_space['p'].'+/', $this->re_space['m'], $dom[$nkey]['value']);
									if (isset($nextstr[0]) AND $same_textdir) {
										$wadj += $this->GetStringWidth($nextstr[0], $tmp_fontname, $tmp_fontstyle, $tmp_fontsize);
										if (isset($nextstr[1])) {
											$write_block = false;
										}
									}
								}
								++$nkey;
							}
						}
						if (($wadj > 0) AND (($strlinelen + $wadj) >= $cwa)) {
							$wadj = 0;
							$nextstr = TCPDF_STATIC::pregSplit('/'.$this->re_space['p'].'/', $this->re_space['m'], $dom[$key]['value']);
							$numblks = count($nextstr);
							if ($numblks > 1) {
								// try to split on blank spaces
								$wadj = ($cwa - $strlinelen + $this->GetStringWidth($nextstr[($numblks - 1)]));
							} else {
								// set the entire block on new line
								$wadj = $this->GetStringWidth($nextstr[0]);
							}
						}
						// check for reversed text direction
						if (($wadj > 0) AND (($this->rtl AND ($this->tmprtl === 'L')) OR (!$this->rtl AND ($this->tmprtl === 'R')))) {
							// LTR text on RTL direction or RTL text on LTR direction
							$reverse_dir = true;
							$this->rtl = !$this->rtl;
							$revshift = ($strlinelen + $wadj + 0.000001); // add little quantity for rounding problems
							if ($this->rtl) {
								$this->x += $revshift;
							} else {
								$this->x -= $revshift;
							}
							$xws = $this->x;
						}
						// ****** write only until the end of the line and get the rest ******
						$strrest = $this->Write($this->lasth, $dom[$key]['value'], '', $wfill, '', false, 0, true, $firstblock, 0, $wadj);
						// restore default direction
						if ($reverse_dir AND ($wadj == 0)) {
							$this->x = $xws; // @phpstan-ignore-line
							$this->rtl = !$this->rtl;
							$reverse_dir = false;
						}
					}
				}
				$this->textindent = 0;
				if (strlen($strrest) > 0) {
					// store the remaining string on the previous $key position
					$this->newline = true;
					if ($strrest == $dom[$key]['value']) {
						// used to avoid infinite loop
						++$loop;
					} else {
						$loop = 0;
					}
					$dom[$key]['value'] = $strrest;
					if ($cell) {
						if ($this->rtl) {
							$this->x -= $this->cell_padding['R'];
						} else {
							$this->x += $this->cell_padding['L'];
						}
					}
					if ($loop < 3) {
						--$key;
					}
				} else {
					$loop = 0;
					// add the positive font spacing of the last character (if any)
					 if ($this->font_spacing > 0) {
					 	if ($this->rtl) {
							$this->x -= $this->font_spacing;
						} else {
							$this->x += $this->font_spacing;
						}
					}
				}
			}
			++$key;
			if (isset($dom[$key]['tag']) AND $dom[$key]['tag'] AND (!isset($dom[$key]['opening']) OR !$dom[$key]['opening']) AND isset($dom[($dom[$key]['parent'])]['attribute']['nobr']) AND ($dom[($dom[$key]['parent'])]['attribute']['nobr'] == 'true')) {
				// check if we are on a new page or on a new column
				if ((!$undo) AND (($this->y < $this->start_transaction_y) OR (($dom[$key]['value'] == 'tr') AND ($dom[($dom[$key]['parent'])]['endy'] < $this->start_transaction_y)))) {
					// we are on a new page or on a new column and the total object height is less than the available vertical space.
					// restore previous object
					$this->rollbackTransaction(true);
					// restore previous values
					foreach ($this_method_vars as $vkey => $vval) {
						$$vkey = $vval;
					}
					if (!empty($dom[$key]['thead'])) {
						$this->inthead = true;
					}
					// add a page (or trig AcceptPageBreak() for multicolumn mode)
					$pre_y = $this->y;
					if ((!$this->checkPageBreak($this->PageBreakTrigger + 1)) AND ($this->y < $pre_y)) {
						$startliney = $this->y;
					}
					$undo = true; // avoid infinite loop
				} else {
					$undo = false;
				}
			}
		} // end for each $key
		// align the last line
		if (isset($startlinex)) {
			$yshift = ($minstartliney - $startliney);
			if (($yshift > 0) OR ($this->page > $startlinepage)) {
				$yshift = 0;
			}
			$t_x = 0;
			// the last line must be shifted to be aligned as requested
			$linew = abs($this->endlinex - $startlinex);
			if ($this->inxobj) {
				// we are inside an XObject template
				$pstart = substr($this->xobjects[$this->xobjid]['outdata'], 0, $startlinepos);
				if (isset($opentagpos)) {
					$midpos = $opentagpos;
				} else {
					$midpos = 0;
				}
				if ($midpos > 0) {
					$pmid = substr($this->xobjects[$this->xobjid]['outdata'], $startlinepos, ($midpos - $startlinepos));
					$pend = substr($this->xobjects[$this->xobjid]['outdata'], $midpos);
				} else {
					$pmid = substr($this->xobjects[$this->xobjid]['outdata'], $startlinepos);
					$pend = '';
				}
			} else {
				$pstart = substr($this->getPageBuffer($startlinepage), 0, $startlinepos);
				if (isset($opentagpos) AND isset($this->footerlen[$startlinepage]) AND (!$this->InFooter)) {
					$this->footerpos[$startlinepage] = $this->pagelen[$startlinepage] - $this->footerlen[$startlinepage];
					$midpos = min($opentagpos, $this->footerpos[$startlinepage]);
				} elseif (isset($opentagpos)) {
					$midpos = $opentagpos;
				} elseif (isset($this->footerlen[$startlinepage]) AND (!$this->InFooter)) {
					$this->footerpos[$startlinepage] = $this->pagelen[$startlinepage] - $this->footerlen[$startlinepage];
					$midpos = $this->footerpos[$startlinepage];
				} else {
					$midpos = 0;
				}
				if ($midpos > 0) {
					$pmid = substr($this->getPageBuffer($startlinepage), $startlinepos, ($midpos - $startlinepos));
					$pend = substr($this->getPageBuffer($startlinepage), $midpos);
				} else {
					$pmid = substr($this->getPageBuffer($startlinepage), $startlinepos);
					$pend = '';
				}
			}
			if ((((($plalign == 'C') OR (($plalign == 'R') AND (!$this->rtl)) OR (($plalign == 'L') AND ($this->rtl)))))) {
				// calculate shifting amount
				$tw = $w;
				if ($this->lMargin != $prevlMargin) {
					$tw += ($prevlMargin - $this->lMargin);
				}
				if ($this->rMargin != $prevrMargin) {
					$tw += ($prevrMargin - $this->rMargin);
				}
				$one_space_width = $this->GetStringWidth(chr(32));
				$no = 0; // number of spaces on a line contained on a single block
				if ($this->isRTLTextDir()) { // RTL
					// remove left space if exist
					$pos1 = TCPDF_STATIC::revstrpos($pmid, '[(');
					if ($pos1 > 0) {
						$pos1 = intval($pos1);
						if ($this->isUnicodeFont()) {
							$pos2 = intval(TCPDF_STATIC::revstrpos($pmid, '[('.chr(0).chr(32)));
							$spacelen = 2;
						} else {
							$pos2 = intval(TCPDF_STATIC::revstrpos($pmid, '[('.chr(32)));
							$spacelen = 1;
						}
						if ($pos1 == $pos2) {
							$pmid = substr($pmid, 0, ($pos1 + 2)).substr($pmid, ($pos1 + 2 + $spacelen));
							if (substr($pmid, $pos1, 4) == '[()]') {
								$linew -= $one_space_width;
							} elseif ($pos1 == strpos($pmid, '[(')) {
								$no = 1;
							}
						}
					}
				} else { // LTR
					// remove right space if exist
					$pos1 = TCPDF_STATIC::revstrpos($pmid, ')]');
					if ($pos1 > 0) {
						$pos1 = intval($pos1);
						if ($this->isUnicodeFont()) {
							$pos2 = intval(TCPDF_STATIC::revstrpos($pmid, chr(0).chr(32).')]')) + 2;
							$spacelen = 2;
						} else {
							$pos2 = intval(TCPDF_STATIC::revstrpos($pmid, chr(32).')]')) + 1;
							$spacelen = 1;
						}
						if ($pos1 == $pos2) {
							$pmid = substr($pmid, 0, ($pos1 - $spacelen)).substr($pmid, $pos1);
							$linew -= $one_space_width;
						}
					}
				}
				$mdiff = ($tw - $linew);
				if ($plalign == 'C') {
					if ($this->rtl) {
						$t_x = -($mdiff / 2);
					} else {
						$t_x = ($mdiff / 2);
					}
				} elseif ($plalign == 'R') {
					// right alignment on LTR document
					$t_x = $mdiff;
				} elseif ($plalign == 'L') {
					// left alignment on RTL document
					$t_x = -$mdiff;
				}
			} // end if startlinex
			if (($t_x != 0) OR ($yshift < 0)) {
				// shift the line
				$trx = sprintf('1 0 0 1 %F %F cm', ($t_x * $this->k), ($yshift * $this->k));
				$pstart .= ""\nq\n"".$trx.""\n"".$pmid.""\nQ\n"";
				$endlinepos = strlen($pstart);
				if ($this->inxobj) {
					// we are inside an XObject template
					$this->xobjects[$this->xobjid]['outdata'] = $pstart.$pend;
					foreach ($this->xobjects[$this->xobjid]['annotations'] as $pak => $pac) {
						if ($pak >= $pask) {
							$this->xobjects[$this->xobjid]['annotations'][$pak]['x'] += $t_x;
							$this->xobjects[$this->xobjid]['annotations'][$pak]['y'] -= $yshift;
						}
					}
				} else {
					$this->setPageBuffer($startlinepage, $pstart.$pend);
					// shift the annotations and links
					if (isset($this->PageAnnots[$this->page])) {
						foreach ($this->PageAnnots[$this->page] as $pak => $pac) {
							if ($pak >= $pask) {
								$this->PageAnnots[$this->page][$pak]['x'] += $t_x;
								$this->PageAnnots[$this->page][$pak]['y'] -= $yshift;
							}
						}
					}
				}
				$this->y -= $yshift;
				$yshift = 0;
			}
		}
		// restore previous values
		$this->setGraphicVars($gvars);
		if ($this->num_columns > 1) {
			$this->selectColumn();
		} elseif ($this->page > $prevPage) {
			$this->lMargin = $this->pagedim[$this->page]['olm'];
			$this->rMargin = $this->pagedim[$this->page]['orm'];
		}
		// restore previous list state
		$this->cell_height_ratio = $prev_cell_height_ratio;
		$this->listnum = $prev_listnum;
		$this->listordered = $prev_listordered;
		$this->listcount = $prev_listcount;
		$this->lispacer = $prev_lispacer;
		if ($ln AND (!($cell AND ($dom[$key-1]['value'] == 'table')))) {
			$this->Ln($this->lasth);
			if (($this->y < $maxbottomliney) AND ($startlinepage == $this->page)) {
				$this->y = $maxbottomliney;
			}
		}
		unset($dom);
	}

	/**
	 * Process opening tags.
	 * @param array $dom html dom array
	 * @param int $key current element id
	 * @param boolean $cell if true add the default left (or right if RTL) padding to each new line (default false).
	 * @return array $dom
	 * @protected
	 */
	protected function openHTMLTagHandler($dom, $key, $cell) {
		$tag = $dom[$key];
		$parent = $dom[($dom[$key]['parent'])];
		$firsttag = ($key == 1);
		// check for text direction attribute
		if (isset($tag['dir'])) {
			$this->setTempRTL($tag['dir']);
		} else {
			$this->tmprtl = false;
		}
		if ($tag['block']) {
			$hbz = 0; // distance from y to line bottom
			$hb = 0; // vertical space between block tags
			// calculate vertical space for block tags
			if (isset($this->tagvspaces[$tag['value']][0]['h']) && !empty($this->tagvspaces[$tag['value']][0]['h']) && ($this->tagvspaces[$tag['value']][0]['h'] >= 0)) {
				$cur_h = $this->tagvspaces[$tag['value']][0]['h'];
			} elseif (isset($tag['fontsize'])) {
				$cur_h = $this->getCellHeight($tag['fontsize'] / $this->k);
			} else {
				$cur_h = $this->getCellHeight($this->FontSize);
			}
			if (isset($this->tagvspaces[$tag['value']][0]['n'])) {
				$on = $this->tagvspaces[$tag['value']][0]['n'];
			} elseif (preg_match('/[h][0-9]/', $tag['value']) > 0) {
				$on = 0.6;
			} else {
				$on = 1;
			}
			if ((!isset($this->tagvspaces[$tag['value']])) AND (in_array($tag['value'], array('div', 'dt', 'dd', 'li', 'br', 'hr')))) {
				$hb = 0;
			} else {
				$hb = ($on * $cur_h);
			}
			if (($this->htmlvspace <= 0) AND ($on > 0)) {
				if (isset($parent['fontsize'])) {
					$hbz = (($parent['fontsize'] / $this->k) * $this->cell_height_ratio);
				} else {
					$hbz = $this->getCellHeight($this->FontSize);
				}
			}
			if (isset($dom[($key - 1)]) AND ($dom[($key - 1)]['value'] == 'table')) {
				// fix vertical space after table
				$hbz = 0;
			}
			// closing vertical space
			$hbc = 0;
			if (isset($this->tagvspaces[$tag['value']][1]['h']) && !empty($this->tagvspaces[$tag['value']][1]['h']) && ($this->tagvspaces[$tag['value']][1]['h'] >= 0)) {
				$pre_h = $this->tagvspaces[$tag['value']][1]['h'];
			} elseif (isset($parent['fontsize'])) {
				$pre_h = $this->getCellHeight($parent['fontsize'] / $this->k);
			} else {
				$pre_h = $this->getCellHeight($this->FontSize);
			}
			if (isset($this->tagvspaces[$tag['value']][1]['n'])) {
				$cn = $this->tagvspaces[$tag['value']][1]['n'];
			} elseif (preg_match('/[h][0-9]/', $tag['value']) > 0) {
				$cn = 0.6;
			} else {
				$cn = 1;
			}
			if (isset($this->tagvspaces[$tag['value']][1])) {
				$hbc = ($cn * $pre_h);
			}
		}
		// Opening tag
		switch($tag['value']) {
			case 'table': {
				$cp = 0;
				$cs = 0;
				$dom[$key]['rowspans'] = array();
				if (!isset($dom[$key]['attribute']['nested']) OR ($dom[$key]['attribute']['nested'] != 'true')) {
					$this->htmlvspace = 0;
					// set table header
					if (!TCPDF_STATIC::empty_string($dom[$key]['thead'])) {
						// set table header
						$this->thead = $dom[$key]['thead'];
						if (!isset($this->theadMargins) OR (empty($this->theadMargins))) {
							$this->theadMargins = array();
							$this->theadMargins['cell_padding'] = $this->cell_padding;
							$this->theadMargins['lmargin'] = $this->lMargin;
							$this->theadMargins['rmargin'] = $this->rMargin;
							$this->theadMargins['page'] = $this->page;
							$this->theadMargins['cell'] = $cell;
							$this->theadMargins['gvars'] = $this->getGraphicVars();
						}
					}
				}
				// store current margins and page
				$dom[$key]['old_cell_padding'] = $this->cell_padding;
				if (isset($tag['attribute']['cellpadding'])) {
					$pad = $this->getHTMLUnitToUnits($tag['attribute']['cellpadding'], 1, 'px');
					$this->setCellPadding($pad);
				} elseif (isset($tag['padding'])) {
					$this->cell_padding = $tag['padding'];
				}
				if (isset($tag['attribute']['cellspacing'])) {
					$cs = $this->getHTMLUnitToUnits($tag['attribute']['cellspacing'], 1, 'px');
				} elseif (isset($tag['border-spacing'])) {
					$cs = $tag['border-spacing']['V'];
				}
				$prev_y = $this->y;
				if ($this->checkPageBreak(((2 * $cp) + (2 * $cs) + $this->lasth), '', false) OR ($this->y < $prev_y)) {
					$this->inthead = true;
					// add a page (or trig AcceptPageBreak() for multicolumn mode)
					$this->checkPageBreak($this->PageBreakTrigger + 1);
				}
				break;
			}
			case 'tr': {
				// array of columns positions
				$dom[$key]['cellpos'] = array();
				break;
			}
			case 'hr': {
				if ((isset($tag['height'])) AND ($tag['height'] != '')) {
					$hrHeight = $this->getHTMLUnitToUnits($tag['height'], 1, 'px');
				} else {
					$hrHeight = $this->GetLineWidth();
				}
				$this->addHTMLVertSpace($hbz, max($hb, ($hrHeight / 2)), $cell, $firsttag);
				$x = $this->GetX();
				$y = $this->GetY();
				$wtmp = $this->w - $this->lMargin - $this->rMargin;
				if ($cell) {
					$wtmp -= ($this->cell_padding['L'] + $this->cell_padding['R']);
				}
				if ((isset($tag['width'])) AND ($tag['width'] != '')) {
					$hrWidth = $this->getHTMLUnitToUnits($tag['width'], $wtmp, 'px');
				} else {
					$hrWidth = $wtmp;
				}
				$prevlinewidth = $this->GetLineWidth();
				$this->setLineWidth($hrHeight);

				$lineStyle = array();
                    		if (isset($tag['fgcolor'])) {
		                        $lineStyle['color'] = $tag['fgcolor'];
                    		}

                    		if (isset($tag['fgcolor'])) {
                        		$lineStyle['color'] = $tag['fgcolor'];
                    		}

                    		if (isset($tag['style']['cap'])) {
                        		$lineStyle['cap'] = $tag['style']['cap'];
                    		}

                    		if (isset($tag['style']['join'])) {
                        		$lineStyle['join'] = $tag['style']['join'];
                    		}

                    		if (isset($tag['style']['dash'])) {
                        		$lineStyle['dash'] = $tag['style']['dash'];
                    		}

                    		if (isset($tag['style']['phase'])) {
                        		$lineStyle['phase'] = $tag['style']['phase'];
                    		}

				$lineStyle = array_filter($lineStyle);

				$this->Line($x, $y, $x + $hrWidth, $y, $lineStyle);
				$this->setLineWidth($prevlinewidth);
				$this->addHTMLVertSpace(max($hbc, ($hrHeight / 2)), 0, $cell, !isset($dom[($key + 1)]));
				break;
			}
			case 'a': {
				if (array_key_exists('href', $tag['attribute'])) {
					$this->HREF['url'] = $tag['attribute']['href'];
				}
				break;
			}
			case 'img': {
				if (empty($tag['attribute']['src'])) {
					break;
				}
				$imgsrc = $tag['attribute']['src'];
				if ($imgsrc[0] === '@') {
					// data stream
					$imgsrc = '@'.base64_decode(substr($imgsrc, 1));
					$type = '';
				} else if (preg_match('@^data:image/([^;]*);base64,(.*)@', $imgsrc, $reg)) {
					$imgsrc = '@'.base64_decode($reg[2]);
					$type = $reg[1];
				} elseif ( $this->allowLocalFiles && substr($imgsrc, 0, 7) === 'file://') {
                    // get image type from a local file path
                    $imgsrc = substr($imgsrc, 7);
                    $type = TCPDF_IMAGES::getImageFileType($imgsrc);
                } else {
					if (($imgsrc[0] === '/') AND !empty($_SERVER['DOCUMENT_ROOT']) AND ($_SERVER['DOCUMENT_ROOT'] != '/')) {
						// fix image path
						$findroot = strpos($imgsrc, $_SERVER['DOCUMENT_ROOT']);
						if (($findroot === false) OR ($findroot > 1)) {
							if (substr($_SERVER['DOCUMENT_ROOT'], -1) == '/') {
								$imgsrc = substr($_SERVER['DOCUMENT_ROOT'], 0, -1).$imgsrc;
							} else {
								$imgsrc = $_SERVER['DOCUMENT_ROOT'].$imgsrc;
							}
						}
						$imgsrc = urldecode($imgsrc);
						$testscrtype = @parse_url($imgsrc);
						if (empty($testscrtype['query'])) {
							// convert URL to server path
							$imgsrc = str_replace(K_PATH_URL, K_PATH_MAIN, $imgsrc);
						} elseif (preg_match('|^https?://|', $imgsrc) !== 1) {
							// convert URL to server path
							$imgsrc = str_replace(K_PATH_MAIN, K_PATH_URL, $imgsrc);
						}
					}
					// get image type
					$type = TCPDF_IMAGES::getImageFileType($imgsrc);
				}
				if (!isset($tag['width'])) {
					$tag['width'] = 0;
				}
				if (!isset($tag['height'])) {
					$tag['height'] = 0;
				}
				//if (!isset($tag['attribute']['align'])) {
					// the only alignment supported is ""bottom""
					// further development is required for other modes.
					$tag['attribute']['align'] = 'bottom';
				//}
				switch($tag['attribute']['align']) {
					case 'top': {
						$align = 'T';
						break;
					}
					case 'middle': {
						$align = 'M';
						break;
					}
					case 'bottom': {
						$align = 'B';
						break;
					}
					default: {
						$align = 'B';
						break;
					}
				}
				$prevy = $this->y;
				$xpos = $this->x;
				$imglink = '';
				if (isset($this->HREF['url']) AND !TCPDF_STATIC::empty_string($this->HREF['url'])) {
					$imglink = $this->HREF['url'];
					if ($imglink[0] == '#') {
						// convert url to internal link
						$lnkdata = explode(',', $imglink);
						if (isset($lnkdata[0])) {
							$page = intval(substr($lnkdata[0], 1));
							if (empty($page) OR ($page <= 0)) {
								$page = $this->page;
							}
							if (isset($lnkdata[1]) AND (strlen($lnkdata[1]) > 0)) {
								$lnky = floatval($lnkdata[1]);
							} else {
								$lnky = 0;
							}
							$imglink = $this->AddLink();
							$this->setLink($imglink, $lnky, $page);
						}
					}
				}
				$border = 0;
				if (isset($tag['border']) AND !empty($tag['border'])) {
					// currently only support 1 (frame) or a combination of 'LTRB'
					$border = $tag['border'];
				}
				$iw = '';
				if (isset($tag['width'])) {
					$iw = $this->getHTMLUnitToUnits($tag['width'], ($tag['fontsize'] / $this->k), 'px', false);
				}
				$ih = '';
				if (isset($tag['height'])) {
					$ih = $this->getHTMLUnitToUnits($tag['height'], ($tag['fontsize'] / $this->k), 'px', false);
				}
				if (($type == 'eps') OR ($type == 'ai')) {
					$this->ImageEps($imgsrc, $xpos, $this->y, $iw, $ih, $imglink, true, $align, '', $border, true);
				} elseif ($type == 'svg') {
					$this->ImageSVG($imgsrc, $xpos, $this->y, $iw, $ih, $imglink, $align, '', $border, true);
				} else {
					$this->Image($imgsrc, $xpos, $this->y, $iw, $ih, '', $imglink, $align, false, 300, '', false, false, $border, false, false, true);
				}
				switch($align) {
					case 'T': {
						$this->y = $prevy;
						break;
					}
					case 'M': {
						$this->y = (($this->img_rb_y + $prevy - ($this->getCellHeight($tag['fontsize'] / $this->k))) / 2);
						break;
					}
					case 'B': {
						$this->y = $this->img_rb_y - ($this->getCellHeight($tag['fontsize'] / $this->k) - ($this->getFontDescent($tag['fontname'], $tag['fontstyle'], $tag['fontsize']) * $this->cell_height_ratio));
						break;
					}
				}
				break;
			}
			case 'dl': {
				++$this->listnum;
				if ($this->listnum == 1) {
					$this->addHTMLVertSpace($hbz, $hb, $cell, $firsttag);
				} else {
					$this->addHTMLVertSpace(0, 0, $cell, $firsttag);
				}
				break;
			}
			case 'dt': {
				$this->addHTMLVertSpace($hbz, $hb, $cell, $firsttag);
				break;
			}
			case 'dd': {
				if ($this->rtl) {
					$this->rMargin += $this->listindent;
				} else {
					$this->lMargin += $this->listindent;
				}
				++$this->listindentlevel;
				$this->addHTMLVertSpace($hbz, $hb, $cell, $firsttag);
				break;
			}
			case 'ul':
			case 'ol': {
				++$this->listnum;
				if ($tag['value'] == 'ol') {
					$this->listordered[$this->listnum] = true;
				} else {
					$this->listordered[$this->listnum] = false;
				}
				if (isset($tag['attribute']['start'])) {
					$this->listcount[$this->listnum] = intval($tag['attribute']['start']) - 1;
				} else {
					$this->listcount[$this->listnum] = 0;
				}
				if ($this->rtl) {
					$this->rMargin += $this->listindent;
					$this->x -= $this->listindent;
				} else {
					$this->lMargin += $this->listindent;
					$this->x += $this->listindent;
				}
				++$this->listindentlevel;
				if ($this->listnum == 1) {
					if ($key > 1) {
						$this->addHTMLVertSpace($hbz, $hb, $cell, $firsttag);
					}
				} else {
					$this->addHTMLVertSpace(0, 0, $cell, $firsttag);
				}
				break;
			}
			case 'li': {
				if ($key > 2) {
					$this->addHTMLVertSpace($hbz, $hb, $cell, $firsttag);
				}
				if ($this->listordered[$this->listnum]) {
					// ordered item
					if (isset($parent['attribute']['type']) AND !TCPDF_STATIC::empty_string($parent['attribute']['type'])) {
						$this->lispacer = $parent['attribute']['type'];
					} elseif (isset($parent['listtype']) AND !TCPDF_STATIC::empty_string($parent['listtype'])) {
						$this->lispacer = $parent['listtype'];
					} elseif (isset($this->lisymbol) AND !TCPDF_STATIC::empty_string($this->lisymbol)) {
						$this->lispacer = $this->lisymbol;
					} else {
						$this->lispacer = '#';
					}
					++$this->listcount[$this->listnum];
					if (isset($tag['attribute']['value'])) {
						$this->listcount[$this->listnum] = intval($tag['attribute']['value']);
					}
				} else {
					// unordered item
					if (isset($parent['attribute']['type']) AND !TCPDF_STATIC::empty_string($parent['attribute']['type'])) {
						$this->lispacer = $parent['attribute']['type'];
					} elseif (isset($parent['listtype']) AND !TCPDF_STATIC::empty_string($parent['listtype'])) {
						$this->lispacer = $parent['listtype'];
					} elseif (isset($this->lisymbol) AND !TCPDF_STATIC::empty_string($this->lisymbol)) {
						$this->lispacer = $this->lisymbol;
					} else {
						$this->lispacer = '!';
					}
				}
				break;
			}
			case 'blockquote': {
				if ($this->rtl) {
					$this->rMargin += $this->listindent;
				} else {
					$this->lMargin += $this->listindent;
				}
				++$this->listindentlevel;
				$this->addHTMLVertSpace($hbz, $hb, $cell, $firsttag);
				break;
			}
			case 'br': {
				$this->addHTMLVertSpace($hbz, $hb, $cell, $firsttag);
				break;
			}
			case 'div': {
				$this->addHTMLVertSpace($hbz, $hb, $cell, $firsttag);
				break;
			}
			case 'p': {
				$this->addHTMLVertSpace($hbz, $hb, $cell, $firsttag);
				break;
			}
			case 'pre': {
				$this->addHTMLVertSpace($hbz, $hb, $cell, $firsttag);
				$this->premode = true;
				break;
			}
			case 'sup': {
				$this->setXY($this->GetX(), $this->GetY() - ((0.7 * $this->FontSizePt) / $this->k));
				break;
			}
			case 'sub': {
				$this->setXY($this->GetX(), $this->GetY() + ((0.3 * $this->FontSizePt) / $this->k));
				break;
			}
			case 'h1':
			case 'h2':
			case 'h3':
			case 'h4':
			case 'h5':
			case 'h6': {
				$this->addHTMLVertSpace($hbz, $hb, $cell, $firsttag);
				break;
			}
			// Form fields (since 4.8.000 - 2009-09-07)
			case 'form': {
				if (isset($tag['attribute']['action'])) {
					$this->form_action = $tag['attribute']['action'];
				} else {
					$this->Error('Please explicitly set action attribute path!');
				}
				if (isset($tag['attribute']['enctype'])) {
					$this->form_enctype = $tag['attribute']['enctype'];
				} else {
					$this->form_enctype = 'application/x-www-form-urlencoded';
				}
				if (isset($tag['attribute']['method'])) {
					$this->form_mode = $tag['attribute']['method'];
				} else {
					$this->form_mode = 'post';
				}
				break;
			}
			case 'input': {
				if (isset($tag['attribute']['name']) AND !TCPDF_STATIC::empty_string($tag['attribute']['name'])) {
					$name = $tag['attribute']['name'];
				} else {
					break;
				}
				$prop = array();
				$opt = array();
				if (isset($tag['attribute']['readonly']) AND !TCPDF_STATIC::empty_string($tag['attribute']['readonly'])) {
					$prop['readonly'] = true;
				}
				if (isset($tag['attribute']['value']) AND !TCPDF_STATIC::empty_string($tag['attribute']['value'])) {
					$value = $tag['attribute']['value'];
				}
				if (isset($tag['attribute']['maxlength']) AND !TCPDF_STATIC::empty_string($tag['attribute']['maxlength'])) {
					$opt['maxlen'] = intval($tag['attribute']['maxlength']);
				}
				$h = $this->getCellHeight($this->FontSize);
				if (isset($tag['attribute']['size']) AND !TCPDF_STATIC::empty_string($tag['attribute']['size'])) {
					$w = intval($tag['attribute']['size']) * $this->GetStringWidth(chr(32)) * 2;
				} else {
					$w = $h;
				}
				if (isset($tag['attribute']['checked']) AND (($tag['attribute']['checked'] == 'checked') OR ($tag['attribute']['checked'] == 'true'))) {
					$checked = true;
				} else {
					$checked = false;
				}
				if (isset($tag['align'])) {
					switch ($tag['align']) {
						case 'C': {
							$opt['q'] = 1;
							break;
						}
						case 'R': {
							$opt['q'] = 2;
							break;
						}
						case 'L':
						default: {
							break;
						}
					}
				}
				switch ($tag['attribute']['type']) {
					case 'text': {
						if (isset($value)) {
							$opt['v'] = $value;
						}
						$this->TextField($name, $w, $h, $prop, $opt, '', '', false);
						break;
					}
					case 'password': {
						if (isset($value)) {
							$opt['v'] = $value;
						}
						$prop['password'] = 'true';
						$this->TextField($name, $w, $h, $prop, $opt, '', '', false);
						break;
					}
					case 'checkbox': {
						if (!isset($value)) {
							break;
						}
						$this->CheckBox($name, $w, $checked, $prop, $opt, $value, '', '', false);
						break;
					}
					case 'radio': {
						if (!isset($value)) {
							break;
						}
						$this->RadioButton($name, $w, $prop, $opt, $value, $checked, '', '', false);
						break;
					}
					case 'submit': {
						if (!isset($value)) {
							$value = 'submit';
						}
						$w = $this->GetStringWidth($value) * 1.5;
						$h *= 1.6;
						$prop = array('lineWidth'=>1, 'borderStyle'=>'beveled', 'fillColor'=>array(196, 196, 196), 'strokeColor'=>array(255, 255, 255));
						$action = array();
						$action['S'] = 'SubmitForm';
						$action['F'] = $this->form_action;
						if ($this->form_enctype != 'FDF') {
							$action['Flags'] = array('ExportFormat');
						}
						if ($this->form_mode == 'get') {
							$action['Flags'] = array('GetMethod');
						}
						$this->Button($name, $w, $h, $value, $action, $prop, $opt, '', '', false);
						break;
					}
					case 'reset': {
						if (!isset($value)) {
							$value = 'reset';
						}
						$w = $this->GetStringWidth($value) * 1.5;
						$h *= 1.6;
						$prop = array('lineWidth'=>1, 'borderStyle'=>'beveled', 'fillColor'=>array(196, 196, 196), 'strokeColor'=>array(255, 255, 255));
						$this->Button($name, $w, $h, $value, array('S'=>'ResetForm'), $prop, $opt, '', '', false);
						break;
					}
					case 'file': {
						$prop['fileSelect'] = 'true';
						$this->TextField($name, $w, $h, $prop, $opt, '', '', false);
						if (!isset($value)) {
							$value = '*';
						}
						$w = $this->GetStringWidth($value) * 2;
						$h *= 1.2;
						$prop = array('lineWidth'=>1, 'borderStyle'=>'beveled', 'fillColor'=>array(196, 196, 196), 'strokeColor'=>array(255, 255, 255));
						$jsaction = 'var f=this.getField(\''.$name.'\'); f.browseForFileToSubmit();';
						$this->Button('FB_'.$name, $w, $h, $value, $jsaction, $prop, $opt, '', '', false);
						break;
					}
					case 'hidden': {
						if (isset($value)) {
							$opt['v'] = $value;
						}
						$opt['f'] = array('invisible', 'hidden');
						$this->TextField($name, 0, 0, $prop, $opt, '', '', false);
						break;
					}
					case 'image': {
						// THIS TYPE MUST BE FIXED
						if (isset($tag['attribute']['src']) AND !TCPDF_STATIC::empty_string($tag['attribute']['src'])) {
							$img = $tag['attribute']['src'];
						} else {
							break;
						}
						$value = 'img';
						//$opt['mk'] = array('i'=>$img, 'tp'=>1, 'if'=>array('sw'=>'A', 's'=>'A', 'fb'=>false));
						if (isset($tag['attribute']['onclick']) AND !empty($tag['attribute']['onclick'])) {
							$jsaction = $tag['attribute']['onclick'];
						} else {
							$jsaction = '';
						}
						$this->Button($name, $w, $h, $value, $jsaction, $prop, $opt, '', '', false);
						break;
					}
					case 'button': {
						if (!isset($value)) {
							$value = ' ';
						}
						$w = $this->GetStringWidth($value) * 1.5;
						$h *= 1.6;
						$prop = array('lineWidth'=>1, 'borderStyle'=>'beveled', 'fillColor'=>array(196, 196, 196), 'strokeColor'=>array(255, 255, 255));
						if (isset($tag['attribute']['onclick']) AND !empty($tag['attribute']['onclick'])) {
							$jsaction = $tag['attribute']['onclick'];
						} else {
							$jsaction = '';
						}
						$this->Button($name, $w, $h, $value, $jsaction, $prop, $opt, '', '', false);
						break;
					}
				}
				break;
			}
			case 'textarea': {
				$prop = array();
				$opt = array();
				if (isset($tag['attribute']['readonly']) AND !TCPDF_STATIC::empty_string($tag['attribute']['readonly'])) {
					$prop['readonly'] = true;
				}
				if (isset($tag['attribute']['name']) AND !TCPDF_STATIC::empty_string($tag['attribute']['name'])) {
					$name = $tag['attribute']['name'];
				} else {
					break;
				}
				if (isset($tag['attribute']['value']) AND !TCPDF_STATIC::empty_string($tag['attribute']['value'])) {
					$opt['v'] = $tag['attribute']['value'];
				}
				if (isset($tag['attribute']['cols']) AND !TCPDF_STATIC::empty_string($tag['attribute']['cols'])) {
					$w = intval($tag['attribute']['cols']) * $this->GetStringWidth(chr(32)) * 2;
				} else {
					$w = 40;
				}
				if (isset($tag['attribute']['rows']) AND !TCPDF_STATIC::empty_string($tag['attribute']['rows'])) {
					$h = intval($tag['attribute']['rows']) * $this->getCellHeight($this->FontSize);
				} else {
					$h = 10;
				}
				$prop['multiline'] = 'true';
				$this->TextField($name, $w, $h, $prop, $opt, '', '', false);
				break;
			}
			case 'select': {
				$h = $this->getCellHeight($this->FontSize);
				if (isset($tag['attribute']['size']) AND !TCPDF_STATIC::empty_string($tag['attribute']['size'])) {
					$h *= ($tag['attribute']['size'] + 1);
				}
				$prop = array();
				$opt = array();
				if (isset($tag['attribute']['name']) AND !TCPDF_STATIC::empty_string($tag['attribute']['name'])) {
					$name = $tag['attribute']['name'];
				} else {
					break;
				}
				$w = 0;
				if (isset($tag['attribute']['opt']) AND !TCPDF_STATIC::empty_string($tag['attribute']['opt'])) {
					$options = explode('#!NwL!#', $tag['attribute']['opt']);
					$values = array();
					foreach ($options as $val) {
						if (strpos($val, '#!TaB!#') !== false) {
							$opts = explode('#!TaB!#', $val);
							$values[] = $opts;
							$w = max($w, $this->GetStringWidth($opts[1]));
						} else {
							$values[] = $val;
							$w = max($w, $this->GetStringWidth($val));
						}
					}
				} else {
					break;
				}
				$w *= 2;
				if (isset($tag['attribute']['multiple']) AND ($tag['attribute']['multiple']='multiple')) {
					$prop['multipleSelection'] = 'true';
					$this->ListBox($name, $w, $h, $values, $prop, $opt, '', '', false);
				} else {
					$this->ComboBox($name, $w, $h, $values, $prop, $opt, '', '', false);
				}
				break;
			}
			case 'tcpdf': {
				if (defined('K_TCPDF_CALLS_IN_HTML') AND (K_TCPDF_CALLS_IN_HTML === true)) {
					// Special tag used to call TCPDF methods
					// This tag is disabled by default by the K_TCPDF_CALLS_IN_HTML constant on TCPDF configuration file.
					// Please use this feature only if you are in control of the HTML content and you are sure that it does not contain any harmful code.
					if (!empty($tag['attribute']['data'])) {
						$tcpdf_tag_data = $this->unserializeTCPDFtag($tag['attribute']['data']);
						if ($this->allowedTCPDFtag($tcpdf_tag_data['m'])) {
							call_user_func_array(array($this, $tcpdf_tag_data['m']), $tcpdf_tag_data['p']);
						}
						$this->newline = true;
					}
				}
				break;
			}
			default: {
				break;
			}
		}
		// define tags that support borders and background colors
		$bordertags = array('blockquote','br','dd','dl','div','dt','h1','h2','h3','h4','h5','h6','hr','li','ol','p','pre','ul','tcpdf','table');
		if (in_array($tag['value'], $bordertags)) {
			// set border
			$dom[$key]['borderposition'] = $this->getBorderStartPosition();
		}
		if ($dom[$key]['self'] AND isset($dom[$key]['attribute']['pagebreakafter'])) {
			$pba = $dom[$key]['attribute']['pagebreakafter'];
			// check for pagebreak
			if (($pba == 'true') OR ($pba == 'left') OR ($pba == 'right')) {
				// add a page (or trig AcceptPageBreak() for multicolumn mode)
				$this->checkPageBreak($this->PageBreakTrigger + 1);
			}
			if ((($pba == 'left') AND (((!$this->rtl) AND (($this->page % 2) == 0)) OR (($this->rtl) AND (($this->page % 2) != 0))))
				OR (($pba == 'right') AND (((!$this->rtl) AND (($this->page % 2) != 0)) OR (($this->rtl) AND (($this->page % 2) == 0))))) {
				// add a page (or trig AcceptPageBreak() for multicolumn mode)
				$this->checkPageBreak($this->PageBreakTrigger + 1);
			}
		}
		return $dom;
	}

	/**
	 * Process closing tags.
	 * @param array $dom html dom array
	 * @param int $key current element id
	 * @param boolean $cell if true add the default left (or right if RTL) padding to each new line (default false).
	 * @param int $maxbottomliney maximum y value of current line
	 * @return array $dom
	 * @protected
	 */
	protected function closeHTMLTagHandler($dom, $key, $cell, $maxbottomliney=0) {
		$tag = $dom[$key];
		$parent = $dom[($dom[$key]['parent'])];
		$lasttag = ((!isset($dom[($key + 1)])) OR ((!isset($dom[($key + 2)])) AND ($dom[($key + 1)]['value'] == 'marker')));
		$in_table_head = false;
		// maximum x position (used to draw borders)
		if ($this->rtl) {
			$xmax = $this->w;
		} else {
			$xmax = 0;
		}
		if ($tag['block']) {
			$hbz = 0; // distance from y to line bottom
			$hb = 0; // vertical space between block tags
			// calculate vertical space for block tags
			if (isset($this->tagvspaces[$tag['value']][1]['h']) && !empty($this->tagvspaces[$tag['value']][1]['h']) && ($this->tagvspaces[$tag['value']][1]['h'] >= 0)) {
				$pre_h = $this->tagvspaces[$tag['value']][1]['h'];
			} elseif (isset($parent['fontsize'])) {
				$pre_h = $this->getCellHeight($parent['fontsize'] / $this->k);
			} else {
				$pre_h = $this->getCellHeight($this->FontSize);
			}
			if (isset($this->tagvspaces[$tag['value']][1]['n'])) {
				$cn = $this->tagvspaces[$tag['value']][1]['n'];
			} elseif (preg_match('/[h][0-9]/', $tag['value']) > 0) {
				$cn = 0.6;
			} else {
				$cn = 1;
			}
			if ((!isset($this->tagvspaces[$tag['value']])) AND ($tag['value'] == 'div')) {
				$hb = 0;
			} else {
				$hb = ($cn * $pre_h);
			}
			if ($maxbottomliney > $this->PageBreakTrigger) {
				$hbz = $this->getCellHeight($this->FontSize);
			} elseif ($this->y < $maxbottomliney) {
				$hbz = ($maxbottomliney - $this->y);
			}
		}
		// Closing tag
		switch($tag['value']) {
			case 'tr': {
				$table_el = $dom[($dom[$key]['parent'])]['parent'];
				if (!isset($parent['endy'])) {
					$dom[($dom[$key]['parent'])]['endy'] = $this->y;
					$parent['endy'] = $this->y;
				}
				if (!isset($parent['endpage'])) {
					$dom[($dom[$key]['parent'])]['endpage'] = $this->page;
					$parent['endpage'] = $this->page;
				}
				if (!isset($parent['endcolumn'])) {
					$dom[($dom[$key]['parent'])]['endcolumn'] = $this->current_column;
					$parent['endcolumn'] = $this->current_column;
				}
				// update row-spanned cells
				if (isset($dom[$table_el]['rowspans'])) {
					foreach ($dom[$table_el]['rowspans'] as $k => $trwsp) {
						$dom[$table_el]['rowspans'][$k]['rowspan'] -= 1;
						if ($dom[$table_el]['rowspans'][$k]['rowspan'] == 0) {
							if (($dom[$table_el]['rowspans'][$k]['endpage'] == $parent['endpage']) AND ($dom[$table_el]['rowspans'][$k]['endcolumn'] == $parent['endcolumn'])) {
								$dom[($dom[$key]['parent'])]['endy'] = max($dom[$table_el]['rowspans'][$k]['endy'], $parent['endy']);
							} elseif (($dom[$table_el]['rowspans'][$k]['endpage'] > $parent['endpage']) OR ($dom[$table_el]['rowspans'][$k]['endcolumn'] > $parent['endcolumn'])) {
								$dom[($dom[$key]['parent'])]['endy'] = $dom[$table_el]['rowspans'][$k]['endy'];
								$dom[($dom[$key]['parent'])]['endpage'] = $dom[$table_el]['rowspans'][$k]['endpage'];
								$dom[($dom[$key]['parent'])]['endcolumn'] = $dom[$table_el]['rowspans'][$k]['endcolumn'];
							}
						}
					}
					// report new endy and endpage to the rowspanned cells
					foreach ($dom[$table_el]['rowspans'] as $k => $trwsp) {
						if ($dom[$table_el]['rowspans'][$k]['rowspan'] == 0) {
							$dom[$table_el]['rowspans'][$k]['endpage'] = max($dom[$table_el]['rowspans'][$k]['endpage'], $dom[($dom[$key]['parent'])]['endpage']);
							$dom[($dom[$key]['parent'])]['endpage'] = $dom[$table_el]['rowspans'][$k]['endpage'];
							$dom[$table_el]['rowspans'][$k]['endcolumn'] = max($dom[$table_el]['rowspans'][$k]['endcolumn'], $dom[($dom[$key]['parent'])]['endcolumn']);
							$dom[($dom[$key]['parent'])]['endcolumn'] = $dom[$table_el]['rowspans'][$k]['endcolumn'];
							$dom[$table_el]['rowspans'][$k]['endy'] = max($dom[$table_el]['rowspans'][$k]['endy'], $dom[($dom[$key]['parent'])]['endy']);
							$dom[($dom[$key]['parent'])]['endy'] = $dom[$table_el]['rowspans'][$k]['endy'];
						}
					}
					// update remaining rowspanned cells
					foreach ($dom[$table_el]['rowspans'] as $k => $trwsp) {
						if ($dom[$table_el]['rowspans'][$k]['rowspan'] == 0) {
							$dom[$table_el]['rowspans'][$k]['endpage'] = $dom[($dom[$key]['parent'])]['endpage'];
							$dom[$table_el]['rowspans'][$k]['endcolumn'] = $dom[($dom[$key]['parent'])]['endcolumn'];
							$dom[$table_el]['rowspans'][$k]['endy'] = $dom[($dom[$key]['parent'])]['endy'];
						}
					}
				}
				$prev_page = $this->page;
				$this->setPage($dom[($dom[$key]['parent'])]['endpage']);
				if ($this->num_columns > 1) {
					if (($prev_page < $this->page)
						AND ((($this->current_column == 0) AND ($dom[($dom[$key]['parent'])]['endcolumn'] == ($this->num_columns - 1)))
							OR ($this->current_column == $dom[($dom[$key]['parent'])]['endcolumn']))) {
						// page jump
						$this->selectColumn(0);
						$dom[($dom[$key]['parent'])]['endcolumn'] = 0;
						$dom[($dom[$key]['parent'])]['endy'] = $this->y;
					} else {
						$this->selectColumn($dom[($dom[$key]['parent'])]['endcolumn']);
						$this->y = $dom[($dom[$key]['parent'])]['endy'];
					}
				} else {
					$this->y = $dom[($dom[$key]['parent'])]['endy'];
				}
				if (isset($dom[$table_el]['attribute']['cellspacing'])) {
					$this->y += $this->getHTMLUnitToUnits($dom[$table_el]['attribute']['cellspacing'], 1, 'px');
				} elseif (isset($dom[$table_el]['border-spacing'])) {
					$this->y += $dom[$table_el]['border-spacing']['V'];
				}
				$this->Ln(0, $cell);
				if ($this->current_column == $parent['startcolumn']) {
					$this->x = $parent['startx'];
				}
				// account for booklet mode
				if ($this->page > $parent['startpage']) {
					if (($this->rtl) AND ($this->pagedim[$this->page]['orm'] != $this->pagedim[$parent['startpage']]['orm'])) {
						$this->x -= ($this->pagedim[$this->page]['orm'] - $this->pagedim[$parent['startpage']]['orm']);
					} elseif ((!$this->rtl) AND ($this->pagedim[$this->page]['olm'] != $this->pagedim[$parent['startpage']]['olm'])) {
						$this->x += ($this->pagedim[$this->page]['olm'] - $this->pagedim[$parent['startpage']]['olm']);
					}
				}
				break;
			}
			case 'tablehead':
				// closing tag used for the thead part
				$in_table_head = true;
				$this->inthead = false;
			case 'table': {
				$table_el = $parent;
				// set default border
				if (isset($table_el['attribute']['border']) AND ($table_el['attribute']['border'] > 0)) {
					// set default border
					$border = array('LTRB' => array('width' => $this->getCSSBorderWidth($table_el['attribute']['border']), 'cap'=>'square', 'join'=>'miter', 'dash'=> 0, 'color'=>array(0,0,0)));
				} else {
					$border = 0;
				}
				$default_border = $border;
				// fix bottom line alignment of last line before page break
				foreach ($dom[($dom[$key]['parent'])]['trids'] as $j => $trkey) {
					// update row-spanned cells
					if (isset($dom[($dom[$key]['parent'])]['rowspans'])) {
						foreach ($dom[($dom[$key]['parent'])]['rowspans'] as $k => $trwsp) {
							if (isset($prevtrkey) AND ($trwsp['trid'] == $prevtrkey) AND ($trwsp['mrowspan'] > 0)) {
								$dom[($dom[$key]['parent'])]['rowspans'][$k]['trid'] = $trkey;
							}
							if ($dom[($dom[$key]['parent'])]['rowspans'][$k]['trid'] == $trkey) {
								$dom[($dom[$key]['parent'])]['rowspans'][$k]['mrowspan'] -= 1;
							}
						}
					}
					if (isset($prevtrkey) AND ($dom[$trkey]['startpage'] > $dom[$prevtrkey]['endpage'])) {
						$pgendy = $this->pagedim[$dom[$prevtrkey]['endpage']]['hk'] - $this->pagedim[$dom[$prevtrkey]['endpage']]['bm'];
						$dom[$prevtrkey]['endy'] = $pgendy;
						// update row-spanned cells
						if (isset($dom[($dom[$key]['parent'])]['rowspans'])) {
							foreach ($dom[($dom[$key]['parent'])]['rowspans'] as $k => $trwsp) {
								if (($trwsp['trid'] == $prevtrkey) AND ($trwsp['mrowspan'] >= 0) AND ($trwsp['endpage'] == $dom[$prevtrkey]['endpage'])) {
									$dom[($dom[$key]['parent'])]['rowspans'][$k]['endy'] = $pgendy;
									$dom[($dom[$key]['parent'])]['rowspans'][$k]['mrowspan'] = -1;
								}
							}
						}
					}
					$prevtrkey = $trkey;
					$table_el = $dom[($dom[$key]['parent'])];
				}
				// for each row
				if (!empty($table_el['trids'])) {
					unset($xmax);
				}
				foreach ($table_el['trids'] as $j => $trkey) {
					$parent = $dom[$trkey];
					if (!isset($xmax)) {
						$xmax = $parent['cellpos'][(count($parent['cellpos']) - 1)]['endx'];
					}
					// for each cell on the row
					foreach ($parent['cellpos'] as $k => $cellpos) {
						if (isset($cellpos['rowspanid']) AND ($cellpos['rowspanid'] >= 0)) {
							$cellpos['startx'] = $table_el['rowspans'][($cellpos['rowspanid'])]['startx'];
							$cellpos['endx'] = $table_el['rowspans'][($cellpos['rowspanid'])]['endx'];
							$endy = $table_el['rowspans'][($cellpos['rowspanid'])]['endy'];
							$startpage = $table_el['rowspans'][($cellpos['rowspanid'])]['startpage'];
							$endpage = $table_el['rowspans'][($cellpos['rowspanid'])]['endpage'];
							$startcolumn = $table_el['rowspans'][($cellpos['rowspanid'])]['startcolumn'];
							$endcolumn = $table_el['rowspans'][($cellpos['rowspanid'])]['endcolumn'];
						} else {
							$endy = $parent['endy'];
							$startpage = $parent['startpage'];
							$endpage = $parent['endpage'];
							$startcolumn = $parent['startcolumn'];
							$endcolumn = $parent['endcolumn'];
						}
						if ($this->num_columns == 0) {
							$this->num_columns = 1;
						}
						if (isset($cellpos['border'])) {
							$border = $cellpos['border'];
						}
						if (isset($cellpos['bgcolor']) AND ($cellpos['bgcolor']) !== false) {
							$this->setFillColorArray($cellpos['bgcolor']);
							$fill = true;
						} else {
							$fill = false;
						}
						$x = $cellpos['startx'];
						$y = $parent['starty'];
						$starty = $y;
						$w = abs($cellpos['endx'] - $cellpos['startx']);
						// get border modes
						$border_start = TCPDF_STATIC::getBorderMode($border, $position='start', $this->opencell);
						$border_end = TCPDF_STATIC::getBorderMode($border, $position='end', $this->opencell);
						$border_middle = TCPDF_STATIC::getBorderMode($border, $position='middle', $this->opencell);
						// design borders around HTML cells.
						for ($page = $startpage; $page <= $endpage; ++$page) { // for each page
							$ccode = '';
							$this->setPage($page);
							if ($this->num_columns < 2) {
								// single-column mode
								$this->x = $x;
								$this->y = $this->tMargin;
							}
							// account for margin changes
							if ($page > $startpage) {
								if (($this->rtl) AND ($this->pagedim[$page]['orm'] != $this->pagedim[$startpage]['orm'])) {
									$this->x -= ($this->pagedim[$page]['orm'] - $this->pagedim[$startpage]['orm']);
								} elseif ((!$this->rtl) AND ($this->pagedim[$page]['olm'] != $this->pagedim[$startpage]['olm'])) {
									$this->x += ($this->pagedim[$page]['olm'] - $this->pagedim[$startpage]['olm']);
								}
							}
							if ($startpage == $endpage) { // single page
								$deltacol = 0;
								$deltath = 0;
								for ($column = $startcolumn; $column <= $endcolumn; ++$column) { // for each column
									$this->selectColumn($column);
									if ($startcolumn == $endcolumn) { // single column
										$cborder = $border;
										$h = $endy - $parent['starty'];
										$this->y = $y;
										$this->x = $x;
									} elseif ($column == $startcolumn) { // first column
										$cborder = $border_start;
										$this->y = $starty;
										$this->x = $x;
										$h = $this->h - $this->y - $this->bMargin;
										if ($this->rtl) {
											$deltacol = $this->x + $this->rMargin - $this->w;
										} else {
											$deltacol = $this->x - $this->lMargin;
										}
									} elseif ($column == $endcolumn) { // end column
										$cborder = $border_end;
										if (isset($this->columns[$column]['th']['\''.$page.'\''])) {
											$this->y = $this->columns[$column]['th']['\''.$page.'\''];
										}
										$this->x += $deltacol;
										$h = $endy - $this->y;
									} else { // middle column
										$cborder = $border_middle;
										if (isset($this->columns[$column]['th']['\''.$page.'\''])) {
											$this->y = $this->columns[$column]['th']['\''.$page.'\''];
										}
										$this->x += $deltacol;
										$h = $this->h - $this->y - $this->bMargin;
									}
									$ccode .= $this->getCellCode($w, $h, '', $cborder, 1, '', $fill, '', 0, true).""\n"";
								} // end for each column
							} elseif ($page == $startpage) { // first page
								$deltacol = 0;
								$deltath = 0;
								for ($column = $startcolumn; $column < $this->num_columns; ++$column) { // for each column
									$this->selectColumn($column);
									if ($column == $startcolumn) { // first column
										$cborder = $border_start;
										$this->y = $starty;
										$this->x = $x;
										$h = $this->h - $this->y - $this->bMargin;
										if ($this->rtl) {
											$deltacol = $this->x + $this->rMargin - $this->w;
										} else {
											$deltacol = $this->x - $this->lMargin;
										}
									} else { // middle column
										$cborder = $border_middle;
										if (isset($this->columns[$column]['th']['\''.$page.'\''])) {
											$this->y = $this->columns[$column]['th']['\''.$page.'\''];
										}
										$this->x += $deltacol;
										$h = $this->h - $this->y - $this->bMargin;
									}
									$ccode .= $this->getCellCode($w, $h, '', $cborder, 1, '', $fill, '', 0, true).""\n"";
								} // end for each column
							} elseif ($page == $endpage) { // last page
								$deltacol = 0;
								$deltath = 0;
								for ($column = 0; $column <= $endcolumn; ++$column) { // for each column
									$this->selectColumn($column);
									if ($column == $endcolumn) { // end column
										$cborder = $border_end;
										if (isset($this->columns[$column]['th']['\''.$page.'\''])) {
											$this->y = $this->columns[$column]['th']['\''.$page.'\''];
										}
										$this->x += $deltacol;
										$h = $endy - $this->y;
									} else { // middle column
										$cborder = $border_middle;
										if (isset($this->columns[$column]['th']['\''.$page.'\''])) {
											$this->y = $this->columns[$column]['th']['\''.$page.'\''];
										}
										$this->x += $deltacol;
										$h = $this->h - $this->y - $this->bMargin;
									}
									$ccode .= $this->getCellCode($w, $h, '', $cborder, 1, '', $fill, '', 0, true).""\n"";
								} // end for each column
							} else { // middle page
								$deltacol = 0;
								$deltath = 0;
								for ($column = 0; $column < $this->num_columns; ++$column) { // for each column
									$this->selectColumn($column);
									$cborder = $border_middle;
									if (isset($this->columns[$column]['th']['\''.$page.'\''])) {
										$this->y = $this->columns[$column]['th']['\''.$page.'\''];
									}
									$this->x += $deltacol;
									$h = $this->h - $this->y - $this->bMargin;
									$ccode .= $this->getCellCode($w, $h, '', $cborder, 1, '', $fill, '', 0, true).""\n"";
								} // end for each column
							}
							if (!empty($cborder) OR !empty($fill)) {
								$offsetlen = strlen($ccode);
								// draw border and fill
								if ($this->inxobj) {
									// we are inside an XObject template
									if (end($this->xobjects[$this->xobjid]['transfmrk']) !== false) {
										$pagemarkkey = key($this->xobjects[$this->xobjid]['transfmrk']);
										$pagemark = $this->xobjects[$this->xobjid]['transfmrk'][$pagemarkkey];
										$this->xobjects[$this->xobjid]['transfmrk'][$pagemarkkey] += $offsetlen;
									} else {
										$pagemark = $this->xobjects[$this->xobjid]['intmrk'];
										$this->xobjects[$this->xobjid]['intmrk'] += $offsetlen;
									}
									$pagebuff = $this->xobjects[$this->xobjid]['outdata'];
									$pstart = substr($pagebuff, 0, $pagemark);
									$pend = substr($pagebuff, $pagemark);
									$this->xobjects[$this->xobjid]['outdata'] = $pstart.$ccode.$pend;
								} else {
									// draw border and fill
									if (end($this->transfmrk[$this->page]) !== false) {
										$pagemarkkey = key($this->transfmrk[$this->page]);
										$pagemark = $this->transfmrk[$this->page][$pagemarkkey];
									} elseif ($this->InFooter) {
										$pagemark = $this->footerpos[$this->page];
									} else {
										$pagemark = $this->intmrk[$this->page];
									}
									$pagebuff = $this->getPageBuffer($this->page);
									$pstart = substr($pagebuff, 0, $pagemark);
									$pend = substr($pagebuff, $pagemark);
									$this->setPageBuffer($this->page, $pstart.$ccode.$pend);
								}
							}
						} // end for each page
						// restore default border
						$border = $default_border;
					} // end for each cell on the row
					if (isset($table_el['attribute']['cellspacing'])) {
						$this->y += $this->getHTMLUnitToUnits($table_el['attribute']['cellspacing'], 1, 'px');
					} elseif (isset($table_el['border-spacing'])) {
						$this->y += $table_el['border-spacing']['V'];
					}
					$this->Ln(0, $cell);
					$this->x = $parent['startx'];
					if ($endpage > $startpage) {
						if (($this->rtl) AND ($this->pagedim[$endpage]['orm'] != $this->pagedim[$startpage]['orm'])) {
							$this->x += ($this->pagedim[$endpage]['orm'] - $this->pagedim[$startpage]['orm']);
						} elseif ((!$this->rtl) AND ($this->pagedim[$endpage]['olm'] != $this->pagedim[$startpage]['olm'])) {
							$this->x += ($this->pagedim[$endpage]['olm'] - $this->pagedim[$startpage]['olm']);
						}
					}
				}
				if (!$in_table_head) { // we are not inside a thead section
					$this->cell_padding = isset($table_el['old_cell_padding']) ? $table_el['old_cell_padding'] : null;
					// reset row height
					$this->resetLastH();
					if (($this->page == ($this->numpages - 1)) AND ($this->pageopen[$this->numpages])) {
						$plendiff = ($this->pagelen[$this->numpages] - $this->emptypagemrk[$this->numpages]);
						if (($plendiff > 0) AND ($plendiff < 60)) {
							$pagediff = substr($this->getPageBuffer($this->numpages), $this->emptypagemrk[$this->numpages], $plendiff);
							if (substr($pagediff, 0, 5) == 'BT /F') {
								// the difference is only a font setting
								$plendiff = 0;
							}
						}
						if ($plendiff == 0) {
							// remove last blank page
							$this->deletePage($this->numpages);
						}
					}
					if (isset($this->theadMargins['top'])) {
						// restore top margin
						$this->tMargin = $this->theadMargins['top'];
					}
					if (!isset($table_el['attribute']['nested']) OR ($table_el['attribute']['nested'] != 'true')) {
						// reset main table header
						$this->thead = '';
						$this->theadMargins = array();
						$this->pagedim[$this->page]['tm'] = $this->tMargin;
					}
				}
				$parent = $table_el;
				break;
			}
			case 'a': {
				$this->HREF = array();
				break;
			}
			case 'sup': {
				$this->setXY($this->GetX(), $this->GetY() + ((0.7 * $parent['fontsize']) / $this->k));
				break;
			}
			case 'sub': {
				$this->setXY($this->GetX(), $this->GetY() - ((0.3 * $parent['fontsize']) / $this->k));
				break;
			}
			case 'div': {
				$this->addHTMLVertSpace($hbz, $hb, $cell, false, $lasttag);
				break;
			}
			case 'blockquote': {
				if ($this->rtl) {
					$this->rMargin -= $this->listindent;
				} else {
					$this->lMargin -= $this->listindent;
				}
				--$this->listindentlevel;
				$this->addHTMLVertSpace($hbz, $hb, $cell, false, $lasttag);
				break;
			}
			case 'p': {
				$this->addHTMLVertSpace($hbz, $hb, $cell, false, $lasttag);
				break;
			}
			case 'pre': {
				$this->addHTMLVertSpace($hbz, $hb, $cell, false, $lasttag);
				$this->premode = false;
				break;
			}
			case 'dl': {
				--$this->listnum;
				if ($this->listnum <= 0) {
					$this->listnum = 0;
					$this->addHTMLVertSpace($hbz, $hb, $cell, false, $lasttag);
				} else {
					$this->addHTMLVertSpace(0, 0, $cell, false, $lasttag);
				}
				$this->resetLastH();
				break;
			}
			case 'dt': {
				$this->lispacer = '';
				$this->addHTMLVertSpace(0, 0, $cell, false, $lasttag);
				break;
			}
			case 'dd': {
				$this->lispacer = '';
				if ($this->rtl) {
					$this->rMargin -= $this->listindent;
				} else {
					$this->lMargin -= $this->listindent;
				}
				--$this->listindentlevel;
				$this->addHTMLVertSpace(0, 0, $cell, false, $lasttag);
				break;
			}
			case 'ul':
			case 'ol': {
				--$this->listnum;
				$this->lispacer = '';
				if ($this->rtl) {
					$this->rMargin -= $this->listindent;
				} else {
					$this->lMargin -= $this->listindent;
				}
				--$this->listindentlevel;
				if ($this->listnum <= 0) {
					$this->listnum = 0;
					$this->addHTMLVertSpace($hbz, $hb, $cell, false, $lasttag);
				} else {
					$this->addHTMLVertSpace(0, 0, $cell, false, $lasttag);
				}
				$this->resetLastH();
				break;
			}
			case 'li': {
				$this->lispacer = '';
				$this->addHTMLVertSpace(0, 0, $cell, false, $lasttag);
				break;
			}
			case 'h1':
			case 'h2':
			case 'h3':
			case 'h4':
			case 'h5':
			case 'h6': {
				$this->addHTMLVertSpace($hbz, $hb, $cell, false, $lasttag);
				break;
			}
			// Form fields (since 4.8.000 - 2009-09-07)
			case 'form': {
				$this->form_action = '';
				$this->form_enctype = 'application/x-www-form-urlencoded';
				break;
			}
			default : {
				break;
			}
		}
		// draw border and background (if any)
		$this->drawHTMLTagBorder($parent, $xmax);
		if (isset($dom[($dom[$key]['parent'])]['attribute']['pagebreakafter'])) {
			$pba = $dom[($dom[$key]['parent'])]['attribute']['pagebreakafter'];
			// check for pagebreak
			if (($pba == 'true') OR ($pba == 'left') OR ($pba == 'right')) {
				// add a page (or trig AcceptPageBreak() for multicolumn mode)
				$this->checkPageBreak($this->PageBreakTrigger + 1);
			}
			if ((($pba == 'left') AND (((!$this->rtl) AND (($this->page % 2) == 0)) OR (($this->rtl) AND (($this->page % 2) != 0))))
				OR (($pba == 'right') AND (((!$this->rtl) AND (($this->page % 2) != 0)) OR (($this->rtl) AND (($this->page % 2) == 0))))) {
				// add a page (or trig AcceptPageBreak() for multicolumn mode)
				$this->checkPageBreak($this->PageBreakTrigger + 1);
			}
		}
		$this->tmprtl = false;
		return $dom;
	}

	/**
	 * Add vertical spaces if needed.
	 * @param string $hbz Distance between current y and line bottom.
	 * @param string $hb The height of the break.
	 * @param boolean $cell if true add the default left (or right if RTL) padding to each new line (default false).
	 * @param boolean $firsttag set to true when the tag is the first.
	 * @param boolean $lasttag set to true when the tag is the last.
	 * @protected
	 */
	protected function addHTMLVertSpace($hbz=0, $hb=0, $cell=false, $firsttag=false, $lasttag=false) {
		if ($firsttag) {
			$this->Ln(0, $cell);
			$this->htmlvspace = 0;
			return;
		}
		if ($lasttag) {
			$this->Ln($hbz, $cell);
			$this->htmlvspace = 0;
			return;
		}
		if ($hb < $this->htmlvspace) {
			$hd = 0;
		} else {
			$hd = $hb - $this->htmlvspace;
			$this->htmlvspace = $hb;
		}
		$this->Ln(($hbz + $hd), $cell);
	}

	/**
	 * Return the starting coordinates to draw an html border
	 * @return array containing top-left border coordinates
	 * @protected
	 * @since 5.7.000 (2010-08-03)
	 */
	protected function getBorderStartPosition() {
		if ($this->rtl) {
			$xmax = $this->lMargin;
		} else {
			$xmax = $this->w - $this->rMargin;
		}
		return array('page' => $this->page, 'column' => $this->current_column, 'x' => $this->x, 'y' => $this->y, 'xmax' => $xmax);
	}

	/**
	 * Draw an HTML block border and fill
	 * @param array $tag array of tag properties.
	 * @param int $xmax end X coordinate for border.
	 * @protected
	 * @since 5.7.000 (2010-08-03)
	 */
	protected function drawHTMLTagBorder($tag, $xmax) {
		if (!isset($tag['borderposition'])) {
			// nothing to draw
			return;
		}
		$prev_x = $this->x;
		$prev_y = $this->y;
		$prev_lasth = $this->lasth;
		$border = 0;
		$fill = false;
		$this->lasth = 0;
		if (isset($tag['border']) AND !empty($tag['border'])) {
			// get border style
			$border = $tag['border'];
			if (!TCPDF_STATIC::empty_string($this->thead) AND (!$this->inthead)) {
				// border for table header
				$border = TCPDF_STATIC::getBorderMode($border, $position='middle', $this->opencell);
			}
		}
		if (isset($tag['bgcolor']) AND ($tag['bgcolor'] !== false)) {
			// get background color
			$old_bgcolor = $this->bgcolor;
			$this->setFillColorArray($tag['bgcolor']);
			$fill = true;
		}
		if (!$border AND !$fill) {
			// nothing to draw
			return;
		}
		if (isset($tag['attribute']['cellspacing'])) {
			$clsp = $this->getHTMLUnitToUnits($tag['attribute']['cellspacing'], 1, 'px');
			$cellspacing = array('H' => $clsp, 'V' => $clsp);
		} elseif (isset($tag['border-spacing'])) {
			$cellspacing = $tag['border-spacing'];
		} else {
			$cellspacing = array('H' => 0, 'V' => 0);
		}
		if (($tag['value'] != 'table') AND (is_array($border)) AND (!empty($border))) {
			// draw the border externally respect the sqare edge.
			$border['mode'] = 'ext';
		}
		if ($this->rtl) {
			if ($xmax >= $tag['borderposition']['x']) {
				$xmax = $tag['borderposition']['xmax'];
			}
			$w = ($tag['borderposition']['x'] - $xmax);
		} else {
			if ($xmax <= $tag['borderposition']['x']) {
				$xmax = $tag['borderposition']['xmax'];
			}
			$w = ($xmax - $tag['borderposition']['x']);
		}
		if ($w <= 0) {
			return;
		}
		$w += $cellspacing['H'];
		$startpage = $tag['borderposition']['page'];
		$startcolumn = $tag['borderposition']['column'];
		$x = $tag['borderposition']['x'];
		$y = $tag['borderposition']['y'];
		$endpage = $this->page;
		$starty = $tag['borderposition']['y'] - $cellspacing['V'];
		$currentY = $this->y;
		$this->x = $x;
		// get latest column
		$endcolumn = $this->current_column;
		if ($this->num_columns == 0) {
			$this->num_columns = 1;
		}
		// get border modes
		$border_start = TCPDF_STATIC::getBorderMode($border, $position='start', $this->opencell);
		$border_end = TCPDF_STATIC::getBorderMode($border, $position='end', $this->opencell);
		$border_middle = TCPDF_STATIC::getBorderMode($border, $position='middle', $this->opencell);
		// temporary disable page regions
		$temp_page_regions = $this->page_regions;
		$this->page_regions = array();
		// design borders around HTML cells.
		for ($page = $startpage; $page <= $endpage; ++$page) { // for each page
			$ccode = '';
			$this->setPage($page);
			if ($this->num_columns < 2) {
				// single-column mode
				$this->x = $x;
				$this->y = $this->tMargin;
			}
			// account for margin changes
			if ($page > $startpage) {
				if (($this->rtl) AND ($this->pagedim[$page]['orm'] != $this->pagedim[$startpage]['orm'])) {
					$this->x -= ($this->pagedim[$page]['orm'] - $this->pagedim[$startpage]['orm']);
				} elseif ((!$this->rtl) AND ($this->pagedim[$page]['olm'] != $this->pagedim[$startpage]['olm'])) {
					$this->x += ($this->pagedim[$page]['olm'] - $this->pagedim[$startpage]['olm']);
				}
			}
			if ($startpage == $endpage) {
				// single page
				for ($column = $startcolumn; $column <= $endcolumn; ++$column) { // for each column
					$this->selectColumn($column);
					if ($startcolumn == $endcolumn) { // single column
						$cborder = $border;
						$h = ($currentY - $y) + $cellspacing['V'];
						$this->y = $starty;
					} elseif ($column == $startcolumn) { // first column
						$cborder = $border_start;
						$this->y = $starty;
						$h = $this->h - $this->y - $this->bMargin;
					} elseif ($column == $endcolumn) { // end column
						$cborder = $border_end;
						$h = $currentY - $this->y;
					} else { // middle column
						$cborder = $border_middle;
						$h = $this->h - $this->y - $this->bMargin;
					}
					$ccode .= $this->getCellCode($w, $h, '', $cborder, 1, '', $fill, '', 0, true).""\n"";
				} // end for each column
			} elseif ($page == $startpage) { // first page
				for ($column = $startcolumn; $column < $this->num_columns; ++$column) { // for each column
					$this->selectColumn($column);
					if ($column == $startcolumn) { // first column
						$cborder = $border_start;
						$this->y = $starty;
						$h = $this->h - $this->y - $this->bMargin;
					} else { // middle column
						$cborder = $border_middle;
						$h = $this->h - $this->y - $this->bMargin;
					}
					$ccode .= $this->getCellCode($w, $h, '', $cborder, 1, '', $fill, '', 0, true).""\n"";
				} // end for each column
			} elseif ($page == $endpage) { // last page
				for ($column = 0; $column <= $endcolumn; ++$column) { // for each column
					$this->selectColumn($column);
					if ($column == $endcolumn) {
						// end column
						$cborder = $border_end;
						$h = $currentY - $this->y;
					} else {
						// middle column
						$cborder = $border_middle;
						$h = $this->h - $this->y - $this->bMargin;
					}
					$ccode .= $this->getCellCode($w, $h, '', $cborder, 1, '', $fill, '', 0, true).""\n"";
				} // end for each column
			} else { // middle page
				for ($column = 0; $column < $this->num_columns; ++$column) { // for each column
					$this->selectColumn($column);
					$cborder = $border_middle;
					$h = $this->h - $this->y - $this->bMargin;
					$ccode .= $this->getCellCode($w, $h, '', $cborder, 1, '', $fill, '', 0, true).""\n"";
				} // end for each column
			}
			if ($cborder OR $fill) {
				$offsetlen = strlen($ccode);
				// draw border and fill
				if ($this->inxobj) {
					// we are inside an XObject template
					if (end($this->xobjects[$this->xobjid]['transfmrk']) !== false) {
						$pagemarkkey = key($this->xobjects[$this->xobjid]['transfmrk']);
						$pagemark = $this->xobjects[$this->xobjid]['transfmrk'][$pagemarkkey];
						$this->xobjects[$this->xobjid]['transfmrk'][$pagemarkkey] += $offsetlen;
					} else {
						$pagemark = $this->xobjects[$this->xobjid]['intmrk'];
						$this->xobjects[$this->xobjid]['intmrk'] += $offsetlen;
					}
					$pagebuff = $this->xobjects[$this->xobjid]['outdata'];
					$pstart = substr($pagebuff, 0, $pagemark);
					$pend = substr($pagebuff, $pagemark);
					$this->xobjects[$this->xobjid]['outdata'] = $pstart.$ccode.$pend;
				} else {
					if (end($this->transfmrk[$this->page]) !== false) {
						$pagemarkkey = key($this->transfmrk[$this->page]);
						$pagemark = $this->transfmrk[$this->page][$pagemarkkey];
					} elseif ($this->InFooter) {
						$pagemark = $this->footerpos[$this->page];
					} else {
						$pagemark = $this->intmrk[$this->page];
					}
					$pagebuff = $this->getPageBuffer($this->page);
					$pstart = substr($pagebuff, 0, $pagemark);
					$pend = substr($pagebuff, $pagemark);
					$this->setPageBuffer($this->page, $pstart.$ccode.$pend);
					$this->bordermrk[$this->page] += $offsetlen;
					$this->cntmrk[$this->page] += $offsetlen;
				}
			}
		} // end for each page
		// restore page regions
		$this->page_regions = $temp_page_regions;
		if (isset($old_bgcolor)) {
			// restore background color
			$this->setFillColorArray($old_bgcolor);
		}
		// restore pointer position
		$this->x = $prev_x;
		$this->y = $prev_y;
		$this->lasth = $prev_lasth;
	}

	/**
	 * Set the default bullet to be used as LI bullet symbol
	 * @param string $symbol character or string to be used (legal values are: '' = automatic, '!' = auto bullet, '#' = auto numbering, 'disc', 'disc', 'circle', 'square', '1', 'decimal', 'decimal-leading-zero', 'i', 'lower-roman', 'I', 'upper-roman', 'a', 'lower-alpha', 'lower-latin', 'A', 'upper-alpha', 'upper-latin', 'lower-greek', 'img|type|width|height|image.ext')
	 * @public
	 * @since 4.0.028 (2008-09-26)
	 */
	public function setLIsymbol($symbol='!') {
		// check for custom image symbol
		if (substr($symbol, 0, 4) == 'img|') {
			$this->lisymbol = $symbol;
			return;
		}
		$symbol = strtolower($symbol);
		$valid_symbols = array('!', '#', 'disc', 'circle', 'square', '1', 'decimal', 'decimal-leading-zero', 'i', 'lower-roman', 'I', 'upper-roman', 'a', 'lower-alpha', 'lower-latin', 'A', 'upper-alpha', 'upper-latin', 'lower-greek');
		if (in_array($symbol, $valid_symbols)) {
			$this->lisymbol = $symbol;
		} else {
			$this->lisymbol = '';
		}
	}

	/**
	 * Set the booklet mode for double-sided pages.
	 * @param boolean $booklet true set the booklet mode on, false otherwise.
	 * @param float $inner Inner page margin.
	 * @param float $outer Outer page margin.
	 * @public
	 * @since 4.2.000 (2008-10-29)
	 */
	public function setBooklet($booklet=true, $inner=-1, $outer=-1) {
		$this->booklet = $booklet;
		if ($inner >= 0) {
			$this->lMargin = $inner;
		}
		if ($outer >= 0) {
			$this->rMargin = $outer;
		}
	}

	/**
	 * Swap the left and right margins.
	 * @param boolean $reverse if true swap left and right margins.
	 * @protected
	 * @since 4.2.000 (2008-10-29)
	 */
	protected function swapMargins($reverse=true) {
		if ($reverse) {
			// swap left and right margins
			$mtemp = $this->original_lMargin;
			$this->original_lMargin = $this->original_rMargin;
			$this->original_rMargin = $mtemp;
			$deltam = $this->original_lMargin - $this->original_rMargin;
			$this->lMargin += $deltam;
			$this->rMargin -= $deltam;
		}
	}

	/**
	 * Set the vertical spaces for HTML tags.
	 * The array must have the following structure (example):
	 * $tagvs = array('h1' => array(0 => array('h' => '', 'n' => 2), 1 => array('h' => 1.3, 'n' => 1)));
	 * The first array level contains the tag names,
	 * the second level contains 0 for opening tags or 1 for closing tags,
	 * the third level contains the vertical space unit (h) and the number spaces to add (n).
	 * If the h parameter is not specified, default values are used.
	 * @param array $tagvs array of tags and relative vertical spaces.
	 * @public
	 * @since 4.2.001 (2008-10-30)
	 */
	public function setHtmlVSpace($tagvs) {
		$this->tagvspaces = $tagvs;
	}

	/**
	 * Set custom width for list indentation.
	 * @param float $width width of the indentation. Use negative value to disable it.
	 * @public
	 * @since 4.2.007 (2008-11-12)
	 */
	public function setListIndentWidth($width) {
		return $this->customlistindent = floatval($width);
	}

	/**
	 * Set the top/bottom cell sides to be open or closed when the cell cross the page.
	 * @param boolean $isopen if true keeps the top/bottom border open for the cell sides that cross the page.
	 * @public
	 * @since 4.2.010 (2008-11-14)
	 */
	public function setOpenCell($isopen) {
		$this->opencell = $isopen;
	}

	/**
	 * Set the color and font style for HTML links.
	 * @param array $color RGB array of colors
	 * @param string $fontstyle additional font styles to add
	 * @public
	 * @since 4.4.003 (2008-12-09)
	 */
	public function setHtmlLinksStyle($color=array(0,0,255), $fontstyle='U') {
		$this->htmlLinkColorArray = $color;
		$this->htmlLinkFontStyle = $fontstyle;
	}

	/**
	 * Convert HTML string containing value and unit of measure to user's units or points.
	 * @param string $htmlval String containing values and unit.
	 * @param string $refsize Reference value in points.
	 * @param string $defaultunit Default unit (can be one of the following: %, em, ex, px, in, mm, pc, pt).
	 * @param boolean $points If true returns points, otherwise returns value in user's units.
	 * @return float value in user's unit or point if $points=true
	 * @public
	 * @since 4.4.004 (2008-12-10)
	 */
	public function getHTMLUnitToUnits($htmlval, $refsize=1, $defaultunit='px', $points=false) {
		$supportedunits = array('%', 'em', 'ex', 'px', 'in', 'cm', 'mm', 'pc', 'pt');
		$retval = 0;
		$value = 0;
		$unit = 'px';
		if ($points) {
			$k = 1;
		} else {
			$k = $this->k;
		}
		if (in_array($defaultunit, $supportedunits)) {
			$unit = $defaultunit;
		}
		if (is_numeric($htmlval)) {
			$value = floatval($htmlval);
		} elseif (preg_match('/([0-9\.\-\+]+)/', $htmlval, $mnum)) {
			$value = floatval($mnum[1]);
			if (preg_match('/([a-z%]+)/', $htmlval, $munit)) {
				if (in_array($munit[1], $supportedunits)) {
					$unit = $munit[1];
				}
			}
		}
		switch ($unit) {
			// percentage
			case '%': {
				$retval = (($value * $refsize) / 100);
				break;
			}
			// relative-size
			case 'em': {
				$retval = ($value * $refsize);
				break;
			}
			// height of lower case 'x' (about half the font-size)
			case 'ex': {
				$retval = ($value * ($refsize / 2));
				break;
			}
			// absolute-size
			case 'in': {
				$retval = (($value * $this->dpi) / $k);
				break;
			}
			// centimeters
			case 'cm': {
				$retval = (($value / 2.54 * $this->dpi) / $k);
				break;
			}
			// millimeters
			case 'mm': {
				$retval = (($value / 25.4 * $this->dpi) / $k);
				break;
			}
			// one pica is 12 points
			case 'pc': {
				$retval = (($value * 12) / $k);
				break;
			}
			// points
			case 'pt': {
				$retval = ($value / $k);
				break;
			}
			// pixels
			case 'px': {
				$retval = $this->pixelsToUnits($value);
				if ($points) {
					$retval *= $this->k;
				}
				break;
			}
		}
		return $retval;
	}

	/**
	 * Output an HTML list bullet or ordered item symbol
	 * @param int $listdepth list nesting level
	 * @param string $listtype type of list
	 * @param float $size current font size
	 * @protected
	 * @since 4.4.004 (2008-12-10)
	 */
	protected function putHtmlListBullet($listdepth, $listtype='', $size=10) {
		if ($this->state != 2) {
			return;
		}
		$size /= $this->k;
		$fill = '';
		$bgcolor = $this->bgcolor;
		$color = $this->fgcolor;
		$strokecolor = $this->strokecolor;
		$width = 0;
		$textitem = '';
		$tmpx = $this->x;
		$lspace = $this->GetStringWidth('  ');
		if ($listtype == '^') {
			// special symbol used for avoid justification of rect bullet
			$this->lispacer = '';
			return;
		} elseif ($listtype == '!') {
			// set default list type for unordered list
			$deftypes = array('disc', 'circle', 'square');
			$listtype = $deftypes[($listdepth - 1) % 3];
		} elseif ($listtype == '#') {
			// set default list type for ordered list
			$listtype = 'decimal';
		} elseif (substr($listtype, 0, 4) == 'img|') {
			// custom image type ('img|type|width|height|image.ext')
			$img = explode('|', $listtype);
			$listtype = 'img';
		}
		switch ($listtype) {
			// unordered types
			case 'none': {
				break;
			}
			case 'disc': {
				$r = $size / 6;
				$lspace += (2 * $r);
				if ($this->rtl) {
					$this->x += $lspace;
				} else {
					$this->x -= $lspace;
				}
				$this->Circle(($this->x + $r), ($this->y + ($this->lasth / 2)), $r, 0, 360, 'F', array(), $color, 8);
				break;
			}
			case 'circle': {
				$r = $size / 6;
				$lspace += (2 * $r);
				if ($this->rtl) {
					$this->x += $lspace;
				} else {
					$this->x -= $lspace;
				}
				$prev_line_style = $this->linestyleWidth.' '.$this->linestyleCap.' '.$this->linestyleJoin.' '.$this->linestyleDash.' '.$this->DrawColor;
				$new_line_style = array('width' => ($r / 3), 'cap' => 'butt', 'join' => 'miter', 'dash' => 0, 'phase' => 0, 'color'=>$color);
				$this->Circle(($this->x + $r), ($this->y + ($this->lasth / 2)), ($r * (1 - (1/6))), 0, 360, 'D', $new_line_style, array(), 8);
				$this->_out($prev_line_style); // restore line settings
				break;
			}
			case 'square': {
				$l = $size / 3;
				$lspace += $l;
				if ($this->rtl) {;
					$this->x += $lspace;
				} else {
					$this->x -= $lspace;
				}
				$this->Rect($this->x, ($this->y + (($this->lasth - $l) / 2)), $l, $l, 'F', array(), $color);
				break;
			}
			case 'img': {
				// 1=>type, 2=>width, 3=>height, 4=>image.ext
				$lspace += $img[2];
				if ($this->rtl) {;
					$this->x += $lspace;
				} else {
					$this->x -= $lspace;
				}
				$imgtype = strtolower($img[1]);
				$prev_y = $this->y;
				switch ($imgtype) {
					case 'svg': {
						$this->ImageSVG($img[4], $this->x, ($this->y + (($this->lasth - $img[3]) / 2)), $img[2], $img[3], '', 'T', '', 0, false);
						break;
					}
					case 'ai':
					case 'eps': {
						$this->ImageEps($img[4], $this->x, ($this->y + (($this->lasth - $img[3]) / 2)), $img[2], $img[3], '', true, 'T', '', 0, false);
						break;
					}
					default: {
						$this->Image($img[4], $this->x, ($this->y + (($this->lasth - $img[3]) / 2)), $img[2], $img[3], $img[1], '', 'T', false, 300, '', false, false, 0, false, false, false);
						break;
					}
				}
				$this->y = $prev_y;
				break;
			}
			// ordered types
			// $this->listcount[$this->listnum];
			// $textitem
			case '1':
			case 'decimal': {
				$textitem = $this->listcount[$this->listnum];
				break;
			}
			case 'decimal-leading-zero': {
				$textitem = sprintf('%02d', $this->listcount[$this->listnum]);
				break;
			}
			case 'i':
			case 'lower-roman': {
				$textitem = strtolower(TCPDF_STATIC::intToRoman($this->listcount[$this->listnum]));
				break;
			}
			case 'I':
			case 'upper-roman': {
				$textitem = TCPDF_STATIC::intToRoman($this->listcount[$this->listnum]);
				break;
			}
			case 'a':
			case 'lower-alpha':
			case 'lower-latin': {
				$textitem = chr(97 + $this->listcount[$this->listnum] - 1);
				break;
			}
			case 'A':
			case 'upper-alpha':
			case 'upper-latin': {
				$textitem = chr(65 + $this->listcount[$this->listnum] - 1);
				break;
			}
			case 'lower-greek': {
				$textitem = TCPDF_FONTS::unichr((945 + $this->listcount[$this->listnum] - 1), $this->isunicode);
				break;
			}
			/*
			// Types to be implemented (special handling)
			case 'hebrew': {
				break;
			}
			case 'armenian': {
				break;
			}
			case 'georgian': {
				break;
			}
			case 'cjk-ideographic': {
				break;
			}
			case 'hiragana': {
				break;
			}
			case 'katakana': {
				break;
			}
			case 'hiragana-iroha': {
				break;
			}
			case 'katakana-iroha': {
				break;
			}
			*/
			default: {
				$textitem = $this->listcount[$this->listnum];
			}
		}
		if (!TCPDF_STATIC::empty_string($textitem)) {
			// Check whether we need a new page or new column
			$prev_y = $this->y;
			$h = $this->getCellHeight($this->FontSize);
			if ($this->checkPageBreak($h) OR ($this->y < $prev_y)) {
				$tmpx = $this->x;
			}
			// print ordered item
			if ($this->rtl) {
				$textitem = '.'.$textitem;
			} else {
				$textitem = $textitem.'.';
			}
			$lspace += $this->GetStringWidth($textitem);
			if ($this->rtl) {
				$this->x += $lspace;
			} else {
				$this->x -= $lspace;
			}
			$this->Write($this->lasth, $textitem, '', false, '', false, 0, false);
		}
		$this->x = $tmpx;
		$this->lispacer = '^';
		// restore colors
		$this->setFillColorArray($bgcolor);
		$this->setDrawColorArray($strokecolor);
		$this->settextColorArray($color);
	}

	/**
	 * Returns current graphic variables as array.
	 * @return array of graphic variables
	 * @protected
	 * @since 4.2.010 (2008-11-14)
	 */
	protected function getGraphicVars() {
		$grapvars = array(
			'FontFamily' => $this->FontFamily,
			'FontStyle' => $this->FontStyle,
			'FontSizePt' => $this->FontSizePt,
			'rMargin' => $this->rMargin,
			'lMargin' => $this->lMargin,
			'cell_padding' => $this->cell_padding,
			'cell_margin' => $this->cell_margin,
			'LineWidth' => $this->LineWidth,
			'linestyleWidth' => $this->linestyleWidth,
			'linestyleCap' => $this->linestyleCap,
			'linestyleJoin' => $this->linestyleJoin,
			'linestyleDash' => $this->linestyleDash,
			'textrendermode' => $this->textrendermode,
			'textstrokewidth' => $this->textstrokewidth,
			'DrawColor' => $this->DrawColor,
			'FillColor' => $this->FillColor,
			'TextColor' => $this->TextColor,
			'ColorFlag' => $this->ColorFlag,
			'bgcolor' => $this->bgcolor,
			'fgcolor' => $this->fgcolor,
			'htmlvspace' => $this->htmlvspace,
			'listindent' => $this->listindent,
			'listindentlevel' => $this->listindentlevel,
			'listnum' => $this->listnum,
			'listordered' => $this->listordered,
			'listcount' => $this->listcount,
			'lispacer' => $this->lispacer,
			'cell_height_ratio' => $this->cell_height_ratio,
			'font_stretching' => $this->font_stretching,
			'font_spacing' => $this->font_spacing,
			'alpha' => $this->alpha,
			// extended
			'lasth' => $this->lasth,
			'tMargin' => $this->tMargin,
			'bMargin' => $this->bMargin,
			'AutoPageBreak' => $this->AutoPageBreak,
			'PageBreakTrigger' => $this->PageBreakTrigger,
			'x' => $this->x,
			'y' => $this->y,
			'w' => $this->w,
			'h' => $this->h,
			'wPt' => $this->wPt,
			'hPt' => $this->hPt,
			'fwPt' => $this->fwPt,
			'fhPt' => $this->fhPt,
			'page' => $this->page,
			'current_column' => $this->current_column,
			'num_columns' => $this->num_columns
			);
		return $grapvars;
	}

	/**
	 * Set graphic variables.
	 * @param array $gvars array of graphic variablesto restore
	 * @param boolean $extended if true restore extended graphic variables
	 * @protected
	 * @since 4.2.010 (2008-11-14)
	 */
	protected function setGraphicVars($gvars, $extended=false) {
		if ($this->state != 2) {
			 return;
		}
		$this->FontFamily = $gvars['FontFamily'];
		$this->FontStyle = $gvars['FontStyle'];
		$this->FontSizePt = $gvars['FontSizePt'];
		$this->rMargin = $gvars['rMargin'];
		$this->lMargin = $gvars['lMargin'];
		$this->cell_padding = $gvars['cell_padding'];
		$this->cell_margin = $gvars['cell_margin'];
		$this->LineWidth = $gvars['LineWidth'];
		$this->linestyleWidth = $gvars['linestyleWidth'];
		$this->linestyleCap = $gvars['linestyleCap'];
		$this->linestyleJoin = $gvars['linestyleJoin'];
		$this->linestyleDash = $gvars['linestyleDash'];
		$this->textrendermode = $gvars['textrendermode'];
		$this->textstrokewidth = $gvars['textstrokewidth'];
		$this->DrawColor = $gvars['DrawColor'];
		$this->FillColor = $gvars['FillColor'];
		$this->TextColor = $gvars['TextColor'];
		$this->ColorFlag = $gvars['ColorFlag'];
		$this->bgcolor = $gvars['bgcolor'];
		$this->fgcolor = $gvars['fgcolor'];
		$this->htmlvspace = $gvars['htmlvspace'];
		$this->listindent = $gvars['listindent'];
		$this->listindentlevel = $gvars['listindentlevel'];
		$this->listnum = $gvars['listnum'];
		$this->listordered = $gvars['listordered'];
		$this->listcount = $gvars['listcount'];
		$this->lispacer = $gvars['lispacer'];
		$this->cell_height_ratio = $gvars['cell_height_ratio'];
		$this->font_stretching = $gvars['font_stretching'];
		$this->font_spacing = $gvars['font_spacing'];
		$this->alpha = $gvars['alpha'];
		if ($extended) {
			// restore extended values
			$this->lasth = $gvars['lasth'];
			$this->tMargin = $gvars['tMargin'];
			$this->bMargin = $gvars['bMargin'];
			$this->AutoPageBreak = $gvars['AutoPageBreak'];
			$this->PageBreakTrigger = $gvars['PageBreakTrigger'];
			$this->x = $gvars['x'];
			$this->y = $gvars['y'];
			$this->w = $gvars['w'];
			$this->h = $gvars['h'];
			$this->wPt = $gvars['wPt'];
			$this->hPt = $gvars['hPt'];
			$this->fwPt = $gvars['fwPt'];
			$this->fhPt = $gvars['fhPt'];
			$this->page = $gvars['page'];
			$this->current_column = $gvars['current_column'];
			$this->num_columns = $gvars['num_columns'];
		}
		$this->_out(''.$this->linestyleWidth.' '.$this->linestyleCap.' '.$this->linestyleJoin.' '.$this->linestyleDash.' '.$this->DrawColor.' '.$this->FillColor.'');
		if (!TCPDF_STATIC::empty_string($this->FontFamily)) {
			$this->setFont($this->FontFamily, $this->FontStyle, $this->FontSizePt);
		}
	}

	/**
	 * Outputs the ""save graphics state"" operator 'q'
	 * @protected
	 */
	protected function _outSaveGraphicsState() {
		$this->_out('q');
	}

	/**
	 * Outputs the ""restore graphics state"" operator 'Q'
	 * @protected
	 */
	protected function _outRestoreGraphicsState() {
		$this->_out('Q');
	}

	/**
	 * Set buffer content (always append data).
	 * @param string $data data
	 * @protected
	 * @since 4.5.000 (2009-01-02)
	 */
	protected function setBuffer($data) {
		$this->bufferlen += strlen($data);
		$this->buffer .= $data;
	}

	/**
	 * Replace the buffer content
	 * @param string $data data
	 * @protected
	 * @since 5.5.000 (2010-06-22)
	 */
	protected function replaceBuffer($data) {
		$this->bufferlen = strlen($data);
		$this->buffer = $data;
	}

	/**
	 * Get buffer content.
	 * @return string buffer content
	 * @protected
	 * @since 4.5.000 (2009-01-02)
	 */
	protected function getBuffer() {
		return $this->buffer;
	}

	/**
	 * Set page buffer content.
	 * @param int $page page number
	 * @param string $data page data
	 * @param boolean $append if true append data, false replace.
	 * @protected
	 * @since 4.5.000 (2008-12-31)
	 */
	protected function setPageBuffer($page, $data, $append=false) {
		if ($append) {
			$this->pages[$page] .= $data;
		} else {
			$this->pages[$page] = $data;
		}
		if ($append AND isset($this->pagelen[$page])) {
			$this->pagelen[$page] += strlen($data);
		} else {
			$this->pagelen[$page] = strlen($data);
		}
	}

	/**
	 * Get page buffer content.
	 * @param int $page page number
	 * @return string page buffer content or false in case of error
	 * @protected
	 * @since 4.5.000 (2008-12-31)
	 */
	protected function getPageBuffer($page) {
		if (isset($this->pages[$page])) {
			return $this->pages[$page];
		}
		return false;
	}

	/**
	 * Set image buffer content.
	 * @param string $image image key
	 * @param array $data image data
	 * @return int image index number
	 * @protected
	 * @since 4.5.000 (2008-12-31)
	 */
	protected function setImageBuffer($image, $data) {
		if (($data['i'] = array_search($image, $this->imagekeys)) === FALSE) {
			$this->imagekeys[$this->numimages] = $image;
			$data['i'] = $this->numimages;
			++$this->numimages;
		}
		$this->images[$image] = $data;
		return $data['i'];
	}

	/**
	 * Set image buffer content for a specified sub-key.
	 * @param string $image image key
	 * @param string $key image sub-key
	 * @param array $data image data
	 * @protected
	 * @since 4.5.000 (2008-12-31)
	 */
	protected function setImageSubBuffer($image, $key, $data) {
		if (!isset($this->images[$image])) {
			$this->setImageBuffer($image, array());
		}
		$this->images[$image][$key] = $data;
	}

	/**
	 * Get image buffer content.
	 * @param string $image image key
	 * @return string|false image buffer content or false in case of error
	 * @protected
	 * @since 4.5.000 (2008-12-31)
	 */
	protected function getImageBuffer($image) {
		if (isset($this->images[$image])) {
			return $this->images[$image];
		}
		return false;
	}

	/**
	 * Set font buffer content.
	 * @param string $font font key
	 * @param array $data font data
	 * @protected
	 * @since 4.5.000 (2009-01-02)
	 */
	protected function setFontBuffer($font, $data) {
		$this->fonts[$font] = $data;
		if (!in_array($font, $this->fontkeys)) {
			$this->fontkeys[] = $font;
			// store object ID for current font
			++$this->n;
			$this->font_obj_ids[$font] = $this->n;
			$this->setFontSubBuffer($font, 'n', $this->n);
		}
	}

	/**
	 * Set font buffer content.
	 * @param string $font font key
	 * @param string $key font sub-key
	 * @param mixed $data font data
	 * @protected
	 * @since 4.5.000 (2009-01-02)
	 */
	protected function setFontSubBuffer($font, $key, $data) {
		if (!isset($this->fonts[$font])) {
			$this->setFontBuffer($font, array());
		}
		$this->fonts[$font][$key] = $data;
	}

	/**
	 * Get font buffer content.
	 * @param string $font font key
	 * @return string|false font buffer content or false in case of error
	 * @protected
	 * @since 4.5.000 (2009-01-02)
	 */
	protected function getFontBuffer($font) {
		if (isset($this->fonts[$font])) {
			return $this->fonts[$font];
		}
		return false;
	}

	/**
	 * Move a page to a previous position.
	 * @param int $frompage number of the source page
	 * @param int $topage number of the destination page (must be less than $frompage)
	 * @return bool true in case of success, false in case of error.
	 * @public
	 * @since 4.5.000 (2009-01-02)
	 */
	public function movePage($frompage, $topage) {
		if (($frompage > $this->numpages) OR ($frompage <= $topage)) {
			return false;
		}
		if ($frompage == $this->page) {
			// close the page before moving it
			$this->endPage();
		}
		// move all page-related states
		$tmppage = $this->getPageBuffer($frompage);
		$tmppagedim = $this->pagedim[$frompage];
		$tmppagelen = $this->pagelen[$frompage];
		$tmpintmrk = $this->intmrk[$frompage];
		$tmpbordermrk = $this->bordermrk[$frompage];
		$tmpcntmrk = $this->cntmrk[$frompage];
		$tmppageobjects = $this->pageobjects[$frompage];
		if (isset($this->footerpos[$frompage])) {
			$tmpfooterpos = $this->footerpos[$frompage];
		}
		if (isset($this->footerlen[$frompage])) {
			$tmpfooterlen = $this->footerlen[$frompage];
		}
		if (isset($this->transfmrk[$frompage])) {
			$tmptransfmrk = $this->transfmrk[$frompage];
		}
		if (isset($this->PageAnnots[$frompage])) {
			$tmpannots = $this->PageAnnots[$frompage];
		}
		if (isset($this->newpagegroup) AND !empty($this->newpagegroup)) {
			for ($i = $frompage; $i > $topage; --$i) {
				if (isset($this->newpagegroup[$i]) AND (($i + $this->pagegroups[$this->newpagegroup[$i]]) > $frompage)) {
					--$this->pagegroups[$this->newpagegroup[$i]];
					break;
				}
			}
			for ($i = $topage; $i > 0; --$i) {
				if (isset($this->newpagegroup[$i]) AND (($i + $this->pagegroups[$this->newpagegroup[$i]]) > $topage)) {
					++$this->pagegroups[$this->newpagegroup[$i]];
					break;
				}
			}
		}
		for ($i = $frompage; $i > $topage; --$i) {
			$j = $i - 1;
			// shift pages down
			$this->setPageBuffer($i, $this->getPageBuffer($j));
			$this->pagedim[$i] = $this->pagedim[$j];
			$this->pagelen[$i] = $this->pagelen[$j];
			$this->intmrk[$i] = $this->intmrk[$j];
			$this->bordermrk[$i] = $this->bordermrk[$j];
			$this->cntmrk[$i] = $this->cntmrk[$j];
			$this->pageobjects[$i] = $this->pageobjects[$j];
			if (isset($this->footerpos[$j])) {
				$this->footerpos[$i] = $this->footerpos[$j];
			} elseif (isset($this->footerpos[$i])) {
				unset($this->footerpos[$i]);
			}
			if (isset($this->footerlen[$j])) {
				$this->footerlen[$i] = $this->footerlen[$j];
			} elseif (isset($this->footerlen[$i])) {
				unset($this->footerlen[$i]);
			}
			if (isset($this->transfmrk[$j])) {
				$this->transfmrk[$i] = $this->transfmrk[$j];
			} elseif (isset($this->transfmrk[$i])) {
				unset($this->transfmrk[$i]);
			}
			if (isset($this->PageAnnots[$j])) {
				$this->PageAnnots[$i] = $this->PageAnnots[$j];
			} elseif (isset($this->PageAnnots[$i])) {
				unset($this->PageAnnots[$i]);
			}
			if (isset($this->newpagegroup[$j])) {
				$this->newpagegroup[$i] = $this->newpagegroup[$j];
				unset($this->newpagegroup[$j]);
			}
			if ($this->currpagegroup == $j) {
				$this->currpagegroup = $i;
			}
		}
		$this->setPageBuffer($topage, $tmppage);
		$this->pagedim[$topage] = $tmppagedim;
		$this->pagelen[$topage] = $tmppagelen;
		$this->intmrk[$topage] = $tmpintmrk;
		$this->bordermrk[$topage] = $tmpbordermrk;
		$this->cntmrk[$topage] = $tmpcntmrk;
		$this->pageobjects[$topage] = $tmppageobjects;
		if (isset($tmpfooterpos)) {
			$this->footerpos[$topage] = $tmpfooterpos;
		} elseif (isset($this->footerpos[$topage])) {
			unset($this->footerpos[$topage]);
		}
		if (isset($tmpfooterlen)) {
			$this->footerlen[$topage] = $tmpfooterlen;
		} elseif (isset($this->footerlen[$topage])) {
			unset($this->footerlen[$topage]);
		}
		if (isset($tmptransfmrk)) {
			$this->transfmrk[$topage] = $tmptransfmrk;
		} elseif (isset($this->transfmrk[$topage])) {
			unset($this->transfmrk[$topage]);
		}
		if (isset($tmpannots)) {
			$this->PageAnnots[$topage] = $tmpannots;
		} elseif (isset($this->PageAnnots[$topage])) {
			unset($this->PageAnnots[$topage]);
		}
		// adjust outlines
		$tmpoutlines = $this->outlines;
		foreach ($tmpoutlines as $key => $outline) {
			if (!$outline['f']) {
				if (($outline['p'] >= $topage) AND ($outline['p'] < $frompage)) {
					$this->outlines[$key]['p'] = ($outline['p'] + 1);
				} elseif ($outline['p'] == $frompage) {
					$this->outlines[$key]['p'] = $topage;
				}
			}
		}
		// adjust dests
		$tmpdests = $this->dests;
		foreach ($tmpdests as $key => $dest) {
			if (!$dest['f']) {
				if (($dest['p'] >= $topage) AND ($dest['p'] < $frompage)) {
					$this->dests[$key]['p'] = ($dest['p'] + 1);
				} elseif ($dest['p'] == $frompage) {
					$this->dests[$key]['p'] = $topage;
				}
			}
		}
		// adjust links
		$tmplinks = $this->links;
		foreach ($tmplinks as $key => $link) {
			if (!$link['f']) {
				if (($link['p'] >= $topage) AND ($link['p'] < $frompage)) {
					$this->links[$key]['p'] = ($link['p'] + 1);
				} elseif ($link['p'] == $frompage) {
					$this->links[$key]['p'] = $topage;
				}
			}
		}
		// adjust javascript
		$jfrompage = $frompage;
		$jtopage = $topage;
		if (preg_match_all('/this\.addField\(\'([^\']*)\',\'([^\']*)\',([0-9]+)/', $this->javascript, $pamatch) > 0) {
			foreach($pamatch[0] as $pk => $pmatch) {
				$pagenum = intval($pamatch[3][$pk]) + 1;
				if (($pagenum >= $jtopage) AND ($pagenum < $jfrompage)) {
					$newpage = ($pagenum + 1);
				} elseif ($pagenum == $jfrompage) {
					$newpage = $jtopage;
				} else {
					$newpage = $pagenum;
				}
				--$newpage;
				$newjs = ""this.addField(\'"".$pamatch[1][$pk].""\',\'"".$pamatch[2][$pk].""\',"".$newpage;
				$this->javascript = str_replace($pmatch, $newjs, $this->javascript);
			}
			unset($pamatch);
		}
		// return to last page
		$this->lastPage(true);
		return true;
	}

	/**
	 * Remove the specified page.
	 * @param int $page page to remove
	 * @return bool true in case of success, false in case of error.
	 * @public
	 * @since 4.6.004 (2009-04-23)
	 */
	public function deletePage($page) {
		if (($page < 1) OR ($page > $this->numpages)) {
			return false;
		}
		// delete current page
		unset($this->pages[$page]);
		unset($this->pagedim[$page]);
		unset($this->pagelen[$page]);
		unset($this->intmrk[$page]);
		unset($this->bordermrk[$page]);
		unset($this->cntmrk[$page]);
		foreach ($this->pageobjects[$page] as $oid) {
			if (isset($this->offsets[$oid])){
				unset($this->offsets[$oid]);
			}
		}
		unset($this->pageobjects[$page]);
		if (isset($this->footerpos[$page])) {
			unset($this->footerpos[$page]);
		}
		if (isset($this->footerlen[$page])) {
			unset($this->footerlen[$page]);
		}
		if (isset($this->transfmrk[$page])) {
			unset($this->transfmrk[$page]);
		}
		if (isset($this->PageAnnots[$page])) {
			unset($this->PageAnnots[$page]);
		}
		if (isset($this->newpagegroup) AND !empty($this->newpagegroup)) {
			for ($i = $page; $i > 0; --$i) {
				if (isset($this->newpagegroup[$i]) AND (($i + $this->pagegroups[$this->newpagegroup[$i]]) > $page)) {
					--$this->pagegroups[$this->newpagegroup[$i]];
					break;
				}
			}
		}
		if (isset($this->pageopen[$page])) {
			unset($this->pageopen[$page]);
		}
		if ($page < $this->numpages) {
			// update remaining pages
			for ($i = $page; $i < $this->numpages; ++$i) {
				$j = $i + 1;
				// shift pages
				$this->setPageBuffer($i, $this->getPageBuffer($j));
				$this->pagedim[$i] = $this->pagedim[$j];
				$this->pagelen[$i] = $this->pagelen[$j];
				$this->intmrk[$i] = $this->intmrk[$j];
				$this->bordermrk[$i] = $this->bordermrk[$j];
				$this->cntmrk[$i] = $this->cntmrk[$j];
				$this->pageobjects[$i] = $this->pageobjects[$j];
				if (isset($this->footerpos[$j])) {
					$this->footerpos[$i] = $this->footerpos[$j];
				} elseif (isset($this->footerpos[$i])) {
					unset($this->footerpos[$i]);
				}
				if (isset($this->footerlen[$j])) {
					$this->footerlen[$i] = $this->footerlen[$j];
				} elseif (isset($this->footerlen[$i])) {
					unset($this->footerlen[$i]);
				}
				if (isset($this->transfmrk[$j])) {
					$this->transfmrk[$i] = $this->transfmrk[$j];
				} elseif (isset($this->transfmrk[$i])) {
					unset($this->transfmrk[$i]);
				}
				if (isset($this->PageAnnots[$j])) {
					$this->PageAnnots[$i] = $this->PageAnnots[$j];
				} elseif (isset($this->PageAnnots[$i])) {
					unset($this->PageAnnots[$i]);
				}
				if (isset($this->newpagegroup[$j])) {
					$this->newpagegroup[$i] = $this->newpagegroup[$j];
					unset($this->newpagegroup[$j]);
				}
				if ($this->currpagegroup == $j) {
					$this->currpagegroup = $i;
				}
				if (isset($this->pageopen[$j])) {
					$this->pageopen[$i] = $this->pageopen[$j];
				} elseif (isset($this->pageopen[$i])) {
					unset($this->pageopen[$i]);
				}
			}
			// remove last page
			unset($this->pages[$this->numpages]);
			unset($this->pagedim[$this->numpages]);
			unset($this->pagelen[$this->numpages]);
			unset($this->intmrk[$this->numpages]);
			unset($this->bordermrk[$this->numpages]);
			unset($this->cntmrk[$this->numpages]);
			foreach ($this->pageobjects[$this->numpages] as $oid) {
				if (isset($this->offsets[$oid])){
					unset($this->offsets[$oid]);
				}
			}
			unset($this->pageobjects[$this->numpages]);
			if (isset($this->footerpos[$this->numpages])) {
				unset($this->footerpos[$this->numpages]);
			}
			if (isset($this->footerlen[$this->numpages])) {
				unset($this->footerlen[$this->numpages]);
			}
			if (isset($this->transfmrk[$this->numpages])) {
				unset($this->transfmrk[$this->numpages]);
			}
			if (isset($this->PageAnnots[$this->numpages])) {
				unset($this->PageAnnots[$this->numpages]);
			}
			if (isset($this->newpagegroup[$this->numpages])) {
				unset($this->newpagegroup[$this->numpages]);
			}
			if ($this->currpagegroup == $this->numpages) {
				$this->currpagegroup = ($this->numpages - 1);
			}
			if (isset($this->pagegroups[$this->numpages])) {
				unset($this->pagegroups[$this->numpages]);
			}
			if (isset($this->pageopen[$this->numpages])) {
				unset($this->pageopen[$this->numpages]);
			}
		}
		--$this->numpages;
		$this->page = $this->numpages;
		// adjust outlines
		$tmpoutlines = $this->outlines;
		foreach ($tmpoutlines as $key => $outline) {
			if (!$outline['f']) {
				if ($outline['p'] > $page) {
					$this->outlines[$key]['p'] = $outline['p'] - 1;
				} elseif ($outline['p'] == $page) {
					unset($this->outlines[$key]);
				}
			}
		}
		// adjust dests
		$tmpdests = $this->dests;
		foreach ($tmpdests as $key => $dest) {
			if (!$dest['f']) {
				if ($dest['p'] > $page) {
					$this->dests[$key]['p'] = $dest['p'] - 1;
				} elseif ($dest['p'] == $page) {
					unset($this->dests[$key]);
				}
			}
		}
		// adjust links
		$tmplinks = $this->links;
		foreach ($tmplinks as $key => $link) {
			if (!$link['f']) {
				if ($link['p'] > $page) {
					$this->links[$key]['p'] = $link['p'] - 1;
				} elseif ($link['p'] == $page) {
					unset($this->links[$key]);
				}
			}
		}
		// adjust javascript
		$jpage = $page;
		if (preg_match_all('/this\.addField\(\'([^\']*)\',\'([^\']*)\',([0-9]+)/', $this->javascript, $pamatch) > 0) {
			foreach($pamatch[0] as $pk => $pmatch) {
				$pagenum = intval($pamatch[3][$pk]) + 1;
				if ($pagenum >= $jpage) {
					$newpage = ($pagenum - 1);
				} elseif ($pagenum == $jpage) {
					$newpage = 1;
				} else {
					$newpage = $pagenum;
				}
				--$newpage;
				$newjs = ""this.addField(\'"".$pamatch[1][$pk].""\',\'"".$pamatch[2][$pk].""\',"".$newpage;
				$this->javascript = str_replace($pmatch, $newjs, $this->javascript);
			}
			unset($pamatch);
		}
		// return to last page
		if ($this->numpages > 0) {
			$this->lastPage(true);
		}
		return true;
	}

	/**
	 * Clone the specified page to a new page.
	 * @param int $page number of page to copy (0 = current page)
	 * @return bool true in case of success, false in case of error.
	 * @public
	 * @since 4.9.015 (2010-04-20)
	 */
	public function copyPage($page=0) {
		if ($page == 0) {
			// default value
			$page = $this->page;
		}
		if (($page < 1) OR ($page > $this->numpages)) {
			return false;
		}
		// close the last page
		$this->endPage();
		// copy all page-related states
		++$this->numpages;
		$this->page = $this->numpages;
		$this->setPageBuffer($this->page, $this->getPageBuffer($page));
		$this->pagedim[$this->page] = $this->pagedim[$page];
		$this->pagelen[$this->page] = $this->pagelen[$page];
		$this->intmrk[$this->page] = $this->intmrk[$page];
		$this->bordermrk[$this->page] = $this->bordermrk[$page];
		$this->cntmrk[$this->page] = $this->cntmrk[$page];
		$this->pageobjects[$this->page] = $this->pageobjects[$page];
		$this->pageopen[$this->page] = false;
		if (isset($this->footerpos[$page])) {
			$this->footerpos[$this->page] = $this->footerpos[$page];
		}
		if (isset($this->footerlen[$page])) {
			$this->footerlen[$this->page] = $this->footerlen[$page];
		}
		if (isset($this->transfmrk[$page])) {
			$this->transfmrk[$this->page] = $this->transfmrk[$page];
		}
		if (isset($this->PageAnnots[$page])) {
			$this->PageAnnots[$this->page] = $this->PageAnnots[$page];
		}
		if (isset($this->newpagegroup[$page])) {
			// start a new group
			$this->newpagegroup[$this->page] = sizeof($this->newpagegroup) + 1;
			$this->currpagegroup = $this->newpagegroup[$this->page];
			$this->pagegroups[$this->currpagegroup] = 1;
		} elseif (isset($this->currpagegroup) AND ($this->currpagegroup > 0)) {
			++$this->pagegroups[$this->currpagegroup];
		}
		// copy outlines
		$tmpoutlines = $this->outlines;
		foreach ($tmpoutlines as $key => $outline) {
			if ($outline['p'] == $page) {
				$this->outlines[] = array('t' => $outline['t'], 'l' => $outline['l'], 'x' => $outline['x'], 'y' => $outline['y'], 'p' => $this->page, 'f' => $outline['f'], 's' => $outline['s'], 'c' => $outline['c']);
			}
		}
		// copy links
		$tmplinks = $this->links;
		foreach ($tmplinks as $key => $link) {
			if ($link['p'] == $page) {
				$this->links[] = array('p' => $this->page, 'y' => $link['y'], 'f' => $link['f']);
			}
		}
		// return to last page
		$this->lastPage(true);
		return true;
	}

	/**
	 * Output a Table of Content Index (TOC).
	 * This method must be called after all Bookmarks were set.
	 * Before calling this method you have to open the page using the addTOCPage() method.
	 * After calling this method you have to call endTOCPage() to close the TOC page.
	 * You can override this method to achieve different styles.
	 * @param int|null $page page number where this TOC should be inserted (leave empty for current page).
	 * @param string $numbersfont set the font for page numbers (please use monospaced font for better alignment).
	 * @param string $filler string used to fill the space between text and page number.
	 * @param string $toc_name name to use for TOC bookmark.
	 * @param string $style Font style for title: B = Bold, I = Italic, BI = Bold + Italic.
	 * @param array $color RGB color array for bookmark title (values from 0 to 255).
	 * @public
	 * @author Nicola Asuni
	 * @since 4.5.000 (2009-01-02)
	 * @see addTOCPage(), endTOCPage(), addHTMLTOC()
	 */
	public function addTOC($page=null, $numbersfont='', $filler='.', $toc_name='TOC', $style='', $color=array(0,0,0)) {
		$fontsize = $this->FontSizePt;
		$fontfamily = $this->FontFamily;
		$fontstyle = $this->FontStyle;
		$w = $this->w - $this->lMargin - $this->rMargin;
		$spacer = $this->GetStringWidth(chr(32)) * 4;
		$lmargin = $this->lMargin;
		$rmargin = $this->rMargin;
		$x_start = $this->GetX();
		$page_first = $this->page;
		$current_page = $this->page;
		$page_fill_start = false;
		$page_fill_end = false;
		$current_column = $this->current_column;
		if (TCPDF_STATIC::empty_string($numbersfont)) {
			$numbersfont = $this->default_monospaced_font;
		}
		if (TCPDF_STATIC::empty_string($filler)) {
			$filler = ' ';
		}
		if (TCPDF_STATIC::empty_string($page)) {
			$gap = ' ';
		} else {
			$gap = '';
			if ($page < 1) {
				$page = 1;
			}
		}
		$this->setFont($numbersfont, $fontstyle, $fontsize);
		$numwidth = $this->GetStringWidth('00000');
		$maxpage = 0; //used for pages on attached documents
		foreach ($this->outlines as $key => $outline) {
			// check for extra pages (used for attachments)
			if (($this->page > $page_first) AND ($outline['p'] >= $this->numpages)) {
				$outline['p'] += ($this->page - $page_first);
			}
			if ($this->rtl) {
				$aligntext = 'R';
				$alignnum = 'L';
			} else {
				$aligntext = 'L';
				$alignnum = 'R';
			}
			if ($outline['l'] == 0) {
				$this->setFont($fontfamily, $outline['s'].'B', $fontsize);
			} else {
				$this->setFont($fontfamily, $outline['s'], $fontsize - $outline['l']);
			}
			$this->setTextColorArray($outline['c']);
			// check for page break
			$this->checkPageBreak(2 * $this->getCellHeight($this->FontSize));
			// set margins and X position
			if (($this->page == $current_page) AND ($this->current_column == $current_column)) {
				$this->lMargin = $lmargin;
				$this->rMargin = $rmargin;
			} else {
				if ($this->current_column != $current_column) {
					if ($this->rtl) {
						$x_start = $this->w - $this->columns[$this->current_column]['x'];
					} else {
						$x_start = $this->columns[$this->current_column]['x'];
					}
				}
				$lmargin = $this->lMargin;
				$rmargin = $this->rMargin;
				$current_page = $this->page;
				$current_column = $this->current_column;
			}
			$this->setX($x_start);
			$indent = ($spacer * $outline['l']);
			if ($this->rtl) {
				$this->x -= $indent;
				$this->rMargin = $this->w - $this->x;
			} else {
				$this->x += $indent;
				$this->lMargin = $this->x;
			}
			$link = $this->AddLink();
			$this->setLink($link, $outline['y'], $outline['p']);
			// write the text
			if ($this->rtl) {
				$txt = ' '.$outline['t'];
			} else {
				$txt = $outline['t'].' ';
			}
			$this->Write(0, $txt, $link, false, $aligntext, false, 0, false, false, 0, $numwidth, '');
			if ($this->rtl) {
				$tw = $this->x - $this->lMargin;
			} else {
				$tw = $this->w - $this->rMargin - $this->x;
			}
			$this->setFont($numbersfont, $fontstyle, $fontsize);
			if (TCPDF_STATIC::empty_string($page)) {
				$pagenum = $outline['p'];
			} else {
				// placemark to be replaced with the correct number
				$pagenum = '{#'.($outline['p']).'}';
				if ($this->isUnicodeFont()) {
					$pagenum = '{'.$pagenum.'}';
				}
				$maxpage = max($maxpage, $outline['p']);
			}
			$fw = ($tw - $this->GetStringWidth($pagenum.$filler));
			$wfiller = $this->GetStringWidth($filler);
			if ($wfiller > 0) {
				$numfills = floor($fw / $wfiller);
			} else {
				$numfills = 0;
			}
			if ($numfills > 0) {
				$rowfill = str_repeat($filler, $numfills);
			} else {
				$rowfill = '';
			}
			if ($this->rtl) {
				$pagenum = $pagenum.$gap.$rowfill;
			} else {
				$pagenum = $rowfill.$gap.$pagenum;
			}
			// write the number
			$this->Cell($tw, 0, $pagenum, 0, 1, $alignnum, 0, $link, 0);
		}
		$page_last = $this->getPage();
		$numpages = ($page_last - $page_first + 1);
		// account for booklet mode
		if ($this->booklet) {
			// check if a blank page is required before TOC
			$page_fill_start = ((($page_first % 2) == 0) XOR (($page % 2) == 0));
			$page_fill_end = (!((($numpages % 2) == 0) XOR ($page_fill_start)));
			if ($page_fill_start) {
				// add a page at the end (to be moved before TOC)
				$this->addPage();
				++$page_last;
				++$numpages;
			}
			if ($page_fill_end) {
				// add a page at the end
				$this->addPage();
				++$page_last;
				++$numpages;
			}
		}
		$maxpage = max($maxpage, $page_last);
		if (!TCPDF_STATIC::empty_string($page)) {
			for ($p = $page_first; $p <= $page_last; ++$p) {
				// get page data
				$temppage = $this->getPageBuffer($p);
				for ($n = 1; $n <= $maxpage; ++$n) {
					// update page numbers
					$a = '{#'.$n.'}';
					// get page number aliases
					$pnalias = $this->getInternalPageNumberAliases($a);
					// calculate replacement number
					if (($n >= $page) AND ($n <= $this->numpages)) {
						$np = $n + $numpages;
					} else {
						$np = $n;
					}
					$na = TCPDF_STATIC::formatTOCPageNumber(($this->starting_page_number + $np - 1));
					$nu = TCPDF_FONTS::UTF8ToUTF16BE($na, false, $this->isunicode, $this->CurrentFont);
					// replace aliases with numbers
					foreach ($pnalias['u'] as $u) {
						$sfill = str_repeat($filler, max(0, (strlen($u) - strlen($nu.' '))));
						if ($this->rtl) {
							$nr = $nu.TCPDF_FONTS::UTF8ToUTF16BE(' '.$sfill, false, $this->isunicode, $this->CurrentFont);
						} else {
							$nr = TCPDF_FONTS::UTF8ToUTF16BE($sfill.' ', false, $this->isunicode, $this->CurrentFont).$nu;
						}
						$temppage = str_replace($u, $nr, $temppage);
					}
					foreach ($pnalias['a'] as $a) {
						$sfill = str_repeat($filler, max(0, (strlen($a) - strlen($na.' '))));
						if ($this->rtl) {
							$nr = $na.' '.$sfill;
						} else {
							$nr = $sfill.' '.$na;
						}
						$temppage = str_replace($a, $nr, $temppage);
					}
				}
				// save changes
				$this->setPageBuffer($p, $temppage);
			}
			// move pages
			$this->Bookmark($toc_name, 0, 0, $page_first, $style, $color);
			if ($page_fill_start) {
				$this->movePage($page_last, $page_first);
			}
			for ($i = 0; $i < $numpages; ++$i) {
				$this->movePage($page_last, $page);
			}
		}
	}

	/**
	 * Output a Table Of Content Index (TOC) using HTML templates.
	 * This method must be called after all Bookmarks were set.
	 * Before calling this method you have to open the page using the addTOCPage() method.
	 * After calling this method you have to call endTOCPage() to close the TOC page.
	 * @param int|null $page page number where this TOC should be inserted (leave empty for current page).
	 * @param string $toc_name name to use for TOC bookmark.
	 * @param array $templates array of html templates. Use: ""#TOC_DESCRIPTION#"" for bookmark title, ""#TOC_PAGE_NUMBER#"" for page number.
	 * @param boolean $correct_align if true correct the number alignment (numbers must be in monospaced font like courier and right aligned on LTR, or left aligned on RTL)
	 * @param string $style Font style for title: B = Bold, I = Italic, BI = Bold + Italic.
	 * @param array $color RGB color array for title (values from 0 to 255).
	 * @public
	 * @author Nicola Asuni
	 * @since 5.0.001 (2010-05-06)
	 * @see addTOCPage(), endTOCPage(), addTOC()
	 */
	public function addHTMLTOC($page=null, $toc_name='TOC', $templates=array(), $correct_align=true, $style='', $color=array(0,0,0)) {
		$filler = ' ';
		$prev_htmlLinkColorArray = $this->htmlLinkColorArray;
		$prev_htmlLinkFontStyle = $this->htmlLinkFontStyle;
		// set new style for link
		$this->htmlLinkColorArray = array();
		$this->htmlLinkFontStyle = '';
		$page_first = $this->getPage();
		$page_fill_start = false;
		$page_fill_end = false;
		// get the font type used for numbers in each template
		$current_font = $this->FontFamily;
		foreach ($templates as $level => $html) {
			$dom = $this->getHtmlDomArray($html);
			foreach ($dom as $key => $value) {
				if ($value['value'] == '#TOC_PAGE_NUMBER#') {
					$this->setFont($dom[($key - 1)]['fontname']);
					$templates['F'.$level] = $this->isUnicodeFont();
				}
			}
		}
		$this->setFont($current_font);
		$maxpage = 0; //used for pages on attached documents
		foreach ($this->outlines as $key => $outline) {
			// get HTML template
			$row = $templates[$outline['l']];
			if (TCPDF_STATIC::empty_string($page)) {
				$pagenum = $outline['p'];
			} else {
				// placemark to be replaced with the correct number
				$pagenum = '{#'.($outline['p']).'}';
				if (isset($templates['F'.$outline['l']]) && $templates['F'.$outline['l']]) {
					$pagenum = '{'.$pagenum.'}';
				}
				$maxpage = max($maxpage, $outline['p']);
			}
			// replace templates with current values
			$row = str_replace('#TOC_DESCRIPTION#', $outline['t'], $row);
			$row = str_replace('#TOC_PAGE_NUMBER#', $pagenum, $row);
			// add link to page
			$row = '<a href=""#'.$outline['p'].','.$outline['y'].'"">'.$row.'</a>';
			// write bookmark entry
			$this->writeHTML($row, false, false, true, false, '');
		}
		// restore link styles
		$this->htmlLinkColorArray = $prev_htmlLinkColorArray;
		$this->htmlLinkFontStyle = $prev_htmlLinkFontStyle;
		// move TOC page and replace numbers
		$page_last = $this->getPage();
		$numpages = ($page_last - $page_first + 1);
		// account for booklet mode
		if ($this->booklet) {
			// check if a blank page is required before TOC
			$page_fill_start = ((($page_first % 2) == 0) XOR (($page % 2) == 0));
			$page_fill_end = (!((($numpages % 2) == 0) XOR ($page_fill_start)));
			if ($page_fill_start) {
				// add a page at the end (to be moved before TOC)
				$this->addPage();
				++$page_last;
				++$numpages;
			}
			if ($page_fill_end) {
				// add a page at the end
				$this->addPage();
				++$page_last;
				++$numpages;
			}
		}
		$maxpage = max($maxpage, $page_last);
		if (!TCPDF_STATIC::empty_string($page)) {
			for ($p = $page_first; $p <= $page_last; ++$p) {
				// get page data
				$temppage = $this->getPageBuffer($p);
				for ($n = 1; $n <= $maxpage; ++$n) {
					// update page numbers
					$a = '{#'.$n.'}';
					// get page number aliases
					$pnalias = $this->getInternalPageNumberAliases($a);
					// calculate replacement number
					if ($n >= $page) {
						$np = $n + $numpages;
					} else {
						$np = $n;
					}
					$na = TCPDF_STATIC::formatTOCPageNumber(($this->starting_page_number + $np - 1));
					$nu = TCPDF_FONTS::UTF8ToUTF16BE($na, false, $this->isunicode, $this->CurrentFont);
					// replace aliases with numbers
					foreach ($pnalias['u'] as $u) {
						if ($correct_align) {
							$sfill = str_repeat($filler, (strlen($u) - strlen($nu.' ')));
							if ($this->rtl) {
								$nr = $nu.TCPDF_FONTS::UTF8ToUTF16BE(' '.$sfill, false, $this->isunicode, $this->CurrentFont);
							} else {
								$nr = TCPDF_FONTS::UTF8ToUTF16BE($sfill.' ', false, $this->isunicode, $this->CurrentFont).$nu;
							}
						} else {
							$nr = $nu;
						}
						$temppage = str_replace($u, $nr, $temppage);
					}
					foreach ($pnalias['a'] as $a) {
						if ($correct_align) {
							$sfill = str_repeat($filler, (strlen($a) - strlen($na.' ')));
							if ($this->rtl) {
								$nr = $na.' '.$sfill;
							} else {
								$nr = $sfill.' '.$na;
							}
						} else {
							$nr = $na;
						}
						$temppage = str_replace($a, $nr, $temppage);
					}
				}
				// save changes
				$this->setPageBuffer($p, $temppage);
			}
			// move pages
			$this->Bookmark($toc_name, 0, 0, $page_first, $style, $color);
			if ($page_fill_start) {
				$this->movePage($page_last, $page_first);
			}
			for ($i = 0; $i < $numpages; ++$i) {
				$this->movePage($page_last, $page);
			}
		}
	}

	/**
	 * Stores a copy of the current TCPDF object used for undo operation.
	 * @public
	 * @since 4.5.029 (2009-03-19)
	 */
	public function startTransaction() {
		if (isset($this->objcopy)) {
			// remove previous copy
			$this->commitTransaction();
		}
		// record current page number and Y position
		$this->start_transaction_page = $this->page;
		$this->start_transaction_y = $this->y;
		// clone current object
		$this->objcopy = TCPDF_STATIC::objclone($this);
	}

	/**
	 * Delete the copy of the current TCPDF object used for undo operation.
	 * @public
	 * @since 4.5.029 (2009-03-19)
	 */
	public function commitTransaction() {
		if (isset($this->objcopy)) {
			$this->objcopy->_destroy(true, true);
			/* The unique file_id should not be used during cleanup again */
			$this->objcopy->file_id = NULL;
			unset($this->objcopy);
		}
	}

	/**
	 * This method allows to undo the latest transaction by returning the latest saved TCPDF object with startTransaction().
	 * @param boolean $self if true restores current class object to previous state without the need of reassignment via the returned value.
	 * @return TCPDF object.
	 * @public
	 * @since 4.5.029 (2009-03-19)
	 */
	public function rollbackTransaction($self=false) {
		if (!isset($this->objcopy)) {
			return $this;
		}
		$file_id = $this->file_id;
		$objcopy = $this->objcopy;
		$this->_destroy(true, true);
		if ($self) {
			$objvars = get_object_vars($objcopy);
			foreach ($objvars as $key => $value) {
				$this->$key = $value;
			}
			$objcopy->_destroy(true, true);
			unset($objcopy);
			return $this;
		}
		$this->file_id = $file_id;
		return $objcopy;
	}

	// --- MULTI COLUMNS METHODS -----------------------

	/**
	 * Set multiple columns of the same size
	 * @param int $numcols number of columns (set to zero to disable columns mode)
	 * @param int $width column width
	 * @param int|null $y column starting Y position (leave empty for current Y position)
	 * @public
	 * @since 4.9.001 (2010-03-28)
	 */
	public function setEqualColumns($numcols=0, $width=0, $y=null) {
		$this->columns = array();
		if ($numcols < 2) {
			$numcols = 0;
			$this->columns = array();
		} else {
			// maximum column width
			$maxwidth = ($this->w - $this->original_lMargin - $this->original_rMargin) / $numcols;
			if (($width == 0) OR ($width > $maxwidth)) {
				$width = $maxwidth;
			}
			if (TCPDF_STATIC::empty_string($y)) {
				$y = $this->y;
			}
			// space between columns
			$space = (($this->w - $this->original_lMargin - $this->original_rMargin - ($numcols * $width)) / ($numcols - 1));
			// fill the columns array (with, space, starting Y position)
			for ($i = 0; $i < $numcols; ++$i) {
				$this->columns[$i] = array('w' => $width, 's' => $space, 'y' => $y);
			}
		}
		$this->num_columns = $numcols;
		$this->current_column = 0;
		$this->column_start_page = $this->page;
		$this->selectColumn(0);
	}

	/**
	 * Remove columns and reset page margins.
	 * @public
	 * @since 5.9.072 (2011-04-26)
	 */
	public function resetColumns() {
		$this->lMargin = $this->original_lMargin;
		$this->rMargin = $this->original_rMargin;
		$this->setEqualColumns();
	}

	/**
	 * Set columns array.
	 * Each column is represented by an array of arrays with the following keys: (w = width, s = space between columns, y = column top position).
	 * @param array $columns
	 * @public
	 * @since 4.9.001 (2010-03-28)
	 */
	public function setColumnsArray($columns) {
		$this->columns = $columns;
		$this->num_columns = count($columns);
		$this->current_column = 0;
		$this->column_start_page = $this->page;
		$this->selectColumn(0);
	}

	/**
	 * Set position at a given column
	 * @param int|null $col column number (from 0 to getNumberOfColumns()-1); empty string = current column.
	 * @public
	 * @since 4.9.001 (2010-03-28)
	 */
	public function selectColumn($col=null) {
		if (TCPDF_STATIC::empty_string($col)) {
			$col = $this->current_column;
		} elseif ($col >= $this->num_columns) {
			$col = 0;
		}
		$xshift = array('x' => 0, 's' => array('H' => 0, 'V' => 0), 'p' => array('L' => 0, 'T' => 0, 'R' => 0, 'B' => 0));
		$enable_thead = false;
		if ($this->num_columns > 1) {
			if ($col != $this->current_column) {
				// move Y pointer at the top of the column
				if ($this->column_start_page == $this->page) {
					$this->y = $this->columns[$col]['y'];
				} else {
					$this->y = $this->tMargin;
				}
				// Avoid to write table headers more than once
				if (($this->page > $this->maxselcol['page']) OR (($this->page == $this->maxselcol['page']) AND ($col > $this->maxselcol['column']))) {
					$enable_thead = true;
					$this->maxselcol['page'] = $this->page;
					$this->maxselcol['column'] = $col;
				}
			}
			$xshift = $this->colxshift;
			// set X position of the current column by case
			$listindent = ($this->listindentlevel * $this->listindent);
			// calculate column X position
			$colpos = 0;
			for ($i = 0; $i < $col; ++$i) {
				$colpos += ($this->columns[$i]['w'] + $this->columns[$i]['s']);
			}
			if ($this->rtl) {
				$x = $this->w - $this->original_rMargin - $colpos;
				$this->rMargin = ($this->w - $x + $listindent);
				$this->lMargin = ($x - $this->columns[$col]['w']);
				$this->x = $x - $listindent;
			} else {
				$x = $this->original_lMargin + $colpos;
				$this->lMargin = ($x + $listindent);
				$this->rMargin = ($this->w - $x - $this->columns[$col]['w']);
				$this->x = $x + $listindent;
			}
			$this->columns[$col]['x'] = $x;
		}
		$this->current_column = $col;
		// fix for HTML mode
		$this->newline = true;
		// print HTML table header (if any)
		if ((!TCPDF_STATIC::empty_string($this->thead)) AND (!$this->inthead)) {
			if ($enable_thead) {
				// print table header
				$this->writeHTML($this->thead, false, false, false, false, '');
				$this->y += $xshift['s']['V'];
				// store end of header position
				if (!isset($this->columns[$col]['th'])) {
					$this->columns[$col]['th'] = array();
				}
				$this->columns[$col]['th']['\''.$this->page.'\''] = $this->y;
				$this->lasth = 0;
			} elseif (isset($this->columns[$col]['th']['\''.$this->page.'\''])) {
				$this->y = $this->columns[$col]['th']['\''.$this->page.'\''];
			}
		}
		// account for an html table cell over multiple columns
		if ($this->rtl) {
			$this->rMargin += $xshift['x'];
			$this->x -= ($xshift['x'] + $xshift['p']['R']);
		} else {
			$this->lMargin += $xshift['x'];
			$this->x += $xshift['x'] + $xshift['p']['L'];
		}
	}

	/**
	 * Return the current column number
	 * @return int current column number
	 * @public
	 * @since 5.5.011 (2010-07-08)
	 */
	public function getColumn() {
		return $this->current_column;
	}

	/**
	 * Return the current number of columns.
	 * @return int number of columns
	 * @public
	 * @since 5.8.018 (2010-08-25)
	 */
	public function getNumberOfColumns() {
		return $this->num_columns;
	}

	/**
	 * Set Text rendering mode.
	 * @param int $stroke outline size in user units (0 = disable).
	 * @param boolean $fill if true fills the text (default).
	 * @param boolean $clip if true activate clipping mode
	 * @public
	 * @since 4.9.008 (2009-04-02)
	 */
	public function setTextRenderingMode($stroke=0, $fill=true, $clip=false) {
		// Ref.: PDF 32000-1:2008 - 9.3.6 Text Rendering Mode
		// convert text rendering parameters
		if ($stroke < 0 || !is_numeric($stroke)) {
			$stroke = 0;
		}
		if ($fill === true) {
			if ($stroke > 0) {
				if ($clip === true) {
					// Fill, then stroke text and add to path for clipping
					$textrendermode = 6;
				} else {
					// Fill, then stroke text
					$textrendermode = 2;
				}
				$textstrokewidth = $stroke;
			} else {
				if ($clip === true) {
					// Fill text and add to path for clipping
					$textrendermode = 4;
				} else {
					// Fill text
					$textrendermode = 0;
				}
			}
		} else {
			if ($stroke > 0) {
				if ($clip === true) {
					// Stroke text and add to path for clipping
					$textrendermode = 5;
				} else {
					// Stroke text
					$textrendermode = 1;
				}
				$textstrokewidth = $stroke;
			} else {
				if ($clip === true) {
					// Add text to path for clipping
					$textrendermode = 7;
				} else {
					// Neither fill nor stroke text (invisible)
					$textrendermode = 3;
				}
			}
		}
		$this->textrendermode = $textrendermode;
		$this->textstrokewidth = $stroke;
	}

	/**
	 * Set parameters for drop shadow effect for text.
	 * @param array $params Array of parameters: enabled (boolean) set to true to enable shadow; depth_w (float) shadow width in user units; depth_h (float) shadow height in user units; color (array) shadow color or false to use the stroke color; opacity (float) Alpha value: real value from 0 (transparent) to 1 (opaque); blend_mode (string) blend mode, one of the following: Normal, Multiply, Screen, Overlay, Darken, Lighten, ColorDodge, ColorBurn, HardLight, SoftLight, Difference, Exclusion, Hue, Saturation, Color, Luminosity.
	 * @since 5.9.174 (2012-07-25)
	 * @public
	*/
	public function setTextShadow($params=array('enabled'=>false, 'depth_w'=>0, 'depth_h'=>0, 'color'=>false, 'opacity'=>1, 'blend_mode'=>'Normal')) {
		if (isset($params['enabled'])) {
			$this->txtshadow['enabled'] = $params['enabled']?true:false;
		} else {
			$this->txtshadow['enabled'] = false;
		}
		if (isset($params['depth_w'])) {
			$this->txtshadow['depth_w'] = floatval($params['depth_w']);
		} else {
			$this->txtshadow['depth_w'] = 0;
		}
		if (isset($params['depth_h'])) {
			$this->txtshadow['depth_h'] = floatval($params['depth_h']);
		} else {
			$this->txtshadow['depth_h'] = 0;
		}
		if (isset($params['color']) AND ($params['color'] !== false) AND is_array($params['color'])) {
			$this->txtshadow['color'] = $params['color'];
		} else {
			$this->txtshadow['color'] = $this->strokecolor;
		}
		if (isset($params['opacity'])) {
			$this->txtshadow['opacity'] = min(1, max(0, floatval($params['opacity'])));
		} else {
			$this->txtshadow['opacity'] = 1;
		}
		if (isset($params['blend_mode']) AND in_array($params['blend_mode'], array('Normal', 'Multiply', 'Screen', 'Overlay', 'Darken', 'Lighten', 'ColorDodge', 'ColorBurn', 'HardLight', 'SoftLight', 'Difference', 'Exclusion', 'Hue', 'Saturation', 'Color', 'Luminosity'))) {
			$this->txtshadow['blend_mode'] = $params['blend_mode'];
		} else {
			$this->txtshadow['blend_mode'] = 'Normal';
		}
		if ((($this->txtshadow['depth_w'] == 0) AND ($this->txtshadow['depth_h'] == 0)) OR ($this->txtshadow['opacity'] == 0)) {
			$this->txtshadow['enabled'] = false;
		}
	}

	/**
	 * Return the text shadow parameters array.
	 * @return array array of parameters.
	 * @since 5.9.174 (2012-07-25)
	 * @public
	 */
	public function getTextShadow() {
		return $this->txtshadow;
	}

	/**
	 * Returns an array of chars containing soft hyphens.
	 * @param array $word array of chars
	 * @param array $patterns Array of hypenation patterns.
	 * @param array $dictionary Array of words to be returned without applying the hyphenation algorithm.
	 * @param int $leftmin Minimum number of character to leave on the left of the word without applying the hyphens.
	 * @param int $rightmin Minimum number of character to leave on the right of the word without applying the hyphens.
	 * @param int $charmin Minimum word length to apply the hyphenation algorithm.
	 * @param int $charmax Maximum length of broken piece of word.
	 * @return array text with soft hyphens
	 * @author Nicola Asuni
	 * @since 4.9.012 (2010-04-12)
	 * @protected
	 */
	protected function hyphenateWord($word, $patterns, $dictionary=array(), $leftmin=1, $rightmin=2, $charmin=1, $charmax=8) {
		$hyphenword = array(); // hyphens positions
		$numchars = count($word);
		if ($numchars <= $charmin) {
			return $word;
		}
		$word_string = TCPDF_FONTS::UTF8ArrSubString($word, '', '', $this->isunicode);
		// some words will be returned as-is
		$pattern = '/^([a-zA-Z0-9_\.\-]+)@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.)|(([a-zA-Z0-9\-]+\.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(\]?)$/';
		if (preg_match($pattern, $word_string) > 0) {
			// email
			return $word;
		}
		$pattern = '/(([a-zA-Z0-9\-]+\.)?)((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.)|(([a-zA-Z0-9\-]+\.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(\]?)$/';
		if (preg_match($pattern, $word_string) > 0) {
			// URL
			return $word;
		}
		if (isset($dictionary[$word_string])) {
			return TCPDF_FONTS::UTF8StringToArray($dictionary[$word_string], $this->isunicode, $this->CurrentFont);
		}
		// surround word with '_' characters
		$tmpword = array_merge(array(46), $word, array(46));
		$tmpnumchars = $numchars + 2;
		$maxpos = $tmpnumchars - 1;
		for ($pos = 0; $pos < $maxpos; ++$pos) {
			$imax = min(($tmpnumchars - $pos), $charmax);
			for ($i = 1; $i <= $imax; ++$i) {
				$subword = strtolower(TCPDF_FONTS::UTF8ArrSubString($tmpword, $pos, ($pos + $i), $this->isunicode));
				if (isset($patterns[$subword])) {
					$pattern = TCPDF_FONTS::UTF8StringToArray($patterns[$subword], $this->isunicode, $this->CurrentFont);
					$pattern_length = count($pattern);
					$digits = 1;
					for ($j = 0; $j < $pattern_length; ++$j) {
						// check if $pattern[$j] is a number = hyphenation level (only numbers from 1 to 5 are valid)
						if (($pattern[$j] >= 48) AND ($pattern[$j] <= 57)) {
							if ($j == 0) {
								$zero = $pos - 1;
							} else {
								$zero = $pos + $j - $digits;
							}
							// get hyphenation level
							$level = ($pattern[$j] - 48);
							// if two levels from two different patterns match at the same point, the higher one is selected.
							if (!isset($hyphenword[$zero]) OR ($hyphenword[$zero] < $level)) {
								$hyphenword[$zero] = $level;
							}
							++$digits;
						}
					}
				}
			}
		}
		$inserted = 0;
		$maxpos = $numchars - $rightmin;
		for ($i = $leftmin; $i <= $maxpos; ++$i) {
			// only odd levels indicate allowed hyphenation points
			if (isset($hyphenword[$i]) AND (($hyphenword[$i] % 2) != 0)) {
				// 173 = soft hyphen character
				array_splice($word, $i + $inserted, 0, 173);
				++$inserted;
			}
		}
		return $word;
	}

	/**
	 * Returns text with soft hyphens.
	 * @param string $text text to process
	 * @param mixed $patterns Array of hypenation patterns or a TEX file containing hypenation patterns. TEX patterns can be downloaded from http://www.ctan.org/tex-archive/language/hyph-utf8/tex/generic/hyph-utf8/patterns/
	 * @param array $dictionary Array of words to be returned without applying the hyphenation algorithm.
	 * @param int $leftmin Minimum number of character to leave on the left of the word without applying the hyphens.
	 * @param int $rightmin Minimum number of character to leave on the right of the word without applying the hyphens.
	 * @param int $charmin Minimum word length to apply the hyphenation algorithm.
	 * @param int $charmax Maximum length of broken piece of word.
	 * @return string text with soft hyphens
	 * @author Nicola Asuni
	 * @since 4.9.012 (2010-04-12)
	 * @public
	 */
	public function hyphenateText($text, $patterns, $dictionary=array(), $leftmin=1, $rightmin=2, $charmin=1, $charmax=8) {
		$text = $this->unhtmlentities($text);
		$word = array(); // last word
		$txtarr = array(); // text to be returned
		$intag = false; // true if we are inside an HTML tag
		$skip = false; // true to skip hyphenation
		if (!is_array($patterns)) {
			$patterns = TCPDF_STATIC::getHyphenPatternsFromTEX($patterns);
		}
		// get array of characters
		$unichars = TCPDF_FONTS::UTF8StringToArray($text, $this->isunicode, $this->CurrentFont);
		// for each char
		foreach ($unichars as $char) {
			if ((!$intag) AND (!$skip) AND TCPDF_FONT_DATA::$uni_type[$char] == 'L') {
				// letter character
				$word[] = $char;
			} else {
				// other type of character
				if (!TCPDF_STATIC::empty_string($word)) {
					// hypenate the word
					$txtarr = array_merge($txtarr, $this->hyphenateWord($word, $patterns, $dictionary, $leftmin, $rightmin, $charmin, $charmax));
					$word = array();
				}
				$txtarr[] = $char;
				if (chr($char) == '<') {
					// we are inside an HTML tag
					$intag = true;
				} elseif ($intag AND (chr($char) == '>')) {
					// end of HTML tag
					$intag = false;
					// check for style tag
					$expected = array(115, 116, 121, 108, 101); // = 'style'
					$current = array_slice($txtarr, -6, 5); // last 5 chars
					$compare = array_diff($expected, $current);
					if (empty($compare)) {
						// check if it is a closing tag
						$expected = array(47); // = '/'
						$current = array_slice($txtarr, -7, 1);
						$compare = array_diff($expected, $current);
						if (empty($compare)) {
							// closing style tag
							$skip = false;
						} else {
							// opening style tag
							$skip = true;
						}
					}
				}
			}
		}
		if (!TCPDF_STATIC::empty_string($word)) {
			// hypenate the word
			$txtarr = array_merge($txtarr, $this->hyphenateWord($word, $patterns, $dictionary, $leftmin, $rightmin, $charmin, $charmax));
		}
		// convert char array to string and return
		return TCPDF_FONTS::UTF8ArrSubString($txtarr, '', '', $this->isunicode);
	}

	/**
	 * Enable/disable rasterization of vector images using ImageMagick library.
	 * @param boolean $mode if true enable rasterization, false otherwise.
	 * @public
	 * @since 5.0.000 (2010-04-27)
	 */
	public function setRasterizeVectorImages($mode) {
		$this->rasterize_vector_images = $mode;
	}

	/**
	 * Enable or disable default option for font subsetting.
	 * @param boolean $enable if true enable font subsetting by default.
	 * @author Nicola Asuni
	 * @public
	 * @since 5.3.002 (2010-06-07)
	 */
	public function setFontSubsetting($enable=true) {
		if ($this->pdfa_mode) {
			$this->font_subsetting = false;
		} else {
			$this->font_subsetting = $enable ? true : false;
		}
	}

	/**
	 * Return the default option for font subsetting.
	 * @return bool default font subsetting state.
	 * @author Nicola Asuni
	 * @public
	 * @since 5.3.002 (2010-06-07)
	 */
	public function getFontSubsetting() {
		return $this->font_subsetting;
	}

	/**
	 * Left trim the input string
	 * @param string $str string to trim
	 * @param string $replace string that replace spaces.
	 * @return string left trimmed string
	 * @author Nicola Asuni
	 * @public
	 * @since 5.8.000 (2010-08-11)
	 */
	public function stringLeftTrim($str, $replace='') {
		return preg_replace('/^'.$this->re_space['p'].'+/'.$this->re_space['m'], $replace, $str);
	}

	/**
	 * Right trim the input string
	 * @param string $str string to trim
	 * @param string $replace string that replace spaces.
	 * @return string right trimmed string
	 * @author Nicola Asuni
	 * @public
	 * @since 5.8.000 (2010-08-11)
	 */
	public function stringRightTrim($str, $replace='') {
		return preg_replace('/'.$this->re_space['p'].'+$/'.$this->re_space['m'], $replace, $str);
	}

	/**
	 * Trim the input string
	 * @param string $str string to trim
	 * @param string $replace string that replace spaces.
	 * @return string trimmed string
	 * @author Nicola Asuni
	 * @public
	 * @since 5.8.000 (2010-08-11)
	 */
	public function stringTrim($str, $replace='') {
		$str = $this->stringLeftTrim($str, $replace);
		$str = $this->stringRightTrim($str, $replace);
		return $str;
	}

	/**
	 * Return true if the current font is unicode type.
	 * @return bool true for unicode font, false otherwise.
	 * @author Nicola Asuni
	 * @public
	 * @since 5.8.002 (2010-08-14)
	 */
	public function isUnicodeFont() {
		return (($this->CurrentFont['type'] == 'TrueTypeUnicode') OR ($this->CurrentFont['type'] == 'cidfont0'));
	}

	/**
	 * Return normalized font name
	 * @param string $fontfamily property string containing font family names
	 * @return string normalized font name
	 * @author Nicola Asuni
	 * @public
	 * @since 5.8.004 (2010-08-17)
	 */
	public function getFontFamilyName($fontfamily) {
		// remove spaces and symbols
		$fontfamily = preg_replace('/[^a-z0-9_\,]/', '', strtolower($fontfamily));
		// extract all font names
		$fontslist = preg_split('/[,]/', $fontfamily);
		// find first valid font name
		foreach ($fontslist as $font) {
			// replace font variations
			$font = preg_replace('/regular$/', '', $font);
			$font = preg_replace('/italic$/', 'I', $font);
			$font = preg_replace('/oblique$/', 'I', $font);
			$font = preg_replace('/bold([I]?)$/', 'B\\1', $font);
			// replace common family names and core fonts
			$pattern = array();
			$replacement = array();
			$pattern[] = '/^serif|^cursive|^fantasy|^timesnewroman/';
			$replacement[] = 'times';
			$pattern[] = '/^sansserif/';
			$replacement[] = 'helvetica';
			$pattern[] = '/^monospace/';
			$replacement[] = 'courier';
			$font = preg_replace($pattern, $replacement, $font);
			if (in_array(strtolower($font), $this->fontlist) OR in_array($font, $this->fontkeys)) {
				return $font;
			}
		}
		// return current font as default
		return $this->CurrentFont['fontkey'];
	}

	/**
	 * Start a new XObject Template.
	 * An XObject Template is a PDF block that is a self-contained description of any sequence of graphics objects (including path objects, text objects, and sampled images).
	 * An XObject Template may be painted multiple times, either on several pages or at several locations on the same page and produces the same results each time, subject only to the graphics state at the time it is invoked.
	 * Note: X,Y coordinates will be reset to 0,0.
	 * @param int $w Template width in user units (empty string or zero = page width less margins).
	 * @param int $h Template height in user units (empty string or zero = page height less margins).
	 * @param mixed $group Set transparency group. Can be a boolean value or an array specifying optional parameters: 'CS' (solour space name), 'I' (boolean flag to indicate isolated group) and 'K' (boolean flag to indicate knockout group).
	 * @return string|false the XObject Template ID in case of success or false in case of error.
	 * @author Nicola Asuni
	 * @public
	 * @since 5.8.017 (2010-08-24)
	 * @see endTemplate(), printTemplate()
	 */
	public function startTemplate($w=0, $h=0, $group=false) {
		if ($this->inxobj) {
			// we are already inside an XObject template
			return false;
		}
		$this->inxobj = true;
		++$this->n;
		// XObject ID
		$this->xobjid = 'XT'.$this->n;
		// object ID
		$this->xobjects[$this->xobjid] = array('n' => $this->n);
		// store current graphic state
		$this->xobjects[$this->xobjid]['gvars'] = $this->getGraphicVars();
		// initialize data
		$this->xobjects[$this->xobjid]['intmrk'] = 0;
		$this->xobjects[$this->xobjid]['transfmrk'] = array();
		$this->xobjects[$this->xobjid]['outdata'] = '';
		$this->xobjects[$this->xobjid]['xobjects'] = array();
		$this->xobjects[$this->xobjid]['images'] = array();
		$this->xobjects[$this->xobjid]['fonts'] = array();
		$this->xobjects[$this->xobjid]['annotations'] = array();
		$this->xobjects[$this->xobjid]['extgstates'] = array();
		$this->xobjects[$this->xobjid]['gradients'] = array();
		$this->xobjects[$this->xobjid]['spot_colors'] = array();
		// set new environment
		$this->num_columns = 1;
		$this->current_column = 0;
		$this->setAutoPageBreak(false);
		if (($w === '') OR ($w <= 0)) {
			$w = $this->w - $this->lMargin - $this->rMargin;
		}
		if (($h === '') OR ($h <= 0)) {
			$h = $this->h - $this->tMargin - $this->bMargin;
		}
		$this->xobjects[$this->xobjid]['x'] = 0;
		$this->xobjects[$this->xobjid]['y'] = 0;
		$this->xobjects[$this->xobjid]['w'] = $w;
		$this->xobjects[$this->xobjid]['h'] = $h;
		$this->w = $w;
		$this->h = $h;
		$this->wPt = $this->w * $this->k;
		$this->hPt = $this->h * $this->k;
		$this->fwPt = $this->wPt;
		$this->fhPt = $this->hPt;
		$this->x = 0;
		$this->y = 0;
		$this->lMargin = 0;
		$this->rMargin = 0;
		$this->tMargin = 0;
		$this->bMargin = 0;
		// set group mode
		$this->xobjects[$this->xobjid]['group'] = $group;
		return $this->xobjid;
	}

	/**
	 * End the current XObject Template started with startTemplate() and restore the previous graphic state.
	 * An XObject Template is a PDF block that is a self-contained description of any sequence of graphics objects (including path objects, text objects, and sampled images).
	 * An XObject Template may be painted multiple times, either on several pages or at several locations on the same page and produces the same results each time, subject only to the graphics state at the time it is invoked.
	 * @return string|false the XObject Template ID in case of success or false in case of error.
	 * @author Nicola Asuni
	 * @public
	 * @since 5.8.017 (2010-08-24)
	 * @see startTemplate(), printTemplate()
	 */
	public function endTemplate() {
		if (!$this->inxobj) {
			// we are not inside a template
			return false;
		}
		$this->inxobj = false;
		// restore previous graphic state
		$this->setGraphicVars($this->xobjects[$this->xobjid]['gvars'], true);
		return $this->xobjid;
	}

	/**
	 * Print an XObject Template.
	 * You can print an XObject Template inside the currently opened Template.
	 * An XObject Template is a PDF block that is a self-contained description of any sequence of graphics objects (including path objects, text objects, and sampled images).
	 * An XObject Template may be painted multiple times, either on several pages or at several locations on the same page and produces the same results each time, subject only to the graphics state at the time it is invoked.
	 * @param string $id The ID of XObject Template to print.
	 * @param float|null $x X position in user units (empty string = current x position)
	 * @param float|null $y Y position in user units (empty string = current y position)
	 * @param float $w Width in user units (zero = remaining page width)
	 * @param float $h Height in user units (zero = remaining page height)
	 * @param string $align Indicates the alignment of the pointer next to template insertion relative to template height. The value can be:<ul><li>T: top-right for LTR or top-left for RTL</li><li>M: middle-right for LTR or middle-left for RTL</li><li>B: bottom-right for LTR or bottom-left for RTL</li><li>N: next line</li></ul>
	 * @param string $palign Allows to center or align the template on the current line. Possible values are:<ul><li>L : left align</li><li>C : center</li><li>R : right align</li><li>'' : empty string : left for LTR or right for RTL</li></ul>
	 * @param boolean $fitonpage If true the template is resized to not exceed page dimensions.
	 * @author Nicola Asuni
	 * @public
	 * @since 5.8.017 (2010-08-24)
	 * @see startTemplate(), endTemplate()
	 */
	public function printTemplate($id, $x=null, $y=null, $w=0, $h=0, $align='', $palign='', $fitonpage=false) {
		if ($this->state != 2) {
			 return;
		}
		if (!isset($this->xobjects[$id])) {
			$this->Error('The XObject Template \''.$id.'\' doesn\'t exist!');
		}
		if ($this->inxobj) {
			if ($id == $this->xobjid) {
				// close current template
				$this->endTemplate();
			} else {
				// use the template as resource for the template currently opened
				$this->xobjects[$this->xobjid]['xobjects'][$id] = $this->xobjects[$id];
			}
		}
		// set default values
		if (TCPDF_STATIC::empty_string($x)) {
			$x = $this->x;
		}
		if (TCPDF_STATIC::empty_string($y)) {
			$y = $this->y;
		}
		// check page for no-write regions and adapt page margins if necessary
		list($x, $y) = $this->checkPageRegions($h, $x, $y);
		$ow = $this->xobjects[$id]['w'];
		if ($ow <= 0) {
			$ow = 1;
		}
		$oh = $this->xobjects[$id]['h'];
		if ($oh <= 0) {
			$oh = 1;
		}
		// calculate template width and height on document
		if (($w <= 0) AND ($h <= 0)) {
			$w = $ow;
			$h = $oh;
		} elseif ($w <= 0) {
			$w = $h * $ow / $oh;
		} elseif ($h <= 0) {
			$h = $w * $oh / $ow;
		}
		// fit the template on available space
		list($w, $h, $x, $y) = $this->fitBlock($w, $h, $x, $y, $fitonpage);
		// set page alignment
		$rb_y = $y + $h;
		// set alignment
		if ($this->rtl) {
			if ($palign == 'L') {
				$xt = $this->lMargin;
			} elseif ($palign == 'C') {
				$xt = ($this->w + $this->lMargin - $this->rMargin - $w) / 2;
			} elseif ($palign == 'R') {
				$xt = $this->w - $this->rMargin - $w;
			} else {
				$xt = $x - $w;
			}
			$rb_x = $xt;
		} else {
			if ($palign == 'L') {
				$xt = $this->lMargin;
			} elseif ($palign == 'C') {
				$xt = ($this->w + $this->lMargin - $this->rMargin - $w) / 2;
			} elseif ($palign == 'R') {
				$xt = $this->w - $this->rMargin - $w;
			} else {
				$xt = $x;
			}
			$rb_x = $xt + $w;
		}
		// print XObject Template + Transformation matrix
		$this->StartTransform();
		// translate and scale
		$sx = ($w / $ow);
		$sy = ($h / $oh);
		$tm = array();
		$tm[0] = $sx;
		$tm[1] = 0;
		$tm[2] = 0;
		$tm[3] = $sy;
		$tm[4] = $xt * $this->k;
		$tm[5] = ($this->h - $h - $y) * $this->k;
		$this->Transform($tm);
		// set object
		$this->_out('/'.$id.' Do');
		$this->StopTransform();
		// add annotations
		if (!empty($this->xobjects[$id]['annotations'])) {
			foreach ($this->xobjects[$id]['annotations'] as $annot) {
				// transform original coordinates
				$coordlt = TCPDF_STATIC::getTransformationMatrixProduct($tm, array(1, 0, 0, 1, ($annot['x'] * $this->k), (-$annot['y'] * $this->k)));
				$ax = ($coordlt[4] / $this->k);
				$ay = ($this->h - $h - ($coordlt[5] / $this->k));
				$coordrb = TCPDF_STATIC::getTransformationMatrixProduct($tm, array(1, 0, 0, 1, (($annot['x'] + $annot['w']) * $this->k), ((-$annot['y'] - $annot['h']) * $this->k)));
				$aw = ($coordrb[4] / $this->k) - $ax;
				$ah = ($this->h - $h - ($coordrb[5] / $this->k)) - $ay;
				$this->Annotation($ax, $ay, $aw, $ah, $annot['text'], $annot['opt'], $annot['spaces']);
			}
		}
		// set pointer to align the next text/objects
		switch($align) {
			case 'T': {
				$this->y = $y;
				$this->x = $rb_x;
				break;
			}
			case 'M': {
				$this->y = $y + round($h/2);
				$this->x = $rb_x;
				break;
			}
			case 'B': {
				$this->y = $rb_y;
				$this->x = $rb_x;
				break;
			}
			case 'N': {
				$this->setY($rb_y);
				break;
			}
			default:{
				break;
			}
		}
	}

	/**
	 * Set the percentage of character stretching.
	 * @param int $perc percentage of stretching (100 = no stretching)
	 * @author Nicola Asuni
	 * @public
	 * @since 5.9.000 (2010-09-29)
	 */
	public function setFontStretching($perc=100) {
		$this->font_stretching = $perc;
	}

	/**
	 * Get the percentage of character stretching.
	 * @return float stretching value
	 * @author Nicola Asuni
	 * @public
	 * @since 5.9.000 (2010-09-29)
	 */
	public function getFontStretching() {
		return $this->font_stretching;
	}

	/**
	 * Set the amount to increase or decrease the space between characters in a text.
	 * @param float $spacing amount to increase or decrease the space between characters in a text (0 = default spacing)
	 * @author Nicola Asuni
	 * @public
	 * @since 5.9.000 (2010-09-29)
	 */
	public function setFontSpacing($spacing=0) {
		$this->font_spacing = $spacing;
	}

	/**
	 * Get the amount to increase or decrease the space between characters in a text.
	 * @return int font spacing (tracking) value
	 * @author Nicola Asuni
	 * @public
	 * @since 5.9.000 (2010-09-29)
	 */
	public function getFontSpacing() {
		return $this->font_spacing;
	}

	/**
	 * Return an array of no-write page regions
	 * @return array of no-write page regions
	 * @author Nicola Asuni
	 * @public
	 * @since 5.9.003 (2010-10-13)
	 * @see setPageRegions(), addPageRegion()
	 */
	public function getPageRegions() {
		return $this->page_regions;
	}

	/**
	 * Set no-write regions on page.
	 * A no-write region is a portion of the page with a rectangular or trapezium shape that will not be covered when writing text or html code.
	 * A region is always aligned on the left or right side of the page ad is defined using a vertical segment.
	 * You can set multiple regions for the same page.
	 * @param array $regions array of no-write regions. For each region you can define an array as follow: ('page' => page number or empy for current page, 'xt' => X top, 'yt' => Y top, 'xb' => X bottom, 'yb' => Y bottom, 'side' => page side 'L' = left or 'R' = right). Omit this parameter to remove all regions.
	 * @author Nicola Asuni
	 * @public
	 * @since 5.9.003 (2010-10-13)
	 * @see addPageRegion(), getPageRegions()
	 */
	public function setPageRegions($regions=array()) {
		// empty current regions array
		$this->page_regions = array();
		// add regions
		foreach ($regions as $data) {
			$this->addPageRegion($data);
		}
	}

	/**
	 * Add a single no-write region on selected page.
	 * A no-write region is a portion of the page with a rectangular or trapezium shape that will not be covered when writing text or html code.
	 * A region is always aligned on the left or right side of the page ad is defined using a vertical segment.
	 * You can set multiple regions for the same page.
	 * @param array $region array of a single no-write region array: ('page' => page number or empy for current page, 'xt' => X top, 'yt' => Y top, 'xb' => X bottom, 'yb' => Y bottom, 'side' => page side 'L' = left or 'R' = right).
	 * @author Nicola Asuni
	 * @public
	 * @since 5.9.003 (2010-10-13)
	 * @see setPageRegions(), getPageRegions()
	 */
	public function addPageRegion($region) {
		if (!isset($region['page']) OR empty($region['page'])) {
			$region['page'] = $this->page;
		}
		if (isset($region['xt']) AND isset($region['xb']) AND ($region['xt'] > 0) AND ($region['xb'] > 0)
			AND isset($region['yt'])  AND isset($region['yb']) AND ($region['yt'] >= 0) AND ($region['yt'] < $region['yb'])
			AND isset($region['side']) AND (($region['side'] == 'L') OR ($region['side'] == 'R'))) {
			$this->page_regions[] = $region;
		}
	}

	/**
	 * Remove a single no-write region.
	 * @param int $key region key
	 * @author Nicola Asuni
	 * @public
	 * @since 5.9.003 (2010-10-13)
	 * @see setPageRegions(), getPageRegions()
	 */
	public function removePageRegion($key) {
		if (isset($this->page_regions[$key])) {
			unset($this->page_regions[$key]);
		}
	}

	/**
	 * Check page for no-write regions and adapt current coordinates and page margins if necessary.
	 * A no-write region is a portion of the page with a rectangular or trapezium shape that will not be covered when writing text or html code.
	 * A region is always aligned on the left or right side of the page ad is defined using a vertical segment.
	 * @param float $h height of the text/image/object to print in user units
	 * @param float $x current X coordinate in user units
	 * @param float $y current Y coordinate in user units
	 * @return float[] array($x, $y)
	 * @author Nicola Asuni
	 * @protected
	 * @since 5.9.003 (2010-10-13)
	 */
	protected function checkPageRegions($h, $x, $y) {
		// set default values
		if ($x === '') {
			$x = $this->x;
		}
		if ($y === '') {
			$y = $this->y;
		}
		if (!$this->check_page_regions OR empty($this->page_regions)) {
			// no page regions defined
			return array($x, $y);
		}
		if (empty($h)) {
			$h = $this->getCellHeight($this->FontSize);
		}
		// check for page break
		if ($this->checkPageBreak($h, $y)) {
			// the content will be printed on a new page
			$x = $this->x;
			$y = $this->y;
		}
		if ($this->num_columns > 1) {
			if ($this->rtl) {
				$this->lMargin = ($this->columns[$this->current_column]['x'] - $this->columns[$this->current_column]['w']);
			} else {
				$this->rMargin = ($this->w - $this->columns[$this->current_column]['x'] - $this->columns[$this->current_column]['w']);
			}
		} else {
			if ($this->rtl) {
				$this->lMargin = max($this->clMargin, $this->original_lMargin);
			} else {
				$this->rMargin = max($this->crMargin, $this->original_rMargin);
			}
		}
		// adjust coordinates and page margins
		foreach ($this->page_regions as $regid => $regdata) {
			if ($regdata['page'] == $this->page) {
				// check region boundaries
				if (($y > ($regdata['yt'] - $h)) AND ($y <= $regdata['yb'])) {
					// Y is inside the region
					$minv = ($regdata['xb'] - $regdata['xt']) / ($regdata['yb'] - $regdata['yt']); // inverse of angular coefficient
					$yt = max($y, $regdata['yt']);
					$yb = min(($yt + $h), $regdata['yb']);
					$xt = (($yt - $regdata['yt']) * $minv) + $regdata['xt'];
					$xb = (($yb - $regdata['yt']) * $minv) + $regdata['xt'];
					if ($regdata['side'] == 'L') { // left side
						$new_margin = max($xt, $xb);
						if ($this->lMargin < $new_margin) {
							if ($this->rtl) {
								// adjust left page margin
								$this->lMargin = max(0, $new_margin);
							}
							if ($x < $new_margin) {
								// adjust x position
								$x = $new_margin;
								if ($new_margin > ($this->w - $this->rMargin)) {
									// adjust y position
									$y = $regdata['yb'] - $h;
								}
							}
						}
					} elseif ($regdata['side'] == 'R') { // right side
						$new_margin = min($xt, $xb);
						if (($this->w - $this->rMargin) > $new_margin) {
							if (!$this->rtl) {
								// adjust right page margin
								$this->rMargin = max(0, ($this->w - $new_margin));
							}
							if ($x > $new_margin) {
								// adjust x position
								$x = $new_margin;
								if ($new_margin > $this->lMargin) {
									// adjust y position
									$y = $regdata['yb'] - $h;
								}
							}
						}
					}
				}
			}
		}
		return array($x, $y);
	}

	// --- SVG METHODS ---------------------------------------------------------

	/**
	 * Embedd a Scalable Vector Graphics (SVG) image.
	 * NOTE: SVG standard is not yet fully implemented, use the setRasterizeVectorImages() method to enable/disable rasterization of vector images using ImageMagick library.
	 * @param string $file Name of the SVG file or a '@' character followed by the SVG data string.
	 * @param float|null $x Abscissa of the upper-left corner.
	 * @param float|null $y Ordinate of the upper-left corner.
	 * @param float $w Width of the image in the page. If not specified or equal to zero, it is automatically calculated.
	 * @param float $h Height of the image in the page. If not specified or equal to zero, it is automatically calculated.
	 * @param mixed $link URL or identifier returned by AddLink().
	 * @param string $align Indicates the alignment of the pointer next to image insertion relative to image height. The value can be:<ul><li>T: top-right for LTR or top-left for RTL</li><li>M: middle-right for LTR or middle-left for RTL</li><li>B: bottom-right for LTR or bottom-left for RTL</li><li>N: next line</li></ul> If the alignment is an empty string, then the pointer will be restored on the starting SVG position.
	 * @param string $palign Allows to center or align the image on the current line. Possible values are:<ul><li>L : left align</li><li>C : center</li><li>R : right align</li><li>'' : empty string : left for LTR or right for RTL</li></ul>
	 * @param mixed $border Indicates if borders must be drawn around the cell. The value can be a number:<ul><li>0: no border (default)</li><li>1: frame</li></ul> or a string containing some or all of the following characters (in any order):<ul><li>L: left</li><li>T: top</li><li>R: right</li><li>B: bottom</li></ul> or an array of line styles for each border group - for example: array('LTRB' => array('width' => 2, 'cap' => 'butt', 'join' => 'miter', 'dash' => 0, 'color' => array(0, 0, 0)))
	 * @param boolean $fitonpage if true the image is resized to not exceed page dimensions.
	 * @author Nicola Asuni
	 * @since 5.0.000 (2010-05-02)
	 * @public
	 */
	public function ImageSVG($file, $x=null, $y=null, $w=0, $h=0, $link='', $align='', $palign='', $border=0, $fitonpage=false) {
		if ($this->state != 2) {
			 return;
		}
		// reset SVG vars
		$this->svggradients = array();
		$this->svggradientid = 0;
		$this->svgdefsmode = false;
		$this->svgdefs = array();
		$this->svgclipmode = false;
		$this->svgclippaths = array();
		$this->svgcliptm = array();
		$this->svgclipid = 0;
		$this->svgtext = '';
		$this->svgtextmode = array();
		if ($this->rasterize_vector_images AND ($w > 0) AND ($h > 0)) {
			// convert SVG to raster image using GD or ImageMagick libraries
			return $this->Image($file, $x, $y, $w, $h, 'SVG', $link, $align, true, 300, $palign, false, false, $border, false, false, false);
		}
		if ($file[0] === '@') { // image from string
			$this->svgdir = '';
			$svgdata = substr($file, 1);
		} else { // SVG file
			$this->svgdir = dirname($file);
            $svgdata = $this->getCachedFileContents($file);
		}
		if ($svgdata === FALSE) {
			$this->Error('SVG file not found: '.$file);
		}
		if (TCPDF_STATIC::empty_string($x)) {
			$x = $this->x;
		}
		if (TCPDF_STATIC::empty_string($y)) {
			$y = $this->y;
		}
		// check page for no-write regions and adapt page margins if necessary
		list($x, $y) = $this->checkPageRegions($h, $x, $y);
		$k = $this->k;
		$ox = 0;
		$oy = 0;
		$ow = $w;
		$oh = $h;
		$aspect_ratio_align = 'xMidYMid';
		$aspect_ratio_ms = 'meet';
		$regs = array();
		// get original image width and height
		preg_match('/<svg([^\>]*)>/si', $svgdata, $regs);
		if (isset($regs[1]) AND !empty($regs[1])) {
			$tmp = array();
			if (preg_match('/[\s]+x[\s]*=[\s]*""([^""]*)""/si', $regs[1], $tmp)) {
				$ox = $this->getHTMLUnitToUnits($tmp[1], 0, $this->svgunit, false);
			}
			$tmp = array();
			if (preg_match('/[\s]+y[\s]*=[\s]*""([^""]*)""/si', $regs[1], $tmp)) {
				$oy = $this->getHTMLUnitToUnits($tmp[1], 0, $this->svgunit, false);
			}
			$tmp = array();
			if (preg_match('/[\s]+width[\s]*=[\s]*""([^""]*)""/si', $regs[1], $tmp)) {
				$ow = $this->getHTMLUnitToUnits($tmp[1], 1, $this->svgunit, false);
			}
			$tmp = array();
			if (preg_match('/[\s]+height[\s]*=[\s]*""([^""]*)""/si', $regs[1], $tmp)) {
				$oh = $this->getHTMLUnitToUnits($tmp[1], 1, $this->svgunit, false);
			}
			$tmp = array();
			$view_box = array();
			if (preg_match('/[\s]+viewBox[\s]*=[\s]*""[\s]*([0-9\.\-]+)[\s]+([0-9\.\-]+)[\s]+([0-9\.]+)[\s]+([0-9\.]+)[\s]*""/si', $regs[1], $tmp)) {
				if (count($tmp) == 5) {
					array_shift($tmp);
					foreach ($tmp as $key => $val) {
						$view_box[$key] = $this->getHTMLUnitToUnits($val, 0, $this->svgunit, false);
					}
					$ox = $view_box[0];
					$oy = $view_box[1];
				}
				// get aspect ratio
				$tmp = array();
				if (preg_match('/[\s]+preserveAspectRatio[\s]*=[\s]*""([^""]*)""/si', $regs[1], $tmp)) {
					$aspect_ratio = preg_split('/[\s]+/si', $tmp[1]);
					switch (count($aspect_ratio)) {
						case 3: {
							$aspect_ratio_align = $aspect_ratio[1];
							$aspect_ratio_ms = $aspect_ratio[2];
							break;
						}
						case 2: {
							$aspect_ratio_align = $aspect_ratio[0];
							$aspect_ratio_ms = $aspect_ratio[1];
							break;
						}
						case 1: {
							$aspect_ratio_align = $aspect_ratio[0];
							$aspect_ratio_ms = 'meet';
							break;
						}
					}
				}
			}
		}
		if ($ow <= 0) {
			$ow = 1;
		}
		if ($oh <= 0) {
			$oh = 1;
		}
		// calculate image width and height on document
		if (($w <= 0) AND ($h <= 0)) {
			// convert image size to document unit
			$w = $ow;
			$h = $oh;
		} elseif ($w <= 0) {
			$w = $h * $ow / $oh;
		} elseif ($h <= 0) {
			$h = $w * $oh / $ow;
		}
		// fit the image on available space
		list($w, $h, $x, $y) = $this->fitBlock($w, $h, $x, $y, $fitonpage);
		if ($this->rasterize_vector_images) {
			// convert SVG to raster image using GD or ImageMagick libraries
			return $this->Image($file, $x, $y, $w, $h, 'SVG', $link, $align, true, 300, $palign, false, false, $border, false, false, false);
		}
		// set alignment
		$this->img_rb_y = $y + $h;
		// set alignment
		if ($this->rtl) {
			if ($palign == 'L') {
				$ximg = $this->lMargin;
			} elseif ($palign == 'C') {
				$ximg = ($this->w + $this->lMargin - $this->rMargin - $w) / 2;
			} elseif ($palign == 'R') {
				$ximg = $this->w - $this->rMargin - $w;
			} else {
				$ximg = $x - $w;
			}
			$this->img_rb_x = $ximg;
		} else {
			if ($palign == 'L') {
				$ximg = $this->lMargin;
			} elseif ($palign == 'C') {
				$ximg = ($this->w + $this->lMargin - $this->rMargin - $w) / 2;
			} elseif ($palign == 'R') {
				$ximg = $this->w - $this->rMargin - $w;
			} else {
				$ximg = $x;
			}
			$this->img_rb_x = $ximg + $w;
		}
		// store current graphic vars
		$gvars = $this->getGraphicVars();
		// store SVG position and scale factors
		$svgoffset_x = ($ximg - $ox) * $this->k;
		$svgoffset_y = -($y - $oy) * $this->k;
		if (isset($view_box[2]) AND ($view_box[2] > 0) AND ($view_box[3] > 0)) {
			$ow = $view_box[2];
			$oh = $view_box[3];
		} else {
			if ($ow <= 0) {
				$ow = $w;
			}
			if ($oh <= 0) {
				$oh = $h;
			}
		}
		$svgscale_x = $w / $ow;
		$svgscale_y = $h / $oh;
		// scaling and alignment
		if ($aspect_ratio_align != 'none') {
			// store current scaling values
			$svgscale_old_x = $svgscale_x;
			$svgscale_old_y = $svgscale_y;
			// force uniform scaling
			if ($aspect_ratio_ms == 'slice') {
				// the entire viewport is covered by the viewBox
				if ($svgscale_x > $svgscale_y) {
					$svgscale_y = $svgscale_x;
				} elseif ($svgscale_x < $svgscale_y) {
					$svgscale_x = $svgscale_y;
				}
			} else { // meet
				// the entire viewBox is visible within the viewport
				if ($svgscale_x < $svgscale_y) {
					$svgscale_y = $svgscale_x;
				} elseif ($svgscale_x > $svgscale_y) {
					$svgscale_x = $svgscale_y;
				}
			}
			// correct X alignment
			switch (substr($aspect_ratio_align, 1, 3)) {
				case 'Min': {
					// do nothing
					break;
				}
				case 'Max': {
					$svgoffset_x += (($w * $this->k) - ($ow * $this->k * $svgscale_x));
					break;
				}
				default:
				case 'Mid': {
					$svgoffset_x += ((($w * $this->k) - ($ow * $this->k * $svgscale_x)) / 2);
					break;
				}
			}
			// correct Y alignment
			switch (substr($aspect_ratio_align, 5)) {
				case 'Min': {
					// do nothing
					break;
				}
				case 'Max': {
					$svgoffset_y -= (($h * $this->k) - ($oh * $this->k * $svgscale_y));
					break;
				}
				default:
				case 'Mid': {
					$svgoffset_y -= ((($h * $this->k) - ($oh * $this->k * $svgscale_y)) / 2);
					break;
				}
			}
		}
		// store current page break mode
		$page_break_mode = $this->AutoPageBreak;
		$page_break_margin = $this->getBreakMargin();
		$cell_padding = $this->cell_padding;
		$this->setCellPadding(0);
		$this->setAutoPageBreak(false);
		// save the current graphic state
		$this->_out('q'.$this->epsmarker);
		// set initial clipping mask
		$this->Rect($ximg, $y, $w, $h, 'CNZ', array(), array());
		// scale and translate
		$e = $ox * $this->k * (1 - $svgscale_x);
		$f = ($this->h - $oy) * $this->k * (1 - $svgscale_y);
		$this->_out(sprintf('%F %F %F %F %F %F cm', $svgscale_x, 0, 0, $svgscale_y, ($e + $svgoffset_x), ($f + $svgoffset_y)));
		// creates a new XML parser to be used by the other XML functions
		$parser = xml_parser_create('UTF-8');
		// the following function allows to use parser inside object
		xml_set_object($parser, $this);
		// disable case-folding for this XML parser
		xml_parser_set_option($parser, XML_OPTION_CASE_FOLDING, 0);
		// sets the element handler functions for the XML parser
		xml_set_element_handler($parser, 'startSVGElementHandler', 'endSVGElementHandler');
		// sets the character data handler function for the XML parser
		xml_set_character_data_handler($parser, 'segSVGContentHandler');
		// start parsing an XML document
		if (!xml_parse($parser, $svgdata)) {
			$error_message = sprintf('SVG Error: %s at line %d', xml_error_string(xml_get_error_code($parser)), xml_get_current_line_number($parser));
			$this->Error($error_message);
		}
		// free this XML parser
		xml_parser_free($parser);

		// >= PHP 7.0.0 ""explicitly unset the reference to parser to avoid memory leaks""
		unset($parser);

		// restore previous graphic state
		$this->_out($this->epsmarker.'Q');
		// restore graphic vars
		$this->setGraphicVars($gvars);
		$this->lasth = $gvars['lasth'];
		if (!empty($border)) {
			$bx = $this->x;
			$by = $this->y;
			$this->x = $ximg;
			if ($this->rtl) {
				$this->x += $w;
			}
			$this->y = $y;
			$this->Cell($w, $h, '', $border, 0, '', 0, '', 0, true);
			$this->x = $bx;
			$this->y = $by;
		}
		if ($link) {
			$this->Link($ximg, $y, $w, $h, $link, 0);
		}
		// set pointer to align the next text/objects
		switch($align) {
			case 'T':{
				$this->y = $y;
				$this->x = $this->img_rb_x;
				break;
			}
			case 'M':{
				$this->y = $y + round($h/2);
				$this->x = $this->img_rb_x;
				break;
			}
			case 'B':{
				$this->y = $this->img_rb_y;
				$this->x = $this->img_rb_x;
				break;
			}
			case 'N':{
				$this->setY($this->img_rb_y);
				break;
			}
			default:{
				// restore pointer to starting position
				$this->x = $gvars['x'];
				$this->y = $gvars['y'];
				$this->page = $gvars['page'];
				$this->current_column = $gvars['current_column'];
				$this->tMargin = $gvars['tMargin'];
				$this->bMargin = $gvars['bMargin'];
				$this->w = $gvars['w'];
				$this->h = $gvars['h'];
				$this->wPt = $gvars['wPt'];
				$this->hPt = $gvars['hPt'];
				$this->fwPt = $gvars['fwPt'];
				$this->fhPt = $gvars['fhPt'];
				break;
			}
		}
		$this->endlinex = $this->img_rb_x;
		// restore page break
		$this->setAutoPageBreak($page_break_mode, $page_break_margin);
		$this->cell_padding = $cell_padding;
	}

	/**
	 * Convert SVG transformation matrix to PDF.
	 * @param array $tm original SVG transformation matrix
	 * @return array transformation matrix
	 * @protected
	 * @since 5.0.000 (2010-05-02)
	 */
	protected function convertSVGtMatrix($tm) {
		$a = $tm[0];
		$b = -$tm[1];
		$c = -$tm[2];
		$d = $tm[3];
		$e = $this->getHTMLUnitToUnits($tm[4], 1, $this->svgunit, false) * $this->k;
		$f = -$this->getHTMLUnitToUnits($tm[5], 1, $this->svgunit, false) * $this->k;
		$x = 0;
		$y = $this->h * $this->k;
		$e = ($x * (1 - $a)) - ($y * $c) + $e;
		$f = ($y * (1 - $d)) - ($x * $b) + $f;
		return array($a, $b, $c, $d, $e, $f);
	}

	/**
	 * Apply SVG graphic transformation matrix.
	 * @param array $tm original SVG transformation matrix
	 * @protected
	 * @since 5.0.000 (2010-05-02)
	 */
	protected function SVGTransform($tm) {
		$this->Transform($this->convertSVGtMatrix($tm));
	}

	/**
	 * Apply the requested SVG styles (*** TO BE COMPLETED ***)
	 * @param array $svgstyle array of SVG styles to apply
	 * @param array $prevsvgstyle array of previous SVG style
	 * @param int $x X origin of the bounding box
	 * @param int $y Y origin of the bounding box
	 * @param int $w width of the bounding box
	 * @param int $h height of the bounding box
	 * @param string $clip_function clip function
	 * @param array $clip_params array of parameters for clipping function
	 * @return string style
	 * @author Nicola Asuni
	 * @since 5.0.000 (2010-05-02)
	 * @protected
	 */
	protected function setSVGStyles($svgstyle, $prevsvgstyle, $x=0, $y=0, $w=1, $h=1, $clip_function='', $clip_params=array()) {
		if ($this->state != 2) {
			 return;
		}
		$objstyle = '';
		$minlen = (0.01 / $this->k); // minimum acceptable length
		if (!isset($svgstyle['opacity'])) {
			return $objstyle;
		}
		// clip-path
		$regs = array();
		if (preg_match('/url\([\s]*\#([^\)]*)\)/si', $svgstyle['clip-path'], $regs)) {
			$clip_path = $this->svgclippaths[$regs[1]];
			foreach ($clip_path as $cp) {
				$this->startSVGElementHandler('clip-path', $cp['name'], $cp['attribs'], $cp['tm']);
			}
		}
		// opacity
		if ($svgstyle['opacity'] != 1) {
			$this->setAlpha($svgstyle['opacity'], 'Normal', $svgstyle['opacity'], false);
		}
		// color
		$fill_color = TCPDF_COLORS::convertHTMLColorToDec($svgstyle['color'], $this->spot_colors);
		$this->setFillColorArray($fill_color);
		// text color
		$text_color = TCPDF_COLORS::convertHTMLColorToDec($svgstyle['text-color'], $this->spot_colors);
		$this->setTextColorArray($text_color);
		// clip
		if (preg_match('/rect\(([a-z0-9\-\.]*)[\s]*([a-z0-9\-\.]*)[\s]*([a-z0-9\-\.]*)[\s]*([a-z0-9\-\.]*)\)/si', $svgstyle['clip'], $regs)) {
			$top = (isset($regs[1])?$this->getHTMLUnitToUnits($regs[1], 0, $this->svgunit, false):0);
			$right = (isset($regs[2])?$this->getHTMLUnitToUnits($regs[2], 0, $this->svgunit, false):0);
			$bottom = (isset($regs[3])?$this->getHTMLUnitToUnits($regs[3], 0, $this->svgunit, false):0);
			$left = (isset($regs[4])?$this->getHTMLUnitToUnits($regs[4], 0, $this->svgunit, false):0);
			$cx = $x + $left;
			$cy = $y + $top;
			$cw = $w - $left - $right;
			$ch = $h - $top - $bottom;
			if ($svgstyle['clip-rule'] == 'evenodd') {
				$clip_rule = 'CNZ';
			} else {
				$clip_rule = 'CEO';
			}
			$this->Rect($cx, $cy, $cw, $ch, $clip_rule, array(), array());
		}
		// fill
		$regs = array();
		if (preg_match('/url\([\s]*\#([^\)]*)\)/si', $svgstyle['fill'], $regs)) {
			// gradient
			$gradient = $this->svggradients[$regs[1]];
			if (isset($gradient['xref'])) {
				// reference to another gradient definition
				$newgradient = $this->svggradients[$gradient['xref']];
				$newgradient['coords'] = $gradient['coords'];
				$newgradient['mode'] = $gradient['mode'];
				$newgradient['type'] = $gradient['type'];
				$newgradient['gradientUnits'] = $gradient['gradientUnits'];
				if (isset($gradient['gradientTransform'])) {
					$newgradient['gradientTransform'] = $gradient['gradientTransform'];
				}
				$gradient = $newgradient;
			}
			//save current Graphic State
			$this->_outSaveGraphicsState();
			//set clipping area
			if (!empty($clip_function) AND method_exists($this, $clip_function)) {
				$bbox = call_user_func_array(array($this, $clip_function), $clip_params);
				if ((!isset($gradient['type']) OR ($gradient['type'] != 3)) AND is_array($bbox) AND (count($bbox) == 4)) {
					list($x, $y, $w, $h) = $bbox;
				}
			}
			if ($gradient['mode'] == 'measure') {
				if (!isset($gradient['coords'][4])) {
					$gradient['coords'][4] = 0.5;
				}
				if (isset($gradient['gradientTransform']) AND !empty($gradient['gradientTransform'])) {
					$gtm = $gradient['gradientTransform'];
					// apply transformation matrix
					$xa = ($gtm[0] * $gradient['coords'][0]) + ($gtm[2] * $gradient['coords'][1]) + $gtm[4];
					$ya = ($gtm[1] * $gradient['coords'][0]) + ($gtm[3] * $gradient['coords'][1]) + $gtm[5];
					$xb = ($gtm[0] * $gradient['coords'][2]) + ($gtm[2] * $gradient['coords'][3]) + $gtm[4];
					$yb = ($gtm[1] * $gradient['coords'][2]) + ($gtm[3] * $gradient['coords'][3]) + $gtm[5];
					$r = sqrt(pow(($gtm[0] * $gradient['coords'][4]), 2) + pow(($gtm[1] * $gradient['coords'][4]), 2));
					$gradient['coords'][0] = $xa;
					$gradient['coords'][1] = $ya;
					$gradient['coords'][2] = $xb;
					$gradient['coords'][3] = $yb;
					$gradient['coords'][4] = $r;
				}
				// convert SVG coordinates to user units
				$gradient['coords'][0] = $this->getHTMLUnitToUnits($gradient['coords'][0], 0, $this->svgunit, false);
				$gradient['coords'][1] = $this->getHTMLUnitToUnits($gradient['coords'][1], 0, $this->svgunit, false);
				$gradient['coords'][2] = $this->getHTMLUnitToUnits($gradient['coords'][2], 0, $this->svgunit, false);
				$gradient['coords'][3] = $this->getHTMLUnitToUnits($gradient['coords'][3], 0, $this->svgunit, false);
				$gradient['coords'][4] = $this->getHTMLUnitToUnits($gradient['coords'][4], 0, $this->svgunit, false);
				if ($w <= $minlen) {
					$w = $minlen;
				}
				if ($h <= $minlen) {
					$h = $minlen;
				}
				// shift units
				if ($gradient['gradientUnits'] == 'objectBoundingBox') {
					// convert to SVG coordinate system
					$gradient['coords'][0] += $x;
					$gradient['coords'][1] += $y;
					$gradient['coords'][2] += $x;
					$gradient['coords'][3] += $y;
				}
				// calculate percentages
				$gradient['coords'][0] = (($gradient['coords'][0] - $x) / $w);
				$gradient['coords'][1] = (($gradient['coords'][1] - $y) / $h);
				$gradient['coords'][2] = (($gradient['coords'][2] - $x) / $w);
				$gradient['coords'][3] = (($gradient['coords'][3] - $y) / $h);
				$gradient['coords'][4] /= $w;
			} elseif ($gradient['mode'] == 'percentage') {
				foreach($gradient['coords'] as $key => $val) {
					$gradient['coords'][$key] = (intval($val) / 100);
					if ($val < 0) {
						$gradient['coords'][$key] = 0;
					} elseif ($val > 1) {
						$gradient['coords'][$key] = 1;
					}
				}
			}
			if (($gradient['type'] == 2) AND ($gradient['coords'][0] == $gradient['coords'][2]) AND ($gradient['coords'][1] == $gradient['coords'][3])) {
				// single color (no shading)
				$gradient['coords'][0] = 1;
				$gradient['coords'][1] = 0;
				$gradient['coords'][2] = 0.999;
				$gradient['coords'][3] = 0;
			}
			// swap Y coordinates
			$tmp = $gradient['coords'][1];
			$gradient['coords'][1] = $gradient['coords'][3];
			$gradient['coords'][3] = $tmp;
			// set transformation map for gradient
			$cy = ($this->h - $y);
			if ($gradient['type'] == 3) {
				// circular gradient
				$cy -= ($gradient['coords'][1] * ($w + $h));
				$h = $w = max($w, $h);
			} else {
				$cy -= $h;
			}
			$this->_out(sprintf('%F 0 0 %F %F %F cm', ($w * $this->k), ($h * $this->k), ($x * $this->k), ($cy * $this->k)));
			if (count($gradient['stops']) > 1) {
				$this->Gradient($gradient['type'], $gradient['coords'], $gradient['stops'], array(), false);
			}
		} elseif ($svgstyle['fill'] != 'none') {
			$fill_color = TCPDF_COLORS::convertHTMLColorToDec($svgstyle['fill'], $this->spot_colors);
			if ($svgstyle['fill-opacity'] != 1) {
				$this->setAlpha($this->alpha['CA'], 'Normal', $svgstyle['fill-opacity'], false);
			}
			$this->setFillColorArray($fill_color);
			if ($svgstyle['fill-rule'] == 'evenodd') {
				$objstyle .= 'F*';
			} else {
				$objstyle .= 'F';
			}
		}
		// stroke
		if ($svgstyle['stroke'] != 'none') {
			if ($svgstyle['stroke-opacity'] != 1) {
				$this->setAlpha($svgstyle['stroke-opacity'], 'Normal', $this->alpha['ca'], false);
			} elseif (preg_match('/rgba\(\d+%?,\s*\d+%?,\s*\d+%?,\s*(\d+(?:\.\d+)?)\)/i', $svgstyle['stroke'], $rgba_matches)) {
				$this->setAlpha($rgba_matches[1], 'Normal', $this->alpha['ca'], false);
			}
			$stroke_style = array(
				'color' => TCPDF_COLORS::convertHTMLColorToDec($svgstyle['stroke'], $this->spot_colors),
				'width' => $this->getHTMLUnitToUnits($svgstyle['stroke-width'], 0, $this->svgunit, false),
				'cap' => $svgstyle['stroke-linecap'],
				'join' => $svgstyle['stroke-linejoin']
				);
			if (isset($svgstyle['stroke-dasharray']) AND !empty($svgstyle['stroke-dasharray']) AND ($svgstyle['stroke-dasharray'] != 'none')) {
				$stroke_style['dash'] = $svgstyle['stroke-dasharray'];
			}
			$this->setLineStyle($stroke_style);
			$objstyle .= 'D';
		}
		// font
		$regs = array();
		if (!empty($svgstyle['font'])) {
			if (preg_match('/font-family[\s]*:[\s]*([^\;\""]*)/si', $svgstyle['font'], $regs)) {
				$font_family = $this->getFontFamilyName($regs[1]);
			} else {
				$font_family = $svgstyle['font-family'];
			}
			if (preg_match('/font-size[\s]*:[\s]*([^\s\;\""]*)/si', $svgstyle['font'], $regs)) {
				$font_size = trim($regs[1]);
			} else {
				$font_size = $svgstyle['font-size'];
			}
			if (preg_match('/font-style[\s]*:[\s]*([^\s\;\""]*)/si', $svgstyle['font'], $regs)) {
				$font_style = trim($regs[1]);
			} else {
				$font_style = $svgstyle['font-style'];
			}
			if (preg_match('/font-weight[\s]*:[\s]*([^\s\;\""]*)/si', $svgstyle['font'], $regs)) {
				$font_weight = trim($regs[1]);
			} else {
				$font_weight = $svgstyle['font-weight'];
			}
			if (preg_match('/font-stretch[\s]*:[\s]*([^\s\;\""]*)/si', $svgstyle['font'], $regs)) {
				$font_stretch = trim($regs[1]);
			} else {
				$font_stretch = $svgstyle['font-stretch'];
			}
			if (preg_match('/letter-spacing[\s]*:[\s]*([^\s\;\""]*)/si', $svgstyle['font'], $regs)) {
				$font_spacing = trim($regs[1]);
			} else {
				$font_spacing = $svgstyle['letter-spacing'];
			}
		} else {
			$font_family = $this->getFontFamilyName($svgstyle['font-family']);
			$font_size = $svgstyle['font-size'];
			$font_style = $svgstyle['font-style'];
			$font_weight = $svgstyle['font-weight'];
			$font_stretch = $svgstyle['font-stretch'];
			$font_spacing = $svgstyle['letter-spacing'];
		}
		$font_size = $this->getHTMLFontUnits($font_size, $this->svgstyles[0]['font-size'], $prevsvgstyle['font-size'], $this->svgunit);
		$font_stretch = $this->getCSSFontStretching($font_stretch, $svgstyle['font-stretch']);
		$font_spacing = $this->getCSSFontSpacing($font_spacing, $svgstyle['letter-spacing']);
		switch ($font_style) {
			case 'italic': {
				$font_style = 'I';
				break;
			}
			case 'oblique': {
				$font_style = 'I';
				break;
			}
			default:
			case 'normal': {
				$font_style = '';
				break;
			}
		}
		switch ($font_weight) {
			case 'bold':
			case 'bolder': {
				$font_style .= 'B';
				break;
			}
			case 'normal': {
				if ((substr($font_family, -1) == 'I') AND (substr($font_family, -2, 1) == 'B')) {
					$font_family = substr($font_family, 0, -2).'I';
				} elseif (substr($font_family, -1) == 'B') {
					$font_family = substr($font_family, 0, -1);
				}
				break;
			}
		}
		switch ($svgstyle['text-decoration']) {
			case 'underline': {
				$font_style .= 'U';
				break;
			}
			case 'overline': {
				$font_style .= 'O';
				break;
			}
			case 'line-through': {
				$font_style .= 'D';
				break;
			}
			default:
			case 'none': {
				break;
			}
		}
		$this->setFont($font_family, $font_style, $font_size);
		$this->setFontStretching($font_stretch);
		$this->setFontSpacing($font_spacing);
		return $objstyle;
	}

	/**
	 * Draws an SVG path
	 * @param string $d attribute d of the path SVG element
	 * @param string $style Style of rendering. Possible values are:
	 * <ul>
	 *	 <li>D or empty string: Draw (default).</li>
	 *	 <li>F: Fill.</li>
	 *	 <li>F*: Fill using the even-odd rule to determine which regions lie inside the clipping path.</li>
	 *	 <li>DF or FD: Draw and fill.</li>
	 *	 <li>DF* or FD*: Draw and fill using the even-odd rule to determine which regions lie inside the clipping path.</li>
	 *	 <li>CNZ: Clipping mode (using the even-odd rule to determine which regions lie inside the clipping path).</li>
	 *	 <li>CEO: Clipping mode (using the nonzero winding number rule to determine which regions lie inside the clipping path).</li>
	 * </ul>
	 * @return array of container box measures (x, y, w, h)
	 * @author Nicola Asuni
	 * @since 5.0.000 (2010-05-02)
	 * @protected
	 */
	protected function SVGPath($d, $style='') {
		if ($this->state != 2) {
			return;
		}
		// set fill/stroke style
		$op = TCPDF_STATIC::getPathPaintOperator($style, '');
		if (empty($op)) {
			return;
		}
		$paths = array();
		$d = preg_replace('/([0-9ACHLMQSTVZ])([\-\+])/si', '\\1 \\2', $d);
		$d = preg_replace('/(\.[0-9]+)(\.)/s', '\\1 \\2', $d);
		preg_match_all('/([ACHLMQSTVZ])[\s]*([^ACHLMQSTVZ\""]*)/si', $d, $paths, PREG_SET_ORDER);
		$x = 0;
		$y = 0;
		$x1 = 0;
		$y1 = 0;
		$x2 = 0;
		$y2 = 0;
		$xmin = 2147483647;
		$xmax = 0;
		$ymin = 2147483647;
		$ymax = 0;
		$xinitial = 0;
		$yinitial = 0;
		$relcoord = false;
		$minlen = (0.01 / $this->k); // minimum acceptable length (3 point)
		$firstcmd = true; // used to print first point
		// draw curve pieces
		foreach ($paths as $key => $val) {
			// get curve type
			$cmd = trim($val[1]);
			if (strtolower($cmd) == $cmd) {
				// use relative coordinated instead of absolute
				$relcoord = true;
				$xoffset = $x;
				$yoffset = $y;
			} else {
				$relcoord = false;
				$xoffset = 0;
				$yoffset = 0;
			}
			$params = array();
			if (isset($val[2])) {
				// get curve parameters
				$rawparams = preg_split('/([\,\s]+)/si', trim($val[2]));
				$params = array();
				foreach ($rawparams as $ck => $cp) {
					$params[$ck] = $this->getHTMLUnitToUnits($cp, 0, $this->svgunit, false);
					if (abs($params[$ck]) < $minlen) {
						// approximate little values to zero
						$params[$ck] = 0;
					}
				}
			}
			// store current origin point
			$x0 = $x;
			$y0 = $y;
			switch (strtoupper($cmd)) {
				case 'M': { // moveto
					foreach ($params as $ck => $cp) {
						if (($ck % 2) == 0) {
							$x = $cp + $xoffset;
						} else {
							$y = $cp + $yoffset;
							if ($firstcmd OR (abs($x0 - $x) >= $minlen) OR (abs($y0 - $y) >= $minlen)) {
								if ($ck == 1) {
									$this->_outPoint($x, $y);
									$firstcmd = false;
									$xinitial = $x;
									$yinitial = $y;
								} else {
									$this->_outLine($x, $y);
								}
								$x0 = $x;
								$y0 = $y;
							}
							$xmin = min($xmin, $x);
							$ymin = min($ymin, $y);
							$xmax = max($xmax, $x);
							$ymax = max($ymax, $y);
							if ($relcoord) {
								$xoffset = $x;
								$yoffset = $y;
							}
						}
					}
					break;
				}
				case 'L': { // lineto
					foreach ($params as $ck => $cp) {
						if (($ck % 2) == 0) {
							$x = $cp + $xoffset;
						} else {
							$y = $cp + $yoffset;
							if ((abs($x0 - $x) >= $minlen) OR (abs($y0 - $y) >= $minlen)) {
								$this->_outLine($x, $y);
								$x0 = $x;
								$y0 = $y;
							}
							$xmin = min($xmin, $x);
							$ymin = min($ymin, $y);
							$xmax = max($xmax, $x);
							$ymax = max($ymax, $y);
							if ($relcoord) {
								$xoffset = $x;
								$yoffset = $y;
							}
						}
					}
					break;
				}
				case 'H': { // horizontal lineto
					foreach ($params as $ck => $cp) {
						$x = $cp + $xoffset;
						if ((abs($x0 - $x) >= $minlen) OR (abs($y0 - $y) >= $minlen)) {
							$this->_outLine($x, $y);
							$x0 = $x;
							$y0 = $y;
						}
						$xmin = min($xmin, $x);
						$xmax = max($xmax, $x);
						if ($relcoord) {
							$xoffset = $x;
						}
					}
					break;
				}
				case 'V': { // vertical lineto
					foreach ($params as $ck => $cp) {
						$y = $cp + $yoffset;
						if ((abs($x0 - $x) >= $minlen) OR (abs($y0 - $y) >= $minlen)) {
							$this->_outLine($x, $y);
							$x0 = $x;
							$y0 = $y;
						}
						$ymin = min($ymin, $y);
						$ymax = max($ymax, $y);
						if ($relcoord) {
							$yoffset = $y;
						}
					}
					break;
				}
				case 'C': { // curveto
					foreach ($params as $ck => $cp) {
						$params[$ck] = $cp;
						if ((($ck + 1) % 6) == 0) {
							$x1 = $params[($ck - 5)] + $xoffset;
							$y1 = $params[($ck - 4)] + $yoffset;
							$x2 = $params[($ck - 3)] + $xoffset;
							$y2 = $params[($ck - 2)] + $yoffset;
							$x = $params[($ck - 1)] + $xoffset;
							$y = $params[($ck)] + $yoffset;
							$this->_outCurve($x1, $y1, $x2, $y2, $x, $y);
							$xmin = min($xmin, $x, $x1, $x2);
							$ymin = min($ymin, $y, $y1, $y2);
							$xmax = max($xmax, $x, $x1, $x2);
							$ymax = max($ymax, $y, $y1, $y2);
							if ($relcoord) {
								$xoffset = $x;
								$yoffset = $y;
							}
						}
					}
					break;
				}
				case 'S': { // shorthand/smooth curveto
					foreach ($params as $ck => $cp) {
						$params[$ck] = $cp;
						if ((($ck + 1) % 4) == 0) {
							if (($key > 0) AND ((strtoupper($paths[($key - 1)][1]) == 'C') OR (strtoupper($paths[($key - 1)][1]) == 'S'))) {
								$x1 = (2 * $x) - $x2;
								$y1 = (2 * $y) - $y2;
							} else {
								$x1 = $x;
								$y1 = $y;
							}
							$x2 = $params[($ck - 3)] + $xoffset;
							$y2 = $params[($ck - 2)] + $yoffset;
							$x = $params[($ck - 1)] + $xoffset;
							$y = $params[($ck)] + $yoffset;
							$this->_outCurve($x1, $y1, $x2, $y2, $x, $y);
							$xmin = min($xmin, $x, $x1, $x2);
							$ymin = min($ymin, $y, $y1, $y2);
							$xmax = max($xmax, $x, $x1, $x2);
							$ymax = max($ymax, $y, $y1, $y2);
							if ($relcoord) {
								$xoffset = $x;
								$yoffset = $y;
							}
						}
					}
					break;
				}
				case 'Q': { // quadratic Bezier curveto
					foreach ($params as $ck => $cp) {
						$params[$ck] = $cp;
						if ((($ck + 1) % 4) == 0) {
							// convert quadratic points to cubic points
							$x1 = $params[($ck - 3)] + $xoffset;
							$y1 = $params[($ck - 2)] + $yoffset;
							$xa = ($x + (2 * $x1)) / 3;
							$ya = ($y + (2 * $y1)) / 3;
							$x = $params[($ck - 1)] + $xoffset;
							$y = $params[($ck)] + $yoffset;
							$xb = ($x + (2 * $x1)) / 3;
							$yb = ($y + (2 * $y1)) / 3;
							$this->_outCurve($xa, $ya, $xb, $yb, $x, $y);
							$xmin = min($xmin, $x, $xa, $xb);
							$ymin = min($ymin, $y, $ya, $yb);
							$xmax = max($xmax, $x, $xa, $xb);
							$ymax = max($ymax, $y, $ya, $yb);
							if ($relcoord) {
								$xoffset = $x;
								$yoffset = $y;
							}
						}
					}
					break;
				}
				case 'T': { // shorthand/smooth quadratic Bezier curveto
					foreach ($params as $ck => $cp) {
						$params[$ck] = $cp;
						if (($ck % 2) != 0) {
							if (($key > 0) AND ((strtoupper($paths[($key - 1)][1]) == 'Q') OR (strtoupper($paths[($key - 1)][1]) == 'T'))) {
								$x1 = (2 * $x) - $x1;
								$y1 = (2 * $y) - $y1;
							} else {
								$x1 = $x;
								$y1 = $y;
							}
							// convert quadratic points to cubic points
							$xa = ($x + (2 * $x1)) / 3;
							$ya = ($y + (2 * $y1)) / 3;
							$x = $params[($ck - 1)] + $xoffset;
							$y = $params[($ck)] + $yoffset;
							$xb = ($x + (2 * $x1)) / 3;
							$yb = ($y + (2 * $y1)) / 3;
							$this->_outCurve($xa, $ya, $xb, $yb, $x, $y);
							$xmin = min($xmin, $x, $xa, $xb);
							$ymin = min($ymin, $y, $ya, $yb);
							$xmax = max($xmax, $x, $xa, $xb);
							$ymax = max($ymax, $y, $ya, $yb);
							if ($relcoord) {
								$xoffset = $x;
								$yoffset = $y;
							}
						}
					}
					break;
				}
				case 'A': { // elliptical arc
					foreach ($params as $ck => $cp) {
						$params[$ck] = $cp;
						if ((($ck + 1) % 7) == 0) {
							$x0 = $x;
							$y0 = $y;
							$rx = max(abs($params[($ck - 6)]), .000000001);
							$ry = max(abs($params[($ck - 5)]), .000000001);
							$ang = -$rawparams[($ck - 4)];
							$angle = deg2rad($ang);
							$fa = $rawparams[($ck - 3)]; // large-arc-flag
							$fs = $rawparams[($ck - 2)]; // sweep-flag
							$x = $params[($ck - 1)] + $xoffset;
							$y = $params[$ck] + $yoffset;
							if ((abs($x0 - $x) < $minlen) AND (abs($y0 - $y) < $minlen)) {
								// endpoints are almost identical
								$xmin = min($xmin, $x);
								$ymin = min($ymin, $y);
								$xmax = max($xmax, $x);
								$ymax = max($ymax, $y);
							} else {
								$cos_ang = cos($angle);
								$sin_ang = sin($angle);
								$a = (($x0 - $x) / 2);
								$b = (($y0 - $y) / 2);
								$xa = ($a * $cos_ang) - ($b * $sin_ang);
								$ya = ($a * $sin_ang) + ($b * $cos_ang);
								$rx2 = $rx * $rx;
								$ry2 = $ry * $ry;
								$xa2 = $xa * $xa;
								$ya2 = $ya * $ya;
								$delta = ($xa2 / $rx2) + ($ya2 / $ry2);
								if ($delta > 1) {
									$rx *= sqrt($delta);
									$ry *= sqrt($delta);
									$rx2 = $rx * $rx;
									$ry2 = $ry * $ry;
								}
								$numerator = (($rx2 * $ry2) - ($rx2 * $ya2) - ($ry2 * $xa2));
								if ($numerator < 0) {
									$root = 0;
								} else {
									$root = sqrt($numerator / (($rx2 * $ya2) + ($ry2 * $xa2)));
								}
								if ($fa == $fs){
									$root *= -1;
								}
								$cax = $root * (($rx * $ya) / $ry);
								$cay = -$root * (($ry * $xa) / $rx);
								// coordinates of ellipse center
								$cx = ($cax * $cos_ang) - ($cay * $sin_ang) + (($x0 + $x) / 2);
								$cy = ($cax * $sin_ang) + ($cay * $cos_ang) + (($y0 + $y) / 2);
								// get angles
								$angs = TCPDF_STATIC::getVectorsAngle(1, 0, (($xa - $cax) / $rx), (($cay - $ya) / $ry));
								$dang = TCPDF_STATIC::getVectorsAngle((($xa - $cax) / $rx), (($ya - $cay) / $ry), ((-$xa - $cax) / $rx), ((-$ya - $cay) / $ry));
								if (($fs == 0) AND ($dang > 0)) {
									$dang -= (2 * M_PI);
								} elseif (($fs == 1) AND ($dang < 0)) {
									$dang += (2 * M_PI);
								}
								$angf = $angs - $dang;
								if ((($fs == 0) AND ($angs > $angf)) OR (($fs == 1) AND ($angs < $angf))) {
									// reverse angles
									$tmp = $angs;
									$angs = $angf;
									$angf = $tmp;
								}
								$angs = round(rad2deg($angs), 6);
								$angf = round(rad2deg($angf), 6);
								// covent angles to positive values
								if (($angs < 0) AND ($angf < 0)) {
									$angs += 360;
									$angf += 360;
								}
								$pie = false;
								if (($key == 0) AND (isset($paths[($key + 1)][1])) AND (trim($paths[($key + 1)][1]) == 'z')) {
									$pie = true;
								}
								list($axmin, $aymin, $axmax, $aymax) = $this->_outellipticalarc($cx, $cy, $rx, $ry, $ang, $angs, $angf, $pie, 2, false, ($fs == 0), true);
								$xmin = min($xmin, $x, $axmin);
								$ymin = min($ymin, $y, $aymin);
								$xmax = max($xmax, $x, $axmax);
								$ymax = max($ymax, $y, $aymax);
							}
							if ($relcoord) {
								$xoffset = $x;
								$yoffset = $y;
							}
						}
					}
					break;
				}
				case 'Z': {
					$this->_out('h');
					$x = $x0 = $xinitial;
					$y = $y0 = $yinitial;
					break;
				}
			}
			$firstcmd = false;
		} // end foreach
		$this->_out($op);
		return array($xmin, $ymin, ($xmax - $xmin), ($ymax - $ymin));
	}

	/**
	 * Return the tag name without the namespace
	 * @param string $name Tag name
	 * @protected
	 */
	protected function removeTagNamespace($name) {
		if(strpos($name, ':') !== false) {
			$parts = explode(':', $name);
			return $parts[(sizeof($parts) - 1)];
		}
		return $name;
	}

	/**
	 * Sets the opening SVG element handler function for the XML parser. (*** TO BE COMPLETED ***)
	 * @param resource|string $parser The first parameter, parser, is a reference to the XML parser calling the handler.
	 * @param string $name The second parameter, name, contains the name of the element for which this handler is called. If case-folding is in effect for this parser, the element name will be in uppercase letters.
	 * @param array $attribs The third parameter, attribs, contains an associative array with the element's attributes (if any). The keys of this array are the attribute names, the values are the attribute values. Attribute names are case-folded on the same criteria as element names. Attribute values are not case-folded. The original order of the attributes can be retrieved by walking through attribs the normal way, using each(). The first key in the array was the first attribute, and so on.
	 * @param array $ctm tranformation matrix for clipping mode (starting transformation matrix).
	 * @author Nicola Asuni
	 * @since 5.0.000 (2010-05-02)
	 * @protected
	 */
	protected function startSVGElementHandler($parser, $name, $attribs, $ctm=array()) {
		$name = $this->removeTagNamespace($name);
		// check if we are in clip mode
		if ($this->svgclipmode) {
			$this->svgclippaths[$this->svgclipid][] = array('name' => $name, 'attribs' => $attribs, 'tm' => $this->svgcliptm[$this->svgclipid]);
			return;
		}
		if ($this->svgdefsmode AND !in_array($name, array('clipPath', 'linearGradient', 'radialGradient', 'stop'))) {
			if (isset($attribs['id'])) {
				$attribs['child_elements'] = array();
				$this->svgdefs[$attribs['id']] = array('name' => $name, 'attribs' => $attribs);
				return;
			}
			if (end($this->svgdefs) !== FALSE) {
				$last_svgdefs_id = key($this->svgdefs);
				if (isset($this->svgdefs[$last_svgdefs_id]['attribs']['child_elements'])) {
					$attribs['id'] = 'DF_'.(count($this->svgdefs[$last_svgdefs_id]['attribs']['child_elements']) + 1);
					$this->svgdefs[$last_svgdefs_id]['attribs']['child_elements'][$attribs['id']] = array('name' => $name, 'attribs' => $attribs);
					return;
				}
			}
			return;
		}
		$clipping = false;
		if ($parser == 'clip-path') {
			// set clipping mode
			$clipping = true;
		}
		// get styling properties
		$prev_svgstyle = $this->svgstyles[max(0,(count($this->svgstyles) - 1))]; // previous style
		$svgstyle = $this->svgstyles[0]; // set default style
		if ($clipping AND !isset($attribs['fill']) AND (!isset($attribs['style']) OR (!preg_match('/[;\""\s]{1}fill[\s]*:[\s]*([^;\""]*)/si', $attribs['style'], $attrval)))) {
			// default fill attribute for clipping
			$attribs['fill'] = 'none';
		}
		if (isset($attribs['style']) AND !TCPDF_STATIC::empty_string($attribs['style']) AND ($attribs['style'][0] != ';')) {
			// fix style for regular expression
			$attribs['style'] = ';'.$attribs['style'];
		}
		foreach ($prev_svgstyle as $key => $val) {
			if (in_array($key, TCPDF_IMAGES::$svginheritprop)) {
				// inherit previous value
				$svgstyle[$key] = $val;
			}
			if (isset($attribs[$key]) AND !TCPDF_STATIC::empty_string($attribs[$key])) {
				// specific attribute settings
				if ($attribs[$key] == 'inherit') {
					$svgstyle[$key] = $val;
				} else {
					$svgstyle[$key] = $attribs[$key];
				}
			} elseif (isset($attribs['style']) AND !TCPDF_STATIC::empty_string($attribs['style'])) {
				// CSS style syntax
				$attrval = array();
				if (preg_match('/[;\""\s]{1}'.$key.'[\s]*:[\s]*([^;\""]*)/si', $attribs['style'], $attrval) AND isset($attrval[1])) {
					if ($attrval[1] == 'inherit') {
						$svgstyle[$key] = $val;
					} else {
						$svgstyle[$key] = $attrval[1];
					}
				}
			}
		}
		// transformation matrix
		if (!empty($ctm)) {
			$tm = $ctm;
		} else {
			$tm = array(1,0,0,1,0,0);
		}
		if (isset($attribs['transform']) AND !empty($attribs['transform'])) {
			$tm = TCPDF_STATIC::getTransformationMatrixProduct($tm, TCPDF_STATIC::getSVGTransformMatrix($attribs['transform']));
		}
		$svgstyle['transfmatrix'] = $tm;
		$invisible = false;
		if (($svgstyle['visibility'] == 'hidden') OR ($svgstyle['visibility'] == 'collapse') OR ($svgstyle['display'] == 'none')) {
			// the current graphics element is invisible (nothing is painted)
			$invisible = true;
		}
		// process tag
		switch($name) {
			case 'defs': {
				$this->svgdefsmode = true;
				break;
			}
			// clipPath
			case 'clipPath': {
				if ($invisible) {
					break;
				}
				$this->svgclipmode = true;
				if (!isset($attribs['id'])) {
					$attribs['id'] = 'CP_'.(count($this->svgcliptm) + 1);
				}
				$this->svgclipid = $attribs['id'];
				$this->svgclippaths[$this->svgclipid] = array();
				$this->svgcliptm[$this->svgclipid] = $tm;
				break;
			}
			case 'svg': {
				// start of SVG object
				if(++$this->svg_tag_depth <= 1) {
					break;
				}
				// inner SVG
				array_push($this->svgstyles, $svgstyle);
				$this->StartTransform();
				$svgX = (isset($attribs['x'])?$attribs['x']:0);
				$svgY = (isset($attribs['y'])?$attribs['y']:0);
				$svgW = (isset($attribs['width'])?$attribs['width']:0);
				$svgH = (isset($attribs['height'])?$attribs['height']:0);
				// set x, y position using transform matrix
				$tm = TCPDF_STATIC::getTransformationMatrixProduct($tm, array( 1, 0, 0, 1, $svgX, $svgY));
				$this->SVGTransform($tm);
				// set clipping for width and height
				$x = 0;
				$y = 0;
				$w = (isset($attribs['width'])?$this->getHTMLUnitToUnits($attribs['width'], 0, $this->svgunit, false):$this->w);
				$h = (isset($attribs['height'])?$this->getHTMLUnitToUnits($attribs['height'], 0, $this->svgunit, false):$this->h);
				// draw clipping rect
				$this->Rect($x, $y, $w, $h, 'CNZ', array(), array());
				// parse viewbox, calculate extra transformation matrix
				if (isset($attribs['viewBox'])) {
					$tmp = array();
					preg_match_all(""/[0-9]+/"", $attribs['viewBox'], $tmp);
					$tmp = $tmp[0];
					if (sizeof($tmp) == 4) {
						$vx = $tmp[0];
						$vy = $tmp[1];
						$vw = $tmp[2];
						$vh = $tmp[3];
						// get aspect ratio
						$tmp = array();
						$aspectX = 'xMid';
						$aspectY = 'YMid';
						$fit = 'meet';
						if (isset($attribs['preserveAspectRatio'])) {
							if($attribs['preserveAspectRatio'] == 'none') {
								$fit = 'none';
							} else {
								preg_match_all('/[a-zA-Z]+/', $attribs['preserveAspectRatio'], $tmp);
								$tmp = $tmp[0];
								if ((sizeof($tmp) == 2) AND (strlen($tmp[0]) == 8) AND (in_array($tmp[1], array('meet', 'slice', 'none')))) {
									$aspectX = substr($tmp[0], 0, 4);
									$aspectY = substr($tmp[0], 4, 4);
									$fit = $tmp[1];
								}
							}
						}
						$wr = ($svgW / $vw);
						$hr = ($svgH / $vh);
						$ax = $ay = 0;
						if ((($fit == 'meet') AND ($hr < $wr)) OR (($fit == 'slice') AND ($hr > $wr))) {
							if ($aspectX == 'xMax') {
								$ax = (($vw * ($wr / $hr)) - $vw);
							}
							if ($aspectX == 'xMid') {
								$ax = ((($vw * ($wr / $hr)) - $vw) / 2);
							}
							$wr = $hr;
						} elseif ((($fit == 'meet') AND ($hr > $wr)) OR (($fit == 'slice') AND ($hr < $wr))) {
							if ($aspectY == 'YMax') {
								$ay = (($vh * ($hr / $wr)) - $vh);
							}
							if ($aspectY == 'YMid') {
								$ay = ((($vh * ($hr / $wr)) - $vh) / 2);
							}
							$hr = $wr;
						}
						$newtm = array($wr, 0, 0, $hr, (($wr * ($ax - $vx)) - $svgX), (($hr * ($ay - $vy)) - $svgY));
						$tm = TCPDF_STATIC::getTransformationMatrixProduct($tm, $newtm);
						$this->SVGTransform($tm);
					}
				}
				$this->setSVGStyles($svgstyle, $prev_svgstyle);
				break;
			}
			case 'g': {
				// group together related graphics elements
				array_push($this->svgstyles, $svgstyle);
				$this->StartTransform();
				$x = (isset($attribs['x'])?$attribs['x']:0);
				$y = (isset($attribs['y'])?$attribs['y']:0);
				$w = 1;//(isset($attribs['width'])?$attribs['width']:1);
				$h = 1;//(isset($attribs['height'])?$attribs['height']:1);
				$tm = TCPDF_STATIC::getTransformationMatrixProduct($tm, array($w, 0, 0, $h, $x, $y));
				$this->SVGTransform($tm);
				$this->setSVGStyles($svgstyle, $prev_svgstyle);
				break;
			}
			case 'linearGradient': {
				if ($this->pdfa_mode && $this->pdfa_version < 2) {
					break;
				}
				if (!isset($attribs['id'])) {
					$attribs['id'] = 'GR_'.(count($this->svggradients) + 1);
				}
				$this->svggradientid = $attribs['id'];
				$this->svggradients[$this->svggradientid] = array();
				$this->svggradients[$this->svggradientid]['type'] = 2;
				$this->svggradients[$this->svggradientid]['stops'] = array();
				if (isset($attribs['gradientUnits'])) {
					$this->svggradients[$this->svggradientid]['gradientUnits'] = $attribs['gradientUnits'];
				} else {
					$this->svggradients[$this->svggradientid]['gradientUnits'] = 'objectBoundingBox';
				}
				//$attribs['spreadMethod']
				if (((!isset($attribs['x1'])) AND (!isset($attribs['y1'])) AND (!isset($attribs['x2'])) AND (!isset($attribs['y2'])))
					OR ((isset($attribs['x1']) AND (substr($attribs['x1'], -1) == '%'))
						OR (isset($attribs['y1']) AND (substr($attribs['y1'], -1) == '%'))
						OR (isset($attribs['x2']) AND (substr($attribs['x2'], -1) == '%'))
						OR (isset($attribs['y2']) AND (substr($attribs['y2'], -1) == '%')))) {
					$this->svggradients[$this->svggradientid]['mode'] = 'percentage';
				} else {
					$this->svggradients[$this->svggradientid]['mode'] = 'measure';
				}
				$x1 = (isset($attribs['x1'])?$attribs['x1']:'0');
				$y1 = (isset($attribs['y1'])?$attribs['y1']:'0');
				$x2 = (isset($attribs['x2'])?$attribs['x2']:'100');
				$y2 = (isset($attribs['y2'])?$attribs['y2']:'0');
				if (isset($attribs['gradientTransform'])) {
					$this->svggradients[$this->svggradientid]['gradientTransform'] = TCPDF_STATIC::getSVGTransformMatrix($attribs['gradientTransform']);
				}
				$this->svggradients[$this->svggradientid]['coords'] = array($x1, $y1, $x2, $y2);
				if (isset($attribs['xlink:href']) AND !empty($attribs['xlink:href'])) {
					// gradient is defined on another place
					$this->svggradients[$this->svggradientid]['xref'] = substr($attribs['xlink:href'], 1);
				}
				break;
			}
			case 'radialGradient': {
				if ($this->pdfa_mode && $this->pdfa_version < 2) {
					break;
				}
				if (!isset($attribs['id'])) {
					$attribs['id'] = 'GR_'.(count($this->svggradients) + 1);
				}
				$this->svggradientid = $attribs['id'];
				$this->svggradients[$this->svggradientid] = array();
				$this->svggradients[$this->svggradientid]['type'] = 3;
				$this->svggradients[$this->svggradientid]['stops'] = array();
				if (isset($attribs['gradientUnits'])) {
					$this->svggradients[$this->svggradientid]['gradientUnits'] = $attribs['gradientUnits'];
				} else {
					$this->svggradients[$this->svggradientid]['gradientUnits'] = 'objectBoundingBox';
				}
				//$attribs['spreadMethod']
				if (((!isset($attribs['cx'])) AND (!isset($attribs['cy'])))
					OR ((isset($attribs['cx']) AND (substr($attribs['cx'], -1) == '%'))
					OR (isset($attribs['cy']) AND (substr($attribs['cy'], -1) == '%')))) {
					$this->svggradients[$this->svggradientid]['mode'] = 'percentage';
				} elseif (isset($attribs['r']) AND is_numeric($attribs['r']) AND ($attribs['r']) <= 1) {
					$this->svggradients[$this->svggradientid]['mode'] = 'ratio';
				} else {
					$this->svggradients[$this->svggradientid]['mode'] = 'measure';
				}
				$cx = (isset($attribs['cx']) ? $attribs['cx'] : 0.5);
				$cy = (isset($attribs['cy']) ? $attribs['cy'] : 0.5);
				$fx = (isset($attribs['fx']) ? $attribs['fx'] : $cx);
				$fy = (isset($attribs['fy']) ? $attribs['fy'] : $cy);
				$r = (isset($attribs['r']) ? $attribs['r'] : 0.5);
				if (isset($attribs['gradientTransform'])) {
					$this->svggradients[$this->svggradientid]['gradientTransform'] = TCPDF_STATIC::getSVGTransformMatrix($attribs['gradientTransform']);
				}
				$this->svggradients[$this->svggradientid]['coords'] = array($cx, $cy, $fx, $fy, $r);
				if (isset($attribs['xlink:href']) AND !empty($attribs['xlink:href'])) {
					// gradient is defined on another place
					$this->svggradients[$this->svggradientid]['xref'] = substr($attribs['xlink:href'], 1);
				}
				break;
			}
			case 'stop': {
				// gradient stops
				if (substr($attribs['offset'], -1) == '%') {
					$offset = floatval(substr($attribs['offset'], 0, -1)) / 100;
				} else {
					$offset = floatval($attribs['offset']);
					if ($offset > 1) {
						$offset /= 100;
					}
				}
				$stop_color = isset($svgstyle['stop-color'])?TCPDF_COLORS::convertHTMLColorToDec($svgstyle['stop-color'], $this->spot_colors):'black';
				$opacity = isset($svgstyle['stop-opacity'])?$svgstyle['stop-opacity']:1;
				$this->svggradients[$this->svggradientid]['stops'][] = array('offset' => $offset, 'color' => $stop_color, 'opacity' => $opacity);
				break;
			}
			// paths
			case 'path': {
				if ($invisible) {
					break;
				}
				if (isset($attribs['d'])) {
					$d = trim($attribs['d']);
					if (!empty($d)) {
						$x = (isset($attribs['x'])?$attribs['x']:0);
						$y = (isset($attribs['y'])?$attribs['y']:0);
						$w = (isset($attribs['width'])?$attribs['width']:1);
						$h = (isset($attribs['height'])?$attribs['height']:1);
						$tm = TCPDF_STATIC::getTransformationMatrixProduct($tm, array($w, 0, 0, $h, $x, $y));
						if ($clipping) {
							$this->SVGTransform($tm);
							$this->SVGPath($d, 'CNZ');
						} else {
							$this->StartTransform();
							$this->SVGTransform($tm);
							$obstyle = $this->setSVGStyles($svgstyle, $prev_svgstyle, $x, $y, $w, $h, 'SVGPath', array($d, 'CNZ'));
							if (!empty($obstyle)) {
								$this->SVGPath($d, $obstyle);
							}
							$this->StopTransform();
						}
					}
				}
				break;
			}
			// shapes
			case 'rect': {
				if ($invisible) {
					break;
				}
				$x = (isset($attribs['x'])?$this->getHTMLUnitToUnits($attribs['x'], 0, $this->svgunit, false):0);
				$y = (isset($attribs['y'])?$this->getHTMLUnitToUnits($attribs['y'], 0, $this->svgunit, false):0);
				$w = (isset($attribs['width'])?$this->getHTMLUnitToUnits($attribs['width'], 0, $this->svgunit, false):0);
				$h = (isset($attribs['height'])?$this->getHTMLUnitToUnits($attribs['height'], 0, $this->svgunit, false):0);
				$rx = (isset($attribs['rx'])?$this->getHTMLUnitToUnits($attribs['rx'], 0, $this->svgunit, false):0);
				$ry = (isset($attribs['ry'])?$this->getHTMLUnitToUnits($attribs['ry'], 0, $this->svgunit, false):$rx);
				if ($clipping) {
					$this->SVGTransform($tm);
					$this->RoundedRectXY($x, $y, $w, $h, $rx, $ry, '1111', 'CNZ', array(), array());
				} else {
					$this->StartTransform();
					$this->SVGTransform($tm);
					$obstyle = $this->setSVGStyles($svgstyle, $prev_svgstyle, $x, $y, $w, $h, 'RoundedRectXY', array($x, $y, $w, $h, $rx, $ry, '1111', 'CNZ'));
					if (!empty($obstyle)) {
						$this->RoundedRectXY($x, $y, $w, $h, $rx, $ry, '1111', $obstyle, array(), array());
					}
					$this->StopTransform();
				}
				break;
			}
			case 'circle': {
				if ($invisible) {
					break;
				}
				$r = (isset($attribs['r']) ? $this->getHTMLUnitToUnits($attribs['r'], 0, $this->svgunit, false) : 0);
				$cx = (isset($attribs['cx']) ? $this->getHTMLUnitToUnits($attribs['cx'], 0, $this->svgunit, false) : (isset($attribs['x']) ? $this->getHTMLUnitToUnits($attribs['x'], 0, $this->svgunit, false) : 0));
				$cy = (isset($attribs['cy']) ? $this->getHTMLUnitToUnits($attribs['cy'], 0, $this->svgunit, false) : (isset($attribs['y']) ? $this->getHTMLUnitToUnits($attribs['y'], 0, $this->svgunit, false) : 0));
				$x = ($cx - $r);
				$y = ($cy - $r);
				$w = (2 * $r);
				$h = $w;
				if ($clipping) {
					$this->SVGTransform($tm);
					$this->Circle($cx, $cy, $r, 0, 360, 'CNZ', array(), array(), 8);
				} else {
					$this->StartTransform();
					$this->SVGTransform($tm);
					$obstyle = $this->setSVGStyles($svgstyle, $prev_svgstyle, $x, $y, $w, $h, 'Circle', array($cx, $cy, $r, 0, 360, 'CNZ'));
					if (!empty($obstyle)) {
						$this->Circle($cx, $cy, $r, 0, 360, $obstyle, array(), array(), 8);
					}
					$this->StopTransform();
				}
				break;
			}
			case 'ellipse': {
				if ($invisible) {
					break;
				}
				$rx = (isset($attribs['rx']) ? $this->getHTMLUnitToUnits($attribs['rx'], 0, $this->svgunit, false) : 0);
				$ry = (isset($attribs['ry']) ? $this->getHTMLUnitToUnits($attribs['ry'], 0, $this->svgunit, false) : 0);
				$cx = (isset($attribs['cx']) ? $this->getHTMLUnitToUnits($attribs['cx'], 0, $this->svgunit, false) : (isset($attribs['x']) ? $this->getHTMLUnitToUnits($attribs['x'], 0, $this->svgunit, false) : 0));
				$cy = (isset($attribs['cy']) ? $this->getHTMLUnitToUnits($attribs['cy'], 0, $this->svgunit, false) : (isset($attribs['y']) ? $this->getHTMLUnitToUnits($attribs['y'], 0, $this->svgunit, false) : 0));
				$x = ($cx - $rx);
				$y = ($cy - $ry);
				$w = (2 * $rx);
				$h = (2 * $ry);
				if ($clipping) {
					$this->SVGTransform($tm);
					$this->Ellipse($cx, $cy, $rx, $ry, 0, 0, 360, 'CNZ', array(), array(), 8);
				} else {
					$this->StartTransform();
					$this->SVGTransform($tm);
					$obstyle = $this->setSVGStyles($svgstyle, $prev_svgstyle, $x, $y, $w, $h, 'Ellipse', array($cx, $cy, $rx, $ry, 0, 0, 360, 'CNZ'));
					if (!empty($obstyle)) {
						$this->Ellipse($cx, $cy, $rx, $ry, 0, 0, 360, $obstyle, array(), array(), 8);
					}
					$this->StopTransform();
				}
				break;
			}
			case 'line': {
				if ($invisible) {
					break;
				}
				$x1 = (isset($attribs['x1'])?$this->getHTMLUnitToUnits($attribs['x1'], 0, $this->svgunit, false):0);
				$y1 = (isset($attribs['y1'])?$this->getHTMLUnitToUnits($attribs['y1'], 0, $this->svgunit, false):0);
				$x2 = (isset($attribs['x2'])?$this->getHTMLUnitToUnits($attribs['x2'], 0, $this->svgunit, false):0);
				$y2 = (isset($attribs['y2'])?$this->getHTMLUnitToUnits($attribs['y2'], 0, $this->svgunit, false):0);
				$x = $x1;
				$y = $y1;
				$w = abs($x2 - $x1);
				$h = abs($y2 - $y1);
				if (!$clipping) {
					$this->StartTransform();
					$this->SVGTransform($tm);
					$obstyle = $this->setSVGStyles($svgstyle, $prev_svgstyle, $x, $y, $w, $h, 'Line', array($x1, $y1, $x2, $y2));
					$this->Line($x1, $y1, $x2, $y2);
					$this->StopTransform();
				}
				break;
			}
			case 'polyline':
			case 'polygon': {
				if ($invisible) {
					break;
				}
				$points = (isset($attribs['points'])?$attribs['points']:'0 0');
				$points = trim($points);
				// note that point may use a complex syntax not covered here
				$points = preg_split('/[\,\s]+/si', $points);
				if (count($points) < 4) {
					break;
				}
				$p = array();
				$xmin = 2147483647;
				$xmax = 0;
				$ymin = 2147483647;
				$ymax = 0;
				foreach ($points as $key => $val) {
					$p[$key] = $this->getHTMLUnitToUnits($val, 0, $this->svgunit, false);
					if (($key % 2) == 0) {
						// X coordinate
						$xmin = min($xmin, $p[$key]);
						$xmax = max($xmax, $p[$key]);
					} else {
						// Y coordinate
						$ymin = min($ymin, $p[$key]);
						$ymax = max($ymax, $p[$key]);
					}
				}
				$x = $xmin;
				$y = $ymin;
				$w = ($xmax - $xmin);
				$h = ($ymax - $ymin);
				if ($name == 'polyline') {
					$this->StartTransform();
					$this->SVGTransform($tm);
					$obstyle = $this->setSVGStyles($svgstyle, $prev_svgstyle, $x, $y, $w, $h, 'PolyLine', array($p, 'CNZ'));
					if (!empty($obstyle)) {
						$this->PolyLine($p, $obstyle, array(), array());
					}
					$this->StopTransform();
				} else { // polygon
					if ($clipping) {
						$this->SVGTransform($tm);
						$this->Polygon($p, 'CNZ', array(), array(), true);
					} else {
						$this->StartTransform();
						$this->SVGTransform($tm);
						$obstyle = $this->setSVGStyles($svgstyle, $prev_svgstyle, $x, $y, $w, $h, 'Polygon', array($p, 'CNZ'));
						if (!empty($obstyle)) {
							$this->Polygon($p, $obstyle, array(), array(), true);
						}
						$this->StopTransform();
					}
				}
				break;
			}
			// image
			case 'image': {
				if ($invisible) {
					break;
				}
				if (!isset($attribs['xlink:href']) OR empty($attribs['xlink:href'])) {
					break;
				}
				$x = (isset($attribs['x'])?$this->getHTMLUnitToUnits($attribs['x'], 0, $this->svgunit, false):0);
				$y = (isset($attribs['y'])?$this->getHTMLUnitToUnits($attribs['y'], 0, $this->svgunit, false):0);
				$w = (isset($attribs['width'])?$this->getHTMLUnitToUnits($attribs['width'], 0, $this->svgunit, false):0);
				$h = (isset($attribs['height'])?$this->getHTMLUnitToUnits($attribs['height'], 0, $this->svgunit, false):0);
				$img = $attribs['xlink:href'];
				if (!$clipping) {
					$this->StartTransform();
					$this->SVGTransform($tm);
					$obstyle = $this->setSVGStyles($svgstyle, $prev_svgstyle, $x, $y, $w, $h);
					if (preg_match('/^data:image\/[^;]+;base64,/', $img, $m) > 0) {
						// embedded image encoded as base64
						$img = '@'.base64_decode(substr($img, strlen($m[0])));
					} else {
						// fix image path
						if (!TCPDF_STATIC::empty_string($this->svgdir) AND (($img[0] == '.') OR (basename($img) == $img))) {
							// replace relative path with full server path
							$img = $this->svgdir.'/'.$img;
						}
						if (($img[0] == '/') AND !empty($_SERVER['DOCUMENT_ROOT']) AND ($_SERVER['DOCUMENT_ROOT'] != '/')) {
							$findroot = strpos($img, $_SERVER['DOCUMENT_ROOT']);
							if (($findroot === false) OR ($findroot > 1)) {
								if (substr($_SERVER['DOCUMENT_ROOT'], -1) == '/') {
									$img = substr($_SERVER['DOCUMENT_ROOT'], 0, -1).$img;
								} else {
									$img = $_SERVER['DOCUMENT_ROOT'].$img;
								}
							}
						}
						$img = urldecode($img);
						$testscrtype = @parse_url($img);
						if (empty($testscrtype['query'])) {
							// convert URL to server path
							$img = str_replace(K_PATH_URL, K_PATH_MAIN, $img);
						} elseif (preg_match('|^https?://|', $img) !== 1) {
							// convert server path to URL
							$img = str_replace(K_PATH_MAIN, K_PATH_URL, $img);
						}
					}
					// get image type
					$imgtype = TCPDF_IMAGES::getImageFileType($img);
					if (($imgtype == 'eps') OR ($imgtype == 'ai')) {
						$this->ImageEps($img, $x, $y, $w, $h);
					} elseif ($imgtype == 'svg') {
						// store SVG vars
						$svggradients = $this->svggradients;
						$svggradientid = $this->svggradientid;
						$svgdefsmode = $this->svgdefsmode;
						$svgdefs = $this->svgdefs;
						$svgclipmode = $this->svgclipmode;
						$svgclippaths = $this->svgclippaths;
						$svgcliptm = $this->svgcliptm;
						$svgclipid = $this->svgclipid;
						$svgtext = $this->svgtext;
						$svgtextmode = $this->svgtextmode;
						$this->ImageSVG($img, $x, $y, $w, $h);
						// restore SVG vars
						$this->svggradients = $svggradients;
						$this->svggradientid = $svggradientid;
						$this->svgdefsmode = $svgdefsmode;
						$this->svgdefs = $svgdefs;
						$this->svgclipmode = $svgclipmode;
						$this->svgclippaths = $svgclippaths;
						$this->svgcliptm = $svgcliptm;
						$this->svgclipid = $svgclipid;
						$this->svgtext = $svgtext;
						$this->svgtextmode = $svgtextmode;
					} else {
						$this->Image($img, $x, $y, $w, $h);
					}
					$this->StopTransform();
				}
				break;
			}
			// text
			case 'text':
			case 'tspan': {
				if (isset($this->svgtextmode['text-anchor']) AND !empty($this->svgtext)) {
					// @TODO: unsupported feature
				}
				// only basic support - advanced features must be implemented
				$this->svgtextmode['invisible'] = $invisible;
				if ($invisible) {
					break;
				}
				array_push($this->svgstyles, $svgstyle);
				if (isset($attribs['x'])) {
					$x = $this->getHTMLUnitToUnits($attribs['x'], 0, $this->svgunit, false);
				} elseif ($name == 'tspan') {
					$x = $this->x;
				} else {
					$x = 0;
				}
				if (isset($attribs['dx'])) {
					$x += $this->getHTMLUnitToUnits($attribs['dx'], 0, $this->svgunit, false);
				}
				if (isset($attribs['y'])) {
					$y = $this->getHTMLUnitToUnits($attribs['y'], 0, $this->svgunit, false);
				} elseif ($name == 'tspan') {
					$y = $this->y;
				} else {
					$y = 0;
				}
				if (isset($attribs['dy'])) {
					$y += $this->getHTMLUnitToUnits($attribs['dy'], 0, $this->svgunit, false);
				}
				$svgstyle['text-color'] = $svgstyle['fill'];
				$this->svgtext = '';
				if (isset($svgstyle['text-anchor'])) {
					$this->svgtextmode['text-anchor'] = $svgstyle['text-anchor'];
				} else {
					$this->svgtextmode['text-anchor'] = 'start';
				}
				if (isset($svgstyle['direction'])) {
					if ($svgstyle['direction'] == 'rtl') {
						$this->svgtextmode['rtl'] = true;
					} else {
						$this->svgtextmode['rtl'] = false;
					}
				} else {
					$this->svgtextmode['rtl'] = false;
				}
				if (isset($svgstyle['stroke']) AND ($svgstyle['stroke'] != 'none') AND isset($svgstyle['stroke-width']) AND ($svgstyle['stroke-width'] > 0)) {
					$this->svgtextmode['stroke'] = $this->getHTMLUnitToUnits($svgstyle['stroke-width'], 0, $this->svgunit, false);
				} else {
					$this->svgtextmode['stroke'] = false;
				}
				$this->StartTransform();
				$this->SVGTransform($tm);
				$obstyle = $this->setSVGStyles($svgstyle, $prev_svgstyle, $x, $y, 1, 1);
				$this->x = $x;
				$this->y = $y;
				break;
			}
			// use
			case 'use': {
				if (isset($attribs['xlink:href']) AND !empty($attribs['xlink:href'])) {
					$svgdefid = substr($attribs['xlink:href'], 1);
					if (isset($this->svgdefs[$svgdefid])) {
						$use = $this->svgdefs[$svgdefid];
						if (isset($attribs['xlink:href'])) {
							unset($attribs['xlink:href']);
						}
						if (isset($attribs['id'])) {
							unset($attribs['id']);
						}
						if (isset($use['attribs']['x']) AND isset($attribs['x'])) {
							$attribs['x'] += $use['attribs']['x'];
						}
						if (isset($use['attribs']['y']) AND isset($attribs['y'])) {
							$attribs['y'] += $use['attribs']['y'];
						}
						if (empty($attribs['style'])) {
							$attribs['style'] = '';
						}
						if (!empty($use['attribs']['style'])) {
							// merge styles
							$attribs['style'] = str_replace(';;',';',';'.$use['attribs']['style'].$attribs['style']);
						}
						$attribs = array_merge($use['attribs'], $attribs);
						$this->startSVGElementHandler($parser, $use['name'], $attribs);
						return;
					}
				}
				break;
			}
			default: {
				break;
			}
		} // end of switch
		// process child elements
		if (!empty($attribs['child_elements'])) {
			$child_elements = $attribs['child_elements'];
			unset($attribs['child_elements']);
			foreach($child_elements as $child_element) {
				if (empty($child_element['attribs']['closing_tag'])) {
					$this->startSVGElementHandler('child-tag', $child_element['name'], $child_element['attribs']);
				} else {
					if (isset($child_element['attribs']['content'])) {
						$this->svgtext = $child_element['attribs']['content'];
					}
					$this->endSVGElementHandler('child-tag', $child_element['name']);
				}
			}
		}
	}

	/**
	 * Sets the closing SVG element handler function for the XML parser.
	 * @param resource|string $parser The first parameter, parser, is a reference to the XML parser calling the handler.
	 * @param string $name The second parameter, name, contains the name of the element for which this handler is called. If case-folding is in effect for this parser, the element name will be in uppercase letters.
	 * @author Nicola Asuni
	 * @since 5.0.000 (2010-05-02)
	 * @protected
	 */
	protected function endSVGElementHandler($parser, $name) {
		$name = $this->removeTagNamespace($name);
		if ($this->svgdefsmode AND !in_array($name, array('defs', 'clipPath', 'linearGradient', 'radialGradient', 'stop'))) {;
			if (end($this->svgdefs) !== FALSE) {
				$last_svgdefs_id = key($this->svgdefs);
				if (isset($this->svgdefs[$last_svgdefs_id]['attribs']['child_elements'])) {
					foreach($this->svgdefs[$last_svgdefs_id]['attribs']['child_elements'] as $child_element) {
						if (isset($child_element['attribs']['id']) AND ($child_element['name'] == $name)) {
							$this->svgdefs[$last_svgdefs_id]['attribs']['child_elements'][$child_element['attribs']['id'].'_CLOSE'] = array('name' => $name, 'attribs' => array('closing_tag' => TRUE, 'content' => $this->svgtext));
							return;
						}
					}
					if ($this->svgdefs[$last_svgdefs_id]['name'] == $name) {
						$this->svgdefs[$last_svgdefs_id]['attribs']['child_elements'][$last_svgdefs_id.'_CLOSE'] = array('name' => $name, 'attribs' => array('closing_tag' => TRUE, 'content' => $this->svgtext));
						return;
					}
				}
			}
			return;
		}
		switch($name) {
			case 'defs': {
				$this->svgdefsmode = false;
				break;
			}
			// clipPath
			case 'clipPath': {
				$this->svgclipmode = false;
				break;
			}
			case 'svg': {
				if (--$this->svg_tag_depth <= 0) {
					break;
				}
			}
			case 'g': {
				// ungroup: remove last style from array
				array_pop($this->svgstyles);
				$this->StopTransform();
				break;
			}
			case 'text':
			case 'tspan': {
				if ($this->svgtextmode['invisible']) {
					// This implementation must be fixed to following the rule:
					// If the 'visibility' property is set to hidden on a 'tspan', 'tref' or 'altGlyph' element, then the text is invisible but still takes up space in text layout calculations.
					break;
				}
				// print text
				$text = $this->svgtext;
				//$text = $this->stringTrim($text);
				$textlen = $this->GetStringWidth($text);
				if ($this->svgtextmode['text-anchor'] != 'start') {
					// check if string is RTL text
					if ($this->svgtextmode['text-anchor'] == 'end') {
						if ($this->svgtextmode['rtl']) {
							$this->x += $textlen;
						} else {
							$this->x -= $textlen;
						}
					} elseif ($this->svgtextmode['text-anchor'] == 'middle') {
						if ($this->svgtextmode['rtl']) {
							$this->x += ($textlen / 2);
						} else {
							$this->x -= ($textlen / 2);
						}
					}
				}
				$textrendermode = $this->textrendermode;
				$textstrokewidth = $this->textstrokewidth;
				$this->setTextRenderingMode($this->svgtextmode['stroke'], true, false);
				if ($name == 'text') {
					// store current coordinates
					$tmpx = $this->x;
					$tmpy = $this->y;
				}
				// print the text
				$this->Cell($textlen, 0, $text, 0, 0, '', false, '', 0, false, 'L', 'T');
				if ($name == 'text') {
					// restore coordinates
					$this->x = $tmpx;
					$this->y = $tmpy;
				}
				// restore previous rendering mode
				$this->textrendermode = $textrendermode;
				$this->textstrokewidth = $textstrokewidth;
				$this->svgtext = '';
				$this->StopTransform();
				if (!$this->svgdefsmode) {
					array_pop($this->svgstyles);
				}
				break;
			}
			default: {
				break;
			}
		}
	}

	/**
	 * Sets the character data handler function for the XML parser.
	 * @param resource $parser The first parameter, parser, is a reference to the XML parser calling the handler.
	 * @param string $data The second parameter, data, contains the character data as a string.
	 * @author Nicola Asuni
	 * @since 5.0.000 (2010-05-02)
	 * @protected
	 */
	protected function segSVGContentHandler($parser, $data) {
		$this->svgtext .= $data;
	}

	// --- END SVG METHODS -----------------------------------------------------

    /**
     * Keeps files in memory, so it doesn't need to downloaded everytime in a loop
     * @param string $file
     * @return string
     */
    protected function getCachedFileContents($file)
    {
        if (!isset($this->fileContentCache[$file])) {
            $this->fileContentCache[$file] = TCPDF_STATIC::fileGetContents($file);
        }
        return $this->fileContentCache[$file];
    }

    /**
     * Avoid multiple calls to an external server to see if a file exists
     * @param string $file
     * @return bool
     */
    protected function fileExists($file)
    {
        if (isset($this->fileContentCache[$file]) || false !== $this->getImageBuffer($file)) {
            return true;
        }

        return TCPDF_STATIC::file_exists($file);
    }

} // END OF TCPDF CLASS

//============================================================+
// END OF FILE
//============================================================+
",0
"function raw_output($output = '')
{
    echo $output;
    die();
}",1
"    public function getBlockLengthInBytes()
    {
        return $this->block_size;
    }",0
"            $file = Url::assemble($location, $name);
            if (File::exists($file)) {
                $svg = StaticStringy::collapseWhitespace(
                    File::get($file)
                );
                break;
            }
        }

        $attributes = $this->renderAttributesFromParams(['src', 'title', 'desc']);

        if ($this->params->get('title') || $this->params->get('desc')) {
            $svg = $this->setTitleAndDesc($svg);
        }

        return str_replace(
            '<svg',
            collect(['<svg', $attributes])->filter()->implode(' '),
            $svg
        );
    }",1
"    public static function requireDER()
    {
        self::$format = self::MODE_DER;
    }",0
"            $controller_object = cmsCore::getController($controller_name);

            foreach ($hooks as $event_name) {

                $hook_class_name = 'on' . string_to_camel('_', $controller_name) . string_to_camel('_', $event_name);

                $hook_object = new $hook_class_name($controller_object);

                // Некоторые хуки не требуют регистрации в базе данных,
                // Например, хуки для CRON или иные, которые вызываются напрямую
                // Свойство $disallow_event_db_register в классе хука регулирует это поведение
                if(empty($hook_object->disallow_event_db_register)){

                    $events[$controller_name][$index] = $event_name;

                    $index++;
                }
            }
        }

        return $events;
    }",1
"    public function column_name($item)
    {
        /**
         * Sanitize the input
         */
        $page = sanitize_text_field($_REQUEST['page']);

        //Build row actions
        $actions = array(
            'edit'   => sprintf('<a href=""#"" onclick=""wp_sms_edit_subscriber(%s)"">' . __('Edit', 'wp-sms') . '</a>', $item['ID']),
            'delete' => sprintf('<a href=""?page=%s&action=%s&ID=%s"">' . __('Delete', 'wp-sms') . '</a>', $page, 'delete', $item['ID']),
        );

        //Return the title contents
        return sprintf('%1$s %3$s',
            /*$1%s*/
            esc_html($item['name']),
            /*$2%s*/
            $item['ID'],
            /*$2%s*/
            $this->row_actions($actions)
        );
    }",1
"    private function assertSuccess(array $result)
    {
        $errors = $result['errors'] ?? [];
        if (!empty($errors)) {
            $this->fail('Failed to assert successful query. Got errors: ' . json_encode($errors, JSON_PRETTY_PRINT));
        }
        $error = $result['error'] ?? null;
        if ($error) {
            $this->fail('Failed to assert successful query. Got error: ' . $error);
        }
    }",1
"    public static function savePrivateKey(BigInteger $n, BigInteger $e, BigInteger $d, array $primes, array $exponents, array $coefficients, $password = '', array $options = [])
    {
        if (count($primes) != 2) {
            throw new \InvalidArgumentException('PuTTY does not support multi-prime RSA keys');
        }

        $public =  Strings::packSSH2('ii', $e, $n);
        $private = Strings::packSSH2('iiii', $d, $primes[1], $primes[2], $coefficients[2]);

        return self::wrapPrivateKey($public, $private, 'ssh-rsa', $password, $options);
    }",0
"    public function toBytes($twos_compliment = false)
    {
        if ($twos_compliment) {
            return $this->toBytesHelper();
        }

        if (!count($this->value)) {
            return $this->precision > 0 ? str_repeat(chr(0), ($this->precision + 1) >> 3) : '';
        }

        $result = $this->bitwise_small_split(8);
        $result = implode('', array_map('chr', $result));

        return $this->precision > 0 ?
            str_pad(
                substr($result, -(($this->precision + 7) >> 3)),
                ($this->precision + 7) >> 3,
                chr(0),
                STR_PAD_LEFT
            ) :
            $result;
    }",0
"    public static function redirect(
        $url
    ) {
        /*
         * If the headers have been sent, then we cannot send an additional location header
         * so we will output a javascript redirect statement.
         */
        
        if (!empty($_REQUEST['ajax_load'])) {
            ob_get_clean();
            $ajax_ret = array(
                'content' => ""<script>SUGAR.ajaxUI.loadContent('$url');</script>\n"",
                'menu' => array(
                    'module' => $_REQUEST['module'],
                    'label' => translate($_REQUEST['module']),
                ),
            );
            $json = getJSONobj();
            echo $json->encode($ajax_ret);
        } else {
            if (headers_sent()) {
                echo ""<script>SUGAR.ajaxUI.loadContent('$url');</script>\n"";
            } else {
                //@ob_end_clean(); // clear output buffer
                session_write_close();
                header('HTTP/1.1 301 Moved Permanently');
                header(""Location: "" . $url);
            }
        }
        if (!defined('SUITE_PHPUNIT_RUNNER')) {
            exit();
        }
    }",1
"    public function error()
    {
        if ($this->lastError4 === $this->lastError6) {
            $message = $this->lastError6;
        } elseif ($this->lastErrorFamily === 6) {
            $message = 'Last error for IPv6: ' . $this->lastError6 . '. Previous error for IPv4: ' . $this->lastError4;
        } else {
            $message = 'Last error for IPv4: ' . $this->lastError4 . '. Previous error for IPv6: ' . $this->lastError6;
        }

        if ($this->hasBeenResolved() && $this->ipsCount === 0) {
            if ($this->lastError6 === $this->lastError4) {
                $message = ' during DNS lookup: ' . $this->lastError6;
            } else {
                $message = ' during DNS lookup. ' . $message;
            }
        } else {
            $message = ': ' . $message;
        }

        return 'Connection to ' . $this->uri . ' failed'  . $message;
    }",0
"function angeltype_controller()
{
    $user = auth()->user();

    if (!auth()->can('angeltypes')) {
        throw_redirect(page_link_to('/'));
    }

    $angeltype = AngelType::findOrFail(request()->input('angeltype_id'));
    /** @var UserAngelType $user_angeltype */
    $user_angeltype = UserAngelType::whereUserId($user->id)->where('angel_type_id', $angeltype->id)->first();
    $members = $angeltype->userAngelTypes->sortBy('name', SORT_NATURAL | SORT_FLAG_CASE);
    $days = angeltype_controller_shiftsFilterDays($angeltype);
    $shiftsFilter = angeltype_controller_shiftsFilter($angeltype, $days);
    if (request()->input('showFilledShifts')) {
        $shiftsFilter->setFilled([ShiftsFilter::FILLED_FREE, ShiftsFilter::FILLED_FILLED]);
    }

    $shiftsFilterRenderer = new ShiftsFilterRenderer($shiftsFilter);
    $shiftsFilterRenderer->enableDaySelection($days);

    $shiftCalendarRenderer = shiftCalendarRendererByShiftFilter($shiftsFilter);
    $request = request();
    $tab = 0;

    if ($request->has('shifts_filter_day') || $request->has('showShiftsTab')) {
        $tab = 1;
    }

    $isSupporter = !is_null($user_angeltype) && $user_angeltype->supporter;
    return [
        sprintf(__('Team %s'), $angeltype->name),
        AngelType_view(
            $angeltype,
            $members,
            $user_angeltype,
            auth()->can('admin_user_angeltypes') || $isSupporter,
            auth()->can('admin_angel_types'),
            $isSupporter,
            $user->license,
            $user,
            $shiftsFilterRenderer,
            $shiftCalendarRenderer,
            $tab
        ),
    ];
}",1
"    public function verify($message, $signature)
    {
        if ($this->curve instanceof MontgomeryCurve) {
            throw new UnsupportedOperationException('Montgomery Curves cannot be used to create signatures');
        }

        $shortFormat = $this->shortFormat;
        $format = $this->sigFormat;
        if ($format === false) {
            return false;
        }

        $order = $this->curve->getOrder();

        if ($this->curve instanceof TwistedEdwardsCurve) {
            if ($shortFormat == 'SSH2') {
                list(, $signature) = Strings::unpackSSH2('ss', $signature);
            }

            if ($this->curve instanceof Ed25519 && self::$engines['libsodium'] && !isset($this->context)) {
                return sodium_crypto_sign_verify_detached($signature, $message, $this->toString('libsodium'));
            }

            $curve = $this->curve;
            if (strlen($signature) != 2 * $curve::SIZE) {
                return false;
            }

            $R = substr($signature, 0, $curve::SIZE);
            $S = substr($signature, $curve::SIZE);

            try {
                $R = PKCS1::extractPoint($R, $curve);
                $R = $this->curve->convertToInternal($R);
            } catch (\Exception $e) {
                return false;
            }

            $S = strrev($S);
            $S = new BigInteger($S, 256);

            if ($S->compare($order) >= 0) {
                return false;
            }

            $A = $curve->encodePoint($this->QA);

            if ($curve instanceof Ed25519) {
                $dom2 = !isset($this->context) ? '' :
                    'SigEd25519 no Ed25519 collisions' . ""\0"" . chr(strlen($this->context)) . $this->context;
            } else {
                $context = isset($this->context) ? $this->context : '';
                $dom2 = 'SigEd448' . ""\0"" . chr(strlen($context)) . $context;
            }

            $hash = new Hash($curve::HASH);
            $k = $hash->hash($dom2 . substr($signature, 0, $curve::SIZE) . $A . $message);
            $k = strrev($k);
            $k = new BigInteger($k, 256);
            list(, $k) = $k->divide($order);

            $qa = $curve->convertToInternal($this->QA);

            $lhs = $curve->multiplyPoint($curve->getBasePoint(), $S);
            $rhs = $curve->multiplyPoint($qa, $k);
            $rhs = $curve->addPoint($rhs, $R);
            $rhs = $curve->convertToAffine($rhs);

            return $lhs[0]->equals($rhs[0]) && $lhs[1]->equals($rhs[1]);
        }

        $params = $format::load($signature);
        if ($params === false || count($params) != 2) {
            return false;
        }
        extract($params);

        if (self::$engines['OpenSSL'] && in_array($this->hash->getHash(), openssl_get_md_methods())) {
            $sig = $format != 'ASN1' ? ASN1Signature::save($r, $s) : $signature;

            $result = openssl_verify($message, $sig, $this->toString('PKCS8', ['namedCurve' => false]), $this->hash->getHash());

            if ($result != -1) {
                return (bool) $result;
            }
        }

        $n_1 = $order->subtract(self::$one);
        if (!$r->between(self::$one, $n_1) || !$s->between(self::$one, $n_1)) {
            return false;
        }

        $e = $this->hash->hash($message);
        $e = new BigInteger($e, 256);

        $Ln = $this->hash->getLength() - $order->getLength();
        $z = $Ln > 0 ? $e->bitwise_rightShift($Ln) : $e;

        $w = $s->modInverse($order);
        list(, $u1) = $z->multiply($w)->divide($order);
        list(, $u2) = $r->multiply($w)->divide($order);

        $u1 = $this->curve->convertInteger($u1);
        $u2 = $this->curve->convertInteger($u2);

        list($x1, $y1) = $this->curve->multiplyAddPoints(
            [$this->curve->getBasePoint(), $this->QA],
            [$u1, $u2]
        );

        $x1 = $x1->toBigInteger();
        list(, $x1) = $x1->divide($order);

        return $x1->equals($r);
    }",0
"    public function setAll(array $messages)
    {
        $this->flashes = $messages;
    }",0
"    public function getAdvancedResultSet($q, $values, $per_page = 100)
    {
        $page = $page = $_GET['page'] ?? 1;
        $per_page = $_GET['per_page'] ?? $per_page;

        $offset = ($page - 1) * $per_page;
        $q = str_replace('SELECT ', 'SELECT SQL_CALC_FOUND_ROWS ', $q);
        $q .= sprintf(' LIMIT %s,%s', $offset, $per_page);
        $result = $this->di['db']->getAll($q, $values);
        $total = $this->di['db']->getCell('SELECT FOUND_ROWS();');

        $pages = ($per_page > 1) ? (int)ceil($total / $per_page) : 1;
        return array(
            ""pages""             => $pages,
            ""page""              => $page,
            ""per_page""          => $per_page,
            ""total""             => $total,
            ""list""              => $result,
        );
    }",1
"	public function testUserSessionNoTimestamp()
	{
		$session = $this->app->session();
		$session->set('kirby.userId', 'homer');

		$this->assertNull($this->auth->user());
		$this->assertSame([
			'challenge' => null,
			'email'     => null,
			'status'    => 'inactive'
		], $this->auth->status()->toArray());

		// user should be logged out completely
		$this->assertSame([], $session->data()->get());
	}",0
"    private function renderShiftHead(Shift $shift, $class, $needed_angeltypes_count)
    {
        $header_buttons = '';
        if (auth()->can('admin_shifts')) {
            $header_buttons = '<div class=""ms-auto d-print-none"">' . table_buttons([
                    button(
                        page_link_to('user_shifts', ['edit_shift' => $shift->id]),
                        icon('pencil'),
                        'btn-' . $class . ' btn-sm border-light text-white'
                    ),
                    button(
                        page_link_to('user_shifts', ['delete_shift' => $shift->id]),
                        icon('trash'),
                        'btn-' . $class . ' btn-sm border-light text-white'
                    ),
                ]) . '</div>';
        }
        $shift_heading = $shift->start->format('H:i') . ' &dash; '
            . $shift->end->format('H:i') . ' &mdash; '
            . $shift->shiftType->name;

        if ($needed_angeltypes_count > 0) {
            $shift_heading = '<span class=""badge bg-light text-danger me-1"">' . $needed_angeltypes_count . '</span> ' . $shift_heading;
        }

        return div('card-header d-flex align-items-center', [
            '<a class=""d-flex align-items-center text-white"" href=""' . shift_link($shift) . '"">' . $shift_heading . '</a>',
            $header_buttons,
        ]);
    }",1
"    private static function pkcs12helper($n, $hashObj, $i, $d, $count)
    {
        static $one;
        if (!isset($one)) {
            $one = new BigInteger(1);
        }

        $blockLength = $hashObj->getBlockLength() >> 3;

        $c = ceil($n / $hashObj->getLengthInBytes());
        $a = '';
        for ($j = 1; $j <= $c; $j++) {
            $ai = $d . $i;
            for ($k = 0; $k < $count; $k++) {
                $ai = $hashObj->hash($ai);
            }
            $b = '';
            while (strlen($b) < $blockLength) {
                $b .= $ai;
            }
            $b = substr($b, 0, $blockLength);
            $b = new BigInteger($b, 256);
            $newi = '';
            for ($k = 0; $k < strlen($i); $k += $blockLength) {
                $temp = substr($i, $k, $blockLength);
                $temp = new BigInteger($temp, 256);
                $temp->setPrecision($blockLength << 3);
                $temp = $temp->add($b);
                $temp = $temp->add($one);
                $newi .= $temp->toBytes(false);
            }
            $i = $newi;
            $a .= $ai;
        }

        return substr($a, 0, $n);
    }",0
"    public function __construct($channel)
    {
        parent::__construct('DAHDITransfer');
        $this->setKey('DAHDIChannel', $channel);
    }",0
"                $parent = $item->getQuoteParentItemId();
                if ($parent && !$item->getParentItem()) {
                    $item->setParentItem($this->getItemByQuoteItemId($parent));
                } elseif (!$parent) {
                    $itemsCount++;
                }
            }
            // Set items count
            $this->setTotalItemCount($itemsCount);
        }
        if ($this->getCustomer()) {
            $this->setCustomerId($this->getCustomer()->getId());
        }

        if ($this->hasBillingAddressId() && $this->getBillingAddressId() === null) {
            $this->unsBillingAddressId();
        }

        if ($this->hasShippingAddressId() && $this->getShippingAddressId() === null) {
            $this->unsShippingAddressId();
        }

        if (!$this->getId()) {
            $this->setData('protect_code', substr(md5(uniqid(mt_rand(), true) . ':' . microtime(true)), 5, 6));
        }

        if ($this->getStatus() !== $this->getOrigData('status')) {
            Mage::dispatchEvent('order_status_changed_before_save', ['order' => $this]);
        }

        return $this;
    }",1
"    protected function decryptBlock($in)
    {
        // Salsa20 does not utilize this method
    }",0
"    public function saveStatisticDecision() {
        if (!$this->isApiRequest()) {
            throw new MethodNotAllowedException();
        }

        /** @var SystemsettingsTable $SystemsettingsTable */
        $SystemsettingsTable = TableRegistry::getTableLocator()->get('Systemsettings');

        try {
            $record = $SystemsettingsTable->getSystemsettingByKey('SYSTEM.ANONYMOUS_STATISTICS');
        } catch (RecordNotFoundException $e) {
            if (empty($record)) {
                throw new \RuntimeException('Systemsetting is missing - did you executed openitcockpit-update?');
            }
        }


        if ($this->request->getData('statistics.decision', null) === null) {
            throw new \RuntimeException('Wrong POST request');
        }


        $record->set('value', (int)$this->request->getData('statistics.decision', 0));

        if ($this->request->getData('statistics.cookie', null) !== null && $record->get('value') === 2) {
            $this->response = $this->response->withCookie(new Cookie(
                'askAgainForHelp',
                'Remind me later',
                new \DateTime('+16 hours'),
                '/'
            ));
        }

        $SystemsettingsTable->save($record);
        if ($record->hasErrors()) {
            $this->set('success', false);
            $this->set('message', __('Error while saving data'));
            $this->viewBuilder()->setOption('serialize', ['success', 'message']);
            return;
        }
        $this->set('success', true);
        $this->set('message', __('Record successfully saved'));
        $this->viewBuilder()->setOption('serialize', ['success', 'message']);
    }",1
"    public function cancelTimer(TimerInterface $timer)
    {
        if ($this->timerEvents->contains($timer)) {
            $event = $this->timerEvents[$timer];
            \event_del($event);
            \event_free($event);

            $this->timerEvents->detach($timer);
        }
    }",0
"    public function __construct(
        string $project_default_visibility,
        array $trove_categories,
        array $field_list,
        array $company_templates,
        array $tuleap_templates,
        array $external_templates,
    ) {
        $this->tuleap_templates             = json_encode($tuleap_templates);
        $this->are_restricted_users_allowed = (bool) ForgeConfig::areRestrictedUsersAllowed();
        $this->project_default_visibility   = $project_default_visibility;
        $this->projects_must_be_approved    = (bool) ForgeConfig::get(
            ProjectManager::CONFIG_PROJECT_APPROVAL,
            true
        );
        $this->trove_categories             = json_encode($trove_categories, JSON_THROW_ON_ERROR);
        $this->is_description_mandatory     = ProjectDescriptionUsageRetriever::isDescriptionMandatory();
        $this->field_list                   = json_encode($field_list);
        $this->company_templates            = json_encode($company_templates);
        $this->company_name                 = ForgeConfig::get('sys_org_name');
        $this->can_user_choose_privacy      = (bool) ForgeConfig::get(
            ProjectManager::SYS_USER_CAN_CHOOSE_PROJECT_PRIVACY
        );
        $this->external_templates           = json_encode($external_templates);
    }",1
"            $this->handlers[] = static function (ExtendedPromiseInterface $promise) use ($onFulfilled, $onRejected, $resolve, $reject, $progressHandler) {
                $promise
                    ->then($onFulfilled, $onRejected)
                    ->done($resolve, $reject, $progressHandler);
            };",0
"    protected function getTopic($topic) {
        if (!array_key_exists($topic, $this->topicLookup)) {
            $this->topicLookup[$topic] = new Topic($topic);
        }

        return $this->topicLookup[$topic];
    }",0
"            $aext = mb_strtolower(trim(trim((string)$aext, '., ')));",1
"    public function addPeriodicTimer($interval, $callback)
    {
        $timer = new Timer($interval, $callback, true);

        $this->scheduleTimer($timer);

        return $timer;
    }",0
"    public function __construct(mixed $value, string $expectedType)
    {
        parent::__construct(sprintf('Expected argument of type %s, %s given', $expectedType, get_debug_type($value)));
    }",0
"    public function __construct(RestApi $jira, string $templateName, $fieldId = null)
    {
        $this->jira = $jira;
        $this->fields = $this->enumAllowedFields();

        $this->templateConfig = Config::module('jira', 'templates');

        $this->templateName = $templateName;

        if ($fieldId !== null) {
            if (! array_key_exists($fieldId, $this->fields)) {
                $this->fieldId = array_search($fieldId, $this->fields);
            } else {
                $this->fieldId = $fieldId;
            }

            $templateFields = $this->templateConfig->getSection($templateName)->toArray();

            $this->fieldValue = $templateFields[$fieldId];
        }
    }",1
"    public function __construct(
        string|array $path = null,
        private ?string $name = null,
        private array $requirements = [],
        private array $options = [],
        private array $defaults = [],
        private ?string $host = null,
        array|string $methods = [],
        array|string $schemes = [],
        private ?string $condition = null,
        private ?int $priority = null,
        string $locale = null,
        string $format = null,
        bool $utf8 = null,
        bool $stateless = null,
        private ?string $env = null
    ) {
        if (\is_array($path)) {
            $this->localizedPaths = $path;
        } else {
            $this->path = $path;
        }
        $this->setMethods($methods);
        $this->setSchemes($schemes);

        if (null !== $locale) {
            $this->defaults['_locale'] = $locale;
        }

        if (null !== $format) {
            $this->defaults['_format'] = $format;
        }

        if (null !== $utf8) {
            $this->options['utf8'] = $utf8;
        }

        if (null !== $stateless) {
            $this->defaults['_stateless'] = $stateless;
        }
    }",0
"	public function testFile()
	{
		$file = __DIR__ . '/fixtures/download.txt';

		$response = Response::file($file);

		$this->assertSame('text/plain', $response->type());
		$this->assertSame(200, $response->code());
		$this->assertSame('test', $response->body());

		$response = Response::file($file, [
			'code'    => '201',
			'headers' => [
				'Pragma' => 'no-cache'
			]
		]);

		$this->assertSame('text/plain', $response->type());
		$this->assertSame(201, $response->code());
		$this->assertSame('test', $response->body());
		$this->assertSame([
			'Pragma' => 'no-cache'
		], $response->headers());
	}",1
"	final static public function ListAttributeDefs($sClass)
	{
		self::_check_subclass($sClass);
		return self::$m_aAttribDefs[$sClass];
	}",1
"    public function close()
    {
        if (!\is_resource($this->master)) {
            return;
        }

        $this->pause();
        \fclose($this->master);
        $this->removeAllListeners();
    }",0
"    public function setCertPath($certPath) {
        $this->certPath = $certPath;
    }",0
"            } elseif ('boolean' === $item[0]) {
                $formattedValue = '<em>'.strtolower(var_export($item[1], true)).'</em>';
            } elseif ('resource' === $item[0]) {",1
"                            $styles[$_rule->getRule()] = $_rule->getValue() . """";
                        }

                        break;
                    }
                }

                if (
                    \array_key_exists(""font-family"", $styles)
                    && (
                        \strtolower(\substr($this->href, 0, 7)) === ""phar://""
                        || ($this->document->allowExternalReferences === false && \strtolower(\substr($this->href, 0, 5)) !== ""data:"")
                    )
                ) {
                    unset($style[""font-family""]);
                }
            }",1
"    public function addTimer($interval, $callback)
    {
        $timer = new Timer($interval, $callback, false);

        $this->timers->add($timer);

        return $timer;
    }",0
"  function privWriteFileHeader(&$p_header)
  {
    $v_result=1;

    // ----- Store the offset position of the file
    $p_header['offset'] = ftell($this->zip_fd);

    // ----- Transform UNIX mtime to DOS format mdate/mtime
    $v_date = getdate($p_header['mtime']);
    $v_mtime = ($v_date['hours']<<11) + ($v_date['minutes']<<5) + $v_date['seconds']/2;
    $v_mdate = (($v_date['year']-1980)<<9) + ($v_date['mon']<<5) + $v_date['mday'];
	$this->writeZip64ExtraData($p_header);

    // ----- Packed data
    $v_binary_data = pack(""VvvvvvVVVvv"", 0x04034b50,
	                      $p_header['version_extracted'], $p_header['flag'],
                          $p_header['compression'], $v_mtime, $v_mdate,
                          $p_header['crc'], $p_header['compressed_size'],
						  $p_header['size'],
                          strlen($p_header['stored_filename']),
						  $p_header['extra_len']);

    // ----- Write the first 148 bytes of the header in the archive
    fputs($this->zip_fd, $v_binary_data, 30);

    // ----- Write the variable fields
    if (strlen($p_header['stored_filename']) != 0)
    {
      fputs($this->zip_fd, $p_header['stored_filename'], strlen($p_header['stored_filename']));
    }
    if ($p_header['extra_len'] != 0)
    {
      fputs($this->zip_fd, $p_header['extra'], $p_header['extra_len']);
    }

    // ----- Return
    return $v_result;
  }",0
"    public function clearCookie(string $name, ?string $path = '/', string $domain = null, bool $secure = false, bool $httpOnly = true, string $sameSite = null)
    {
        $this->setCookie(new Cookie($name, null, 1, $path, $domain, $secure, $httpOnly, false, $sameSite));
    }",0
"    private function cleanupPushSubscriptions()
    {
        PushSubscription::where('activity_at', '<', date(MOVIM_SQL_DATE, time()-(60*60*24*30)))
            ->delete();
    }",1
"    protected function putFile($sourcePath, $destinationFileName = null)
    {
        if (!$destinationFileName) {
            $destinationFileName = $this->disk_name;
        }

        $destinationPath = $this->getStorageDirectory() . $this->getPartitionDirectory();

        if (!$this->isLocalStorage()) {
            return $this->copyLocalToStorage($sourcePath, $destinationPath . $destinationFileName);
        }

        /*
         * Using local storage, tack on the root path and work locally
         * this will ensure the correct permissions are used.
         */
        $destinationPath = $this->getLocalRootPath() . '/' . $destinationPath;

        /*
         * Verify the directory exists, if not try to create it. If creation fails
         * because the directory was created by a concurrent process then proceed,
         * otherwise trigger the error.
         */
        if (
            !FileHelper::isDirectory($destinationPath) &&
            !FileHelper::makeDirectory($destinationPath, 0777, true, true)
        ) {
            trigger_error(error_get_last()['message'], E_USER_WARNING);
        }

        return FileHelper::copy($sourcePath, $destinationPath . $destinationFileName);
    }",1
"    public function can_connect_timeout()
    {
        $options = array(
        	'host' => '2.3.4.5',
            'scheme' => 'tcp://',
        	'port' => 9999,
        	'username' => 'asd',
        	'secret' => 'asd',
            'connect_timeout' => 3,
        	'read_timeout' => 10
        );
        $start = time();
        try
        {
	        $client = new \PAMI\Client\Impl\ClientImpl($options);
	        $client->open();
        } catch(\Exception $e) {
        }
        $length = time() - $start;
        $this->assertTrue($length >= 2 && $length <= 5);
    }",0
"    public static function cleanHtml($dirtyHtml, $removeHtml = false)
    {
        // $encode_html previously effected the decoding process.
        // we should decode regardless, just in case, the calling method passing encoded html
        //Prevent that the email address in Outlook format are removed
        $pattern = '/(.*)(&lt;([a-zA-Z0-9.!#$%&\'*+\=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)&gt;)(.*)/';
        $replacement = '${1}<<a href=""mailto:${3}"">${3}</a>> ${4}';
        $dirtyHtml =  preg_replace($pattern, $replacement, $dirtyHtml);
        $dirty_html_decoded = html_entity_decode($dirtyHtml);

        // Re-encode html
        if ($removeHtml === true) {
            // remove all HTML tags
            $sugarCleaner = self::getInstance();
            $purifier = $sugarCleaner->purifier;
            $clean_html = $purifier->purify($dirty_html_decoded);
        } else {
            // encode all HTML tags
            $clean_html = $dirty_html_decoded;
        }

        return $clean_html;
    }",1
"	public function srvPhpinfo(){
		phpinfo();exit;
	}",1
"	public function testCustomerFtpsAddSymlinkOutsideHomedir()
	{
		global $admin_userdata;

		// get customer
		$json_result = Customers::getLocal($admin_userdata, array(
			'loginname' => 'test1'
		))->get();
		$customer_userdata = json_decode($json_result, true)['data']; //

		$customer_userdata['documentroot'] = sys_get_temp_dir() . '/';
		@unlink($customer_userdata['documentroot'] . '/frx');
		symlink(Froxlor::getInstallDir(), $customer_userdata['documentroot'] . '/frx');

		$data = [
			'ftp_password' => 'h4xXx0r',
			'path' => '/frx/sub',
			'ftp_description' => 'testing',
			'sendinfomail' => TRAVIS_CI == 1 ? 0 : 1
		];

		$this->expectExceptionMessage('Found symlink pointing outside of customer home directory: /frx');
		Ftps::getLocal($customer_userdata, $data)->add();
	}",0
"    public function delete($key)
    {
        unset($this->data[$key], $this->expires[$key]);

        return Promise\resolve(true);
    }",0
"    public function queryAndReturnResult(GraphQLSchema $schema, $query, ?array $vars = [])
    {
        if ($this->errorHandler) {
            set_error_handler($this->errorHandler);
        }
        $context = $this->getContext();
        $last = function ($schema, $query, $context, $vars) {
            return GraphQL::executeQuery($schema, $query, null, $context, $vars);
        };

        return $this->callMiddleware($schema, $query, $context, $vars ?? [], $last);
    }",1
"    public function can_play_dtmf()
    {
        $write = array(implode(""\r\n"", array(
        	'action: PlayDTMF',
            'actionid: 1432.123',
            'channel: channel',
            'digit: 1',
        	''
        )));
	    $action = new \PAMI\Message\Action\PlayDTMFAction('channel', '1');
        $client = $this->_start($write, $action);
    }",0
"    public function toString($type, array $options = [])
    {
        $type = self::validatePlugin('Keys', $type, 'savePublicKey');

        return $type::savePublicKey($this->prime, $this->base, $this->publicKey, $options);
    }",0
"    public function getDisplayName()
    {
        return $this->getLocale()->getSite()->getSiteName();
    }",1
"                $strArr[] = array('str' => $tmpStr, 'sort_order' => $sortOrder);
            }
            usort(
                $strArr,
                function ($a, $b) {
                    return $a['sort_order'] - $b['sort_order'];
                }
            );
            foreach ($strArr as $bits) {
                $str .= $bits['str'];
            }
            $str .= '</dl>';

            return $str;
        case ""DateTime"":
            return $responseArr[0]->answer_datetime;
        case ""Date"":
            $date = $timedate->fromUser($responseArr[0]->answer_datetime);
            if (!$date) {
                return $responseArr[0]->answer_datetime;
            } else {
                $date = $timedate->tzGMT($date);

                return $timedate->asUserDate($date);
            }
            // no break
        case ""Rating"":
            return str_repeat('<img width=20 src=""modules/Surveys/imgs/star.png""/>', $responseArr[0]->answer);
        case ""Scale"":
            return $responseArr[0]->answer . '/10';
        case ""Textbox"":
        case ""Text"":
        default:
            return $responseArr[0]->answer;
    }
}",1
"function save_query($query) {
    global $table_prefix;	// table prefix;
    global $conn;   		// MySQL connection variable.

    $query = json_encode($query);
    $conn->query(""INSERT INTO {$table_prefix}latest_queries (query_value) VALUES ($query)"");

}",0
"                                $user = cmsCore::getModel('users')->getUserByAuth($profile['email'], $value);

                                if (!$user){
                                    return LANG_OLD_PASS_INCORRECT;
                                }

                                return true;

                            })
                        )
                    )),
                    new fieldString('password1', array(
                        'title' => LANG_NEW_PASS,
                        'is_password' => true,
                        'options'=>array(
                            'min_length'=> 6,
                            'max_length'=> 72
                        )
                    )),
                    new fieldString('password2', array(
                        'title' => LANG_RETYPE_NEW_PASS,
                        'is_password' => true,
                        'options'=>array(
                            'min_length'=> 6,
                            'max_length'=> 72
                        )
                    ))
                )
            )",1
"    public function getId() {
        return $this->_sessionId;
    }",0
"                        $dumper->addExpressionLanguageProvider($provider);
                    }
                }

                $cache->write($dumper->dump(), $this->getRouteCollection()->getResources());
            }",0
"    public function multiplyPoint(array $p, BigInteger $d)
    {
        //$r = strrev(sodium_crypto_scalarmult($d->toBytes(), strrev($p[0]->toBytes())));
        //return [$this->factory->newInteger(new BigInteger($r, 256))];

        $d = $d->toBytes();
        $d[0] = $d[0] & ""\xFC"";
        $d = strrev($d);
        $d |= ""\x80"";
        $d = new BigInteger($d, 256);

        return parent::multiplyPoint($p, $d);
    }",0
"    protected function setupIsPrime()
    {
        $length = $this->getLengthInBytes();

        // see HAC 4.49 ""Note (controlling the error probability)""
        // @codingStandardsIgnoreStart
             if ($length >= 163) { $t =  2; } // floor(1300 / 8)
        else if ($length >= 106) { $t =  3; } // floor( 850 / 8)
        else if ($length >= 81 ) { $t =  4; } // floor( 650 / 8)
        else if ($length >= 68 ) { $t =  5; } // floor( 550 / 8)
        else if ($length >= 56 ) { $t =  6; } // floor( 450 / 8)
        else if ($length >= 50 ) { $t =  7; } // floor( 400 / 8)
        else if ($length >= 43 ) { $t =  8; } // floor( 350 / 8)
        else if ($length >= 37 ) { $t =  9; } // floor( 300 / 8)
        else if ($length >= 31 ) { $t = 12; } // floor( 250 / 8)
        else if ($length >= 25 ) { $t = 15; } // floor( 200 / 8)
        else if ($length >= 18 ) { $t = 18; } // floor( 150 / 8)
        else                     { $t = 27; }
        // @codingStandardsIgnoreEnd

        return $t;
    }",0
"    public function onSuccess()
    {
        if ($this->callOnSuccess === false) {
            $this->getSubmitButton()->setValue($this->getElement('delete')->getButtonLabel());
            return;
        }

        $templateConfig = Config::fromIni($this->config->getConfigFile());
        $value = $this->getValue('template');

        if ($this->templateName !== null && $value !== $this->templateName) {
            $template = $templateConfig->getSection($this->templateName);
            $templateConfig->removeSection($this->templateName);
            $templateConfig->setSection($value, $template);
        } else {
            $template = $templateConfig->getSection($value);
            $templateConfig->setSection($this->getValue('template'), $template);
        }

        $templateConfig->saveIni($templateConfig->getConfigFile());
    }",1
"    public function testGetConnection() {
        $class  = new \ReflectionClass('\\Ratchet\\AbstractConnectionDecorator');
        $method = $class->getMethod('getConnection');
        $method->setAccessible(true);

        $conn = $method->invokeArgs($this->l1, array());

        $this->assertSame($this->mock, $conn);
    }",0
"    private function registerCleaner()
    {
        $this->loop->addPeriodicTimer(5, function () {
            foreach ($this->sessions as $sid => $session) {
                if (
                    $session->countClients() == 0
                    && $session->registered == null
                ) {
                    $session->killLinker();
                }

                if ($session->process == null) {
                    unset($this->sessions[$sid]);
                }
            }

            $this->cleanupDBSessions();
            $this->cleanupEncryptedPasswords();
            $this->cleanupPushSubscriptions();
        });
    }",0
"    private function _dir_closedir()
    {
        return true;
    }",0
"	public function fileGetHash(){
		$pageNum = 1024 * 1024 * 10;
		$this->in['pageNum'] = isset($this->in['pageNum']) ? $this->in['pageNum'] : $pageNum;
		$this->in['pageNum'] = $this->in['pageNum'] >= $pageNum ? $pageNum : $this->in['pageNum'];
		// ActionCall(""explorer.editor.fileGet"");exit;

		$url = $this->in['path'];
		$urlInfo = parse_url_query($url);
		if( !isset($urlInfo[""explorer/share/unzipListHash""]) && 
			!isset($urlInfo[""accessToken""])){
			show_json(LNG('common.pathNotExists'),false);
		}
		$index 	  = json_decode(rawurldecode($urlInfo['index']),true);
		$zipFile  = $this->fileHash(rawurldecode($urlInfo['path']));
		$filePart = IOArchive::unzipPart($zipFile,$index ? $index:'-1');
		if(!$filePart || !IO::exist($filePart['file'])){
			show_json(LNG('common.pathNotExists'),false);
		}
		Action(""explorer.editor"")->fileGetMake($filePart['file'],IO::info($filePart['file']),$url);
	}",1
"    public function title()
    {
        return 'Cannot View report';
    }",0
"    public function close()
    {
        if ($this->closed) {
            return;
        }

        $this->closed = true;

        $this->emit('close');
        $this->pause();
        $this->removeAllListeners();

        if (\is_resource($this->stream)) {
            \fclose($this->stream);
        }
    }",0
"    public function isUploaded($name){

        if (!isset($_FILES[$name])) { return false; }

        if (empty($_FILES[$name]['size'])) {

            if(isset($_FILES[$name]['error'])){
                if(isset($this->upload_errors[$_FILES[$name]['error']]) && $this->upload_errors[$_FILES[$name]['error']] !== UPLOAD_ERR_OK){
                    $this->last_error = $this->upload_errors[$_FILES[$name]['error']];
                }
            }

            return false;

        }

        return true;

    }",1
"    public function getHistory()
    {
        $scrollback = '';
        $last_attr = $this->base_attr_cell;
        for ($i = 0; $i < count($this->history); $i++) {
            for ($j = 0; $j <= $this->max_x + 1; $j++) {
                $cur_attr = $this->history_attrs[$i][$j];
                $scrollback .= $this->processCoordinate($last_attr, $cur_attr, isset($this->history[$i][$j]) ? $this->history[$i][$j] : '');
                $last_attr = $this->history_attrs[$i][$j];
            }
            $scrollback .= ""\r\n"";
        }
        $base_attr_cell = $this->base_attr_cell;
        $this->base_attr_cell = $last_attr;
        $scrollback .= $this->getScreen();
        $this->base_attr_cell = $base_attr_cell;

        return '<pre width=""' . ($this->max_x + 1) . '"" style=""color: white; background: black"">' . $scrollback . '</span></pre>';",0
"    public function bitwise_rightShift($shift)
    {
        $temp = new static();
        $temp->value = bcdiv($this->value, bcpow('2', $shift, 0), 0);

        return $this->normalize($temp);
    }",0
"function warning($msg, $immediately = false, $immediatelyRaw = false)
{
    return alert(NotificationType::WARNING, $msg, $immediately, $immediatelyRaw);
}",0
"    public function getTimeout()
    {
        return $this->timeout;
    }",0
"    private function _dir_opendir($path, $options)
    {
        $path = $this->parse_path($path);
        if ($path === false) {
            return false;
        }
        $this->pos = 0;
        $this->entries = $this->sftp->nlist($path);
        return $this->entries !== false;
    }",0
"    private function isMimeTypeAllowed($file_path) {

        $finfo = finfo_open(FILEINFO_MIME_TYPE);

        $file_mime = finfo_file($finfo, $file_path);

        if($file_mime === false){ return false; }

        return in_array($file_mime, $this->allowed_mime);

    }",1
"    public function save($check_notify = false)
    {
        global $current_user;

        $id = false;

        if ($this->isDuplicate) {
            $GLOBALS['log']->debug(""EMAIL - tried to save a duplicate Email record"");
        } else {
            if (empty($this->id)) {
                $this->id = create_guid();
                $this->new_with_id = true;
            }

            if ($this->cleanEmails($this->from_addr_name) === '') {
                $this->from_addr_name = $this->cleanEmails($this->from_name);
            } else {
                $this->from_addr_name = $this->cleanEmails($this->from_addr_name);
            }
            $this->to_addrs_names = $this->cleanEmails($this->to_addrs_names);
            $this->cc_addrs_names = $this->cleanEmails($this->cc_addrs_names);
            $this->bcc_addrs_names = $this->cleanEmails($this->bcc_addrs_names);
            $this->reply_to_addr = $this->cleanEmails($this->reply_to_addr);
            $this->description = SugarCleaner::cleanHtml($this->description);
            if (empty($this->description_html)) {
                $this->description_html = $this->description;
                $this->description_html = nl2br($this->description_html);
            }
            $this->description_html = SugarCleaner::cleanHtml($this->description_html, true);
            $this->raw_source = SugarCleaner::cleanHtml($this->raw_source, true);
            $this->saveEmailText();
            $this->saveEmailAddresses();


            if (empty($this->assigned_user_id)) {
                $this->assigned_user_id = $current_user->id;
            }

            $GLOBALS['log']->debug('-------------------------------> Email called save()');

            if (empty($this->date_sent_received)) {
                global $timedate;

                $date_sent_received_obj = $timedate->fromUser(
                    $timedate->merge_date_time($this->date_start, $this->time_start),
                    $current_user
                );

                if ($date_sent_received_obj !== null && ($date_sent_received_obj instanceof SugarDateTime)) {
                    $this->date_sent_received = $date_sent_received_obj->asDb();
                }
            }


            $validator = new EmailFromValidator();
            if (!defined('SUGARCRM_IS_INSTALLING') && !$validator->isValid($this)) {
                $errors = $validator->getErrorsAsText();
                $details = ""Details:\n{$errors['messages']}\ncodes:{$errors['codes']}"";
                LoggerManager::getLogger()->error(""Saving Email with invalid From name and/or Address. $details"");
            }


            if ((!isset($this->date_sent_received) || !$this->date_sent_received) && in_array($this->status, ['sent', 'replied'])) {
                $this->date_sent_received = TimeDate::getInstance()->nowDb();
            }

            $id = parent::save($check_notify);

            if (!empty($this->parent_type) && !empty($this->parent_id)) {
                if (!empty($this->fetched_row) && !empty($this->fetched_row['parent_id']) && !empty($this->fetched_row['parent_type'])) {
                    if ($this->fetched_row['parent_id'] != $this->parent_id || $this->fetched_row['parent_type'] != $this->parent_type) {
                        $mod = strtolower($this->fetched_row['parent_type']);
                        $rel = array_key_exists(
                            $mod,
                            $this->field_defs
                        ) ? $mod : $mod . ""_activities_emails""; //Custom modules rel name
                        if ($this->load_relationship($rel)) {
                            $this->$rel->delete($this->id, $this->fetched_row['parent_id']);
                        }
                    }
                }
                $mod = strtolower($this->parent_type);
                $rel = array_key_exists(
                    $mod,
                    $this->field_defs
                ) ? $mod : $mod . ""_activities_emails""; //Custom modules rel name
                if ($this->load_relationship($rel)) {
                    $this->$rel->add($this->parent_id);
                }
            }
        }
        $GLOBALS['log']->debug('-------------------------------> Email save() done');

        return $id;
    }",1
"	public static function UTF8StringToArray($str, $isunicode, &$currentfont) {
		$str = is_null($str) ? '' : $str;
		if ($isunicode) {
			// requires PCRE unicode support turned on
			$chars = TCPDF_STATIC::pregSplit('//','u', $str, -1, PREG_SPLIT_NO_EMPTY);
			$carr = array_map(array('TCPDF_FONTS', 'uniord'), $chars);
		} else {
			$chars = str_split($str);
			$carr = array_map('ord', $chars);
		}
		if (is_array($currentfont['subsetchars']) && is_array($carr)) {
			$currentfont['subsetchars'] += array_fill_keys($carr, true);
		} else {
			$currentfont['subsetchars'] = array_merge($currentfont['subsetchars'], $carr);
		}
		return $carr;
	}",1
"	public function checkAccessToken(){
		$config = Model('Plugin')->getConfig('fileView');
		if(!$config['apiKey']) return;

		$timeTo = isset($this->in['timeTo'])?intval($this->in['timeTo']):'';
		$token = md5($this->in['path'].$timeTo.$config['apiKey']);
		if($token != $this->in['token']){
			show_tips('token ' . LNG('common.error'));
		}
		if($timeTo != '' && $timeTo <= time()){
			show_tips('token ' . LNG('common.expired'));
		}
	}",1
"    private function fetchUserGroupList($is_read_only, array $changeset_values)
    {
        $field_id     = $this->getId();
        $element_name = 'artifact[' . $field_id . '][u_groups][]';

        $hp    = Codendi_HTMLPurifier::instance();
        $html  = '<select '
            . 'name=""' . $hp->purify($element_name) . '"" '
            . 'id=""' . $hp->purify(str_replace('[]', '', $element_name)) . '"" '
            . 'multiple '
            . 'size=""8"" '
            . (($this->isRequired()) ? 'required=""required""' : '' )",1
"    public function applyGridFilter(cmsModel $model, $filter) {

        // применяем сортировку
        if (!empty($filter['order_by']) && !empty($filter['order_to'])) {

            // Есть ли вообще такой столбец
            if(empty($this->grid['columns'][$filter['order_by']])){
                $filter['order_by'] = $this->grid['options']['order_by'];
            }

            $order_by = $filter['order_by'];

            // Есть отдельный столбец для сортировки
            if (!empty($this->grid['columns'][$order_by]['order_by'])) {
                $order_by = $this->grid['columns'][$order_by]['order_by'];
            }

            $model->orderBy($order_by, $filter['order_to']);
        }

        // устанавливаем страницу
        if (!empty($filter['page'])) {

            $filter['perpage'] = !empty($filter['perpage']) ? (int) $filter['perpage'] : 30;
            $filter['page']    = (int) ($filter['page'] <= 0 ? 1 : $filter['page']);

            $model->limitPage($filter['page'], $filter['perpage']);
        }

        // Пагинация отключена
        if(!$this->grid['options']['is_pagination']){
            $model->limit(false);
        }

        //
        // проходим по каждой колонке таблицы
        // и проверяем не передан ли фильтр для нее
        //
        foreach ($this->getVisibleColumns() as $field => $column) {

            if (empty($column['filter']) ||
                    $column['filter'] === 'none' ||
                    !array_key_exists($field, $filter) ||
                    is_empty_value($filter[$field])) {
                continue;
            }

            if (!empty($column['filter_by'])) {
                $filter_field = $column['filter_by'];
            } else {
                $filter_field = $field;
            }

            switch ($column['filter']) {
                case 'range_date':
                    if (isset($filter[$field]['from']) && !is_empty_value($filter[$field]['from'])) {
                        $date_from = date('Y-m-d', strtotime($filter[$field]['from']));
                        $model->filterGtEqual($filter_field, $date_from);
                    }
                    if (isset($filter[$field]['to']) && !is_empty_value($filter[$field]['to'])) {
                        $date_to = date('Y-m-d', strtotime($filter[$field]['to']));
                        $model->filterLtEqual($filter_field, $date_to);
                    }
                case 'range':
                    if (isset($filter[$field]['from']) && !is_empty_value($filter[$field]['from'])) {
                        $model->filterGtEqual($filter_field, $filter[$field]['from']);
                    }
                    if (isset($filter[$field]['to']) && !is_empty_value($filter[$field]['to'])) {
                        $model->filterLtEqual($filter_field, $filter[$field]['to']);
                    }
                    break;
                case 'zero':
                    if($filter[$field]) {
                        $model->filterEqual($filter_field, 0);
                    }
                case 'nn':
                    if($filter[$field]) {
                        $model->filterNotNull($filter_field);
                    }
                    break;
                case 'ni':
                    if($filter[$field]) {
                        $model->filterIsNull($filter_field);
                    }
                    break;
                case 'in': $model->filterIn($filter_field, !is_array($filter[$field]) ? explode(',', $filter[$field]) : $filter[$field]);
                    break;
                case 'filled': ($filter[$field] ? $model->filterNotNull($filter_field) : $model->filterIsNull($filter_field));
                    break;
                case 'exact': $model->filterEqual($filter_field, $filter[$field]);
                    break;
                case 'ip': $model->filterEqual($filter_field, string_iptobin($filter[$field]), true);
                    break;
                case 'like': $model->filterLike($filter_field, ""%{$filter[$field]}%"");
                    break;
                case 'date':
                    $date = date('Y-m-d', strtotime($filter[$field]));
                    $model->filterLike($filter_field, ""%{$date}%"");
                    break;
            }
        }

        // Запоминаем
        $this->grid['filter'] = array_merge($this->grid['filter'], $filter);

        // Дополнительный фильтр
        if (!empty($filter['advanced_filter']) && is_string($filter['advanced_filter'])) {

            parse_str($filter['advanced_filter'], $dataset_filters);

            $model->applyDatasetFilters($dataset_filters);
        }

        return $model;
    }",1
"    public function multiply(BCMath $x)
    {
        $temp = new self();
        $temp->value = bcmul($this->value, $x->value);

        return $this->normalize($temp);
    }",0
"	public function testBlockWithAssign() {
		$this->assertEquals('Captured content is: Content with lots of html here', $this->smarty->fetch('038_child.tpl'));
	}",1
"    public function isEmpty()
    {
        return !$this->signals;
    }",0
"                $select .= '<option value=""' . $id . '"" ' . ($id == $checked_val ? 'selected=""selected""' : '') . '>' . $hp->purify($name) . '</option>';
            }
            $select .= '</optgroup>';
        }
        $select .= '</select>';
        return $select;
    }",1
"    public function __construct(string $name, string $value, string $path = '/', string $domain = null)
    {
        $this->name = $name;
        $this->value = $value;
        $this->path = $path;
        $this->domain = $domain;
    }",0
"    public function encodePoint($point)
    {
        list($x, $y) = $point;
        $y = ""\0"" . $y->toBytes();
        if ($x->isOdd()) {
            $y[0] = $y[0] | chr(0x80);
        }
        $y = strrev($y);

        return $y;
    }",0
"    function read($key)
    {
        //$this->log->debug('Session read');

        $data = '';
        $this->key = $key;

        $userAgent = substr($_SERVER['HTTP_USER_AGENT'], 0, 253);

        try {
            $dbh = $this->getDb();

            // Start a transaction
            $this->beginTransaction();

            // Get this session
            $sth = $dbh->getConnection()->prepare('
                SELECT `session_data`, `isexpired`, `useragent`, `session_expiration`, `userId` 
                  FROM `session`
                 WHERE `session_id` = :session_id
            ');
            $sth->execute(['session_id' => $key]);

            if (!$row = $sth->fetch()) {
                // New session.
                $this->insertSession($key, '', time(), time() + $this->maxLifetime);

                $this->expired = false;

            } else {
                // Existing session
                // Check the session hasn't expired
                if ($row['session_expiration'] < time())
                    $this->expired = true;
                else
                    $this->expired = $row['isexpired'];

                // What happens if the UserAgent has changed?
                if ($row['useragent'] != $userAgent) {
                    // Force delete this session
                    $this->expired = 1;
                    $this->pruneKey = true;
                }

                $this->userId = $row['userId'];
                $this->sessionExpiry = $row['session_expiration'];

                // Set the session data (expired or not)
                $data = $row['session_data'];
            }

            return (string)$data;

        } catch (\Exception $e) {
            $this->log->error('Error reading session: %s', $e->getMessage());

            return (string)$data;
        }
    }",1
"    public function update(SaveUserRequest $request, $id)
    {
        $this->authorize('update', User::class);

        $user = User::findOrFail($id);
        $user = Company::scopeCompanyables($user)->find($id);
        $this->authorize('update', $user);

        /**
         * This is a janky hack to prevent people from changing admin demo user data on the public demo.
         * 
         * The $ids 1 and 2 are special since they are seeded as superadmins in the demo seeder.
         * 
         *  Thanks, jerks. You are why we can't have nice things. - snipe
         * 
         */ 


        if ((($id == 1) || ($id == 2)) && (config('app.lock_passwords'))) {
            return response()->json(Helper::formatStandardApiResponse('error', null, 'Permission denied. You cannot update user information via API on the demo.'));
        }


        $user->fill($request->all());
        
        if ($user->id == $request->input('manager_id')) {
            return response()->json(Helper::formatStandardApiResponse('error', null, 'You cannot be your own manager'));
        }

        if ($request->filled('password')) {
            $user->password = bcrypt($request->input('password'));
        }

        // We need to use has()  instead of filled()
        // here because we need to overwrite permissions
        // if someone needs to null them out
        if ($request->has('permissions')) {
            $permissions_array = $request->input('permissions');

            // Strip out the superuser permission if the API user isn't a superadmin
            if (! Auth::user()->isSuperUser()) {
                unset($permissions_array['superuser']);
            }

            $user->permissions = $permissions_array;
        }


        // Update the location of any assets checked out to this user
        Asset::where('assigned_type', User::class)
            ->where('assigned_to', $user->id)->update(['location_id' => $request->input('location_id', null)]);

        
        app('App\Http\Requests\ImageUploadRequest')->handleImages($user, 600, 'image', 'avatars', 'avatar');
          
        if ($user->save()) {

            // Check if the request has groups passed and has a value
            if ($request->filled('groups')) {

                $validator = Validator::make($request->all(), [
                    'groups.*' => 'integer|exists:permission_groups,id',
                ]);
                
                if ($validator->fails()){
                    return response()->json(Helper::formatStandardApiResponse('error', null, $user->getErrors()));
                }

                // Only save groups if the user is a superuser
                if (Auth::user()->isSuperUser()) {
                    $user->groups()->sync($request->input('groups'));
                }

            // The groups field has been passed but it is null, so we should blank it out
            } elseif ($request->has('groups')) {
                
                // Only save groups if the user is a superuser
                if (Auth::user()->isSuperUser()) {
                    $user->groups()->sync($request->input('groups'));
                }
            }


            return response()->json(Helper::formatStandardApiResponse('success', (new UsersTransformer)->transformUser($user), trans('admin/users/message.success.update')));
        }

        return response()->json(Helper::formatStandardApiResponse('error', null, $user->getErrors()));
    }",1
"    protected static function safe_intval_inline()
    {
        if (self::$use_reg_intval) {
            return PHP_INT_SIZE == 4 && PHP_VERSION_ID >= 80100 ? 'intval(%s)' : '%s';
        }

        $safeint = '(is_int($temp = %s) ? $temp : (fmod($temp, 0x80000000) & 0x7FFFFFFF) | ';
        return $safeint . '((fmod(floor($temp / 0x80000000), 2) & 1) << 31))';
    }",0
"    public static function disableRFC4050Syntax()
    {
        self::$rfc4050 = false;
    }",0
"        throw new TimeoutException($time, 'Timer expired after ' . $time . ' seconds');
    });
}",0
"    public function getDestination()
    {
        return $this->getKey('Destination');
    }",0
"            foreach ($releases as $id => $name) {
                $select .= '<option value=""' . $id . '"" ' . ($id == $checked_val ? 'selected=""selected""' : '') . '>' . $hp->purify($name) . '</option>';",1
"            foreach ($values as $value) {
                header($name.': '.$value, $replace, $this->statusCode);
            }",0
"    public function onClose(ConnectionInterface $conn) {
        if ($this->connections->contains($conn)) {
            $context = $this->connections[$conn];
            $this->connections->detach($conn);

            $this->delegate->onClose($context->connection);
        }
    }",0
"            $this->emitter->once('event', $aCallable);
        };
        $this->emitter->once('event', $bCallable);

        self::assertFalse($aCalled);
        self::assertFalse($bCalled);
        $this->emitter->emit('event');

        self::assertFalse($aCalled);
        self::assertTrue($bCalled);
        $this->emitter->emit('event');

        self::assertTrue($aCalled);
        self::assertTrue($bCalled);
    }",0
"            $this->pending[$id]->reject(new \RuntimeException(
                'DNS query for ' . $name . ' failed: ' . $reason,
                $code
            ));
        }",0
"    public function cpuUsageLinux(){
        $filePath = ('/proc/stat');
        if ( !@is_readable($filePath)) {
            return 0;
        }
        $stat1  = file($filePath);
        sleep(1);
        $stat2  = file($filePath);
        $info1  = explode(' ', preg_replace('!cpu +!', '', $stat1[0]));
        $info2  = explode(' ', preg_replace('!cpu +!', '', $stat2[0]));
        $total1 = array_sum($info1);
        $total2 = array_sum($info2);
        $time1  = $total1 - $info1[3];
        $time2  = $total2 - $info2[3];
        return round(($time2 - $time1) / ($total2 - $total1), 3);
    }",1
"function runQuery($query){
   
    global $conn;			// MySQL connection variable.

    $runQuery = $conn->query($query);

    // Check If the syntax has any error then throw an the error. Otherwise return ture;
    if($runQuery === false) {

        // insert log 
        create_log($conn->error, debug_backtrace());

        // Keep the transaction error record
        $conn->get_all_error[] = $conn->error;

        return $conn->error; // Return the error

    } else {
        return true;
    }

}",1
"    public function getAllRegistryData()
    {
        // clear cache to make sure we have current data...
        Setup_Controller::getInstance()->clearCache();

        $registryData['Setup'] = $this->getRegistryData();
        
        // setup also need some core tinebase regdata
        $locale = Tinebase_Core::get('locale');
        $symbols = Zend_Locale::getTranslationList('symbols', $locale);

        $registryData['Tinebase'] = array(
            'serviceMap'       => Setup_Frontend_Http::getServiceMap(),
            'timeZone'         => Setup_Core::getUserTimezone(),
            'jsonKey'          => Setup_Core::get('jsonKey'),
            'locale'           => array(
                'locale'   => $locale->toString(), 
                'language' => Zend_Locale::getTranslation($locale->getLanguage(), 'language', $locale),
                'region'   => Zend_Locale::getTranslation($locale->getRegion(), 'country', $locale),
            ),
            'version'          => array(
                'buildType'     => TINE20_BUILDTYPE,
                'codeName'      => TINE20SETUP_CODENAME,
                'packageString' => TINE20SETUP_PACKAGESTRING,
                'releaseTime'   => TINE20SETUP_RELEASETIME,
                // NOTE: if assetHash is not available we have a serious problem -  please don't generate one!
                'assetHash'     => Tinebase_Frontend_Http_SinglePageApplication::getAssetHash(),
            ),
            'maxFileUploadSize' => Tinebase_Helper::convertToBytes(ini_get('upload_max_filesize')),
            'maxPostSize'       => Tinebase_Helper::convertToBytes(ini_get('post_max_size')),
            'thousandSeparator' => $symbols['group'],
            'decimalSeparator'  => $symbols['decimal'],
            'brandingWeburl'    => Tinebase_Config::getInstance()->get(Tinebase_Config::BRANDING_WEBURL),
            'brandingLogo'      => Tinebase_ImageHelper::getDataUrl(Tinebase_Config::getInstance()->get(Tinebase_Config::BRANDING_LOGO)),
            'brandingFaviconSvg' => Tinebase_Config::getInstance()->get(Tinebase_Config::BRANDING_FAVICON_SVG),
            'brandingTitle'     => Tinebase_Config::getInstance()->get(Tinebase_Config::BRANDING_TITLE),
            'brandingDescription'=> Tinebase_Config::getInstance()->get(Tinebase_Config::BRANDING_DESCRIPTION),
            'brandingHelpUrl'    => Tinebase_Config::getInstance()->get(Tinebase_Config::BRANDING_HELPURL),
            'brandingShopUrl'    => Tinebase_Config::getInstance()->get(Tinebase_Config::BRANDING_SHOPURL),
            'brandingBugsUrl'    => Tinebase_Config::getInstance()->get(Tinebase_Config::BRANDING_BUGSURL),
            'installLogo'       => Tinebase_ImageHelper::getDataUrl(Tinebase_Core::getInstallLogo()),
            'websiteUrl'        => Tinebase_Config::getInstance()->get(Tinebase_Config::WEBSITE_URL),
        );
        
        return $registryData;
    }",1
"            $error = error_get_last();
            if ((isset($error['type']) ? $error['type'] : 0) & (E_ERROR | E_CORE_ERROR | E_COMPILE_ERROR | E_USER_ERROR | E_RECOVERABLE_ERROR)) {
                return;
            }

            if (!$hasRun && !$stopped) {
                $loop->run();
            }
        });
        // @codeCoverageIgnoreEnd

        return self::$instance;
    }",0
"    public function setChallenge($challenge)
    {
        $this->challenge = $challenge;
    }",0
"    public function getOptions()
    {
        return $this->options;
    }",0
"    public static function minMaxBits($bits)
    {
        $bytes = $bits >> 3;
        $min = str_repeat(chr(0), $bytes);
        $max = str_repeat(chr(0xFF), $bytes);
        $msb = $bits & 7;
        if ($msb) {
            $min = chr(1 << ($msb - 1)) . $min;
            $max = chr((1 << $msb) - 1) . $max;
        } else {
            $min[0] = chr(0x80);
        }
        return [
            'min' => new static($min, 256),
            'max' => new static($max, 256)
        ];
    }",0
"    public function initialize(array &$flashes)
    {
        $this->flashes = &$flashes;
    }",0
"	public function shortcode( $atts ) {
		if ( empty( $atts[ 0 ] ) ) {
			Debug2::debug( '[ESI] ===shortcode wrong format', $atts );
			return 'Wrong shortcode esi format';
		}

		$cache = 'public,no-vary';
		if ( ! empty( $atts[ 'cache' ] ) ) {
			$cache = $atts[ 'cache' ];
			unset( $atts[ 'cache' ] );
		}

		$silence = false;
		if ( ! empty( $atts[ '_ls_silence' ] ) ) {
			$silence = true;
		}

		do_action( 'litespeed_esi_shortcode-' . $atts[ 0 ] );

		// Show ESI link
		return $this->sub_esi_block( 'esi', 'esi-shortcode', $atts, $cache, $silence );
	}",1
"    protected function jacobianAddPointMixedXY(array $p, array $q)
    {
        list($u1, $s1) = $p;
        list($u2, $s2) = $q;
        if ($u1->equals($u2)) {
            if (!$s1->equals($s2)) {
                return [];
            } else {
                return $this->doublePoint($p);
            }
        }
        $h = $u2->subtract($u1);
        $r = $s2->subtract($s1);
        $h2 = $h->multiply($h);
        $h3 = $h2->multiply($h);
        $v = $u1->multiply($h2);
        $x3 = $r->multiply($r)->subtract($h3)->subtract($v->multiply($this->two));
        $y3 = $r->multiply(
            $v->subtract($x3)
        )->subtract(
            $s1->multiply($h3)
        );
        return [$x3, $y3, $h];
    }",0
"                    $this->app->cache_manager->delete($item);
                }
            }
        }

        $user_sid = $this->app->user_manager->session_id();
        $the_user_id = $this->app->user_manager->id();

        if (!isset($data['session_id']) and $user_sid) {
            $data['session_id'] = $user_sid;
        }
        if (!isset($data['id'])) {

            $data['id'] = 0;

        }
        if (isset($data['cf_temp'])) {
            $cf_temp = $data['cf_temp'];
        }
        $allow_html = false;
        $allow_scripts = false;
        if (isset($data['allow_html']) and (!isset($_REQUEST['allow_html']))) {
            $allow_html = $data['allow_html'];
        }
        if (isset($data['allow_scripts']) and (!isset($_REQUEST['allow_scripts']))) {
            $allow_scripts = $data['allow_scripts'];
        }

        /* if (isset($data['debug']) and $data['debug'] == true) {
             $dbg = 1;
             unset($data['debug']);
         } else {
             $dbg = false;
         }
         if ($dbg != false) {
             var_dump($data);
         }*/

        if (!isset($data['user_ip'])) {
            $data['user_ip'] = user_ip();
        }
        if (isset($data['id']) == false or $data['id'] == 0) {
            $data['id'] = 0;
            $l = $this->last_id($table);
            $data['new_id'] = intval($l + 1);
            $original_data['new_id'] = $data['new_id'];
        }

        if (!isset($the_user_id)) {
            $the_user_id = 0;
        }
        if (intval($data['id']) == 0) {

            if (isset($data['created_at'])) {
                try {
                    $carbonUpdatedAt = Carbon::parse($data['created_at']);
                    $data['created_at'] = $carbonUpdatedAt->format('Y-m-d H:i:s');
                } catch (\Exception $e) {
                    $data['created_at'] = Carbon::now()->format('Y-m-d H:i:s');
                }
            } else {
                $data['created_at'] = Carbon::now()->format('Y-m-d H:i:s');
            }


//            if (isset($data['created_at']) == false) {
//                $data['created_at'] = date('Y-m-d H:i:s');
//            }
            if ($the_user_id) {
                $data['created_by'] = $the_user_id;
            }
            if ($the_user_id) {
                $data['edited_by'] = $the_user_id;
            }
        } else {
            if ($the_user_id) {
                $data['edited_by'] = $the_user_id;
            }
        }

        if (isset($data['position'])) {
            $data['position'] = intval($data['position']);
        }

        $table_assoc_name = $this->assoc_table_name($table);

        $criteria_orig = $data;
        $criteria = $this->map_array_to_table($table, $data);
        if ($allow_html == false) {
            $criteria = $this->app->format->clean_html($criteria);
        } else {
            if ($allow_scripts == false) {
               $criteria = $this->clean_input($criteria);

               // $evil = ['(?<!\w)on\w*', 'xmlns', 'formaction', 'xlink:href', 'FSCommand', 'seekSegmentTime'];
              //  $clearInput = new HTMLClean();
               // $criteria = $clearInput->cleanArray($criteria);

            }

        }
        $criteria = $this->app->url_manager->replace_site_url($criteria);

        if (is_array($data_to_save_options) and $data_to_save_options['use_this_field_for_id'] != false) {
            $criteria['id'] = $criteria_orig[$data_to_save_options['use_this_field_for_id']];
        }


        if (!isset($criteria['id'])) {
            $criteria['id'] = 0;
        }
        $criteria['id'] = intval($criteria['id']);

        $criteria = $criteria_overwrite = $this->app->event_manager->response('mw.database.' . $table . '.save.params', $criteria);
        $criteria = $this->map_array_to_table($table, $criteria);

        if(!$criteria){
            return;
        }

//        $auto_fields = ['created_by','edited_by','created_at','updated_at','created_by','session_id','id'];


        if (intval($criteria['id']) == 0) {
            unset($criteria['id']);
            $engine = $this->get_sql_engine();
            if ($engine == 'pgsql') {
                $highestId = $this->table($table)->select(DB::raw('MAX(id)'))->first();
                $next_id = 0;
                if (!isset($highestId->max)) {
                    $next_id = 1;
                } else {
                    $next_id = $highestId->max + 1;
                }
                if (!empty($criteria)) {
                    $criteria['id'] = $next_id;
                }
            }
            $id_to_return = $this->table($table_assoc_name)->insert($criteria);
            $id_to_return = $this->last_id($table);

        } else {
            $insert_or_update = $highestId = $this->table($table)->where('id', $criteria['id'])->count();
            if ($insert_or_update != 0) {
                $insert_or_update = 'update';
            } else {
                $insert_or_update = 'insert';
            }
            $id_to_return = $this->table($table_assoc_name)->where('id', $criteria['id'])->$insert_or_update($criteria);
            $id_to_return = $criteria['id'];
        }

        if ($id_to_return == false) {
            $id_to_return = $this->last_id($table);
        }
        $id_to_return = intval($id_to_return);

        $original_data['table'] = $table;
        $original_data['id'] = $id_to_return;
        $cache_group = $this->assoc_table_name($table);


        $this->app->cache_manager->delete($cache_group);

        if ($skip_cache == false) {
            $cache_group = $this->assoc_table_name($table);
            $this->app->cache_manager->delete($cache_group . '');
            $this->app->cache_manager->delete('content/global/full_page_cache');
            $this->app->cache_manager->delete($cache_group . '/' . $id_to_return);
            if (isset($criteria['parent_id'])) {
                $this->app->cache_manager->delete($cache_group . '/' . intval($criteria['parent_id']));
            }
        }

        $criteria_overwrite['id'] = $id_to_return;
        $this->app->event_manager->trigger('mw.database.' . $table . '.save.after', $criteria_overwrite);
        $this->app->event_manager->trigger('mw.database.' . $table . '.save.after.data', $data);

        return $id_to_return;
    }",1
"    public function logoutClient()
    {
        if ($_COOKIE) { // testing env fix
            setcookie('BOXCLR', '', time() - 3600, '/');
        }
        $this->di['session']->delete('client');
        $this->di['session']->delete('client_id');
        $this->di['logger']->info('Logged out');

        return true;
    }",1
"function ShiftType_delete_view(ShiftType $shifttype)
{
    return page_with_title(sprintf(__('Delete shifttype %s'), $shifttype->name), [
        info(sprintf(__('Do you want to delete shifttype %s?'), $shifttype->name), true),
        form([
            buttons([
                button(page_link_to('shifttypes'), icon('x-lg') . __('cancel')),
                form_submit(
                    'delete',
                    icon('trash') . __('delete'),
                    'btn-danger',
                    false
                ),
            ]),
        ]),
    ], true);
}",1
"    function __construct(PermessageDeflateOptions $perMessageDeflateOptions = null) {
        $this->verifier = new ResponseVerifier;

        $this->defaultHeader = new Request('GET', '', [
            'Connection'            => 'Upgrade'
          , 'Upgrade'               => 'websocket'
          , 'Sec-WebSocket-Version' => $this->getVersion()
          , 'User-Agent'            => ""Ratchet""
        ]);

        if ($perMessageDeflateOptions === null) {
            $perMessageDeflateOptions = PermessageDeflateOptions::createDisabled();
        }

        // https://bugs.php.net/bug.php?id=73373
        // https://bugs.php.net/bug.php?id=74240 - need >=7.1.4 or >=7.0.18
        if ($perMessageDeflateOptions->isEnabled() &&
            !PermessageDeflateOptions::permessageDeflateSupported()) {
            trigger_error('permessage-deflate is being disabled because it is not support by your PHP version.', E_USER_NOTICE);
            $perMessageDeflateOptions = PermessageDeflateOptions::createDisabled();
        }
        if ($perMessageDeflateOptions->isEnabled() && !function_exists('deflate_add')) {
            trigger_error('permessage-deflate is being disabled because you do not have the zlib extension.', E_USER_NOTICE);
            $perMessageDeflateOptions = PermessageDeflateOptions::createDisabled();
        }

        $this->defaultHeader = $perMessageDeflateOptions->addHeaderToRequest($this->defaultHeader);
    }",0
"        $panel_body .= '<br>' . icon('person')
            . '<span class=""text-' . $shift['style'] . '"">'
            . $needed_angels['need'] . ' &times; ' . $needed_angels['angeltype_name']
            . '</span>';
    }

    $type = 'bg-dark';
    if (theme_type() == 'light') {
        $type = 'bg-light';
    }

    return div('col-md-3 mb-3', [
        div('dashboard-card card border-' . $shift['style'] . ' ' . $type, [
            div('card-body', [
                '<a class=""card-link"" href=""' . shift_link($shift) . '""></a>',
                $panel_body,
            ]),
        ]),
    ]);
}",1
"    protected function formatSegmentValue(CustomerSegmentInterface $segment)
    {
        return sprintf('<span class=""label label-default"">%s</span>', $segment->getName());
    }",1
"                $toPush = array(
                    'id' => $attr['id'],
                    'uuid' => $attr['uuid'],
                    'content' => $attr['value'],
                    'event_id' => $attr['event_id'],
                    'group' => 'attribute',
                    'timestamp' => $attr['timestamp'],
                    'first_seen' => $attr['first_seen'],
                    'last_seen' => $attr['last_seen'],
                    'attribute_type' => $attr['type'],
                    'date_sighting' => $sightingsAttributeMap[$attr['id']] ?? [],
                    'is_image' => $this->__eventModel->Attribute->isImage($attr),
                );
                $this->__json['items'][] = $toPush;
            }",1
"        $encodedImage = $this->imageManager->make($file->getStream())->heighten(60, function ($constraint) {
            $constraint->upsize();
        })->encode('png');",1
"function twitter_feed_get_user_tweets($twitter_handle = false, $results_count = 5) {

    $count = intval($results_count);
    $url = 'https://api.twitter.com/1.1/statuses/user_timeline.json';
	 
 
    $getfield = '?include_entities=true&include_rts=false&count=' . $count . '&exxclude_replies=true&nofilter=retweets&screen_name=' . $twitter_handle;
	//dd($url, $getfield); 
    $items = twitter_feed_perform_api_request($url, $getfield);
		
	if(isset($items[""errors""])){
		return;
	}
    return $items;
}",1
"    public function getSaveValue($value)
    {
        return strlen($value) ? $value : null;
    }",1
"    public function renderView()
    {
        /** @var RequestSql $obj */
        if (!($obj = $this->loadObject(true))) {
            return '';
        }

        try {
            if ($results = Db::readOnly()->getArray($obj->sql)) {
                foreach (array_keys($results[0]) as $key) {
                    $tabKey[] = $key;
                }

                $view['name'] = $obj->name;
                $view['key'] = $tabKey;
                $view['results'] = $results;

                $this->toolbar_title = $obj->name;

                $requestSql = new RequestSql();
                $view['attributes'] = $requestSql->attributes;
            } else {
                $view['error'] = true;
            }
        } catch (PrestaShopException $e) {
            $this->errors[] = $e->getMessage();
            $view = [
                'name'    => '',
                'key'     => '',
                'results' => [],
            ];
        }

        $this->tpl_view_vars = [
            'view' => $view,
        ];

        return parent::renderView();
    }",1
"    public static function typeEmail($value, array $params, array $field)
    {
        if (empty($value)) {
            return false;
        }

        if (!isset($params['max'])) {
            $params['max'] = 320;
        }

        $values = !is_array($value) ? explode(',', preg_replace('/\s+/', '', $value)) : $value;

        foreach ($values as $val) {
            if (!(self::typeText($val, $params, $field) && strpos($val, '@', 1))) {
                return false;
            }
        }

        return true;
    }",0
"    public function add()
    {
        $site = $this->app->make('site')->getSite();
        $brandingText = $site->getSiteName();
        /** @var Detector $detector */
        $detector = $this->app->make('multilingual/detector');

        $this->set('includeTransparency', false);
        $this->set('includeStickyNav', false);
        $this->set('includeNavigation', true);
        $this->set('includeNavigationDropdowns', false);
        $this->set('includeSearchInput', false);
        $this->set('includeBrandText', true);
        $this->set('includeBrandLogo', false);
        $this->set('brandingLogo', null);
        $this->set('brandingTransparentLogo', null);
        $this->set('searchInputFormActionPageID', null);
        $this->set('brandingText', $brandingText);
        $this->set('includeSwitchLanguage', $detector->isEnabled());
        $this->edit();
    }",1
"            $this->grid[$key] = array_merge(($this->grid[$key] ?? []), $data);
        }",1
"function smarty_function_sugarvar($params, &$smarty)
{
	if(empty($params['key']))  {
	    $smarty->trigger_error(""sugarvar: missing 'key' parameter"");
	    return;
	}

	$object = (empty($params['objectName']))?$smarty->get_template_vars('parentFieldArray'): $params['objectName'];
	$displayParams = $smarty->get_template_vars('displayParams');


	if(empty($params['memberName'])){
		$member = $smarty->get_template_vars('vardef');
		$member = $member['name'];
	}else{
		$members = explode('.', $params['memberName']);
		$member =  $smarty->get_template_vars($members[0]);
		for($i = 1; $i < count($members); $i++){
			$member = $member[$members[$i]];
		}
	}

    $_contents =  '$'. $object . '.' . $member . '.' . $params['key'];
	if(empty($params['stringFormat']) && empty($params['string'])) {
		$_contents = '{' . $_contents;
		if(!empty($displayParams['htmlescape'])){
			$_contents .= '|escape:\'html\'';
		}
		if(!empty($params['htmlentitydecode'])){
			$_contents .= '|escape:\'html_entity_decode\'';
		}
		if(!empty($displayParams['strip_tags'])){
			$_contents .= '|strip_tags';
		}
		if(!empty($displayParams['url2html'])){
			$_contents .= '|url2html';
		}
		if(!empty($displayParams['nl2br'])){
			$_contents .= '|nl2br';
		}

		$_contents .= '}';
    }
    return $_contents;
}",1
"    public function haltAction()
    {
        $backend = new Backend();
        $backend->configdRun('system halt', true);
        return [
            'status' => 'ok'
        ];
    }",1
"    public function __construct($channel, $filename)
    {
        parent::__construct('ChangeMonitor');
        $this->setKey('Channel', $channel);
        $this->setKey('File', $filename);
    }",0
"    public function getCurve()
    {
        if (!$this->key instanceof EC) {
            throw new UnsupportedAlgorithmException('Only EC keys have curves');
        }

        return $this->key->getCurve();
    }",0
"    public function getMaskingKey() {
        if (!$this->isMasked()) {
            return '';
        }

        $start  = 1 + $this->getNumPayloadBytes();

        if ($this->bytesRecvd < $start + static::MASK_LENGTH) {
            throw call_user_func($this->ufeg, 'Not enough data buffered to calculate the masking key');
        }

        return substr($this->data, $start, static::MASK_LENGTH);
    }",0
"    public function __construct($topicId) {
        $this->id = $topicId;
        $this->subscribers = new \SplObjectStorage;
    }",0
"    public function saveXHRFile($destination, $orig_name=''){

        $target = @fopen($destination, 'wb');
        $input  = @fopen(""php://input"", 'rb');

        if (!$target){
            return array(
                'success' => false,
                'error'   => LANG_UPLOAD_ERR_CANT_WRITE,
                'name'    => $orig_name,
                'path'    => ''
            );
        }
        if (!$input){
            return array(
                'success' => false,
                'error'   => LANG_UPLOAD_ERR_NO_FILE,
                'name'    => $orig_name,
                'path'    => ''
            );
        }

        while ($buff = fread($input, 4096)) {
            fwrite($target, $buff);
        }

        @fclose($target);
        @fclose($input);

        $real_size = filesize($destination);

        if (!$real_size || $real_size != $this->getXHRFileSize()){
            @unlink($destination);
            return array(
                'success' => false,
                'error'   => LANG_UPLOAD_ERR_PARTIAL,
                'name'    => $orig_name,
                'path'    => ''
            );
        }

        if($this->allowed_mime !== false){
            if(!$this->isMimeTypeAllowed($destination)){
                @unlink($destination);
                return array(
                    'error'   => LANG_UPLOAD_ERR_MIME.'. '.sprintf(LANG_PARSER_FILE_EXTS_FIELD_HINT, implode(', ', $this->allowed_mime_ext)),
                    'success' => false,
                    'name'    => $orig_name,
                    'path'    => ''
                );
            }
        }

        return array(
            'success' => true,
            'path'    => $destination,
            'url'     => str_replace($this->site_cfg->upload_path, '', $destination),
            'name'    => $orig_name,
            'size'    => $real_size
        );

    }",1
"		foreach ($parts as $part) {
			$pair = explode('=', $part);

			if (isset($pair[0])) {
				$key = (string)$pair[0];
			}

			if (isset($pair[1])) {
				$value = (string)$pair[1];
			} else {
				$value = '';
			}

			$result = $this->model_design_seo_url->getSeoUrlByKeyValue((string)$key, (string)$value);

			if ($result) {
				$paths[] = $result;

				unset($query[$key]);
			}
		}",1
"    public function getMaxUploadSize(){

        // вычисляем по тому, что меньше, т.к. если post_max_size меньше upload_max_filesize,
        // то максимум можно будет загрузить post_max_size
        $max_size = min(files_convert_bytes(@ini_get('upload_max_filesize')), files_convert_bytes(@ini_get('post_max_size')));

        return files_format_bytes($max_size);

    }",1
"    public function setUp()
    {
        global $mockTime;
        $this->_properties = array();
        $mockTime = true;
    }",0
"    public static function errconst($errno)
    {
        if (\function_exists('socket_strerror')) {
            foreach (\get_defined_constants(false) as $name => $value) {
                if ($value === $errno && \strpos($name, 'SOCKET_E') === 0) {
                    return ' (' . \substr($name, 7) . ')';
                }
            }
        }

        return '';
    }",0
"                                        <a href=""javascript:void(0);"" data-categorie-id=""<?= $page['id'] ?>"" class=""go-category left-side <?= isset($_GET['category']) && $_GET['category'] == $page['id'] ? 'selected' : '' ?>"">
                                            <?= $page['name'] ?>
                                        </a>
                                        <?php
                                        if ($children === true) {
                                            loop_tree($page['children'], true);
                                        } else {
                                            ?>
                                        </li>
                                        <?php
                                    }
                                }
                                ?>
                            </ul>
                            <?php
                            if ($is_recursion === true) {
                                ?>
                                </li>
                                <?php
                            }
                        }",1
"    public function testuploadAssets_Exception()
    {
        $themeMock = $this->getMockBuilder('\Box\Mod\Theme\Model\Theme')->disableOriginalConstructor()->getMock();
        $themeMock->expects($this->atLeastOnce())
            ->method('getPathAssets');
        $files = array(
            'test0' => array(
                'error' => UPLOAD_ERR_CANT_WRITE
            ),
        );
        $this->expectException(\Box_Exception::class);
        $this->expectExceptionMessage(sprintf(""Error uploading file %s Error code: %d"", 'test0', UPLOAD_ERR_CANT_WRITE));
        $this->service->uploadAssets($themeMock, $files);
    }",1
"    public function __construct($loop, $baseuri)
    {
        $this->key = \generateKey(32);

        $this->setWebsocket(config('daemon.port'));

        $this->loop    = $loop;
        $this->baseuri = $baseuri;

        DBSession::whereNotNull('id')->delete();

        // API_SOCKET ?
        if (file_exists(CACHE_PATH . 'socketapi.sock')) {
            unlink(CACHE_PATH . 'socketapi.sock');
        }

        array_map('unlink', array_merge(
            glob(PUBLIC_CACHE_PATH . '*.css'),
            glob(PUBLIC_CACHE_PATH . '*.js')
        ));

        $this->registerCleaner();

        // Generate Push Notification
        if (!file_exists(CACHE_PATH . 'vapid_keys.json')) {
            echo colorize(""Generate and store the Push Notification VAPID keys"", 'green').""\n"";
            $keyset = VAPID::createVapidKeys();
            file_put_contents(CACHE_PATH . 'vapid_keys.json', json_encode($keyset));
        }
    }",1
"    public function provideCustomDepthLimit()
    {
        return $this->createProviderForComplexityOrDepth(25);
    }",0
"		function _run_garbage_collector() {
			// @todo - Remove this check once the garbage collector is ready to be out of beta.
			if ( true !== fs_get_optional_constant( 'WP_FS__ENABLE_GARBAGE_COLLECTOR', false ) ) {
				return;
			}

			if ( ! $this->is_user_in_admin() ) {
				return;
			}

			require_once WP_FS__DIR_INCLUDES . '/class-fs-lock.php';

			$lock = new FS_Lock( 'garbage_collection' );

			if ( $lock->is_locked() ) {
				return;
			}

			// Create a 1-day lock.
			$lock->lock( WP_FS__TIME_24_HOURS_IN_SEC );

			FS_Garbage_Collector::instance()->clean();
		}",1
"    public function setSession(SessionInterface $session)
    {
        $this->session = $session;
    }",0
"    public function onOpen(ConnectionInterface $conn)
    {
        // WebSockets from the Browser
        $sid = $this->getSid($conn);
        if ($sid != null) {
            $path = $this->getPath($conn);

            if (in_array($path, $this->single)) {
                if (array_key_exists($sid, $this->singlelocks)
                && array_key_exists($path, $this->singlelocks[$sid])) {
                    $this->singlelocks[$sid][$path]++;
                    $conn->close(1008);
                } else {
                    $this->singlelocks[$sid][$path] = 1;
                }
            }

            if (!array_key_exists($sid, $this->sessions)) {
                $language = $this->getLanguage($conn);
                $offset = $this->getOffset($conn);

                $this->sessions[$sid] = new Session(
                    $this->loop,
                    $sid,
                    $this->baseuri,
                    config('daemon.port'),
                    $this->key,
                    $language,
                    $offset,
                    config('daemon.verbose'),
                    config('daemon.debug')
                );
            }

            $this->sessions[$sid]->attach($conn);
        } else {
            // WebSocket from the internal subprocess
            $sid = $this->getHeaderSid($conn);
            if ($sid != null && isset($this->sessions[$sid])) {
                $this->sessions[$sid]->attachInternal($conn);

                $obj = new \StdClass;
                $obj->func = 'started';
                $this->sessions[$sid]->messageOut(json_encode($obj));
            }
        }
    }",1
"    public function close() {
        $this->conn->end();
    }",0
"	public function linkOut($path,$token=false){
		$parse  = KodIO::parse($path);
		$info   = IO::info($path);
		$apiKey = 'explorer/index/fileOut';
		if($parse['type'] == KodIO::KOD_SHARE_LINK){
			$apiKey = 'explorer/share/fileOut';
		}
		$etag = substr(md5($path),0,5);
		$name = isset($this->in['name']) ? rawurlencode($this->in['name']):'';
		if($info){
			$name = rawurlencode($info['name']);
			$etag = substr(md5($info['modifyTime'].$info['size']),0,5);
		}
		$url = urlApi($apiKey,""path="".rawurlencode($path).'&et='.$etag.'&name=/'.$name);
		if($token) $url .= '&accessToken='.Action('user.index')->accessToken();
		return $url;
	}",1
"                htmlspecialchars($angeltype->name)
            )
        );",0
"    private function cleanupEncryptedPasswords()
    {
        EncryptedPassword::where('updated_at', '<', date(MOVIM_SQL_DATE, time()-(60*60*24*7)))
            ->delete();
    }",1
"    protected function encryptBlock($in)
    {
        // Salsa20 does not utilize this method
    }",0
"function twitter_feed_perform_api_request($url = 'https://api.twitter.com/1.1/search/tweets.json', $getfield = false) {


    $oauth_access_token = get_option('access_token', 'twitter_feed');
    $oauth_access_token_secret = get_option('access_token_secret', 'twitter_feed');
    $consumer_key = get_option('consumer_key', 'twitter_feed');
    $consumer_secret = get_option('consumer_secret', 'twitter_feed');


    if ($oauth_access_token==false){
        $oauth_access_token = ""220111598-87eLa7MgXZmd7YeRSkenTSVxhZikok61PXMKZFti"";
    }

    if ($oauth_access_token_secret==false){
        $oauth_access_token_secret = ""KsDrxrxoGqVVK0ethvcTTrV58RBH3WUjnPeI616fnxIFS"";
    }

    if ($consumer_key==false){
        $consumer_key = ""WgDmyOjMgX1N7RhcLpQqzUrtR""; 
    }


    if ($consumer_secret==false){
        $consumer_secret = ""0e8PlzIeKlmGGyH1ajS2Ggaw0anPTX23p3gp2WqZ0PCNxkYYX1"";
    }


    if (!$oauth_access_token || !$oauth_access_token_secret || !$consumer_key || !$consumer_secret){
        return false;
    }


    $cache_expiration_minutes = 1500;
    $cache_id = md5($url . $getfield);
    $cache_group = 'twitter_feed_2';
    $cached_results = cache_get($cache_id, $cache_group,$cache_expiration_minutes);
    if ($cached_results!=false){
        return $cached_results;
    }

    $settings = array(
        'oauth_access_token'        => $oauth_access_token,
        'oauth_access_token_secret' => $oauth_access_token_secret,
        'consumer_key'              => $consumer_key,
        'consumer_secret'           => $consumer_secret
    );

    $requestMethod = 'GET';

    $twitter = new TwitterAPIExchange($settings);
    $response = $twitter->setGetfield($getfield)
        ->buildOauth($url, $requestMethod)
        ->performRequest();


    $return = json_decode($response, true);

	

    if (!empty($return)){
        cache_save($return, $cache_id, $cache_group, $cache_expiration_minutes);
    }




    return $return;
}",1
"$opt = ['entity' => $_POST[""entity_restrict""]];",1
"    function feof($resource) {
        global $mockFgets;
        if (isset($mockFgets) && $mockFgets === true) {
            return false;
        }
        return \feof($resource);
    }",0
"    public function setUserId($id) {
        $this->user_id = $id; return $this;
    }",1
"    public function getMetadata($key = null)
    {
        if (!$key) {
            return $this->metadata;
        }

        return $this->metadata[$key] ?? null;
    }",0
"    public function cancelTimer(TimerInterface $timer)
    {
        if (!isset($this->timers[$timer])) {
            return;
        }

        $event = $this->timers[$timer];
        $event->stop();
        $this->timers->detach($timer);
    }",0
"    public function &getCurrentCert()
    {
        return $this->currentCert;
    }",0
"    public function removeSecondaryImage()
    {
        if ($this->input->is_ajax_request()) {
            $img = '.' . DIRECTORY_SEPARATOR . 'attachments' . DIRECTORY_SEPARATOR . 'shop_images' . DIRECTORY_SEPARATOR . '' . $_POST['folder'] . DIRECTORY_SEPARATOR . $_POST['image'];
            unlink($img);
        }
    }",1
"    public function end($data = null)
    {
        $this->readable->pause();
        $this->writable->end($data);
    }",0
"function get_tracks($type)
{
    static $pattern = '#^a:\d+:{[i:;\d]+}$#';

    switch ($type) {
        case 'topic':
            $c_name = COOKIE_TOPIC;
            break;
        case 'forum':
            $c_name = COOKIE_FORUM;
            break;
        case 'pm':
            $c_name = COOKIE_PM;
            break;
        default:
            trigger_error(__FUNCTION__ . "": invalid type '$type'"", E_USER_ERROR);
    }
    $tracks = !empty($_COOKIE[$c_name]) ? @unserialize($_COOKIE[$c_name]) : false;
    return $tracks ?: [];
}",1
"    public function saveInboundEmailSystemSettings($type, $macro)
    {
        global $sugar_config;

        // inbound_email_case_subject_macro
        $var = ""inbound_email_"" . strtolower($type) . ""_subject_macro"";
        $sugar_config[$var] = $macro;

        ksort($sugar_config);

        $sugar_config_string = ""<?php\n"" .
            '// created: ' . date('Y-m-d H:i:s') . ""\n"" .
            '$sugar_config = ' .
            var_export($sugar_config, true) .
            "";\n?>\n"";

        write_array_to_file(""sugar_config"", $sugar_config, ""config.php"");
    }

    /**
     * returns the HTML for InboundEmail system settings
     * @return string HTML
     */
    public function getSystemSettingsForm()
    {
        global $sugar_config;
        global $mod_strings;
        global $app_strings;
        global $app_list_strings;

        $c = BeanFactory::newBean('Cases');
        $template = new Sugar_Smarty();
        $template->assign('APP', $app_strings);
        $template->assign('MOD', $mod_strings);
        $template->assign('MACRO', $c->getEmailSubjectMacro());

        return $template->fetch('modules/InboundEmail/tpls/systemSettingsForm.tpl');
    }

    /**
     * For mailboxes of type ""Support"" parse for '[CASE:%1]'
     *
     * @param string $emailName The subject line of the email
     * @param aCase $aCase A Case object
     *
     * @return string|boolean   Case ID or FALSE if not found
     */
    public function getCaseIdFromCaseNumber($emailName, $aCase)
    {
        //$emailSubjectMacro
        $exMacro = explode('%1', $aCase->getEmailSubjectMacro());
        $open = $exMacro[0];
        $close = $exMacro[1];

        if ($sub = stristr($emailName, $open)) {
            // eliminate everything up to the beginning of the macro and return the rest
            // $sub is [CASE:XX] xxxxxxxxxxxxxxxxxxxxxx
            $sub2 = str_replace($open, '', $sub);
            // $sub2 is XX] xxxxxxxxxxxxxx
            $sub3 = substr($sub2, 0, strpos($sub2, $close));

            // case number is supposed to be numeric
            if (ctype_digit($sub3)) {
                // filter out deleted records in order to create a new case
                // if email is related to deleted one (bug #49840)
                $query = 'SELECT id FROM cases WHERE case_number = '
                    . $this->db->quoted($sub3)
                    . ' and deleted = 0';
                $results = $this->db->query($query, true);
                $row = $this->db->fetchByAssoc($results);
                if (!empty($row['id'])) {
                    return $row['id'];
                }
            }
        }

        return false;
    }

    /**
     * @param $option_name
     * @param null $default_value
     * @param null $stored_options
     * @return mixed
     */
    public function get_stored_options($option_name, $default_value = null, $stored_options = null)
    {
        if (empty($stored_options)) {
            $stored_options = $this->stored_options;
        }

        return self::get_stored_options_static($option_name, $default_value, $stored_options);
    }

    /**
     * Returns the stored options property un-encoded and un serialised.
     * @return array
     */
    public function getStoredOptions()
    {
        return sugar_unserialize(base64_decode($this->stored_options));
    }

    /**
     * @param array $options
     */
    public function setStoredOptions($options)
    {
        $this->stored_options = base64_encode(serialize($options));
    }


    /**
     * @param $option_name
     * @param null $default_value
     * @param null $stored_options
     * @return mixed
     */
    public static function get_stored_options_static($option_name, $default_value = null, $stored_options = null)
    {
        if (!empty($stored_options)) {
            $storedOptions = sugar_unserialize(base64_decode($stored_options));
            if (isset($storedOptions[$option_name])) {
                $default_value = $storedOptions[$option_name];
            }
        }

        return $default_value;
    }


    /**
     * This function returns a contact or user ID if a matching email is found
     * @param    $email        the email address to match
     * @param    $table        which table to query
     */
    public function getRelatedId($email, $module)
    {
        $email = trim(strtoupper($email));
        if (strpos($email, ',') !== false) {
            $emailsArray = explode(',', $email);
            $emailAddressString = """";
            foreach ($emailsArray as $emailAddress) {
                if (!empty($emailAddressString)) {
                    $emailAddressString .= "","";
                }
                $emailAddressString .= $this->db->quoted(trim($emailAddress));
            } // foreach
            $email = $emailAddressString;
        } else {
            $email = $this->db->quoted($email);
        } // else
        $module = $this->db->quoted(ucfirst($module));

        $q = ""SELECT bean_id FROM email_addr_bean_rel eabr
                JOIN email_addresses ea ON (eabr.email_address_id = ea.id)
                WHERE bean_module = $module AND ea.email_address_caps in ( {$email} ) AND eabr.deleted=0"";

        $r = $this->db->query($q, true);

        $retArr = array();
        while ($a = $this->db->fetchByAssoc($r)) {
            $retArr[] = $a['bean_id'];
        }
        if (count($retArr) > 0) {
            return $retArr;
        }

        return false;
    }

    /**
     * finds emails tagged ""//UNSEEN"" on mailserver and ""SINCE: [date]"" if that
     * option is set
     *
     * @return array Array of messageNumbers (mail server's internal keys)
     */
    public function getNewMessageIds()
    {
        $storedOptions = sugar_unserialize(base64_decode($this->stored_options));

        //TODO figure out if the since date is UDT
        if (!is_bool($storedOptions) && $storedOptions['only_since']) {// POP3 does not support Unseen flags
            if (!isset($storedOptions['only_since_last']) && !empty($storedOptions['only_since_last'])) {
                $q = ""SELECT last_run FROM schedulers WHERE job = '{$this->job_name}'"";
                $r = $this->db->query($q, true);
                $a = $this->db->fetchByAssoc($r);

                $date = date('r', strtotime($a['last_run']));
                LoggerManager::getLogger()->debug(""-----> getNewMessageIds() executed query: {$q}"");
            } else {
                $date = $storedOptions['only_since_last'];
            }
            $ret = $this->getImap()->search('SINCE ""' . $date . '"" UNDELETED UNSEEN');
            $check = $this->getImap()->check();
            $storedOptions['only_since_last'] = $check->Date;
            $this->stored_options = base64_encode(serialize($storedOptions));
            $this->save();
        } else {
            if (!$this->getImap()->isValidStream($this->conn)) {
                LoggerManager::getLogger()->fatal('Inbound Email Connection is not valid resource for getting New Message Ids.');

                return false;
            }
            $ret = $this->getImap()->search('UNDELETED UNSEEN');
        }

        $nmessages = is_countable($ret)? count($ret) : 0;
        LoggerManager::getLogger()->debug('-----> getNewMessageIds() got ' . $nmessages . ' new Messages');

        return $ret;
    }

    /**
     * Constructs the resource connection string that IMAP needs
     * @param string $service Service string, will generate if not passed
     * @return string
     */
    public function getConnectString($service = '', $mbox = '', $includeMbox = true)
    {
        $service = empty($service) ? $this->getServiceString() : $service;
        $mbox = empty($mbox) ? $this->mailbox : $mbox;

        $protocol = $this->protocol ?? 'imap';
        $port = $this->port ?? '143';

        $connectString = '{' . $this->server_url . ':' . $port . '/service=' . $protocol . $service . '}';

        if (!empty($this->connection_string)){
            $connectString = '{' . $this->connection_string . '}';
        }

        $connectString .= ($includeMbox) ? $mbox : """";

        return $connectString;
    }

    /**
     *
     */
    public function disconnectMailserver()
    {
        if ($this->getImap()->isValidStream($this->conn)) {
            $this->getImap()->close();
        }
    }

    /**
     * Connects to mailserver.  If an existing IMAP resource is available, it
     * will attempt to reuse the connection, updating the mailbox path.
     *
     * @param bool test Flag to test connection
     * @param bool force Force reconnect
     * @return string ""true"" on success, ""false"" or $errorMessage on failure
     */
    public function connectMailserver($test = false, $force = false)
    {
        global $mod_strings;

        $msg = '';

        if (!$this->getImap()->isAvailable()) {
            $GLOBALS['log']->debug('------------------------- IMAP libraries NOT available!!!! die()ing thread.----');

            return $mod_strings['LBL_WARN_NO_IMAP'];
        }


        $this->getImap()->getErrors(); // clearing error stack
        //error_reporting(0); // turn off notices from IMAP

        // tls::ca::ssl::protocol::novalidate-cert::notls

        if (!isset($_REQUEST['ssl'])) {
            LoggerManager::getLogger()->warn('Request ssl value not found.');
            $requestSsl = null;
        } else {
            $requestSsl = $_REQUEST['ssl'];
        }

        $useSsl = ($requestSsl == 'true') ? true : false; // TODO: validate the ssl request variable value (for e.g its posibble to give a numeric 1 as true)
        if ($test) {
            $this->getImap()->setTimeout(1, 5); // 60 secs is the default
            $this->getImap()->setTimeout(2, 5);
            $this->getImap()->setTimeout(3, 5);

            $opts = $this->findOptimumSettings($useSsl);
            if (!empty($opts) && isset($opts['good']) && empty($opts['good'])) {
                $ret = array_pop($opts['err']); // TODO: lost error info?

                return $ret;
            }
            if (!empty($opts) && is_array($opts['service'])) {
                $service = $opts['service'];
            } else {
                $service = null;
            }
            $service = str_replace('foo', '', $service); // foo there to support no-item explodes
        } else {
            $service = $this->getServiceString();
        }

        if (!isset($_REQUEST['folder'])) {
            LoggerManager::getLogger()->warn('Requested folder is not defined');
            $requestFolder = null;
        } else {
            $requestFolder = $_REQUEST['folder'];
        }

        if ($requestFolder === 'sent') {
            $this->mailbox = $this->get_stored_options('sentFolder');
        }

        if ($requestFolder === 'inbound') {
            if (!empty($_REQUEST['folder_name'])) {
                $this->mailbox = $_REQUEST['folder_name'];
            } elseif ($this->mailboxarray && (is_countable($this->mailboxarray) ? count($this->mailboxarray) : 0)) {
                $this->mailbox = $this->mailboxarray[0];
            } else {
                $this->mailbox = 'INBOX';
            }
        }

        $connectString = $this->getConnectString($service, $this->mailbox);

        /*
         * Try to recycle the current connection to reduce response times
         */
        if ($this->getImap()->isValidStream($this->getImap()->getConnection())) {
            if ($force) {
                // force disconnect
                $this->getImap()->close();
            }

            if ($this->getImap()->ping()) {
                // we have a live connection
                $this->getImap()->reopen($connectString, CL_EXPUNGE);
            }
        }

        // final test
        if (!$this->getImap()->isValidStream($this->getImap()->getConnection()) && !$test) {

            $imapUser = $this->email_user;
            [$imapPassword, $imapOAuthConnectionOptions] = $this->getOAuthCredentials($this->email_password, CL_EXPUNGE);

            $this->conn = $this->getImapConnection(
                $connectString,
                $imapUser,
                $imapPassword,
                $imapOAuthConnectionOptions
            );
        }

        if ($test) {
            if ($opts === false && !$this->getImap()->isValidStream($this->getImap()->getConnection())) {

                $imapUser = $this->email_user;
                [$imapPassword, $imapOAuthConnectionOptions] = $this->getOAuthCredentials($this->email_password, CL_EXPUNGE);

                $this->conn = $this->getImapConnection(
                    $connectString,
                    $imapUser,
                    $imapPassword,
                    $imapOAuthConnectionOptions
                );
            }
            $errors = '';
            $alerts = '';
            $successful = false;
            if (($errors = $this->getImap()->getLastError()) || ($alerts = $this->getImap()->getAlerts()) || !$this->conn) {
                if ($errors === 'Mailbox is empty') { // false positive
                    $successful = true;
                } else {
                    if (!isset($msg)) {
                        $msg = $errors;
                    } else {
                        $msg .= $errors;
                    }
                    $msg .= '<p>' . $alerts . '<p>';
                    $msg .= '<p>' . $mod_strings['ERR_TEST_MAILBOX'];
                }
            } else {
                $successful = true;
            }

            if ($successful) {
                if ($this->protocol == 'imap') {
                    $msg .= $mod_strings['LBL_TEST_SUCCESSFUL'];
                } else {
                    $msg .= $mod_strings['LBL_POP3_SUCCESS'];
                }
            }

            $this->getImap()->getErrors(); // collapse error stack

            if ($this->getImap()->isValidStream($this->getImap()->getConnection())) {
                $this->getImap()->close();
            } else {
                LoggerManager::getLogger()->warn('Connection is not a valid resource.');
            }


            return $msg;
        } elseif (!$this->getImap()->isValidStream($this->getImap()->getConnection())) {
            $GLOBALS['log']->fatal('Couldn\'t connect to mail server id: ' . $this->id);

            return ""false"";
        }
        $GLOBALS['log']->info('Connected to mail server id: ' . $this->id);

        return ""true"";
    }

    /**
     * @return mixed|string|void
     */
    public function checkImap()
    {
        global $app_strings, $mod_strings;

        if (!$this->getImap()->isAvailable()) {
            $template = new Sugar_Smarty();
            $template->assign('APP', $app_strings);
            $template->assign('MOD', $mod_strings);
            $output = $template->fetch('modules/InboundEmail/tpls/checkImap.tpl');
            echo $output;

            return $output;
        }
    }

    /**
     * Attempt to create an IMAP connection using passed in parameters
     * return either the connection resource or false if unable to connect
     *
     * @param string $mailbox Mailbox to be used to create imap connection
     * @param string $username The user name
     * @param string $password The password associated with the username
     * @param integer $options Bitmask for options parameter to the imap_open function
     *
     * @return resource|boolean  Connection resource on success, FALSE on failure
     */
    protected function getImapConnection($mailbox, $username, $password, $options = 0)
    {
        $connection = null;
        $authenticators = ['', 'GSSAPI', 'NTLM'];

        $isOAuth = $this->isOAuth();
        if ($isOAuth === true) {
            $token = $this->getOAuthToken($this->external_oauth_connection_id ?? '');

            if ($token === null) {
                return false;
            }

            $password = $token;
        }

        while (!$connection && ($authenticator = array_shift($authenticators)) !== null) {
            if ($authenticator) {
                $params = [
                    'DISABLE_AUTHENTICATOR' => $authenticator,
                ];
            } else {
                $params = [];
            }

            $connection = $this->getImap()->open($mailbox, $username, $password, $options, 0, $params);

            if (!$connection){
                break;
            }

        }

        return $connection;
    }

    /**
     * retrieves an array of I-E beans based on the group_id
     * @param string $groupId GUID of the group user or Individual
     * @return    array    $beans        array of beans
     * @return    boolean false if none returned
     */
    public function retrieveByGroupId($groupId)
    {
        $q = '
          SELECT id FROM inbound_email
          WHERE
            group_id = \'' . $groupId . '\' AND
            deleted = 0 AND
            status = \'Active\'';
        $r = $this->db->query($q, true);

        $beans = array();
        while ($a = $this->db->fetchByAssoc($r)) {
            $ie = BeanFactory::newBean('InboundEmail');
            $ie->retrieve($a['id']);
            $beans[$a['id']] = $ie;
        }

        return $beans;
    }

    /**
     * Retrieves the current count of personal accounts for the user specified.
     *
     * @param unknown_type $user
     */
    public function getUserPersonalAccountCount($user = null)
    {
        if ($user == null) {
            $user = $GLOBALS['current_user'];
        }

        $query = ""SELECT count(*) as c FROM inbound_email WHERE deleted=0 AND is_personal='1' AND (group_id='{$user->id}' OR created_by='{$user->id}') AND status='Active'"";

        $rs = $this->db->query($query);
        $row = $this->db->fetchByAssoc($rs);

        return $row['c'];
    }

    /**
     * retrieves an array of I-E beans based on the group folder id
     * @param string $groupFolderId GUID of the group folder
     * @return    array    $beans        array of beans
     * @return    boolean false if none returned
     */
    public function retrieveByGroupFolderId($groupFolderId)
    {
        $q = 'SELECT id FROM inbound_email WHERE groupfolder_id = \'' . $groupFolderId . '\' AND deleted = 0 ';
        $r = $this->db->query($q, true);

        $beans = array();
        while ($a = $this->db->fetchByAssoc($r)) {
            $ie = BeanFactory::newBean('InboundEmail');
            $ie->retrieve($a['id']);
            $beans[] = $ie;
        }

        return $beans;
    }

    /**
     * Retrieves an array of I-E beans that the user has team access to
     *
     * @param string $id user id
     * @param bool $includePersonal
     * @return array
     */
    public function retrieveAllByGroupId($id, $includePersonal = true)
    {
        $beans = ($includePersonal) ? $this->retrieveByGroupId($id) : array();
        $q = ""
          SELECT inbound_email.id FROM inbound_email
          WHERE
            is_personal = 0 AND
            -- (groupfolder_id is null OR groupfolder_id = '') AND
            mailbox_type not like 'bounce' AND
            inbound_email.deleted = 0 AND
            status = 'Active' "";
        $r = $this->db->query($q, true);

        while ($a = $this->db->fetchByAssoc($r)) {
            $found = false;
            foreach ($beans as $bean) {
                if ($bean->id == $a['id']) {
                    $found = true;
                }
            }

            if (!$found) {
                $ie = BeanFactory::newBean('InboundEmail');
                $ie->retrieve($a['id']);
                $beans[$a['id']] = $ie;
            }
        }

        return $beans;
    }

    /**
     * Retrieves an array of I-E beans that the user has team access to including group
     *
     * @param string $id
     * @param bool $includePersonal
     * @return InboundEmail[]
     */
    public function retrieveAllByGroupIdWithGroupAccounts($id, $includePersonal = true)
    {
        $beans = ($includePersonal) ? $this->retrieveByGroupId($id) : array();

        $q = ""
          SELECT DISTINCT inbound_email.id
          FROM inbound_email
          WHERE
            is_personal = 0 AND
            mailbox_type not like 'bounce' AND
            status = 'Active' AND
            inbound_email.deleted = 0 "";
        $r = $this->db->query($q, true);

        while ($a = $this->db->fetchByAssoc($r)) {
            $found = false;
            foreach ($beans as $bean) {
                if ($bean->id == $a['id']) {
                    $found = true;
                }
            }

            if (!$found) {
                $ie = BeanFactory::newBean('InboundEmail');
                $ie->retrieve($a['id']);
                $beans[$a['id']] = $ie;
            }
        }

        return $beans;
    }


    /**
     * returns the bean name - overrides SugarBean's
     */
    public function get_summary_text()
    {
        return $this->name;
    }

    /**
     * Override's SugarBean's
     */
    public function create_export_query($order_by, $where, $show_deleted = 0)
    {
        return $this->create_new_list_query($order_by, $where, array(), array(), $show_deleted);
    }

    /**
     * @return array
     */
    public function getUserInboundAccounts(): array {
        global $current_user, $db;

        $where = '';
        if (is_admin($current_user)) {
            $currentUserId = $db->quote($current_user->id);
            $tableName = $db->quote($this->table_name);
            $where = ""(($tableName.is_personal IS NULL) OR ($tableName.is_personal = 0 ) OR ($tableName.is_personal = 1 AND $tableName.created_by = '$currentUserId'))"";
        }

        return $this->get_list('', $where)['list'] ?? [];
    }

    /**
     * @inheritDoc
     */
    public function create_new_list_query(
        $order_by,
        $where,
        $filter = array(),
        $params = array(),
        $show_deleted = 0,
        $join_type = '',
        $return_array = false,
        $parentbean = null,
        $singleSelect = false,
        $ifListForExport = false
    ) {
        global $current_user, $db;

        $ret_array = parent::create_new_list_query(
            $order_by,
            $where,
            $filter,
            $params ,
            $show_deleted,
            $join_type,
            true,
            $parentbean,
            $singleSelect,
            $ifListForExport
        );

        if(is_admin($current_user)) {
            if ($return_array) {
                return $ret_array;
            }

            return $ret_array['select'] . $ret_array['from'] . $ret_array['where'] . $ret_array['order_by'];
        }

        if (is_array($ret_array) && !empty($ret_array['where'])){
            $tableName = $db->quote($this->table_name);
            $currentUserId = $db->quote($current_user->id);

            $showGroupRecords = ""($tableName.is_personal IS NULL) OR ($tableName.is_personal = 0) OR "";

            $hasActionAclsDefined = has_group_action_acls_defined('InboundEmail', 'list');

            if($hasActionAclsDefined === false) {
                $showGroupRecords = '';
            }

            $ret_array['where'] = $ret_array['where'] . "" AND ( $showGroupRecords ($tableName.is_personal = 1 AND $tableName.created_by = '$currentUserId') )"";
        }

        if ($return_array) {
            return $ret_array;
        }

        return $ret_array['select'] . $ret_array['from'] . $ret_array['where'] . $ret_array['order_by'];
    }

    /**
     * Override's SugarBean's
     */

    /**
     * Override's SugarBean's
     */
    public function get_list_view_data()
    {
        global $mod_strings;
        global $app_list_strings;
        $temp_array = $this->get_list_view_array();

        $temp_array['MAILBOX_TYPE_NAME'] = '';
        if (!empty($this->mailbox_type)) {
            if (!isset($app_list_strings['dom_mailbox_type'][$this->mailbox_type])) {
                LoggerManager::getLogger()->fatal('Language string not found for app_list_string[dom_mailbox_type][' . $this->mailbox_type . ']');
            }
            $temp_array['MAILBOX_TYPE_NAME'] = $app_list_strings['dom_mailbox_type'][$this->mailbox_type] ?? null;
        }

        //cma, fix bug 21670.
        $temp_array['GLOBAL_PERSONAL_STRING'] = ($this->is_personal ? $mod_strings['LBL_IS_PERSONAL'] : $mod_strings['LBL_IS_GROUP']);
        $temp_array['STATUS'] = ($this->status == 'Active') ? $mod_strings['LBL_STATUS_ACTIVE'] : $mod_strings['LBL_STATUS_INACTIVE'];

        return $temp_array;
    }

    /**
     * Override's SugarBean's
     */
    public function fill_in_additional_list_fields()
    {
        $this->fill_in_additional_detail_fields();
    }

    /**
     * Override's SugarBean's
     */
    public function fill_in_additional_detail_fields()
    {
        $this->calculateType();
        $this->calculateDefault();
        $this->calculateSignature();

        $this->expandStoreOptions();

        if (!empty($this->service)) {
            $exServ = explode('::', $this->service);
            $this->tls = $exServ[0];
            if (isset($exServ[1])) {
                $this->ca = $exServ[1];
            }
            if (isset($exServ[2])) {
                $this->ssl = $exServ[2];
            }
            if (isset($exServ[3])) {
                $this->protocol = $exServ[3];
            }
        }
    }

    public function calculateType(): void {

        if (!empty($this->type)){
            return;
        }

        if (isTrue($this->is_personal ?? false)) {
            $this->type = 'personal';
            return;
        }

        $mailboxType = $this->mailbox_type ?? '';
        if ($mailboxType === 'createcase') {
            $this->type = 'group';
            return;
        }

        if ($mailboxType === 'bounce') {
            $this->type = 'bounce';
            return;
        }

        if ($mailboxType === 'pick' ) {
            $this->type = 'group';
        }
    }

    public function calculateDefault(): void {

        global $current_user;

        if ($this->type === 'personal' && $this->getUsersDefaultOutboundServerId($current_user) === $this->id) {
            $this->is_default = 1;
        }
    }

    public function calculateSignature(): void {
        $inboundEmailId = $this->id ?? '';
        $createdBy = $this->created_by ?? '';

        if ($inboundEmailId === '' || $createdBy === '') {
            return;
        }

        /** @var User $owner */
        $owner = BeanFactory::getBean('Users', $createdBy);

        $emailSignatures = $owner->getPreference('account_signatures', 'Emails') ?? '';
        $emailSignatures = sugar_unserialize(base64_decode($emailSignatures));

        $signatureId = $emailSignatures[$inboundEmailId] ?? '';

        if ($signatureId !== '') {
            $this->account_signature_id = $signatureId;
        }
    }

    /**
     * Expand options
     * @return void
     */
    public function expandStoreOptions(): void {

        if (empty($this->stored_options)) {
            return;
        }

        // FROM NAME and Address
        $storedOptions = unserialize(base64_decode($this->stored_options), ['allowed_classes' => false]);

        $this->from_name = ($storedOptions['from_name'] ?? '');
        $this->from_addr = ($storedOptions['from_addr'] ?? '');
        $this->reply_to_name = $storedOptions['reply_to_name'] ?? '';
        $this->reply_to_addr = $storedOptions['reply_to_addr'] ?? '';
        $this->only_since = isTrue($storedOptions['LBL_ONLY_SINCE_NO'] ?? false);
        $this->filter_domain = $storedOptions['filter_domain'] ?? '';
        $this->trashFolder =  $storedOptions['trashFolder'] ?? '';
        $this->sentFolder = $storedOptions['sentFolder'] ?? '';
        $this->mailbox = $storedOptions['mailbox'] ?? '';

        $this->leave_messages_on_mail_server = isTrue($storedOptions['leaveMessagesOnMailServer'] ?? false);
        $this->move_messages_to_trash_after_import = !isTrue($storedOptions['leaveMessagesOnMailServer'] ?? true);

        $this->distrib_method = $storedOptions['distrib_method'] ?? '';
        $this->distribution_user_id = $storedOptions['distribution_user_id'] ?? '';
        $this->distribution_options = $storedOptions['distribution_options'] ?? '';
        $this->create_case_template_id = $storedOptions['create_case_email_template'] ?? '';
        $this->email_num_autoreplies_24_hours = $storedOptions['email_num_autoreplies_24_hours'] ?? $this->defaultEmailNumAutoreplies24Hours;

        $this->is_auto_import = isTrue($storedOptions['isAutoImport'] ?? false);
        $this->is_create_case = ($this->mailbox_type ?? '') === 'createcase';
        $this->allow_outbound_group_usage = isTrue($storedOptions['allow_outbound_group_usage'] ?? false);

        $this->outbound_email_id = $storedOptions['outbound_email'] ?? '';
    }

    /**
     * Checks for $user's autoImport setting and returns the current value
     * @param object $user User in focus, defaults to $current_user
     * @return bool
     */
    public function isAutoImport($user = null)
    {
        if (!empty($this->autoImport)) {
            return $this->autoImport;
        }

        global $current_user;
        if (empty($user)) {
            $user = $current_user;
        }

        $emailSettings = $current_user->getPreference('emailSettings', 'Emails');
        $emailSettings = is_string($emailSettings) ? sugar_unserialize($emailSettings) : $emailSettings;

        $this->autoImport = (isset($emailSettings['autoImport']) && !empty($emailSettings['autoImport'])) ? true : false;

        return $this->autoImport;
    }

    /**
     * Clears out cache files for a user
     */
    public function cleanOutCache()
    {
        $GLOBALS['log']->debug(""INBOUNDEMAIL: at cleanOutCache()"");
        $this->deleteCache();
    }

    /**
     * moves emails from folder to folder
     * @param string $fromIe I-E id
     * @param string $fromFolder IMAP path to folder in which the email lives
     * @param string $toIe I-E id
     * @param string $toFolder
     * @param string $uids UIDs of emails to move, either Sugar GUIDS or IMAP
     * UIDs
     */
    public function copyEmails($fromIe, $fromFolder, $toIe, $toFolder, $uids)
    {
        $this->moveEmails($fromIe, $fromFolder, $toIe, $toFolder, $uids, true);
    }

    /**
     * moves emails from folder to folder
     * @param string $fromIe I-E id
     * @param string $fromFolder IMAP path to folder in which the email lives
     * @param string $toIe I-E id
     * @param string $toFolder
     * @param string $uids UIDs of emails to move, either Sugar GUIDS or IMAP
     * UIDs
     * @param bool $copy Default false
     * @return bool True on successful execution
     */
    public function moveEmails($fromIe, $fromFolder, $toIe, $toFolder, $uids, $copy = false)
    {
        global $app_strings;
        global $current_user;


        // same I-E server
        if ($fromIe == $toIe) {
            $GLOBALS['log']->debug(""********* SUGARFOLDER - moveEmails() moving email from I-E to I-E"");
            //$exDestFolder = explode(""::"", $toFolder);
            //preserve $this->mailbox
            if ($this->mailbox !== null) {
                $oldMailbox = $this->mailbox;
            }


            $this->retrieve($fromIe);
            $this->mailbox = $fromFolder;
            $this->connectMailserver();
            $exUids = explode('::;::', $uids);
            $uids = implode("","", $exUids);
            // imap_mail_move accepts comma-delimited lists of UIDs
            if ($copy) {
                if ($this->getImap()->mailCopy($uids, $toFolder, CP_UID)) {
                    $this->mailbox = $toFolder;
                    $this->connectMailserver();
                    $newOverviews = $this->getImap()->fetchOverview($uids, FT_UID);
                    $this->updateOverviewCacheFile($newOverviews, 'append');
                    if (isset($oldMailbox)) {
                        $this->mailbox = $oldMailbox;
                    }

                    return true;
                }
                $GLOBALS['log']->debug(""INBOUNDEMAIL: could not imap_mail_copy() [ {$uids} ] to folder [ {$toFolder} ] from folder [ {$fromFolder} ]"");
            } else {
                if ($this->getImap()->mailMove($uids, $toFolder, CP_UID)) {
                    $GLOBALS['log']->info(""INBOUNDEMAIL: imap_mail_move() [ {$uids} ] to folder [ {$toFolder} ] from folder [ {$fromFolder} ]"");
                    $this->getImap()->expunge(); // hard deletes moved messages

                    // update cache on fromFolder
                    $newOverviews = $this->getOverviewsFromCacheFile($uids, $fromFolder, true);
                    $this->deleteCachedMessages($uids, $fromFolder);

                    // update cache on toFolder
                    $this->checkEmailOneMailbox($toFolder, true, true);
                    if (isset($oldMailbox)) {
                        $this->mailbox = $oldMailbox;
                    }

                    return true;
                }
                $GLOBALS['log']->debug(""INBOUNDEMAIL: could not imap_mail_move() [ {$uids} ] to folder [ {$toFolder} ] from folder [ {$fromFolder} ]"");
            }
        } elseif ($toIe == 'folder' && $fromFolder == 'sugar::Emails') {
            $GLOBALS['log']->debug(""********* SUGARFOLDER - moveEmails() moving email from SugarFolder to SugarFolder"");
            // move from sugar folder to sugar folder
            require_once(""include/SugarFolders/SugarFolders.php"");
            $sugarFolder = new SugarFolder();
            $exUids = explode($app_strings['LBL_EMAIL_DELIMITER'], $uids);
            foreach ($exUids as $id) {
                if ($copy) {
                    $sugarFolder->copyBean($fromIe, $toFolder, $id, ""Emails"");
                } else {
                    $fromSugarFolder = new SugarFolder();
                    $fromSugarFolder->retrieve($fromIe);
                    $toSugarFolder = new SugarFolder();
                    $toSugarFolder->retrieve($toFolder);

                    $email = BeanFactory::newBean('Emails');
                    $email->retrieve($id);
                    $email->status = 'unread';

                    // when you move from My Emails to Group Folder, Assign To field for the Email should become null
                    if ($fromSugarFolder->is_dynamic && $toSugarFolder->is_group) {
                        // Bug 50972 - assigned_user_id set to empty string not true null
                        // Modifying the field defs in just this one place to allow
                        // a true null since this is what is expected when reading
                        // inbox folders
                        $email->setFieldNullable('assigned_user_id');
                        $email->assigned_user_id = """";
                        $email->save();
                        $email->revertFieldNullable('assigned_user_id');
                        // End fix 50972
                        if (!$toSugarFolder->checkEmailExistForFolder($id)) {
                            $fromSugarFolder->deleteEmailFromAllFolder($id);
                            $toSugarFolder->addBean($email);
                        }
                    } elseif ($fromSugarFolder->is_group && $toSugarFolder->is_dynamic) {
                        $fromSugarFolder->deleteEmailFromAllFolder($id);
                        $email->assigned_user_id = $current_user->id;
                        $email->save();
                    } else {
                        // If you are moving something from personal folder then delete an entry from all folder
                        if (!$fromSugarFolder->is_dynamic && !$fromSugarFolder->is_group) {
                            $fromSugarFolder->deleteEmailFromAllFolder($id);
                        } // if

                        if ($fromSugarFolder->is_dynamic && !$toSugarFolder->is_dynamic && !$toSugarFolder->is_group) {
                            $email->assigned_user_id = """";
                            $toSugarFolder->addBean($email);
                        } // if
                        if (!$toSugarFolder->checkEmailExistForFolder($id)) {
                            if (!$toSugarFolder->is_dynamic) {
                                $fromSugarFolder->deleteEmailFromAllFolder($id);
                                $toSugarFolder->addBean($email);
                            } else {
                                $fromSugarFolder->deleteEmailFromAllFolder($id);
                                $email->assigned_user_id = $current_user->id;
                            }
                        } else {
                            $sugarFolder->move($fromIe, $toFolder, $id);
                        } // else
                        $email->save();
                    } // else
                }
            }

            return true;
        } elseif ($toIe == 'folder') {
            $GLOBALS['log']->debug(""********* SUGARFOLDER - moveEmails() moving email from I-E to SugarFolder"");
            // move to Sugar folder
            require_once(""include/SugarFolders/SugarFolders.php"");
            $sugarFolder = new SugarFolder();
            $sugarFolder->retrieve($toFolder);
            //Show the import form if we don't have the required info
            if (!isset($_REQUEST['delete'])) {
                $json = getJSONobj();
                if ($sugarFolder->is_group) {
                    $_REQUEST['showTeam'] = false;
                    $_REQUEST['showAssignTo'] = false;
                }
                $ret = $this->email->et->getImportForm($_REQUEST, $this->email);
                $ret['move'] = true;
                $ret['srcFolder'] = $fromFolder;
                $ret['srcIeId'] = $fromIe;
                $ret['dstFolder'] = $toFolder;
                $ret['dstIeId'] = $toIe;
                $out = trim($json->encode($ret, false));
                echo $out;

                return true;
            }


            // import to Sugar
            $this->retrieve($fromIe);
            $this->mailbox = $fromFolder;
            $this->connectMailserver();
            // If its a group folder the team should be of the folder team
            if ($sugarFolder->is_group) {
                $_REQUEST['team_id'] = $sugarFolder->team_id;
                $_REQUEST['team_set_id'] = $sugarFolder->team_set_id;
            }
            // TODO - set team_id, team_set for new UI
            // else

            $exUids = explode($app_strings['LBL_EMAIL_DELIMITER'], $uids);

            if (!empty($sugarFolder->id)) {
                $count = 1;
                $return = array();
                $json = getJSONobj();
                foreach ($exUids as $k => $uid) {
                    $msgNo = $uid;
                    if ($this->isPop3Protocol()) {
                        $msgNo = $this->getCorrectMessageNoForPop3($uid);
                    } else {
                        $msgNo = $this->getImap()->getMessageNo($uid);
                    }

                    if (!empty($msgNo)) {
                        $importStatus = $this->returnImportedEmail($msgNo, $uid);
                        // add to folder
                        if ($importStatus) {
                            $sugarFolder->addBean($this);
                            if (!$copy && isset($_REQUEST['delete']) && ($_REQUEST['delete'] == ""true"") && $importStatus) {
                                $GLOBALS['log']->error(""********* delete from mailserver [ {explode("", "", $uids)} ]"");
                                // delete from mailserver
                                $this->deleteMessageOnMailServer($uid);
                                $this->deleteMessageFromCache($uid);
                            } // if
                        }
                        $return[] = $app_strings['LBL_EMAIL_MESSAGE_NO'] . "" "" . $count . "", "" . $app_strings['LBL_STATUS'] . "" "" . ($importStatus ? $app_strings['LBL_EMAIL_IMPORT_SUCCESS'] : $app_strings['LBL_EMAIL_IMPORT_FAIL']);
                        $count++;
                    } // if
                } // foreach
                echo $json->encode($return);

                return true;
            }
            $GLOBALS['log']->error(""********* SUGARFOLDER - failed to retrieve folder ID [ {$toFolder} ]"");
        } else {
            $GLOBALS['log']->debug(""********* SUGARFOLDER - moveEmails() called with no passing criteria"");
        }

        return false;
    }


    /**
     * Hard deletes an I-E account
     * @param string id GUID
     */
    public function hardDelete($id)
    {
        $q = ""DELETE FROM inbound_email WHERE id = '{$id}'"";
        $this->db->query($q, true);

        $q = ""DELETE FROM folders WHERE id = '{$id}'"";
        $this->db->query($q, true);

        $q = ""DELETE FROM folders WHERE parent_folder = '{$id}'"";
        $this->db->query($q, true);
    }

    /**
     * Generate a unique filename for attachments based on the message id.  There are no maximum
     * specifications for the length of the message id, the only requirement is that it be globally unique.
     *
     * @param bool $nameOnly Whether or not the attachment count should be appended to the filename.
     * @return string The temp file name
     */
    public function getTempFilename($nameOnly = false)
    {
        $str = $this->compoundMessageId;

        if (!$nameOnly) {
            $str = $str . $this->attachmentCount;
            $this->attachmentCount++;
        }

        return $str;
    }

    /**
     * deletes and expunges emails on server
     * @param string $uid UID(s), comma delimited, of email(s) on server
     * @return bool true on success
     */
    public function deleteMessageOnMailServer($uid)
    {
        global $app_strings;
        $this->connectMailserver();

        $uids = [];
        if (strpos($uid, (string) $app_strings['LBL_EMAIL_DELIMITER']) !== false) {
            $uids = explode($app_strings['LBL_EMAIL_DELIMITER'], $uid);
        } else {
            $uids[] = $uid;
        }

        $return = true;
        $msgnos = [];

        if ($this->protocol == 'imap') {
            $trashFolder = $this->get_stored_options(""trashFolder"");
            if (empty($trashFolder)) {
                $trashFolder = ""INBOX.Trash"";
            }
            $uidsToMove = implode('::;::', $uids);
            if ($this->moveEmails($this->id, $this->mailbox, $this->id, $trashFolder, $uidsToMove)) {
                $GLOBALS['log']->fatal(""INBOUNDEMAIL: MoveEmail to {$trashFolder} successful."");
            } else {
                $GLOBALS['log']->fatal(""INBOUNDEMAIL: MoveEmail to {$trashFolder} FAILED - trying hard delete for message: $uid"");
                $uidsToDelete = implode(',', $uids);
                $this->getImap()->delete($uidsToDelete, FT_UID);
                $return = true;
            }
        } else {
            foreach ($uids as $uid) {
                $msgnos[] = $this->getCorrectMessageNoForPop3($uid);
            }
            $msgnos = implode(',', $msgnos);
            $this->getImap()->delete($msgnos);
            $return = true;
        }

        if (!$this->getImap()->expunge()) {
            $GLOBALS['log']->debug(""NOOP: could not expunge deleted email."");
            $return = false;
        } else {
            LoggerManager::getLogger()->info(""INBOUNDEMAIL: hard-deleted mail with MSgno's' [ {$msgnos} ]"");
        }

        return $return;
    }

    /**
     * deletes and expunges emails on server
     * @param string $uid UID(s), comma delimited, of email(s) on server
     */
    public function deleteMessageOnMailServerForPop3($uid)
    {
        if (!$this->getImap()->isValidStream($this->conn)) {
            LoggerManager::getLogger()->fatal('Inbound Email connection is not a resource for deleting Message On Mail Server For Pop3');

            return false;
        }
        if ($this->getImap()->delete($uid)) {
            if (!$this->getImap()->expunge()) {
                $GLOBALS['log']->debug(""NOOP: could not expunge deleted email."");
                $return = false;
            } else {
                $GLOBALS['log']->info(""INBOUNDEMAIL: hard-deleted mail with MSgno's' [ {$uid} ]"");
            }
        }
    }

    /**
     * Checks if this is a pop3 type of an account or not
     * @return boolean
     */
    public function isPop3Protocol()
    {
        return ($this->protocol == 'pop3');
    }

    /**
     * Gets the UIDL from database for the corresponding msgno
     * @param int messageNo of a message
     * @return UIDL for the message
     */
    public function getUIDLForMessage($msgNo)
    {
        $query = ""SELECT message_id FROM email_cache WHERE ie_id = '{$this->id}' AND msgno = '{$msgNo}'"";
        $r = $this->db->query($query);
        $a = $this->db->fetchByAssoc($r);

        // Protect against the query failing.
        if ($a === false) {
            return null;
        } else {
            return $a['message_id'];
        }
    }

    /**
     * Get the users default IE account id
     *
     * @param User $user
     * @return string
     */
    public function getUsersDefaultOutboundServerId($user)
    {
        $id = $user->getPreference($this->keyForUsersDefaultIEAccount, 'Emails', $user);
        //If no preference has been set, grab the default system id.
        if (empty($id)) {
            $oe = new OutboundEmail();
            $system = $oe->getSystemMailerSettings();
            $id = empty($system->id) ? '' : $system->id;
        }

        return $id;
    }


    public function isOnlyPersonalInbound()
    {
        $inboundAccount = $this->getUserPersonalAccountCount();
        if ($inboundAccount == 1) {
            return true;
        }
        return false;
    }

    /**
     * @param $id
     * @return bool
     */
    public function isDefaultPersonalInbound($userId): bool
    {
        $user = BeanFactory::getBean('Users', $userId);
        $isDefault = $user->getPreference($this->keyForUsersDefaultIEAccount, 'Emails');
        if ($isDefault == $userId){
            return true;
        }
        return false;
    }

    /**
     * Get the users default IE account id
     *
     * @param User $user
     */
    public function setUsersDefaultOutboundServerId($user, $oe_id)
    {
        $user->setPreference($this->keyForUsersDefaultIEAccount, $oe_id, '', 'Emails');
    }

    /**
     * Gets the UIDL from database for the corresponding msgno
     * @param int messageNo of a message
     * @return UIDL for the message
     */
    public function getMsgnoForMessageID($messageid)
    {
        $query = ""SELECT msgno FROM email_cache WHERE ie_id = '{$this->id}' AND message_id = '{$messageid}'"";
        $r = $this->db->query($query);
        $a = $this->db->fetchByAssoc($r);

        if (!isset($a['message_id'])) {
            LoggerManager::getLogger()->warn('unable to get msgno for message id');

            return null;
        }

        return $a['message_id'];
    }

    /**
     * fills InboundEmail->email with an email's details
     * @param int uid Unique ID of email
     * @param bool isMsgNo flag that passed ID is msgNo, default false
     * @param bool setRead Sets the 'seen' flag in cache
     * @param bool forceRefresh Skips cache file
     * @return string
     */
    public function setEmailForDisplay($uid, $isMsgNo = false, $setRead = false, $forceRefresh = false)
    {

        if (empty($uid)) {
            $GLOBALS['log']->debug(""*** ERROR: INBOUNDEMAIL trying to setEmailForDisplay() with no UID"");

            return 'NOOP';
        }

        global $sugar_config;
        global $app_strings;

        $cacheFile = [];
        // if its a pop3 then get the UIDL and see if this file name exist or not
        if ($this->isPop3Protocol()) {
            // get the UIDL from database;
            $cachedUIDL = md5($uid);
            $cache = ""{$this->EmailCachePath}/{$this->id}/messages/{$this->mailbox}{$cachedUIDL}.php"";
        } else {
            $cache = ""{$this->EmailCachePath}/{$this->id}/messages/{$this->mailbox}{$uid}.php"";
        }

        if (isset($cache) && strpos($cache, "".."") !== false) {
            die(""Directory navigation attack denied."");
        }

        if (file_exists($cache) && !$forceRefresh) {
            $GLOBALS['log']->info(""INBOUNDEMAIL: Using cache file for setEmailForDisplay()"");

            include($cache); // profides $cacheFile
            /** @var $cacheFile array */

            $metaOut = unserialize($cacheFile['out']);
            $meta = $metaOut['meta']['email'];
            $email = BeanFactory::newBean('Emails');

            foreach ($meta as $k => $v) {
                $email->$k = $v;
            }

            $email->to_addrs = $meta['toaddrs'];
            $email->date_sent_received = $meta['date_start'];

            $this->email = $email;
            $this->email->email2init();
            $ret = 'cache';
        } else {
            $GLOBALS['log']->info(""INBOUNDEMAIL: opening new connection for setEmailForDisplay()"");
            if ($this->isPop3Protocol()) {
                $msgNo = $this->getCorrectMessageNoForPop3($uid);
            } else {
                if (empty($this->conn)) {
                    $this->connectMailserver();
                }
                $msgNo = ($isMsgNo) ? $uid : $this->getImap()->getMessageNo($uid);
            }
            if (empty($this->conn)) {
                $status = $this->connectMailserver();
                if ($status == ""false"") {
                    $this->email = BeanFactory::newBean('Emails');
                    $this->email->name = $app_strings['LBL_EMAIL_ERROR_MAILSERVERCONNECTION'];
                    $ret = 'error';

                    return $ret;
                }
            }

            $this->returnImportedEmail($msgNo, $uid, true);
            $this->email->id = '';
            $this->email->new_with_id = false;
            $ret = 'import';
        }

        if ($setRead) {
            $this->setStatuses($uid, 'seen', 1);
        }

        return $ret;
    }


    /**
     * Sets status for a particular attribute on the mailserver and the local cache file
     */
    public function setStatuses($uid, $field, $value)
    {
        global $sugar_config;
        /** available status fields
         * [subject] => aaa
         * [from] => Some Name
         * [to] => Some Name
         * [date] => Mon, 22 Jan 2007 17:32:57 -0800
         * [message_id] =>
         * [size] => 718
         * [uid] => 191
         * [msgno] => 141
         * [recent] => 0
         * [flagged] => 0
         * [answered] => 0
         * [deleted] => 0
         * [seen] => 1
         * [draft] => 0
         */
        // local cache
        $file = ""{$this->mailbox}.imapFetchOverview.php"";
        $overviews = $this->getCacheValueForUIDs($this->mailbox, array($uid));

        if (!empty($overviews)) {
            $updates = array();

            foreach ($overviews['retArr'] as $k => $obj) {
                if ($obj->imap_uid == $uid) {
                    $obj->$field = $value;
                    $updates[] = $obj;
                }
            }

            if (!empty($updates)) {
                $this->setCacheValue($this->mailbox, array(), $updates);
            }
        }
    }

    /**
     * Removes an email from the cache file, deletes the message from the cache too
     * @param string String of uids, comma delimited
     */
    public function deleteMessageFromCache($uids)
    {
        global $app_strings;

        // delete message cache file and email_cache file
        $exUids = explode($app_strings['LBL_EMAIL_DELIMITER'], $uids);

        foreach ($exUids as $uid) {
            // local cache
            $queryUID = $this->db->quote($uid);
            if ($this->isPop3Protocol()) {
                $q = ""DELETE FROM email_cache WHERE message_id = '{$queryUID}' AND ie_id = '{$this->id}'"";
            } else {
                $q = ""DELETE FROM email_cache WHERE imap_uid = '{$queryUID}' AND ie_id = '{$this->id}'"";
            }
            $r = $this->db->query($q);
            if ($this->isPop3Protocol()) {
                $uid = md5($uid);
            } // if
            $msgCacheFile = ""{$this->EmailCachePath}/{$this->id}/messages/{$this->mailbox}{$uid}.php"";
            if (file_exists($msgCacheFile)) {
                if (!unlink($msgCacheFile)) {
                    $GLOBALS['log']->error(""***ERROR: InboundEmail could not delete the cache file [ {$msgCacheFile} ]"");
                }
            }
        }
    }


    /**
     * Shows one email.
     * @param int uid UID of email to display
     * @param string mbox Mailbox to look in for the message
     * @param bool isMsgNo Flag to assume $uid is a MessageNo, not UniqueID, default false
     */
    public function displayOneEmail($uid, $mbox, $isMsgNo = false)
    {
        require_once(""include/JSON.php"");

        global $timedate;
        global $app_strings;
        global $app_list_strings;
        global $sugar_smarty;
        global $theme;
        global $current_user;
        global $sugar_config;

        $fetchedAttributes = array(
            'name',
            'from_name',
            'from_addr',
            'date_start',
            'time_start',
            'message_id',
        );

        $souEmail = array();
        foreach ($fetchedAttributes as $k) {
            if ($k == 'date_start') {
                $this->email->$k . "" "" . $this->email->time_start;
                $souEmail[$k] = $this->email->$k . "" "" . $this->email->time_start;
            } elseif ($k == 'time_start') {
                $souEmail[$k] = """";
            } else {
                $souEmail[$k] = trim($this->email->$k);
            }
        }

        // if a MsgNo is passed in, convert to UID
        if ($isMsgNo) {
            $uid = $this->getImap()->getUid($uid);
        }

        // meta object to allow quick retrieval for replies
        $meta = array();
        $meta['type'] = $this->email->type;
        $meta['uid'] = $uid;
        $meta['ieId'] = $this->id;
        $meta['email'] = $souEmail;
        $meta['mbox'] = $this->mailbox;
        $ccs = '';
        // imap vs pop3

        // self mapping
        $exMbox = explode(""::"", $mbox);

        // CC section
        $cc = '';
        if (!empty($this->email->cc_addrs)) {
            //$ccs = $this->collapseLongMailingList($this->email->cc_addrs);
            $ccs = to_html($this->email->cc_addrs_names);
            $cc = <<<eoq
                <tr>
                    <td NOWRAP valign=""top"" class=""displayEmailLabel"">
                        {$app_strings['LBL_EMAIL_CC']}:
                    </td>
                    <td class=""displayEmailValue"">
                        {$ccs}
                    </td>
                </tr>
eoq;
        }
        $meta['cc'] = $cc;
        $meta['email']['cc_addrs'] = $ccs;
        // attachments
        $attachments = '';
        if ($mbox == ""sugar::Emails"") {
            $q = ""SELECT id, filename, file_mime_type FROM notes WHERE parent_id = '{$uid}' AND deleted = 0"";
            $r = $this->db->query($q);
            $i = 0;
            while ($a = $this->db->fetchByAssoc($r)) {
                $url = ""index.php?entryPoint=download&type=notes&id={$a['id']}"";
                $lbl = ($i == 0) ? $app_strings['LBL_EMAIL_ATTACHMENTS'] . "":"" : '';
                $i++;
                $attachments .= <<<EOQ
                <tr>
                            <td NOWRAP valign=""top"" class=""displayEmailLabel"">
                                {$lbl}
                            </td>
                            <td NOWRAP valign=""top"" colspan=""2"" class=""displayEmailValue"">
                                <a href=""{$url}"">{$a['filename']}</a>
                            </td>
                        </tr>
EOQ;
                $this->email->cid2Link($a['id'], $a['file_mime_type']);
            } // while
        } else {
            if ($this->attachmentCount > 0) {
                $theCount = $this->attachmentCount;

                for ($i = 0; $i < $theCount; $i++) {
                    $lbl = ($i == 0) ? $app_strings['LBL_EMAIL_ATTACHMENTS'] . "":"" : '';
                    $name = $this->getTempFilename(true) . $i;
                    $tempName = urlencode($this->tempAttachment[$name]);

                    $url = ""index.php?entryPoint=download&type=temp&isTempFile=true&ieId={$this->id}&tempName={$tempName}&id={$name}"";

                    $attachments .= <<<eoq
                        <tr>
                            <td NOWRAP valign=""top"" class=""displayEmailLabel"">
                                {$lbl}
                            </td>
                            <td NOWRAP valign=""top"" colspan=""2"" class=""displayEmailValue"">
                                <a href=""{$url}"">{$this->tempAttachment[$name]}</a>
                            </td>
                        </tr>
eoq;
                } // for
            } // if
        } // else
        $meta['email']['attachments'] = $attachments;

        // toasddrs
        $meta['email']['toaddrs'] = $this->collapseLongMailingList($this->email->to_addrs);
        $meta['email']['cc_addrs'] = $ccs;

        // body
        $description = (empty($this->email->description_html)) ? nl2br($this->email->description) : $this->email->description_html;
        $meta['email']['description'] = $description;

        // meta-metadata
        $meta['is_sugarEmail'] = ($exMbox[0] == 'sugar') ? true : false;

        if (!$meta['is_sugarEmail']) {
            if ($this->isAutoImport) {
                $meta['is_sugarEmail'] = true;
            }
        } else {
            if ($this->email->status != 'sent') {
                // mark SugarEmail read
                $q = ""UPDATE emails SET status = 'read' WHERE id = '{$uid}'"";
                $r = $this->db->query($q);
            }
        }

        $return = array();
        $meta['email']['name'] = to_html($this->email->name);
        $meta['email']['from_addr'] = (!empty($this->email->from_addr_name)) ? to_html($this->email->from_addr_name) : to_html($this->email->from_addr);
        isValidEmailAddress($meta['email']['from_addr']);
        $meta['email']['toaddrs'] = (!empty($this->email->to_addrs_names)) ? to_html($this->email->to_addrs_names) : to_html($this->email->to_addrs);
        $meta['email']['cc_addrs'] = to_html($this->email->cc_addrs_names);
        $meta['email']['reply_to_addr'] = to_html($this->email->reply_to_addr);
        $return['meta'] = $meta;

        return $return;
    }

    /**
     * Takes a long list of email addresses from a To or CC field and shows the first 3, the rest hidden
     * @param string emails
     * @return string
     */
    public function collapseLongMailingList($emails)
    {
        global $app_strings;

        $ex = explode("","", $emails);
        $i = 0;
        $j = 0;

        if (count($ex) > 3) {
            $emails = """";
            $emailsHidden = """";

            foreach ($ex as $email) {
                if ($i < 2) {
                    if (!empty($emails)) {
                        $emails .= "", "";
                    }
                    $emails .= trim($email);
                } else {
                    if (!empty($emailsHidden)) {
                        $emailsHidden .= "", "";
                    }
                    $emailsHidden .= trim($email);
                    $j++;
                }
                $i++;
            }

            if (!empty($emailsHidden)) {
                $email2 = $emails;
                $emails = ""<span onclick='javascript:SUGAR.email2.detailView.showFullEmailList(this);' style='cursor:pointer;'>{$emails} [...{$j} {$app_strings['LBL_MORE']}]</span>"";
                $emailsHidden = ""<span onclick='javascript:SUGAR.email2.detailView.showCroppedEmailList(this)' style='cursor:pointer; display:none;'>{$email2}, {$emailsHidden} [ {$app_strings['LBL_LESS']} ]</span>"";
            }

            $emails .= $emailsHidden;
        }

        return $emails;
    }


    /**
     * Sorts IMAP's imap_fetch_overview() results
     * @param array $arr Array of standard objects
     * @param string $sort Column to sort by
     * @param string direction Direction to sort by (asc/desc)
     * @return array Sorted array of obj.
     */
    public function sortFetchedOverview($arr, $sort = 4, $direction = 'DESC', $forceSeen = false)
    {
        global $current_user;

        $currentNode = [];

        $sortPrefs = $current_user->getPreference('folderSortOrder', 'Emails');
        if (!empty($sortPrefs)) {
            $listPrefs = $sortPrefs;
        } else {
            $listPrefs = array();
        }

        if (isset($listPrefs[$this->id][$this->mailbox])) {
            $currentNode = $listPrefs[$this->id][$this->mailbox];
        }

        if (isset($currentNode['current']) && !empty($currentNode['current'])) {
            $sort = $currentNode['current']['sort'];
            $direction = $currentNode['current']['direction'];
        }

        // sort defaults
        if (empty($sort)) {
            $sort = $this->defaultSort;//4;
            $direction = $this->defaultDirection; //'DESC';
        } elseif (!is_numeric($sort)) {
            // handle bad sort index
            $sort = $this->defaultSort;
        } else {
            // translate numeric index to human readable
            $sort = $this->hrSort[$sort];
        }
        if (empty($direction)) {
            $direction = 'DESC';
        }


        $retArr = array();
        $sorts = array();

        foreach ($arr as $k => $overview) {
            $sorts['flagged'][$k] = $overview->flagged;
            $sorts['status'][$k] = $overview->answered;
            $sorts['from'][$k] = str_replace('""', """", $this->handleMimeHeaderDecode($overview->from));
            $sorts['subj'][$k] = $this->handleMimeHeaderDecode(quoted_printable_decode($overview->subject));
            $sorts['date'][$k] = $overview->date;
        }

        // sort by column
        natcasesort($sorts[$sort]);

        // direction
        if (strtolower($direction) == 'desc') {
            $revSorts = array();
            $keys = array_reverse(array_keys($sorts[$sort]));
            $keysCount = count($keys);

            for ($i = 0; $i < $keysCount; $i++) {
                $v = $keys[$i];
                $revSorts[$v] = $sorts[$sort][$v];
            }

            $sorts[$sort] = $revSorts;
        }
        $timedate = TimeDate::getInstance();
        foreach ($sorts[$sort] as $k2 => $overview2) {
            $arr[$k2]->date = $timedate->fromString($arr[$k2]->date)->asDb();
            $retArr[] = $arr[$k2];
        }

        $finalReturn = array();
        $finalReturn['retArr'] = $retArr;
        $finalReturn['sortBy'] = $sort;
        $finalReturn['direction'] = $direction;

        return $finalReturn;
    }


    public function setReadFlagOnFolderCache($mbox, $uid)
    {
        global $sugar_config;

        $this->mailbox = $mbox;

        // cache
        if ($this->validCacheExists($this->mailbox)) {
            $ret = $this->getCacheValue($this->mailbox);

            $updates = array();

            foreach ($ret as $k => $v) {
                if ($v->imap_uid == $uid) {
                    $v->seen = 1;
                    $updates[] = $v;
                    break;
                }
            }

            $this->setCacheValue($this->mailbox, array(), $updates);
        }
    }

    /**
     * Returns a list of emails in a mailbox.
     * @param string mbox Name of mailbox using dot notation paths to display
     * @param string $forceRefresh Flag to use cache or not
     * @param integer page number
     */
    public function displayFolderContents($mbox, $forceRefresh = 'false', $page = 1)
    {
        global $current_user;

        $delimiter = $this->get_stored_options('folderDelimiter');
        if ($delimiter) {
            $mbox = str_replace('.', $delimiter, (string) $mbox);
        }

        $this->mailbox = $mbox;

        // jchi #9424, get sort and direction from user preference
        $sort = 'date';
        $direction = 'desc';
        $sortSerial = $current_user->getPreference('folderSortOrder', 'Emails');
        if (!empty($sortSerial) && !empty($_REQUEST['ieId']) && !empty($_REQUEST['mbox'])) {
            $sortArray = sugar_unserialize($sortSerial);
            $sort = $sortArray[$_REQUEST['ieId']][$_REQUEST['mbox']]['current']['sort'];
            $direction = $sortArray[$_REQUEST['ieId']][$_REQUEST['mbox']]['current']['direction'];
        }
        //end

        // save sort order
        if (!empty($_REQUEST['sort']) && !empty($_REQUEST['dir'])) {
            $this->email->et->saveListViewSortOrder(
                $_REQUEST['ieId'],
                $_REQUEST['mbox'],
                $_REQUEST['sort'],
                $_REQUEST['dir']
            );
            $sort = $_REQUEST['sort'];
            $direction = $_REQUEST['dir'];
        } else {
            $_REQUEST['sort'] = '';
            $_REQUEST['dir'] = '';
        }

        // cache
        $ret = array();
        $cacheUsed = false;
        if ($forceRefresh == 'false' && $this->validCacheExists($this->mailbox)) {
            $emailSettings = $current_user->getPreference('emailSettings', 'Emails');

            // cn: default to a low number until user specifies otherwise
            if (empty($emailSettings['showNumInList'])) {
                $emailSettings['showNumInList'] = 20;
            }

            $ret = $this->getCacheValue($this->mailbox, $emailSettings['showNumInList'], $page, $sort, $direction);
            $cacheUsed = true;
        }

        $out = $this->displayFetchedSortedListXML($ret, $mbox);

        $metadata = array();
        $metadata['mbox'] = $mbox;
        $metadata['ieId'] = $this->id;
        $metadata['name'] = $this->name;
        $metadata['fromCache'] = $cacheUsed ? 1 : 0;
        $metadata['out'] = $out;

        return $metadata;
    }

    /**
     * For a group email account, create subscriptions for all users associated with the
     * team assigned to the account.
     *
     */
    public function createUserSubscriptionsForGroupAccount()
    {
        $team = new Team();
        $team->retrieve($this->team_id);
        $usersList = $team->get_team_members(true);
        foreach ($usersList as $userObject) {
            $previousSubscriptions = sugar_unserialize(
                base64_decode(
                    $userObject->getPreference(
                        'showFolders',
                        'Emails',
                        $userObject
                    )
                )
            );
            if ($previousSubscriptions === false) {
                $previousSubscriptions = array();
            }

            $previousSubscriptions[] = $this->id;

            $encodedSubs = base64_encode(serialize($previousSubscriptions));
            $userObject->setPreference('showFolders', $encodedSubs, '', 'Emails');
            $userObject->savePreferencesToDB();
        }
    }

    /**
     * Create a sugar folder for this inbound email account
     * if the Enable Auto Import option is selected
     *
     * @return String Id of the sugar folder created.
     */
    public function createAutoImportSugarFolder()
    {
        global $current_user;
        $guid = create_guid();
        $GLOBALS['log']->debug(""Creating Sugar Folder for IE with id $guid"");
        $folder = new SugarFolder();
        $folder->id = $guid;
        $folder->new_with_id = true;
        $folder->name = $this->name;
        $folder->has_child = 0;
        $folder->is_group = 1;
        $folder->assign_to_id = $current_user->id;
        $folder->parent_folder = """";


        //If this inbound email is marked as inactive, don't add subscriptions.
        $addSubscriptions = ($this->status == 'Inactive' || $this->mailbox_type == 'bounce') ? false : true;
        $folder->save($addSubscriptions);

        return $guid;
    }

    public function validCacheExists($mbox)
    {
        $q = ""SELECT count(*) c FROM email_cache WHERE ie_id = '{$this->id}'"";
        $r = $this->db->query($q);
        $a = $this->db->fetchByAssoc($r);
        $count = $a['c'];

        if ($count > 0) {
            return true;
        }

        return false;
    }


    public function displayFetchedSortedListXML($ret, $mbox)
    {
        global $timedate;
        global $current_user;
        global $sugar_config;

        if (empty($ret['retArr'])) {
            return array();
        }

        $tPref = $current_user->getUserDateTimePreferences();

        $return = array();

        foreach ($ret['retArr'] as $msg) {
            $flagged = ($msg->flagged == 0) ? """" : $this->iconFlagged;
            $status = ($msg->deleted) ? $this->iconDeleted : """";
            $status = ($msg->draft == 0) ? $status : $this->iconDraft;
            $status = ($msg->answered == 0) ? $status : $this->iconAnswered;
            $from = $this->handleMimeHeaderDecode($msg->from);
            $subject = $this->handleMimeHeaderDecode($msg->subject);
            //$date		= date($tPref['date']."" "".$tPref['time'], $msg->date);
            $date = $timedate->to_display_date_time($this->db->fromConvert($msg->date, 'datetime'));
            //$date		= date($tPref['date'], $this->getUnixHeaderDate($msg->date));

            $temp = array();
            $temp['flagged'] = $flagged;
            $temp['status'] = $status;
            $temp['from'] = to_html($from);
            $temp['subject'] = $subject;
            $temp['date'] = $date;
            $temp['uid'] = $msg->uid; // either from an imap_search() or massaged cache value
            $temp['mbox'] = $this->mailbox;
            $temp['ieId'] = $this->id;
            $temp['site_url'] = $sugar_config['site_url'];
            $temp['seen'] = $msg->seen;
            $temp['type'] = (isset($msg->type)) ? $msg->type : 'remote';
            $temp['to_addrs'] = to_html($msg->to);
            $temp['hasAttach'] = '0';

            $return[] = $temp;
        }

        return $return;
    }


    /**
     * retrieves the mailboxes for a given account in the following format
     * Array(
     * [INBOX] => Array
     * (
     * [Bugs] => Bugs
     * [Builder] => Builder
     * [DEBUG] => Array
     * (
     * [out] => out
     * [test] => test
     * )
     * )
     * @param bool $justRaw Default false
     * @return array
     */
    public function getMailboxes($justRaw = false)
    {
        if ($justRaw == true) {
            return $this->mailboxarray;
        } // if

        return $this->generateMultiDimArrayFromFlatArray($this->mailboxarray, $this->retrieveDelimiter());
    }

    public function getMailBoxesForGroupAccount()
    {
        $mailboxes = $this->generateMultiDimArrayFromFlatArray(
            explode("","", $this->mailbox),
            $this->retrieveDelimiter()
        );
        $mailboxesArray = $this->generateFlatArrayFromMultiDimArray($mailboxes, $this->retrieveDelimiter());
        $mailboxesArray = $this->filterMailBoxFromRaw(explode("","", $this->mailbox), $mailboxesArray);
        $this->saveMailBoxFolders($mailboxesArray);

        return $mailboxes;
    } // fn

    public function saveMailBoxFolders($value)
    {
        if (is_array($value)) {
            $value = implode("","", $value);
        }
        $this->mailboxarray = explode("","", $value);
        $value = $this->db->quoted($value);
        $query = ""update inbound_email set mailbox = $value where id ='{$this->id}'"";
        $this->db->query($query);
    }

    public function insertMailBoxFolders($value)
    {
        $query = ""select value from config where category='InboundEmail' and name='{$this->id}'"";
        $r = $this->db->query($query);
        $a = $this->db->fetchByAssoc($r);
        if (empty($a['value'])) {
            if (is_array($value)) {
                $value = implode("","", $value);
            }
            $this->mailboxarray = explode("","", $value);
            $value = $this->db->quoted($value);

            $query = ""INSERT INTO config VALUES('InboundEmail', '{$this->id}', $value)"";
            $this->db->query($query);
        } // if
    }

    public function saveMailBoxValueOfInboundEmail()
    {
        $emailUserQuoted = $this->db->quote($this->email_user);
        $query = ""update Inbound_email set mailbox = '$emailUserQuoted'"";
        $this->db->query($query);
    }

    public function retrieveMailBoxFolders()
    {
        $this->mailboxarray = explode("","", $this->mailbox);
    } // fn


    public function retrieveDelimiter()
    {
        $delimiter = $this->get_stored_options('folderDelimiter');
        if (!$delimiter) {
            $delimiter = '.';
        }

        return $delimiter;
    } // fn

    public function generateFlatArrayFromMultiDimArray($arraymbox, $delimiter)
    {
        $ret = array();
        foreach ($arraymbox as $key => $value) {
            $this->generateArrayData($key, $value, $ret, $delimiter);
        } // foreach

        return $ret;
    } // fn

    public function generateMultiDimArrayFromFlatArray($raw, $delimiter)
    {
        // generate a multi-dimensional array to iterate through
        $ret = array();
        foreach ($raw as $mbox) {
            $ret = $this->sortMailboxes($mbox, $ret, $delimiter);
        }

        return $ret;
    } // fn

    public function generateArrayData($key, $arraymbox, &$ret, $delimiter)
    {
        $ret [] = $key;
        if (is_array($arraymbox)) {
            foreach ($arraymbox as $mboxKey => $value) {
                $newKey = $key . $delimiter . $mboxKey;
                $this->generateArrayData($newKey, $value, $ret, $delimiter);
            } // foreach
        } // if
    }

    /**
     * sorts the folders in a mailbox in a multi-dimensional array
     * @param string $MBOX
     * @param array $ret
     * @return array
     */
    public function sortMailboxes($mbox, $ret, $delimeter = ""."")
    {
        if (strpos((string) $mbox, (string) $delimeter)) {
            $node = substr((string) $mbox, 0, strpos((string) $mbox, (string) $delimeter));
            $nodeAfter = substr((string) $mbox, strpos((string) $mbox, (string) $node) + strlen($node) + 1, strlen((string) $mbox));

            if (!isset($ret[$node])) {
                $ret[$node] = array();
            } elseif (isset($ret[$node]) && !is_array($ret[$node])) {
                $ret[$node] = array();
            }
            $ret[$node] = $this->sortMailboxes($nodeAfter, $ret[$node], $delimeter);
        } else {
            $ret[$mbox] = $mbox;
        }

        return $ret;
    }

    /**
     * parses Sugar's storage method for imap server service strings
     * @return string
     */
    public function getServiceString()
    {
        $service = '';
        $exServ = explode('::', $this->service);

        foreach ($exServ as $v) {
            if (!empty($v) && ($v != 'imap' && $v != 'pop3')) {
                $service .= '/' . $v;
            }
        }

        return $service;
    }


    /**
     * Get Email messages IDs from server which aren't in database
     * @return array Ids of messages, which aren't still in database
     */
    public function getNewEmailsForSyncedMailbox()
    {
        // ids's count limit for batch processing
        $limit = 20;

        if (!$this->getImap()->isValidStream($this->conn)) {
            LoggerManager::getLogger()->fatal('Inbound Email connection is not a resource for getting New Emails For Synced Mailbox');

            return false;
        }

        $msgIds = $this->getImap()->search('ALL UNDELETED');
        $result = array();
        try {
            if ((is_countable($msgIds) ? count($msgIds) : 0) > 0) {
                /*
                 * @var collect results of queries and message headers
                 */
                $tmpMsgs = array();
                $repeats = 0;
                $counter = 0;

                // sort IDs to get lastest on top
                arsort($msgIds);
                $GLOBALS['log']->debug('-----> getNewEmailsForSyncedMailbox() got ' . (is_countable($msgIds) ? count($msgIds) : 0) . ' Messages');
                foreach ($msgIds as $k => &$msgNo) {
                    $uid = $this->getImap()->getUid($msgNo);
                    $header = $this->getImap()->headerInfo($msgNo);
                    $fullHeader = $this->getImap()->fetchHeader($msgNo);
                    $message_id = isset($header->message_id) ? $header->message_id : '';
                    $deliveredTo = $this->id;
                    $matches = array();
                    preg_match('/(delivered-to:|x-real-to:){1}\s*(\S+)\s*\n{1}/im', (string) $fullHeader, $matches);
                    if (count($matches)) {
                        $deliveredTo = $matches[2];
                    }
                    if (empty($message_id) || !isset($message_id)) {
                        $GLOBALS['log']->debug('*********** NO MESSAGE_ID.');
                        $message_id = $this->getMessageId($header);
                    }

                    // generate compound messageId
                    $this->compoundMessageId = trim($message_id) . trim($deliveredTo);
                    // if the length > 255 then md5 it so that the data will be of smaller length
                    if (strlen($this->compoundMessageId) > 255) {
                        $this->compoundMessageId = md5($this->compoundMessageId);
                    } // if

                    if (empty($this->compoundMessageId)) {
                        break;
                    } // if
                    $counter++;
                    $potentials = clean_xss($this->compoundMessageId, false);

                    if (is_array($potentials) && !empty($potentials)) {
                        foreach ($potentials as $bad) {
                            $this->compoundMessageId = str_replace($bad, """", $this->compoundMessageId);
                        }
                    }
                    array_push($tmpMsgs, array('msgNo' => $msgNo, 'msgId' => $this->compoundMessageId, 'exists' => 0));
                    if ($counter == $limit) {
                        $counter = 0;
                        $query = array();
                        foreach (array_slice($tmpMsgs, -$limit, $limit) as $k1 => $v1) {
                            $query[] = $v1['msgId'];
                        }
                        $query = 'SELECT count(emails.message_id) as cnt, emails.message_id AS mid FROM emails WHERE emails.message_id IN (""' . implode(
                                '"",""',
                                $query
                            ) . '"") and emails.deleted = 0 group by emails.message_id';
                        $r = $this->db->query($query);
                        $tmp = array();
                        while ($a = $this->db->fetchByAssoc($r)) {
                            $tmp[html_entity_decode((string) $a['mid'])] = $a['cnt'];
                        }
                        foreach ($tmpMsgs as $k1 => $v1) {
                            if (isset($tmp[$v1['msgId']]) && $tmp[$v1['msgId']] > 0) {
                                $tmpMsgs[$k1]['exists'] = 1;
                            }
                        }
                        foreach ($tmpMsgs as $k1 => $v1) {
                            if ($v1['exists'] == 0) {
                                $repeats = 0;
                                array_push($result, $v1['msgNo']);
                            } else {
                                $repeats++;
                            }
                        }
                        if ($repeats > 0) {
                            if ($repeats >= $limit) {
                                break;
                            }
                            $tmpMsgs = array_splice($tmpMsgs, -$repeats, $repeats);
                        } else {
                            $tmpMsgs = array();
                        }
                    }
                }
                unset($msgNo);
            }
        } catch (Exception $ex) {
            $GLOBALS['log']->fatal($ex->getMessage());
        }
        $GLOBALS['log']->debug('-----> getNewEmailsForSyncedMailbox() got ' . count($result) . ' unsynced messages');

        return $result;
    }

    /**
     * Import new messages from given account.
     */
    public function importMessages()
    {
        $protocol = $this->isPop3Protocol() ? 'pop3' : 'imap';
        switch ($protocol) {
            case 'pop3':
                $this->importMailboxMessages($protocol);
                break;
            case 'imap':
                $mailboxes = $this->getMailboxes(true);
                foreach ($mailboxes as $mailbox) {
                    $this->importMailboxMessages($protocol, $mailbox);
                }
                $this->getImap()->expunge();
                $this->getImap()->close();
                break;
        }
    }

    /**
     * Import messages from specified mailbox
     *
     * @param string $protocol Mailing protocol
     * @param string|null $mailbox Mailbox (if applied to protocol)
     */
    protected function importMailboxMessages($protocol, $mailbox = null)
    {
        switch ($protocol) {
            case 'pop3':
                $msgNumbers = $this->getPop3NewMessagesToDownload();
                break;
            case 'imap':
                $this->mailbox = $mailbox;
                $this->connectMailserver();
                $msgNumbers = $this->getNewMessageIds();
                if (!$msgNumbers) {
                    $msgNumbers = array();
                }
                break;
            default:
                $msgNumbers = array();
                break;
        }

        foreach ($msgNumbers as $msgNumber) {
            $uid = $this->getMessageUID($msgNumber, $protocol);
            $GLOBALS['log']->info('Importing message no: ' . $msgNumber);
            $this->returnImportedEmail($msgNumber, $uid, false, false);
        }
    }

    /**
     * Retrieves message UID by it's number
     *
     * @param int $msgNumber Number of the message in current sequence
     * @param string $protocol Mailing protocol
     * @return string
     */
    protected function getMessageUID($msgNumber, $protocol)
    {
        switch ($protocol) {
            case 'pop3':
                $uid = $this->getUIDLForMessage($msgNumber);
                break;
            case 'imap':
                $uid = $this->getImap()->getUid($msgNumber);
                break;
            default:
                $uid = null;
                break;
        }

        return $uid;
    }

    public function bean_implements($interface)
    {
        if ($interface === 'ACL') {
            return true;
        }

        return false;
    }

    /**
     * Check if its admin only action
     * @param string $view
     * @return bool
     */
    protected function isAdminOnlyAction(string $view): bool
    {
        $adminOnlyAction = ['edit', 'delete', 'editview', 'save'];
        return in_array(strtolower($view), $adminOnlyAction);
    }

    /**
     * Check if its a security based action
     * @param string $view
     * @return bool
     */
    protected function isSecurityGroupBasedAction(string $view): bool
    {
        $securityBasedActions = ['detail', 'detailview', 'view'];
        return in_array(strtolower($view), $securityBasedActions);
    }

    /**
     * Get not allowed action
     * @param string $view
     * @return bool
     */
    protected function isNotAllowedAction(string $view): bool
    {
        $notAllowed = ['export', 'import', 'massupdate', 'duplicate'];
        return in_array(strtolower($view), $notAllowed);
    }


    /**
     * @param array $order
     * @return array
     */
    protected function getSortCriteria(array $order): array
    {
        // handle sorting
        // Default: to sort the date in descending order
        $sortCriteria = SORTARRIVAL;
        $sortCRM = 'udate';
        $sortOrder = 1;

        return [$sortCriteria, $sortCRM, $sortOrder];
    }

    /**
     * @param array $filter
     * @return string|null
     */
    protected function getFilterCriteria(array $filter): ?string
    {
        // handle filtering
        $filterCriteria = null;
        $emailFilteringOption = 'multi';

        if ($this->email_body_filtering) {
            $emailFilteringOption = $this->email_body_filtering;
        }

        if (!empty($filter)) {
            foreach ($filter as $filterField => $filterFieldValue) {

                if (empty($filterFieldValue)) {
                    continue;
                }

                // Convert to a blank string as NULL will break the IMAP request
                if ($filterCriteria == null) {
                    $filterCriteria = '';
                }

                if ($filterField === 'BODY' && $emailFilteringOption !== 'multi') {
                    $word = strtok($filterFieldValue, ' ') ?? '';
                    if (!empty($word)){
                        $filterCriteria .= ' ' . $filterField . ' ""' . $word . '"" ';
                    }
                } else {
                    $filterCriteria .= ' ' . $filterField . ' ""' . $filterFieldValue . '"" ';
                }
            }
        }

        return $filterCriteria;
    }

    /**
     * @param array $returnService
     * @param array $serviceArr
     * @param $tmpMailbox
     * @return void
     */
    protected function overrideConnectionConfigs(array &$returnService, array &$serviceArr, $tmpMailbox): void
    {
        $connectionString = str_replace('//', '', $this->connection_string ?? '');

        $parts = explode('/', $connectionString) ?? [];
        array_shift($parts);
        $servicesString = implode('/', $parts);
        $serviceKey = implode('-', $parts);

        $returnService[$serviceKey] = 'foo' . $servicesString;
        $serviceArr[$serviceKey] = '{' . $this->connection_string . '}' . $tmpMailbox;
    }

    /**
     * @param $emailHeaders
     * @param $sortCRM
     * @param $sortOrder
     * @return mixed
     */
    protected function sortMessageList($emailHeaders, $sortCRM, $sortOrder)
    {
        // TODO: parameter 1 could be a bool but it should be an array!
        usort(
            $emailHeaders,
            function ($a, $b) use ($sortCRM) {  // defaults to DESC order
                if ($a[$sortCRM] === $b[$sortCRM]) {
                    return 0;
                } elseif ($a[$sortCRM] < $b[$sortCRM]) {
                    return 1;
                }

                return -1;
            }
        );

        // Make it ASC order
        if (!$sortOrder) {
            array_reverse($emailHeaders);
        };

        return $emailHeaders;
    }

    /**
     * @param $password
     * @param int $imapConnectionOptions
     * @return array
     */
    protected function getOAuthCredentials($password, int $imapConnectionOptions): array
    {
        if ($this->isOAuth()) {
            /** @var ExternalOAuthConnection $oAuthConnection */
            $oAuthConnection = BeanFactory::getBean('ExternalOAuthConnection', $this->external_oauth_connection_id);
            $password = $oAuthConnection->access_token;
            $imapConnectionOptions = OP_XOAUTH2;
        }

        return [$password, $imapConnectionOptions];
    }

    /**
     * Get Imap handler type
     * @return string
     */
    protected function getImapHandlerType(): string
    {
        return 'imap2';
    }

    /**
     * Get refersh token error messages
     * @param $reLogin
     * @param ExternalOAuthConnection $oauthConnection
     * @param string $oAuthConnectionId
     * @return string
     */
    protected function getOAuthRefreshTokenErrorMessage(
        $reLogin,
        ExternalOAuthConnection $oauthConnection,
        string $oAuthConnectionId
    ): string {
        $message = translate('ERR_IMAP_OAUTH_CONNECTION_ERROR', 'InboundEmail');
        $linkAction = 'DetailView';

        if ($reLogin === true) {
            $linkAction = 'EditView';
            $message = translate('WARN_OAUTH_TOKEN_SESSION_EXPIRED', 'InboundEmail');
        }

        $oauthConnectionName = $oauthConnection->name;

        $hasAccess = $oauthConnection->ACLAccess('edit') ?? false;
        if ($hasAccess === true) {
            $message .= "" <a href=\""index.php?module=ExternalOAuthConnection&action=$linkAction&record=$oAuthConnectionId\"">$oauthConnectionName</a>."";
        } else {
            $message .= $oauthConnectionName . '.';
        }

        return $message;
    }

    /**
     * Get OAuthToken. Refresh if needed
     * @param string $oAuthConnectionId
     * @return string|null
     */
    protected function getOAuthToken(string $oAuthConnectionId): ?string
    {
        require_once __DIR__ . '/../ExternalOAuthConnection/services/OAuthAuthorizationService.php';
        $oAuth = new OAuthAuthorizationService();

        /** @var ExternalOAuthConnection $oauthConnection */
        $oauthConnection = BeanFactory::getBean('ExternalOAuthConnection', $oAuthConnectionId);
        $password = $oauthConnection->access_token;

        $hasExpiredFeedback = $oAuth->hasConnectionTokenExpired($oauthConnection);
        $refreshToken = $hasExpiredFeedback['refreshToken'] ?? false;
        if ($refreshToken === true) {
            $refreshTokenFeedback = $oAuth->refreshConnectionToken($oauthConnection);

            if ($refreshTokenFeedback['success'] === false) {
                $message = $this->getOAuthRefreshTokenErrorMessage(
                    $refreshTokenFeedback['reLogin'],
                    $oauthConnection,
                    $oAuthConnectionId
                );
                displayAdminError($message);
                return null;
            }

            return $oauthConnection->access_token;
        }

        return $password;
    }

    /**
     * Check if is using oauth authentication
     * @return bool
     */
    protected function isOAuth(): bool
    {
        $authType = $this->auth_type ?? '';
        $oAuthConnectionId = $this->external_oauth_connection_id ?? '';

        return $authType === 'oauth' && $oAuthConnectionId !== '';
    }


} // end class definition
",1
"    protected function bitwiseOrHelper(Engine $x)
    {
        $left = $this->toBytes(true);
        $right = $x->toBytes(true);

        $length = max(strlen($left), strlen($right));

        $left = str_pad($left, $length, chr(0), STR_PAD_LEFT);
        $right = str_pad($right, $length, chr(0), STR_PAD_LEFT);

        return $this->normalize(new static($left | $right, -256));
    }",0
"    public function logout(Request $request, Response $response, $id)
    {
        if ($this->getUser()->userTypeId != 1) {
            throw new AccessDeniedException();
        }

        // We log out all of this user's sessions.
        $this->sessionFactory->expireByUserId($id);

        // Return
        $this->getState()->hydrate([
            'message' => __('User Logged Out.')
        ]);

        return $this->render($request, $response);
    }",0
"	public function create_item( $request ) {
		/**
		 * Original post ID.
		 *
		 * @var int $original_id
		 */
		$original_id = ! empty( $request['original_id'] ) ? $request['original_id'] : null;
		if ( ! $original_id ) {
			return parent::create_item( $request );
		}

		$original_post = $this->get_post( $original_id );
		if ( is_wp_error( $original_post ) ) {
			return $original_post;
		}

		if ( ! $this->check_update_permission( $original_post ) ) {
			return new \WP_Error(
				'rest_cannot_create',
				__( 'Sorry, you are not allowed to duplicate this story.', 'web-stories' ),
				[ 'status' => rest_authorization_required_code() ]
			);
		}

		$request->set_param( 'content', $original_post->post_content );
		$request->set_param( 'excerpt', $original_post->post_excerpt );

		$title = sprintf(
			/* translators: %s: story title. */
			__( '%s (Copy)', 'web-stories' ),
			$original_post->post_title
		);
		$request->set_param( 'title', $title );

		$story_data = json_decode( $original_post->post_content_filtered, true );
		if ( $story_data ) {
			$request->set_param( 'story_data', $story_data );
		}

		$thumbnail_id = get_post_thumbnail_id( $original_post );
		if ( $thumbnail_id ) {
			$request->set_param( 'featured_media', $thumbnail_id );
		}

		$meta = $this->get_registered_meta( $original_post );
		if ( $meta ) {
			$request->set_param( 'meta', $meta );
		}

		return parent::create_item( $request );
	}",0
"    public static function addTimer($interval, $callback)
    {
        return self::get()->addTimer($interval, $callback);
    }",0
"    public function __construct(
        private readonly HttpKernelInterface $httpKernel,
        private readonly SalesChannelContextServiceInterface $contextService,
        private bool $kernelDebug,
        private readonly CacheInterface $cache,
        private readonly AbstractCacheTracer $cacheTracer,
        private readonly EntityCacheKeyGenerator $generator,
        private readonly CacheInvalidator $cacheInvalidator,
        private readonly EventDispatcherInterface $eventDispatcher
    ) {
    }",1
"            $updated = $temporal->toUserTime($active_session['last_accessed']);

            $sessions_card .=
<<<HTML
<table class=""ml-4 mb-2 text-muted"">
    <tbody>
        <tr>
            <td class=""align-top pr-3 text-primary"">
                <small><b class=""text-uppercase"">{$this->lang->t9n('Client IP')}</b></small>
            </td>
            <td>
                {$active_session['remote_ip']}
            </td>
        </tr>
        <tr>
            <td class=""align-top pr-3"">
                <small><b class=""text-uppercase"">{$this->lang->t9n('Software')}</b></small>
            </td>
            <td>
                {$active_session['user_agent']}
            </td>
        </tr>
        <tr>
            <td class=""align-top pr-3"">
                <small><b class=""text-uppercase"">{$this->lang->t9n('Started')}</b></small>
            </td>
            <td>
                $created
            </td>
        </tr>
        <tr>
            <td class=""align-top pr-3"">
                <small><b class=""text-uppercase"">{$this->lang->t9n('Last access')}</b></small>
            </td>
            <td>
                $updated
            </td>
        </tr>
    </tbody>
</table>
HTML;
        }

        /*
         * Row.
         */

        /** @var Bootstrap\Row $el */
        $el = $this->di->get('Row');

        $el->addClass('d-flex align-content-start no-gutters');
        $el->column($bc, 'col-12');
        $el->column($cards[0] ?? '', 'col-xl-6 mb-3 pr-xl-2');
        $el->column($cards[1] ?? '', 'col-xl-6 mb-3 pl-xl-2');
        $el->column($cards[2] ?? '', 'col-xl-6 mb-3 pr-xl-2');
        $el->column($cards[3] ?? '', 'col-xl-6 mb-3 pl-xl-2');
        $el->column($cards[4] ?? '', 'col-xl-6 mb-3 pr-xl-2');
        $el->column($cards[5] ?? '', 'col-xl-6 mb-3 pl-xl-2');
        $el->column($cards[6] ?? '', 'col-xl-6 mb-3 pr-xl-2');
        $el->column($cards[7] ?? '', 'col-xl-6 mb-3 pl-xl-2');
        $el->column($sessions_card, 'col-12 mb-3');

        $content = $el->render();

        /*
         * Advanced search modal.
         */

        /** @var Bootstrap\Button $el */
        $el = $this->di->get('Button');

        $el->addClass('search-submit');
        $el->context('primary');
        $el->html($this->lang->t9n('Search-VERB'));
        $search_button = $el->render();

        $el = null;

        /** @var Bootstrap\Modal $el */
        $el = $this->di->get('Modal');

        $el->id('modal-advanced-search');
        $el->header($this->lang->t9n('Search library'));
        $el->button($search_button);
        $el->body($this->sharedAdvancedSearch($data['tags']), 'bg-darker-5');
        $el->componentSize('large');
        $content .= $el->render();

        $el = null;

        $this->append([
            'html' => $content
        ]);

        return $this->send();
    }",1
"			$qs = parse_url( htmlspecialchars_decode( $url ), PHP_URL_QUERY );
			parse_str( $qs, $qs );
			if ( empty( $qs[ self::QS_ACTION ] ) ) {
				continue;
			}
			$esi_id = $qs[ self::QS_ACTION ];
			$esi_param = ! empty( $qs[ self::QS_PARAMS ] ) ? $this->_parse_esi_param( $qs[ self::QS_PARAMS ] ) : false;
			$inline_param = apply_filters( 'litespeed_esi_inline-' . $esi_id, array(), $esi_param ); // Returned array need to be [ val, control, tag ]
			if ( $inline_param ) {
				$output .= self::_build_inline( $url, $inline_param );
			}
		}",1
"	public function currentUserFromSession($session = null)
	{
		$session = $this->session($session);

		$id = $session->data()->get('kirby.userId');

		if (is_string($id) !== true) {
			return null;
		}

		if ($user = $this->kirby->users()->find($id)) {
			// in case the session needs to be updated, do it now
			// for better performance
			$session->commit();
			return $user;
		}

		return null;
	}",1
"			$diroptions_filename = FileDir::makeCorrectFile(Settings::Get('system.apacheconf_diroptions') . '/40_froxlor_diroption_' . md5($row_diroptions['path']) . '.conf');

			if (!isset($this->diroptions_data[$diroptions_filename])) {
				$this->diroptions_data[$diroptions_filename] = '';
			}

			if (is_dir($row_diroptions['path'])) {
				$cperlenabled = Customer::customerHasPerlEnabled($row_diroptions['customerid']);

				$this->diroptions_data[$diroptions_filename] .= '<Directory ""' . $row_diroptions['path'] . '"">' . ""\n"";

				if (isset($row_diroptions['options_indexes']) && $row_diroptions['options_indexes'] == '1') {
					$this->diroptions_data[$diroptions_filename] .= '  Options +Indexes';

					// add perl options if enabled
					if ($cperlenabled && isset($row_diroptions['options_cgi']) && $row_diroptions['options_cgi'] == '1') {
						$this->diroptions_data[$diroptions_filename] .= ' +ExecCGI -MultiViews +SymLinksIfOwnerMatch +FollowSymLinks' . ""\n"";
					} else {
						$this->diroptions_data[$diroptions_filename] .= ""\n"";
					}
					FroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_INFO, 'Setting Options +Indexes for ' . $row_diroptions['path']);
				}

				if (isset($row_diroptions['options_indexes']) && $row_diroptions['options_indexes'] == '0') {
					$this->diroptions_data[$diroptions_filename] .= '  Options -Indexes';

					// add perl options if enabled
					if ($cperlenabled && isset($row_diroptions['options_cgi']) && $row_diroptions['options_cgi'] == '1') {
						$this->diroptions_data[$diroptions_filename] .= ' +ExecCGI -MultiViews +SymLinksIfOwnerMatch +FollowSymLinks' . ""\n"";
					} else {
						$this->diroptions_data[$diroptions_filename] .= ""\n"";
					}
					FroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_INFO, 'Setting Options -Indexes for ' . $row_diroptions['path']);
				}

				$statusCodes = [
					'404',
					'403',
					'500'
				];
				foreach ($statusCodes as $statusCode) {
					if (isset($row_diroptions['error' . $statusCode . 'path']) && $row_diroptions['error' . $statusCode . 'path'] != '') {
						$defhandler = $row_diroptions['error' . $statusCode . 'path'];
						if (!Validate::validateUrl($defhandler)) {
							if (substr($defhandler, 0, 1) != '""' && substr($defhandler, -1, 1) != '""') {
								$defhandler = '""' . FileDir::makeCorrectFile($defhandler) . '""';
							}
						}
						$this->diroptions_data[$diroptions_filename] .= '  ErrorDocument ' . $statusCode . ' ' . $defhandler . ""\n"";
					}
				}

				if ($cperlenabled && isset($row_diroptions['options_cgi']) && $row_diroptions['options_cgi'] == '1') {
					$this->diroptions_data[$diroptions_filename] .= '  AllowOverride None' . ""\n"";
					$this->diroptions_data[$diroptions_filename] .= '  AddHandler cgi-script .cgi .pl' . ""\n"";
					// >=apache-2.4 enabled?
					if (Settings::Get('system.apache24') == '1') {
						$mypath_dir = new Directory($row_diroptions['path']);
						// only create the require all granted if there is not active directory-protection
						// for this path, as this would be the first require and therefore grant all access
						if ($mypath_dir->isUserProtected() == false) {
							$this->diroptions_data[$diroptions_filename] .= '  Require all granted' . ""\n"";
							// $this->diroptions_data[$diroptions_filename] .= ' AllowOverride All' . ""\n"";
						}
					} else {
						$this->diroptions_data[$diroptions_filename] .= '  Order allow,deny' . ""\n"";
						$this->diroptions_data[$diroptions_filename] .= '  Allow from all' . ""\n"";
					}
					FroxlorLogger::getInstanceOf()->logAction(FroxlorLogger::CRON_ACTION, LOG_INFO, 'Enabling perl execution for ' . $row_diroptions['path']);

					// check for suexec-workaround, #319
					if ((int)Settings::Get('perl.suexecworkaround') == 1) {
						// symlink this directory to suexec-safe-path
						$loginname = Customer::getCustomerDetail($row_diroptions['customerid'], 'loginname');
						$suexecpath = FileDir::makeCorrectDir(Settings::Get('perl.suexecpath') . '/' . $loginname . '/' . md5($row_diroptions['path']) . '/');

						if (!file_exists($suexecpath)) {
							FileDir::safe_exec('mkdir -p ' . escapeshellarg($suexecpath));
							FileDir::safe_exec('chown -R ' . escapeshellarg($row_diroptions['guid']) . ':' . escapeshellarg($row_diroptions['guid']) . ' ' . escapeshellarg($suexecpath));
						}

						// symlink to {$givenpath}/cgi-bin
						// NOTE: symlinks are FILES, so do not append a / here
						$perlsymlink = FileDir::makeCorrectFile($row_diroptions['path'] . '/cgi-bin');
						if (!file_exists($perlsymlink)) {
							FileDir::safe_exec('ln -s ' . escapeshellarg($suexecpath) . ' ' . escapeshellarg($perlsymlink));
						}
						FileDir::safe_exec('chown -h ' . escapeshellarg($row_diroptions['guid']) . ':' . escapeshellarg($row_diroptions['guid']) . ' ' . escapeshellarg($perlsymlink));
					}
				} else {
					// if no perl-execution is enabled but the workaround is,
					// we have to remove the symlink and folder in suexecpath
					if ((int)Settings::Get('perl.suexecworkaround') == 1) {
						$loginname = Customer::getCustomerDetail($row_diroptions['customerid'], 'loginname');
						$suexecpath = FileDir::makeCorrectDir(Settings::Get('perl.suexecpath') . '/' . $loginname . '/' . md5($row_diroptions['path']) . '/');
						$perlsymlink = FileDir::makeCorrectFile($row_diroptions['path'] . '/cgi-bin');

						// remove symlink
						if (file_exists($perlsymlink)) {
							FileDir::safe_exec('rm -f ' . escapeshellarg($perlsymlink));
						}
						// remove folder in suexec-path
						if (file_exists($suexecpath)) {
							FileDir::safe_exec('rm -rf ' . escapeshellarg($suexecpath));
						}
					}
				}

				if (count($row_diroptions['htpasswds']) > 0) {
					$htpasswd_filename = FileDir::makeCorrectFile(Settings::Get('system.apacheconf_htpasswddir') . '/' . $row_diroptions['customerid'] . '-' . md5($row_diroptions['path']) . '.htpasswd');

					if (!isset($this->htpasswds_data[$htpasswd_filename])) {
						$this->htpasswds_data[$htpasswd_filename] = '';
					}

					foreach ($row_diroptions['htpasswds'] as $row_htpasswd) {
						$this->htpasswds_data[$htpasswd_filename] .= $row_htpasswd['username'] . ':' . $row_htpasswd['password'] . ""\n"";
					}

					$this->diroptions_data[$diroptions_filename] .= '  AuthType Basic' . ""\n"";
					$this->diroptions_data[$diroptions_filename] .= '  AuthName ""' . $row_htpasswd['authname'] . '""' . ""\n"";
					$this->diroptions_data[$diroptions_filename] .= '  AuthUserFile ' . $htpasswd_filename . ""\n"";
					$this->diroptions_data[$diroptions_filename] .= '  require valid-user' . ""\n"";
				}

				$this->diroptions_data[$diroptions_filename] .= '</Directory>' . ""\n"";
			}
		}",1
"    public function fill_in_additional_detail_fields()
    {
        global $current_language, $timedate, $locale, $sugar_config;

        parent::fill_in_additional_detail_fields();

        $mod_strings = return_module_language($current_language, 'Documents');

        if (!empty($this->document_revision_id)) {
            $query = ""SELECT users.first_name AS first_name, users.last_name AS last_name, document_revisions.date_entered AS rev_date,
            	 document_revisions.filename AS filename, document_revisions.revision AS revision,
            	 document_revisions.file_ext AS file_ext, document_revisions.file_mime_type AS file_mime_type
            	 FROM users, document_revisions
            	 WHERE users.id = document_revisions.created_by AND document_revisions.id = '$this->document_revision_id'"";

            $result = $this->db->query($query);
            $row = $this->db->fetchByAssoc($result);

            //populate name
            if (isset($this->document_name)) {
                $this->name = $this->document_name;
            }

            if (isset($row['filename'])) {
                $this->filename = $row['filename'];
            }
            //$this->latest_revision = $row['revision'];
            if (isset($row['revision'])) {
                $this->revision = $row['revision'];
            }

            //image is selected based on the extension name <ext>_icon_inline, extension is stored in document_revisions.
            //if file is not found then default image file will be used.
            global $img_name, $img_name_bare;

            if (!empty($row['file_ext'])) {
                $img_name = SugarThemeRegistry::current()->getImageURL(strtolower($row['file_ext']) . ""_image_inline.gif"");
                $img_name_bare = strtolower($row['file_ext']) . ""_image_inline"";

                $allowedPreview = $sugar_config['allowed_preview'] ?? [];

                if (in_array($row['file_ext'], $allowedPreview, true)) {
                    $this->show_preview = true;
                }

            }
        }

        //set default file name.
        if (!empty($img_name) && file_exists($img_name)) {
            $img_name = $img_name_bare;
        } else {
            $img_name = ""def_image_inline""; //todo change the default image.
        }
        if ($this->ACLAccess('DetailView')) {
            if (!empty($this->doc_type) && $this->doc_type != 'Sugar' && !empty($this->doc_url)) {
                $file_url = ""<a href='"" . $this->doc_url . ""' target='_blank'>"" . SugarThemeRegistry::current()->getImage(
                    $this->doc_type . '_image_inline',
                    'border=""0""',
                    null,
                    null,
                    '.png',
                    $mod_strings['LBL_LIST_VIEW_DOCUMENT']
                ) . ""</a>"";
            } else {
                $file_url = ""<a href='index.php?entryPoint=download&id={$this->document_revision_id}&type=Documents' target='_blank'>"" . SugarThemeRegistry::current()->getImage(
                    $img_name,
                    'border=""0""',
                    null,
                    null,
                    '.gif',
                    $mod_strings['LBL_LIST_VIEW_DOCUMENT']
                ) . ""</a>"";
            }

            $this->file_url = $file_url;
            $this->file_url_noimage = ""index.php?entryPoint=download&type=Documents&id={$this->document_revision_id}"";
        } else {
            $this->file_url = """";
            $this->file_url_noimage = """";
        }

        //get last_rev_by user name.
        if (!empty($row)) {
            $this->last_rev_created_name = $locale->getLocaleFormattedName($row['first_name'], $row['last_name']);

            $this->last_rev_create_date = $timedate->to_display_date_time($this->db->fromConvert(
                $row['rev_date'],
                'datetime'
            ));
            $this->last_rev_mime_type = $row['file_mime_type'];
        }

        global $app_list_strings;
        if (!empty($this->status_id)) {
            $this->status = $app_list_strings['document_status_dom'][$this->status_id];
        }
        if (!empty($this->related_doc_id)) {
            $this->related_doc_name = (new Document())->get_document_name($this->related_doc_id);
            $this->related_doc_rev_number = (new DocumentRevision)->get_document_revision_name($this->related_doc_rev_id);
        }
    }",1
"            $port = intval($_SERVER['SERVER_PORT']);
        } elseif ($protocol === 'https') {
            $port = 443;
        } else {
            $port = 80;
        }

        if (isset($_SERVER['HTTP_HOST'])) {
            $host = explode(':', $_SERVER['HTTP_HOST'])[0];
        } elseif (isset($_SERVER['SERVER_NAME'])) {
            $host = $_SERVER['SERVER_NAME'];
        } elseif (isset($_SERVER['SERVER_ADDR'])) {
            $host = $_SERVER['SERVER_ADDR'];
        } else {
            return 'http:///';
        }

        $port = (443 === $port) || (80 === $port) ? '' : ':' . $port;
	    
        $explodedRequestUri = isset($_SERVER['REQUEST_URI']) ? explode('?', $_SERVER['REQUEST_URI']) : [];
        return sprintf('%s://%s%s/%s', $protocol, $host, $port, trim(reset($explodedRequestUri), '/'));
    }",0
"				foreach($keywords as $keyword){

					$bind_key = ':freeword'.$keywordCounts;

					if($keyword[0] == ""-""){
						$keyword = substr($keyword,1);
						$freeword[] = 'Entry.'.$column."" not like "".$bind_key."""";
					}else{
						$freeword[] = 'Entry.'.$column."" like "".$bind_key."""";
					}

					$binds[$bind_key] = '%'.$keyword.'%';
					$keywordCounts ++;
				}",1
"    private function convert2pdf($file,$cacheFile,$ext){
		$command = $this->getSoffice();
		if(!$command){
			Action($this->pluginName)->showTips(LNG('officeViewer.libreOffice.sofficeError'), 'LibreOffice');
		}
		//linux下$cacheFile不可写问题，先生成到/tmp下;再复制出来
		$tempPath = $cacheFile;
		if($GLOBALS['config']['systemOS'] == 'linux' && is_writable('/tmp/')){
			mk_dir('/tmp/libreOffice');
			$tempPath = '/tmp/libreOffice/'.rand_string(15).'.pdf';
		}
        $fname = get_path_this($tempPath);
        $fpath = get_path_father($tempPath);
        // 转换类型'pdf'改为'新文件名.pdf'，会生成'源文件名.新文件名.pdf'
		$export = 'export HOME=/tmp/libreOffice && ';
        $script = $export.$command . ' --headless --invisible --convert-to '.escapeShell($fname).' ""'.escapeShell($file).'"" --outdir '.$fpath;
		$out = shell_exec($script);

        $tname = substr(end(explode('/', $file)), 0, -strlen('.'.$ext));
        $tfile = $fpath . $tname . '.' . $fname;    // 源文件名.filename.pdf
        if(!file_exists($tfile)){
            write_log('libreoffice convert error: '.$script.""\n"".$out,'error');
        }
		$res = move_path($tfile,$cacheFile);
		if (!$res) write_log('libreoffice move file error: '.$tfile.'=>'.$cacheFile, 'error');
	}",0
"    public function isVisible()
    {
        // current photo album must belong to current organization
        if ($this->getValue('pho_id') > 0 && (int) $this->getValue('pho_org_id') !== $GLOBALS['gCurrentOrgId']) {
            return false;
        }
        // locked photo album could only be viewed by module administrators
        elseif ((int) $this->getValue('pho_locked') === 1 && !$GLOBALS['gCurrentUser']->editPhotoRight()) {
            return false;
        }

        return true;
    }",1
"    public function sourceRecords($params = [], $sort = null, $limit = null)
    {
        $list = new ArrayList();
        $list->setDataClass(Member::class);
        return $list;
    }",0
"    public function __construct(MessageComponentInterface $component, array $allowed = []) {
        $this->_component = $component;
        $this->allowedOrigins += $allowed;
    }",0
"    public function __construct(
        SystemStoreInterface $systemStore,
        RequestAnalyzerInterface $requestAnalyzer,
        string $context
    ) {
        $this->systemStore = $systemStore;
        $this->requestAnalyzer = $requestAnalyzer;
        $this->context = $context;
    }",1
"    public function uploadXHR($post_filename, $allowed_ext = false, $allowed_size = 0, $destination = false){

        $dest_name = files_sanitize_name($_GET['qqfile'], false);
        $dest_ext  = pathinfo($dest_name, PATHINFO_EXTENSION);

        if(!$this->checkExt($dest_ext, $allowed_ext)){
            return array(
                'error'   => LANG_UPLOAD_ERR_MIME,
                'success' => false,
                'name'    => $dest_name
            );
        }

        if ($allowed_size){
            if ($this->getXHRFileSize() > $allowed_size){
                return array(
                    'error'   => sprintf(LANG_UPLOAD_ERR_INI_SIZE, files_format_bytes($allowed_size)),
                    'success' => false,
                    'name'    => $dest_name
                );
            }
        }

        if (!$destination){
            $destination = $this->getUploadDestinationDirectory();
        } else {
            $destination = $this->site_cfg->upload_path . $destination . '/';
        }

        $destination .= $this->getFileName($destination, $dest_ext);

        return $this->saveXHRFile($destination, $dest_name);

    }",1
"	public static function pregSplit($pattern, $modifiers, $subject, $limit=NULL, $flags=NULL) {
		// PHP 8.1 deprecates nulls for $limit and $flags
		$limit = $limit === null ? -1 : $limit;
		$flags = $flags === null ? 0 : $flags;
		// the bug only happens on PHP 5.2 when using the u modifier
		if ((strpos($modifiers, 'u') === FALSE) OR (count(preg_split('//u', ""\n\t"", -1, PREG_SPLIT_NO_EMPTY)) == 2)) {
			$ret = preg_split($pattern.$modifiers, $subject, $limit, $flags);
			if ($ret === false) {
				return array();
			}
			return $ret;
		}
		// preg_split is bugged - try alternative solution
		$ret = array();
		while (($nl = strpos($subject, ""\n"")) !== FALSE) {
			$ret = array_merge($ret, preg_split($pattern.$modifiers, substr($subject, 0, $nl), $limit, $flags));
			$ret[] = ""\n"";
			$subject = substr($subject, ($nl + 1));
		}
		if (strlen($subject) > 0) {
			$ret = array_merge($ret, preg_split($pattern.$modifiers, $subject, $limit, $flags));
		}
		return $ret;
	}",1
"    public function getForbiddenStandardMassiveAction()
    {

        $forbidden   = parent::getForbiddenStandardMassiveAction();
        $forbidden[] = 'update';

        if (isset($_POST['rule_class_name']) && is_subclass_of(\Rule::class, $_POST['rule_class_name'])) {
            $rule = new $_POST['rule_class_name']();
            if ($rule->maxActionsCount() == 1) {
                $forbidden[] = 'clone';
            }
        }
        //maxActionsCount on Rule
        return $forbidden;
    }",1
"	public function relational_terms_search() {
		check_ajax_referer( SCF_Config::NAME . '-relation-taxonomies', 'nonce' );
		$_terms = array();
		$args   = array();

		$taxonomies = filter_input( INPUT_POST, 'taxonomies' );
		if ( $taxonomies ) {
			$taxonomies = explode( ',', $taxonomies );
			$args       = array(
				'taxonomy'     => $taxonomies,
				'order'        => 'ASC',
				'orderby'      => 'ID',
				'number'       => '',
				'hide_empty'   => false,
				'hierarchical' => false,
			);

			$click_count = filter_input( INPUT_POST, 'click_count' );
			if ( $click_count ) {
				$number = get_option( 'posts_per_page' );
				$offset = $click_count * $number;
				$args   = array_merge(
					$args,
					array(
						'offset' => $offset,
						'number' => $number,
					)
				);
			}

			$search = filter_input( INPUT_POST, 'search' );
			if ( $search ) {
				$args = array_merge(
					$args,
					array(
						'search' => $search,
					)
				);
			}

			$_terms = get_terms( $args );
		}
		header( 'Content-Type: application/json; charset=utf-8' );
		echo wp_json_encode( $_terms );
		die();
	}",1
"    public function get_by_order_id($order_id = false)
    {
        $order_id = intval($order_id);
        if ($order_id == false) {
            return;
        }
        $params = array();
        $table =  'cart';
        $params['table'] = $table;
        $params['order_id'] = $order_id;
        $get = $this->app->database_manager->get($params);

        if (!empty($get)) {
            foreach ($get as $k => $item) {

                if (is_array($item) and isset($item['custom_fields_data']) and $item['custom_fields_data'] != '') {
                    $item = $this->app->format->render_item_custom_fields_data($item);
                }

                if (!isset($item['item_image']) and is_array($item) and isset($item['rel_id']) and isset($item['rel_type']) and $item['rel_type'] == 'content') {
                    $item['item_image'] = get_picture($item['rel_id']);
                }

                if (!isset($item['item_image'])) {
                    $item['item_image'] = false;
                }

                $get[$k] = $item;
            }
        }

        return $get;
    }",1
"    public function setFileName($name) {
        $this->file_name = mb_substr(trim($name), 0, 64); return $this;
    }",1
"    protected function makeStyle($attributes) {
        $style = new Style();
        $style->inherit($this);
        $style->fromStyleSheets($this, $attributes);
        $style->fromAttributes($attributes);

        return $style;
    }",1
"    public function enableRemoteUpload() {
        $this->allow_remote = true; return $this;
    }",1
"                                    <a href=""javascript:void(0);"" data-categorie-id=""<?= $page['id'] ?>"" class=""go-category left-side <?= isset($_GET['category']) && $_GET['category'] == $page['id'] ? 'selected' : '' ?>"">
                                        <?= $page['name'] ?>
                                    </a>
                                    <?php
                                    if ($children === true) {
                                        loop_tree($page['children'], true);
                                    } else {
                                        ?>
                                    </li>
                                    <?php
                                }
                            }
                            ?>
                        </ul>
                        <?php
                        if ($is_recursion === true) {
                            ?>
                            </li>
                            <?php
                        }
                    }",1
"        $callback = function (array $match) {
            return strtoupper($match[0]);
        };",0
"    public static function savePublicKey(BigInteger $p, BigInteger $q, BigInteger $g, BigInteger $y)
    {
        return ""<DSAKeyValue>\r\n"" .
               '  <P>' . Strings::base64_encode($p->toBytes()) . ""</P>\r\n"" .
               '  <Q>' . Strings::base64_encode($q->toBytes()) . ""</Q>\r\n"" .
               '  <G>' . Strings::base64_encode($g->toBytes()) . ""</G>\r\n"" .
               '  <Y>' . Strings::base64_encode($y->toBytes()) . ""</Y>\r\n"" .
               '</DSAKeyValue>';
    }",0
"    public function getMarkerDataCustom($marker_object)
    {

        // Define Marker
        $marker = array();
        $marker['name'] = $marker_object->name;
        if (empty($marker['name'])) {
            $marker['name'] = 'N/A';
        }
        $marker['id'] = $marker_object->id;
        $marker['lat'] = $marker_object->jjwg_maps_lat;
        if (!$this->is_valid_lat($marker['lat'])) {
            $marker['lat'] = '0';
        }
        $marker['lng'] = $marker_object->jjwg_maps_lng;
        if (!$this->is_valid_lng($marker['lng'])) {
            $marker['lng'] = '0';
        }
        $marker['image'] = $marker_object->marker_image;
        if (empty($marker['image'])) {
            $marker['image'] = 'None';
        }

        if ($marker['lat'] != '0' || $marker['lng'] != '0') {
            $fields = array();
            foreach ($marker_object->column_fields as $field) {
                $fields[$field] = $marker_object->$field;
            }
            // Define Maps Info Window HTML by Sugar Smarty Template
            $this->sugarSmarty->assign(""module_type"", 'jjwg_Markers');
            $this->sugarSmarty->assign(""fields"", $fields); // display fields array
            // Use @ error suppression to avoid issues with SugarCRM On-Demand
            $marker['html'] = @$this->sugarSmarty->fetch('./custom/modules/jjwg_Markers/tpls/MarkersInfoWindow.tpl');
            if (empty($marker['html'])) {
                $marker['html'] = $this->sugarSmarty->fetch('./modules/jjwg_Markers/tpls/MarkersInfoWindow.tpl');
            }
            $marker['html'] = preg_replace('/\n\r/', ' ', (string) $marker['html']);
            //var_dump($marker['html']);
            return $marker;
        } else {
            return false;
        }
    }",1
"	public function testDefaultProps()
	{
		$field = $this->field('link');

		$this->assertSame('link', $field->type());
		$this->assertSame('link', $field->name());
		$this->assertSame('', $field->value());
		$this->assertNull($field->label());
		$this->assertNull($field->text());
		$this->assertTrue($field->save());
		$this->assertNull($field->after());
		$this->assertNull($field->before());
		$this->assertNull($field->icon());
		$this->assertNull($field->placeholder());
		$this->assertSame([
			'url',
			'page',
			'file',
			'email',
			'tel',
			'anchor',
			'custom'
		], $field->options());
	}",1
"	public function formatListRecord($record, $model) {

		$record['path'] = $model->path;

		if ($model instanceof Folder) {
			$record['type_id'] = 'd:' . $model->id;
			$record['type'] = \GO::t(""Folder"", ""files"");
			$record['size'] = '-';
			$record['extension'] = 'folder';
			$record['readonly']=$model->readonly;
		} else {
			$record['type_id'] = 'f:' . $model->id;
			$record['type'] = \GO\Base\Fs\File::getFileTypeDescription($model->extension);
			$record['extension'] = strtolower($model->extension);
			$record['size']=$model->size;
			$record['permission_level']=$this->_listFolderPermissionLevel;
			$record['unlock_allowed']=$model->unlockAllowed();

			if(empty($_REQUEST['noHandler'])){ // Added this line because the json_decode function cannot handle javascript. When noHandler is set to true, this line will be skipped
				$record['handler']='startjs:function(){'.$model->getDefaultHandler()->getHandler($model).'}:endjs';
			}
		}
		$record['thumb_url'] = $model->thumbURL;

		return $record;
	}",1
"    public function testConfiguration()
    {
        $sut = new PDFRenderer(
            $this->createMock(Environment::class),
            $this->createMock(HtmlToPdfConverter::class),
            $this->createMock(ProjectStatisticService::class)
        );

        $this->assertEquals('pdf', $sut->getId());
    }",1
"	public function is_nonce_action( $action ) {
		// If GM not run yet, then ESI not init yet, then ESI nonce will not be allowed even nonce func replaced.
		if ( ! defined( 'LITESPEED_ESI_INITED' ) ) {
			return null;
		}

		if ( is_admin() ) {
			return null;
		}

		if ( defined( 'LITESPEED_ESI_OFF' ) ) {
			return null;
		}

		foreach ( $this->_nonce_actions as $k => $v ) {
			if ( strpos( $k, '*' ) !== false ) {
				if( preg_match( '#' . $k . '#iU', $action ) ) {
					return $v;
				}
			}
			else {
				if ( $k == $action ) {
					return $v;
				}
			}
		}

		return null;
	}",1
"    public function __construct($conference, $user)
    {
        parent::__construct('MeetmeMute');
        $this->setKey('Meetme', $conference);
        $this->setKey('Usernum', $user);
    }",0
"    public function get_sessiondata()
    {
        $sd_resv = !empty($_COOKIE[COOKIE_DATA]) ? unserialize($_COOKIE[COOKIE_DATA], ['allowed_classes' => false]) : [];

        // autologin_id
        if (!empty($sd_resv['uk']) && verify_id($sd_resv['uk'], LOGIN_KEY_LENGTH)) {
            $this->sessiondata['uk'] = $sd_resv['uk'];
        }
        // user_id
        if (!empty($sd_resv['uid'])) {
            $this->sessiondata['uid'] = (int)$sd_resv['uid'];
        }
        // sid
        if (!empty($sd_resv['sid']) && verify_id($sd_resv['sid'], SID_LENGTH)) {
            $this->sessiondata['sid'] = $sd_resv['sid'];
        }
    }",1
"        $last = function ($schema, $query, $context, $vars) {
            return GraphQL::executeQuery($schema, $query, null, $context, $vars);
        };",1
"    public function testInvalidDomainPolicyReader() {
        $this->setExpectedException('UnexpectedValueException');
        $this->_policy->setSiteControl('all');
        $this->_policy->addAllowedAccess('dev.example.*', '*');
        $this->_policy->renderPolicy();
    }",0
"function se_start_user_session($ud) {
	
	/* reset session id */
	session_regenerate_id(true);

	$_SESSION['user_id'] = $ud['user_id'];
	$_SESSION['user_nick'] = $ud['user_nick'];
	$_SESSION['user_mail'] = $ud['user_mail'];
	$_SESSION['user_class'] = $ud['user_class'];
	$_SESSION['user_psw'] = $ud['user_psw'];
	$_SESSION['user_firstname'] = $ud['user_firstname'];
	$_SESSION['user_lastname'] = $ud['user_lastname'];
	$_SESSION['user_hash'] = md5($ud['user_nick']);
	
	/* CSRF Protection */
	$token = md5(uniqid(rand(), TRUE));
	$_SESSION['token']      = $token;
	$_SESSION['token_time'] = time();
	
	$arr_drm = explode(""|"", $ud['user_drm']);
	
	if($arr_drm[0] == ""drm_acp_pages"")	{  $_SESSION['acp_pages'] = ""allowed"";  }
	if($arr_drm[1] == ""drm_acp_files"")	{  $_SESSION['acp_files'] = ""allowed"";  }
	if($arr_drm[2] == ""drm_acp_user"")	{  $_SESSION['acp_user'] = ""allowed"";  }
	if($arr_drm[3] == ""drm_acp_system"")	{  $_SESSION['acp_system'] = ""allowed"";  }
	if($arr_drm[4] == ""drm_acp_editpages"")	{  $_SESSION['acp_editpages'] = ""allowed"";  }
	if($arr_drm[5] == ""drm_acp_editownpages"")	{  $_SESSION['acp_editownpages'] = ""allowed"";  }
	if($arr_drm[6] == ""drm_moderator"")	{  $_SESSION['drm_moderator'] = ""allowed"";  }
	if($arr_drm[7] == ""drm_can_publish"")	{  $_SESSION['drm_can_publish'] = ""true"";  }
	if($arr_drm[8] == ""drm_acp_sensitive_files"")	{  $_SESSION['drm_acp_sensitive_files'] = ""allowed"";  }
	
}",1
"    public static function keyProvider() {
        return array(
            array(true,  ['hkfa1L7uwN6DCo4IS3iWAw==']),
            array(true,  ['765vVoQpKSGJwPzJIMM2GA==']),
            array(true,  ['AQIDBAUGBwgJCgsMDQ4PEC==']),
            array(true,  ['axa2B/Yz2CdpfQAY2Q5P7w==']),
            array(false, [0]),
            array(false, ['Hello World']),
            array(false, ['1234567890123456']),
            array(false, ['123456789012345678901234']),
            array(true,  [base64_encode('UTF8allthngs+✓')]),
            array(true,  ['dGhlIHNhbXBsZSBub25jZQ==']),
            array(false, []),
            array(false, ['dGhlIHNhbXBsZSBub25jZQ==', 'Some other value']),
            array(false, ['Some other value', 'dGhlIHNhbXBsZSBub25jZQ=='])
        );
    }",0
"    private function insertSession($key, $data, $lastAccessed, $expiry)
    {
        //$this->log->debug('Session insert');

        $sql = '
          INSERT INTO `session` (session_id, session_data, session_expiration, lastaccessed, userid, isexpired, useragent, remoteaddr)
            VALUES (:session_id, :session_data, :session_expiration, :lastAccessed, :userId, :expired, :useragent, :remoteaddr)
        ';

        $params = [
            'session_id' => $key,
            'session_data' => $data,
            'session_expiration' => $expiry,
            'lastAccessed' => Carbon::createFromTimestamp($lastAccessed)->format(DateFormatHelper::getSystemFormat()),
            'userId' => $this->userId,
            'expired' => ($this->expired) ? 1 : 0,
            'useragent' => substr(htmlspecialchars($_SERVER['HTTP_USER_AGENT']), 0, 253),
            'remoteaddr' => $this->getIp()
        ];

        $this->getDb()->update($sql, $params);
    }",0
"                        $iv = substr($ciphertext, -$this->block_size);
                    }

                    return $ciphertext;
                case self::MODE_CFB8:
                    $ciphertext = openssl_encrypt($plaintext, $this->cipher_name_openssl, $this->key, OPENSSL_RAW_DATA | OPENSSL_ZERO_PADDING, $this->encryptIV);
                    if ($this->continuousBuffer) {
                        if (($len = strlen($ciphertext)) >= $this->block_size) {
                            $this->encryptIV = substr($ciphertext, -$this->block_size);
                        } else {
                            $this->encryptIV = substr($this->encryptIV, $len - $this->block_size) . substr($ciphertext, -$len);
                        }
                    }
                    return $ciphertext;
                case self::MODE_OFB8:
                    $ciphertext = '';
                    $len = strlen($plaintext);
                    $iv = $this->encryptIV;

                    for ($i = 0; $i < $len; ++$i) {
                        $xor = openssl_encrypt($iv, $this->cipher_name_openssl_ecb, $this->key, $this->openssl_options, $this->decryptIV);
                        $ciphertext .= $plaintext[$i] ^ $xor;
                        $iv = substr($iv, 1) . $xor[0];
                    }

                    if ($this->continuousBuffer) {
                        $this->encryptIV = $iv;
                    }
                    break;
                case self::MODE_OFB:
                    return $this->openssl_ofb_process($plaintext, $this->encryptIV, $this->enbuffer);
            }
        }

        if ($this->engine === self::ENGINE_MCRYPT) {
            set_error_handler(function () {
            });
            if ($this->enchanged) {
                mcrypt_generic_init($this->enmcrypt, $this->key, $this->getIV($this->encryptIV));
                $this->enchanged = false;
            }

            // re: {@link http://phpseclib.sourceforge.net/cfb-demo.phps}
            // using mcrypt's default handing of CFB the above would output two different things.  using phpseclib's
            // rewritten CFB implementation the above outputs the same thing twice.
            if ($this->mode == self::MODE_CFB && $this->continuousBuffer) {
                $block_size = $this->block_size;
                $iv = &$this->encryptIV;
                $pos = &$this->enbuffer['pos'];
                $len = strlen($plaintext);
                $ciphertext = '';
                $i = 0;
                if ($pos) {
                    $orig_pos = $pos;
                    $max = $block_size - $pos;
                    if ($len >= $max) {
                        $i = $max;
                        $len -= $max;
                        $pos = 0;
                    } else {
                        $i = $len;
                        $pos += $len;
                        $len = 0;
                    }
                    $ciphertext = substr($iv, $orig_pos) ^ $plaintext;
                    $iv = substr_replace($iv, $ciphertext, $orig_pos, $i);
                    $this->enbuffer['enmcrypt_init'] = true;
                }
                if ($len >= $block_size) {
                    if ($this->enbuffer['enmcrypt_init'] === false || $len > $this->cfb_init_len) {
                        if ($this->enbuffer['enmcrypt_init'] === true) {
                            mcrypt_generic_init($this->enmcrypt, $this->key, $iv);
                            $this->enbuffer['enmcrypt_init'] = false;
                        }
                        $ciphertext .= mcrypt_generic($this->enmcrypt, substr($plaintext, $i, $len - $len % $block_size));
                        $iv = substr($ciphertext, -$block_size);
                        $len %= $block_size;
                    } else {
                        while ($len >= $block_size) {
                            $iv = mcrypt_generic($this->ecb, $iv) ^ substr($plaintext, $i, $block_size);
                            $ciphertext .= $iv;
                            $len -= $block_size;
                            $i += $block_size;
                        }
                    }
                }

                if ($len) {
                    $iv = mcrypt_generic($this->ecb, $iv);
                    $block = $iv ^ substr($plaintext, -$len);
                    $iv = substr_replace($iv, $block, 0, $len);
                    $ciphertext .= $block;
                    $pos = $len;
                }

                restore_error_handler();

                return $ciphertext;
            }

            $ciphertext = mcrypt_generic($this->enmcrypt, $plaintext);

            if (!$this->continuousBuffer) {
                mcrypt_generic_init($this->enmcrypt, $this->key, $this->getIV($this->encryptIV));
            }

            restore_error_handler();

            return $ciphertext;
        }

        if ($this->engine === self::ENGINE_EVAL) {
            $inline = $this->inline_crypt;
            return $inline('encrypt', $plaintext);
        }

        $buffer = &$this->enbuffer;
        $block_size = $this->block_size;
        $ciphertext = '';
        switch ($this->mode) {
            case self::MODE_ECB:
                for ($i = 0; $i < strlen($plaintext); $i += $block_size) {
                    $ciphertext .= $this->encryptBlock(substr($plaintext, $i, $block_size));
                }
                break;
            case self::MODE_CBC:
                $xor = $this->encryptIV;
                for ($i = 0; $i < strlen($plaintext); $i += $block_size) {
                    $block = substr($plaintext, $i, $block_size);
                    $block = $this->encryptBlock($block ^ $xor);
                    $xor = $block;
                    $ciphertext .= $block;
                }
                if ($this->continuousBuffer) {
                    $this->encryptIV = $xor;
                }
                break;
            case self::MODE_CTR:
                $xor = $this->encryptIV;
                if (strlen($buffer['ciphertext'])) {
                    for ($i = 0; $i < strlen($plaintext); $i += $block_size) {
                        $block = substr($plaintext, $i, $block_size);
                        if (strlen($block) > strlen($buffer['ciphertext'])) {
                            $buffer['ciphertext'] .= $this->encryptBlock($xor);
                            Strings::increment_str($xor);
                        }
                        $key = Strings::shift($buffer['ciphertext'], $block_size);
                        $ciphertext .= $block ^ $key;
                    }
                } else {
                    for ($i = 0; $i < strlen($plaintext); $i += $block_size) {
                        $block = substr($plaintext, $i, $block_size);
                        $key = $this->encryptBlock($xor);
                        Strings::increment_str($xor);
                        $ciphertext .= $block ^ $key;
                    }
                }
                if ($this->continuousBuffer) {
                    $this->encryptIV = $xor;
                    if ($start = strlen($plaintext) % $block_size) {
                        $buffer['ciphertext'] = substr($key, $start) . $buffer['ciphertext'];
                    }
                }
                break;
            case self::MODE_CFB:
                // cfb loosely routines inspired by openssl's:
                // {@link http://cvs.openssl.org/fileview?f=openssl/crypto/modes/cfb128.c&v=1.3.2.2.2.1}
                if ($this->continuousBuffer) {
                    $iv = &$this->encryptIV;
                    $pos = &$buffer['pos'];
                } else {
                    $iv = $this->encryptIV;
                    $pos = 0;
                }
                $len = strlen($plaintext);
                $i = 0;
                if ($pos) {
                    $orig_pos = $pos;
                    $max = $block_size - $pos;
                    if ($len >= $max) {
                        $i = $max;
                        $len -= $max;
                        $pos = 0;
                    } else {
                        $i = $len;
                        $pos += $len;
                        $len = 0;
                    }
                    // ie. $i = min($max, $len), $len-= $i, $pos+= $i, $pos%= $blocksize
                    $ciphertext = substr($iv, $orig_pos) ^ $plaintext;
                    $iv = substr_replace($iv, $ciphertext, $orig_pos, $i);
                }
                while ($len >= $block_size) {
                    $iv = $this->encryptBlock($iv) ^ substr($plaintext, $i, $block_size);
                    $ciphertext .= $iv;
                    $len -= $block_size;
                    $i += $block_size;
                }
                if ($len) {
                    $iv = $this->encryptBlock($iv);
                    $block = $iv ^ substr($plaintext, $i);
                    $iv = substr_replace($iv, $block, 0, $len);
                    $ciphertext .= $block;
                    $pos = $len;
                }
                break;
            case self::MODE_CFB8:
                $ciphertext = '';
                $len = strlen($plaintext);
                $iv = $this->encryptIV;

                for ($i = 0; $i < $len; ++$i) {
                    $ciphertext .= ($c = $plaintext[$i] ^ $this->encryptBlock($iv));
                    $iv = substr($iv, 1) . $c;
                }

                if ($this->continuousBuffer) {
                    if ($len >= $block_size) {
                        $this->encryptIV = substr($ciphertext, -$block_size);
                    } else {
                        $this->encryptIV = substr($this->encryptIV, $len - $block_size) . substr($ciphertext, -$len);
                    }
                }
                break;
            case self::MODE_OFB8:
                $ciphertext = '';
                $len = strlen($plaintext);
                $iv = $this->encryptIV;

                for ($i = 0; $i < $len; ++$i) {
                    $xor = $this->encryptBlock($iv);
                    $ciphertext .= $plaintext[$i] ^ $xor;
                    $iv = substr($iv, 1) . $xor[0];
                }

                if ($this->continuousBuffer) {
                    $this->encryptIV = $iv;
                }
                break;
            case self::MODE_OFB:
                $xor = $this->encryptIV;
                if (strlen($buffer['xor'])) {
                    for ($i = 0; $i < strlen($plaintext); $i += $block_size) {
                        $block = substr($plaintext, $i, $block_size);
                        if (strlen($block) > strlen($buffer['xor'])) {
                            $xor = $this->encryptBlock($xor);
                            $buffer['xor'] .= $xor;
                        }
                        $key = Strings::shift($buffer['xor'], $block_size);
                        $ciphertext .= $block ^ $key;
                    }
                } else {
                    for ($i = 0; $i < strlen($plaintext); $i += $block_size) {
                        $xor = $this->encryptBlock($xor);
                        $ciphertext .= substr($plaintext, $i, $block_size) ^ $xor;
                    }
                    $key = $xor;
                }
                if ($this->continuousBuffer) {
                    $this->encryptIV = $xor;
                    if ($start = strlen($plaintext) % $block_size) {
                        $buffer['xor'] = substr($key, $start) . $buffer['xor'];
                    }
                }
                break;
            case self::MODE_STREAM:
                $ciphertext = $this->encryptBlock($plaintext);
                break;
        }

        return $ciphertext;
    }",0
"    public static function max(PHP32 ...$nums)
    {
        return self::maxHelper($nums);
    }",0
"    public function setVerifyPeer($verifyPeer) {
        $this->verifyPeer = $verifyPeer;
    }",0
"    public function add($prefix, $paths, $prepend = false)
    {
        $paths = (array) $paths;
        if (!$prefix) {
            if ($prepend) {
                $this->fallbackDirsPsr0 = array_merge(
                    $paths,
                    $this->fallbackDirsPsr0
                );
            } else {
                $this->fallbackDirsPsr0 = array_merge(
                    $this->fallbackDirsPsr0,
                    $paths
                );
            }

            return;
        }

        $first = $prefix[0];
        if (!isset($this->prefixesPsr0[$first][$prefix])) {
            $this->prefixesPsr0[$first][$prefix] = $paths;

            return;
        }
        if ($prepend) {
            $this->prefixesPsr0[$first][$prefix] = array_merge(
                $paths,
                $this->prefixesPsr0[$first][$prefix]
            );
        } else {
            $this->prefixesPsr0[$first][$prefix] = array_merge(
                $this->prefixesPsr0[$first][$prefix],
                $paths
            );
        }
    }",0
"    protected function _sendMail($admin, $admin_pass)
    {
        $admin_name = $admin->name;
        $admin_email = $admin->email;

        $client_url = $this->di['url']->link('/');
        $admin_url = $this->di['url']->adminLink('/');

        $content = ""Hello, $admin_name. "" . PHP_EOL;
        $content .= 'You have successfully installed FOSSBilling at ' . BB_URL . PHP_EOL;
        $content .= 'Access the client area at: ' . $client_url . PHP_EOL;
        $content .= 'Access the admin area at: ' . $admin_url . ' with login details:' . PHP_EOL;
        $content .= 'Email: ' . $admin_email . PHP_EOL;
        $content .= 'Password: ' . $admin_pass . PHP_EOL . PHP_EOL;

        $content .= 'Read the FOSSBilling documentation to get started https://fossbilling.org/docs' . PHP_EOL;
        $content .= 'Thank you for using FOSSBilling.' . PHP_EOL;

        $subject = sprintf('FOSSBilling is ready at ""%s""', BB_URL);

        $systemService = $this->di['mod_service']('system');
        $from = $systemService->getParamValue('company_email');
        $emailService = $this->di['mod_service']('Email');
        $emailService->sendMail($admin_email, $from, $subject, $content);
    }",1
"    public function __construct($device, $number, $message)
    {
        parent::__construct('DongleSendSMS');
        $this->setKey('Device', $device);
        $this->setKey('Number', $number);
        $this->setKey('Message', $message);
    }",0
"            $artifact               = $art_factory->getArtifactById($artifact_link->getArtifactId());
            $this->artifact_links[] = new ArtifactInTypeTablePresenter(
                $artifact,
                $html_classes,
                $field,
                $this->are_links_deletable,
            );
        }",1
"    public function prepareInputForUpdate($input)
    {

        if (isset($input[""rootdn_passwd""])) {
            if (empty($input[""rootdn_passwd""])) {
                unset($input[""rootdn_passwd""]);
            } else {
                $input[""rootdn_passwd""] = (new GLPIKey())->encrypt($input[""rootdn_passwd""]);
            }
        }

        if (isset($input[""_blank_passwd""]) && $input[""_blank_passwd""]) {
            $input['rootdn_passwd'] = '';
        }

       // Set attributes in lower case
        if (count($input)) {
            foreach ($input as $key => $val) {
                if (preg_match('/_field$/', $key)) {
                    $input[$key] = Toolbox::strtolower($val);
                }
            }
        }

       //do not permit to override sync_field
        if (
            $this->isSyncFieldEnabled()
            && isset($input['sync_field'])
            && $this->isSyncFieldUsed()
        ) {
            if ($input['sync_field'] == $this->fields['sync_field']) {
                unset($input['sync_field']);
            } else {
                Session::addMessageAfterRedirect(
                    __('Synchronization field cannot be changed once in use.'),
                    false,
                    ERROR
                );
                return false;
            };
        }

        $this->checkFilesExist($input);
        return $input;
    }",1
"	public function thumbImageCreate($file,$cacheFile,$maxSize,$ext){
		$command = $this->getConvert();
		if(!$command){
			echo ""ImageMagick "".LNG(""fileThumb.check.notFound"");
			return false;
		}
		$size  = $maxSize.'x'.$maxSize;
		$param = ""-auto-orient -alpha off -quality 90 -size "".$size;
		switch ($ext){
			case 'eps':
			case 'psb':
			case 'psd':
			case 'ps'://ps,ai,pdf; ==> window:缺少组件;mac:命令行可以执行，但php执行有问题
			case 'ai':$file.= '[0]';break;
			case 'pdf':$file.= '[0]';
				$param = ""-auto-orient -alpha remove -alpha off -quality 90 -size "".$size."" -background white"";
				break; // pdf 生成缩略图透明背景变为黑色问题处理;
			
			/**
			 * 生成doc/docx封面; or转图片;
			 * 
			 * mac: 使用liboffice=>soffice 关联convert的delegate;
			 * centos : unoconv (yum install unoconv); 
			 * 		转doc/docx/ppt/pptx/xls/xlsx/odt/odf为pdf; 再用convert提取某页为图片;
			 * 		实现office预览方案之一;(中文字体copy)
			 * 		unoconv -f pdf /data/from.docx /data/toxx.pdf;
			 * 		// https://github.com/ScoutsGidsenVL/Pydio/blob/master/plugins/editor.imagick/class.IMagickPreviewer.php
			 */
			case 'ppt':
			case 'pptx':
			case 'doc':
			case 'docx':$file.= '[0]';break;

			// https://legacy.imagemagick.org/Usage/thumbnails/
			case 'tif':$file.= '[0]';$param = "" -flatten "";break;
			case 'gif':$file.= '[0]';break;
			case 'webp':
			case 'png':
			case 'bmp':$param = ""-resize "".$size;break;
			case 'jpe':
			case 'jpg':
			case 'jpeg':
			case 'heic':$param = ""-auto-orient -resize "".$size;break;
			
			default:
				$dng = 'dng,cr2,erf,raf,kdc,dcr,mrw,nrw,nef,orf,pef,x3f,srf,arw,sr2';
				$dng = $dng.',3fr,crw,dcm,fff,iiq,mdc,mef,mos,plt,ppm,raw,rw2,srw,tst';
				if(in_array($ext,explode(',',$dng))){
					$param = ""-resize "".$size;
					//$file = 'rgb:'.$file.'[0]';
				}
				break;
		}

		//linux下$cacheFile不可写问题，先生成到/tmp下;再复制出来
		$tempPath = $cacheFile;
		if($GLOBALS['config']['systemOS'] == 'linux' && is_writable('/tmp/')){
			mk_dir('/tmp/fileThumb');
			if(is_writable('/tmp/fileThumb')){ // 可能有不可写的情况;
				$tempPath = '/tmp/fileThumb/'.rand_string(15).'.png';
			}
		}

		$script = $command.' '.$param.' '.escapeShell($file).' '.escapeShell($tempPath).' 2>&1';
		$out = shell_exec($script);
		if(!file_exists($tempPath)) return $this->log('image thumb error:'.$out.';cmd='.$script);
		move_path($tempPath,$cacheFile);
		return true;
	}",0
"    private function assertMissingField(array $result, string $fieldName)
    {
        $errors = $result['errors'] ?? [];
        foreach ($errors as $error) {
            if (preg_match('/^Cannot query field ""' . $fieldName . '""/', $error['message'] ?? '')) {
                return;
            }
        }

        $this->fail('Failed to assert that result was missing field ""' . $fieldName . '""');
    }",1
"function form_checkbox($name, $label, $selected, $value = 'checked', $html_id = null)
{
    if (is_null($html_id)) {
        $html_id = $name;
    }

    return '<div class=""form-check"">'
        . '<input class=""form-check-input"" type=""checkbox"" id=""' . $html_id . '"" name=""' . $name . '"" value=""' . htmlspecialchars((string) $value) . '"" '
        . ($selected ? ' checked=""checked""' : '') . ' /><label class=""form-check-label"" for=""' . $html_id . '"">'",1
"	public function parseBbCode($strComment)
	{
		$arrSearch = array
		(
			'@\[b\](.*)\[/b\]@Uis',
			'@\[i\](.*)\[/i\]@Uis',
			'@\[u\](.*)\[/u\]@Uis',
			'@\s*\[code\](.*)\[/code\]\s*@Uis',
			'@\[color=([^\]"" ]+)\](.*)\[/color\]@Uis',
			'@\s*\[quote\](.*)\[/quote\]\s*@Uis',
			'@\s*\[quote=([^\]]+)\](.*)\[/quote\]\s*@Uis',
			'@\[img\]\s*([^\["" ]+\.(jpe?g|png|gif|bmp|tiff?|ico))\s*\[/img\]@i',
			'@\[url\]\s*([^\["" ]+)\s*\[/url\]@i',
			'@\[url=([^\]"" ]+)\](.*)\[/url\]@Uis',
			'@\[email\]\s*([^\["" ]+)\s*\[/email\]@i',
			'@\[email=([^\]"" ]+)\](.*)\[/email\]@Uis',
			'@href=""(([a-z0-9]+\.)*[a-z0-9]+\.([a-z]{2}|asia|biz|com|info|name|net|org|tel)(/|""))@i'
		);

		$arrReplace = array
		(
			'<strong>$1</strong>',
			'<em>$1</em>',
			'<span style=""text-decoration:underline"">$1</span>',
			""\n\n"" . '<div class=""code""><p>' . $GLOBALS['TL_LANG']['MSC']['com_code'] . '</p><pre>$1</pre></div>' . ""\n\n"",
			'<span style=""color:$1"">$2</span>',
			""\n\n"" . '<blockquote>$1</blockquote>' . ""\n\n"",
			""\n\n"" . '<blockquote><p>' . sprintf($GLOBALS['TL_LANG']['MSC']['com_quote'], '$1') . '</p>$2</blockquote>' . ""\n\n"",
			'<img src=""$1"" alt="""" />',
			'<a href=""$1"">$1</a>',
			'<a href=""$1"">$2</a>',
			'<a href=""mailto:$1"">$1</a>',
			'<a href=""mailto:$1"">$2</a>',
			'href=""http://$1'
		);

		$strComment = preg_replace($arrSearch, $arrReplace, $strComment);

		// Encode e-mail addresses
		if (str_contains($strComment, 'mailto:'))
		{
			$strComment = StringUtil::encodeEmail($strComment);
		}

		return $strComment;
	}",1
"    public function bitwise_xor(PHP32 $x)
    {
        return $this->bitwiseXorHelper($x);
    }",0
"	public function contain_preserve_esi( $content ) {
		$hit_list = array();
		foreach ( $this->_esi_preserve_list as $k => $v ) {
			if ( strpos( $content, '""' . $k . '""' ) !== false ) {
				$hit_list[] = '""' . $k . '""';
			}
			if ( strpos( $content, ""'"" . $k . ""'"" ) !== false ) {
				$hit_list[] = ""'"" . $k . ""'"";
			}
		}
		return $hit_list;
	}",1
"                $options = ['name'        => '_itil_' . $_POST[""actortype""] . '[users_id]',
                    'entity'      => $_POST['entity_restrict'],",1
"    public function getIMEIState()
    {
        return $this->getKey('IMEIState');
    }",0
"function alert(NotificationType $type, $msg, $immediately = false)
{
    if (empty($msg)) {
        return '';
    }

    if ($immediately) {
        $type = str_replace(
            [
                NotificationType::ERROR->value,
                NotificationType::WARNING->value,
                NotificationType::INFORMATION->value,
                NotificationType::MESSAGE->value,
            ],
            ['danger', 'warning', 'info', 'success'],
            $type->value
        );
        return '<div class=""alert alert-' . $type . '"" role=""alert"">' . $msg . '</div>';
    }

    $type = 'messages.' . $type->value;
    $session = session();
    $messages = $session->get($type, []);
    $messages[] = $msg;
    $session->set($type, $messages);

    return '';
}",1
"    public function remove(string $key)
    {
        $uniqueKey = strtr($key, self::UPPER, self::LOWER);
        unset($this->headerNames[$uniqueKey]);

        if ('set-cookie' === $uniqueKey) {
            $this->cookies = [];

            return;
        }

        parent::remove($key);

        if ('cache-control' === $uniqueKey) {
            $this->computedCacheControl = [];
        }

        if ('date' === $uniqueKey) {
            $this->initDate();
        }
    }",0
"    private function assertFailure(array $result)
    {
        $errors = $result['errors'] ?? [];
        if (empty($errors)) {
            $this->fail('Failed to assert that query was not successful');
        }
    }",1
"    public function multiplyAddPoints(array $points, array $scalars)
    {
        $p1 = $this->convertToInternal($points[0]);
        $p2 = $this->convertToInternal($points[1]);
        $p1 = $this->multiplyPoint($p1, $scalars[0]);
        $p2 = $this->multiplyPoint($p2, $scalars[1]);
        $r = $this->addPoint($p1, $p2);
        return $this->convertToAffine($r);
    }",0
"	public function sub_comment_form_block( $post_id ) {
		echo GUI::clean_wrapper_end();
		$params = array(
			self::PARAM_ID => $post_id,
			self::PARAM_ARGS => $this->esi_args,
		);

		echo $this->sub_esi_block( 'comment-form', 'comment form', $params );
		echo GUI::clean_wrapper_begin();
		add_action( 'comment_form_after', array( $this, 'comment_form_sub_clean' ) );
	}",1
"    protected function normalize(PHP $result)
    {
        $result->precision = $this->precision;
        $result->bitmask = $this->bitmask;

        $value = &$result->value;

        if (!count($value)) {
            $result->is_negative = false;
            return $result;
        }

        $value = static::trim($value);

        if (!empty($result->bitmask->value)) {
            $length = min(count($value), count($result->bitmask->value));
            $value = array_slice($value, 0, $length);

            for ($i = 0; $i < $length; ++$i) {
                $value[$i] = $value[$i] & $result->bitmask->value[$i];
            }

            $value = static::trim($value);
        }

        return $result;
    }",0
"    public function getServerMaxWindowBits()
    {
        return $this->server_max_window_bits;
    }",0
"    public function __unset($name) {
        unset($this->wrappedConn->$name);
    }",0
"            new Behavior\Handler\ClosureHandler(
                static function (NodeInterface $node, ?DOMNode $domNode) {
                    return $domNode !== null ? new DOMText(trim($domNode->nodeValue)) : null;
                }",1
"                        unset($tokens[$tokenK]);
                    }

                    require $fileLang;
                    if (isset($lang)) {
                        $arrPhpFiles[$fileLang] = $lang;
                        unset($lang);
                    }
                }
                if ($ext == 'js') {
                    $jsTrans = file_get_contents($fileLang);
                    preg_match_all('/(.+?)""(.+?)""/', $jsTrans, $PMA);
                    $arrJsFiles[$fileLang] = $PMA;
                    unset($PMA);
                }
            }",0
"            $route->addRequirements($requirements);
        }
    }",0
"    public function __construct(string $id)
    {
        $this->id = $id;
    }",0
"function se_start_user_session($ud) {
	
	/* reset session id */
	session_regenerate_id(true);

	$_SESSION['user_id'] = $ud['user_id'];
	$_SESSION['user_nick'] = $ud['user_nick'];
	$_SESSION['user_mail'] = $ud['user_mail'];
	$_SESSION['user_class'] = $ud['user_class'];
	$_SESSION['user_psw'] = $ud['user_psw'];
	$_SESSION['user_firstname'] = $ud['user_firstname'];
	$_SESSION['user_lastname'] = $ud['user_lastname'];
	$_SESSION['user_hash'] = md5($ud['user_nick']);
	
	/* CSRF Protection */
    if(empty($_SESSION['token'])) {
        $token = md5(uniqid(rand(), TRUE));
        $_SESSION['token'] = $token;
        $_SESSION['token_time'] = time();
    }
	
	$arr_drm = explode(""|"", $ud['user_drm']);
	
	if($arr_drm[0] == ""drm_acp_pages"")	{  $_SESSION['acp_pages'] = ""allowed"";  }
	if($arr_drm[1] == ""drm_acp_files"")	{  $_SESSION['acp_files'] = ""allowed"";  }
	if($arr_drm[2] == ""drm_acp_user"")	{  $_SESSION['acp_user'] = ""allowed"";  }
	if($arr_drm[3] == ""drm_acp_system"")	{  $_SESSION['acp_system'] = ""allowed"";  }
	if($arr_drm[4] == ""drm_acp_editpages"")	{  $_SESSION['acp_editpages'] = ""allowed"";  }
	if($arr_drm[5] == ""drm_acp_editownpages"")	{  $_SESSION['acp_editownpages'] = ""allowed"";  }
	if($arr_drm[6] == ""drm_moderator"")	{  $_SESSION['drm_moderator'] = ""allowed"";  }
	if($arr_drm[7] == ""drm_can_publish"")	{  $_SESSION['drm_can_publish'] = ""true"";  }
	if($arr_drm[8] == ""drm_acp_sensitive_files"")	{  $_SESSION['drm_acp_sensitive_files'] = ""allowed"";  }
	
}",0
"    public function run(Process $process)
    {
        $this->init();
        $this->startLegacyApp();

        /* @noinspection PhpIncludeInspection */
        require_once 'include/portability/Services/ACL/UserACLService.php';

        $options = $process->getOptions();
        [
            'module' => $module,
            'payload' => $payload
        ] = $options;

        $routeAction = $payload['routeAction'] ?? 'index';
        $routeRecord = $payload['record'] ?? '';
        $queryParams = $payload['queryParams'];

        $context = [
            'record' => $routeRecord
        ];

        $actionKey = $routeAction;

        $resolvedLegacyModule = $this->getResolvedLegacyModule($module, $actionKey, $queryParams);
        if (!empty($resolvedLegacyModule)) {
            $actionKey = $module;
            $module = $resolvedLegacyModule;
        }

        $legacyModuleName = $this->moduleNameMapper->toLegacy($module);
        $frontEndModuleName = $this->moduleNameMapper->toFrontEnd($module);

        $hasAccess = false;
        if ($this->moduleNameMapper->isValidModule($legacyModuleName)
            && ($this->baseActionDefinitionProvider->isActionAccessible($frontEndModuleName, $actionKey, $context))
        ) {
            $hasAccess = true;
        }

        global $current_user;
        $isAdmin = is_admin($current_user);
        $isActionAdminOnly = $this->isAdminOnlyAction($frontEndModuleName, $legacyModuleName, $actionKey, $queryParams);

        if ($isActionAdminOnly && !$isAdmin) {
            $hasAccess = false;
        }

        $service = new UserACLService();
        $result = $service->run($legacyModuleName, $payload['routeURL'], $hasAccess);

        $process->setStatus('success');

        if ($result['status'] !== true) {
            $process->setStatus('error');
        }

        if (!empty($result['message'])) {
            $process->setMessages([
                $result['message']
            ]);
        }

        $this->close();

        $process->setData(['result' => $result['status']]);
    }",0
"    public static function savePublicKey(BaseCurve $curve, array $publicKey)
    {
        $public = explode(' ', OpenSSH::savePublicKey($curve, $publicKey));
        $type = $public[0];
        $public = Strings::base64_decode($public[1]);
        list(, $length) = unpack('N', Strings::shift($public, 4));
        Strings::shift($public, $length);

        return self::wrapPublicKey($public, $type);
    }",0
"                $item['controller_title'] = string_lang($item['target_controller'].'_CONTROLLER');

                $item['subject_title'] = $item['controller_title'];

                if($subj_controller !== null){

                    $ctype = $subj_controller->getContentTypeForModeration($item['target_subject']);

                    $item['subject_title'] = $ctype['title'];

                }

                return $item;

            });

            $this->cms_template->renderGridRowsJSON($grid, $data, $total, $pages);

            $this->halt();

        }

        if($additional_h1){
            $this->cms_template->setPageH1($additional_h1);
        }

        $this->model->resetFilters();

		return $this->cms_template->render('backend/logs', array(
            'grid'      => $grid,
            'sub_url'   => $sub_url,
            'url_query' => $url_query,
            'url'       => $url.($sub_url ? '/'.implode('/', $sub_url) : '').(($action > -1) ? '?'.http_build_query($url_query) : '')
        ));",1
"function ShiftEntry_delete_view_admin(Shift $shift, AngelType $angeltype, User $signoff_user)
{
    return page_with_title(ShiftEntry_delete_title(), [
        info(sprintf(
            __('Do you want to sign off %s from shift %s from %s to %s as %s?'),
            User_Nick_render($signoff_user),
            $shift->shiftType->name,
            $shift->start->format(__('Y-m-d H:i')),
            $shift->end->format(__('Y-m-d H:i')),
            $angeltype->name
        ), true),
        form([
            buttons([
                button(user_link($signoff_user->id), icon('x-lg') . __('cancel')),
                form_submit('delete', icon('trash') . __('sign off'), 'btn-danger', false),
            ]),
        ]),
    ]);
}",1
"                        $binary .= \pack('n*', $opt, \strlen((string) $value)) . $value;
                    }
                    break;
                default:
                    // RDATA is already stored as binary value for unknown record types
                    $binary = $record->data;
            }",0
"    protected static function reduce(array $x, array $n, $class)
    {
        static $cache = [
            self::VARIABLE => [],
            self::DATA => []
        ];

        if (($key = array_search($n, $cache[self::VARIABLE])) === false) {
            $key = count($cache[self::VARIABLE]);
            $cache[self::VARIABLE][] = $x;
            $cache[self::DATA][] = self::modInverse67108864($n, $class);
        }

        $k = count($n);

        $result = [self::VALUE => $x];

        for ($i = 0; $i < $k; ++$i) {
            $temp = $result[self::VALUE][$i] * $cache[self::DATA][$key];
            $temp = $temp - $class::BASE_FULL * ($class::BASE === 26 ? intval($temp / 0x4000000) : ($temp >> 31));
            $temp = $class::regularMultiply([$temp], $n);
            $temp = array_merge(self::array_repeat(0, $i), $temp);
            $result = $class::addHelper($result[self::VALUE], false, $temp, false);
        }

        $result[self::VALUE] = array_slice($result[self::VALUE], $k);

        if (self::compareHelper($result, false, $n, false) >= 0) {
            $result = $class::subtractHelper($result[self::VALUE], false, $n, false);
        }

        return $result[self::VALUE];
    }",0
"    private function testForIntermediate($caonly, $count)
    {
        $opts = $this->getExtension('id-pe-authorityInfoAccess');
        if (!is_array($opts)) {
            return false;
        }
        foreach ($opts as $opt) {
            if ($opt['accessMethod'] == 'id-ad-caIssuers') {
                // accessLocation is a GeneralName. GeneralName fields support stuff like email addresses, IP addresses, LDAP,
                // etc, but we're only supporting URI's. URI's and LDAP are the only thing https://tools.ietf.org/html/rfc4325
                // discusses
                if (isset($opt['accessLocation']['uniformResourceIdentifier'])) {
                    $url = $opt['accessLocation']['uniformResourceIdentifier'];
                    break;
                }
            }
        }

        if (!isset($url)) {
            return false;
        }

        $cert = static::fetchURL($url);
        if (!is_string($cert)) {
            return false;
        }

        $parent = new static();
        $parent->CAs = $this->CAs;
        /*
         ""Conforming applications that support HTTP or FTP for accessing
          certificates MUST be able to accept .cer files and SHOULD be able
          to accept .p7c files."" -- https://tools.ietf.org/html/rfc4325

         A .p7c file is 'a ""certs-only"" CMS message as specified in RFC 2797""

         These are currently unsupported
        */
        if (!is_array($parent->loadX509($cert))) {
            return false;
        }

        if (!$parent->validateSignatureCountable($caonly, ++$count)) {
            return false;
        }

        $this->CAs[] = $parent->currentCert;
        //$this->loadCA($cert);

        return true;
    }",0
"    public static function is_stringable($var)
    {
        return is_string($var) || (is_object($var) && method_exists($var, '__toString'));
    }",0
"	protected function readPassword()
	{
		return F::read($this->root() . '/.htpasswd');
	}",1
"            . (in_array($i['id'], $selected) ? ' checked=""checked""' : '')
            . '><label class=""form-check-label"" for=""' . $id . '"">' . $i['name'] . '</label>'
            . (!isset($i['enabled']) || $i['enabled'] ? '' : icon('mortarboard-fill'))",1
"	public function getCellHeight($fontsize, $padding=TRUE) {
		$height = ($fontsize * $this->cell_height_ratio);
		if ($padding) {
			$height += ($this->cell_padding['T'] + $this->cell_padding['B']);
		}
		return round($height, 6);
	}",1
"    public function testOnSubscribeCreatesTopicObject() {
        $this->mock->expects($this->once())->method('onSubscribe')->with(
            $this->conn, $this->isInstanceOf('Ratchet\Wamp\Topic')
        );

        $this->mngr->onSubscribe($this->conn, 'new topic');
    }",0
"    public static function setRecurringModuloFunction($instanceID, callable $function)
    {
        static::$reduce[$instanceID] = $function;
        if (!isset(static::$zero[static::class])) {
            static::$zero[static::class] = new BigInteger();
        }
    }",0
"    public function processSite($format = null, array $vars = [])
    {
        try {
            $grav = $this->grav;

            // set the page now its been processed
            $grav->fireEvent('onTwigSiteVariables');

            /** @var Pages $pages */
            $pages = $grav['pages'];

            /** @var PageInterface $page */
            $page = $grav['page'];

            $twig_vars = $this->twig_vars;
            $twig_vars['theme'] = $grav['config']->get('theme');
            $twig_vars['pages'] = $pages->root();
            $twig_vars['page'] = $page;
            $twig_vars['header'] = $page->header();
            $twig_vars['media'] = $page->media();
            $twig_vars['content'] = $page->content();

            // determine if params are set, if so disable twig cache
            $params = $grav['uri']->params(null, true);
            if (!empty($params)) {
                $this->twig->setCache(false);
            }

            // Get Twig template layout
            $template = $this->getPageTwigTemplate($page, $format);
            $page->templateFormat($format);

            $output = $this->twig->render($template, $vars + $twig_vars);
        } catch (LoaderError $e) {
            throw new RuntimeException($e->getMessage(), 400, $e);
        } catch (RuntimeError $e) {
            $prev = $e->getPrevious();
            if ($prev instanceof TwigException) {
                $code = $prev->getCode() ?: 500;
                // Fire onPageNotFound event.
                $event = new Event([
                    'page' => $page,
                    'code' => $code,
                    'message' => $prev->getMessage(),
                    'exception' => $prev,
                    'route' => $grav['route'],
                    'request' => $grav['request']
                ]);
                $event = $grav->fireEvent(""onDisplayErrorPage.{$code}"", $event);
                $newPage = $event['page'];
                if ($newPage && $newPage !== $page) {
                    unset($grav['page']);
                    $grav['page'] = $newPage;

                    return $this->processSite($newPage->templateFormat(), $vars);
                }
            }

            throw $e;
        }

        return $output;
    }",1
"            foreach ($hooks as $event_name) {

                $hook_class_name = 'on' . string_to_camel('_', $controller_name) . string_to_camel('_', $event_name);

                $hook_object = new $hook_class_name($controller_object);

                // Некоторые хуки не требуют регистрации в базе данных,
                // Например, хуки для CRON или иные, которые вызываются напрямую
                // Свойство $disallow_event_db_register в классе хука регулирует это поведение
                if(empty($hook_object->disallow_event_db_register)){

                    $events[$controller_name][$index] = $event_name;

                    $index++;
                }
            }",1
"    public function getExtension($id, array $cert = null, $path = null)
    {
        return $this->getExtensionHelper($id, $cert, $path);
    }",0
"    private function fetchRestrictCheckbox($can_user_restrict_permissions_to_nobody, $disabled, $is_expecting_input)
    {
        $empty_value_class = '';
        if ($is_expecting_input) {
            $empty_value_class = 'empty_value';
        }

        $html = '<p class=""tracker_field_permissionsonartifact ' . $empty_value_class . '"">';
        if ($this->isRequired() == false) {
            if (! $disabled) {
                $html .= '<input type=""hidden"" name=""artifact[' . $this->getId() . '][use_artifact_permissions]"" value=""0"" />';
            }
            $html .= '<label class=""checkbox"" for=""artifact_' . $this->getId() . '_use_artifact_permissions"">';
            $html .= '<input type=""checkbox""
                        name=""artifact[' . $this->getId() . '][use_artifact_permissions]""
                        id=""artifact_' . $this->getId() . '_use_artifact_permissions""
                        value=""1"" ' .
                (($can_user_restrict_permissions_to_nobody == true) ? 'checked=""checked""' : '') .
                (($disabled == true) ? 'disabled=""disabled""' : '') .",1
"	public function checkAccessToken(){
		$model  = $this->loadModel('Plugin');
		$config = $model->getConfig('fileView');
		if(!$config['apiKey']){
			return;
		}
		$timeTo = isset($this->in['timeTo'])?intval($this->in['timeTo']):'';
		$token = md5($config['apiKey'].$this->in['path'].$timeTo);
		
		//show_tips(array($config['apiKey'],$token,$this->in));
		if($token != $this->in['token']){
			show_tips('token 错误!');
		}
		if($timeTo != '' && $timeTo <= time()){
			show_tips('token已失效!');
		}
	}",1
"    public function __construct(
        $queue = false,
        $members = false,
        $rules = false,
        $parameters = false
    ) {
        parent::__construct('QueueReload');
        if ($queue !== false) {
            $this->setKey('Queue', $queue);
        }
        $this->setKey('Members', $members ? 'yes' : 'no');
        $this->setKey('Rules', $rules ? 'yes' : 'no');
        $this->setKey('Parameters', $parameters ? 'yes' : 'no');
    }",0
"    public function testConfiguration()
    {
        $sut = new HtmlRenderer(
            $this->createMock(Environment::class),
            new EventDispatcher(),
            $this->createMock(ProjectStatisticService::class),
            $this->createMock(ActivityStatisticService::class)
        );

        $this->assertEquals('print', $sut->getId());
    }",1
"    public function setReduction(\Closure $func)
    {
        $this->reduce = $func->bindTo($this, $this);
    }",0
"	function checkPassword($user_login, $user_password) {
		global $fmdb, $__FM_CONFIG, $fm_name;
		
		if (empty($user_login) || empty($user_password)) return false;
		
		/** Built-in authentication */
		$fm_db_version = getOption('fm_db_version');
		$auth_method = ($fm_db_version >= 18) ? getOption('auth_method') : true;
		if ($auth_method) {
			/** Use Builtin Auth when Default Auth Method is LDAP but user is defined with 'facileManager/Builtin' */
			$result = $fmdb->query(""SELECT * FROM `fm_users` WHERE `user_login` = '$user_login' and `user_auth_type`=1 and `user_status`='active'"");
			if (isset($fmdb->last_result) && is_array($fmdb->last_result) && $fmdb->last_result[0]->user_login == $user_login) {
				$auth_method = 1;
			}

			/** Builtin Authentication */
			if ($auth_method == 1) {
				if ($fm_db_version >= 18) {
					$result = $fmdb->get_results(""SELECT * FROM `fm_users` WHERE `user_status`='active' AND `user_auth_type`=1 AND `user_template_only`='no' AND `user_login`='$user_login'"");
				} else {
					/** Old auth */
					$result = $fmdb->get_results(""SELECT * FROM `fm_users` WHERE `user_status`='active' AND `user_login`='$user_login' AND `user_password`='$user_password'"");
				}
				if (!$fmdb->num_rows) {
					return false;
				} else {
					$user = $fmdb->last_result[0];
					
					/** Check password */
					if ($user->user_password[0] == '*') {
						/** Old MySQL hashing that needs to change */
						if ($user->user_password != '*' . strtoupper(sha1(sha1($user_password, true)))) {
							return false;
						}
						resetPassword($user_login, $user_password);
					} else {
						/** PHP hashing */
						if (!password_verify($user_password, $user->user_password)) {
							return false;
						}
					}
					
					/** Enforce password change? */
					if ($fm_db_version >= 15) {
						if ($user->user_force_pwd_change == 'yes') {
							$pwd_reset_query = ""SELECT * FROM `fm_pwd_resets` WHERE `pwd_login`={$user->user_id} ORDER BY `pwd_timestamp` LIMIT 1"";
							$fmdb->get_results($pwd_reset_query);
							if ($fmdb->num_rows) {
								$reset = $fmdb->last_result[0];
								return array($reset->pwd_id, $user_login);
							}
						}
					}
			
					$this->setSession($user);

					return true;
				}
			/** LDAP Authentication */
			} else {
				return $this->doLDAPAuth($user_login, $_POST['password']);
			}
		}
		
		return false;
	}",0
"        $ugroup_with_restricted->shouldReceive('removeUser')->with(
            $restricted_user_in_ugroup_only,
            \Mockery::on(
                function (PFUser $user) {
                    return (int) $user->getId() === 0;
                }",1
"        foreach ($headers as $header => $value) {
            // Numeric array keys are converted to int by PHP.
            $header = (string) $header;

            $this->assertHeader($header);
            $value = $this->normalizeHeaderValue($value);
            $normalized = strtolower($header);
            if (isset($this->headerNames[$normalized])) {
                $header = $this->headerNames[$normalized];
                $this->headers[$header] = array_merge($this->headers[$header], $value);
            } else {
                $this->headerNames[$normalized] = $header;
                $this->headers[$header] = $value;
            }
        }",0
        $this->onControl = $onControl ?: function() {};,0
"	protected function fixTags($tags) {
		// move @ tags out of variable namespace
		foreach ($tags as &$tag) {
			if ($tag{0} == $this->lessc->vPrefix)
				$tag[0] = $this->lessc->mPrefix;
		}
		return $tags;
	}",1
"            return isset($crumbs['cookies'][$sessionName]) ? $crumbs['cookies'][$sessionName] : false;
        }, false);

        if (null === $request || false === $id) {
            $saveHandler = $this->_null;
            $id = '';
        } else {
            $saveHandler = $this->_handler;
        }

        $conn->Session = new Session(new VirtualSessionStorage($saveHandler, $id, $this->_serializer));

        if (ini_get('session.auto_start')) {
            $conn->Session->start();
        }

        return $this->_app->onOpen($conn, $request);
    }",0
"    public function __construct(SessionBackendInterface $sessionBackend, int $sessionLifetime, IpLocker $ipLocker)
    {
        $this->sessionBackend = $sessionBackend;
        $this->sessionLifetime = $sessionLifetime;
        $this->ipLocker = $ipLocker;
    }",1
"    public static function load($key, $password = '')
    {
        $parsed = parent::load($key, $password);

        if (isset($parsed['paddedKey'])) {
            $paddedKey = $parsed['paddedKey'];
            list($type) = Strings::unpackSSH2('s', $paddedKey);
            if ($type != $parsed['type']) {
                throw new \RuntimeException(""The public and private keys are not of the same type ($type vs $parsed[type])"");
            }
            if ($type == 'ssh-ed25519') {
                list(, $key, $comment) = Strings::unpackSSH2('sss', $paddedKey);
                $key = libsodium::load($key);
                $key['comment'] = $comment;
                return $key;
            }
            list($curveName, $publicKey, $privateKey, $comment) = Strings::unpackSSH2('ssis', $paddedKey);
            $curve = self::loadCurveByParam(['namedCurve' => $curveName]);
            $curve->rangeCheck($privateKey);
            return [
                'curve' => $curve,
                'dA' => $privateKey,
                'QA' => self::extractPoint(""\0$publicKey"", $curve),
                'comment' => $comment
            ];
        }

        if ($parsed['type'] == 'ssh-ed25519') {
            if (Strings::shift($parsed['publicKey'], 4) != ""\0\0\0\x20"") {
                throw new \RuntimeException('Length of ssh-ed25519 key should be 32');
            }

            $curve = new Ed25519();
            $qa = self::extractPoint($parsed['publicKey'], $curve);
        } else {
            list($curveName, $publicKey) = Strings::unpackSSH2('ss', $parsed['publicKey']);
            $curveName = '\phpseclib3\Crypt\EC\Curves\\' . $curveName;
            $curve = new $curveName();

            $qa = self::extractPoint(""\0"" . $publicKey, $curve);
        }

        return [
            'curve' => $curve,
            'QA' => $qa,
            'comment' => $parsed['comment']
        ];
    }",0
"    public function testCall() {
        $args     = func_get_args();
        $paramNum = array_shift($args);

        $uri = 'http://example.com/endpoint/' . rand(1, 100);
        $id  = uniqid('', false);
        $clientMessage = array_merge(array(2, $id, $uri), $args);

        $conn = $this->newConn();

        $this->_comp->onOpen($conn);
        $this->_comp->onMessage($conn, json_encode($clientMessage));

        $this->assertEquals($id,  $this->_app->last['onCall'][1]);
        $this->assertEquals($uri, $this->_app->last['onCall'][2]);

        $this->assertEquals($paramNum, count($this->_app->last['onCall'][3]));
    }",0
"                    $el->setAttribute($attr, $forced);
                }

                // Matches ""javascript:"" with any arbitrary linebreaks inbetween the characters.
                $regex = '/^\s*' . implode('\s*', str_split('javascript:')) . '/i';
                // Strip out javascript execution in href or src attributes.
                foreach (['src', 'href', 'data'] as $dangerAttribute) {
                    if ($el->hasAttribute($dangerAttribute)) {
                        if (preg_match($regex, $el->getAttribute($dangerAttribute))) {
                            $el->removeAttribute($dangerAttribute);
                        }
                    }
                }
            }

            if ($el->tagName === 'a' && $linkRelValue !== null) {
                $this->addRelValue($el, $linkRelValue);
            }
        }
    }",1
"	public static function GetDashboardToEdit($sDashboardFile, $sDashBoardId)
	{
		$bCustomized = false;

		$sDashboardFileSanitized = utils::RealPath($sDashboardFile, APPROOT);
		if (false === $sDashboardFileSanitized) {
			throw new SecurityException('Invalid dashboard file !');
		}

		// Search for an eventual user defined dashboard
		$oUDSearch = new DBObjectSearch('UserDashboard');
		$oUDSearch->AddCondition('user_id', UserRights::GetUserId(), '=');
		$oUDSearch->AddCondition('menu_code', $sDashBoardId, '=');
		$oUDSet = new DBObjectSet($oUDSearch);
		if ($oUDSet->Count() > 0) {
			// Assuming there is at most one couple {user, menu}!
			$oUserDashboard = $oUDSet->Fetch();
			$sDashboardDefinition = $oUserDashboard->Get('contents');
			$bCustomized = true;
		} else {
			$sDashboardDefinition = @file_get_contents($sDashboardFileSanitized);
		}


		if ($sDashboardDefinition !== false) {
			$oDashboard = new RuntimeDashboard($sDashBoardId);
			$oDashboard->FromXml($sDashboardDefinition);
			$oDashboard->SetCustomFlag($bCustomized);
			$oDashboard->SetDefinitionFile($sDashboardFileSanitized);
		} else {
			$oDashboard = null;
		}

		return $oDashboard;
	}",0
"    public static function versionSupportProvider() {
        return [
            ['7.0.17', false],
            ['7.0.18', true],
            ['7.0.200', true],
            ['5.6.0', false],
            ['7.1.3', false],
            ['7.1.4', true],
            ['7.1.200', true],
            ['10.0.0', true]
        ];
    }",0
"	public function execute( $par ) {
		if ( !EntryPointUtils::currentWikiIsGlobalWiki() ) {
			return $this->getOutput()->addHTML(
				Html::errorBox( $this->msg( 'createwiki-wikinotglobalwiki' )->escaped() )
			);
		}

		$this->setHeaders();

		if ( $par === null || $par === '' ) {
			$this->doPagerStuff();
		} else {
			$this->getOutput()->addBacklinkSubtitle( $this->getPageTitle() );

			$this->lookupRequest( $par );
		}
	}",0
"		function read_gps_location($file)
		{
			if (is_file($file)) {
				$exif = exif_read_data($file);
				if (
					isset($exif['GPSLatitude']) && isset($exif['GPSLongitude']) &&
					isset($exif['GPSLatitudeRef']) && isset($exif['GPSLongitudeRef']) &&
					in_array($exif['GPSLatitudeRef'], array('E', 'W', 'N', 'S')) && in_array($exif['GPSLongitudeRef'], array('E', 'W', 'N', 'S'))
				) {

					$GPSLatitudeRef	 = strtolower(trim($exif['GPSLatitudeRef']));
					$GPSLongitudeRef = strtolower(trim($exif['GPSLongitudeRef']));

					$lat_degrees_a = explode('/', $exif['GPSLatitude'][0]);
					$lat_minutes_a = explode('/', $exif['GPSLatitude'][1]);
					$lat_seconds_a = explode('/', $exif['GPSLatitude'][2]);
					$lon_degrees_a = explode('/', $exif['GPSLongitude'][0]);
					$lon_minutes_a = explode('/', $exif['GPSLongitude'][1]);
					$lon_seconds_a = explode('/', $exif['GPSLongitude'][2]);

					$lat_degrees = $lat_degrees_a[0] / $lat_degrees_a[1];
					$lat_minutes = $lat_minutes_a[0] / $lat_minutes_a[1];
					$lat_seconds = $lat_seconds_a[0] / $lat_seconds_a[1];
					$lon_degrees = $lon_degrees_a[0] / $lon_degrees_a[1];
					$lon_minutes = $lon_minutes_a[0] / $lon_minutes_a[1];
					$lon_seconds = $lon_seconds_a[0] / $lon_seconds_a[1];

					$lat = (float) $lat_degrees + ((($lat_minutes * 60) + ($lat_seconds)) / 3600);
					$lon = (float) $lon_degrees + ((($lon_minutes * 60) + ($lon_seconds)) / 3600);

					// If the latitude is South, make it negative
					// If the longitude is west, make it negative
					$GPSLatitudeRef	 == 's' ? $lat *= -1 : '';
					$GPSLongitudeRef == 'w' ? $lon *= -1 : '';

					return array(
						'lat' => htmlentities($lat),
						'lon' => htmlentities($lon)
					);
				}
			}
			return false;
		}",0
"    private function getFileName($path, $file_ext, $file_name = false) {

        if(!$file_name){
            if($this->file_name){
                $file_name = str_replace('.'.$file_ext, '', files_sanitize_name($this->file_name.'.'.$file_ext));
            } else {
                $file_name = substr(md5(microtime(true)), 0, 8);
            }
        }

        if (file_exists($path.$file_name.'.'.$file_ext)) {
            return $this->getFileName($path, $file_ext, $file_name.'_'.md5(microtime(true)));
        }

        return $file_name.'.'.$file_ext;

    }",1
"    private function uploadPackage(){

        $this->cms_uploader->enableRemoteUpload();

        if (!$this->cms_uploader->isUploaded($this->upload_name) && !$this->cms_uploader->isUploadedFromLink($this->upload_name)){

            $last_error = $this->cms_uploader->getLastError();
            if($last_error){
                cmsUser::addSessionMessage($last_error, 'error');
            }

            return false;

        }

        files_clear_directory(cmsConfig::get('upload_path') . $this->installer_upload_path);

        $result = $this->cms_uploader->upload($this->upload_name, $this->upload_exts, 0, $this->installer_upload_path);

        if (!$result['success']){
            cmsUser::addSessionMessage($result['error'], 'error');
            return false;
        }

        return $result['name'];

    }",1
"        } elseif ($encoding === PHP_QUERY_RFC1738) {
            $encoder = 'urlencode';
        } else {",0
"	public function testUserSession2()
	{
		$session = (new AutoSession($this->app->root('sessions')))->createManually();
		$session->set('kirby.userId', 'homer');

		$user = $this->auth->user($session);
		$this->assertSame('homer@simpsons.com', $user->email());
		$this->assertSame([
			'challenge' => null,
			'email'     => 'homer@simpsons.com',
			'status'    => 'active'
		], $this->auth->status()->toArray());
	}",1
"    public function add($listener)
    {
        $this->queue->enqueue($listener);
    }",0
"function clean_xss($str, $cleanImg = true)
{
    global $sugar_config;

    if (empty($sugar_config['email_xss'])) {
        $sugar_config['email_xss'] = getDefaultXssTags();
    }

    $xsstags = unserialize(base64_decode($sugar_config['email_xss']));

    // cn: bug 13079 - ""on\w"" matched too many non-events (cONTact, strONG, etc.)
    $jsEvents = 'onblur|onfocus|oncontextmenu|onresize|onscroll|onunload|ondblclick|onclick|';
    $jsEvents .= 'onmouseup|onmouseover|onmousedown|onmouseenter|onmouseleave|onmousemove|onload|onchange|';
    $jsEvents .= 'onreset|onselect|onsubmit|onkeydown|onkeypress|onkeyup|onabort|onerror|ondragdrop';

    $attribute_regex = ""#\b({$jsEvents})\s*=\s*(?|(?!['\""])\S+|['\""].+?['\""])#sim"";
    $javascript_regex = '@<[^/>][^>]+(expression\(|j\W*a\W*v\W*a|v\W*b\W*s\W*c\W*r|&#|/\*|\*/)[^>]*>@sim';
    $imgsrc_regex = '#<[^>]+src[^=]*=([^>]*?http(s)?://[^>]*)>#sim';
    $css_url = '#url\(.*\.\w+\)#';

    $tagsrex = '#<\/?(\w+)((?:\s+(?:\w|\w[\w-]*\w)(?:\s*=\s*(?:\"".*?\""|\'.*?\'|[^\'\"">\s]+))?)+\s*|\s*)\/?>#im';

    $tagmatches = array();
    $matches = array();
    preg_match_all($tagsrex, (string) $str, $tagmatches, PREG_PATTERN_ORDER);
    foreach ($tagmatches[1] as $no => $tag) {
        if (in_array($tag, $xsstags)) {
            // dangerous tag - take out whole
            $matches[] = $tagmatches[0][$no];
            continue;
        }
        $attrmatch = array();
        preg_match_all($attribute_regex, $tagmatches[2][$no], $attrmatch, PREG_PATTERN_ORDER);
        if (!empty($attrmatch[0])) {
            $matches = array_merge($matches, $attrmatch[0]);
        }
    }

    $matches = array_merge($matches, xss_check_pattern($javascript_regex, $str));

    if ($cleanImg) {
        $matches = array_merge(
            $matches,
            xss_check_pattern($imgsrc_regex, $str)
        );
    }

    // cn: bug 13498 - custom white-list of allowed domains that vet remote images
    preg_match_all($css_url, (string) $str, $cssUrlMatches, PREG_PATTERN_ORDER);

    if (isset($sugar_config['security_trusted_domains']) && !empty($sugar_config['security_trusted_domains']) && is_array($sugar_config['security_trusted_domains'])) {
        if (is_array($cssUrlMatches) && count($cssUrlMatches) > 0) {
            // normalize whitelist
            foreach ($sugar_config['security_trusted_domains'] as $k => $v) {
                $sugar_config['security_trusted_domains'][$k] = strtolower($v);
            }

            foreach ($cssUrlMatches[0] as $match) {
                $domain = strtolower(substr(strstr($match, '://'), 3));
                $baseUrl = substr($domain, 0, strpos($domain, '/'));

                if (!in_array($baseUrl, $sugar_config['security_trusted_domains'])) {
                    $matches[] = $match;
                }
            }
        }
    } else {
        $matches = array_merge($matches, $cssUrlMatches[0]);
    }

    return $matches;
}

/**
 * Helper function used by clean_xss() to parse for known-bad vectors.
 *
 * @param string pattern Regex pattern to use
 * @param string str String to parse for badness
 *
 * @return array
 */
function xss_check_pattern($pattern, $str)
{
    preg_match_all($pattern, (string) $str, $matches, PREG_PATTERN_ORDER);

    return $matches[1];
}

/**
 * Designed to take a string passed in the URL as a parameter and clean all ""bad"" data from it.
 *
 * @param string $str
 * @param string $filter       which corresponds to a regular expression to use; choices are:
 *                             ""STANDARD"" ( default )
 *                             ""STANDARDSPACE""
 *                             ""FILE""
 *                             ""NUMBER""
 *                             ""SQL_COLUMN_LIST""
 *                             ""PATH_NO_URL""
 *                             ""SAFED_GET""
 *                             ""UNIFIED_SEARCH""
 *                             ""AUTO_INCREMENT""
 *                             ""ALPHANUM""
 * @param bool   $dieOnBadData true (default) if you want to die if bad data if found, false if not
 */
function clean_string($str, $filter = 'STANDARD', $dieOnBadData = true)
{
    global $sugar_config;

    $filters = array(
        'STANDARD' => '#[^A-Z0-9\-_\.\@]#i',
        'STANDARDSPACE' => '#[^A-Z0-9\-_\.\@\ ]#i',
        'FILE' => '#[^A-Z0-9\-_\.]#i',
        'NUMBER' => '#[^0-9\-]#i',
        'SQL_COLUMN_LIST' => '#[^A-Z0-9\(\),_\.]#i',
        'PATH_NO_URL' => '#://#i',
        'SAFED_GET' => '#[^A-Z0-9\@\=\&\?\.\/\-_~+]#i', /* range of allowed characters in a GET string */
        'UNIFIED_SEARCH' => '#[\\x00]#', /* cn: bug 3356 & 9236 - MBCS search strings */
        'AUTO_INCREMENT' => '#[^0-9\-,\ ]#i',
        'ALPHANUM' => '#[^A-Z0-9\-]#i',
    );

    if (preg_match($filters[$filter], $str)) {
        if (isset($GLOBALS['log']) && is_object($GLOBALS['log'])) {
            $GLOBALS['log']->fatal(""SECURITY[$filter]: bad data passed in; string: {$str}"");
        }
        if ($dieOnBadData) {
            die(""Bad data passed in; <a href=\""{$sugar_config['site_url']}\"">Return to Home</a>"");
        }

        return false;
    }
    return $str;
}

function clean_file_output($string, $mine_type)
{
    $patterns = [];

    if ($mine_type === 'image/svg+xml') {
        $patterns[] = ""/onload=\""window.location='(.*?)'\""/"";
    }

    $string = preg_replace($patterns, '', (string) $string);

    return $string;
}


function clean_special_arguments()
{
    if (isset($_SERVER['PHP_SELF'])) {
        if (!empty($_SERVER['PHP_SELF'])) {
            clean_string($_SERVER['PHP_SELF'], 'SAFED_GET');
        }
    }
    if (!empty($_REQUEST) && !empty($_REQUEST['login_theme'])) {
        clean_string($_REQUEST['login_theme'], 'STANDARD');
    }
    if (!empty($_REQUEST) && !empty($_REQUEST['login_module'])) {
        clean_string($_REQUEST['login_module'], 'STANDARD');
    }
    if (!empty($_REQUEST) && !empty($_REQUEST['login_action'])) {
        clean_string($_REQUEST['login_action'], 'STANDARD');
    }
    if (!empty($_REQUEST) && !empty($_REQUEST['ck_login_theme_20'])) {
        clean_string($_REQUEST['ck_login_theme_20'], 'STANDARD');
    }
    if (!empty($_SESSION) && !empty($_SESSION['authenticated_user_theme'])) {
        clean_string($_SESSION['authenticated_user_theme'], 'STANDARD');
    }
    if (!empty($_REQUEST) && !empty($_REQUEST['module_name'])) {
        clean_string($_REQUEST['module_name'], 'STANDARD');
    }
    if (!empty($_REQUEST) && !empty($_REQUEST['module'])) {
        clean_string($_REQUEST['module'], 'STANDARD');
    }
    if (!empty($_POST) && !empty($_POST['parent_type'])) {
        clean_string($_POST['parent_type'], 'STANDARD');
    }
    if (!empty($_REQUEST) && !empty($_REQUEST['mod_lang'])) {
        clean_string($_REQUEST['mod_lang'], 'STANDARD');
    }
    if (!empty($_SESSION) && !empty($_SESSION['authenticated_user_language'])) {
        clean_string($_SESSION['authenticated_user_language'], 'STANDARD');
    }
    if (!empty($_SESSION) && !empty($_SESSION['dyn_layout_file'])) {
        clean_string($_SESSION['dyn_layout_file'], 'PATH_NO_URL');
    }
    if (!empty($_GET) && !empty($_GET['from'])) {
        clean_string($_GET['from']);
    }
    if (!empty($_GET) && !empty($_GET['gmto'])) {
        clean_string($_GET['gmto'], 'NUMBER');
    }
    if (!empty($_GET) && !empty($_GET['case_number'])) {
        clean_string($_GET['case_number'], 'AUTO_INCREMENT');
    }
    if (!empty($_GET) && !empty($_GET['bug_number'])) {
        clean_string($_GET['bug_number'], 'AUTO_INCREMENT');
    }
    if (!empty($_GET) && !empty($_GET['quote_num'])) {
        clean_string($_GET['quote_num'], 'AUTO_INCREMENT');
    }
    clean_superglobals('stamp', 'ALPHANUM'); // for vcr controls
    clean_superglobals('offset', 'ALPHANUM');
    clean_superglobals('return_action');
    clean_superglobals('return_module');

    return true;
}

/**
 * cleans the given key in superglobals $_GET, $_POST, $_REQUEST.
 */
function clean_superglobals($key, $filter = 'STANDARD')
{
    if (isset($_GET[$key])) {
        clean_string($_GET[$key], $filter);
    }
    if (isset($_POST[$key])) {
        clean_string($_POST[$key], $filter);
    }
    if (isset($_REQUEST[$key])) {
        clean_string($_REQUEST[$key], $filter);
    }
}

function set_superglobals($key, $val)
{
    $_GET[$key] = $val;
    $_POST[$key] = $val;
    $_REQUEST[$key] = $val;
}

// Works in conjunction with clean_string() to defeat SQL injection, file inclusion attacks, and XSS
function clean_incoming_data()
{
    global $sugar_config;
    global $RAW_REQUEST;

    $RAW_REQUEST = $_REQUEST;

    $req = array_map('securexss', $_REQUEST);
    $post = array_map('securexss', $_POST);
    $get = array_map('securexss', $_GET);

    // PHP cannot stomp out superglobals reliably
    foreach ($post as $k => $v) {
        $_POST[$k] = $v;
    }
    foreach ($get as $k => $v) {
        $_GET[$k] = $v;
    }
    foreach ($req as $k => $v) {
        $_REQUEST[$k] = $v;

        //ensure the keys are safe as well.  If mbstring encoding translation is on, the post keys don't
        //get translated, so scrub the data but don't die
        if (ini_get('mbstring.encoding_translation') === '1') {
            securexsskey($k, false);
        } else {
            securexsskey($k, true);
        }
    }
    // Any additional variables that need to be cleaned should be added here
    if (isset($_REQUEST['login_theme'])) {
        clean_string($_REQUEST['login_theme']);
    }
    if (isset($_REQUEST['login_module'])) {
        clean_string($_REQUEST['login_module']);
    }
    if (isset($_REQUEST['login_action'])) {
        clean_string($_REQUEST['login_action']);
    }
    if (isset($_REQUEST['login_language'])) {
        clean_string($_REQUEST['login_language']);
    }
    if (isset($_REQUEST['action'])) {
        clean_string($_REQUEST['action']);
    }
    if (isset($_REQUEST['module'])) {
        clean_string($_REQUEST['module']);
    }
    if (isset($_REQUEST['record'])) {
        clean_string($_REQUEST['record'], 'STANDARDSPACE');
    }
    if (isset($_SESSION['authenticated_user_theme'])) {
        clean_string($_SESSION['authenticated_user_theme']);
    }
    if (isset($_SESSION['authenticated_user_language'])) {
        clean_string($_SESSION['authenticated_user_language']);
    }
    if (isset($_REQUEST['language'])) {
        clean_string($_REQUEST['language']);
    }
    if (isset($sugar_config['default_theme'])) {
        clean_string($sugar_config['default_theme']);
    }
    if (isset($_REQUEST['offset'])) {
        clean_string($_REQUEST['offset']);
    }
    if (isset($_REQUEST['stamp'])) {
        clean_string($_REQUEST['stamp']);
    }

    if (isset($_REQUEST['lvso'])) {
        set_superglobals('lvso', (strtolower($_REQUEST['lvso']) === 'desc') ? 'desc' : 'asc');
    }
    // Clean ""offset"" and ""order_by"" parameters in URL
    foreach ($_REQUEST as $key => $val) {
        if (str_end($key, '_offset')) {
            clean_string($_REQUEST[$key], 'ALPHANUM'); // keep this ALPHANUM for disable_count_query
            set_superglobals($key, $_REQUEST[$key]);
        } elseif (str_end($key, '_ORDER_BY')) {
            clean_string($_REQUEST[$key], 'SQL_COLUMN_LIST');
            set_superglobals($key, $_REQUEST[$key]);
        }
    }

    return 0;
}

// Returns TRUE if $str begins with $begin
function str_begin($str, $begin)
{
    return substr((string) $str, 0, strlen((string) $begin)) == $begin;
}

// Returns TRUE if $str ends with $end
function str_end($str, $end)
{
    return substr((string) $str, strlen((string) $str) - strlen((string) $end)) == $end;
}

/**
 * @param $uncleanString
 * @return array
 */
function securexss($uncleanString)
{
    if (is_array($uncleanString)) {
        $new = [];
        foreach ($uncleanString as $key => $val) {
            $new[$key] = securexss($val);
        }

        return $new;
    }

    static $xss_cleanup = [
        '&quot;' => '&#38;',
        '""' => '&quot;',
        ""'"" => '&#039;',
        '<' => '&lt;',
        '>' => '&gt;',
        '`' => '&#96;'
    ];

    $uncleanString = preg_replace(array('/javascript:/i', '/\0/', '/javascript:/i'),
        array('java script:', '', 'java script:'), (string) $uncleanString);

    $partialString = str_replace(array_keys($xss_cleanup), $xss_cleanup, $uncleanString);

    $antiXss = new AntiXSS();
    $antiXss->removeEvilAttributes(['style']);

    return $antiXss->xss_clean($partialString);
}

function securexsskey($value, $die = true)
{
    global $sugar_config;
    $matches = array();
    preg_match('/[\'""<>]/', (string) $value, $matches);
    if (!empty($matches)) {
        if ($die) {
            die(""Bad data passed in; <a href=\""{$sugar_config['site_url']}\"">Return to Home</a>"");
        }
        unset($_REQUEST[$value]);
        unset($_POST[$value]);
        unset($_GET[$value]);
    }
}

/**
 * @param string|null $value
 * @return string
 */
function purify_html(?string $value): string {

    if (($value ?? '') === '') {
        return '';
    }

    $cleanedValue = htmlentities((string) SugarCleaner::cleanHtml($value, true));
    $decoded = html_entity_decode($cleanedValue);
    $doubleDecoded = html_entity_decode($decoded);

    if (stripos($decoded, '<script>') !== false || stripos($doubleDecoded, '<script>') !== false){
        $cleanedValue = '';
    }

    return $cleanedValue;
}

function preprocess_param($value)
{
    if (is_string($value)) {
        $value = securexss($value);
    } elseif (is_array($value)) {
        foreach ($value as $key => $element) {
            $value[$key] = preprocess_param($element);
        }
    }

    return $value;
}

function cleanup_slashes($value)
{
    if (is_string($value)) {
        return stripslashes($value);
    }

    return $value;
}

function set_register_value($category, $name, $value)
{
    return sugar_cache_put(""{$category}:{$name}"", $value);
}

function get_register_value($category, $name)
{
    return sugar_cache_retrieve(""{$category}:{$name}"");
}

function clear_register_value($category, $name)
{
    return sugar_cache_clear(""{$category}:{$name}"");
}

// this function cleans id's when being imported
function convert_id($string)
{
    $errorLevelStored = error_reporting();
    error_reporting(0);

    $function = function ($matches) {
        return ord($matches[0]);
    };

    if ($function === false) {
        LoggerManager::getLogger()->warn('Function not created');
    }

    error_reporting($errorLevelStored);

    return preg_replace_callback('|[^A-Za-z0-9\-]|', $function, (string) $string);
}

/**
 * @deprecated use SugarTheme::getImage()
 */
function get_image($image, $other_attributes, $width = '', $height = '', $ext = '.gif', $alt = '')
{
    return SugarThemeRegistry::current()->getImage(basename((string) $image), $other_attributes, empty($width) ? null : $width, empty($height) ? null : $height, $ext, $alt);
}

/**
 * @deprecated use SugarTheme::getImageURL()
 */
function getImagePath($image_name)
{
    return SugarThemeRegistry::current()->getImageURL($image_name);
}

function getWebPath($relative_path)
{
    $current_theme = SugarThemeRegistry::current();
    $theme_directory = $current_theme->dirName;
    if (strpos((string) $relative_path, ""themes"" . DIRECTORY_SEPARATOR . $theme_directory) === false) {
        $test_path = SUGAR_PATH . DIRECTORY_SEPARATOR . ""themes"" . DIRECTORY_SEPARATOR . $theme_directory . DIRECTORY_SEPARATOR . $relative_path;
        if (file_exists($test_path)) {
            $resource_name = ""themes"" . DIRECTORY_SEPARATOR . $theme_directory . DIRECTORY_SEPARATOR . $relative_path;
        }
    }
    //if it has  a :// then it isn't a relative path
    if (substr_count((string) $relative_path, '://') > 0) {
        return $relative_path;
    }
    if (defined('TEMPLATE_URL')) {
        $relative_path = SugarTemplateUtilities::getWebPath($relative_path);
    }

    return $relative_path;
}

function getVersionedPath($path, $additional_attrs = '')
{
    if (empty($GLOBALS['sugar_config']['js_custom_version'])) {
        $GLOBALS['sugar_config']['js_custom_version'] = 1;
    }
    $js_version_key = isset($GLOBALS['js_version_key']) ? $GLOBALS['js_version_key'] : '';
    if (inDeveloperMode()) {
        static $rand;
        if (empty($rand)) {
            $rand = mt_rand();
        }
        $dev = $rand;
    } else {
        $dev = '';
    }
    if (is_array($additional_attrs)) {
        $additional_attrs = implode('|', $additional_attrs);
    }
    // cutting 2 last chars here because since md5 is 32 chars, it's always ==
    $str = substr(base64_encode(md5(""$js_version_key|{$GLOBALS['sugar_config']['js_custom_version']}|$dev|$additional_attrs"", true)), 0, -2);
    // remove / - it confuses some parsers
    $str = strtr($str, '/+', '-_');
    if (empty($path)) {
        return $str;
    }

    return $path . ""?v=$str"";
}

function getVersionedScript($path, $additional_attrs = '')
{
    return '<script type=""text/javascript"" src=""' . getVersionedPath($path, $additional_attrs) . '""></script>';
}

function getJSPath($relative_path, $additional_attrs = '')
{
    if (defined('TEMPLATE_URL')) {
        $relative_path = SugarTemplateUtilities::getWebPath($relative_path);
    }

    return getVersionedPath($relative_path) . (!empty($additional_attrs) ? ""&$additional_attrs"" : '');
}

/**
 * @deprecated This function is unused and will be removed in a future release.
 */
function getSWFPath($relative_path, $additional_params = '')
{
    $path = $relative_path;
    if (!empty($additional_params)) {
        $path .= '?' . $additional_params;
    }
    if (defined('TEMPLATE_URL')) {
        $path = TEMPLATE_URL . '/' . $path;
    }

    return $path;
}

/**
 * @deprecated This function is unused and will be removed in a future release.
 */
function getSQLDate($date_str)
{
    if (preg_match('/^(\d{1,2})-(\d{1,2})-(\d{4})$/', (string) $date_str, $match)) {
        if (strlen($match[2]) == 1) {
            $match[2] = '0' . $match[2];
        }
        if (strlen($match[1]) == 1) {
            $match[1] = '0' . $match[1];
        }

        return ""{$match[3]}-{$match[1]}-{$match[2]}"";
    } elseif (preg_match('/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/', (string) $date_str, $match)) {
        if (strlen($match[2]) == 1) {
            $match[2] = '0' . $match[2];
        }
        if (strlen($match[1]) == 1) {
            $match[1] = '0' . $match[1];
        }

        return ""{$match[3]}-{$match[1]}-{$match[2]}"";
    }
    return '';
}

/**
 * @deprecated This function is unused and will be removed in a future release.
 */
function clone_history(&$db, $from_id, $to_id, $to_type)
{
    global $timedate;
    $old_note_id = null;
    $old_filename = null;
    require_once 'include/upload_file.php';
    $tables = array('calls' => 'Call', 'meetings' => 'Meeting', 'notes' => 'Note', 'tasks' => 'Task');

    $location = array('Email' => 'modules/Emails/Email.php',
        'Call' => 'modules/Calls/Call.php',
        'Meeting' => 'modules/Meetings/Meeting.php',
        'Note' => 'modules/Notes/Note.php',
        'Tasks' => 'modules/Tasks/Task.php',
    );

    foreach ($tables as $table => $bean_class) {
        if (!class_exists($bean_class)) {
            require_once $location[$bean_class];
        }

        $bProcessingNotes = false;
        if ($table == 'notes') {
            $bProcessingNotes = true;
        }
        $query = ""SELECT id FROM $table WHERE parent_id='$from_id'"";
        $results = $db->query($query);
        while ($row = $db->fetchByAssoc($results)) {
            //retrieve existing record.
            $bean = new $bean_class();
            $bean->retrieve($row['id']);
            //process for new instance.
            if ($bProcessingNotes) {
                $old_note_id = $row['id'];
                $old_filename = $bean->filename;
            }
            $bean->id = null;
            $bean->parent_id = $to_id;
            $bean->parent_type = $to_type;
            if ($to_type == 'Contacts' && in_array('contact_id', $bean->column_fields)) {
                $bean->contact_id = $to_id;
            }
            $bean->update_date_modified = false;
            $bean->update_modified_by = false;
            if (isset($bean->date_modified)) {
                $bean->date_modified = $timedate->to_db($bean->date_modified);
            }
            if (isset($bean->date_entered)) {
                $bean->date_entered = $timedate->to_db($bean->date_entered);
            }
            //save
            $new_id = $bean->save();

            //duplicate the file now. for notes.
            if ($bProcessingNotes && !empty($old_filename)) {
                UploadFile::duplicate_file($old_note_id, $new_id, $old_filename);
            }
            //reset the values needed for attachment duplication.
            $old_note_id = null;
            $old_filename = null;
        }
    }
}

/**
 * @deprecated This function is unused and will be removed in a future release.
 */
function values_to_keys($array)
{
    $new_array = array();
    if (!is_array($array)) {
        return $new_array;
    }
    foreach ($array as $arr) {
        $new_array[$arr] = $arr;
    }

    return $new_array;
}

/**
 * @param $db
 * @param array $tables
 * @param $from_column
 * @param $from_id
 * @param $to_id
 */
function clone_relationship(&$db, $tables, $from_column = null, $from_id = null, $to_id = null)
{
    foreach ((array) $tables as $table) {
        if ($table == 'emails_beans') {
            $query = ""SELECT * FROM $table WHERE $from_column='$from_id' and bean_module='Leads'"";
        } else {
            $query = ""SELECT * FROM $table WHERE $from_column='$from_id'"";
        }
        $results = $db->query($query);
        while ($row = $db->fetchByAssoc($results)) {
            $query = ""INSERT INTO $table "";
            $names = '';
            $values = '';
            $row[$from_column] = $to_id;
            $row['id'] = create_guid();
            if ($table == 'emails_beans') {
                $row['bean_module'] == 'Contacts';
            }

            foreach ($row as $name => $value) {
                if (empty($names)) {
                    $names .= $name;
                    $values .= ""'$value'"";
                } else {
                    $names .= ', ' . $name;
                    $values .= "", '$value'"";
                }
            }
            $query .= ""($names)	VALUES ($values)"";
            $db->query($query);
        }
    }
}

function get_unlinked_email_query($type, $bean)
{
    global $current_user;

    $return_array = [];
    $return_array['select'] = 'SELECT emails.id ';
    $return_array['from'] = 'FROM emails ';
    $return_array['where'] = '';
    $return_array['join'] = "" JOIN (select DISTINCT email_id from emails_email_addr_rel eear

	join email_addr_bean_rel eabr on eabr.bean_id ='$bean->id' and eabr.bean_module = '$bean->module_dir' and
	eabr.email_address_id = eear.email_address_id and eabr.deleted=0
	where eear.deleted=0 and eear.email_id not in
	(select eb.email_id from emails_beans eb where eb.bean_module ='$bean->module_dir' and eb.bean_id = '$bean->id')
	) derivedemails on derivedemails.email_id = emails.id"";
    $return_array['join_tables'][0] = '';

    if (isset($type) && ! empty($type['return_as_array'])) {
        return $return_array;
    }

    return $return_array['select'] . $return_array['from'] . $return_array['where'] . $return_array['join'];
}

// fn

function get_emails_by_assign_or_link($params)
{
    $relation = $params['link'];
    $bean = $GLOBALS['app']->controller->bean;
    if (empty($bean->$relation)) {
        $bean->load_relationship($relation);
    }
    if (empty($bean->$relation)) {
        $GLOBALS['log']->error(""Bad relation '$relation' for bean '{$bean->object_name}' id '{$bean->id}'"");

        return array();
    }
    $rel_module = $bean->$relation->getRelatedModuleName();
    $rel_join = $bean->$relation->getJoin(array(
        'join_table_alias' => 'link_bean',
        'join_table_link_alias' => 'linkt',
    ));
    $rel_join = str_replace(""{$bean->table_name}.id"", ""'{$bean->id}'"", (string) $rel_join);
    $return_array = [];
    $return_array['select'] = 'SELECT DISTINCT emails.id ';
    $return_array['from'] = 'FROM emails ';

    $return_array['join'] = array();

    // directly assigned emails
    $return_array['join'][] = ""
        SELECT
            eb.email_id,
            'direct' source
        FROM
            emails_beans eb
        WHERE
            eb.bean_module = '{$bean->module_dir}'
            AND eb.bean_id = '{$bean->id}'
            AND eb.deleted=0
    "";

    // Related by directly by email
    $return_array['join'][] = ""
        SELECT DISTINCT
            eear.email_id,
            'relate' source
        FROM
            emails_email_addr_rel eear
        INNER JOIN
            email_addr_bean_rel eabr
        ON
            eabr.bean_id ='{$bean->id}'
            AND eabr.bean_module = '{$bean->module_dir}'
            AND eabr.email_address_id = eear.email_address_id
            AND eabr.deleted=0
        WHERE
            eear.deleted=0
    "";

    $showEmailsOfRelatedContacts = empty($bean->field_defs[$relation]['hide_history_contacts_emails']);
    if (!empty($GLOBALS['sugar_config']['hide_history_contacts_emails']) && isset($GLOBALS['sugar_config']['hide_history_contacts_emails'][$bean->module_name])) {
        $showEmailsOfRelatedContacts = empty($GLOBALS['sugar_config']['hide_history_contacts_emails'][$bean->module_name]);
    }
    if ($showEmailsOfRelatedContacts) {
        // Assigned to contacts
        $return_array['join'][] = ""
            SELECT DISTINCT
                eb.email_id,
                'contact' source
            FROM
                emails_beans eb
            $rel_join AND link_bean.id = eb.bean_id
            WHERE
                eb.bean_module = '$rel_module'
                AND eb.deleted=0
        "";
        // Related by email to linked contact
        $return_array['join'][] = ""
            SELECT DISTINCT
                eear.email_id,
                'relate_contact' source
            FROM
                emails_email_addr_rel eear
            INNER JOIN
                email_addr_bean_rel eabr
            ON
                eabr.email_address_id=eear.email_address_id
                AND eabr.bean_module = '$rel_module'
                AND eabr.deleted=0
            $rel_join AND link_bean.id = eabr.bean_id
            WHERE
                eear.deleted=0
        "";
    }

    $return_array['join'] = ' INNER JOIN (' . implode(' UNION ', $return_array['join']) . ') email_ids ON emails.id=email_ids.email_id ';

    $return_array['where'] = ' WHERE emails.deleted=0 ';

    //$return_array['join'] = '';
    $return_array['join_tables'][0] = '';

    if ($bean->object_name == 'Case' && !empty($bean->case_number)) {
        $where = str_replace('%1', $bean->case_number, (string) $bean->getEmailSubjectMacro());
        $return_array['where'] .= ""\n AND (email_ids.source = 'direct' OR emails.name LIKE '%$where%')"";
    }

    return $return_array;
}

/**
 * Check to see if the number is empty or non-zero.
 *
 * @param $value
 *
 * @return bool
 * */
function number_empty($value)
{
    return empty($value) && $value != '0';
}

/**
 * @param bool $add_blank
 * @param $bean_name
 * @param $display_columns
 * @param string $where
 * @param string $order_by
 * @param bool $blank_is_none
 * @return array
 */
function get_bean_select_array(
    $add_blank,
    $bean_name = null,
    $display_columns = null,
    $where = '',
    $order_by = '',
    $blank_is_none = false
) {
    global $beanFiles;

    // set $add_blank = true by default
    if (!is_bool($add_blank)) {
        $add_blank = true;
    }

    require_once $beanFiles[$bean_name];
    $focus = new $bean_name();
    $user_array = array();

    $key = ($bean_name == 'EmailTemplate') ? $bean_name : $bean_name . $display_columns . $where . $order_by;
    $user_array = get_register_value('select_array', $key);
    if (!$user_array) {
        $db = DBManagerFactory::getInstance();

        $temp_result = array();
        $query = ""SELECT {$focus->table_name}.id, {$display_columns} as display from {$focus->table_name} "";
        $query .= 'where ';
        if ($where != '') {
            $query .= $where . ' AND ';
        }

        $query .= "" {$focus->table_name}.deleted=0"";

        $accessWhere = $focus->buildAccessWhere('list');
        if (!empty($accessWhere)) {
            $query .= ' AND ' . $accessWhere;
        }

        if ($order_by != '') {
            $query .= "" order by {$focus->table_name}.{$order_by}"";
        }

        $GLOBALS['log']->debug(""get_user_array query: $query"");
        $result = $db->query($query, true, 'Error filling in user array: ');

        if ($add_blank == true) {
            // Add in a blank row
            if ($blank_is_none == true) { // set 'blank row' to ""--None--""
                global $app_strings;
                $temp_result[''] = $app_strings['LBL_NONE'];
            } else {
                $temp_result[''] = '';
            }
        }

        // Get the id and the name.
        while ($row = $db->fetchByAssoc($result)) {
            $temp_result[$row['id']] = $row['display'];
        }

        $user_array = $temp_result;
        set_register_value('select_array', $key, $temp_result);
    }

    return $user_array;
}

/**
 * @param unknown_type $listArray
 */
// function parse_list_modules
// searches a list for items in a user's allowed tabs and returns an array that removes unallowed tabs from list
function parse_list_modules(&$listArray)
{
    global $modListHeader;
    $returnArray = array();

    foreach ($listArray as $optionName => $optionVal) {
        if (array_key_exists($optionName, $modListHeader)) {
            $returnArray[$optionName] = $optionVal;
        }

        // special case for projects
        if (array_key_exists('Project', $modListHeader)) {
            $returnArray['ProjectTask'] = $listArray['ProjectTask'];
        }
    }
    $acldenied = ACLController::disabledModuleList($listArray, false);
    foreach ($acldenied as $denied) {
        unset($returnArray[$denied]);
    }
    asort($returnArray);

    return $returnArray;
}

function display_notice($msg = false)
{
    global $error_notice;
    //no error notice - lets just display the error to the user
    if (!isset($error_notice)) {
        echo '<br>' . $msg . '<br>';
    } else {
        $error_notice .= $msg . '<br>';
    }
}

/**
 * Checks if it is a number that at least has the plus at the beginning.
 *
 * @deprecated No longer used, will be removed without replacement in SuiteCRM 7.12.
 */
function skype_formatted($number)
{
    //kbrill - BUG #15375
    if (isset($_REQUEST['action']) && $_REQUEST['action'] == 'Popup') {
        return false;
    }
    return substr((string) $number, 0, 1) == '+' || substr((string) $number, 0, 2) == '00' || substr((string) $number, 0, 3) == '011';

    //	return substr($number, 0, 1) == '+' || substr($number, 0, 2) == '00' || substr($number, 0, 2) == '011';
}

/**
 * @deprecated No longer used, will be removed without replacement in SuiteCRM 7.12.
 */
function format_skype($number)
{
    return preg_replace('/[^\+0-9]/', '', (string) $number);
}

function insert_charset_header()
{
    header('Content-Type: text/html; charset=UTF-8');
}

/**
 * @deprecated This function is unused and will be removed in a future release.
 */
function getCurrentURL()
{
    $href = 'http:';
    if (!empty($_SERVER['HTTPS']) && $_SERVER['HTTPS'] === 'on') {
        $href = 'https:';
    }

    $href .= '//' . $_SERVER['HTTP_HOST'] . $_SERVER['SCRIPT_NAME'] . '?' . $_SERVER['QUERY_STRING'];

    return $href;
}

function javascript_escape($str)
{
    $new_str = '';

    for ($i = 0; $i < strlen((string) $str); ++$i) {
        if (ord(substr((string) $str, $i, 1)) == 10) {
            $new_str .= '\n';
        } elseif (ord(substr((string) $str, $i, 1)) == 13) {
            $new_str .= '\r';
        } else {
            $new_str .= $str[$i];
        }
    }

    $new_str = str_replace(""'"", ""\\'"", $new_str);

    return $new_str;
}

function js_escape($str, $keep = true)
{
    $str = html_entity_decode(str_replace('\\', '', (string) $str), ENT_QUOTES);

    if ($keep) {
        $str = javascript_escape($str);
    } else {
        $str = str_replace(""'"", ' ', $str);
        $str = str_replace('""', ' ', $str);
    }

    return $str;

    //end function js_escape
}

function br2nl($str)
{
    $regex = '#<[^>]+br.+?>#i';
    preg_match_all($regex, (string) $str, $matches);

    foreach ($matches[0] as $match) {
        $str = str_replace($match, '<br>', (string) $str);
    }

    $brs = array('<br>', '<br/>', '<br />');
    $str = str_replace(""\r\n"", ""\n"", (string) $str); // make from windows-returns, *nix-returns
    $str = str_replace(""\n\r"", ""\n"", $str); // make from windows-returns, *nix-returns
    $str = str_replace(""\r"", ""\n"", $str); // make from windows-returns, *nix-returns
    $str = str_ireplace($brs, ""\n"", $str); // to retrieve it

    return $str;
}

/**
 * Private helper function for displaying the contents of a given variable.
 * This function is only intended to be used for SugarCRM internal development.
 * The ppd stands for Pre Print Die.
 * @deprecated This function is unused and will be removed in a future release.
 */
function _ppd($mixed)
{
}

/**
 * Private helper function for displaying the contents of a given variable in
 * the Logger. This function is only intended to be used for SugarCRM internal
 * development. The pp stands for Pre Print.
 *
 * @param $mixed var to print_r()
 * @param $die boolean end script flow
 * @param $displayStackTrace also show stack trace
 * @deprecated This function is unused and will be removed in a future release.
 */
function _ppl($mixed, $die = false, $displayStackTrace = false, $loglevel = 'fatal')
{
    if (!isset($GLOBALS['log']) || empty($GLOBALS['log'])) {
        $GLOBALS['log'] = LoggerManager:: getLogger();
    }

    $mix = print_r($mixed, true); // send print_r() output to $mix
    $stack = debug_backtrace();

    $GLOBALS['log']->$loglevel('------------------------------ _ppLogger() output start -----------------------------');
    $GLOBALS['log']->$loglevel($mix);
    if ($displayStackTrace) {
        foreach ($stack as $position) {
            $GLOBALS['log']->$loglevel($position['file'] . ""({$position['line']})"");
        }
    }

    $GLOBALS['log']->$loglevel('------------------------------ _ppLogger() output end -----------------------------');
    $GLOBALS['log']->$loglevel('------------------------------ _ppLogger() file: ' . $stack[0]['file'] . ' line#: ' . $stack[0]['line'] . '-----------------------------');

    if ($die) {
        die();
    }
}

/**
 * private helper function to quickly show the major, direct, field attributes of a given bean.
 * The ppf stands for Pre[formatted] Print Focus [object].
 *
 * @param object bean The focus bean
 * @deprecated This function is unused and will be removed in a future release.
 */
function _ppf($bean, $die = false)
{
}

/**
 * Private helper function for displaying the contents of a given variable.
 * This function is only intended to be used for SugarCRM internal development.
 * The pp stands for Pre Print.
 * @deprecated This function is unused and will be removed in a future release.
 */
function _pp($mixed)
{
}

/**
 * Private helper function for displaying the contents of a given variable.
 * This function is only intended to be used for SugarCRM internal development.
 * The pp stands for Pre Print.
 * @deprecated This function is unused and will be removed in a future release.
 */
function _pstack_trace($mixed = null)
{
}

/**
 * Private helper function for displaying the contents of a given variable.
 * This function is only intended to be used for SugarCRM internal development.
 * The pp stands for Pre Print Trace.
 * @deprecated This function is unused and will be removed in a future release.
 */
function _ppt($mixed, $textOnly = false)
{
}

/**
 * Private helper function for displaying the contents of a given variable.
 * This function is only intended to be used for SugarCRM internal development.
 * The pp stands for Pre Print Trace Die.
 * @deprecated This function is unused and will be removed in a future release.
 */
function _pptd($mixed)
{
}

/**
 * Private helper function for decoding javascript UTF8
 * This function is only intended to be used for SugarCRM internal development.
 * @deprecated This function is unused and will be removed in a future release.
 */
function decodeJavascriptUTF8($str)
{
}

/**
 * Will check if a given PHP version string is accepted or not.
 * Do not pass in any pararameter to default to a check against the
 * current environment's PHP version.
 *
 * @param string $sys_php_version Version to check against, defaults to the current environment's.
 * @param string $min_php_version Minimum version to check against. Defaults to the SUITECRM_PHP_MIN_VERSION constant.
 * @param string $rec_php_version Recommended version. Defaults to the SUITECRM_PHP_REC_VERSION constant
 *
 * @return integer 1 if version is greater than the recommended PHP version,
 *   0 if version is between minimun and recomended PHP versions,
 *   -1 otherwise (less than minimum or buggy version)
 */
function check_php_version($sys_php_version = '', $min_php_version = '', $rec_php_version = '')
{
    if ($sys_php_version === '') {
        $sys_php_version = constant('PHP_VERSION');
    }
    if ($min_php_version === '') {
        $min_php_version = constant('SUITECRM_PHP_MIN_VERSION');
    }
    if ($rec_php_version === '') {
        $rec_php_version = constant('SUITECRM_PHP_REC_VERSION');
    }

    // versions below MIN_PHP_VERSION are not accepted, so return early.
    if (version_compare($sys_php_version, $min_php_version, '<') === true) {
        return -1;
    }

    // If the checked version is between the minimum and recommended versions, return 0.
    if (version_compare($sys_php_version, $rec_php_version, '<') === true) {
        return 0;
    }

    // Everything else is fair game
    return 1;
}

/**
 * Will check if a given IIS version string is supported (tested on this ver),
 * unsupported (results unknown), or invalid (something will break on this
 * ver).
 *
 * @return 1 implies supported, 0 implies unsupported, -1 implies invalid
 */
function check_iis_version($sys_iis_version = '')
{
    $server_software = $_SERVER['SERVER_SOFTWARE'];
    $iis_version = '';
    if (strpos((string) $server_software, 'Microsoft-IIS') !== false && preg_match_all(""/^.*\/(\d+\.?\d*)$/"", (string) $server_software, $out)) {
        $iis_version = $out[1][0];
    }

    $sys_iis_version = empty($sys_iis_version) ? $iis_version : $sys_iis_version;

    // versions below $min_considered_iis_version considered invalid by default,
    // versions equal to or above this ver will be considered depending
    // on the rules that follow
    $min_considered_iis_version = '6.0';

    // only the supported versions,
    // should be mutually exclusive with $invalid_iis_versions
    $supported_iis_versions = array('6.0', '7.0');
    $unsupported_iis_versions = array();
    $invalid_iis_versions = array('5.0');

    // default unsupported
    $retval = 0;

    // versions below $min_considered_iis_version are invalid
    if (1 == version_compare($sys_iis_version, $min_considered_iis_version, '<')) {
        $retval = -1;
    }

    // supported version check overrides default unsupported
    foreach ($supported_iis_versions as $ver) {
        if (1 == version_compare($sys_iis_version, $ver, 'eq') || strpos((string) $sys_iis_version, $ver) !== false) {
            $retval = 1;
            break;
        }
    }

    // unsupported version check overrides default unsupported
    foreach ($unsupported_iis_versions as $ver) {
        if (1 == version_compare($sys_iis_version, $ver, 'eq') && strpos((string) $sys_iis_version, (string) $ver) !== false) {
            $retval = 0;
            break;
        }
    }

    // invalid version check overrides default unsupported
    foreach ($invalid_iis_versions as $ver) {
        if (1 == version_compare($sys_iis_version, $ver, 'eq') && strpos((string) $sys_iis_version, $ver) !== false) {
            $retval = -1;
            break;
        }
    }

    return $retval;
}

function pre_login_check()
{
    global $action, $login_error;
    if (!empty($action) && $action == 'Login') {
        if (!empty($login_error)) {
            $login_error = htmlentities((string) $login_error);
            $login_error = str_replace(array('&lt;pre&gt;', '&lt;/pre&gt;', ""\r\n"", ""\n""), '<br>', $login_error);
            $_SESSION['login_error'] = $login_error;
            echo '<script>
						function set_focus() {}
						if(document.getElementById(""post_error"")) {
							document.getElementById(""post_error"").innerHTML=""' . $login_error . '"";
							document.getElementById(""cant_login"").value=1;
							document.getElementById(""login_button"").disabled = true;
							document.getElementById(""user_name"").disabled = true;
						}
						</script>';
        }
    }
}

/**
 * Like exit() but will throw an exception if called during tests.
 *
 * This is to avoid exit() stopping the test suite without us noticing.
 *
 * @param int|string $status
 * @throws Exception
 */
function suite_exit($status = 0)
{
    if (defined('SUITE_PHPUNIT_RUNNER'))
        throw new Exception(""exit() called during tests with status: $status"");
    else
        exit($status);
}

function sugar_cleanup($exit = false)
{
    static $called = false;
    if ($called) {
        return;
    }
    $called = true;
    set_include_path(realpath(__DIR__ . '/..') . PATH_SEPARATOR . get_include_path());
    chdir(realpath(__DIR__ . '/..'));
    global $sugar_config;
    require_once 'include/utils/LogicHook.php';
    LogicHook::initialize();
    $GLOBALS['logic_hook']->call_custom_logic('', 'server_round_trip');

    //added this check to avoid errors during install.
    if (empty($sugar_config['dbconfig'])) {
        if ($exit) {
            suite_exit();
        }
        return;
    }

    if (!class_exists('Tracker', true)) {
        require_once 'modules/Trackers/Tracker.php';
    }
    Tracker::logPage();
    // Now write the cached tracker_queries
    if (!empty($GLOBALS['savePreferencesToDB']) && $GLOBALS['savePreferencesToDB']) {
        if (isset($GLOBALS['current_user']) && $GLOBALS['current_user'] instanceof User) {
            $GLOBALS['current_user']->savePreferencesToDB();
        }
    }

    //check to see if this is not an `ajax call AND the user preference error flag is set
    if (
            (isset($_SESSION['USER_PREFRENCE_ERRORS']) && $_SESSION['USER_PREFRENCE_ERRORS']) && ($_REQUEST['action'] != 'modulelistmenu' && $_REQUEST['action'] != 'DynamicAction') && ($_REQUEST['action'] != 'favorites' && $_REQUEST['action'] != 'DynamicAction') && (empty($_REQUEST['to_pdf']) || !$_REQUEST['to_pdf']) && (empty($_REQUEST['sugar_body_only']) || !$_REQUEST['sugar_body_only'])
    ) {
        global $app_strings;
        //this is not an ajax call and the user preference error flag is set, so reset the flag and print js to flash message
        $err_mess = $app_strings['ERROR_USER_PREFS'];
        $_SESSION['USER_PREFRENCE_ERRORS'] = false;
        echo ""
		<script>
			ajaxStatus.flashStatus('$err_mess',7000);
		</script>"";
    }

    pre_login_check();
    if (class_exists('DBManagerFactory')) {
        $db = DBManagerFactory::getInstance();
        $db->disconnect();
        if ($exit) {
            suite_exit();
        }
    }
}

register_shutdown_function('sugar_cleanup');

/*
  check_logic_hook - checks to see if your custom logic is in the logic file
  if not, it will add it. If the file isn't built yet, it will create the file

 */

function check_logic_hook_file($module_name, $event, $action_array)
{
    require_once 'include/utils/logic_utils.php';
    $add_logic = false;

    if (file_exists(""custom/modules/$module_name/logic_hooks.php"")) {
        $hook_array = get_hook_array($module_name);

        if (check_existing_element($hook_array, $event, $action_array) == true) {
            //the hook at hand is present, so do nothing
        } else {
            $add_logic = true;

            $logic_count = 0;
            if (!empty($hook_array[$event])) {
                $logic_count = is_countable($hook_array[$event]) ? count($hook_array[$event]) : 0;
            }

            if ($action_array[0] == '') {
                $action_array[0] = $logic_count + 1;
            }
            $hook_array[$event][] = $action_array;
        }
        //end if the file exists already
    } else {
        $add_logic = true;
        if ($action_array[0] == '') {
            $action_array[0] = 1;
        }
        $hook_array = array();
        $hook_array[$event][] = $action_array;
        //end if else file exists already
    }
    if ($add_logic == true) {

        //reorder array by element[0]
        //$hook_array = reorder_array($hook_array, $event);
        //!!!Finish this above TODO

        $new_contents = replace_or_add_logic_type($hook_array);
        write_logic_file($module_name, $new_contents);

        //end if add_element is true
    }

    //end function check_logic_hook_file
}

function remove_logic_hook($module_name, $event, $action_array)
{
    require_once 'include/utils/logic_utils.php';
    $add_logic = false;

    if (file_exists('custom/modules/' . $module_name . '/logic_hooks.php')) {
        // The file exists, let's make sure the hook is there
        $hook_array = get_hook_array($module_name);

        if (check_existing_element($hook_array, $event, $action_array) == true) {
            // The hook is there, time to take it out.

            foreach ($hook_array[$event] as $i => $hook) {
                // We don't do a full comparison below just in case the filename changes
                if ($hook[0] == $action_array[0] && $hook[1] == $action_array[1] && $hook[3] == $action_array[3] && $hook[4] == $action_array[4]
                ) {
                    unset($hook_array[$event][$i]);
                }
            }

            $new_contents = replace_or_add_logic_type($hook_array);
            write_logic_file($module_name, $new_contents);
        }
    }
}

function display_stack_trace($textOnly = false)
{
    $stack = debug_backtrace();

    echo ""\n\n display_stack_trace caller, file: "" . $stack[0]['file'] . ' line#: ' . $stack[0]['line'];

    if (!$textOnly) {
        echo '<br>';
    }

    $first = true;
    $out = '';

    foreach ($stack as $item) {
        $file = '';
        $class = '';
        $line = '';
        $function = '';

        if (isset($item['file'])) {
            $file = $item['file'];
        }
        if (isset($item['class'])) {
            $class = $item['class'];
        }
        if (isset($item['line'])) {
            $line = $item['line'];
        }
        if (isset($item['function'])) {
            $function = $item['function'];
        }

        if (!$first) {
            if (!$textOnly) {
                $out .= '<font color=""black""><b>';
            }

            $out .= $file;

            if (!$textOnly) {
                $out .= '</b></font><font color=""blue"">';
            }

            $out .= ""[L:{$line}]"";

            if (!$textOnly) {
                $out .= '</font><font color=""red"">';
            }

            $out .= ""({$class}:{$function})"";

            if (!$textOnly) {
                $out .= '</font><br>';
            } else {
                $out .= ""\n"";
            }
        } else {
            $first = false;
        }
    }

    echo $out;
    return $out;
}

function StackTraceErrorHandler($errno, $errstr, $errfile, $errline, $errcontext)
{
    $error_msg = "" $errstr occurred in <b>$errfile</b> on line $errline ["" . date('Y-m-d H:i:s') . ']';

    switch ($errno) {
//        case 2048:
//            return; //depricated we have lots of these ignore them
        case E_USER_NOTICE:
            $type = 'User notice';
            // no break
        case E_NOTICE:
            $type = 'Notice';
            $halt_script = false;
            break;


        case E_USER_WARNING:
            $type = 'User warning';
            // no break
        case E_COMPILE_WARNING:
            $type = 'Compile warning';
            // no break
        case E_CORE_WARNING:
            $type = 'Core warning';
            // no break
        case E_WARNING:
            $type = 'Warning';
            $halt_script = false;
            break;

        case E_USER_ERROR:
            $type = 'User error';
            // no break
        case E_COMPILE_ERROR:
            $type = 'Compile error';
            // no break
        case E_CORE_ERROR:
            $type = 'Core error';
            // no break
        case E_ERROR:
            $type = 'Error';
            $halt_script = true;
            break;

        case E_PARSE:
            $type = 'Parse Error';
            $halt_script = true;
            break;

        default:
            //don't know what it is might not be so bad
            $type = ""Unknown Error ($errno)"";
            $halt_script = false;
            break;
    }
    $error_msg = '<b>[' . $type . ']</b> ' . $error_msg;
    echo $error_msg;
    $trace = display_stack_trace();
    \SuiteCRM\ErrorMessage::log(""Catch an error: $error_msg \nTrace info:\n"" . $trace);
    if ($halt_script) {
        exit(1);
    }
}

if (isset($sugar_config['stack_trace_errors']) && $sugar_config['stack_trace_errors']) {
    set_error_handler('StackTraceErrorHandler');
}

function get_sub_cookies($name)
{
    $cookies = array();
    if (isset($_COOKIE[$name])) {
        $subs = explode('#', $_COOKIE[$name]);
        foreach ($subs as $cookie) {
            if (!empty($cookie)) {
                $cookie = explode('=', $cookie);

                $cookies[$cookie[0]] = $cookie[1];
            }
        }
    }

    return $cookies;
}

/**
 * @deprecated This function is unused and will be removed in a future release.
 */
function mark_delete_components($sub_object_array, $run_second_level = false, $sub_sub_array = '')
{
    if (!empty($sub_object_array)) {
        foreach ($sub_object_array as $sub_object) {

            //run_second level is set to true if you need to remove sub-sub components
            if ($run_second_level == true) {
                mark_delete_components($sub_object->get_linked_beans($sub_sub_array['rel_field'], $sub_sub_array['rel_module']));

                //end if run_second_level is true
            }
            $sub_object->mark_deleted($sub_object->id);
            //end foreach sub component
        }
        //end if this is not empty
    }

    //end function mark_delete_components
}

/**
 * Translates php.ini memory values into bytes.
 * For example, an input value of '8M' will return 8388608.
 * 8M is 8 mebibytes, 1 mebibyte is 1,048,576 bytes or 2^20 bytes.
 *
 * @param string $val A string like '8M'.
 * @return integer The number of bytes represented by that string.
 */
function return_bytes($val)
{
    $val = trim($val);
    $last = strtolower($val[strlen($val) - 1]);
    $val = preg_replace(""/[^0-9,.]/"", """", $val);

    switch ($last) {
        case 'g':
            $val *= 1024;
            // no break
        case 'm':
            $val *= 1024;
            // no break
        case 'k':
            $val *= 1024;
    }

    return $val;
}

/**
 * Adds the href HTML tags around any URL in the $string.
 */
function url2html($string)
{
    $return_string = preg_replace('/(\w+:\/\/)(\S+)/', ' <a href=""\\1\\2"" target=""_new""  style=""font-weight: normal;"">\\1\\2</a>', (string) $string);

    return $return_string;
}

/**
 * tries to determine whether the Host machine is a Windows machine.
 */
function is_windows()
{
    static $is_windows = null;
    if (!isset($is_windows)) {
        $is_windows = strtoupper(substr(PHP_OS, 0, 3)) == 'WIN';
    }

    return $is_windows;
}

/**
 * equivalent for windows filesystem for PHP's is_writable().
 *
 * @param string file Full path to the file/dir
 *
 * @return bool true if writable
 */
function is_writable_windows($file)
{
    if ($file[strlen((string) $file) - 1] == '/') {
        return is_writable_windows($file . uniqid(mt_rand()) . '.tmp');
    }

    // the assumption here is that Windows has an inherited permissions scheme
    // any file that is a descendant of an unwritable directory will inherit
    // that property and will trigger a failure below.
    if (is_dir($file)) {
        return true;
    }

    $file = str_replace('/', '\\', (string) $file);

    if (file_exists($file)) {
        if (!($f = @sugar_fopen($file, 'r+'))) {
            return false;
        }
        fclose($f);

        return true;
    }

    if (!($f = @sugar_fopen($file, 'w'))) {
        return false;
    }
    fclose($f);
    unlink($file);

    return true;
}

/**
 * best guesses Timezone based on webserver's TZ settings.
 */
function lookupTimezone($userOffset = 0)
{
    return TimeDate::guessTimezone($userOffset);
}

function convert_module_to_singular($module_array)
{
    global $beanList;

    foreach ($module_array as $key => $value) {
        if (!empty($beanList[$value])) {
            $module_array[$key] = $beanList[$value];
        }

        if ($value == 'Cases') {
            $module_array[$key] = 'Case';
        }
        if ($key == 'projecttask') {
            $module_array['ProjectTask'] = 'Project Task';
            unset($module_array[$key]);
        }
    }

    return $module_array;

    //end function convert_module_to_singular
}

/*
 * Given the bean_name which may be plural or singular return the singular
 * bean_name. This is important when you need to include files.
 */

function get_singular_bean_name($bean_name)
{
    global $beanFiles, $beanList;
    if (array_key_exists($bean_name, $beanList)) {
        return $beanList[$bean_name];
    }
    return $bean_name;
}

/*
 * Given the potential module name (singular name, renamed module name)
 * Return the real internal module name.
 */

function get_module_from_singular($singular)
{

    // find the internal module name for a singular name
    if (isset($GLOBALS['app_list_strings']['moduleListSingular'])) {
        $singular_modules = $GLOBALS['app_list_strings']['moduleListSingular'];

        foreach ($singular_modules as $mod_name => $sin_name) {
            if ($singular == $sin_name && $mod_name != $sin_name) {
                return $mod_name;
            }
        }
    }

    // find the internal module name for a renamed module
    if (isset($GLOBALS['app_list_strings']['moduleList'])) {
        $moduleList = $GLOBALS['app_list_strings']['moduleList'];

        foreach ($moduleList as $mod_name => $name) {
            if ($singular == $name && $mod_name != $name) {
                return $mod_name;
            }
        }
    }

    // if it's not a singular name, nor a renamed name, return the original value
    return $singular;
}

function get_label($label_tag, $temp_module_strings)
{
    global $app_strings;
    if (!empty($temp_module_strings[$label_tag])) {
        $label_name = $temp_module_strings[$label_tag];
    } else {
        if (!empty($app_strings[$label_tag])) {
            $label_name = $app_strings[$label_tag];
        } else {
            $label_name = $label_tag;
        }
    }

    return $label_name;

    //end function get_label
}

function search_filter_rel_info(&$focus, $tar_rel_module, $relationship_name)
{
    $rel_list = array();

    foreach ($focus->relationship_fields as $rel_key => $rel_value) {
        if ($rel_value == $relationship_name) {
            $temp_bean = BeanFactory::getBean($tar_rel_module, $focus->$rel_key);
            if ($temp_bean) {
                $rel_list[] = $temp_bean;

                return $rel_list;
            }
        }
    }

    foreach ($focus->field_defs as $field_name => $field_def) {
        //Check if the relationship_name matches a ""relate"" field
        if (!empty($field_def['type']) && $field_def['type'] == 'relate' && !empty($field_def['id_name']) && !empty($focus->field_defs[$field_def['id_name']]) && !empty($focus->field_defs[$field_def['id_name']]['relationship']) && $focus->field_defs[$field_def['id_name']]['relationship'] == $relationship_name
        ) {
            $temp_bean = BeanFactory::getBean($tar_rel_module, $field_def['id_name']);
            if ($temp_bean) {
                $rel_list[] = $temp_bean;

                return $rel_list;
            }
            //Check if the relationship_name matches a ""link"" in a relate field
        } elseif (!empty($rel_value['link']) && !empty($rel_value['id_name']) && $rel_value['link'] == $relationship_name) {
            $temp_bean = BeanFactory::getBean($tar_rel_module, $rel_value['id_name']);
            if ($temp_bean) {
                $rel_list[] = $temp_bean;

                return $rel_list;
            }
        }
    }

    // special case for unlisted parent-type relationships
    if (!empty($focus->parent_type) && $focus->parent_type == $tar_rel_module && !empty($focus->parent_id)) {
        $temp_bean = BeanFactory::getBean($tar_rel_module, $focus->parent_id);
        if ($temp_bean) {
            $rel_list[] = $temp_bean;

            return $rel_list;
        }
    }

    return $rel_list;

    //end function search_filter_rel_info
}

/**
 * @param $module_name
 * @return mixed
 */
function get_module_info($module_name)
{
    return BeanFactory::getBean($module_name);
}

/**
 * In order to have one place to obtain the proper object name. aCase for example causes issues throughout the application.
 *
 * @param string $moduleName
 */
function get_valid_bean_name($module_name)
{
    global $beanList;

    $vardef_name = $beanList[$module_name];
    if ($vardef_name == 'aCase') {
        $bean_name = 'Case';
    } else {
        $bean_name = $vardef_name;
    }

    return $bean_name;
}

function checkAuthUserStatus()
{

    //authUserStatus();
}

/**
 * This function returns an array of phpinfo() results that can be parsed and
 * used to figure out what version we run, what modules are compiled in, etc.
 *
 * @param   $level int        info level constant (1,2,4,8...64);
 *
 * @return $returnInfo array    array of info about the PHP environment
 *
 * @author    original by ""code at adspeed dot com"" Fron php.net
 * @author    customized for Sugar by Chris N.
 */
function getPhpInfo($level = -1)
{
    /* 	Name (constant)		Value	Description
      INFO_GENERAL		1		The configuration line, php.ini location, build date, Web Server, System and more.
      INFO_CREDITS		2		PHP Credits. See also phpcredits().
      INFO_CONFIGURATION	4		Current Local and Master values for PHP directives. See also ini_get().
      INFO_MODULES		8		Loaded modules and their respective settings. See also get_loaded_extensions().
      INFO_ENVIRONMENT	16		Environment Variable information that's also available in $_ENV.
      INFO_VARIABLES		32		Shows all predefined variables from EGPCS (Environment, GET, POST, Cookie, Server).
      INFO_LICENSE		64		PHP License information. See also the license FAQ.
      INFO_ALL			-1		Shows all of the above. This is the default value.
     */
    ob_start();
    phpinfo($level);
    $phpinfo = ob_get_contents();
    ob_end_clean();

    $phpinfo = strip_tags($phpinfo, '<h1><h2><th><td>');
    $phpinfo = preg_replace('/<th[^>]*>([^<]+)<\/th>/', '<info>\\1</info>', $phpinfo);
    $phpinfo = preg_replace('/<td[^>]*>([^<]+)<\/td>/', '<info>\\1</info>', $phpinfo);
    $parsedInfo = preg_split('/(<h.?>[^<]+<\/h.>)/', $phpinfo, -1, PREG_SPLIT_DELIM_CAPTURE);
    $match = '';
    $version = '';
    $returnInfo = array();

    if (preg_match('/<h1 class\=\""p\"">PHP Version ([^<]+)<\/h1>/', $phpinfo, $version)) {
        $returnInfo['PHP Version'] = $version[1];
    }
    $parsedInfoCount = count($parsedInfo);

    for ($i = 1; $i < $parsedInfoCount; ++$i) {
        if (preg_match('/<h.>([^<]+)<\/h.>/', $parsedInfo[$i], $match)) {
            $vName = trim($match[1]);
            $parsedInfo2 = explode(""\n"", $parsedInfo[$i + 1]);

            foreach ($parsedInfo2 as $vOne) {
                $vPat = '<info>([^<]+)<\/info>';
                $vPat3 = ""/$vPat\s*$vPat\s*$vPat/"";
                $vPat2 = ""/$vPat\s*$vPat/"";

                if (preg_match($vPat3, $vOne, $match)) { // 3cols
                    $returnInfo[$vName][trim($match[1])] = array(trim($match[2]), trim($match[3]));
                } elseif (preg_match($vPat2, $vOne, $match)) { // 2cols
                    $returnInfo[$vName][trim($match[1])] = trim($match[2]);
                }
            }
        } elseif (true) {
        }
    }

    return $returnInfo;
}

/**
 * This function will take a string that has tokens like {0}, {1} and will replace
 * those tokens with the args provided.
 *
 * @param   $format string to format
 * @param   $args   args to replace
 *
 * @return $result a formatted string
 */
function string_format($format, $args, $escape = true)
{
    $result = $format;

    /* Bug47277 fix.
     * If args array has only one argument, and it's empty, so empty single quotes are used '' . That's because
     * IN () fails and IN ('') works.
     */
    if ((is_countable($args) ? count($args) : 0) == 1) {
        reset($args);
        $singleArgument = current($args);
        if (empty($singleArgument)) {
            return str_replace('{0}', ""''"", (string) $result);
        }
    }
    /* End of fix */

    if ($escape) {
        $db = DBManagerFactory::getInstance();
    }
    $argsCount = count($args);
    for ($i = 0; $i < $argsCount; ++$i) {
        if (strpos((string) $args[$i], ',') !== false) {
            $values = explode(',', $args[$i]);
            if ($escape) {
                foreach ($values as &$value) {
                    $value = $db->quote($value);
                }
            }
            $args[$i] = implode(""','"", $values);
            $result = str_replace('{'.$i.'}', $args[$i], (string) $result);
       }
        else if ($escape){
            $result = str_replace('{'.$i.'}', $db->quote($args[$i]), (string) $result);
        }
        else{
            $result = str_replace('{'.$i.'}', $args[$i], (string) $result);
        }
    }

    return $result;
}

/**
 * Generate a string for displaying a unique identifier that is composed
 * of a system_id and number.  This is use to allow us to generate quote
 * numbers using a DB auto-increment key from offline clients and still
 * have the number be unique (since it is modified by the system_id.
 *
 * @deprecated This function is unused and will be removed in a future release.
 *
 * @param   $num       of bean
 * @param   $system_id from system
 *
 * @return $result a formatted string
 */
function format_number_display($num, $system_id)
{
    global $sugar_config;
    if (isset($num) && !empty($num)) {
        $num = unformat_number($num);
        if (isset($system_id) && $system_id == 1) {
            return sprintf('%d', $num);
        }
        return sprintf('%d-%d', $num, $system_id);
    }
}

/**
 * @deprecated This function is unused and will be removed in a future release.
 */
function checkLoginUserStatus()
{
}

/**
 * This function will take a number and system_id and format.
 *
 * @param   $url  URL containing host to append port
 * @param   $port the port number - if '' is passed, no change to url
 *
 * @return $resulturl the new URL with the port appended to the host
 */
function appendPortToHost($url, $port)
{
    $resulturl = $url;

    // if no port, don't change the url
    if ($port != '') {
        $split = explode('/', $url);
        //check if it starts with http, in case they didn't include that in url
        if (str_begin($url, 'http')) {
            //third index ($split[2]) will be the host
            $split[2] .= ':' . $port;
        } else {
            // otherwise assumed to start with host name
            //first index ($split[0]) will be the host
            $split[0] .= ':' . $port;
        }

        $resulturl = implode('/', $split);
    }

    return $resulturl;
}

/**
 * Singleton to return JSON object.
 *
 * @return JSON object
 */
function getJSONobj()
{
    static $json = null;
    if (!isset($json)) {
        require_once 'include/JSON.php';
        $json = new JSON();
    }

    return $json;
}

require_once 'include/utils/db_utils.php';

/**
 * Set default php.ini settings for entry points.
 */
function setPhpIniSettings()
{
    // zlib module
    // Bug 37579 - Comment out force enabling zlib.output_compression, since it can cause problems on certain hosts
    /*
      if(function_exists('gzclose') && headers_sent() == false) {
      ini_set('zlib.output_compression', 1);
      }
     */
    // mbstring module
    //nsingh: breaks zip/unzip functionality. Commenting out 4/23/08

    /* if(function_exists('mb_strlen')) {
      ini_set('mbstring.func_overload', 7);
      ini_set('mbstring.internal_encoding', 'UTF-8');
      } */

    // http://us3.php.net/manual/en/ref.pcre.php#ini.pcre.backtrack-limit
    // starting with 5.2.0, backtrack_limit breaks JSON decoding
    $backtrack_limit = ini_get('pcre.backtrack_limit');
    if (!empty($backtrack_limit)) {
        ini_set('pcre.backtrack_limit', '-1');
    }
}

/**
 * Identical to sugarArrayMerge but with some speed improvements and used specifically to merge
 * language files.  Language file merges do not need to account for null values so we can get some
 * performance increases by using this specialized function. Note this merge function does not properly
 * handle null values.
 *
 * @param $gimp
 * @param $dom
 *
 * @return array
 */
function sugarLangArrayMerge($gimp, $dom)
{
    if (is_array($gimp) && is_array($dom)) {
        foreach ($dom as $domKey => $domVal) {
            if (isset($gimp[$domKey])) {
                if (is_array($domVal)) {
                    $tempArr = array();
                    foreach ($domVal as $domArrKey => $domArrVal) {
                        $tempArr[$domArrKey] = $domArrVal;
                    }
                    foreach ($gimp[$domKey] as $gimpArrKey => $gimpArrVal) {
                        if (!isset($tempArr[$gimpArrKey])) {
                            $tempArr[$gimpArrKey] = $gimpArrVal;
                        }
                    }
                    $gimp[$domKey] = $tempArr;
                } else {
                    $gimp[$domKey] = $domVal;
                }
            } else {
                $gimp[$domKey] = $domVal;
            }
        }
    } // if the passed value for gimp isn't an array, then return the $dom
    elseif (is_array($dom)) {
        return $dom;
    }

    return $gimp;
}

/**
 * like array_merge() but will handle array elements that are themselves arrays;
 * PHP's version just overwrites the element with the new one.
 *
 * @internal Note that this function deviates from the internal array_merge()
 *           functions in that it does does not treat numeric keys differently
 *           than string keys.  Additionally, it deviates from
 *           array_merge_recursive() by not creating an array when like values
 *           found.
 *
 * @param array gimp the array whose values will be overloaded
 * @param array dom the array whose values will pwn the gimp's
 *
 * @return array beaten gimp
 */
function sugarArrayMerge($gimp, $dom)
{
    if (is_array($gimp) && is_array($dom)) {
        foreach ($dom as $domKey => $domVal) {
            if (array_key_exists($domKey, $gimp)) {
                if (is_array($domVal)) {
                    $tempArr = array();
                    foreach ($domVal as $domArrKey => $domArrVal) {
                        $tempArr[$domArrKey] = $domArrVal;
                    }
                    foreach ($gimp[$domKey] as $gimpArrKey => $gimpArrVal) {
                        if (!array_key_exists($gimpArrKey, $tempArr)) {
                            $tempArr[$gimpArrKey] = $gimpArrVal;
                        }
                    }
                    $gimp[$domKey] = $tempArr;
                } else {
                    $gimp[$domKey] = $domVal;
                }
            } else {
                $gimp[$domKey] = $domVal;
            }
        }
    } // if the passed value for gimp isn't an array, then return the $dom
    elseif (is_array($dom)) {
        return $dom;
    }

    return $gimp;
}

/**
 * Similiar to sugarArrayMerge except arrays of N depth are merged.
 *
 * @param array gimp the array whose values will be overloaded
 * @param array dom the array whose values will pwn the gimp's
 *
 * @return array beaten gimp
 */
function sugarArrayMergeRecursive($gimp, $dom)
{
    if (is_array($gimp) && is_array($dom)) {
        foreach ($dom as $domKey => $domVal) {
            if (array_key_exists($domKey, $gimp)) {
                if (is_array($domVal) && is_array($gimp[$domKey])) {
                    $gimp[$domKey] = sugarArrayMergeRecursive($gimp[$domKey], $domVal);
                } else {
                    $gimp[$domKey] = $domVal;
                }
            } else {
                $gimp[$domKey] = $domVal;
            }
        }
    } // if the passed value for gimp isn't an array, then return the $dom
    elseif (is_array($dom)) {
        return $dom;
    }

    return $gimp;
}

/**
 * Finds the correctly working versions of PHP-JSON.
 * @deprecated This function is unused and will be removed in a future release.
 *
 * @return bool True if NOT found or WRONG version
 */
function returnPhpJsonStatus()
{
    if (function_exists('json_encode')) {
        $phpInfo = getPhpInfo(8);

        return version_compare($phpInfo['json']['json version'], '1.1.1', '<');
    }

    return true; // not found
}

/**
 * getTrackerSubstring.
 *
 * Returns a [number]-char or less string for the Tracker to display in the header
 * based on the tracker_max_display_length setting in config.php.  If not set,
 * or invalid length, then defaults to 15 for COM editions, 30 for others.
 *
 * @param string name field for a given Object
 *
 * @return string [number]-char formatted string if length of string exceeds the max allowed
 */
function getTrackerSubstring($name)
{
    static $max_tracker_item_length;

    //Trim the name
    $name = html_entity_decode((string) $name, ENT_QUOTES, 'UTF-8');
    $strlen = function_exists('mb_strlen') ? mb_strlen($name) : strlen($name);

    global $sugar_config;

    if (!isset($max_tracker_item_length)) {
        if (isset($sugar_config['tracker_max_display_length'])) {
            $max_tracker_item_length = (is_int($sugar_config['tracker_max_display_length']) && $sugar_config['tracker_max_display_length'] > 0 && $sugar_config['tracker_max_display_length'] < 50) ? $sugar_config['tracker_max_display_length'] : 15;
        } else {
            $max_tracker_item_length = 15;
        }
    }

    if ($strlen > $max_tracker_item_length) {
        $chopped = function_exists('mb_substr') ? mb_substr($name, 0, $max_tracker_item_length - 3, 'UTF-8') : substr($name, 0, $max_tracker_item_length - 3);
        $chopped .= '...';
    } else {
        $chopped = $name;
    }

    return $chopped;
}

/**
 * @param array $field_list
 * @param array $values
 * @param array $bean
 * @param bool $add_custom_fields
 * @param string $module
 * @return array
 */
function generate_search_where(
    $field_list,
    $values,
    &$bean = null,
    $add_custom_fields = false,
    $module = ''
) {
    $where_clauses = array();
    $like_char = '%';
    $table_name = $bean->object_name;
    foreach ($field_list[$module] as $field => $parms) {
        if (isset($values[$field]) && $values[$field] != '') {
            $operator = 'like';
            if (!empty($parms['operator'])) {
                $operator = $parms['operator'];
            }
            if (is_array($values[$field])) {
                $operator = 'in';
                $field_value = '';
                foreach ($values[$field] as $key => $val) {
                    if ($val != ' ' && $val != '') {
                        if (!empty($field_value)) {
                            $field_value .= ',';
                        }
                        $field_value .= ""'"" . DBManagerFactory::getInstance()->quote($val) . ""'"";
                    }
                }
            } else {
                $field_value = DBManagerFactory::getInstance()->quote($values[$field]);
            }
            //set db_fields array.
            if (!isset($parms['db_field'])) {
                $parms['db_field'] = array($field);
            }
            if (isset($parms['my_items']) && $parms['my_items'] == true) {
                global $current_user;
                $field_value = DBManagerFactory::getInstance()->quote($current_user->id);
                $operator = '=';
            }

            $where = '';
            $itr = 0;
            if ($field_value != '') {
                foreach ($parms['db_field'] as $db_field) {
                    if (strstr((string) $db_field, '.') === false) {
                        $db_field = $bean->table_name . '.' . $db_field;
                    }
                    if (DBManagerFactory::getInstance()->supports('case_sensitive') && isset($parms['query_type']) && $parms['query_type'] == 'case_insensitive') {
                        $db_field = 'upper(' . $db_field . ')';
                        $field_value = strtoupper($field_value);
                    }

                    ++$itr;
                    if (!empty($where)) {
                        $where .= ' OR ';
                    }
                    switch (strtolower($operator)) {
                        case 'like':
                            $where .= $db_field . "" like '"" . $field_value . $like_char . ""'"";
                            break;
                        case 'in':
                            $where .= $db_field . ' in (' . $field_value . ')';
                            break;
                        case '=':
                            $where .= $db_field . "" = '"" . $field_value . ""'"";
                            break;
                    }
                }
            }
            if (!empty($where)) {
                if ($itr > 1) {
                    array_push($where_clauses, '( ' . $where . ' )');
                } else {
                    array_push($where_clauses, $where);
                }
            }
        }
    }
    if ($add_custom_fields) {
        require_once 'modules/DynamicFields/DynamicField.php';
        $bean->setupCustomFields($module);
        $bean->custom_fields->setWhereClauses($where_clauses);
    }

    return $where_clauses;
}

/**
 * @deprecated This function is unused and will be removed in a future release.
 */
function add_quotes($str)
{
    return ""'{$str}'"";
}

/**
 * This function will rebuild the config file.
 *
 * @param   $sugar_config
 * @param   $sugar_version
 *
 * @return bool true if successful
 */
function rebuildConfigFile($sugar_config, $sugar_version)
{
    // add defaults to missing values of in-memory sugar_config
    $sugar_config = sugarArrayMerge(get_sugar_config_defaults(), $sugar_config);
    // need to override version with default no matter what
    $sugar_config['sugar_version'] = $sugar_version;

    ksort($sugar_config);

    if (write_array_to_file('sugar_config', $sugar_config, 'config.php')) {
        return true;
    }
    return false;
}

/**
 * Loads clean configuration, not overridden by config_override.php.
 *
 * @return array
 */
function loadCleanConfig()
{
    $sugar_config = array();
    require 'config.php';

    return $sugar_config;
}

/**
 * getJavascriptSiteURL
 * This function returns a URL for the client javascript calls to access
 * the site.  It uses $_SERVER['HTTP_REFERER'] in the event that Proxy servers
 * are used to access the site.  Thus, the hostname in the URL returned may
 * not always match that of $sugar_config['site_url'].  Basically, the
 * assumption is that however the user accessed the website is how they
 * will continue to with subsequent javascript requests.  If the variable
 * $_SERVER['HTTP_REFERER'] is not found then we default to old algorithm.
 *
 * @return $site_url The url used to refer to the website
 */
function getJavascriptSiteURL()
{
    global $sugar_config;
    if (!empty($_SERVER['HTTP_REFERER'])) {
        $url = parse_url((string) $_SERVER['HTTP_REFERER']);
        $replacement_url = $url['scheme'] . '://' . $url['host'];
        if (!empty($url['port'])) {
            $replacement_url .= ':' . $url['port'];
        }
        $site_url = preg_replace('/^http[s]?\:\/\/[^\/]+/', $replacement_url, (string) $sugar_config['site_url']);
    } else {
        $site_url = preg_replace('/^http(s)?\:\/\/[^\/]+/', 'http$1://' . $_SERVER['HTTP_HOST'], (string) $sugar_config['site_url']);
        if (!empty($_SERVER['SERVER_PORT']) && $_SERVER['SERVER_PORT'] == '443') {
            $site_url = preg_replace('/^http\:/', 'https:', $site_url);
        }
    }
    $GLOBALS['log']->debug('getJavascriptSiteURL(), site_url=' . $site_url);

    return $site_url;
}


/**
 * Works nicely with array_map() -- can be used to wrap single quotes around
 * each element in an array.
 *
 * @deprecated This function is unused and will be removed in a future release.
 */
function add_squotes($str)
{
    return ""'"" . $str . ""'"";
}


/**
 * Recursive function to count the number of levels within an array.
 * @deprecated This function is unused and will be removed in a future release.
 */
function array_depth($array, $depth_count = -1, $depth_array = array())
{
    ++$depth_count;
    if (is_array($array)) {
        foreach ($array as $key => $value) {
            $depth_array[] = array_depth($value, $depth_count);
        }
    } else {
        return $depth_count;
    }
    foreach ($depth_array as $value) {
        $depth_count = $value > $depth_count ? $value : $depth_count;
    }

    return $depth_count;
}

/**
 * Creates a new Group User.
 *
 * @param string $name Name of Group User
 *
 * @return string GUID of new Group User
 */
function createGroupUser($name)
{
    $group = BeanFactory::newBean('Users');
    $group->user_name = $name;
    $group->last_name = $name;
    $group->is_group = 1;
    $group->deleted = 0;
    $group->status = 'Active'; // cn: bug 6711
    $group->setPreference('timezone', TimeDate::userTimezone());
    $group->save();

    return $group->id;
}

/*
 * Helper function to locate an icon file given only a name
 * Searches through the various paths for the file
 * @param string iconFileName   The filename of the icon
 * @return string Relative pathname of the located icon, or '' if not found
 */

function _getIcon($iconFileName)
{
    if (file_exists(SugarThemeRegistry::current()->getImagePath() . DIRECTORY_SEPARATOR . 'icon_' . $iconFileName . '.svg')) {
        $iconName = ""icon_{$iconFileName}.svg"";
        $iconFound = SugarThemeRegistry::current()->getImageURL($iconName, false);
    } else {
        $iconName = ""icon_{$iconFileName}.gif"";
        $iconFound = SugarThemeRegistry::current()->getImageURL($iconName, false);
    }



    //First try un-ucfirst-ing the icon name
    if (empty($iconFound)) {
        $iconName = 'icon_' . strtolower(substr((string) $iconFileName, 0, 1)) . substr((string) $iconFileName, 1) . '.gif';
    }
    $iconFound = SugarThemeRegistry::current()->getImageURL($iconName, false);

    //Next try removing the icon prefix
    if (empty($iconFound)) {
        $iconName = ""{$iconFileName}.gif"";
    }
    $iconFound = SugarThemeRegistry::current()->getImageURL($iconName, false);

    if (empty($iconFound)) {
        $iconName = '';
    }

    return $iconName;
}

/**
 * Function to grab the correct icon image for Studio.
 *
 * @param string $iconFileName Name of the icon file
 * @param string $altfilename  Name of a fallback icon file (displayed if the imagefilename doesn't exist)
 * @param string $width        Width of image
 * @param string $height       Height of image
 * @param string $align        Alignment of image
 * @param string $alt          Alt tag of image
 *
 * @return string $string <img> tag with corresponding image
 */
function getStudioIcon($iconFileName = '', $altFileName = '', $width = '48', $height = '48', $align = 'baseline', $alt = '')
{
    global $app_strings, $theme;

    $iconName = _getIcon($iconFileName);
    if (empty($iconName)) {
        $iconName = _getIcon($altFileName);
        if (empty($iconName)) {
            return $app_strings['LBL_NO_IMAGE'];
        }
    }

    return SugarThemeRegistry::current()->getImage($iconName, ""align=\""$align\"" border=\""0\"""", $width, $height);
}

/**
 * Function to grab the correct icon image for Dashlets Dialog.
 *
 * @param string $filename Location of the icon file
 * @param string $module   Name of the module to fall back onto if file does not exist
 * @param string $width    Width of image
 * @param string $height   Height of image
 * @param string $align    Alignment of image
 * @param string $alt      Alt tag of image
 *
 * @return string $string <img> tag with corresponding image
 */
function get_dashlets_dialog_icon($module = '', $width = '32', $height = '32', $align = 'absmiddle', $alt = '')
{
    global $app_strings, $theme;
    $iconName = _getIcon($module . '_32');
    if (empty($iconName)) {
        $iconName = _getIcon($module);
    }
    if (empty($iconName)) {
        return $app_strings['LBL_NO_IMAGE'];
    }

    return $iconName;
}

// works nicely to change UTF8 strings that are html entities - good for PDF conversions
function html_entity_decode_utf8($string)
{
    static $trans_tbl;
    // replace numeric entities
    //php will have issues with numbers with leading zeros, so do not include them in what we send to code2utf.

    $string = preg_replace_callback('~&#x0*([0-9a-f]+);~i', function ($matches) {
        return code2utf(hexdec($matches[1]));
    }, (string) $string);
    $string = preg_replace_callback('~&#0*([0-9]+);~', function ($matches) {
        return code2utf($matches[1]);
    }, $string);

    // replace literal entities
    if (!isset($trans_tbl)) {
        $trans_tbl = array();
        foreach (get_html_translation_table(HTML_ENTITIES) as $val => $key) {
            $trans_tbl[$key] = mb_convert_encoding($val, 'UTF-8', 'ISO-8859-1');
        }
    }

    return strtr($string, $trans_tbl);
}

// Returns the utf string corresponding to the unicode value
function code2utf($num)
{
    if ($num < 128) {
        return chr($num);
    }
    if ($num < 2048) {
        return chr(($num >> 6) + 192) . chr(($num & 63) + 128);
    }
    if ($num < 65536) {
        return chr(($num >> 12) + 224) . chr((($num >> 6) & 63) + 128) . chr(($num & 63) + 128);
    }
    if ($num < 2097152) {
        return chr(($num >> 18) + 240) . chr((($num >> 12) & 63) + 128) . chr((($num >> 6) & 63) + 128) . chr(($num & 63) + 128);
    }

    return '';
}

/*
 * @deprecated use DBManagerFactory::isFreeTDS
 */

function is_freetds()
{
    return DBManagerFactory::isFreeTDS();
}

/**
 * Chart dashlet helper function that returns the correct CSS file, dependent on the current theme.
 *
 * @deprecated This function is unused and will be removed in a future release.
 *
 * @todo this won't work completely right until we impliment css compression and combination
 *       for now, we'll just include the last css file found.
 *
 * @return chart.css file to use
 */
function chartStyle()
{
    return SugarThemeRegistry::current()->getCSSURL('chart.css');
}

/**
 * Chart dashlet helper functions that returns the correct XML color file for charts,
 * dependent on the current theme.
 *
 * @deprecated This function is unused and will be removed in a future release.
 * @return sugarColors.xml to use
 */
function chartColors()
{
    if (SugarThemeRegistry::current()->getCSSURL('sugarColors.xml') == '') {
        return SugarThemeRegistry::current()->getImageURL('sugarColors.xml');
    }

    return SugarThemeRegistry::current()->getCSSURL('sugarColors.xml');
}

/* End Chart Dashlet helper functions */

/**
 * This function is designed to set up the php enviroment
 * for AJAX requests.
 *
 * @deprecated This function is unused and will be removed in a future release.
 */
function ajaxInit()
{
    //ini_set('display_errors', 'false');
}

/**
 * Returns an absolute path from the given path, determining if it is relative or absolute.
 *
 * @param string $path
 *
 * @return string
 */
function getAbsolutePath(
    $path,
    $currentServer = false
) {
    $path = trim($path);

    // try to match absolute paths like \\server\share, /directory or c:\
    if ((substr($path, 0, 2) == '\\\\') || ($path[0] == '/') || preg_match('/^[A-z]:/i', $path) || $currentServer
    ) {
        return $path;
    }

    return getcwd() . '/' . $path;
}

/**
 * Returns the bean object of the given module.
 *
 * @deprecated use SugarModule::loadBean() instead
 *
 * @param string $module
 *
 * @return object
 */
function loadBean(
    $module
) {
    return SugarModule::get($module)->loadBean();
}

/**
 * Returns true if the application is being accessed on a touch screen interface ( like an iPad ).
 */
function isTouchScreen()
{
    $ua = empty($_SERVER['HTTP_USER_AGENT']) ? 'undefined' : strtolower($_SERVER['HTTP_USER_AGENT']);

    // first check if we have forced use of the touch enhanced interface
    if (isset($_COOKIE['touchscreen']) && $_COOKIE['touchscreen'] == '1') {
        return true;
    }

    // next check if we should use the touch interface with our device
    if (strpos($ua, 'ipad') !== false) {
        return true;
    }

    return false;
}

/**
 * Returns the shortcut keys to access the shortcut links.  Shortcut
 * keys vary depending on browser versions and operating systems.
 *
 * @return string value of the shortcut keys
 */
function get_alt_hot_key()
{
    $ua = '';
    if (isset($_SERVER['HTTP_USER_AGENT'])) {
        $ua = strtolower($_SERVER['HTTP_USER_AGENT']);
    }
    $isMac = strpos($ua, 'mac') !== false;
    $isLinux = strpos($ua, 'linux') !== false;

    if (!$isMac && !$isLinux && strpos($ua, 'mozilla') !== false) {
        if (preg_match('/firefox\/(\d)?\./', $ua, $matches)) {
            return $matches[1] < 2 ? 'Alt+' : 'Alt+Shift+';
        }
    }

    return $isMac ? 'Ctrl+' : 'Alt+';
}

function can_start_session()
{
    if (!empty($_GET['PHPSESSID'])) {
        return true;
    }
    $session_id = session_id();

    return empty($session_id) ? true : false;
}

function load_link_class($properties)
{
    $class = 'Link2';
    if (!empty($properties['link_class']) && !empty($properties['link_file'])) {
        if (!file_exists($properties['link_file'])) {
            $GLOBALS['log']->fatal('File not found: ' . $properties['link_file']);
        } else {
            require_once $properties['link_file'];
            $class = $properties['link_class'];
        }
    }

    return $class;
}

function inDeveloperMode()
{
    return isset($GLOBALS['sugar_config']['developerMode']) && $GLOBALS['sugar_config']['developerMode'];
}

/**
 * Filter the protocol list for inbound email accounts.
 *
 * @param array $protocol
 */
function filterInboundEmailPopSelection($protocol)
{
    if (!isset($GLOBALS['sugar_config']['allow_pop_inbound']) || !$GLOBALS['sugar_config']['allow_pop_inbound']) {
        if (isset($protocol['pop3'])) {
            unset($protocol['pop3']);
        }
    } else {
        $protocol['pop3'] = 'POP3';
    }

    return $protocol;
}

/**
 * Get Inbound Email protocols
 *
 * @return array
 */
function getInboundEmailProtocols(): array
{
    global $app_list_strings, $sugar_config;

    $protocols = $app_list_strings['dom_email_server_type'];
    if (!isset($sugar_config['allow_pop_inbound']) || !$sugar_config['allow_pop_inbound']) {
        if (isset($protocols['pop3'])) {
            unset($protocols['pop3']);
        }
    } else {
        $protocols['pop3'] = 'POP3';
    }

    return $protocols;
}

/**
 * The function is used because currently we are not supporting mbstring.func_overload
 * For some user using mssql without FreeTDS, they may store multibyte charaters in varchar using latin_general collation. It cannot store so many mutilbyte characters, so we need to use strlen.
 * The varchar in MySQL, Orcale, and nvarchar in FreeTDS, we can store $length mutilbyte charaters in it. we need mb_substr to keep more info.
 *
 * @returns the substred strings.
 */
function sugar_substr($string, $length, $charset = 'UTF-8')
{
    if (mb_strlen($string, $charset) > $length) {
        $string = trim(mb_substr(trim($string), 0, $length, $charset));
    }

    return $string;
}

/**
 * The function is used because on FastCGI enviroment, the ucfirst(Chinese Characters) will produce bad charcters.
 * This will work even without setting the mbstring.*encoding.
 */
function sugar_ucfirst($string, $charset = 'UTF-8')
{
    return mb_strtoupper(mb_substr($string, 0, 1, $charset), $charset) . mb_substr($string, 1, mb_strlen($string), $charset);
}

/**
 * Given a multienum encoded as a string, convert it to an array of strings,
 * e.g. `""^Monday^,^Tuesday^,^Wednesday^,^Thursday^""` becomes
 * `[""Monday"", ""Tuesday"", ""Wednesday"", ""Thursday""]`.
 *
 * @param string|string[] $string The encoded multienum value. If this is already an array, the array will be returned unchanged.
 * @return string[] An array of strings representing the multienum's values.
 */
function unencodeMultienum($string)
{
    if (is_array($string)) {
        return $string;
    }
    if (substr($string, 0, 1) == '^' && substr($string, -1) == '^') {
        $string = substr(substr($string, 1), 0, strlen($string) - 2);
    }

    return explode('^,^', $string);
}

function encodeMultienumValue($arr)
{
    if (!is_array($arr)) {
        return $arr;
    }

    if (empty($arr)) {
        return '';
    }

    $string = '^' . implode('^,^', $arr) . '^';

    return $string;
}

/**
 * create_export_query is used for export and massupdate
 * We haven't handle the these fields: $field['type'] == 'relate' && isset($field['link']
 * This function will correct the where clause and output necessary join condition for them.
 *
 * @param $module : the module name
 * @param $searchFields : searchFields which is got after $searchForm->populateFromArray()
 * @param $where : where clauses
 *
 * @return array
 */
function create_export_query_relate_link_patch($module, $searchFields, $where)
{
    $ret_array = [];
    $join = [];
    if (file_exists('modules/' . $module . '/SearchForm.html')) {
        $ret_array['where'] = $where;

        return $ret_array;
    }
    $seed = BeanFactory::getBean($module);
    foreach ($seed->field_defs as $name => $field) {
        if ($field['type'] == 'relate' && isset($field['link']) && !empty($searchFields[$name]['value'])) {
            $seed->load_relationship($field['link']);
            $params = array();
            if (empty($join_type)) {
                $params['join_type'] = ' LEFT JOIN ';
            } else {
                $params['join_type'] = $join_type;
            }
            if (isset($data['join_name'])) {
                $params['join_table_alias'] = $field['join_name'];
            } else {
                $params['join_table_alias'] = 'join_' . $field['name'];
            }
            if (isset($data['join_link_name'])) {
                $params['join_table_link_alias'] = $field['join_link_name'];
            } else {
                $params['join_table_link_alias'] = 'join_link_' . $field['name'];
            }
            $fieldLink = $field['link'];
            $join = $seed->$fieldLink->getJoin($params, true);
            $join_table_alias = 'join_' . $field['name'];
            if (isset($field['db_concat_fields'])) {
                $db_field = DBManager::concat($join_table_alias, $field['db_concat_fields']);
                $where = preg_replace('/' . $field['name'] . '/', $db_field, (string) $where);
            } else {
                $where = preg_replace('/(^|[\s(])' . $field['name'] . '/', '${1}' . $join_table_alias . '.' . $field['rname'], (string) $where);
            }
        }
    }
    $ret_array = array('where' => $where, 'join' => isset($join['join']) ? $join['join'] : '');

    return $ret_array;
}

/**
 * We need to clear all the js cache files, including the js language files  in serval places in MB. So I extract them into a util function here.
 *
 * @Depends on QuickRepairAndRebuild.php
 * @Relate bug 30642  ,23177
 */
function clearAllJsAndJsLangFilesWithoutOutput()
{
    global $current_language, $mod_strings;
    $MBmodStrings = $mod_strings;
    $mod_strings = return_module_language($current_language, 'Administration');
    include_once 'modules/Administration/QuickRepairAndRebuild.php';
    $repair = new RepairAndClear();
    $repair->module_list = array();
    $repair->show_output = false;
    $repair->clearJsLangFiles();
    $repair->clearJsFiles();
    $mod_strings = $MBmodStrings;
}

/**
 * This function will allow you to get a variable value from query string.
 */
function getVariableFromQueryString($variable, $string)
{
    $matches = array();
    $number = preg_match(""/{$variable}=([a-zA-Z0-9_-]+)[&]?/"", (string) $string, $matches);
    if ($number) {
        return $matches[1];
    }
    return false;
}

/**
 * should_hide_iframes
 * This is a helper method to determine whether or not to show iframes (My Sites) related
 * information in the application.
 *
 * @return bool flag indicating whether or not iframes module should be hidden
 */
function should_hide_iframes()
{
    //Remove the MySites module
    if (file_exists('modules/iFrames/iFrame.php')) {
        if (!class_exists('iFrame')) {
            require_once 'modules/iFrames/iFrame.php';
        }

        return false;
    }

    return true;
}

/**
 * Given a version such as 5.5.0RC1 return RC. If we have a version such as: 5.5 then return GA.
 *
 * @deprecated This function is unused and will be removed in a future release.
 *
 * @param string $version
 * @return string RC, BETA, GA
 */
function getVersionStatus($version)
{
    if (preg_match('/^[\d\.]+?([a-zA-Z]+?)[\d]*?$/si', $version, $matches)) {
        return strtoupper($matches[1]);
    }
    return 'GA';
}

/**
 * Return the numeric portion of a version. For example if passed 5.5.0RC1 then return 5.5. If given
 * 5.5.1RC1 then return 5.5.1.
 *
 * @deprecated This function is unused and will be removed in a future release.
 *
 * @param string $version
 *
 * @return version
 */
function getMajorMinorVersion($version)
{
    if (preg_match('/^([\d\.]+).*$/si', $version, $matches2)) {
        $version = $matches2[1];
        $arr = explode('.', $version);
        if (count($arr) > 2) {
            if ($arr[2] == '0') {
                $version = substr($version, 0, 3);
            }
        }
    }

    return $version;
}

/**
 * Return string composed of seconds & microseconds of current time, without dots.
 *
 * @return string
 */
function sugar_microtime()
{
    $now = explode(' ', microtime());
    $unique_id = $now[1] . str_replace('.', '', $now[0]);

    return $unique_id;
}

/**
 * Extract urls from a piece of text.
 *
 * @param  $string
 *
 * @return array of urls found in $string
 */
function getUrls($string)
{
    $lines = explode('<br>', trim($string));
    $urls = array();
    foreach ($lines as $line) {
        $regex = '/http?\:\/\/[^\"" ]+/i';
        preg_match_all($regex, $line, $matches);
        foreach ($matches[0] as $match) {
            $urls[] = $match;
        }
    }

    return $urls;
}

/**
 * Sanitize image file from hostile content.
 *
 * @param string $path Image file
 * @param bool   $jpeg Accept only JPEGs?
 */
function verify_image_file($path, $jpeg = false)
{
    if (function_exists('imagepng') && function_exists('imagejpeg') && function_exists('imagecreatefromstring')) {
        $img = imagecreatefromstring(file_get_contents($path));
        if (!$img) {
            return false;
        }
        $img_size = getimagesize($path);
        $filetype = $img_size['mime'];
        //if filetype is jpeg or if we are only allowing jpegs, create jpg image
        if ($filetype == 'image/jpeg' || $jpeg) {
            ob_start();
            imagejpeg($img);
            $image = ob_get_clean();
            // not writing directly because imagejpeg does not work with streams
            if (file_put_contents($path, $image)) {
                return true;
            }
        } elseif ($filetype == 'image/png') {
            // else if the filetype is png, create png
            imagealphablending($img, true);
            imagesavealpha($img, true);
            ob_start();
            imagepng($img);
            $image = ob_get_clean();
            if (file_put_contents($path, $image)) {
                return true;
            }
        } else {
            return false;
        }
    } else {
        // check image manually
        $fp = fopen($path, 'rb');
        if (!$fp) {
            return false;
        }
        $data = '';
        // read the whole file in chunks
        while (!feof($fp)) {
            $data .= fread($fp, 8192);
        }

        fclose($fp);
        if (preg_match(""/<(\?php|html|!doctype|script|body|head|plaintext|table|img |pre(>| )|frameset|iframe|object|link|base|style|font|applet|meta|center|form|isindex)/i"", $data, $m)) {
            $GLOBALS['log']->fatal(""Found {$m[0]} in $path, not allowing upload"");

            return false;
        }

        return true;
    }

    return false;
}

/**
 * Verify uploaded image
 * Verifies that image has proper extension, MIME type and doesn't contain hostile content.
 *
 * @param string $path      Image path
 * @param bool   $jpeg_only Accept only JPEGs?
 */
function verify_uploaded_image($path, $jpeg_only = false)
{
    $supportedExtensions = array('jpg' => 'image/jpeg', 'jpeg' => 'image/jpeg', 'tmp' => 'tmp');
    if (!$jpeg_only) {
        $supportedExtensions['png'] = 'image/png';
    }

    if (!file_exists($path) || !is_file($path)) {
        return false;
    }

    $img_size = getimagesize($path);
    $filetype = $img_size['mime'];
    $tmpArray = explode('.', $path);
    $ext = end($tmpArray);
    if (substr_count('..', $path) > 0 || ($ext !== $path && !isset($supportedExtensions[strtolower($ext)])) ||
            !in_array($filetype, array_values($supportedExtensions))
    ) {
        return false;
    }

    return verify_image_file($path, $jpeg_only);
}

function cmp_beans($a, $b)
{
    global $sugar_web_service_order_by;
    //If the order_by field is not valid, return 0;
    if (empty($sugar_web_service_order_by) || !isset($a->$sugar_web_service_order_by) || !isset($b->$sugar_web_service_order_by)) {
        return 0;
    }
    if (is_object($a->$sugar_web_service_order_by) || is_object($b->$sugar_web_service_order_by) || is_array($a->$sugar_web_service_order_by) || is_array($b->$sugar_web_service_order_by)
    ) {
        return 0;
    }
    if ($a->$sugar_web_service_order_by < $b->$sugar_web_service_order_by) {
        return -1;
    }
    return 1;
}

function order_beans($beans, $field_name)
{
    //Since php 5.2 doesn't include closures, we must use a global to pass the order field to cmp_beans.
    global $sugar_web_service_order_by;
    $sugar_web_service_order_by = $field_name;
    usort($beans, 'cmp_beans');

    return $beans;
}

/**
 * Return search like string
 * This function takes a user input string and returns a string that contains wild card(s) that can be used in db query.
 *
 * @param string $str       string to be searched
 * @param string $like_char Database like character, usually '%'
 *
 * @return string Returns a string to be searched in db query
 */
function sql_like_string($str, $like_char, $wildcard = '%', $appendWildcard = true)
{

    // override default wildcard character
    if (isset($GLOBALS['sugar_config']['search_wildcard_char']) &&
            strlen((string) $GLOBALS['sugar_config']['search_wildcard_char']) == 1
    ) {
        $wildcard = $GLOBALS['sugar_config']['search_wildcard_char'];
    }

    // add wildcard at the beginning of the search string
    if (isset($GLOBALS['sugar_config']['search_wildcard_infront']) &&
            $GLOBALS['sugar_config']['search_wildcard_infront'] == true
    ) {
        if (substr($str, 0, 1) != $wildcard) {
            $str = $wildcard . $str;
        }
    }

    // add wildcard at the end of search string (default)
    if ($appendWildcard) {
        if (substr($str, -1) != $wildcard) {
            $str .= $wildcard;
        }
    }

    return str_replace($wildcard, $like_char, $str);
}

//check to see if custom utils exists
if (file_exists('custom/include/custom_utils.php')) {
    include_once 'custom/include/custom_utils.php';
}

//check to see if custom utils exists in Extension framework
if (file_exists('custom/application/Ext/Utils/custom_utils.ext.php')) {
    include_once 'custom/application/Ext/Utils/custom_utils.ext.php';
}

/**
 * @param $input - the input string to sanitize
 * @param int    $quotes  - use quotes
 * @param string $charset - the default charset
 * @param bool   $remove  - strip tags or not
 *
 * @return string - the sanitized string
 */
function sanitize($input, $quotes = ENT_QUOTES, $charset = 'UTF-8', $remove = false)
{
    return htmlentities((string) $input, $quotes, $charset);
}

/**
 * @return string - the full text search engine name
 */
function getFTSEngineType()
{
    if (isset($GLOBALS['sugar_config']['full_text_engine']) && is_array($GLOBALS['sugar_config']['full_text_engine'])) {
        foreach ($GLOBALS['sugar_config']['full_text_engine'] as $name => $defs) {
            return $name;
        }
    }

    return '';
}

/**
 * @deprecated This function is unused and will be removed in a future release.
 *
 * @param string $optionName - name of the option to be retrieved from app_list_strings
 * @return array - the array to be used in option element
 */
function getFTSBoostOptions($optionName)
{
    if (isset($GLOBALS['app_list_strings'][$optionName])) {
        return $GLOBALS['app_list_strings'][$optionName];
    }
    return array();
}

/**
 * utf8_recursive_encode.
 *
 * This function walks through an Array and recursively calls utf8_encode on the
 * values of each of the elements.
 *
 * @deprecated This function is unused and will be removed in a future release.
 *
 * @param $data Array of data to encode
 *
 * @return utf8 encoded Array data
 */
function utf8_recursive_encode($data)
{
    $result = array();
    foreach ($data as $key => $val) {
        if (is_array($val)) {
            $result[$key] = utf8_recursive_encode($val);
        } else {
            $result[$key] = mb_convert_encoding($val, 'UTF-8', 'ISO-8859-1');
        }
    }

    return $result;
}

/**
 * get_language_header.
 *
 * This is a utility function for 508 Compliance.  It returns the lang=[Current Language] text string used
 * inside the <html> tag.  If no current language is specified, it defaults to lang='en'.
 *
 * @return string The lang=[Current Language] markup to insert into the <html> tag
 */
function get_language_header()
{
    return isset($GLOBALS['current_language']) ? ""lang='{$GLOBALS['current_language']}'"" : ""lang='en'"";
}

/**
 * get_custom_file_if_exists.
 *
 * This function handles the repetitive code we have where we first check if a file exists in the
 * custom directory to determine whether we should load it, require it, include it, etc.  This function returns the
 * path of the custom file if it exists.  It basically checks if custom/{$file} exists and returns this path if so;
 * otherwise it return $file
 *
 * @param $file String of filename to check
 *
 * @return $file String of filename including custom directory if found
 */
function get_custom_file_if_exists($file)
{
    return file_exists(""custom/{$file}"") ? ""custom/{$file}"" : $file;
}

/**
 * get_help_url.
 *
 * This will return the URL used to redirect the user to the help documentation.
 * It can be overriden completely by setting the custom_help_url or partially by setting the custom_help_base_url
 * in config.php or config_override.php.
 *
 * @deprecated This function is unused and will be removed in a future release.
 *
 * @param string $send_edition
 * @param string $send_version
 * @param string $send_lang
 * @param string $send_module
 * @param string $send_action
 * @param string $dev_status
 * @param string $send_key
 * @param string $send_anchor
 *
 * @return string the completed help URL
 */
function get_help_url($send_edition = '', $send_version = '', $send_lang = '', $send_module = '', $send_action = '', $dev_status = '', $send_key = '', $send_anchor = '')
{
    global $sugar_config;

    if (!empty($sugar_config['custom_help_url'])) {
        $sendUrl = $sugar_config['custom_help_url'];
    } else {
        if (!empty($sugar_config['custom_help_base_url'])) {
            $baseUrl = $sugar_config['custom_help_base_url'];
        } else {
            $baseUrl = 'http://www.sugarcrm.com/crm/product_doc.php';
        }
        $sendUrl = $baseUrl . ""?edition={$send_edition}&version={$send_version}&lang={$send_lang}&module={$send_module}&help_action={$send_action}&status={$dev_status}&key={$send_key}"";
        if (!empty($send_anchor)) {
            $sendUrl .= '&anchor=' . $send_anchor;
        }
    }

    return $sendUrl;
}

/**
 * generateETagHeader.
 *
 * This function generates the necessary cache headers for using ETags with dynamic content. You
 * simply have to generate the ETag, pass it in, and the function handles the rest.
 *
 * @param string $etag ETag to use for this content.
 */
function generateETagHeader($etag)
{
    header('cache-control:');
    header('Expires: ');
    header('ETag: ' . $etag);
    header('Pragma:');
    if (isset($_SERVER['HTTP_IF_NONE_MATCH'])) {
        if ($etag == $_SERVER['HTTP_IF_NONE_MATCH']) {
            ob_clean();
            header('Status: 304 Not Modified');
            header('HTTP/1.0 304 Not Modified');
            die();
        }
    }
}

/**
 * getReportNameTranslation.
 *
 * Translates the report name if a translation exists,
 * otherwise just returns the name
 *
 * @param string $reportName
 *
 * @return string translated report name
 */
function getReportNameTranslation($reportName)
{
    global $current_language;

    // Used for translating reports
    $mod_strings = return_module_language($current_language, 'Reports');

    // Search for the report name in the default language and get the key
    $key = array_search($reportName, return_module_language('', 'Reports'), true);

    // If the key was found, use it to get a translation, otherwise just use report name
    if (!empty($key)) {
        $title = $mod_strings[$key];
    } else {
        $title = $reportName;
    }

    return $title;
}

/**
 * Remove vars marked senstitive from array.
 *
 * @param array           $defs
 * @param SugarBean|array $data
 *
 * @return mixed $data without sensitive fields
 */
function clean_sensitive_data($defs, $data)
{
    foreach ($defs as $field => $def) {
        if (!empty($def['sensitive'])) {
            if (is_array($data)) {
                $data[$field] = '';
            }
            if ($data instanceof SugarBean) {
                $data->$field = '';
            }
        }
    }

    return $data;
}

/**
 * Return relations with labels for duplicates.
 *
 * @deprecated This function is unused and will be removed in a future release.
 */
function getDuplicateRelationListWithTitle($def, $var_def, $module)
{
    global $current_language;
    $select_array = array_unique($def);
    if (count($select_array) < (is_countable($def) ? count($def) : 0)) {
        $temp_module_strings = return_module_language($current_language, $module);
        $temp_duplicate_array = array_diff_assoc($def, $select_array);
        $temp_duplicate_array = array_merge($temp_duplicate_array, array_intersect($select_array, $temp_duplicate_array));

        foreach ($temp_duplicate_array as $temp_key => $temp_value) {
            // Don't add duplicate relationships
            if (!empty($var_def[$temp_key]['relationship']) && array_key_exists($var_def[$temp_key]['relationship'], $select_array)) {
                continue;
            }
            $select_array[$temp_key] = $temp_value;
        }

        // Add the relationship name for easier recognition
        foreach ($select_array as $key => $value) {
            $select_array[$key] .= ' (' . $key . ')';
        }
    }
    asort($select_array);

    return $select_array;
}

/**
 * Gets the list of ""*type_display*"".
 *
 * @return array
 */
function getTypeDisplayList()
{
    return array('record_type_display', 'parent_type_display', 'record_type_display_notes');
}

/**
 * Breaks given string into substring according
 * to 'db_concat_fields' from field definition
 * and assigns values to corresponding properties
 * of bean.
 *
 * @param SugarBean $bean
 * @param array     $fieldDef
 * @param string    $value
 */
function assignConcatenatedValue(SugarBean $bean, $fieldDef, $value)
{
    $fieldName = '';
    $valueParts = explode(' ', $value);
    $valueParts = array_filter($valueParts);
    $fieldNum = is_countable($fieldDef['db_concat_fields']) ? count($fieldDef['db_concat_fields']) : 0;

    if (count($valueParts) == 1 && $fieldDef['db_concat_fields'] == array('first_name', 'last_name')) {
        $bean->last_name = $value;
    } // elseif ($fieldNum >= count($valueParts))
    else {
        for ($i = 0; $i < $fieldNum; ++$i) {
            $fieldValue = array_shift($valueParts);
            $fieldName = $fieldDef['db_concat_fields'][$i];
            $bean->$fieldName = $fieldValue !== false ? $fieldValue : '';
        }

        if (!empty($valueParts)) {
            $bean->$fieldName .= ' ' . implode(' ', $valueParts);
        }
    }
}

/**
 * Performs unserialization. Accepts all types except Objects.
 *
 * @param string $value Serialized value of any type except Object
 *
 * @return mixed False if Object, converted value for other cases
 */
function sugar_unserialize($value)
{
    preg_match('/[oc]:[^:]*\d+:/i', $value, $matches);

    if (count($matches)) {
        return false;
    }

    return unserialize($value);
}

define('DEFAULT_UTIL_SUITE_ENCODING', 'UTF-8');

/**
 * @deprecated This function is unused and will be removed in a future release.
 */
function suite_strlen($input, $encoding = DEFAULT_UTIL_SUITE_ENCODING)
{
    if (function_exists('mb_strlen')) {
        return mb_strlen($input, $encoding);
    }
    return strlen((string) $input);
}

/**
 * @deprecated This function is unused and will be removed in a future release.
 */
function suite_substr($input, $start, $length = null, $encoding = DEFAULT_UTIL_SUITE_ENCODING)
{
    if (function_exists('mb_substr')) {
        return mb_substr($input, $start, $length, $encoding);
    }
    return substr((string) $input, $start, $length);
}

/**
 * @deprecated This function is unused and will be removed in a future release.
 */
function suite_strtoupper($input, $encoding = DEFAULT_UTIL_SUITE_ENCODING)
{
    if (function_exists('mb_strtoupper')) {
        return mb_strtoupper($input, $encoding);
    }
    return strtoupper($input);
}

/**
 * @deprecated This function is unused and will be removed in a future release.
 */
function suite_strtolower($input, $encoding = DEFAULT_UTIL_SUITE_ENCODING)
{
    if (function_exists('mb_strtolower')) {
        return mb_strtolower($input, $encoding);
    }
    return strtolower($input);
}

/**
 * @deprecated This function is unused and will be removed in a future release.
 */
function suite_strpos($haystack, $needle, $offset = 0, $encoding = DEFAULT_UTIL_SUITE_ENCODING)
{
    if (function_exists('mb_strpos')) {
        return mb_strpos((string) $haystack, (string) $needle, $offset, $encoding);
    }
    return strpos((string) $haystack, (string) $needle, $offset);
}

/**
 * @deprecated This function is unused and will be removed in a future release.
 */
function suite_strrpos($haystack, $needle, $offset = 0, $encoding = DEFAULT_UTIL_SUITE_ENCODING)
{
    if (function_exists('mb_strrpos')) {
        return mb_strrpos((string) $haystack, (string) $needle, $offset, $encoding);
    }
    return strrpos((string) $haystack, (string) $needle, $offset);
}

/**
 * @deprecated deprecated since version 7.10 please use the SuiteValidator class
 */
function isValidId($id)
{
    $deprecatedMessage = 'isValidId method is deprecated please update your code';
    if (isset($GLOBALS['log'])) {
        $GLOBALS['log']->deprecated($deprecatedMessage);
    } else {
        trigger_error($deprecatedMessage, E_USER_DEPRECATED);
    }
    $isValidator = new \SuiteCRM\Utility\SuiteValidator();
    $result = $isValidator->isValidId($id);
    return $result;
}

function isValidEmailAddress($email, $message = 'Invalid email address given', $orEmpty = true, $logInvalid = 'error')
{
    if ($orEmpty && !$email) {
        return true;
    }
    if (filter_var($email, FILTER_VALIDATE_EMAIL)) {
        return true;
    }
    if ($logInvalid) {
        $trace = debug_backtrace();
        $where = ""Called at {$trace[1]['file']}:{$trace[1]['line']} from function {$trace[1]['function']}."";
        \SuiteCRM\ErrorMessage::log(""$message: [$email] $where"", $logInvalid);
    }
    return false;
}

function displayAdminError($errorString)
{
    SugarApplication::appendErrorMessage($errorString);
}

function getAppString($key)
{
    global $app_strings;

    if (!isset($app_strings[$key])) {
        LoggerManager::getLogger()->warn('Language key not found: ' . $key);
        return $key;
    }

    if (!$app_strings[$key]) {
        LoggerManager::getLogger()->warn('Language string is empty at key: ' . $key);
        return $key;
    }

    return $app_strings[$key];
}

/**
 * Check if has valid image extension
 * @param string $fieldName
 * @param string $value
 * @return bool
 */
function has_valid_image_extension($fieldName, $name)
{
    global $sugar_config;

    $validExtensions = [
        'gif',
        'png',
        'jpg',
        'jpeg',
        'svg'
    ];

    if (isset($sugar_config['valid_image_ext']) && is_array($sugar_config['valid_image_ext'])){
        $validExtensions = $sugar_config['valid_image_ext'];
    }

    return has_valid_extension($fieldName, $name, $validExtensions);
}

/**
 * Check if has valid extension
 * @param string $fieldName
 * @param string $name
 * @param array $validExtensions
 * @return bool
 */
function has_valid_extension($fieldName, $name, $validExtensions)
{

    if ($name === '.' || empty($name)) {
        LoggerManager::getLogger()->security(""Invalid ext  $fieldName : '$name'."");

        return false;
    }

    $validExtensions = array_map('strtolower', $validExtensions);

    $parts = explode('.', $name);

    if (empty($parts)) {
        LoggerManager::getLogger()->security(""Invalid ext  $fieldName : '$name'."");

        return false;
    }

    $ext = array_pop($parts);
    $trimmedValue = preg_replace('/.*\.([^\.]+)$/', '\1', $ext);

    if (!in_array(strtolower($trimmedValue), $validExtensions, true)) {
        LoggerManager::getLogger()->security(""Invalid $fieldName: '$name'."");

        return false;
    }

    return true;
}

/**
 * Check if value is one of the accepted true representations
 * @param $value
 * @return bool
 */
function isTrue($value): bool {
    return $value === true || $value === 'true' || $value === 1 || $value === '1' || $value === 'on';
}

/**
 * Check if value is one of the accepted false representations
 * @param $value
 * @return bool
 */
function isFalse($value): bool {
    return $value === false || $value === 'false' || $value === 0 || $value === '0';
}

/**
 * Get validation pattern
 * @return string
 */
function get_id_validation_pattern(): string {
    global $sugar_config;

    $pattern = '/^[a-zA-Z0-9_-]*$/i';
    if (!empty($sugar_config['id_validation_pattern'])){
        $pattern = $sugar_config['id_validation_pattern'];
    }

    return $pattern;
}

/**
 * Check if user has group and action acls defined
 * @param string $module
 * @param string $action
 * @return bool
 */
function has_group_action_acls_defined(string $module, string $action): bool
{
    global $current_user;

    $hasGroupActionAcls = true;

    $groups = SecurityGroup::getUserSecurityGroups($current_user->id);
    $hasGroups = !empty($groups);

    $aclActions = ACLAction::getUserActions($current_user->id, false, $module, 'module', $action);
    $isDefaultListACL = !empty($aclActions['isDefault']) && isTrue($aclActions['isDefault']);

    if (!$hasGroups) {
        $hasGroupActionAcls = false;
    }

    if ($isDefaultListACL) {
        $hasGroupActionAcls = false;
    }

    return $hasGroupActionAcls;
}

/**
 * Check if is value is smtp in a case-insensitive way
 * @param $value
 * @return bool
 */
function isSmtp($value): bool {
    if (empty($value) || !is_string($value)) {
        return false;
    }

    return strtolower($value)  === 'smtp';
}

/**
 * Check if is string is an allowed module name
 * @param string $value
 * @return bool
 */
function isAllowedModuleName(string $value): bool {
    if (empty($value)) {
        return false;
    }

    $result = preg_match(""/^[\w\-\_\.]+$/"", $value);

    if (!empty($result)) {
        return true;
    }

    return false;
}

/**
 * @param $endpoint
 * @return bool
 */
function isSelfRequest($endpoint) : bool {
    $domain = 'localhost';
    if (isset($_SERVER[""HTTP_HOST""])) {
        $domain = $_SERVER[""HTTP_HOST""];
    }

    $siteUrl = SugarConfig::getInstance()->get('site_url');
    if (empty($siteUrl)){
        $siteUrl = '';
    }

    return stripos((string) $endpoint, (string) $domain) !== false || stripos((string) $endpoint, (string) $siteUrl) !== false;
}
",1
"    public static function saveParameters(BigInteger $p, BigInteger $q, BigInteger $g)
    {
        $key = [
            'p' => $p,
            'q' => $q,
            'g' => $g
        ];

        $key = ASN1::encodeDER($key, Maps\DSAParams::MAP);

        return ""-----BEGIN DSA PARAMETERS-----\r\n"" .
               chunk_split(Strings::base64_encode($key), 64) .
               ""-----END DSA PARAMETERS-----\r\n"";
    }",0
"    public static function addPeriodicTimer($interval, $callback)
    {
        return self::get()->addPeriodicTimer($interval, $callback);
    }",0
"    public static function setCookie($key, $value, $time = 3600, $path = '/', $http_only = true, $domain = '') {

        $cookie_domain = cmsConfig::get('cookie_domain');

        if (!$domain && $cookie_domain) {
            $domain = $cookie_domain;
        }

        if (PHP_VERSION_ID < 70300) {
            return setcookie('icms[' . $key . ']', $value, time() + $time, $path, $domain, false, $http_only);
        } else {
            return setcookie('icms[' . $key . ']', $value, [
                'expires'  => time() + $time,
                'path'     => $path,
                'domain'   => $domain,
                'samesite' => 'Lax',
                'secure'   => false,
                'httponly' => $http_only
            ]);
        }
    }",1
"function strip_request_tags($name, $default_value = null)
{
    $request = request();
    if ($request->has($name)) {
        return strip_tags($request->input($name));
    }

    return $default_value;
}",1
"    public function getFirst()
    {
        // ensure timers are sorted to simply accessing next (first) one
        if (!$this->sorted) {
            $this->sorted = true;
            \asort($this->schedule);
        }

        return \reset($this->schedule);
    }",0
"    public function __invoke(
        ContainerInterface $container,
        $requestedName,
        array $options = null
    ) {
        if (!empty($options)) {
            throw new \Exception('Unexpected options sent to factory.');
        }
        return new $requestedName(
            $container->get(\VuFind\Cover\Loader::class),
            $container->get(\VuFind\Cover\CachingProxy::class),
            $container->get(\VuFind\Session\Settings::class)
        );
    }",1
"    public function testFullDefaultConfig()
    {
        $fullDefaultConfig = [
            'data_dir' => '/tmp/',
            'timesheet' => [
                'default_begin' => 'now',
                'mode' => 'default',
                'markdown_content' => false,
                'rounding' => [
                    'default' => [
                        'begin' => 1,
                        'end' => 1,
                        'duration' => 0,
                        'mode' => 'default',
                        'days' => ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday']
                    ]
                ],
                'rates' => [],
                'active_entries' => [
                    'hard_limit' => 1,
                ],
                'rules' => [
                    'allow_future_times' => true,
                    'allow_zero_duration' => true,
                    'allow_overlapping_records' => true,
                    'lockdown_period_start' => null,
                    'lockdown_period_end' => null,
                    'lockdown_grace_period' => null,
                    'allow_overbooking_budget' => true,
                    'lockdown_period_timezone' => null,
                    'break_warning_duration' => 0,
                    'long_running_duration' => 0,
                    'require_activity' => true,
                ],
                'duration_increment' => 15,
                'time_increment' => 15,
            ],
            'user' => [
                'registration' => false,
                'password_reset' => true,
                'login' => true,
                'password_reset_retry_ttl' => 7200,
                'password_reset_token_ttl' => 86400,
            ],
            'invoice' => [
                'documents' => [
                ],
                'defaults' => [
                    0 => 'var/invoices/',
                    1 => 'templates/invoice/renderer/',
                ],
                'number_format' => '{Y}/{cy,3}',
                'upload_twig' => true,
            ],
            'export' => [
                'documents' => [
                ],
                'defaults' => [
                    0 => 'var/export/',
                    1 => 'templates/export/renderer/',
                ],
            ],
            'calendar' => [
                'week_numbers' => true,
                'day_limit' => 4,
                'slot_duration' => '00:30:00',
                'businessHours' => [
                    'begin' => '08:00',
                    'end' => '20:00',
                ],
                'visibleHours' => [
                    'begin' => '00:00',
                    'end' => '23:59',
                ],
                'google' => [
                    'api_key' => null,
                    'sources' => [
                    ],
                ],
                'weekends' => true,
                'dragdrop_amount' => 5,
                'dragdrop_data' => false,
                'title_pattern' => '{activity}',
            ],
            'theme' => [
                'show_about' => true,
                'branding' => [
                    'logo' => null,
                    'mini' => null,
                    'company' => null,
                    'title' => null,
                ],
                'colors_limited' => true,
                'color_choices' => 'Silver|#c0c0c0,Gray|#808080,Black|#000000,Maroon|#800000,Brown|#a52a2a,Red|#ff0000,Orange|#ffa500,Gold|#ffd700,Yellow|#ffff00,Peach|#ffdab9,Khaki|#f0e68c,Olive|#808000,Lime|#00ff00,Jelly|#9acd32,Green|#008000,Teal|#008080,Aqua|#00ffff,LightBlue|#add8e6,DeepSky|#00bfff,Dodger|#1e90ff,Blue|#0000ff,Navy|#000080,Purple|#800080,Fuchsia|#ff00ff,Violet|#ee82ee,Rose|#ffe4e1,Lavender|#E6E6FA',
                'avatar_url' => false,
            ],
            'defaults' => [
                'customer' => [
                    'timezone' => null,
                    'country' => 'DE',
                    'currency' => 'EUR',
                ],
                'user' => [
                    'timezone' => null,
                    'language' => 'en',
                    'theme' => 'default',
                    'currency' => 'EUR',
                ],
            ],
            'permissions' => [
                'sets' => [],
                'maps' => [],
                'roles' => [
                    'ROLE_USER' => [],
                    'ROLE_TEAMLEAD' => [],
                    'ROLE_ADMIN' => [],
                    'ROLE_SUPER_ADMIN' => [],
                ],
            ],
            'ldap' => [
                'activate' => false,
                'connection' => [
                    'host' => null,
                    'port' => 389,
                    'useStartTls' => false,
                    'useSsl' => false,
                    'bindRequiresDn' => true,
                    'accountFilterFormat' => null,
                ],
                'user' => [
                    'baseDn' => null,
                    'filter' => '',
                    'attributesFilter' => '(objectClass=*)',
                    'usernameAttribute' => 'uid',
                    'attributes' => [],
                ],
                'role' => [
                    'baseDn' => null,
                    'usernameAttribute' => 'dn',
                    'nameAttribute' => 'cn',
                    'userDnAttribute' => 'member',
                    'groups' => [],
                ],
            ],
            'saml' => [
                'activate' => false,
                'title' => 'Login with SAML',
                'roles' => [
                    'resetOnLogin' => true,
                    'attribute' => null,
                    'mapping' => []
                ],
                'mapping' => [],
                'connection' => [
                    'organization' => []
                ],
                'provider' => 'default',
            ],
            'company' => [
                'financial_year' => null,
            ],
            'quick_entry' => [
                'recent_activities' => 5,
                'recent_activity_weeks' => null,
                'minimum_rows' => 3,
            ],
            'project' => [
                'copy_teams_on_create' => false,
            ],
            'activity' => [
                'allow_inline_create' => false,
            ],
            'customer' => [
                'number_format' => '{cc,4}',
                'rules' => [
                    'allow_duplicate_number' => false,
                ],
            ],
            'features' => [
                'user_registration' => false,
            ],
        ];

        $this->assertConfig($this->getMinConfig(), $fullDefaultConfig);
    }",1
"    public function testIsAbsoluteUrl()
    {
        $this->assertTrue(Director::is_absolute_url('http://test.com/testpage'));
        $this->assertTrue(Director::is_absolute_url('https:/\\test.com'));
        $this->assertTrue(Director::is_absolute_url('https:\\/test.com'));
        $this->assertTrue(Director::is_absolute_url('https:\\\\test.com'));
        $this->assertTrue(Director::is_absolute_url('ftp://test.com'));
        $this->assertFalse(Director::is_absolute_url('test.com/testpage'));
        $this->assertFalse(Director::is_absolute_url('/relative'));
        $this->assertFalse(Director::is_absolute_url('relative'));
        $this->assertFalse(Director::is_absolute_url(""/relative/?url=http://foo.com""));
        $this->assertFalse(Director::is_absolute_url(""/relative/#http://foo.com""));
        $this->assertTrue(Director::is_absolute_url(""https://test.com/?url=http://foo.com""));
        $this->assertTrue(Director::is_absolute_url(""trickparseurl:http://test.com""));
        $this->assertTrue(Director::is_absolute_url('//test.com'));
        $this->assertTrue(Director::is_absolute_url('\\/\\/test.com'));
        $this->assertTrue(Director::is_absolute_url('\/\/test.com'));
        $this->assertTrue(Director::is_absolute_url('/\\test.com'));
        $this->assertTrue(Director::is_absolute_url('\\\\test.com'));
        $this->assertFalse(Director::is_absolute_url('\\test.com'));
        $this->assertTrue(Director::is_absolute_url('/////test.com'));
        $this->assertTrue(Director::is_absolute_url('  ///test.com'));
        $this->assertTrue(Director::is_absolute_url('http:test.com'));
        $this->assertTrue(Director::is_absolute_url('//http://test.com'));
    }",0
"    public function testEventNameMustBeStringOn()
    {
        self::expectException(InvalidArgumentException::class);
        self::expectExceptionMessage('event name must not be null');

        $this->emitter->on(null, function () {});
    }",0
"    public static function min(PHP64 ...$nums)
    {
        return self::minHelper($nums);
    }",0
"                                    return $reduceFunc($c, $value, $i++, $total);
                                });
                        });",0
"	static public function GetDefaultFieldsToLoad(array $aComplementAttributeSpec, string $sObjectImageAttCode)
	{
		// Friendly name complementary fields
		$aFieldsToLoad = $aComplementAttributeSpec[1];

		// Image attribute
		if (!empty($sObjectImageAttCode)) {
			$aFieldsToLoad[] = $sObjectImageAttCode;
		}

		// Add friendly name
		$aFieldsToLoad[] = 'friendlyname';

		return $aFieldsToLoad;
	}",1
"    public function __construct(RouteCollection $routes, RequestContext $context)
    {
        $this->routes = $routes;
        $this->context = $context;
    }",0
"function dol_htmlentitiesbr($stringtoencode, $nl2brmode = 0, $pagecodefrom = 'UTF-8', $removelasteolbr = 1)
{
	if (is_null($stringtoencode)) {
		return '';
	}

	$newstring = $stringtoencode;
	if (dol_textishtml($stringtoencode)) {	// Check if text is already HTML or not
		$newstring = preg_replace('/<br(\s[\sa-zA-Z_=""]*)?\/?>/i', '<br>', $newstring); // Replace ""<br type=""_moz"" />"" by ""<br>"". It's same and avoid pb with FPDF.
		if ($removelasteolbr) {
			$newstring = preg_replace('/<br>$/i', '', $newstring); // Remove last <br> (remove only last one)
		}
		$newstring = strtr($newstring, array('&'=>'__and__', '<'=>'__lt__', '>'=>'__gt__', '""'=>'__dquot__'));
		$newstring = dol_htmlentities($newstring, ENT_COMPAT, $pagecodefrom); // Make entity encoding
		$newstring = strtr($newstring, array('__and__'=>'&', '__lt__'=>'<', '__gt__'=>'>', '__dquot__'=>'""'));
	} else {
		if ($removelasteolbr) {
			$newstring = preg_replace('/(\r\n|\r|\n)$/i', '', $newstring); // Remove last \n (may remove several)
		}
		$newstring = dol_nl2br(dol_htmlentities($newstring, ENT_COMPAT, $pagecodefrom), $nl2brmode);
	}
	// Other substitutions that htmlentities does not do
	//$newstring=str_replace(chr(128),'&euro;',$newstring);	// 128 = 0x80. Not in html entity table.     // Seems useles with TCPDF. Make bug with UTF8 languages
	return $newstring;
}

/**
 *	This function is called to decode a HTML string (it decodes entities and br tags)
 *
 *	@param	string	$stringtodecode		String to decode
 *	@param	string	$pagecodeto			Page code for result
 *	@return	string						String decoded
 */
function dol_htmlentitiesbr_decode($stringtodecode, $pagecodeto = 'UTF-8')
{
	$ret = dol_html_entity_decode($stringtodecode, ENT_COMPAT | ENT_HTML5, $pagecodeto);
	$ret = preg_replace('/'.""\r\n"".'<br(\s[\sa-zA-Z_=""]*)?\/?>/i', ""<br>"", $ret);
	$ret = preg_replace('/<br(\s[\sa-zA-Z_=""]*)?\/?>'.""\r\n"".'/i', ""\r\n"", $ret);
	$ret = preg_replace('/<br(\s[\sa-zA-Z_=""]*)?\/?>'.""\n"".'/i', ""\n"", $ret);
	$ret = preg_replace('/<br(\s[\sa-zA-Z_=""]*)?\/?>/i', ""\n"", $ret);
	return $ret;
}

/**
 *	This function remove all ending \n and br at end
 *
 *	@param	string	$stringtodecode		String to decode
 *	@return	string						String decoded
 */
function dol_htmlcleanlastbr($stringtodecode)
{
	$ret = preg_replace('/&nbsp;$/i', """", $stringtodecode);		// Because wysiwyg editor may add a &nbsp; at end of last line
	$ret = preg_replace('/(<br>|<br(\s[\sa-zA-Z_=""]*)?\/?>|'.""\n"".'|'.""\r"".')+$/i', """", $ret);
	return $ret;
}

/**
 * Replace html_entity_decode functions to manage errors
 *
 * @param   string	$a					Operand a
 * @param   string	$b					Operand b (ENT_QUOTES|ENT_HTML5=convert simple, double quotes, colon, e accent, ...)
 * @param   string	$c					Operand c
 * @param	string	$keepsomeentities	Entities but &, <, >, "" are not converted.
 * @return  string						String decoded
 */
function dol_html_entity_decode($a, $b, $c = 'UTF-8', $keepsomeentities = 0)
{
	$newstring = $a;
	if ($keepsomeentities) {
		$newstring = strtr($newstring, array('&amp;'=>'__andamp__', '&lt;'=>'__andlt__', '&gt;'=>'__andgt__', '""'=>'__dquot__'));
	}
	$newstring = html_entity_decode((string) $newstring, (int) $b, (string) $c);
	if ($keepsomeentities) {
		$newstring = strtr($newstring, array('__andamp__'=>'&amp;', '__andlt__'=>'&lt;', '__andgt__'=>'&gt;', '__dquot__'=>'""'));
	}
	return $newstring;
}

/**
 * Replace htmlentities functions.
 * Goal of this function is to be sure to have default values of htmlentities that match what we need.
 *
 * @param   string  $string         The input string to encode
 * @param   int     $flags          Flags (see PHP doc above)
 * @param   string  $encoding       Encoding page code
 * @param   bool    $double_encode  When double_encode is turned off, PHP will not encode existing html entities
 * @return  string  $ret            Encoded string
 */
function dol_htmlentities($string, $flags = ENT_QUOTES|ENT_SUBSTITUTE, $encoding = 'UTF-8', $double_encode = false)
{
	return htmlentities($string, $flags, $encoding, $double_encode);
}

/**
 *	Check if a string is a correct iso string
 *	If not, it will we considered not HTML encoded even if it is by FPDF.
 *	Example, if string contains euro symbol that has ascii code 128
 *
 *	@param	string		$s      	String to check
 *  @param	string		$clean		Clean if it is not an ISO. Warning, if file is utf8, you will get a bad formated file.
 *	@return	int|string  	   		0 if bad iso, 1 if good iso, Or the clean string if $clean is 1
 */
function dol_string_is_good_iso($s, $clean = 0)
{
	$len = dol_strlen($s);
	$out = '';
	$ok = 1;
	for ($scursor = 0; $scursor < $len; $scursor++) {
		$ordchar = ord($s[$scursor]);
		//print $scursor.'-'.$ordchar.'<br>';
		if ($ordchar < 32 && $ordchar != 13 && $ordchar != 10) {
			$ok = 0;
			break;
		} elseif ($ordchar > 126 && $ordchar < 160) {
			$ok = 0;
			break;
		} elseif ($clean) {
			$out .= $s[$scursor];
		}
	}
	if ($clean) {
		return $out;
	}
	return $ok;
}

/**
 *	Return nb of lines of a clear text
 *
 *	@param	string	$s			String to check
 * 	@param	int     $maxchar	Not yet used
 *	@return	int					Number of lines
 *  @see	dol_nboflines_bis(), dolGetFirstLineOfText()
 */
function dol_nboflines($s, $maxchar = 0)
{
	if ($s == '') {
		return 0;
	}
	$arraystring = explode(""\n"", $s);
	$nb = count($arraystring);

	return $nb;
}


/**
 *	Return nb of lines of a formated text with \n and <br> (WARNING: string must not have mixed \n and br separators)
 *
 *	@param	string	$text      		Text
 *	@param	int		$maxlinesize  	Largeur de ligne en caracteres (ou 0 si pas de limite - defaut)
 * 	@param	string	$charset		Give the charset used to encode the $text variable in memory.
 *	@return int						Number of lines
 *	@see	dol_nboflines(), dolGetFirstLineOfText()
 */
function dol_nboflines_bis($text, $maxlinesize = 0, $charset = 'UTF-8')
{
	$repTable = array(""\t"" => "" "", ""\n"" => ""<br>"", ""\r"" => "" "", ""\0"" => "" "", ""\x0B"" => "" "");
	if (dol_textishtml($text)) {
		$repTable = array(""\t"" => "" "", ""\n"" => "" "", ""\r"" => "" "", ""\0"" => "" "", ""\x0B"" => "" "");
	}

	$text = strtr($text, $repTable);
	if ($charset == 'UTF-8') {
		$pattern = '/(<br[^>]*>)/Uu';
	} else {
		// /U is to have UNGREEDY regex to limit to one html tag. /u is for UTF8 support
		$pattern = '/(<br[^>]*>)/U'; // /U is to have UNGREEDY regex to limit to one html tag.
	}
	$a = preg_split($pattern, $text, -1, PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY);

	$nblines = (int) floor((count($a) + 1) / 2);
	// count possible auto line breaks
	if ($maxlinesize) {
		foreach ($a as $line) {
			if (dol_strlen($line) > $maxlinesize) {
				//$line_dec = html_entity_decode(strip_tags($line));
				$line_dec = html_entity_decode($line);
				if (dol_strlen($line_dec) > $maxlinesize) {
					$line_dec = wordwrap($line_dec, $maxlinesize, '\n', true);
					$nblines += substr_count($line_dec, '\n');
				}
			}
		}
	}

	unset($a);
	return $nblines;
}

/**
 *	Return if a text is a html content
 *
 *	@param	string	$msg		Content to check
 *	@param	int		$option		0=Full detection, 1=Fast check
 *	@return	boolean				true/false
 *	@see	dol_concatdesc()
 */
function dol_textishtml($msg, $option = 0)
{
	if (is_null($msg)) {
		return false;
	}

	if ($option == 1) {
		if (preg_match('/<html/i', $msg)) {
			return true;
		} elseif (preg_match('/<body/i', $msg)) {
			return true;
		} elseif (preg_match('/<\/textarea/i', $msg)) {
			return true;
		} elseif (preg_match('/<(b|em|i|u)(\s+[^>]+)?>/i', $msg)) {
			return true;
		} elseif (preg_match('/<br/i', $msg)) {
			return true;
		}
		return false;
	} else {
		// Remove all urls because 'http://aa?param1=abc&amp;param2=def' must not be used inside detection
		$msg = preg_replace('/https?:\/\/[^""\'\s]+/i', '', $msg);
		if (preg_match('/<html/i', $msg)) {
			return true;
		} elseif (preg_match('/<body/i', $msg)) {
			return true;
		} elseif (preg_match('/<\/textarea/i', $msg)) {
			return true;
		} elseif (preg_match('/<(b|em|i|u)(\s+[^>]+)?>/i', $msg)) {
			return true;
		} elseif (preg_match('/<br\/>/i', $msg)) {
			return true;
		} elseif (preg_match('/<(br|div|font|li|p|span|strong|table)>/i', $msg)) {
			return true;
		} elseif (preg_match('/<(br|div|font|li|p|span|strong|table)\s+[^<>\/]*\/?>/i', $msg)) {
			return true;
		} elseif (preg_match('/<img\s+[^<>]*src[^<>]*>/i', $msg)) {
			return true; // must accept <img src=""http://example.com/aaa.png"" />
		} elseif (preg_match('/<a\s+[^<>]*href[^<>]*>/i', $msg)) {
			return true; // must accept <a href=""http://example.com/aaa.png"" />
		} elseif (preg_match('/<h[0-9]>/i', $msg)) {
			return true;
		} elseif (preg_match('/&[A-Z0-9]{1,6};/i', $msg)) {
			// TODO If content is 'A link https://aaa?param=abc&amp;param2=def', it return true but must be false
			return true; // Html entities names (http://www.w3schools.com/tags/ref_entities.asp)
		} elseif (preg_match('/&#[0-9]{2,3};/i', $msg)) {
			return true; // Html entities numbers (http://www.w3schools.com/tags/ref_entities.asp)
		}

		return false;
	}
}

/**
 *  Concat 2 descriptions with a new line between them (second operand after first one with appropriate new line separator)
 *  text1 html + text2 html => text1 + '<br>' + text2
 *  text1 html + text2 txt  => text1 + '<br>' + dol_nl2br(text2)
 *  text1 txt  + text2 html => dol_nl2br(text1) + '<br>' + text2
 *  text1 txt  + text2 txt  => text1 + '\n' + text2
 *
 *  @param  string  $text1          Text 1
 *  @param  string  $text2          Text 2
 *  @param  bool    $forxml         true=Use <br /> instead of <br> if we have to add a br tag
 *  @param  bool    $invert         invert order of description lines (we often use config MAIN_CHANGE_ORDER_CONCAT_DESCRIPTION in this parameter)
 *  @return string                  Text 1 + new line + Text2
 *  @see    dol_textishtml()
 */
function dol_concatdesc($text1, $text2, $forxml = false, $invert = false)
{
	if (!empty($invert)) {
			$tmp = $text1;
			$text1 = $text2;
			$text2 = $tmp;
	}

	$ret = '';
	$ret .= (!dol_textishtml($text1) && dol_textishtml($text2)) ? dol_nl2br(dol_escape_htmltag($text1, 0, 1, '', 1), 0, $forxml) : $text1;
	$ret .= (!empty($text1) && !empty($text2)) ? ((dol_textishtml($text1) || dol_textishtml($text2)) ? ($forxml ? ""<br \>\n"" : ""<br>\n"") : ""\n"") : """";
	$ret .= (dol_textishtml($text1) && !dol_textishtml($text2)) ? dol_nl2br(dol_escape_htmltag($text2, 0, 1, '', 1), 0, $forxml) : $text2;
	return $ret;
}



/**
 * Return array of possible common substitutions. This includes several families like: 'system', 'mycompany', 'object', 'objectamount', 'date', 'user'
 *
 * @param	Translate	$outputlangs	Output language
 * @param   int         $onlykey        1=Do not calculate some heavy values of keys (performance enhancement when we need only the keys), 2=Values are trunc and html sanitized (to use for help tooltip)
 * @param   array       $exclude        Array of family keys we want to exclude. For example array('system', 'mycompany', 'object', 'objectamount', 'date', 'user', ...)
 * @param   Object      $object         Object for keys on object
 * @param   array       $include        Array of family keys we want to include. For example array('system', 'mycompany', 'object', 'objectamount', 'date', 'user', ...)
 * @return	array						Array of substitutions
 * @see setSubstitFromObject()
 */
function getCommonSubstitutionArray($outputlangs, $onlykey = 0, $exclude = null, $object = null, $include = null)
{
	global $db, $conf, $mysoc, $user, $extrafields;

	$substitutionarray = array();

	if ((empty($exclude) || !in_array('user', $exclude)) && (empty($include) || in_array('user', $include))) {
		// Add SIGNATURE into substitutionarray first, so, when we will make the substitution,
		// this will include signature content first and then replace var found into content of signature
		//var_dump($onlykey);
		$emailsendersignature = $user->signature; //  dy default, we use the signature of current user. We must complete substitution with signature in c_email_senderprofile of array after calling getCommonSubstitutionArray()
		$usersignature = $user->signature;
		$substitutionarray = array_merge($substitutionarray, array(
			'__SENDEREMAIL_SIGNATURE__' => (string) ((empty($conf->global->MAIN_MAIL_DO_NOT_USE_SIGN)) ? ($onlykey == 2 ? dol_trunc('SignatureFromTheSelectedSenderProfile', 30) : $emailsendersignature) : ''),
			'__USER_SIGNATURE__' => (string) (($usersignature && empty($conf->global->MAIN_MAIL_DO_NOT_USE_SIGN)) ? ($onlykey == 2 ? dol_trunc(dol_string_nohtmltag($usersignature), 30) : $usersignature) : '')
		));

		if (is_object($user)) {
			$substitutionarray = array_merge($substitutionarray, array(
				'__USER_ID__' => (string) $user->id,
				'__USER_LOGIN__' => (string) $user->login,
				'__USER_EMAIL__' => (string) $user->email,
				'__USER_PHONE__' => (string) dol_print_phone($user->office_phone, '', 0, 0, '', "" "", '', '', -1),
				'__USER_PHONEPRO__' => (string) dol_print_phone($user->user_mobile, '', 0, 0, '', "" "", '', '', -1),
				'__USER_PHONEMOBILE__' => (string) dol_print_phone($user->personal_mobile, '', 0, 0, '', "" "", '', '', -1),
				'__USER_FAX__' => (string) $user->office_fax,
				'__USER_LASTNAME__' => (string) $user->lastname,
				'__USER_FIRSTNAME__' => (string) $user->firstname,
				'__USER_FULLNAME__' => (string) $user->getFullName($outputlangs),
				'__USER_SUPERVISOR_ID__' => (string) ($user->fk_user ? $user->fk_user : '0'),
				'__USER_JOB__' => (string) $user->job,
				'__USER_REMOTE_IP__' => (string) getUserRemoteIP()
				));
		}
	}
	if ((empty($exclude) || !in_array('mycompany', $exclude)) && is_object($mysoc) && (empty($include) || in_array('mycompany', $include))) {
		$substitutionarray = array_merge($substitutionarray, array(
			'__MYCOMPANY_NAME__'    => $mysoc->name,
			'__MYCOMPANY_EMAIL__'   => $mysoc->email,
			'__MYCOMPANY_PHONE__'   => dol_print_phone($mysoc->phone, '', 0, 0, '', "" "", '', '', -1),
			'__MYCOMPANY_FAX__'     => dol_print_phone($mysoc->fax, '', 0, 0, '', "" "", '', '', -1),
			'__MYCOMPANY_PROFID1__' => $mysoc->idprof1,
			'__MYCOMPANY_PROFID2__' => $mysoc->idprof2,
			'__MYCOMPANY_PROFID3__' => $mysoc->idprof3,
			'__MYCOMPANY_PROFID4__' => $mysoc->idprof4,
			'__MYCOMPANY_PROFID5__' => $mysoc->idprof5,
			'__MYCOMPANY_PROFID6__' => $mysoc->idprof6,
			'__MYCOMPANY_CAPITAL__' => $mysoc->capital,
			'__MYCOMPANY_FULLADDRESS__' => (method_exists($mysoc, 'getFullAddress') ? $mysoc->getFullAddress(1, ', ') : ''),	// $mysoc may be stdClass
			'__MYCOMPANY_ADDRESS__' => $mysoc->address,
			'__MYCOMPANY_ZIP__'     => $mysoc->zip,
			'__MYCOMPANY_TOWN__'    => $mysoc->town,
			'__MYCOMPANY_COUNTRY__'    => $mysoc->country,
			'__MYCOMPANY_COUNTRY_ID__' => $mysoc->country_id,
			'__MYCOMPANY_COUNTRY_CODE__' => $mysoc->country_code,
			'__MYCOMPANY_CURRENCY_CODE__' => $conf->currency
		));
	}

	if (($onlykey || is_object($object)) && (empty($exclude) || !in_array('object', $exclude)) && (empty($include) || in_array('object', $include))) {
		if ($onlykey) {
			$substitutionarray['__ID__'] = '__ID__';
			$substitutionarray['__REF__'] = '__REF__';
			$substitutionarray['__NEWREF__'] = '__NEWREF__';
			$substitutionarray['__LABEL__'] = '__LABEL__';
			$substitutionarray['__REF_CLIENT__'] = '__REF_CLIENT__';
			$substitutionarray['__REF_SUPPLIER__'] = '__REF_SUPPLIER__';
			$substitutionarray['__NOTE_PUBLIC__'] = '__NOTE_PUBLIC__';
			$substitutionarray['__NOTE_PRIVATE__'] = '__NOTE_PRIVATE__';
			$substitutionarray['__EXTRAFIELD_XXX__'] = '__EXTRAFIELD_XXX__';

			if (isModEnabled(""societe"")) {	// Most objects are concerned
				$substitutionarray['__THIRDPARTY_ID__'] = '__THIRDPARTY_ID__';
				$substitutionarray['__THIRDPARTY_NAME__'] = '__THIRDPARTY_NAME__';
				$substitutionarray['__THIRDPARTY_NAME_ALIAS__'] = '__THIRDPARTY_NAME_ALIAS__';
				$substitutionarray['__THIRDPARTY_CODE_CLIENT__'] = '__THIRDPARTY_CODE_CLIENT__';
				$substitutionarray['__THIRDPARTY_CODE_FOURNISSEUR__'] = '__THIRDPARTY_CODE_FOURNISSEUR__';
				$substitutionarray['__THIRDPARTY_EMAIL__'] = '__THIRDPARTY_EMAIL__';
				$substitutionarray['__THIRDPARTY_PHONE__'] = '__THIRDPARTY_PHONE__';
				$substitutionarray['__THIRDPARTY_FAX__'] = '__THIRDPARTY_FAX__';
				$substitutionarray['__THIRDPARTY_ADDRESS__'] = '__THIRDPARTY_ADDRESS__';
				$substitutionarray['__THIRDPARTY_ZIP__'] = '__THIRDPARTY_ZIP__';
				$substitutionarray['__THIRDPARTY_TOWN__'] = '__THIRDPARTY_TOWN__';
				$substitutionarray['__THIRDPARTY_IDPROF1__'] = '__THIRDPARTY_IDPROF1__';
				$substitutionarray['__THIRDPARTY_IDPROF2__'] = '__THIRDPARTY_IDPROF2__';
				$substitutionarray['__THIRDPARTY_IDPROF3__'] = '__THIRDPARTY_IDPROF3__';
				$substitutionarray['__THIRDPARTY_IDPROF4__'] = '__THIRDPARTY_IDPROF4__';
				$substitutionarray['__THIRDPARTY_IDPROF5__'] = '__THIRDPARTY_IDPROF5__';
				$substitutionarray['__THIRDPARTY_IDPROF6__'] = '__THIRDPARTY_IDPROF6__';
				$substitutionarray['__THIRDPARTY_TVAINTRA__'] = '__THIRDPARTY_TVAINTRA__';
				$substitutionarray['__THIRDPARTY_NOTE_PUBLIC__'] = '__THIRDPARTY_NOTE_PUBLIC__';
				$substitutionarray['__THIRDPARTY_NOTE_PRIVATE__'] = '__THIRDPARTY_NOTE_PRIVATE__';
			}
			if (isModEnabled('adherent') && (!is_object($object) || $object->element == 'adherent') && (empty($exclude) || !in_array('member', $exclude)) && (empty($include) || in_array('member', $include))) {
				$substitutionarray['__MEMBER_ID__'] = '__MEMBER_ID__';
				$substitutionarray['__MEMBER_CIVILITY__'] = '__MEMBER_CIVILITY__';
				$substitutionarray['__MEMBER_FIRSTNAME__'] = '__MEMBER_FIRSTNAME__';
				$substitutionarray['__MEMBER_LASTNAME__'] = '__MEMBER_LASTNAME__';
				$substitutionarray['__MEMBER_USER_LOGIN_INFORMATION__'] = 'Login and pass of the external user account';
				/*$substitutionarray['__MEMBER_NOTE_PUBLIC__'] = '__MEMBER_NOTE_PUBLIC__';
				$substitutionarray['__MEMBER_NOTE_PRIVATE__'] = '__MEMBER_NOTE_PRIVATE__';*/
			}
			// add variables subtitutions ticket
			if (isModEnabled('ticket') && (!is_object($object) || $object->element == 'ticket') && (empty($exclude) || !in_array('ticket', $exclude)) && (empty($include) || in_array('ticket', $include))) {
				$substitutionarray['__TICKET_TRACKID__'] = '__TICKET_TRACKID__';
				$substitutionarray['__TICKET_SUBJECT__'] = '__TICKET_SUBJECT__';
				$substitutionarray['__TICKET_TYPE__'] = '__TICKET_TYPE__';
				$substitutionarray['__TICKET_SEVERITY__'] = '__TICKET_SEVERITY__';
				$substitutionarray['__TICKET_CATEGORY__'] = '__TICKET_CATEGORY__';
				$substitutionarray['__TICKET_ANALYTIC_CODE__'] = '__TICKET_ANALYTIC_CODE__';
				$substitutionarray['__TICKET_MESSAGE__'] = '__TICKET_MESSAGE__';
				$substitutionarray['__TICKET_PROGRESSION__'] = '__TICKET_PROGRESSION__';
				$substitutionarray['__TICKET_USER_ASSIGN__'] = '__TICKET_USER_ASSIGN__';
			}

			if (isModEnabled('recruitment') && (!is_object($object) || $object->element == 'recruitmentcandidature') && (empty($exclude) || !in_array('recruitment', $exclude)) && (empty($include) || in_array('recruitment', $include))) {
				$substitutionarray['__CANDIDATE_FULLNAME__'] = '__CANDIDATE_FULLNAME__';
				$substitutionarray['__CANDIDATE_FIRSTNAME__'] = '__CANDIDATE_FIRSTNAME__';
				$substitutionarray['__CANDIDATE_LASTNAME__'] = '__CANDIDATE_LASTNAME__';
			}
			if (isModEnabled('project') && (empty($exclude) || !in_array('project', $exclude)) && (empty($include) || in_array('project', $include))) {		// Most objects
				$substitutionarray['__PROJECT_ID__'] = '__PROJECT_ID__';
				$substitutionarray['__PROJECT_REF__'] = '__PROJECT_REF__';
				$substitutionarray['__PROJECT_NAME__'] = '__PROJECT_NAME__';
				/*$substitutionarray['__PROJECT_NOTE_PUBLIC__'] = '__PROJECT_NOTE_PUBLIC__';
				$substitutionarray['__PROJECT_NOTE_PRIVATE__'] = '__PROJECT_NOTE_PRIVATE__';*/
			}
			if (isModEnabled('contrat') && (!is_object($object) || $object->element == 'contract') && (empty($exclude) || !in_array('contract', $exclude)) && (empty($include) || in_array('contract', $include))) {
				$substitutionarray['__CONTRACT_HIGHEST_PLANNED_START_DATE__'] = 'Highest date planned for a service start';
				$substitutionarray['__CONTRACT_HIGHEST_PLANNED_START_DATETIME__'] = 'Highest date and hour planned for service start';
				$substitutionarray['__CONTRACT_LOWEST_EXPIRATION_DATE__'] = 'Lowest data for planned expiration of service';
				$substitutionarray['__CONTRACT_LOWEST_EXPIRATION_DATETIME__'] = 'Lowest date and hour for planned expiration of service';
			}
			if (isModEnabled(""propal"") && (!is_object($object) || $object->element == 'propal') && (empty($exclude) || !in_array('propal', $exclude)) && (empty($include) || in_array('propal', $include))) {
				$substitutionarray['__ONLINE_SIGN_URL__'] = 'ToOfferALinkForOnlineSignature';
			}
			if (isModEnabled(""ficheinter"") && (!is_object($object) || $object->element == 'fichinter') && (empty($exclude) || !in_array('intervention', $exclude)) && (empty($include) || in_array('intervention', $include))) {
				$substitutionarray['__ONLINE_SIGN_FICHINTER_URL__'] = 'ToOfferALinkForOnlineSignature';
			}
			$substitutionarray['__ONLINE_PAYMENT_URL__'] = 'UrlToPayOnlineIfApplicable';
			$substitutionarray['__ONLINE_PAYMENT_TEXT_AND_URL__'] = 'TextAndUrlToPayOnlineIfApplicable';
			$substitutionarray['__SECUREKEYPAYMENT__'] = 'Security key (if key is not unique per record)';
			$substitutionarray['__SECUREKEYPAYMENT_MEMBER__'] = 'Security key for payment on a member subscription (one key per member)';
			$substitutionarray['__SECUREKEYPAYMENT_ORDER__'] = 'Security key for payment on an order';
			$substitutionarray['__SECUREKEYPAYMENT_INVOICE__'] = 'Security key for payment on an invoice';
			$substitutionarray['__SECUREKEYPAYMENT_CONTRACTLINE__'] = 'Security key for payment on a service of a contract';

			$substitutionarray['__DIRECTDOWNLOAD_URL_PROPOSAL__'] = 'Direct download url of a proposal';
			$substitutionarray['__DIRECTDOWNLOAD_URL_ORDER__'] = 'Direct download url of an order';
			$substitutionarray['__DIRECTDOWNLOAD_URL_INVOICE__'] = 'Direct download url of an invoice';
			$substitutionarray['__DIRECTDOWNLOAD_URL_CONTRACT__'] = 'Direct download url of a contract';
			$substitutionarray['__DIRECTDOWNLOAD_URL_SUPPLIER_PROPOSAL__'] = 'Direct download url of a supplier proposal';

			if (isModEnabled(""expedition"") && (!is_object($object) || $object->element == 'shipping')) {
				$substitutionarray['__SHIPPINGTRACKNUM__'] = 'Shipping tracking number';
				$substitutionarray['__SHIPPINGTRACKNUMURL__'] = 'Shipping tracking url';
			}
			if (isModEnabled(""reception"") && (!is_object($object) || $object->element == 'reception')) {
				$substitutionarray['__RECEPTIONTRACKNUM__'] = 'Shippin tracking number of shipment';
				$substitutionarray['__RECEPTIONTRACKNUMURL__'] = 'Shipping tracking url';
			}
		} else {
			$substitutionarray['__ID__'] = $object->id;
			$substitutionarray['__REF__'] = $object->ref;
			$substitutionarray['__NEWREF__'] = $object->newref;
			$substitutionarray['__LABEL__'] = (isset($object->label) ? $object->label : (isset($object->title) ? $object->title : null));
			$substitutionarray['__REF_CLIENT__'] = (isset($object->ref_client) ? $object->ref_client : (isset($object->ref_customer) ? $object->ref_customer : null));
			$substitutionarray['__REF_SUPPLIER__'] = (isset($object->ref_supplier) ? $object->ref_supplier : null);
			$substitutionarray['__NOTE_PUBLIC__'] = (isset($object->note_public) ? $object->note_public : null);
			$substitutionarray['__NOTE_PRIVATE__'] = (isset($object->note_private) ? $object->note_private : null);
			if ($object->element == ""shipping"") {
				$substitutionarray['__DATE_DELIVERY__'] = (isset($object->date_delivery) ? dol_print_date($object->date_delivery, 'day', 0, $outputlangs) : '');
			} else {
				$substitutionarray['__DATE_DELIVERY__'] = (isset($object->date_livraison) ? dol_print_date($object->date_livraison, 'day', 0, $outputlangs) : '');
			}
			$substitutionarray['__DATE_DELIVERY_DAY__'] = (isset($object->date_livraison) ? dol_print_date($object->date_livraison, ""%d"") : '');
			$substitutionarray['__DATE_DELIVERY_DAY_TEXT__'] = (isset($object->date_livraison) ? dol_print_date($object->date_livraison, ""%A"") : '');
			$substitutionarray['__DATE_DELIVERY_MON__'] = (isset($object->date_livraison) ? dol_print_date($object->date_livraison, ""%m"") : '');
			$substitutionarray['__DATE_DELIVERY_MON_TEXT__'] = (isset($object->date_livraison) ? dol_print_date($object->date_livraison, ""%b"") : '');
			$substitutionarray['__DATE_DELIVERY_YEAR__'] = (isset($object->date_livraison) ? dol_print_date($object->date_livraison, ""%Y"") : '');
			$substitutionarray['__DATE_DELIVERY_HH__'] = (isset($object->date_livraison) ? dol_print_date($object->date_livraison, ""%H"") : '');
			$substitutionarray['__DATE_DELIVERY_MM__'] = (isset($object->date_livraison) ? dol_print_date($object->date_livraison, ""%M"") : '');
			$substitutionarray['__DATE_DELIVERY_SS__'] = (isset($object->date_livraison) ? dol_print_date($object->date_livraison, ""%S"") : '');

			// For backward compatibility
			$substitutionarray['__REFCLIENT__'] = (isset($object->ref_client) ? $object->ref_client : (isset($object->ref_customer) ? $object->ref_customer : null));
			$substitutionarray['__REFSUPPLIER__'] = (isset($object->ref_supplier) ? $object->ref_supplier : null);
			$substitutionarray['__SUPPLIER_ORDER_DATE_DELIVERY__'] = (isset($object->date_livraison) ? dol_print_date($object->date_livraison, 'day', 0, $outputlangs) : '');
			$substitutionarray['__SUPPLIER_ORDER_DELAY_DELIVERY__'] = (isset($object->availability_code) ? ($outputlangs->transnoentities(""AvailabilityType"".$object->availability_code) != ('AvailabilityType'.$object->availability_code) ? $outputlangs->transnoentities(""AvailabilityType"".$object->availability_code) : $outputlangs->convToOutputCharset(isset($object->availability) ? $object->availability : '')) : '');

			if (is_object($object) && ($object->element == 'adherent' || $object->element == 'member') && $object->id > 0) {
				$birthday = (empty($object->birth) ? '' : dol_print_date($object->birth, 'day'));

				$substitutionarray['__MEMBER_ID__'] = (isset($object->id) ? $object->id : '');
				if (method_exists($object, 'getCivilityLabel')) {
					$substitutionarray['__MEMBER_CIVILITY__'] = $object->getCivilityLabel();
				}
				$substitutionarray['__MEMBER_FIRSTNAME__'] = (isset($object->firstname) ? $object->firstname : '');
				$substitutionarray['__MEMBER_LASTNAME__'] = (isset($object->lastname) ? $object->lastname : '');
				$substitutionarray['__MEMBER_USER_LOGIN_INFORMATION__'] = '';
				if (method_exists($object, 'getFullName')) {
					$substitutionarray['__MEMBER_FULLNAME__'] = $object->getFullName($outputlangs);
				}
				$substitutionarray['__MEMBER_COMPANY__'] = (isset($object->societe) ? $object->societe : '');
				$substitutionarray['__MEMBER_ADDRESS__'] = (isset($object->address) ? $object->address : '');
				$substitutionarray['__MEMBER_ZIP__'] = (isset($object->zip) ? $object->zip : '');
				$substitutionarray['__MEMBER_TOWN__'] = (isset($object->town) ? $object->town : '');
				$substitutionarray['__MEMBER_COUNTRY__'] = (isset($object->country) ? $object->country : '');
				$substitutionarray['__MEMBER_EMAIL__'] = (isset($object->email) ? $object->email : '');
				$substitutionarray['__MEMBER_BIRTH__'] = (isset($birthday) ? $birthday : '');
				$substitutionarray['__MEMBER_PHOTO__'] = (isset($object->photo) ? $object->photo : '');
				$substitutionarray['__MEMBER_LOGIN__'] = (isset($object->login) ? $object->login : '');
				$substitutionarray['__MEMBER_PASSWORD__'] = (isset($object->pass) ? $object->pass : '');
				$substitutionarray['__MEMBER_PHONE__'] = (isset($object->phone) ? dol_print_phone($object->phone) : '');
				$substitutionarray['__MEMBER_PHONEPRO__'] = (isset($object->phone_perso) ? dol_print_phone($object->phone_perso) : '');
				$substitutionarray['__MEMBER_PHONEMOBILE__'] = (isset($object->phone_mobile) ? dol_print_phone($object->phone_mobile) : '');
				$substitutionarray['__MEMBER_TYPE__'] = (isset($object->type) ? $object->type : '');
				$substitutionarray['__MEMBER_FIRST_SUBSCRIPTION_DATE__']       = dol_print_date($object->first_subscription_date, 'dayrfc');
				$substitutionarray['__MEMBER_FIRST_SUBSCRIPTION_DATE_START__'] = (isset($object->first_subscription_date_start) ? dol_print_date($object->first_subscription_date_start, 'dayrfc') : '');
				$substitutionarray['__MEMBER_FIRST_SUBSCRIPTION_DATE_END__']   = (isset($object->first_subscription_date_end) ? dol_print_date($object->first_subscription_date_end, 'dayrfc') : '');
				$substitutionarray['__MEMBER_LAST_SUBSCRIPTION_DATE__']        = dol_print_date($object->last_subscription_date, 'dayrfc');
				$substitutionarray['__MEMBER_LAST_SUBSCRIPTION_DATE_START__']  = dol_print_date($object->last_subscription_date_start, 'dayrfc');
				$substitutionarray['__MEMBER_LAST_SUBSCRIPTION_DATE_END__']    = dol_print_date($object->last_subscription_date_end, 'dayrfc');
			}

			if (is_object($object) && $object->element == 'societe') {
				$substitutionarray['__THIRDPARTY_ID__'] = (is_object($object) ? $object->id : '');
				$substitutionarray['__THIRDPARTY_NAME__'] = (is_object($object) ? $object->name : '');
				$substitutionarray['__THIRDPARTY_NAME_ALIAS__'] = (is_object($object) ? $object->name_alias : '');
				$substitutionarray['__THIRDPARTY_CODE_CLIENT__'] = (is_object($object) ? $object->code_client : '');
				$substitutionarray['__THIRDPARTY_CODE_FOURNISSEUR__'] = (is_object($object) ? $object->code_fournisseur : '');
				$substitutionarray['__THIRDPARTY_EMAIL__'] = (is_object($object) ? $object->email : '');
				$substitutionarray['__THIRDPARTY_PHONE__'] = (is_object($object) ? dol_print_phone($object->phone) : '');
				$substitutionarray['__THIRDPARTY_FAX__'] = (is_object($object) ? dol_print_phone($object->fax) : '');
				$substitutionarray['__THIRDPARTY_ADDRESS__'] = (is_object($object) ? $object->address : '');
				$substitutionarray['__THIRDPARTY_ZIP__'] = (is_object($object) ? $object->zip : '');
				$substitutionarray['__THIRDPARTY_TOWN__'] = (is_object($object) ? $object->town : '');
				$substitutionarray['__THIRDPARTY_COUNTRY_ID__'] = (is_object($object) ? $object->country_id : '');
				$substitutionarray['__THIRDPARTY_COUNTRY_CODE__'] = (is_object($object) ? $object->country_code : '');
				$substitutionarray['__THIRDPARTY_IDPROF1__'] = (is_object($object) ? $object->idprof1 : '');
				$substitutionarray['__THIRDPARTY_IDPROF2__'] = (is_object($object) ? $object->idprof2 : '');
				$substitutionarray['__THIRDPARTY_IDPROF3__'] = (is_object($object) ? $object->idprof3 : '');
				$substitutionarray['__THIRDPARTY_IDPROF4__'] = (is_object($object) ? $object->idprof4 : '');
				$substitutionarray['__THIRDPARTY_IDPROF5__'] = (is_object($object) ? $object->idprof5 : '');
				$substitutionarray['__THIRDPARTY_IDPROF6__'] = (is_object($object) ? $object->idprof6 : '');
				$substitutionarray['__THIRDPARTY_TVAINTRA__'] = (is_object($object) ? $object->tva_intra : '');
				$substitutionarray['__THIRDPARTY_NOTE_PUBLIC__'] = (is_object($object) ? dol_htmlentitiesbr($object->note_public) : '');
				$substitutionarray['__THIRDPARTY_NOTE_PRIVATE__'] = (is_object($object) ? dol_htmlentitiesbr($object->note_private) : '');
			} elseif (is_object($object->thirdparty)) {
				$substitutionarray['__THIRDPARTY_ID__'] = (is_object($object->thirdparty) ? $object->thirdparty->id : '');
				$substitutionarray['__THIRDPARTY_NAME__'] = (is_object($object->thirdparty) ? $object->thirdparty->name : '');
				$substitutionarray['__THIRDPARTY_NAME_ALIAS__'] = (is_object($object->thirdparty) ? $object->thirdparty->name_alias : '');
				$substitutionarray['__THIRDPARTY_CODE_CLIENT__'] = (is_object($object->thirdparty) ? $object->thirdparty->code_client : '');
				$substitutionarray['__THIRDPARTY_CODE_FOURNISSEUR__'] = (is_object($object->thirdparty) ? $object->thirdparty->code_fournisseur : '');
				$substitutionarray['__THIRDPARTY_EMAIL__'] = (is_object($object->thirdparty) ? $object->thirdparty->email : '');
				$substitutionarray['__THIRDPARTY_PHONE__'] = (is_object($object->thirdparty) ? dol_print_phone($object->thirdparty->phone) : '');
				$substitutionarray['__THIRDPARTY_FAX__'] = (is_object($object->thirdparty) ? dol_print_phone($object->thirdparty->fax) : '');
				$substitutionarray['__THIRDPARTY_ADDRESS__'] = (is_object($object->thirdparty) ? $object->thirdparty->address : '');
				$substitutionarray['__THIRDPARTY_ZIP__'] = (is_object($object->thirdparty) ? $object->thirdparty->zip : '');
				$substitutionarray['__THIRDPARTY_TOWN__'] = (is_object($object->thirdparty) ? $object->thirdparty->town : '');
				$substitutionarray['__THIRDPARTY_COUNTRY_ID__'] = (is_object($object->thirdparty) ? $object->thirdparty->country_id : '');
				$substitutionarray['__THIRDPARTY_COUNTRY_CODE__'] = (is_object($object->thirdparty) ? $object->thirdparty->country_code : '');
				$substitutionarray['__THIRDPARTY_IDPROF1__'] = (is_object($object->thirdparty) ? $object->thirdparty->idprof1 : '');
				$substitutionarray['__THIRDPARTY_IDPROF2__'] = (is_object($object->thirdparty) ? $object->thirdparty->idprof2 : '');
				$substitutionarray['__THIRDPARTY_IDPROF3__'] = (is_object($object->thirdparty) ? $object->thirdparty->idprof3 : '');
				$substitutionarray['__THIRDPARTY_IDPROF4__'] = (is_object($object->thirdparty) ? $object->thirdparty->idprof4 : '');
				$substitutionarray['__THIRDPARTY_IDPROF5__'] = (is_object($object->thirdparty) ? $object->thirdparty->idprof5 : '');
				$substitutionarray['__THIRDPARTY_IDPROF6__'] = (is_object($object->thirdparty) ? $object->thirdparty->idprof6 : '');
				$substitutionarray['__THIRDPARTY_TVAINTRA__'] = (is_object($object->thirdparty) ? $object->thirdparty->tva_intra : '');
				$substitutionarray['__THIRDPARTY_NOTE_PUBLIC__'] = (is_object($object->thirdparty) ? dol_htmlentitiesbr($object->thirdparty->note_public) : '');
				$substitutionarray['__THIRDPARTY_NOTE_PRIVATE__'] = (is_object($object->thirdparty) ? dol_htmlentitiesbr($object->thirdparty->note_private) : '');
			}

			if (is_object($object) && $object->element == 'recruitmentcandidature') {
				$substitutionarray['__CANDIDATE_FULLNAME__'] = $object->getFullName($outputlangs);
				$substitutionarray['__CANDIDATE_FIRSTNAME__'] = isset($object->firstname) ? $object->firstname : '';
				$substitutionarray['__CANDIDATE_LASTNAME__'] = isset($object->lastname) ? $object->lastname : '';
			}

			if (is_object($object->project)) {
				$substitutionarray['__PROJECT_ID__'] = (is_object($object->project) ? $object->project->id : '');
				$substitutionarray['__PROJECT_REF__'] = (is_object($object->project) ? $object->project->ref : '');
				$substitutionarray['__PROJECT_NAME__'] = (is_object($object->project) ? $object->project->title : '');
			}
			if (is_object($object->projet)) {	// Deprecated, for backward compatibility
				$substitutionarray['__PROJECT_ID__'] = (is_object($object->projet) ? $object->projet->id : '');
				$substitutionarray['__PROJECT_REF__'] = (is_object($object->projet) ? $object->projet->ref : '');
				$substitutionarray['__PROJECT_NAME__'] = (is_object($object->projet) ? $object->projet->title : '');
			}
			if (is_object($object) && $object->element == 'project') {
				$substitutionarray['__PROJECT_NAME__'] = $object->title;
			}

			if (is_object($object) && $object->element == 'shipping') {
				$substitutionarray['__SHIPPINGTRACKNUM__'] = $object->tracking_number;
				$substitutionarray['__SHIPPINGTRACKNUMURL__'] = $object->tracking_url;
			}
			if (is_object($object) && $object->element == 'reception') {
				$substitutionarray['__RECEPTIONTRACKNUM__'] = $object->tracking_number;
				$substitutionarray['__RECEPTIONTRACKNUMURL__'] = $object->tracking_url;
			}

			if (is_object($object) && $object->element == 'contrat' && $object->id > 0 && is_array($object->lines)) {
				$dateplannedstart = '';
				$datenextexpiration = '';
				foreach ($object->lines as $line) {
					if ($line->date_start > $dateplannedstart) {
						$dateplannedstart = $line->date_start;
					}
					if ($line->statut == 4 && $line->date_end && (!$datenextexpiration || $line->date_end < $datenextexpiration)) {
						$datenextexpiration = $line->date_end;
					}
				}
				$substitutionarray['__CONTRACT_HIGHEST_PLANNED_START_DATE__'] = dol_print_date($dateplannedstart, 'dayrfc');
				$substitutionarray['__CONTRACT_HIGHEST_PLANNED_START_DATETIME__'] = dol_print_date($dateplannedstart, 'standard');
				$substitutionarray['__CONTRACT_LOWEST_EXPIRATION_DATE__'] = dol_print_date($datenextexpiration, 'dayrfc');
				$substitutionarray['__CONTRACT_LOWEST_EXPIRATION_DATETIME__'] = dol_print_date($datenextexpiration, 'standard');
			}
			// add substition variable for ticket
			if (is_object($object) && $object->element == 'ticket') {
				$substitutionarray['__TICKET_TRACKID__'] = $object->track_id;
				$substitutionarray['__REF__'] = $object->ref;
				$substitutionarray['__TICKET_SUBJECT__'] = $object->subject;
				$substitutionarray['__TICKET_TYPE__'] = $object->type_code;
				$substitutionarray['__TICKET_SEVERITY__'] = $object->severity_code;
				$substitutionarray['__TICKET_CATEGORY__'] = $object->category_code; // For backward compatibility
				$substitutionarray['__TICKET_ANALYTIC_CODE__'] = $object->category_code;
				$substitutionarray['__TICKET_MESSAGE__'] = $object->message;
				$substitutionarray['__TICKET_PROGRESSION__'] = $object->progress;
				$userstat = new User($db);
				if ($object->fk_user_assign > 0) {
					$userstat->fetch($object->fk_user_assign);
					$substitutionarray['__TICKET_USER_ASSIGN__'] = dolGetFirstLastname($userstat->firstname, $userstat->lastname);
				}

				if ($object->fk_user_create > 0) {
					$userstat->fetch($object->fk_user_create);
					$substitutionarray['__USER_CREATE__'] = dolGetFirstLastname($userstat->firstname, $userstat->lastname);
				}
			}

			// Create dynamic tags for __EXTRAFIELD_FIELD__
			if ($object->table_element && $object->id > 0) {
				if (!is_object($extrafields)) {
					$extrafields = new ExtraFields($db);
				}
				$extrafields->fetch_name_optionals_label($object->table_element, true);

				if ($object->fetch_optionals() > 0) {
					if (is_array($extrafields->attributes[$object->table_element]['label']) && count($extrafields->attributes[$object->table_element]['label']) > 0) {
						foreach ($extrafields->attributes[$object->table_element]['label'] as $key => $label) {
							if ($extrafields->attributes[$object->table_element]['type'][$key] == 'date') {
								$substitutionarray['__EXTRAFIELD_'.strtoupper($key).'__'] = dol_print_date($object->array_options['options_'.$key], 'day');
								$substitutionarray['__EXTRAFIELD_'.strtoupper($key).'_LOCALE__'] = dol_print_date($object->array_options['options_'.$key], 'day', 'tzserver', $outputlangs);
								$substitutionarray['__EXTRAFIELD_'.strtoupper($key).'_RFC__'] = dol_print_date($object->array_options['options_'.$key], 'dayrfc');
							} elseif ($extrafields->attributes[$object->table_element]['type'][$key] == 'datetime') {
								$datetime = $object->array_options['options_'.$key];
								$substitutionarray['__EXTRAFIELD_'.strtoupper($key).'__'] = ($datetime != ""0000-00-00 00:00:00"" ? dol_print_date($datetime, 'dayhour') : '');
								$substitutionarray['__EXTRAFIELD_'.strtoupper($key).'_LOCALE__'] = ($datetime != ""0000-00-00 00:00:00"" ? dol_print_date($datetime, 'dayhour', 'tzserver', $outputlangs) : '');
								$substitutionarray['__EXTRAFIELD_'.strtoupper($key).'_DAY_LOCALE__'] = ($datetime != ""0000-00-00 00:00:00"" ? dol_print_date($datetime, 'day', 'tzserver', $outputlangs) : '');
								$substitutionarray['__EXTRAFIELD_'.strtoupper($key).'_RFC__'] = ($datetime != ""0000-00-00 00:00:00"" ? dol_print_date($datetime, 'dayhourrfc') : '');
							} elseif ($extrafields->attributes[$object->table_element]['type'][$key] == 'phone') {
								$substitutionarray['__EXTRAFIELD_'.strtoupper($key).'__'] = dol_print_phone($object->array_options['options_'.$key]);
							} elseif ($extrafields->attributes[$object->table_element]['type'][$key] == 'price') {
								$substitutionarray['__EXTRAFIELD_'.strtoupper($key).'__'] = $object->array_options['options_'.$key];
								$substitutionarray['__EXTRAFIELD_'.strtoupper($key).'_FORMATED__'] = price($object->array_options['options_'.$key]);
							} elseif ($extrafields->attributes[$object->table_element]['type'][$key] != 'separator') {
								$substitutionarray['__EXTRAFIELD_'.strtoupper($key).'__'] = $object->array_options['options_'.$key];
							}
						}
					}
				}
			}

			// Complete substitution array with the url to make online payment
			$paymenturl = '';
			if (empty($substitutionarray['__REF__'])) {
				$paymenturl = '';
			} else {
				// Set the online payment url link into __ONLINE_PAYMENT_URL__ key
				require_once DOL_DOCUMENT_ROOT.'/core/lib/payments.lib.php';
				$outputlangs->loadLangs(array('paypal', 'other'));

				$amounttouse = 0;
				$typeforonlinepayment = 'free';
				if (is_object($object) && $object->element == 'commande') {
					$typeforonlinepayment = 'order';
				}
				if (is_object($object) && $object->element == 'facture') {
					$typeforonlinepayment = 'invoice';
				}
				if (is_object($object) && $object->element == 'member') {
					$typeforonlinepayment = 'member';
					if (!empty($object->last_subscription_amount)) {
						$amounttouse = $object->last_subscription_amount;
					}
				}
				if (is_object($object) && $object->element == 'contrat') {
					$typeforonlinepayment = 'contract';
				}
				if (is_object($object) && $object->element == 'fichinter') {
					$typeforonlinepayment = 'ficheinter';
				}

				$url = getOnlinePaymentUrl(0, $typeforonlinepayment, $substitutionarray['__REF__'], $amounttouse);
				$paymenturl = $url;
			}

			if ($object->id > 0) {
				$substitutionarray['__ONLINE_PAYMENT_TEXT_AND_URL__'] = ($paymenturl ?str_replace('\n', ""\n"", $outputlangs->trans(""PredefinedMailContentLink"", $paymenturl)) : '');
				$substitutionarray['__ONLINE_PAYMENT_URL__'] = $paymenturl;

				if (!empty($conf->global->PROPOSAL_ALLOW_EXTERNAL_DOWNLOAD) && is_object($object) && $object->element == 'propal') {
					$substitutionarray['__DIRECTDOWNLOAD_URL_PROPOSAL__'] = $object->getLastMainDocLink($object->element);
				} else {
					$substitutionarray['__DIRECTDOWNLOAD_URL_PROPOSAL__'] = '';
				}
				if (!empty($conf->global->ORDER_ALLOW_EXTERNAL_DOWNLOAD) && is_object($object) && $object->element == 'commande') {
					$substitutionarray['__DIRECTDOWNLOAD_URL_ORDER__'] = $object->getLastMainDocLink($object->element);
				} else {
					$substitutionarray['__DIRECTDOWNLOAD_URL_ORDER__'] = '';
				}
				if (!empty($conf->global->INVOICE_ALLOW_EXTERNAL_DOWNLOAD) && is_object($object) && $object->element == 'facture') {
					$substitutionarray['__DIRECTDOWNLOAD_URL_INVOICE__'] = $object->getLastMainDocLink($object->element);
				} else {
					$substitutionarray['__DIRECTDOWNLOAD_URL_INVOICE__'] = '';
				}
				if (!empty($conf->global->CONTRACT_ALLOW_EXTERNAL_DOWNLOAD) && is_object($object) && $object->element == 'contrat') {
					$substitutionarray['__DIRECTDOWNLOAD_URL_CONTRACT__'] = $object->getLastMainDocLink($object->element);
				} else {
					$substitutionarray['__DIRECTDOWNLOAD_URL_CONTRACT__'] = '';
				}
				if (!empty($conf->global->FICHINTER_ALLOW_EXTERNAL_DOWNLOAD) && is_object($object) && $object->element == 'fichinter') {
					$substitutionarray['__DIRECTDOWNLOAD_URL_FICHINTER__'] = $object->getLastMainDocLink($object->element);
				} else {
					$substitutionarray['__DIRECTDOWNLOAD_URL_FICHINTER__'] = '';
				}
				if (!empty($conf->global->SUPPLIER_PROPOSAL_ALLOW_EXTERNAL_DOWNLOAD) && is_object($object) && $object->element == 'supplier_proposal') {
					$substitutionarray['__DIRECTDOWNLOAD_URL_SUPPLIER_PROPOSAL__'] = $object->getLastMainDocLink($object->element);
				} else {
					$substitutionarray['__DIRECTDOWNLOAD_URL_SUPPLIER_PROPOSAL__'] = '';
				}

				if (is_object($object) && $object->element == 'propal') {
					$substitutionarray['__URL_PROPOSAL__'] = DOL_MAIN_URL_ROOT.""/comm/propal/card.php?id="".$object->id;
					require_once DOL_DOCUMENT_ROOT.'/core/lib/signature.lib.php';
					$substitutionarray['__ONLINE_SIGN_URL__'] = getOnlineSignatureUrl(0, 'proposal', $object->ref);
				}
				if (is_object($object) && $object->element == 'commande') {
					$substitutionarray['__URL_ORDER__'] = DOL_MAIN_URL_ROOT.""/commande/card.php?id="".$object->id;
				}
				if (is_object($object) && $object->element == 'facture') {
					$substitutionarray['__URL_INVOICE__'] = DOL_MAIN_URL_ROOT.""/compta/facture/card.php?id="".$object->id;
				}
				if (is_object($object) && $object->element == 'contrat') {
					$substitutionarray['__URL_CONTRACT__'] = DOL_MAIN_URL_ROOT.""/contrat/card.php?id="".$object->id;
					require_once DOL_DOCUMENT_ROOT.'/core/lib/signature.lib.php';
					$substitutionarray['__ONLINE_SIGN_URL__'] = getOnlineSignatureUrl(0, 'contract', $object->ref);
				}
				if (is_object($object) && $object->element == 'fichinter') {
					$substitutionarray['__URL_FICHINTER__'] = DOL_MAIN_URL_ROOT.""/fichinter/card.php?id="".$object->id;
					require_once DOL_DOCUMENT_ROOT.'/core/lib/signature.lib.php';
					$substitutionarray['__ONLINE_SIGN_FICHINTER_URL__'] = getOnlineSignatureUrl(0, 'fichinter', $object->ref);
				}
				if (is_object($object) && $object->element == 'supplier_proposal') {
					$substitutionarray['__URL_SUPPLIER_PROPOSAL__'] = DOL_MAIN_URL_ROOT.""/supplier_proposal/card.php?id="".$object->id;
				}
				if (is_object($object) && $object->element == 'shipping') {
					$substitutionarray['__URL_SHIPMENT__'] = DOL_MAIN_URL_ROOT.""/expedition/card.php?id="".$object->id;
				}
			}

			if (is_object($object) && $object->element == 'action') {
				$substitutionarray['__EVENT_LABEL__'] = $object->label;
				$substitutionarray['__EVENT_DATE__'] = dol_print_date($object->datep, '%A %d %b %Y');
				$substitutionarray['__EVENT_TIME__'] = dol_print_date($object->datep, '%H:%M:%S');
			}
		}
	}
	if ((empty($exclude) || !in_array('objectamount', $exclude)) && (empty($include) || in_array('objectamount', $include))) {
		include_once DOL_DOCUMENT_ROOT.'/core/lib/functionsnumtoword.lib.php';

		$substitutionarray['__DATE_YMD__']        = is_object($object) ? (isset($object->date) ? dol_print_date($object->date, 'day', 0, $outputlangs) : null) : '';
		$substitutionarray['__DATE_DUE_YMD__']    = is_object($object) ? (isset($object->date_lim_reglement) ? dol_print_date($object->date_lim_reglement, 'day', 0, $outputlangs) : null) : '';

		$already_payed_all = 0;
		if (is_object($object) && ($object instanceof Facture)) {
			$already_payed_all = $object->sumpayed + $object->sumdeposit + $object->sumcreditnote;
		}

		$substitutionarray['__AMOUNT_EXCL_TAX__'] = is_object($object) ? $object->total_ht : '';

		$substitutionarray['__AMOUNT__']          = is_object($object) ? $object->total_ttc : '';
		$substitutionarray['__AMOUNT_TEXT__']     = is_object($object) ? dol_convertToWord($object->total_ttc, $outputlangs, '', true) : '';
		$substitutionarray['__AMOUNT_TEXTCURRENCY__'] = is_object($object) ? dol_convertToWord($object->total_ttc, $outputlangs, $conf->currency, true) : '';

		$substitutionarray['__AMOUNT_REMAIN__'] = is_object($object) ? price2num($object->total_ttc - $already_payed_all, 'MT') : '';

		$substitutionarray['__AMOUNT_VAT__']      = is_object($object) ? (isset($object->total_vat) ? $object->total_vat : $object->total_tva) : '';
		$substitutionarray['__AMOUNT_VAT_TEXT__']      = is_object($object) ? (isset($object->total_vat) ? dol_convertToWord($object->total_vat, $outputlangs, '', true) : dol_convertToWord($object->total_tva, $outputlangs, '', true)) : '';
		$substitutionarray['__AMOUNT_VAT_TEXTCURRENCY__']      = is_object($object) ? (isset($object->total_vat) ? dol_convertToWord($object->total_vat, $outputlangs, $conf->currency, true) : dol_convertToWord($object->total_tva, $outputlangs, $conf->currency, true)) : '';

		if ($onlykey != 2 || $mysoc->useLocalTax(1)) {
			$substitutionarray['__AMOUNT_TAX2__']     = is_object($object) ? $object->total_localtax1 : '';
		}
		if ($onlykey != 2 || $mysoc->useLocalTax(2)) {
			$substitutionarray['__AMOUNT_TAX3__']     = is_object($object) ? $object->total_localtax2 : '';
		}

		// Amount keys formated in a currency
		$substitutionarray['__AMOUNT_EXCL_TAX_FORMATED__'] = is_object($object) ? ($object->total_ht ? price($object->total_ht, 0, $outputlangs, 0, -1, -1, $conf->currency) : null) : '';
		$substitutionarray['__AMOUNT_FORMATED__']          = is_object($object) ? ($object->total_ttc ? price($object->total_ttc, 0, $outputlangs, 0, -1, -1, $conf->currency) : null) : '';
		$substitutionarray['__AMOUNT_REMAIN_FORMATED__'] = is_object($object) ? ($object->total_ttc ? price($object->total_ttc - $already_payed_all, 0, $outputlangs, 0, -1, -1, $conf->currency) : null) : '';
		$substitutionarray['__AMOUNT_VAT_FORMATED__']      = is_object($object) ? (isset($object->total_vat) ? price($object->total_vat, 0, $outputlangs, 0, -1, -1, $conf->currency) : ($object->total_tva ? price($object->total_tva, 0, $outputlangs, 0, -1, -1, $conf->currency) : null)) : '';
		if ($onlykey != 2 || $mysoc->useLocalTax(1)) {
			$substitutionarray['__AMOUNT_TAX2_FORMATED__']     = is_object($object) ? ($object->total_localtax1 ? price($object->total_localtax1, 0, $outputlangs, 0, -1, -1, $conf->currency) : null) : '';
		}
		if ($onlykey != 2 || $mysoc->useLocalTax(2)) {
			$substitutionarray['__AMOUNT_TAX3_FORMATED__']     = is_object($object) ? ($object->total_localtax2 ? price($object->total_localtax2, 0, $outputlangs, 0, -1, -1, $conf->currency) : null) : '';
		}

		$substitutionarray['__AMOUNT_MULTICURRENCY__']          = (is_object($object) && isset($object->multicurrency_total_ttc)) ? $object->multicurrency_total_ttc : '';
		$substitutionarray['__AMOUNT_MULTICURRENCY_TEXT__']     = (is_object($object) && isset($object->multicurrency_total_ttc)) ? dol_convertToWord($object->multicurrency_total_ttc, $outputlangs, '', true) : '';
		$substitutionarray['__AMOUNT_MULTICURRENCY_TEXTCURRENCY__'] = (is_object($object) && isset($object->multicurrency_total_ttc)) ? dol_convertToWord($object->multicurrency_total_ttc, $outputlangs, $object->multicurrency_code, true) : '';
		// TODO Add other keys for foreign multicurrency

		// For backward compatibility
		if ($onlykey != 2) {
			$substitutionarray['__TOTAL_TTC__']    = is_object($object) ? $object->total_ttc : '';
			$substitutionarray['__TOTAL_HT__']     = is_object($object) ? $object->total_ht : '';
			$substitutionarray['__TOTAL_VAT__']    = is_object($object) ? (isset($object->total_vat) ? $object->total_vat : $object->total_tva) : '';
		}
	}

	//var_dump($substitutionarray['__AMOUNT_FORMATED__']);
	if ((empty($exclude) || !in_array('date', $exclude)) && (empty($include) || in_array('date', $include))) {
		include_once DOL_DOCUMENT_ROOT.'/core/lib/date.lib.php';

		$now = dol_now();

		$tmp = dol_getdate($now, true);
		$tmp2 = dol_get_prev_day($tmp['mday'], $tmp['mon'], $tmp['year']);
		$tmp3 = dol_get_prev_month($tmp['mon'], $tmp['year']);
		$tmp4 = dol_get_next_day($tmp['mday'], $tmp['mon'], $tmp['year']);
		$tmp5 = dol_get_next_month($tmp['mon'], $tmp['year']);

		$daytext = $outputlangs->trans('Day'.$tmp['wday']);

		$substitutionarray = array_merge($substitutionarray, array(
			'__NOW_TMS__' => (int) $now,
			'__NOW_TMS_YMD__' => dol_print_date($now, 'day', 0, $outputlangs),
			'__DAY__' => (string) $tmp['mday'],
			'__DAY_TEXT__' => $daytext, // Monday
			'__DAY_TEXT_SHORT__' => dol_trunc($daytext, 3, 'right', 'UTF-8', 1), // Mon
			'__DAY_TEXT_MIN__' => dol_trunc($daytext, 1, 'right', 'UTF-8', 1), // M
			'__MONTH__' => (string) $tmp['mon'],
			'__MONTH_TEXT__' => $outputlangs->trans('Month'.sprintf(""%02d"", $tmp['mon'])),
			'__MONTH_TEXT_SHORT__' => $outputlangs->trans('MonthShort'.sprintf(""%02d"", $tmp['mon'])),
			'__MONTH_TEXT_MIN__' => $outputlangs->trans('MonthVeryShort'.sprintf(""%02d"", $tmp['mon'])),
			'__YEAR__' => (string) $tmp['year'],
			'__PREVIOUS_DAY__' => (string) $tmp2['day'],
			'__PREVIOUS_MONTH__' => (string) $tmp3['month'],
			'__PREVIOUS_YEAR__' => (string) ($tmp['year'] - 1),
			'__NEXT_DAY__' => (string) $tmp4['day'],
			'__NEXT_MONTH__' => (string) $tmp5['month'],
			'__NEXT_YEAR__' => (string) ($tmp['year'] + 1),
		));
	}

	if (isModEnabled('multicompany')) {
		$substitutionarray = array_merge($substitutionarray, array('__ENTITY_ID__' => $conf->entity));
	}
	if ((empty($exclude) || !in_array('system', $exclude)) && (empty($include) || in_array('user', $include))) {
		$substitutionarray['__DOL_MAIN_URL_ROOT__'] = DOL_MAIN_URL_ROOT;
		$substitutionarray['__(AnyTranslationKey)__'] = $outputlangs->trans('TranslationOfKey');
		$substitutionarray['__(AnyTranslationKey|langfile)__'] = $outputlangs->trans('TranslationOfKey').' (load also language file before)';
		$substitutionarray['__[AnyConstantKey]__'] = $outputlangs->trans('ValueOfConstantKey');
	}

	return $substitutionarray;
}

/**
 *  Make substitution into a text string, replacing keys with vals from $substitutionarray (oldval=>newval),
 *  and texts like __(TranslationKey|langfile)__ and __[ConstantKey]__ are also replaced.
 *  Example of usage:
 *  $substitutionarray = getCommonSubstitutionArray($langs, 0, null, $thirdparty);
 *  complete_substitutions_array($substitutionarray, $langs, $thirdparty);
 *  $mesg = make_substitutions($mesg, $substitutionarray, $langs);
 *
 *  @param	string		$text	      					Source string in which we must do substitution
 *  @param  array		$substitutionarray				Array with key->val to substitute. Example: array('__MYKEY__' => 'MyVal', ...)
 *  @param	Translate	$outputlangs					Output language
 *  @param	int			$converttextinhtmlifnecessary	0=Convert only value into HTML if text is already in HTML
 *  													1=Will also convert initial $text into HTML if we try to insert one value that is HTML
 * 	@return string  		    						Output string after substitutions
 *  @see	complete_substitutions_array(), getCommonSubstitutionArray()
 */
function make_substitutions($text, $substitutionarray, $outputlangs = null, $converttextinhtmlifnecessary = 0)
{
	global $conf, $langs;

	if (!is_array($substitutionarray)) {
		return 'ErrorBadParameterSubstitutionArrayWhenCalling_make_substitutions';
	}

	if (empty($outputlangs)) {
		$outputlangs = $langs;
	}

	// Is initial text HTML or simple text ?
	$msgishtml = 0;
	if (dol_textishtml($text, 1)) {
		$msgishtml = 1;
	}

	// Make substitution for language keys: __(AnyTranslationKey)__ or __(AnyTranslationKey|langfile)__
	if (is_object($outputlangs)) {
		$reg = array();
		while (preg_match('/__\(([^\)]+)\)__/', $text, $reg)) {
			// If key is __(TranslationKey|langfile)__, then force load of langfile.lang
			$tmp = explode('|', $reg[1]);
			if (!empty($tmp[1])) {
				$outputlangs->load($tmp[1]);
			}

			$value = $outputlangs->transnoentitiesnoconv($reg[1]);

			if (empty($converttextinhtmlifnecessary)) {
				// convert $newval into HTML is necessary
				$text = preg_replace('/__\('.preg_quote($reg[1], '/').'\)__/', $msgishtml ? dol_htmlentitiesbr($value) : $value, $text);
			} else {
				if (! $msgishtml) {
					$valueishtml = dol_textishtml($value, 1);
					//var_dump(""valueishtml="".$valueishtml);

					if ($valueishtml) {
						$text = dol_htmlentitiesbr($text);
						$msgishtml = 1;
					}
				} else {
					$value = dol_nl2br(""$value"");
				}

				$text = preg_replace('/__\('.preg_quote($reg[1], '/').'\)__/', $value, $text);
			}
		}
	}

	// Make substitution for constant keys.
	// Must be after the substitution of translation, so if the text of translation contains a string __[xxx]__, it is also converted.
	$reg = array();
	while (preg_match('/__\[([^\]]+)\]__/', $text, $reg)) {
		$keyfound = $reg[1];
		if (isASecretKey($keyfound)) {
			$value = '*****forbidden*****';
		} else {
			$value = empty($conf->global->$keyfound) ? '' : $conf->global->$keyfound;
		}

		if (empty($converttextinhtmlifnecessary)) {
			// convert $newval into HTML is necessary
			$text = preg_replace('/__\['.preg_quote($keyfound, '/').'\]__/', $msgishtml ? dol_htmlentitiesbr($value) : $value, $text);
		} else {
			if (! $msgishtml) {
				$valueishtml = dol_textishtml($value, 1);

				if ($valueishtml) {
					$text = dol_htmlentitiesbr($text);
					$msgishtml = 1;
				}
			} else {
				$value = dol_nl2br(""$value"");
			}

			$text = preg_replace('/__\['.preg_quote($keyfound, '/').'\]__/', $value, $text);
		}
	}

	// Make substitution for array $substitutionarray
	foreach ($substitutionarray as $key => $value) {
		if (!isset($value)) {
			continue; // If value is null, it same than not having substitution key at all into array, we do not replace.
		}

		if (($key == '__USER_SIGNATURE__' || $key == '__SENDEREMAIL_SIGNATURE__') && (!empty($conf->global->MAIN_MAIL_DO_NOT_USE_SIGN))) {
			$value = ''; // Protection
		}

		if (empty($converttextinhtmlifnecessary)) {
			$text = str_replace(""$key"", ""$value"", $text); // We must keep the "" to work when value is 123.5 for example
		} else {
			if (! $msgishtml) {
				$valueishtml = dol_textishtml($value, 1);

				if ($valueishtml) {
					$text = dol_htmlentitiesbr($text);
					$msgishtml = 1;
				}
			} else {
				$value = dol_nl2br(""$value"");
			}
			$text = str_replace(""$key"", ""$value"", $text); // We must keep the "" to work when value is 123.5 for example
		}
	}

	return $text;
}

/**
 *  Complete the $substitutionarray with more entries coming from external module that had set the ""substitutions=1"" into module_part array.
 *  In this case, method completesubstitutionarray provided by module is called.
 *
 *  @param  array		$substitutionarray		Array substitution old value => new value value
 *  @param  Translate	$outputlangs            Output language
 *  @param  Object		$object                 Source object
 *  @param  mixed		$parameters       		Add more parameters (useful to pass product lines)
 *  @param  string      $callfunc               What is the name of the custom function that will be called? (default: completesubstitutionarray)
 *  @return	void
 *  @see 	make_substitutions()
 */
function complete_substitutions_array(&$substitutionarray, $outputlangs, $object = null, $parameters = null, $callfunc = ""completesubstitutionarray"")
{
	global $conf, $user;

	require_once DOL_DOCUMENT_ROOT.'/core/lib/files.lib.php';

	// Note: substitution key for each extrafields, using key __EXTRA_XXX__ is already available into the getCommonSubstitutionArray used to build the substitution array.

	// Check if there is external substitution to do, requested by plugins
	$dirsubstitutions = array_merge(array(), (array) $conf->modules_parts['substitutions']);

	foreach ($dirsubstitutions as $reldir) {
		$dir = dol_buildpath($reldir, 0);

		// Check if directory exists
		if (!dol_is_dir($dir)) {
			continue;
		}

		$substitfiles = dol_dir_list($dir, 'files', 0, 'functions_');
		foreach ($substitfiles as $substitfile) {
			$reg = array();
			if (preg_match('/functions_(.*)\.lib\.php/i', $substitfile['name'], $reg)) {
				$module = $reg[1];

				dol_syslog(""Library "".$substitfile['name']."" found into "".$dir);
				// Include the user's functions file
				require_once $dir.$substitfile['name'];
				// Call the user's function, and only if it is defined
				$function_name = $module.""_"".$callfunc;
				if (function_exists($function_name)) {
					$function_name($substitutionarray, $outputlangs, $object, $parameters);
				}
			}
		}
	}
	if (!empty($conf->global->ODT_ENABLE_ALL_TAGS_IN_SUBSTITUTIONS)) {
		// to list all tags in odt template
		$tags = '';
		foreach ($substitutionarray as $key => $value) {
			$tags .= '{'.$key.'} => '.$value.""\n"";
		}
		$substitutionarray = array_merge($substitutionarray, array('__ALL_TAGS__' => $tags));
	}
}

/**
 *    Format output for start and end date
 *
 *    @param	int	$date_start    Start date
 *    @param    int	$date_end      End date
 *    @param    string		$format        Output format
 *    @param	Translate	$outputlangs   Output language
 *    @return	void
 */
function print_date_range($date_start, $date_end, $format = '', $outputlangs = '')
{
	print get_date_range($date_start, $date_end, $format, $outputlangs);
}

/**
 *    Format output for start and end date
 *
 *    @param	int			$date_start    		Start date
 *    @param    int			$date_end      		End date
 *    @param    string		$format        		Output date format ('day', 'dayhour', ...)
 *    @param	Translate	$outputlangs   		Output language
 *    @param	integer		$withparenthesis	1=Add parenthesis, 0=no parenthesis
 *    @return	string							String
 */
function get_date_range($date_start, $date_end, $format = '', $outputlangs = '', $withparenthesis = 1)
{
	global $langs;

	$out = '';

	if (!is_object($outputlangs)) {
		$outputlangs = $langs;
	}

	if ($date_start && $date_end) {
		$out .= ($withparenthesis ? ' (' : '').$outputlangs->transnoentitiesnoconv('DateFromTo', dol_print_date($date_start, $format, false, $outputlangs), dol_print_date($date_end, $format, false, $outputlangs)).($withparenthesis ? ')' : '');
	}
	if ($date_start && !$date_end) {
		$out .= ($withparenthesis ? ' (' : '').$outputlangs->transnoentitiesnoconv('DateFrom', dol_print_date($date_start, $format, false, $outputlangs)).($withparenthesis ? ')' : '');
	}
	if (!$date_start && $date_end) {
		$out .= ($withparenthesis ? ' (' : '').$outputlangs->transnoentitiesnoconv('DateUntil', dol_print_date($date_end, $format, false, $outputlangs)).($withparenthesis ? ')' : '');
	}

	return $out;
}

/**
 * Return firstname and lastname in correct order
 *
 * @param	string	$firstname		Firstname
 * @param	string	$lastname		Lastname
 * @param	int		$nameorder		-1=Auto, 0=Lastname+Firstname, 1=Firstname+Lastname, 2=Firstname, 3=Firstname if defined else lastname, 4=Lastname, 5=Lastname if defined else firstname
 * @return	string					Firstname + lastname or Lastname + firstname
 */
function dolGetFirstLastname($firstname, $lastname, $nameorder = -1)
{
	global $conf;

	$ret = '';
	// If order not defined, we use the setup
	if ($nameorder < 0) {
		$nameorder = (empty($conf->global->MAIN_FIRSTNAME_NAME_POSITION) ? 1 : 0);
	}
	if ($nameorder == 1) {
		$ret .= $firstname;
		if ($firstname && $lastname) {
			$ret .= ' ';
		}
		$ret .= $lastname;
	} elseif ($nameorder == 2 || $nameorder == 3) {
		$ret .= $firstname;
		if (empty($ret) && $nameorder == 3) {
			$ret .= $lastname;
		}
	} else {	// 0, 4 or 5
		$ret .= $lastname;
		if (empty($ret) && $nameorder == 5) {
			$ret .= $firstname;
		}
		if ($nameorder == 0) {
			if ($firstname && $lastname) {
				$ret .= ' ';
			}
			$ret .= $firstname;
		}
	}
	return $ret;
}


/**
 *	Set event message in dol_events session object. Will be output by calling dol_htmloutput_events.
 *  Note: Calling dol_htmloutput_events is done into pages by standard llxFooter() function.
 *  Note: Prefer to use setEventMessages instead.
 *
 *	@param	string|string[] $mesgs			Message string or array
 *  @param  string          $style      	Which style to use ('mesgs' by default, 'warnings', 'errors')
 *  @param	int				$noduplicate	1 means we do not add the message if already present in session stack
 *  @return	void
 *  @see	dol_htmloutput_events()
 */
function setEventMessage($mesgs, $style = 'mesgs', $noduplicate = 0)
{
	//dol_syslog(__FUNCTION__ . "" is deprecated"", LOG_WARNING);		This is not deprecated, it is used by setEventMessages function
	if (!is_array($mesgs)) {
		// If mesgs is a string
		if ($mesgs) {
			if (!empty($noduplicate) && isset($_SESSION['dol_events'][$style]) && in_array($mesgs, $_SESSION['dol_events'][$style])) {
				return;
			}
			$_SESSION['dol_events'][$style][] = $mesgs;
		}
	} else {
		// If mesgs is an array
		foreach ($mesgs as $mesg) {
			if ($mesg) {
				if (!empty($noduplicate) && isset($_SESSION['dol_events'][$style]) && in_array($mesg, $_SESSION['dol_events'][$style])) {
					return;
				}
				$_SESSION['dol_events'][$style][] = $mesg;
			}
		}
	}
}

/**
 *	Set event messages in dol_events session object. Will be output by calling dol_htmloutput_events.
 *  Note: Calling dol_htmloutput_events is done into pages by standard llxFooter() function.
 *
 *	@param	string		$mesg			Message string
 *	@param	array|null	$mesgs			Message array
 *  @param  string		$style      	Which style to use ('mesgs' by default, 'warnings', 'errors')
 *  @param	string		$messagekey		A key to be used to allow the feature ""Never show this message again""
 *  @param	int			$noduplicate	1 means we do not add the message if already present in session stack
 *  @return	void
 *  @see	dol_htmloutput_events()
 */
function setEventMessages($mesg, $mesgs, $style = 'mesgs', $messagekey = '', $noduplicate = 0)
{
	if (empty($mesg) && empty($mesgs)) {
		dol_syslog(""Try to add a message in stack, but value to add is empty message"", LOG_WARNING);
	} else {
		if ($messagekey) {
			// Complete message with a js link to set a cookie ""DOLHIDEMESSAGE"".$messagekey;
			// TODO
			$mesg .= '';
		}
		if (empty($messagekey) || empty($_COOKIE[""DOLHIDEMESSAGE"".$messagekey])) {
			if (!in_array((string) $style, array('mesgs', 'warnings', 'errors'))) {
				dol_print_error('', 'Bad parameter style='.$style.' for setEventMessages');
			}
			if (empty($mesgs)) {
				setEventMessage($mesg, $style, $noduplicate);
			} else {
				if (!empty($mesg) && !in_array($mesg, $mesgs)) {
					setEventMessage($mesg, $style, $noduplicate); // Add message string if not already into array
				}
				setEventMessage($mesgs, $style, $noduplicate);
			}
		}
	}
}

/**
 *	Print formated messages to output (Used to show messages on html output).
 *  Note: Calling dol_htmloutput_events is done into pages by standard llxFooter() function, so there is
 *  no need to call it explicitely.
 *
 *  @param	int		$disabledoutputofmessages	Clear all messages stored into session without diplaying them
 *  @return	void
 *  @see    									dol_htmloutput_mesg()
 */
function dol_htmloutput_events($disabledoutputofmessages = 0)
{
	// Show mesgs
	if (isset($_SESSION['dol_events']['mesgs'])) {
		if (empty($disabledoutputofmessages)) {
			dol_htmloutput_mesg('', $_SESSION['dol_events']['mesgs']);
		}
		unset($_SESSION['dol_events']['mesgs']);
	}
	// Show errors
	if (isset($_SESSION['dol_events']['errors'])) {
		if (empty($disabledoutputofmessages)) {
			dol_htmloutput_mesg('', $_SESSION['dol_events']['errors'], 'error');
		}
		unset($_SESSION['dol_events']['errors']);
	}

	// Show warnings
	if (isset($_SESSION['dol_events']['warnings'])) {
		if (empty($disabledoutputofmessages)) {
			dol_htmloutput_mesg('', $_SESSION['dol_events']['warnings'], 'warning');
		}
		unset($_SESSION['dol_events']['warnings']);
	}
}

/**
 *	Get formated messages to output (Used to show messages on html output).
 *  This include also the translation of the message key.
 *
 *	@param	string		$mesgstring		Message string or message key
 *	@param	string[]	$mesgarray      Array of message strings or message keys
 *  @param  string		$style          Style of message output ('ok' or 'error')
 *  @param  int			$keepembedded   Set to 1 in error message must be kept embedded into its html place (this disable jnotify)
 *	@return	string						Return html output
 *
 *  @see    dol_print_error()
 *  @see    dol_htmloutput_errors()
 *  @see    setEventMessages()
 */
function get_htmloutput_mesg($mesgstring = '', $mesgarray = '', $style = 'ok', $keepembedded = 0)
{
	global $conf, $langs;

	$ret = 0;
	$return = '';
	$out = '';
	$divstart = $divend = '';

	// If inline message with no format, we add it.
	if ((empty($conf->use_javascript_ajax) || !empty($conf->global->MAIN_DISABLE_JQUERY_JNOTIFY) || $keepembedded) && !preg_match('/<div class="".*"">/i', $out)) {
		$divstart = '<div class=""'.$style.' clearboth"">';
		$divend = '</div>';
	}

	if ((is_array($mesgarray) && count($mesgarray)) || $mesgstring) {
		$langs->load(""errors"");
		$out .= $divstart;
		if (is_array($mesgarray) && count($mesgarray)) {
			foreach ($mesgarray as $message) {
				$ret++;
				$out .= $langs->trans($message);
				if ($ret < count($mesgarray)) {
					$out .= ""<br>\n"";
				}
			}
		}
		if ($mesgstring) {
			$ret++;
			$out .= $langs->trans($mesgstring);
		}
		$out .= $divend;
	}

	if ($out) {
		if (!empty($conf->use_javascript_ajax) && empty($conf->global->MAIN_DISABLE_JQUERY_JNOTIFY) && empty($keepembedded)) {
			$return = '<script nonce=""'.getNonce().'"">
					$(document).ready(function() {
						var block = '.(!empty($conf->global->MAIN_USE_JQUERY_BLOCKUI) ? ""true"" : ""false"").'
						if (block) {
							$.dolEventValid("""",""'.dol_escape_js($out).'"");
						} else {
							/* jnotify(message, preset of message type, keepmessage) */
							$.jnotify(""'.dol_escape_js($out).'"",
							""'.($style == ""ok"" ? 3000 : $style).'"",
							'.($style == ""ok"" ? ""false"" : ""true"").',
							{ remove: function (){} } );
						}
					});
				</script>';
		} else {
			$return = $out;
		}
	}

	return $return;
}

/**
 *  Get formated error messages to output (Used to show messages on html output).
 *
 *  @param  string	$mesgstring         Error message
 *  @param  array	$mesgarray          Error messages array
 *  @param  int		$keepembedded       Set to 1 in error message must be kept embedded into its html place (this disable jnotify)
 *  @return string                		Return html output
 *
 *  @see    dol_print_error()
 *  @see    dol_htmloutput_mesg()
 */
function get_htmloutput_errors($mesgstring = '', $mesgarray = array(), $keepembedded = 0)
{
	return get_htmloutput_mesg($mesgstring, $mesgarray, 'error', $keepembedded);
}

/**
 *	Print formated messages to output (Used to show messages on html output).
 *
 *	@param	string		$mesgstring		Message string or message key
 *	@param	string[]	$mesgarray      Array of message strings or message keys
 *	@param  string      $style          Which style to use ('ok', 'warning', 'error')
 *	@param  int         $keepembedded   Set to 1 if message must be kept embedded into its html place (this disable jnotify)
 *	@return	void
 *
 *	@see    dol_print_error()
 *	@see    dol_htmloutput_errors()
 *	@see    setEventMessages()
 */
function dol_htmloutput_mesg($mesgstring = '', $mesgarray = array(), $style = 'ok', $keepembedded = 0)
{
	if (empty($mesgstring) && (!is_array($mesgarray) || count($mesgarray) == 0)) {
		return;
	}

	$iserror = 0;
	$iswarning = 0;
	if (is_array($mesgarray)) {
		foreach ($mesgarray as $val) {
			if ($val && preg_match('/class=""error""/i', $val)) {
				$iserror++;
				break;
			}
			if ($val && preg_match('/class=""warning""/i', $val)) {
				$iswarning++;
				break;
			}
		}
	} elseif ($mesgstring && preg_match('/class=""error""/i', $mesgstring)) {
		$iserror++;
	} elseif ($mesgstring && preg_match('/class=""warning""/i', $mesgstring)) {
		$iswarning++;
	}
	if ($style == 'error') {
		$iserror++;
	}
	if ($style == 'warning') {
		$iswarning++;
	}

	if ($iserror || $iswarning) {
		// Remove div from texts
		$mesgstring = preg_replace('/<\/div><div class=""(error|warning)"">/', '<br>', $mesgstring);
		$mesgstring = preg_replace('/<div class=""(error|warning)"">/', '', $mesgstring);
		$mesgstring = preg_replace('/<\/div>/', '', $mesgstring);
		// Remove div from texts array
		if (is_array($mesgarray)) {
			$newmesgarray = array();
			foreach ($mesgarray as $val) {
				if (is_string($val)) {
					$tmpmesgstring = preg_replace('/<\/div><div class=""(error|warning)"">/', '<br>', $val);
					$tmpmesgstring = preg_replace('/<div class=""(error|warning)"">/', '', $tmpmesgstring);
					$tmpmesgstring = preg_replace('/<\/div>/', '', $tmpmesgstring);
					$newmesgarray[] = $tmpmesgstring;
				} else {
					dol_syslog(""Error call of dol_htmloutput_mesg with an array with a value that is not a string"", LOG_WARNING);
				}
			}
			$mesgarray = $newmesgarray;
		}
		print get_htmloutput_mesg($mesgstring, $mesgarray, ($iserror ? 'error' : 'warning'), $keepembedded);
	} else {
		print get_htmloutput_mesg($mesgstring, $mesgarray, 'ok', $keepembedded);
	}
}

/**
 *  Print formated error messages to output (Used to show messages on html output).
 *
 *  @param	string	$mesgstring          Error message
 *  @param  array	$mesgarray           Error messages array
 *  @param  int		$keepembedded        Set to 1 in error message must be kept embedded into its html place (this disable jnotify)
 *  @return	void
 *
 *  @see    dol_print_error()
 *  @see    dol_htmloutput_mesg()
 */
function dol_htmloutput_errors($mesgstring = '', $mesgarray = array(), $keepembedded = 0)
{
	dol_htmloutput_mesg($mesgstring, $mesgarray, 'error', $keepembedded);
}

/**
 * 	Advanced sort array by second index function, which produces ascending (default)
 *  or descending output and uses optionally natural case insensitive sorting (which
 *  can be optionally case sensitive as well).
 *
 *  @param      array		$array      		Array to sort (array of array('key1'=>val1,'key2'=>val2,'key3'...) or array of objects)
 *  @param      string		$index				Key in array to use for sorting criteria
 *  @param      int			$order				Sort order ('asc' or 'desc')
 *  @param      int			$natsort			If values are strings (I said value not type): 0=Use alphabetical order, 1=use ""natural"" sort (natsort)
 *   											If values are numeric (I said value not type): 0=Use numeric order (even if type is string) so use a ""natural"" sort, 1=use ""natural"" sort too (same than 0), -1=Force alphabetical order
 *  @param      int			$case_sensitive		1=sort is case sensitive, 0=not case sensitive
 *  @param		int			$keepindex			If 0 and index key of array to sort is a numeric, than index will be rewrote. If 1 or index key is not numeric, key for index is kept after sorting.
 *  @return     array							Sorted array
 */
function dol_sort_array(&$array, $index, $order = 'asc', $natsort = 0, $case_sensitive = 0, $keepindex = 0)
{
	// Clean parameters
	$order = strtolower($order);

	if (is_array($array)) {
		$sizearray = count($array);
		if ($sizearray > 0) {
			$temp = array();
			foreach (array_keys($array) as $key) {
				if (is_object($array[$key])) {
					$temp[$key] = empty($array[$key]->$index) ? 0 : $array[$key]->$index;
				} else {
					$temp[$key] = empty($array[$key][$index]) ? 0 : $array[$key][$index];
				}
				if ($natsort == -1) {
					$temp[$key] = '___'.$temp[$key];        // We add a string at begin of value to force an alpha order when using asort.
				}
			}

			if (empty($natsort) || $natsort == -1) {
				if ($order == 'asc') {
					asort($temp);
				} else {
					arsort($temp);
				}
			} else {
				if ($case_sensitive) {
					natsort($temp);
				} else {
					natcasesort($temp);	// natecasesort is not sensible to case
				}
				if ($order != 'asc') {
					$temp = array_reverse($temp, true);
				}
			}

			$sorted = array();

			foreach (array_keys($temp) as $key) {
				(is_numeric($key) && empty($keepindex)) ? $sorted[] = $array[$key] : $sorted[$key] = $array[$key];
			}

			return $sorted;
		}
	}
	return $array;
}


/**
 *      Check if a string is in UTF8
 *
 *      @param	string	$str        String to check
 * 		@return	boolean				True if string is UTF8 or ISO compatible with UTF8, False if not (ISO with special char or Binary)
 */
function utf8_check($str)
{
	$str = (string) $str;	// Sometimes string is an int.

	// We must use here a binary strlen function (so not dol_strlen)
	$strLength = dol_strlen($str);
	for ($i = 0; $i < $strLength; $i++) {
		if (ord($str[$i]) < 0x80) {
			continue; // 0bbbbbbb
		} elseif ((ord($str[$i]) & 0xE0) == 0xC0) {
			$n = 1; // 110bbbbb
		} elseif ((ord($str[$i]) & 0xF0) == 0xE0) {
			$n = 2; // 1110bbbb
		} elseif ((ord($str[$i]) & 0xF8) == 0xF0) {
			$n = 3; // 11110bbb
		} elseif ((ord($str[$i]) & 0xFC) == 0xF8) {
			$n = 4; // 111110bb
		} elseif ((ord($str[$i]) & 0xFE) == 0xFC) {
			$n = 5; // 1111110b
		} else {
			return false; // Does not match any model
		}
		for ($j = 0; $j < $n; $j++) { // n bytes matching 10bbbbbb follow ?
			if ((++$i == strlen($str)) || ((ord($str[$i]) & 0xC0) != 0x80)) {
				return false;
			}
		}
	}
	return true;
}

/**
 *      Check if a string is in ASCII
 *
 *      @param	string	$str        String to check
 * 		@return	boolean				True if string is ASCII, False if not (byte value > 0x7F)
 */
function ascii_check($str)
{
	if (function_exists('mb_check_encoding')) {
		//if (mb_detect_encoding($str, 'ASCII', true) return false;
		if (!mb_check_encoding($str, 'ASCII')) {
			return false;
		}
	} else {
		if (preg_match('/[^\x00-\x7f]/', $str)) {
			return false; // Contains a byte > 7f
		}
	}

	return true;
}


/**
 *      Return a string encoded into OS filesystem encoding. This function is used to define
 * 	    value to pass to filesystem PHP functions.
 *
 *      @param	string	$str        String to encode (UTF-8)
 * 		@return	string				Encoded string (UTF-8, ISO-8859-1)
 */
function dol_osencode($str)
{
	global $conf;

	$tmp = ini_get(""unicode.filesystem_encoding""); // Disponible avec PHP 6.0
	if (empty($tmp) && !empty($_SERVER[""WINDIR""])) {
		$tmp = 'iso-8859-1'; // By default for windows
	}
	if (empty($tmp)) {
		$tmp = 'utf-8'; // By default for other
	}
	if (!empty($conf->global->MAIN_FILESYSTEM_ENCODING)) {
		$tmp = $conf->global->MAIN_FILESYSTEM_ENCODING;
	}

	if ($tmp == 'iso-8859-1') {
		return mb_convert_encoding($str, 'ISO-8859-1', 'UTF-8');
	}
	return $str;
}


/**
 *      Return an id or code from a code or id.
 *      Store also Code-Id into a cache to speed up next request on same key.
 *
 * 		@param	DoliDB	$db				Database handler
 * 		@param	string	$key			Code or Id to get Id or Code
 * 		@param	string	$tablename		Table name without prefix
 * 		@param	string	$fieldkey		Field to search the key into
 * 		@param	string	$fieldid		Field to get
 *      @param  int		$entityfilter	Filter by entity
 *      @param	string	$filters		Filters to add. WARNING: string must be escaped for SQL and not coming from user input.
 *      @return int						<0 if KO, Id of code if OK
 *      @see $langs->getLabelFromKey
 */
function dol_getIdFromCode($db, $key, $tablename, $fieldkey = 'code', $fieldid = 'id', $entityfilter = 0, $filters = '')
{
	global $cache_codes;

	// If key empty
	if ($key == '') {
		return '';
	}

	// Check in cache
	if (isset($cache_codes[$tablename][$key][$fieldid])) {	// Can be defined to 0 or ''
		return $cache_codes[$tablename][$key][$fieldid]; // Found in cache
	}

	dol_syslog('dol_getIdFromCode (value for field '.$fieldid.' from key '.$key.' not found into cache)', LOG_DEBUG);

	$sql = ""SELECT "".$fieldid."" as valuetoget"";
	$sql .= "" FROM "".MAIN_DB_PREFIX.$tablename;
	$sql .= "" WHERE "".$fieldkey."" = '"".$db->escape($key).""'"";
	if (!empty($entityfilter)) {
		$sql .= "" AND entity IN ("".getEntity($tablename)."")"";
	}
	if ($filters) {
		$sql .= $filters;
	}

	$resql = $db->query($sql);
	if ($resql) {
		$obj = $db->fetch_object($resql);
		if ($obj) {
			$cache_codes[$tablename][$key][$fieldid] = $obj->valuetoget;
		} else {
			$cache_codes[$tablename][$key][$fieldid] = '';
		}
		$db->free($resql);
		return $cache_codes[$tablename][$key][$fieldid];
	} else {
		return -1;
	}
}

/**
 * Verify if condition in string is ok or not
 *
 * @param 	string		$strToEvaluate	String with condition to check
 * @return 	boolean						True or False. Note: It returns also True if $strToEvaluate is ''. False if error
 */
function verifCond($strToEvaluate)
{
	global $user, $conf, $langs;
	global $leftmenu;
	global $rights; // To export to dol_eval function

	//print $strToEvaluate.""<br>\n"";
	$rights = true;
	if (isset($strToEvaluate) && $strToEvaluate !== '') {
		//var_dump($strToEvaluate);
		$rep = dol_eval($strToEvaluate, 1, 1, '1'); // The dol_eval must contains all the global $xxx for all variables $xxx found into the string condition
		$rights = $rep && (!is_string($rep) || strpos($rep, 'Bad string syntax to evaluate') === false);
		//var_dump($rights);
	}
	return $rights;
}

/**
 * Replace eval function to add more security.
 * This function is called by verifCond() or trans() and transnoentitiesnoconv().
 *
 * @param 	string	$s					String to evaluate
 * @param	int		$returnvalue		0=No return (used to execute eval($a=something)). 1=Value of eval is returned (used to eval($something)).
 * @param   int     $hideerrors     	1=Hide errors
 * @param	string	$onlysimplestring	'0' (used for computed property of extrafields)=Accept all chars, '1' (most common use)=Accept only simple string with char 'a-z0-9\s^$_+-.*>&|=!?():""\',/@';',  '2' (rarely used)=Accept also '[]'
 * @return	mixed						Nothing or return result of eval
 */
function dol_eval($s, $returnvalue = 0, $hideerrors = 1, $onlysimplestring = '1')
{
	// Only global variables can be changed by eval function and returned to caller
	global $db, $langs, $user, $conf, $website, $websitepage;
	global $action, $mainmenu, $leftmenu;
	global $mysoc;
	global $objectoffield;

	// Old variables used
	global $rights;
	global $object;
	global $obj; // To get $obj used into list when dol_eval is used for computed fields and $obj is not yet $object
	global $soc; // For backward compatibility

	try {
		// Test on dangerous char (used for RCE), we allow only characters to make PHP variable testing
		if ($onlysimplestring == '1') {
			// We must accept: '1 && getDolGlobalInt(""doesnotexist1"") && $conf->global->MAIN_FEATURES_LEVEL'
			// We must accept: '$conf->barcode->enabled || preg_match(\'/^AAA/\',$leftmenu)'
			// We must accept: '$user->rights->cabinetmed->read && !$object->canvas==""patient@cabinetmed""'
			if (preg_match('/[^a-z0-9\s'.preg_quote('^$_+-.*>&|=!?():""\',/@', '/').']/i', $s)) {
				if ($returnvalue) {
					return 'Bad string syntax to evaluate (found chars that are not chars for simplestring): '.$s;
				} else {
					dol_syslog('Bad string syntax to evaluate (found chars that are not chars for simplestring): '.$s);
					return '';
				}
				// TODO
				// We can exclude all parenthesis ( that are not '($db' and 'getDolGlobalInt(' and 'getDolGlobalString(' and 'preg_match(' and 'isModEnabled('
				// ...
			}
		} elseif ($onlysimplestring == '2') {
			// We must accept: (($reloadedobj = new Task($db)) && ($reloadedobj->fetchNoCompute($object->id) > 0) && ($secondloadedobj = new Project($db)) && ($secondloadedobj->fetchNoCompute($reloadedobj->fk_project) > 0)) ? $secondloadedobj->ref : ""Parent project not found""
			if (preg_match('/[^a-z0-9\s'.preg_quote('^$_+-.*>&|=!?():""\',/@[]', '/').']/i', $s)) {
				if ($returnvalue) {
					return 'Bad string syntax to evaluate (found chars that are not chars for simplestring): '.$s;
				} else {
					dol_syslog('Bad string syntax to evaluate (found chars that are not chars for simplestring): '.$s);
					return '';
				}
				// TODO
				// We can exclude all parenthesis ( that are not '($db' and 'getDolGlobalInt(' and 'getDolGlobalString(' and 'preg_match(' and 'isModEnabled('
				// ...
			}
		}
		if (is_array($s) || $s === 'Array') {
			return 'Bad string syntax to evaluate (value is Array) '.var_export($s, true);
		}
		if (strpos($s, '::') !== false) {
			if ($returnvalue) {
				return 'Bad string syntax to evaluate (double : char is forbidden): '.$s;
			} else {
				dol_syslog('Bad string syntax to evaluate (double : char is forbidden): '.$s);
				return '';
			}
		}
		if (strpos($s, '`') !== false) {
			if ($returnvalue) {
				return 'Bad string syntax to evaluate (backtick char is forbidden): '.$s;
			} else {
				dol_syslog('Bad string syntax to evaluate (backtick char is forbidden): '.$s);
				return '';
			}
		}
		if (preg_match('/[^0-9]+\.[^0-9]+/', $s)) {	// We refuse . if not between 2 numbers
			if ($returnvalue) {
				return 'Bad string syntax to evaluate (dot char is forbidden): '.$s;
			} else {
				dol_syslog('Bad string syntax to evaluate (dot char is forbidden): '.$s);
				return '';
			}
		}

		// We block use of php exec or php file functions
		$forbiddenphpstrings = array('$$');
		$forbiddenphpstrings = array_merge($forbiddenphpstrings, array('_ENV', '_SESSION', '_COOKIE', '_GET', '_POST', '_REQUEST'));

		$forbiddenphpfunctions = array(""exec"", ""passthru"", ""shell_exec"", ""system"", ""proc_open"", ""popen"", ""eval"", ""dol_eval"", ""executeCLI"", ""verifCond"", ""base64_decode"");
		$forbiddenphpfunctions = array_merge($forbiddenphpfunctions, array(""fopen"", ""file_put_contents"", ""fputs"", ""fputscsv"", ""fwrite"", ""fpassthru"", ""require"", ""include"", ""mkdir"", ""rmdir"", ""symlink"", ""touch"", ""unlink"", ""umask""));
		$forbiddenphpfunctions = array_merge($forbiddenphpfunctions, array(""function"", ""call_user_func""));

		$forbiddenphpregex = 'global\s+\$|\b('.implode('|', $forbiddenphpfunctions).')\b';

		do {
			$oldstringtoclean = $s;
			$s = str_ireplace($forbiddenphpstrings, '__forbiddenstring__', $s);
			$s = preg_replace('/'.$forbiddenphpregex.'/i', '__forbiddenstring__', $s);
			//$s = preg_replace('/\$[a-zA-Z0-9_\->\$]+\(/i', '', $s);	// Remove $function( call and $mycall->mymethod(
		} while ($oldstringtoclean != $s);

		if (strpos($s, '__forbiddenstring__') !== false) {
			dol_syslog('Bad string syntax to evaluate: '.$s, LOG_WARNING);
			if ($returnvalue) {
				return 'Bad string syntax to evaluate: '.$s;
			} else {
				dol_syslog('Bad string syntax to evaluate: '.$s);
				return '';
			}
		}

		//print $s.""<br>\n"";
		if ($returnvalue) {
			if ($hideerrors) {
				return @eval('return '.$s.';');
			} else {
				return eval('return '.$s.';');
			}
		} else {
			if ($hideerrors) {
				@eval($s);
			} else {
				eval($s);
			}
		}
	} catch (Error $e) {
		$error = 'dol_eval try/catch error : ';
		$error .= $e->getMessage();
		dol_syslog($error);
	}
}

/**
 * Return if var element is ok
 *
 * @param   string      $element    Variable to check
 * @return  boolean                 Return true of variable is not empty
 */
function dol_validElement($element)
{
	return (trim($element) != '');
}

/**
 * 	Return img flag of country for a language code or country code.
 *
 * 	@param	string	$codelang	Language code ('en_IN', 'fr_CA', ...) or ISO Country code on 2 characters in uppercase ('IN', 'FR')
 *  @param	string	$moreatt	Add more attribute on img tag (For example 'style=""float: right""' or 'class=""saturatemedium""')
 *  @param	int		$notitlealt	No title alt
 * 	@return	string				HTML img string with flag.
 */
function picto_from_langcode($codelang, $moreatt = '', $notitlealt = 0)
{
	if (empty($codelang)) {
		return '';
	}

	if ($codelang == 'auto') {
		return '<span class=""fa fa-language""></span>';
	}

	$langtocountryflag = array(
		'ar_AR' => '',
		'ca_ES' => 'catalonia',
		'da_DA' => 'dk',
		'fr_CA' => 'mq',
		'sv_SV' => 'se',
		'sw_SW' => 'unknown',
		'AQ' => 'unknown',
		'CW' => 'unknown',
		'IM' => 'unknown',
		'JE' => 'unknown',
		'MF' => 'unknown',
		'BL' => 'unknown',
		'SX' => 'unknown'
	);

	if (isset($langtocountryflag[$codelang])) {
		$flagImage = $langtocountryflag[$codelang];
	} else {
		$tmparray = explode('_', $codelang);
		$flagImage = empty($tmparray[1]) ? $tmparray[0] : $tmparray[1];
	}

	return img_picto_common($codelang, 'flags/'.strtolower($flagImage).'.png', $moreatt, 0, $notitlealt);
}

/**
 * Return default language from country code.
 * Return null if not found.
 *
 * @param 	string 	$countrycode	Country code like 'US', 'FR', 'CA', 'ES', 'IN', 'MX', ...
 * @return	string					Value of locale like 'en_US', 'fr_FR', ... or null if not found
 */
function getLanguageCodeFromCountryCode($countrycode)
{
	global $mysoc;

	if (empty($countrycode)) {
		return null;
	}

	if (strtoupper($countrycode) == 'MQ') {
		return 'fr_CA';
	}
	if (strtoupper($countrycode) == 'SE') {
		return 'sv_SE'; // se_SE is Sami/Sweden, and we want in priority sv_SE for SE country
	}
	if (strtoupper($countrycode) == 'CH') {
		if ($mysoc->country_code == 'FR') {
			return 'fr_CH';
		}
		if ($mysoc->country_code == 'DE') {
			return 'de_CH';
		}
		if ($mysoc->country_code == 'IT') {
			return 'it_CH';
		}
	}

	// Locale list taken from:
	// http://stackoverflow.com/questions/3191664/
	// list-of-all-locales-and-their-short-codes
	$locales = array(
		'af-ZA',
		'am-ET',
		'ar-AE',
		'ar-BH',
		'ar-DZ',
		'ar-EG',
		'ar-IQ',
		'ar-JO',
		'ar-KW',
		'ar-LB',
		'ar-LY',
		'ar-MA',
		'ar-OM',
		'ar-QA',
		'ar-SA',
		'ar-SY',
		'ar-TN',
		'ar-YE',
		//'as-IN',		// Moved after en-IN
		'ba-RU',
		'be-BY',
		'bg-BG',
		'bn-BD',
		//'bn-IN',		// Moved after en-IN
		'bo-CN',
		'br-FR',
		'ca-ES',
		'co-FR',
		'cs-CZ',
		'cy-GB',
		'da-DK',
		'de-AT',
		'de-CH',
		'de-DE',
		'de-LI',
		'de-LU',
		'dv-MV',
		'el-GR',
		'en-AU',
		'en-BZ',
		'en-CA',
		'en-GB',
		'en-IE',
		'en-IN',
		'as-IN',	// as-IN must be after en-IN (en in priority if country is IN)
		'bn-IN',	// bn-IN must be after en-IN (en in priority if country is IN)
		'en-JM',
		'en-MY',
		'en-NZ',
		'en-PH',
		'en-SG',
		'en-TT',
		'en-US',
		'en-ZA',
		'en-ZW',
		'es-AR',
		'es-BO',
		'es-CL',
		'es-CO',
		'es-CR',
		'es-DO',
		'es-EC',
		'es-ES',
		'es-GT',
		'es-HN',
		'es-MX',
		'es-NI',
		'es-PA',
		'es-PE',
		'es-PR',
		'es-PY',
		'es-SV',
		'es-US',
		'es-UY',
		'es-VE',
		'et-EE',
		'eu-ES',
		'fa-IR',
		'fi-FI',
		'fo-FO',
		'fr-BE',
		'fr-CA',
		'fr-CH',
		'fr-FR',
		'fr-LU',
		'fr-MC',
		'fy-NL',
		'ga-IE',
		'gd-GB',
		'gl-ES',
		'gu-IN',
		'he-IL',
		'hi-IN',
		'hr-BA',
		'hr-HR',
		'hu-HU',
		'hy-AM',
		'id-ID',
		'ig-NG',
		'ii-CN',
		'is-IS',
		'it-CH',
		'it-IT',
		'ja-JP',
		'ka-GE',
		'kk-KZ',
		'kl-GL',
		'km-KH',
		'kn-IN',
		'ko-KR',
		'ky-KG',
		'lb-LU',
		'lo-LA',
		'lt-LT',
		'lv-LV',
		'mi-NZ',
		'mk-MK',
		'ml-IN',
		'mn-MN',
		'mr-IN',
		'ms-BN',
		'ms-MY',
		'mt-MT',
		'nb-NO',
		'ne-NP',
		'nl-BE',
		'nl-NL',
		'nn-NO',
		'oc-FR',
		'or-IN',
		'pa-IN',
		'pl-PL',
		'ps-AF',
		'pt-BR',
		'pt-PT',
		'rm-CH',
		'ro-MD',
		'ro-RO',
		'ru-RU',
		'rw-RW',
		'sa-IN',
		'se-FI',
		'se-NO',
		'se-SE',
		'si-LK',
		'sk-SK',
		'sl-SI',
		'sq-AL',
		'sv-FI',
		'sv-SE',
		'sw-KE',
		'ta-IN',
		'te-IN',
		'th-TH',
		'tk-TM',
		'tn-ZA',
		'tr-TR',
		'tt-RU',
		'ug-CN',
		'uk-UA',
		'ur-PK',
		'vi-VN',
		'wo-SN',
		'xh-ZA',
		'yo-NG',
		'zh-CN',
		'zh-HK',
		'zh-MO',
		'zh-SG',
		'zh-TW',
		'zu-ZA',
	);

	$buildprimarykeytotest = strtolower($countrycode).'-'.strtoupper($countrycode);
	if (in_array($buildprimarykeytotest, $locales)) {
		return strtolower($countrycode).'_'.strtoupper($countrycode);
	}

	if (function_exists('locale_get_primary_language') && function_exists('locale_get_region')) {    // Need extension php-intl
		foreach ($locales as $locale) {
			$locale_language = locale_get_primary_language($locale);
			$locale_region = locale_get_region($locale);
			if (strtoupper($countrycode) == $locale_region) {
				//var_dump($locale.' - '.$locale_language.' - '.$locale_region);
				return strtolower($locale_language).'_'.strtoupper($locale_region);
			}
		}
	} else {
		dol_syslog(""Warning Exention php-intl is not available"", LOG_WARNING);
	}

	return null;
}

/**
 *  Complete or removed entries into a head array (used to build tabs).
 *  For example, with value added by external modules. Such values are declared into $conf->modules_parts['tab'].
 *  Or by change using hook completeTabsHead
 *
 *  @param	Conf			$conf           Object conf
 *  @param  Translate		$langs          Object langs
 *  @param  object|null		$object         Object object
 *  @param  array			$head          	Object head
 *  @param  int				$h				New position to fill
 *  @param  string			$type           Value for object where objectvalue can be
 *                              			'thirdparty'       to add a tab in third party view
 *		                        	      	'intervention'     to add a tab in intervention view
 *     		                    	     	'supplier_order'   to add a tab in purchase order view
 *          		            	        'supplier_invoice' to add a tab in purchase invoice view
 *                  		    	        'invoice'          to add a tab in sales invoice view
 *                          			    'order'            to add a tab in sales order view
 *                          				'contract'		   to add a tabl in contract view
 *                      			        'product'          to add a tab in product view
 *                              			'propal'           to add a tab in propal view
 *                              			'user'             to add a tab in user view
 *                              			'group'            to add a tab in group view
 * 		        	               	     	'member'           to add a tab in fundation member view
 *      		                        	'categories_x'	   to add a tab in category view ('x': type of category (0=product, 1=supplier, 2=customer, 3=member)
 *      									'ecm'			   to add a tab for another ecm view
 *                                          'stock'            to add a tab for warehouse view
 *  @param  string		$mode  	        	'add' to complete head, 'remove' to remove entries
 *  @param	string		$filterorigmodule	Filter on module origin: 'external' will show only external modules. 'core' only core modules. No filter (default) will add both.
 *	@return	void
 */
function complete_head_from_modules($conf, $langs, $object, &$head, &$h, $type, $mode = 'add', $filterorigmodule = '')
{
	global $hookmanager, $db;

	if (isset($conf->modules_parts['tabs'][$type]) && is_array($conf->modules_parts['tabs'][$type])) {
		foreach ($conf->modules_parts['tabs'][$type] as $value) {
			$values = explode(':', $value);

			$reg = array();
			if ($mode == 'add' && !preg_match('/^\-/', $values[1])) {
				if (count($values) == 6) {
					// new declaration with permissions:
					// $value='objecttype:+tabname1:Title1:langfile@mymodule:$user->rights->mymodule->read:/mymodule/mynewtab1.php?id=__ID__'
					// $value='objecttype:+tabname1:Title1,class,pathfile,method:langfile@mymodule:$user->rights->mymodule->read:/mymodule/mynewtab1.php?id=__ID__'
					if ($values[0] != $type) {
						continue;
					}

					if (verifCond($values[4])) {
						if ($values[3]) {
							if ($filterorigmodule) {	// If a filter of module origin has been requested
								if (strpos($values[3], '@')) {	// This is an external module
									if ($filterorigmodule != 'external') {
										continue;
									}
								} else {	// This looks a core module
									if ($filterorigmodule != 'core') {
										continue;
									}
								}
							}
							$langs->load($values[3]);
						}
						if (preg_match('/SUBSTITUTION_([^_]+)/i', $values[2], $reg)) {
							// If label is ""SUBSTITUION_...""
							$substitutionarray = array();
							complete_substitutions_array($substitutionarray, $langs, $object, array('needforkey'=>$values[2]));
							$label = make_substitutions($reg[1], $substitutionarray);
						} else {
							// If label is ""Label,Class,File,Method"", we call the method to show content inside the badge
							$labeltemp = explode(',', $values[2]);
							$label = $langs->trans($labeltemp[0]);

							if (!empty($labeltemp[1]) && is_object($object) && !empty($object->id)) {
								dol_include_once($labeltemp[2]);
								$classtoload = $labeltemp[1];
								if (class_exists($classtoload)) {
									$obj = new $classtoload($db);
									$function = $labeltemp[3];
									if ($obj && $function && method_exists($obj, $function)) {
										$nbrec = $obj->$function($object->id, $obj);
										$label .= '<span class=""badge marginleftonlyshort"">'.$nbrec.'</span>';
									}
								}
							}
						}

						$head[$h][0] = dol_buildpath(preg_replace('/__ID__/i', ((is_object($object) && !empty($object->id)) ? $object->id : ''), $values[5]), 1);
						$head[$h][1] = $label;
						$head[$h][2] = str_replace('+', '', $values[1]);
						$h++;
					}
				} elseif (count($values) == 5) {       // case deprecated
					dol_syslog('Passing 5 values in tabs module_parts is deprecated. Please update to 6 with permissions.', LOG_WARNING);

					if ($values[0] != $type) {
						continue;
					}
					if ($values[3]) {
						if ($filterorigmodule) {	// If a filter of module origin has been requested
							if (strpos($values[3], '@')) {	// This is an external module
								if ($filterorigmodule != 'external') {
									continue;
								}
							} else {	// This looks a core module
								if ($filterorigmodule != 'core') {
									continue;
								}
							}
						}
						$langs->load($values[3]);
					}
					if (preg_match('/SUBSTITUTION_([^_]+)/i', $values[2], $reg)) {
						$substitutionarray = array();
						complete_substitutions_array($substitutionarray, $langs, $object, array('needforkey'=>$values[2]));
						$label = make_substitutions($reg[1], $substitutionarray);
					} else {
						$label = $langs->trans($values[2]);
					}

					$head[$h][0] = dol_buildpath(preg_replace('/__ID__/i', ((is_object($object) && !empty($object->id)) ? $object->id : ''), $values[4]), 1);
					$head[$h][1] = $label;
					$head[$h][2] = str_replace('+', '', $values[1]);
					$h++;
				}
			} elseif ($mode == 'remove' && preg_match('/^\-/', $values[1])) {
				if ($values[0] != $type) {
					continue;
				}
				$tabname = str_replace('-', '', $values[1]);
				foreach ($head as $key => $val) {
					$condition = (!empty($values[3]) ? verifCond($values[3]) : 1);
					//var_dump($key.' - '.$tabname.' - '.$head[$key][2].' - '.$values[3].' - '.$condition);
					if ($head[$key][2] == $tabname && $condition) {
						unset($head[$key]);
						break;
					}
				}
			}
		}
	}

	// No need to make a return $head. Var is modified as a reference
	if (!empty($hookmanager)) {
		$parameters = array('object' => $object, 'mode' => $mode, 'head' => &$head, 'filterorigmodule' => $filterorigmodule);
		$reshook = $hookmanager->executeHooks('completeTabsHead', $parameters);
		if ($reshook > 0) {		// Hook ask to replace completely the array
			$head = $hookmanager->resArray;
		} else {				// Hook
			$head = array_merge($head, $hookmanager->resArray);
		}
		$h = count($head);
	}
}

/**
 * Print common footer :
 * 		conf->global->MAIN_HTML_FOOTER
 *      js for switch of menu hider
 * 		js for conf->global->MAIN_GOOGLE_AN_ID
 * 		js for conf->global->MAIN_SHOW_TUNING_INFO or $_SERVER[""MAIN_SHOW_TUNING_INFO""]
 * 		js for conf->logbuffer
 *
 * @param	string	$zone	'private' (for private pages) or 'public' (for public pages)
 * @return	void
 */
function printCommonFooter($zone = 'private')
{
	global $conf, $hookmanager, $user, $debugbar;
	global $action;
	global $micro_start_time;

	if ($zone == 'private') {
		print ""\n"".'<!-- Common footer for private page -->'.""\n"";
	} else {
		print ""\n"".'<!-- Common footer for public page -->'.""\n"";
	}

	// A div to store page_y POST parameter so we can read it using javascript
	print ""\n<!-- A div to store page_y POST parameter -->\n"";
	print '<div id=""page_y"" style=""display: none;"">'.(GETPOST('page_y') ? GETPOST('page_y') : '').'</div>'.""\n"";

	$parameters = array();
	$reshook = $hookmanager->executeHooks('printCommonFooter', $parameters); // Note that $action and $object may have been modified by some hooks
	if (empty($reshook)) {
		if (!empty($conf->global->MAIN_HTML_FOOTER)) {
			print $conf->global->MAIN_HTML_FOOTER.""\n"";
		}

		print ""\n"";
		if (!empty($conf->use_javascript_ajax)) {
			print ""\n<!-- A script section to add menuhider handler on backoffice, manage focus and madatory fields, tuning info, ... -->\n"";
			print '<script>'.""\n"";
			print 'jQuery(document).ready(function() {'.""\n"";

			if ($zone == 'private' && empty($conf->dol_use_jmobile)) {
				print ""\n"";
				print '/* JS CODE TO ENABLE to manage handler to switch left menu page (menuhider) */'.""\n"";
				print 'jQuery(""li.menuhider"").click(function(event) {';
				print '  if (!$( ""body"" ).hasClass( ""sidebar-collapse"" )){ event.preventDefault(); }'.""\n"";
				print '  console.log(""We click on .menuhider"");'.""\n"";
				print '  $(""body"").toggleClass(""sidebar-collapse"")'.""\n"";
				print '});'.""\n"";
			}

			// Management of focus and mandatory for fields
			if ($action == 'create' || $action == 'edit' || (empty($action) && (preg_match('/new\.php/', $_SERVER[""PHP_SELF""]))) || ((empty($action) || $action == 'addline') && (preg_match('/card\.php/', $_SERVER[""PHP_SELF""])))) {
				print '/* JS CODE TO ENABLE to manage focus and mandatory form fields */'.""\n"";
				$relativepathstring = $_SERVER[""PHP_SELF""];
				// Clean $relativepathstring
				if (constant('DOL_URL_ROOT')) {
					$relativepathstring = preg_replace('/^'.preg_quote(constant('DOL_URL_ROOT'), '/').'/', '', $relativepathstring);
				}
				$relativepathstring = preg_replace('/^\//', '', $relativepathstring);
				$relativepathstring = preg_replace('/^custom\//', '', $relativepathstring);
				//$tmpqueryarraywehave = explode('&', dol_string_nohtmltag($_SERVER['QUERY_STRING']));
				if (!empty($user->default_values[$relativepathstring]['focus'])) {
					foreach ($user->default_values[$relativepathstring]['focus'] as $defkey => $defval) {
						$qualified = 0;
						if ($defkey != '_noquery_') {
							$tmpqueryarraytohave = explode('&', $defkey);
							$foundintru = 0;
							foreach ($tmpqueryarraytohave as $tmpquerytohave) {
								$tmpquerytohaveparam = explode('=', $tmpquerytohave);
								//print ""console.log('"".$tmpquerytohaveparam[0]."" "".$tmpquerytohaveparam[1]."" "".GETPOST($tmpquerytohaveparam[0]).""');"";
								if (!GETPOSTISSET($tmpquerytohaveparam[0]) || ($tmpquerytohaveparam[1] != GETPOST($tmpquerytohaveparam[0]))) {
									$foundintru = 1;
								}
							}
							if (!$foundintru) {
								$qualified = 1;
							}
							//var_dump($defkey.'-'.$qualified);
						} else {
							$qualified = 1;
						}

						if ($qualified) {
							foreach ($defval as $paramkey => $paramval) {
								// Set focus on field
								print 'jQuery(""input[name=\''.$paramkey.'\']"").focus();'.""\n"";
								print 'jQuery(""textarea[name=\''.$paramkey.'\']"").focus();'.""\n"";
								print 'jQuery(""select[name=\''.$paramkey.'\']"").focus();'.""\n""; // Not really usefull, but we keep it in case of.
							}
						}
					}
				}
				if (!empty($user->default_values[$relativepathstring]['mandatory'])) {
					foreach ($user->default_values[$relativepathstring]['mandatory'] as $defkey => $defval) {
						$qualified = 0;
						if ($defkey != '_noquery_') {
							$tmpqueryarraytohave = explode('&', $defkey);
							$foundintru = 0;
							foreach ($tmpqueryarraytohave as $tmpquerytohave) {
								$tmpquerytohaveparam = explode('=', $tmpquerytohave);
								//print ""console.log('"".$tmpquerytohaveparam[0]."" "".$tmpquerytohaveparam[1]."" "".GETPOST($tmpquerytohaveparam[0]).""');"";
								if (!GETPOSTISSET($tmpquerytohaveparam[0]) || ($tmpquerytohaveparam[1] != GETPOST($tmpquerytohaveparam[0]))) {
									$foundintru = 1;
								}
							}
							if (!$foundintru) {
								$qualified = 1;
							}
							//var_dump($defkey.'-'.$qualified);
						} else {
							$qualified = 1;
						}

						if ($qualified) {
							foreach ($defval as $paramkey => $paramval) {
								// Add property 'required' on input
								print 'jQuery(""input[name=\''.$paramkey.'\']"").prop(\'required\',true);'.""\n"";
								print 'jQuery(""textarea[name=\''.$paramkey.'\']"").prop(\'required\',true);'.""\n"";
								print '// required on a select works only if key is """", so we add the required attributes but also we reset the key -1 or 0 to an empty string'.""\n"";
								print 'jQuery(""select[name=\''.$paramkey.'\']"").prop(\'required\',true);'.""\n"";
								print 'jQuery(""select[name=\''.$paramkey.'\'] option[value=\'-1\']"").prop(\'value\', \'\');'.""\n"";
								print 'jQuery(""select[name=\''.$paramkey.'\'] option[value=\'0\']"").prop(\'value\', \'\');'.""\n"";

								// Add 'field required' class on closest td for all input elements : input, textarea and select
								print 'jQuery("":input[name=\'' . $paramkey . '\']"").closest(""tr"").find(""td:first"").addClass(""fieldrequired"");' . ""\n"";
							}
						}
					}
				}
			}

			print '});'.""\n"";

			// End of tuning
			if (!empty($_SERVER['MAIN_SHOW_TUNING_INFO']) || !empty($conf->global->MAIN_SHOW_TUNING_INFO)) {
				print ""\n"";
				print ""/* JS CODE TO ENABLE to add memory info */\n"";
				print 'window.console && console.log(""';
				if (!empty($conf->global->MEMCACHED_SERVER)) {
					print 'MEMCACHED_SERVER='.$conf->global->MEMCACHED_SERVER.' - ';
				}
				print 'MAIN_OPTIMIZE_SPEED='.(isset($conf->global->MAIN_OPTIMIZE_SPEED) ? $conf->global->MAIN_OPTIMIZE_SPEED : 'off');
				if (!empty($micro_start_time)) {   // Works only if MAIN_SHOW_TUNING_INFO is defined at $_SERVER level. Not in global variable.
					$micro_end_time = microtime(true);
					print ' - Build time: '.ceil(1000 * ($micro_end_time - $micro_start_time)).' ms';
				}

				if (function_exists(""memory_get_usage"")) {
					print ' - Mem: '.memory_get_usage(); // Do not use true here, it seems it takes the peak amount
				}
				if (function_exists(""memory_get_peak_usage"")) {
					print ' - Real mem peak: '.memory_get_peak_usage(true);
				}
				if (function_exists(""zend_loader_file_encoded"")) {
					print ' - Zend encoded file: '.(zend_loader_file_encoded() ? 'yes' : 'no');
				}
				print '"");'.""\n"";
			}

			print ""\n"".'</script>'.""\n"";

			// Google Analytics
			// TODO Add a hook here
			if (isModEnabled('google') && !empty($conf->global->MAIN_GOOGLE_AN_ID)) {
				$tmptagarray = explode(',', $conf->global->MAIN_GOOGLE_AN_ID);
				foreach ($tmptagarray as $tmptag) {
					print ""\n"";
					print ""<!-- JS CODE TO ENABLE for google analtics tag -->\n"";
					print '
					<!-- Global site tag (gtag.js) - Google Analytics -->
					<script nonce=""'.getNonce().'"" async src=""https://www.googletagmanager.com/gtag/js?id='.trim($tmptag).'""></script>
					<script>
					window.dataLayer = window.dataLayer || [];
					function gtag(){dataLayer.push(arguments);}
					gtag(\'js\', new Date());

					gtag(\'config\', \''.trim($tmptag).'\');
					</script>';
					print ""\n"";
				}
			}
		}

		// Add Xdebug coverage of code
		if (defined('XDEBUGCOVERAGE')) {
			print_r(xdebug_get_code_coverage());
		}

		// Add DebugBar data
		if (!empty($user->rights->debugbar->read) && is_object($debugbar)) {
			$debugbar['time']->stopMeasure('pageaftermaster');
			print '<!-- Output debugbar data -->'.""\n"";
			$renderer = $debugbar->getRenderer();
			print $debugbar->getRenderer()->render();
		} elseif (count($conf->logbuffer)) {    // If there is some logs in buffer to show
			print ""\n"";
			print ""<!-- Start of log output\n"";
			//print '<div class=""hidden"">'.""\n"";
			foreach ($conf->logbuffer as $logline) {
				print $logline.""<br>\n"";
			}
			//print '</div>'.""\n"";
			print ""End of log output -->\n"";
		}
	}
}

/**
 * Split a string with 2 keys into key array.
 * For example: ""A=1;B=2;C=2"" is exploded into array('A'=>1,'B'=>2,'C'=>3)
 *
 * @param 	string	$string		String to explode
 * @param 	string	$delimiter	Delimiter between each couple of data. Example: ';' or '[\n;]+' or '(\n\r|\r|\n|;)'
 * @param 	string	$kv			Delimiter between key and value
 * @return	array				Array of data exploded
 */
function dolExplodeIntoArray($string, $delimiter = ';', $kv = '=')
{
	if (preg_match('/^\[.*\]$/sm', $delimiter) || preg_match('/^\(.*\)$/sm', $delimiter)) {
		// This is a regex string
		$newdelimiter = $delimiter;
	} else {
		// This is a simple string
		$newdelimiter = preg_quote($delimiter, '/');
	}

	if ($a = preg_split('/'.$newdelimiter.'/', $string)) {
		$ka = array();
		foreach ($a as $s) { // each part
			if ($s) {
				if ($pos = strpos($s, $kv)) { // key/value delimiter
					$ka[trim(substr($s, 0, $pos))] = trim(substr($s, $pos + strlen($kv)));
				} else { // key delimiter not found
					$ka[] = trim($s);
				}
			}
		}
		return $ka;
	}

	return array();
}


/**
 * Set focus onto field with selector (similar behaviour of 'autofocus' HTML5 tag)
 *
 * @param 	string	$selector	Selector ('#id' or 'input[name=""ref""]') to use to find the HTML input field that must get the autofocus. You must use a CSS selector, so unique id preceding with the '#' char.
 * @return	void
 */
function dol_set_focus($selector)
{
	print ""\n"".'<!-- Set focus onto a specific field -->'.""\n"";
	print '<script nonce=""'.getNonce().'"">jQuery(document).ready(function() { jQuery(""'.dol_escape_js($selector).'"").focus(); });</script>'.""\n"";
}


/**
 * Return getmypid() or random PID when function is disabled
 * Some web hosts disable this php function for security reasons
 * and sometimes we can't redeclare function.
 *
 * @return	int
 */
function dol_getmypid()
{
	if (!function_exists('getmypid')) {
		return mt_rand(99900000, 99965535);
	} else {
		return getmypid();	// May be a number on 64 bits (depending on OS)
	}
}


/**
 * Generate natural SQL search string for a criteria (this criteria can be tested on one or several fields)
 *
 * @param   string|string[]	$fields 	String or array of strings, filled with the name of all fields in the SQL query we must check (combined with a OR). Example: array(""p.field1"",""p.field2"")
 * @param   string 			$value 		The value to look for.
 *                          		    If param $mode is 0, can contains several keywords separated with a space or |
 *                                      like ""keyword1 keyword2"" = We want record field like keyword1 AND field like keyword2
 *                                      or like ""keyword1|keyword2"" = We want record field like keyword1 OR field like keyword2
 *                             			If param $mode is 1, can contains an operator <, > or = like ""<10"" or "">=100.5 < -1000""
 *                             			If param $mode is 2 or -2, can contains a list of int id separated by comma like ""1,3,4""
 *                             			If param $mode is 3 or -3, can contains a list of string separated by comma like ""a,b,c"".
 * @param	integer			$mode		0=value is list of keyword strings, 1=value is a numeric test (Example "">5.5 <10""), 2=value is a list of ID separated with comma (Example '1,3,4'), -2 is for exclude list,
 * 										3=value is list of string separated with comma (Example 'text 1,text 2'), -3 if for exclude list, 4=value is a list of ID separated with comma (Example '2,7') to be used to search into a multiselect string '1,2,3,4'
 * @param	integer			$nofirstand	1=Do not output the first 'AND'
 * @return 	string 			$res 		The statement to append to the SQL query
 * @see dolSqlDateFilter()
 */
function natural_search($fields, $value, $mode = 0, $nofirstand = 0)
{
	global $db, $langs;

	$value = trim($value);

	if ($mode == 0) {
		$value = preg_replace('/\*/', '%', $value); // Replace * with %
	}
	if ($mode == 1) {
		$value = preg_replace('/([!<>=]+)\s+([0-9'.preg_quote($langs->trans(""DecimalSeparator""), '/').'\-])/', '\1\2', $value); // Clean string '< 10' into '<10' so we can then explode on space to get all tests to do
	}

	$value = preg_replace('/\s*\|\s*/', '|', $value);

	$crits = explode(' ', $value);
	$res = '';
	if (!is_array($fields)) {
		$fields = array($fields);
	}

	$i1 = 0;	// count the nb of and criteria added (all fields / criterias)
	foreach ($crits as $crit) {		// Loop on each AND criteria
		$crit = trim($crit);
		$i2 = 0;	// count the nb of valid criteria added for this this first criteria
		$newres = '';
		foreach ($fields as $field) {
			if ($mode == 1) {
				$tmpcrits = explode('|', $crit);
				$i3 = 0;	// count the nb of valid criteria added for this current field
				foreach ($tmpcrits as $tmpcrit) {
					if ($tmpcrit !== '0' && empty($tmpcrit)) {
						continue;
					}
					$tmpcrit = trim($tmpcrit);

					$newres .= (($i2 > 0 || $i3 > 0) ? ' OR ' : '');

					$operator = '=';
					$newcrit = preg_replace('/([!<>=]+)/', '', $tmpcrit);

					$reg = array();
					preg_match('/([!<>=]+)/', $tmpcrit, $reg);
					if (!empty($reg[1])) {
						$operator = $reg[1];
					}
					if ($newcrit != '') {
						$numnewcrit = price2num($newcrit);
						if (is_numeric($numnewcrit)) {
							$newres .= $field.' '.$operator.' '.((float) $numnewcrit); // should be a numeric
						} else {
							$newres .= '1 = 2'; // force false, we received a corrupted data
						}
						$i3++; // a criteria was added to string
					}
				}
				$i2++; // a criteria for 1 more field was added to string
			} elseif ($mode == 2 || $mode == -2) {
				$crit = preg_replace('/[^0-9,]/', '', $crit); // ID are always integer
				$newres .= ($i2 > 0 ? ' OR ' : '').$field."" "".($mode == -2 ? 'NOT ' : '');
				$newres .= $crit ? ""IN ("".$db->sanitize($db->escape($crit))."")"" : ""IN (0)"";
				if ($mode == -2) {
					$newres .= ' OR '.$field.' IS NULL';
				}
				$i2++; // a criteria for 1 more field was added to string
			} elseif ($mode == 3 || $mode == -3) {
				$tmparray = explode(',', $crit);
				if (count($tmparray)) {
					$listofcodes = '';
					foreach ($tmparray as $val) {
						$val = trim($val);
						if ($val) {
							$listofcodes .= ($listofcodes ? ',' : '');
							$listofcodes .= ""'"".$db->escape($val).""'"";
						}
					}
					$newres .= ($i2 > 0 ? ' OR ' : '').$field."" "".($mode == -3 ? 'NOT ' : '').""IN ("".$db->sanitize($listofcodes, 1)."")"";
					$i2++; // a criteria for 1 more field was added to string
				}
				if ($mode == -3) {
					$newres .= ' OR '.$field.' IS NULL';
				}
			} elseif ($mode == 4) {
				$tmparray = explode(',', $crit);
				if (count($tmparray)) {
					$listofcodes = '';
					foreach ($tmparray as $val) {
						$val = trim($val);
						if ($val) {
							$newres .= ($i2 > 0 ? "" OR ("" : ""("").$field."" LIKE '"".$db->escape($val)."",%'"";
							$newres .= ' OR '.$field."" = '"".$db->escape($val).""'"";
							$newres .= ' OR '.$field."" LIKE '%,"".$db->escape($val).""'"";
							$newres .= ' OR '.$field."" LIKE '%,"".$db->escape($val)."",%'"";
							$newres .= ')';
							$i2++; // a criteria for 1 more field was added to string (we can add several citeria for the same field as it is a multiselect search criteria)
						}
					}
				}
			} else { // $mode=0
				$tmpcrits = explode('|', $crit);
				$i3 = 0;	// count the nb of valid criteria added for the current couple criteria/field
				foreach ($tmpcrits as $tmpcrit) {	// loop on each OR criteria
					if ($tmpcrit !== '0' && empty($tmpcrit)) {
						continue;
					}
					$tmpcrit = trim($tmpcrit);

					if ($tmpcrit == '^$' || strpos($crit, '!') === 0) {	// If we search empty, we must combined different OR fields with AND
						$newres .= (($i2 > 0 || $i3 > 0) ? ' AND ' : '');
					} else {
						$newres .= (($i2 > 0 || $i3 > 0) ? ' OR ' : '');
					}

					if (preg_match('/\.(id|rowid)$/', $field)) {	// Special case for rowid that is sometimes a ref so used as a search field
						$newres .= $field."" = "".(is_numeric($tmpcrit) ? ((float) $tmpcrit) : '0');
					} else {
						$tmpcrit2 = $tmpcrit;
						$tmpbefore = '%';
						$tmpafter = '%';
						$tmps = '';

						if (preg_match('/^!/', $tmpcrit)) {
							$tmps .= $field."" NOT LIKE ""; // ! as exclude character
							$tmpcrit2 = preg_replace('/^!/', '', $tmpcrit2);
						} else {
							$tmps .= $field."" LIKE "";
						}
						$tmps .= ""'"";

						if (preg_match('/^[\^\$]/', $tmpcrit)) {
							$tmpbefore = '';
							$tmpcrit2 = preg_replace('/^[\^\$]/', '', $tmpcrit2);
						}
						if (preg_match('/[\^\$]$/', $tmpcrit)) {
							$tmpafter = '';
							$tmpcrit2 = preg_replace('/[\^\$]$/', '', $tmpcrit2);
						}

						if ($tmpcrit2 == '' || preg_match('/^!/', $tmpcrit)) {
							$tmps = ""("".$tmps;
						}
						$newres .= $tmps;
						$newres .= $tmpbefore;
						$newres .= $db->escape($tmpcrit2);
						$newres .= $tmpafter;
						$newres .= ""'"";
						if ($tmpcrit2 == '' || preg_match('/^!/', $tmpcrit)) {
							$newres .= "" OR "".$field."" IS NULL)"";
						}
					}

					$i3++;
				}

				$i2++; // a criteria for 1 more field was added to string
			}
		}

		if ($newres) {
			$res = $res.($res ? ' AND ' : '').($i2 > 1 ? '(' : '').$newres.($i2 > 1 ? ')' : '');
		}
		$i1++;
	}
	$res = ($nofirstand ? """" : "" AND "").""("".$res."")"";

	return $res;
}

/**
 * Return string with full Url. The file qualified is the one defined by relative path in $object->last_main_doc
 *
 * @param   Object	$object				Object
 * @return	string						Url string
 */
function showDirectDownloadLink($object)
{
	global $conf, $langs;

	$out = '';
	$url = $object->getLastMainDocLink($object->element);

	$out .= img_picto($langs->trans(""PublicDownloadLinkDesc""), 'globe').' <span class=""opacitymedium"">'.$langs->trans(""DirectDownloadLink"").'</span><br>';
	if ($url) {
		$out .= '<div class=""urllink""><input type=""text"" id=""directdownloadlink"" class=""quatrevingtpercent"" value=""'.$url.'""></div>';
		$out .= ajax_autoselect(""directdownloadlink"", 0);
	} else {
		$out .= '<div class=""urllink"">'.$langs->trans(""FileNotShared"").'</div>';
	}

	return $out;
}

/**
 * Return the filename of file to get the thumbs
 *
 * @param   string  $file           Original filename (full or relative path)
 * @param   string  $extName        Extension to differenciate thumb file name ('', '_small', '_mini')
 * @param   string  $extImgTarget   Force image extension for thumbs. Use '' to keep same extension than original image (default).
 * @return  string                  New file name (full or relative path, including the thumbs/). May be the original path if no thumb can exists.
 */
function getImageFileNameForSize($file, $extName, $extImgTarget = '')
{
	$dirName = dirname($file);
	if ($dirName == '.') {
		$dirName = '';
	}

	$fileName = preg_replace('/(\.gif|\.jpeg|\.jpg|\.png|\.bmp|\.webp)$/i', '', $file); // We remove extension, whatever is its case
	$fileName = basename($fileName);

	if (empty($extImgTarget)) {
		$extImgTarget = (preg_match('/\.jpg$/i', $file) ? '.jpg' : '');
	}
	if (empty($extImgTarget)) {
		$extImgTarget = (preg_match('/\.jpeg$/i', $file) ? '.jpeg' : '');
	}
	if (empty($extImgTarget)) {
		$extImgTarget = (preg_match('/\.gif$/i', $file) ? '.gif' : '');
	}
	if (empty($extImgTarget)) {
		$extImgTarget = (preg_match('/\.png$/i', $file) ? '.png' : '');
	}
	if (empty($extImgTarget)) {
		$extImgTarget = (preg_match('/\.bmp$/i', $file) ? '.bmp' : '');
	}
	if (empty($extImgTarget)) {
		$extImgTarget = (preg_match('/\.webp$/i', $file) ? '.webp' : '');
	}

	if (!$extImgTarget) {
		return $file;
	}

	$subdir = '';
	if ($extName) {
		$subdir = 'thumbs/';
	}

	return ($dirName ? $dirName.'/' : '').$subdir.$fileName.$extName.$extImgTarget; // New filename for thumb
}


/**
 * Return URL we can use for advanced preview links
 *
 * @param   string    $modulepart     propal, facture, facture_fourn, ...
 * @param   string    $relativepath   Relative path of docs.
 * @param	int		  $alldata		  Return array with all components (1 is recommended, then use a simple a href link with the class, target and mime attribute added. 'documentpreview' css class is handled by jquery code into main.inc.php)
 * @param	string	  $param		  More param on http links
 * @return  string|array              Output string with href link or array with all components of link
 */
function getAdvancedPreviewUrl($modulepart, $relativepath, $alldata = 0, $param = '')
{
	global $conf, $langs;

	if (empty($conf->use_javascript_ajax)) {
		return '';
	}

	$isAllowedForPreview = dolIsAllowedForPreview($relativepath);

	if ($alldata == 1) {
		if ($isAllowedForPreview) {
			return array('target'=>'_blank', 'css'=>'documentpreview', 'url'=>DOL_URL_ROOT.'/document.php?modulepart='.$modulepart.'&attachment=0&file='.urlencode($relativepath).($param ? '&'.$param : ''), 'mime'=>dol_mimetype($relativepath));
		} else {
			return array();
		}
	}

	// old behavior, return a string
	if ($isAllowedForPreview) {
		return 'javascript:document_preview(\''.dol_escape_js(DOL_URL_ROOT.'/document.php?modulepart='.$modulepart.'&attachment=0&file='.urlencode($relativepath).($param ? '&'.$param : '')).'\', \''.dol_mimetype($relativepath).'\', \''.dol_escape_js($langs->trans('Preview')).'\')';
	} else {
		return '';
	}
}


/**
 * Make content of an input box selected when we click into input field.
 *
 * @param string	$htmlname		Id of html object ('#idvalue' or '.classvalue')
 * @param string	$addlink		Add a 'link to' after
 * @param string	$textonlink		Text to show on link or 'image'
 * @return string
 */
function ajax_autoselect($htmlname, $addlink = '', $textonlink = 'Link')
{
	global $langs;
	$out = '<script nonce=""'.getNonce().'"">
               jQuery(document).ready(function () {
				    jQuery(""'.((strpos($htmlname, '.') === 0 ? '' : '#').$htmlname).'"").click(function() { jQuery(this).select(); } );
				});
		    </script>';
	if ($addlink) {
		if ($textonlink === 'image') {
			$out .= ' <a href=""'.$addlink.'"" target=""_blank"" rel=""noopener noreferrer"">'.img_picto('', 'globe').'</a>';
		} else {
			$out .= ' <a href=""'.$addlink.'"" target=""_blank"" rel=""noopener noreferrer"">'.$langs->trans(""Link"").'</a>';
		}
	}
	return $out;
}

/**
 *	Return if a file is qualified for preview
 *
 *	@param	string	$file		Filename we looking for information
 *	@return int					1 If allowed, 0 otherwise
 *  @see    dol_mimetype(), image_format_supported() from images.lib.php
 */
function dolIsAllowedForPreview($file)
{
	global $conf;

	// Check .noexe extension in filename
	if (preg_match('/\.noexe$/i', $file)) {
		return 0;
	}

	// Check mime types
	$mime_preview = array('bmp', 'jpeg', 'png', 'gif', 'tiff', 'pdf', 'plain', 'css', 'webp');
	if (!empty($conf->global->MAIN_ALLOW_SVG_FILES_AS_IMAGES)) {
		$mime_preview[] = 'svg+xml';
	}
	//$mime_preview[]='vnd.oasis.opendocument.presentation';
	//$mime_preview[]='archive';
	$num_mime = array_search(dol_mimetype($file, '', 1), $mime_preview);
	if ($num_mime !== false) {
		return 1;
	}

	// By default, not allowed for preview
	return 0;
}


/**
 *	Return MIME type of a file from its name with extension.
 *
 *	@param	string	$file		Filename we looking for MIME type
 *  @param  string	$default    Default mime type if extension not found in known list
 * 	@param	int		$mode    	0=Return full mime, 1=otherwise short mime string, 2=image for mime type, 3=source language, 4=css of font fa
 *	@return string 		    	Return a mime type family (text/xxx, application/xxx, image/xxx, audio, video, archive)
 *  @see    dolIsAllowedForPreview(), image_format_supported() from images.lib.php
 */
function dol_mimetype($file, $default = 'application/octet-stream', $mode = 0)
{
	$mime = $default;
	$imgmime = 'other.png';
	$famime = 'file-o';
	$srclang = '';

	$tmpfile = preg_replace('/\.noexe$/', '', $file);

	// Plain text files
	if (preg_match('/\.txt$/i', $tmpfile)) {
		$mime = 'text/plain';
		$imgmime = 'text.png';
		$famime = 'file-text-o';
	}
	if (preg_match('/\.rtx$/i', $tmpfile)) {
		$mime = 'text/richtext';
		$imgmime = 'text.png';
		$famime = 'file-text-o';
	}
	if (preg_match('/\.csv$/i', $tmpfile)) {
		$mime = 'text/csv';
		$imgmime = 'text.png';
		$famime = 'file-text-o';
	}
	if (preg_match('/\.tsv$/i', $tmpfile)) {
		$mime = 'text/tab-separated-values';
		$imgmime = 'text.png';
		$famime = 'file-text-o';
	}
	if (preg_match('/\.(cf|conf|log)$/i', $tmpfile)) {
		$mime = 'text/plain';
		$imgmime = 'text.png';
		$famime = 'file-text-o';
	}
	if (preg_match('/\.ini$/i', $tmpfile)) {
		$mime = 'text/plain';
		$imgmime = 'text.png';
		$srclang = 'ini';
		$famime = 'file-text-o';
	}
	if (preg_match('/\.md$/i', $tmpfile)) {
		$mime = 'text/plain';
		$imgmime = 'text.png';
		$srclang = 'md';
		$famime = 'file-text-o';
	}
	if (preg_match('/\.css$/i', $tmpfile)) {
		$mime = 'text/css';
		$imgmime = 'css.png';
		$srclang = 'css';
		$famime = 'file-text-o';
	}
	if (preg_match('/\.lang$/i', $tmpfile)) {
		$mime = 'text/plain';
		$imgmime = 'text.png';
		$srclang = 'lang';
		$famime = 'file-text-o';
	}
	// Certificate files
	if (preg_match('/\.(crt|cer|key|pub)$/i', $tmpfile)) {
		$mime = 'text/plain';
		$imgmime = 'text.png';
		$famime = 'file-text-o';
	}
	// XML based (HTML/XML/XAML)
	if (preg_match('/\.(html|htm|shtml)$/i', $tmpfile)) {
		$mime = 'text/html';
		$imgmime = 'html.png';
		$srclang = 'html';
		$famime = 'file-text-o';
	}
	if (preg_match('/\.(xml|xhtml)$/i', $tmpfile)) {
		$mime = 'text/xml';
		$imgmime = 'other.png';
		$srclang = 'xml';
		$famime = 'file-text-o';
	}
	if (preg_match('/\.xaml$/i', $tmpfile)) {
		$mime = 'text/xml';
		$imgmime = 'other.png';
		$srclang = 'xaml';
		$famime = 'file-text-o';
	}
	// Languages
	if (preg_match('/\.bas$/i', $tmpfile)) {
		$mime = 'text/plain';
		$imgmime = 'text.png';
		$srclang = 'bas';
		$famime = 'file-code-o';
	}
	if (preg_match('/\.(c)$/i', $tmpfile)) {
		$mime = 'text/plain';
		$imgmime = 'text.png';
		$srclang = 'c';
		$famime = 'file-code-o';
	}
	if (preg_match('/\.(cpp)$/i', $tmpfile)) {
		$mime = 'text/plain';
		$imgmime = 'text.png';
		$srclang = 'cpp';
		$famime = 'file-code-o';
	}
	if (preg_match('/\.cs$/i', $tmpfile)) {
		$mime = 'text/plain';
		$imgmime = 'text.png';
		$srclang = 'cs';
		$famime = 'file-code-o';
	}
	if (preg_match('/\.(h)$/i', $tmpfile)) {
		$mime = 'text/plain';
		$imgmime = 'text.png';
		$srclang = 'h';
		$famime = 'file-code-o';
	}
	if (preg_match('/\.(java|jsp)$/i', $tmpfile)) {
		$mime = 'text/plain';
		$imgmime = 'text.png';
		$srclang = 'java';
		$famime = 'file-code-o';
	}
	if (preg_match('/\.php([0-9]{1})?$/i', $tmpfile)) {
		$mime = 'text/plain';
		$imgmime = 'php.png';
		$srclang = 'php';
		$famime = 'file-code-o';
	}
	if (preg_match('/\.phtml$/i', $tmpfile)) {
		$mime = 'text/plain';
		$imgmime = 'php.png';
		$srclang = 'php';
		$famime = 'file-code-o';
	}
	if (preg_match('/\.(pl|pm)$/i', $tmpfile)) {
		$mime = 'text/plain';
		$imgmime = 'pl.png';
		$srclang = 'perl';
		$famime = 'file-code-o';
	}
	if (preg_match('/\.sql$/i', $tmpfile)) {
		$mime = 'text/plain';
		$imgmime = 'text.png';
		$srclang = 'sql';
		$famime = 'file-code-o';
	}
	if (preg_match('/\.js$/i', $tmpfile)) {
		$mime = 'text/x-javascript';
		$imgmime = 'jscript.png';
		$srclang = 'js';
		$famime = 'file-code-o';
	}
	// Open office
	if (preg_match('/\.odp$/i', $tmpfile)) {
		$mime = 'application/vnd.oasis.opendocument.presentation';
		$imgmime = 'ooffice.png';
		$famime = 'file-powerpoint-o';
	}
	if (preg_match('/\.ods$/i', $tmpfile)) {
		$mime = 'application/vnd.oasis.opendocument.spreadsheet';
		$imgmime = 'ooffice.png';
		$famime = 'file-excel-o';
	}
	if (preg_match('/\.odt$/i', $tmpfile)) {
		$mime = 'application/vnd.oasis.opendocument.text';
		$imgmime = 'ooffice.png';
		$famime = 'file-word-o';
	}
	// MS Office
	if (preg_match('/\.mdb$/i', $tmpfile)) {
		$mime = 'application/msaccess';
		$imgmime = 'mdb.png';
		$famime = 'file-o';
	}
	if (preg_match('/\.doc[xm]?$/i', $tmpfile)) {
		$mime = 'application/msword';
		$imgmime = 'doc.png';
		$famime = 'file-word-o';
	}
	if (preg_match('/\.dot[xm]?$/i', $tmpfile)) {
		$mime = 'application/msword';
		$imgmime = 'doc.png';
		$famime = 'file-word-o';
	}
	if (preg_match('/\.xlt(x)?$/i', $tmpfile)) {
		$mime = 'application/vnd.ms-excel';
		$imgmime = 'xls.png';
		$famime = 'file-excel-o';
	}
	if (preg_match('/\.xla(m)?$/i', $tmpfile)) {
		$mime = 'application/vnd.ms-excel';
		$imgmime = 'xls.png';
		$famime = 'file-excel-o';
	}
	if (preg_match('/\.xls$/i', $tmpfile)) {
		$mime = 'application/vnd.ms-excel';
		$imgmime = 'xls.png';
		$famime = 'file-excel-o';
	}
	if (preg_match('/\.xls[bmx]$/i', $tmpfile)) {
		$mime = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';
		$imgmime = 'xls.png';
		$famime = 'file-excel-o';
	}
	if (preg_match('/\.pps[mx]?$/i', $tmpfile)) {
		$mime = 'application/vnd.ms-powerpoint';
		$imgmime = 'ppt.png';
		$famime = 'file-powerpoint-o';
	}
	if (preg_match('/\.ppt[mx]?$/i', $tmpfile)) {
		$mime = 'application/x-mspowerpoint';
		$imgmime = 'ppt.png';
		$famime = 'file-powerpoint-o';
	}
	// Other
	if (preg_match('/\.pdf$/i', $tmpfile)) {
		$mime = 'application/pdf';
		$imgmime = 'pdf.png';
		$famime = 'file-pdf-o';
	}
	// Scripts
	if (preg_match('/\.bat$/i', $tmpfile)) {
		$mime = 'text/x-bat';
		$imgmime = 'script.png';
		$srclang = 'dos';
		$famime = 'file-code-o';
	}
	if (preg_match('/\.sh$/i', $tmpfile)) {
		$mime = 'text/x-sh';
		$imgmime = 'script.png';
		$srclang = 'bash';
		$famime = 'file-code-o';
	}
	if (preg_match('/\.ksh$/i', $tmpfile)) {
		$mime = 'text/x-ksh';
		$imgmime = 'script.png';
		$srclang = 'bash';
		$famime = 'file-code-o';
	}
	if (preg_match('/\.bash$/i', $tmpfile)) {
		$mime = 'text/x-bash';
		$imgmime = 'script.png';
		$srclang = 'bash';
		$famime = 'file-code-o';
	}
	// Images
	if (preg_match('/\.ico$/i', $tmpfile)) {
		$mime = 'image/x-icon';
		$imgmime = 'image.png';
		$famime = 'file-image-o';
	}
	if (preg_match('/\.(jpg|jpeg)$/i', $tmpfile)) {
		$mime = 'image/jpeg';
		$imgmime = 'image.png';
		$famime = 'file-image-o';
	}
	if (preg_match('/\.png$/i', $tmpfile)) {
		$mime = 'image/png';
		$imgmime = 'image.png';
		$famime = 'file-image-o';
	}
	if (preg_match('/\.gif$/i', $tmpfile)) {
		$mime = 'image/gif';
		$imgmime = 'image.png';
		$famime = 'file-image-o';
	}
	if (preg_match('/\.bmp$/i', $tmpfile)) {
		$mime = 'image/bmp';
		$imgmime = 'image.png';
		$famime = 'file-image-o';
	}
	if (preg_match('/\.(tif|tiff)$/i', $tmpfile)) {
		$mime = 'image/tiff';
		$imgmime = 'image.png';
		$famime = 'file-image-o';
	}
	if (preg_match('/\.svg$/i', $tmpfile)) {
		$mime = 'image/svg+xml';
		$imgmime = 'image.png';
		$famime = 'file-image-o';
	}
	if (preg_match('/\.webp$/i', $tmpfile)) {
		$mime = 'image/webp';
		$imgmime = 'image.png';
		$famime = 'file-image-o';
	}
	// Calendar
	if (preg_match('/\.vcs$/i', $tmpfile)) {
		$mime = 'text/calendar';
		$imgmime = 'other.png';
		$famime = 'file-text-o';
	}
	if (preg_match('/\.ics$/i', $tmpfile)) {
		$mime = 'text/calendar';
		$imgmime = 'other.png';
		$famime = 'file-text-o';
	}
	// Other
	if (preg_match('/\.torrent$/i', $tmpfile)) {
		$mime = 'application/x-bittorrent';
		$imgmime = 'other.png';
		$famime = 'file-o';
	}
	// Audio
	if (preg_match('/\.(mp3|ogg|au|wav|wma|mid)$/i', $tmpfile)) {
		$mime = 'audio';
		$imgmime = 'audio.png';
		$famime = 'file-audio-o';
	}
	// Video
	if (preg_match('/\.mp4$/i', $tmpfile)) {
		$mime = 'video/mp4';
		$imgmime = 'video.png';
		$famime = 'file-video-o';
	}
	if (preg_match('/\.ogv$/i', $tmpfile)) {
		$mime = 'video/ogg';
		$imgmime = 'video.png';
		$famime = 'file-video-o';
	}
	if (preg_match('/\.webm$/i', $tmpfile)) {
		$mime = 'video/webm';
		$imgmime = 'video.png';
		$famime = 'file-video-o';
	}
	if (preg_match('/\.avi$/i', $tmpfile)) {
		$mime = 'video/x-msvideo';
		$imgmime = 'video.png';
		$famime = 'file-video-o';
	}
	if (preg_match('/\.divx$/i', $tmpfile)) {
		$mime = 'video/divx';
		$imgmime = 'video.png';
		$famime = 'file-video-o';
	}
	if (preg_match('/\.xvid$/i', $tmpfile)) {
		$mime = 'video/xvid';
		$imgmime = 'video.png';
		$famime = 'file-video-o';
	}
	if (preg_match('/\.(wmv|mpg|mpeg)$/i', $tmpfile)) {
		$mime = 'video';
		$imgmime = 'video.png';
		$famime = 'file-video-o';
	}
	// Archive
	if (preg_match('/\.(zip|rar|gz|tgz|z|cab|bz2|7z|tar|lzh|zst)$/i', $tmpfile)) {
		$mime = 'archive';
		$imgmime = 'archive.png';
		$famime = 'file-archive-o';
	}    // application/xxx where zzz is zip, ...
	// Exe
	if (preg_match('/\.(exe|com)$/i', $tmpfile)) {
		$mime = 'application/octet-stream';
		$imgmime = 'other.png';
		$famime = 'file-o';
	}
	// Lib
	if (preg_match('/\.(dll|lib|o|so|a)$/i', $tmpfile)) {
		$mime = 'library';
		$imgmime = 'library.png';
		$famime = 'file-o';
	}
	// Err
	if (preg_match('/\.err$/i', $tmpfile)) {
		$mime = 'error';
		$imgmime = 'error.png';
		$famime = 'file-text-o';
	}

	// Return string
	if ($mode == 1) {
		$tmp = explode('/', $mime);
		return (!empty($tmp[1]) ? $tmp[1] : $tmp[0]);
	}
	if ($mode == 2) {
		return $imgmime;
	}
	if ($mode == 3) {
		return $srclang;
	}
	if ($mode == 4) {
		return $famime;
	}
	return $mime;
}

/**
 * Return the value of a filed into a dictionary for the record $id.
 * This also set all the values into a cache for a next search.
 *
 * @param string	$tablename		Name of table dictionary (without the MAIN_DB_PREFIX, example: 'c_holiday_types')
 * @param string	$field			The name of field where to find the value to return
 * @param int		$id				Id of line record
 * @param bool		$checkentity	Add filter on entity
 * @param string	$rowidfield		Name of the column rowid (to use for the filter on $id)
 * @return string					The value of field $field. This also set $dictvalues cache.
 */
function getDictionaryValue($tablename, $field, $id, $checkentity = false, $rowidfield = 'rowid')
{
	global $conf, $db;

	$tablename = preg_replace('/^'.preg_quote(MAIN_DB_PREFIX, '/').'/', '', $tablename);	// Clean name of table for backward compatibility.

	$dictvalues = (isset($conf->cache['dictvalues_'.$tablename]) ? $conf->cache['dictvalues_'.$tablename] : null);

	if (is_null($dictvalues)) {
		$dictvalues = array();

		$sql = ""SELECT * FROM "".MAIN_DB_PREFIX.$tablename."" WHERE 1 = 1""; // Here select * is allowed as it is generic code and we don't have list of fields
		if ($checkentity) {
			$sql .= ' AND entity IN (0,'.getEntity($tablename).')';
		}

		$resql = $db->query($sql);
		if ($resql) {
			while ($obj = $db->fetch_object($resql)) {
				$dictvalues[$obj->{$rowidfield}] = $obj;	// $obj is stdClass
			}
		} else {
			dol_print_error($db);
		}

		$conf->cache['dictvalues_'.$tablename] = $dictvalues;
	}

	if (!empty($dictvalues[$id])) {
		// Found
		$tmp = $dictvalues[$id];
		return (property_exists($tmp, $field) ? $tmp->$field : '');
	} else {
		// Not found
		return '';
	}
}

/**
 *	Return true if the color is light
 *
 *  @param	string	$stringcolor		String with hex (FFFFFF) or comma RGB ('255,255,255')
 *  @return	int							-1 : Error with argument passed |0 : color is dark | 1 : color is light
 */
function colorIsLight($stringcolor)
{
	$stringcolor = str_replace('#', '', $stringcolor);
	$res = -1;
	if (!empty($stringcolor)) {
		$res = 0;
		$tmp = explode(',', $stringcolor);
		if (count($tmp) > 1) {   // This is a comma RGB ('255','255','255')
			$r = $tmp[0];
			$g = $tmp[1];
			$b = $tmp[2];
		} else {
			$hexr = $stringcolor[0].$stringcolor[1];
			$hexg = $stringcolor[2].$stringcolor[3];
			$hexb = $stringcolor[4].$stringcolor[5];
			$r = hexdec($hexr);
			$g = hexdec($hexg);
			$b = hexdec($hexb);
		}
		$bright = (max($r, $g, $b) + min($r, $g, $b)) / 510.0; // HSL algorithm
		if ($bright > 0.6) {
			$res = 1;
		}
	}
	return $res;
}

/**
 * Function to test if an entry is enabled or not
 *
 * @param	string		$type_user					0=We test for internal user, 1=We test for external user
 * @param	array		$menuentry					Array for feature entry to test
 * @param	array		$listofmodulesforexternal	Array with list of modules allowed to external users
 * @return	int										0=Hide, 1=Show, 2=Show gray
 */
function isVisibleToUserType($type_user, &$menuentry, &$listofmodulesforexternal)
{
	global $conf;

	//print 'type_user='.$type_user.' module='.$menuentry['module'].' enabled='.$menuentry['enabled'].' perms='.$menuentry['perms'];
	//print 'ok='.in_array($menuentry['module'], $listofmodulesforexternal);
	if (empty($menuentry['enabled'])) {
		return 0; // Entry disabled by condition
	}
	if ($type_user && $menuentry['module']) {
		$tmploops = explode('|', $menuentry['module']);
		$found = 0;
		foreach ($tmploops as $tmploop) {
			if (in_array($tmploop, $listofmodulesforexternal)) {
				$found++;
				break;
			}
		}
		if (!$found) {
			return 0; // Entry is for menus all excluded to external users
		}
	}
	if (!$menuentry['perms'] && $type_user) {
		return 0; // No permissions and user is external
	}
	if (!$menuentry['perms'] && !empty($conf->global->MAIN_MENU_HIDE_UNAUTHORIZED)) {
		return 0; // No permissions and option to hide when not allowed, even for internal user, is on
	}
	if (!$menuentry['perms']) {
		return 2; // No permissions and user is external
	}
	return 1;
}

/**
 * Round to next multiple.
 *
 * @param 	double		$n		Number to round up
 * @param 	integer		$x		Multiple. For example 60 to round up to nearest exact minute for a date with seconds.
 * @return 	integer				Value rounded.
 */
function roundUpToNextMultiple($n, $x = 5)
{
	return (ceil($n) % $x === 0) ? ceil($n) : round(($n + $x / 2) / $x) * $x;
}

/**
 * Function dolGetBadge
 *
 * @param   string  $label      label of badge no html : use in alt attribute for accessibility
 * @param   string  $html       optional : label of badge with html
 * @param   string  $type       type of badge : Primary Secondary Success Danger Warning Info Light Dark status0 status1 status2 status3 status4 status5 status6 status7 status8 status9
 * @param   string  $mode       default '' , 'pill', 'dot'
 * @param   string  $url        the url for link
 * @param   array   $params     various params for future : recommended rather than adding more fuction arguments. array('attr'=>array('title'=>'abc'))
 * @return  string              Html badge
 */
function dolGetBadge($label, $html = '', $type = 'primary', $mode = '', $url = '', $params = array())
{
	$attr = array(
		'class'=>'badge '.(!empty($mode) ? ' badge-'.$mode : '').(!empty($type) ? ' badge-'.$type : '').(empty($params['css']) ? '' : ' '.$params['css'])
	);

	if (empty($html)) {
		$html = $label;
	}

	if (!empty($url)) {
		$attr['href'] = $url;
	}

	if ($mode === 'dot') {
		$attr['class'] .= ' classfortooltip';
		$attr['title'] = $html;
		$attr['aria-label'] = $label;
		$html = '';
	}

	// Override attr
	if (!empty($params['attr']) && is_array($params['attr'])) {
		foreach ($params['attr'] as $key => $value) {
			if ($key == 'class') {
				$attr['class'] .= ' '.$value;
			} elseif ($key == 'classOverride') {
				$attr['class'] = $value;
			} else {
				$attr[$key] = $value;
			}
		}
	}

	// TODO: add hook

	// escape all attribute
	$attr = array_map('dol_escape_htmltag', $attr);

	$TCompiledAttr = array();
	foreach ($attr as $key => $value) {
		$TCompiledAttr[] = $key.'=""'.$value.'""';
	}

	$compiledAttributes = !empty($TCompiledAttr) ?implode(' ', $TCompiledAttr) : '';

	$tag = !empty($url) ? 'a' : 'span';

	return '<'.$tag.' '.$compiledAttributes.'>'.$html.'</'.$tag.'>';
}


/**
 * Output the badge of a status.
 *
 * @param   string  $statusLabel       Label of badge no html : use in alt attribute for accessibility
 * @param   string  $statusLabelShort  Short label of badge no html
 * @param   string  $html              Optional : label of badge with html
 * @param   string  $statusType        status0 status1 status2 status3 status4 status5 status6 status7 status8 status9 : image name or badge name
 * @param   int	    $displayMode       0=Long label, 1=Short label, 2=Picto + Short label, 3=Picto, 4=Picto + Long label, 5=Short label + Picto, 6=Long label + Picto
 * @param   string  $url               The url for link
 * @param   array   $params            Various params. Example: array('tooltip'=>'no|...', 'badgeParams'=>...)
 * @return  string                     Html status string
 */
function dolGetStatus($statusLabel = '', $statusLabelShort = '', $html = '', $statusType = 'status0', $displayMode = 0, $url = '', $params = array())
{
	global $conf;

	$return = '';
	$dolGetBadgeParams = array();

	if (!empty($params['badgeParams'])) {
		$dolGetBadgeParams = $params['badgeParams'];
	}

	// TODO : add a hook
	if ($displayMode == 0) {
		$return = !empty($html) ? $html : (empty($conf->dol_optimize_smallscreen) ? $statusLabel : (empty($statusLabelShort) ? $statusLabel : $statusLabelShort));
	} elseif ($displayMode == 1) {
		$return = !empty($html) ? $html : (empty($statusLabelShort) ? $statusLabel : $statusLabelShort);
	} elseif (!empty($conf->global->MAIN_STATUS_USES_IMAGES)) {
		// Use status with images (for backward compatibility)
		$return = '';
		$htmlLabel      = (in_array($displayMode, array(1, 2, 5)) ? '<span class=""hideonsmartphone"">' : '').(!empty($html) ? $html : $statusLabel).(in_array($displayMode, array(1, 2, 5)) ? '</span>' : '');
		$htmlLabelShort = (in_array($displayMode, array(1, 2, 5)) ? '<span class=""hideonsmartphone"">' : '').(!empty($html) ? $html : (!empty($statusLabelShort) ? $statusLabelShort : $statusLabel)).(in_array($displayMode, array(1, 2, 5)) ? '</span>' : '');

		// For small screen, we always use the short label instead of long label.
		if (!empty($conf->dol_optimize_smallscreen)) {
			if ($displayMode == 0) {
				$displayMode = 1;
			} elseif ($displayMode == 4) {
				$displayMode = 2;
			} elseif ($displayMode == 6) {
				$displayMode = 5;
			}
		}

		// For backward compatibility. Image's filename are still in French, so we use this array to convert
		$statusImg = array(
			'status0' => 'statut0',
			'status1' => 'statut1',
			'status2' => 'statut2',
			'status3' => 'statut3',
			'status4' => 'statut4',
			'status5' => 'statut5',
			'status6' => 'statut6',
			'status7' => 'statut7',
			'status8' => 'statut8',
			'status9' => 'statut9'
		);

		if (!empty($statusImg[$statusType])) {
			$htmlImg = img_picto($statusLabel, $statusImg[$statusType]);
		} else {
			$htmlImg = img_picto($statusLabel, $statusType);
		}

		if ($displayMode === 2) {
			$return = $htmlImg.' '.$htmlLabelShort;
		} elseif ($displayMode === 3) {
			$return = $htmlImg;
		} elseif ($displayMode === 4) {
			$return = $htmlImg.' '.$htmlLabel;
		} elseif ($displayMode === 5) {
			$return = $htmlLabelShort.' '.$htmlImg;
		} else { // $displayMode >= 6
			$return = $htmlLabel.' '.$htmlImg;
		}
	} elseif (empty($conf->global->MAIN_STATUS_USES_IMAGES) && !empty($displayMode)) {
		// Use new badge
		$statusLabelShort = (empty($statusLabelShort) ? $statusLabel : $statusLabelShort);

		$dolGetBadgeParams['attr']['class'] = 'badge-status';
		$dolGetBadgeParams['attr']['title'] = empty($params['tooltip']) ? $statusLabel : ($params['tooltip'] != 'no' ? $params['tooltip'] : '');

		if ($displayMode == 3) {
			$return = dolGetBadge((empty($conf->dol_optimize_smallscreen) ? $statusLabel : (empty($statusLabelShort) ? $statusLabel : $statusLabelShort)), '', $statusType, 'dot', $url, $dolGetBadgeParams);
		} elseif ($displayMode === 5) {
			$return = dolGetBadge($statusLabelShort, $html, $statusType, '', $url, $dolGetBadgeParams);
		} else {
			$return = dolGetBadge((empty($conf->dol_optimize_smallscreen) ? $statusLabel : (empty($statusLabelShort) ? $statusLabel : $statusLabelShort)), $html, $statusType, '', $url, $dolGetBadgeParams);
		}
	}

	return $return;
}


/**
 * Function dolGetButtonAction
 *
 * @param string    	$label      Label or tooltip of button. Also used as tooltip in title attribute. Can be escaped HTML content or full simple text.
 * @param string    	$text       Optional : short label on button. Can be escaped HTML content or full simple text.
 * @param string    	$actionType 'default', 'delete', 'danger', 'email', ...
 * @param string|array 	$url        Url for link or array of subbutton description
 * @param string    	$id         Attribute id of button
 * @param int|boolean	$userRight  User action right
 * // phpcs:disable
 * @param array 		$params = [ // Various params for future : recommended rather than adding more function arguments
 *                              'attr' => [ // to add or override button attributes
 *                              'xxxxx' => '', // your xxxxx attribute you want
 *                              'class' => 'reposition', // to add more css class to the button class attribute
 *                              'classOverride' => '' // to replace class attribute of the button
 *                              ],
 *                              'confirm' => [
 *                              'url' => 'http://', // Overide Url to go when user click on action btn, if empty default url is $url.?confirm=yes, for no js compatibility use $url for fallback confirm.
 *                              'title' => '', // Overide title of modal,  if empty default title use ""ConfirmBtnCommonTitle"" lang key
 *                              'action-btn-label' => '', // Overide label of action button,  if empty default label use ""Confirm"" lang key
 *                              'cancel-btn-label' => '', // Overide label of cancel button,  if empty default label use ""CloseDialog"" lang key
 *                              'content' => '', // Overide text of content,  if empty default content use ""ConfirmBtnCommonContent"" lang key
 *                              'modal' => true, // true|false to display dialog as a modal (with dark background)
 *                              'isDropDrown' => false, // true|false to display dialog as a dropdown (with dark background)
 *                              ],
 *                              ]
 * // phpcs:enable
 * @return string               	html button
 */
function dolGetButtonAction($label, $text = '', $actionType = 'default', $url = '', $id = '', $userRight = 1, $params = array())
{
	global $hookmanager, $action, $object, $langs;

	// If $url is an array, we must build a dropdown button
	if (is_array($url)) {
		$out = '<div class=""dropdown inline-block dropdown-holder"">';
		$out .= '<a style=""margin-right: auto;"" class=""dropdown-toggle butAction"" data-toggle=""dropdown"">'.$label.'</a>';
		$out .= '<div class=""dropdown-content"">';
		foreach ($url as $subbutton) {
			if ($subbutton['enabled'] && $subbutton['perm']) {
				if (!empty($subbutton['lang'])) {
					$langs->load($subbutton['lang']);
				}
				$out .= dolGetButtonAction('', $langs->trans($subbutton['label']), 'default', DOL_URL_ROOT.$subbutton['url'].(empty($params['backtopage']) ? '' : '&amp;backtopage='.urlencode($params['backtopage'])), '', 1, array('isDropDown' => true));
			}
		}
		$out .= ""</div>"";
		$out .= ""</div>"";

		return $out;
	}

	// If $url is a simple link
	if (!empty($params['isDropdown']))
		$class = ""dropdown-item"";
	else {
		$class = 'butAction';
		if ($actionType == 'danger' || $actionType == 'delete') {
			$class = 'butActionDelete';
			if (!empty($url) && strpos($url, 'token=') === false) $url .= '&token='.newToken();
		}
	}
	$attr = array(
		'class' => $class,
		'href' => empty($url) ? '' : $url,
		'title' => $label
	);

	if (empty($text)) {
		$text = $label;
		$attr['title'] = ''; // if html not set, leave label on title is redundant
	} else {
		$attr['title'] = $label;
		$attr['aria-label'] = $label;
	}

	if (empty($userRight)) {
		$attr['class'] = 'butActionRefused';
		$attr['href'] = '';
		$attr['title'] = (($label && $text && $label != $text) ? $label : $langs->trans('NotEnoughPermissions'));
	}

	if (!empty($id)) {
		$attr['id'] = $id;
	}

	// Override attr
	if (!empty($params['attr']) && is_array($params['attr'])) {
		foreach ($params['attr'] as $key => $value) {
			if ($key == 'class') {
				$attr['class'] .= ' '.$value;
			} elseif ($key == 'classOverride') {
				$attr['class'] = $value;
			} else {
				$attr[$key] = $value;
			}
		}
	}

	// automatic add tooltip when title is detected
	if (!empty($attr['title']) && !empty($attr['class']) && strpos($attr['class'], 'classfortooltip') === false) {
		$attr['class'].= ' classfortooltip';
	}

	// Js Confirm button
	if ($userRight && !empty($params['confirm'])) {
		if (!is_array($params['confirm'])) {
			$params['confirm'] = array();
		}

		if (empty($params['confirm']['url'])) {
			$params['confirm']['url'] = $url . (strpos($url, '?') > 0 ? '&' : '?') . 'confirm=yes';
		}

		// for js desabled compatibility set $url as call to confirm action and $params['confirm']['url'] to confirmed action
		$attr['data-confirm-url'] = $params['confirm']['url'];
		$attr['data-confirm-title'] = !empty($params['confirm']['title']) ? $params['confirm']['title'] : $langs->trans('ConfirmBtnCommonTitle', $label);
		$attr['data-confirm-content'] = !empty($params['confirm']['content']) ? $params['confirm']['content'] : $langs->trans('ConfirmBtnCommonContent', $label);
		$attr['data-confirm-content'] = preg_replace(""/\r|\n/"", """", $attr['data-confirm-content']);
		$attr['data-confirm-action-btn-label'] = !empty($params['confirm']['action-btn-label']) ? $params['confirm']['action-btn-label'] : $langs->trans('Confirm');
		$attr['data-confirm-cancel-btn-label'] = !empty($params['confirm']['cancel-btn-label']) ? $params['confirm']['cancel-btn-label'] : $langs->trans('CloseDialog');
		$attr['data-confirm-modal'] = !empty($params['confirm']['modal']) ? $params['confirm']['modal'] : true;

		$attr['class'].= ' butActionConfirm';
	}

	if (isset($attr['href']) && empty($attr['href'])) {
		unset($attr['href']);
	}

	// escape all attribute
	$attr = array_map('dol_escape_htmltag', $attr);

	$TCompiledAttr = array();
	foreach ($attr as $key => $value) {
		$TCompiledAttr[] = $key.'= ""'.$value.'""';
	}

	$compiledAttributes = empty($TCompiledAttr) ? '' : implode(' ', $TCompiledAttr);

	$tag = !empty($attr['href']) ? 'a' : 'span';


	$parameters = array(
		'TCompiledAttr' => $TCompiledAttr,				// array
		'compiledAttributes' => $compiledAttributes,	// string
		'attr' => $attr,
		'tag' => $tag,
		'label' => $label,
		'html' => $text,
		'actionType' => $actionType,
		'url' => $url,
		'id' => $id,
		'userRight' => $userRight,
		'params' => $params
	);

	$reshook = $hookmanager->executeHooks('dolGetButtonAction', $parameters, $object, $action); // Note that $action and $object may have been modified by some hooks
	if ($reshook < 0) setEventMessages($hookmanager->error, $hookmanager->errors, 'errors');

	if (empty($reshook)) {
		if (dol_textishtml($text)) {	// If content already HTML encoded
			return '<' . $tag . ' ' . $compiledAttributes . '>' . $text . '</' . $tag . '>';
		} else {
			return '<' . $tag . ' ' . $compiledAttributes . '>' . dol_escape_htmltag($text) . '</' . $tag . '>';
		}
	} else {
		return $hookmanager->resPrint;
	}
}

/**
 * Add space between dolGetButtonTitle
 *
 * @param  string $moreClass 	more css class label
 * @return string 				html of title separator
 */
function dolGetButtonTitleSeparator($moreClass = """")
{
	return '<span class=""button-title-separator '.$moreClass.'"" ></span>';
}

/**
 * get field error icon
 *
 * @param  string  $fieldValidationErrorMsg message to add in tooltip
 * @return string html output
 */
function getFieldErrorIcon($fieldValidationErrorMsg)
{
	$out = '';
	if (!empty($fieldValidationErrorMsg)) {
		$out.= '<span class=""field-error-icon classfortooltip"" title=""'.dol_escape_htmltag($fieldValidationErrorMsg, 1).'""  role=""alert"" >'; // role alert is used for accessibility
		$out.= '<span class=""fa fa-exclamation-circle"" aria-hidden=""true"" ></span>'; // For accessibility icon is separated and aria-hidden
		$out.= '</span>';
	}

	return $out;
}

/**
 * Function dolGetButtonTitle : this kind of buttons are used in title in list
 *
 * @param string    $label      label of button
 * @param string    $helpText   optional : content for help tooltip
 * @param string    $iconClass  class for icon element (Example: 'fa fa-file')
 * @param string    $url        the url for link
 * @param string    $id         attribute id of button
 * @param int       $status     0 no user rights, 1 active, 2 current action or selected, -1 Feature Disabled, -2 disable Other reason use param $helpText as tooltip help
 * @param array     $params     various params for future : recommended rather than adding more function arguments
 * @return string               html button
 */
function dolGetButtonTitle($label, $helpText = '', $iconClass = 'fa fa-file', $url = '', $id = '', $status = 1, $params = array())
{
	global $langs, $conf, $user;

	// Actually this conf is used in css too for external module compatibility and smooth transition to this function
	if (!empty($conf->global->MAIN_BUTTON_HIDE_UNAUTHORIZED) && (!$user->admin) && $status <= 0) {
		return '';
	}

	$class = 'btnTitle';
	if (in_array($iconClass, array('fa fa-plus-circle', 'fa fa-plus-circle size15x', 'fa fa-comment-dots', 'fa fa-paper-plane'))) {
		$class .= ' btnTitlePlus';
	}
	$useclassfortooltip = 1;

	if (!empty($params['morecss'])) {
		$class .= ' '.$params['morecss'];
	}

	$attr = array(
		'class' => $class,
		'href' => empty($url) ? '' : $url
	);

	if (!empty($helpText)) {
		$attr['title'] = dol_escape_htmltag($helpText);
	} elseif (empty($attr['title']) && $label) {
		$attr['title'] = $label;
		$useclassfortooltip = 0;
	}

	if ($status == 2) {
		$attr['class'] .= ' btnTitleSelected';
	} elseif ($status <= 0) {
		$attr['class'] .= ' refused';

		$attr['href'] = '';

		if ($status == -1) { // disable
			$attr['title'] = dol_escape_htmltag($langs->transnoentitiesnoconv(""FeatureDisabled""));
		} elseif ($status == 0) { // Not enough permissions
			$attr['title'] = dol_escape_htmltag($langs->transnoentitiesnoconv(""NotEnoughPermissions""));
		}
	}

	if (!empty($attr['title']) && $useclassfortooltip) {
		$attr['class'] .= ' classfortooltip';
	}

	if (!empty($id)) {
		$attr['id'] = $id;
	}

	// Override attr
	if (!empty($params['attr']) && is_array($params['attr'])) {
		foreach ($params['attr'] as $key => $value) {
			if ($key == 'class') {
				$attr['class'] .= ' '.$value;
			} elseif ($key == 'classOverride') {
				$attr['class'] = $value;
			} else {
				$attr[$key] = $value;
			}
		}
	}

	if (isset($attr['href']) && empty($attr['href'])) {
		unset($attr['href']);
	}

	// TODO : add a hook

	// escape all attribute
	$attr = array_map('dol_escape_htmltag', $attr);

	$TCompiledAttr = array();
	foreach ($attr as $key => $value) {
		$TCompiledAttr[] = $key.'=""'.$value.'""';
	}

	$compiledAttributes = (empty($TCompiledAttr) ? '' : implode(' ', $TCompiledAttr));

	$tag = (empty($attr['href']) ? 'span' : 'a');

	$button = '<'.$tag.' '.$compiledAttributes.'>';
	$button .= '<span class=""'.$iconClass.' valignmiddle btnTitle-icon""></span>';
	if (!empty($params['forcenohideoftext'])) {
		$button .= '<span class=""valignmiddle text-plus-circle btnTitle-label'.(empty($params['forcenohideoftext']) ? ' hideonsmartphone' : '').'"">'.$label.'</span>';
	}
	$button .= '</'.$tag.'>';

	return $button;
}

/**
 * Get an array with properties of an element.
 *
 * @param   string 	$element_type 	Element type (Value of $object->element). Example:
 * 									'action', 'facture', 'project_task',
 * 									'myobject@mymodule' or
 * 									'myobject_mysubobject' (where mymodule = myobject, like 'project_task')
 * @return  array					(module, classpath, element, subelement, classfile, classname)
 * @see fetchObjectByElement()
 */
function getElementProperties($element_type)
{
	$regs = array();

	$classfile = $classname = $classpath = '';

	// Parse element/subelement
	$module = $element_type;
	$element = $element_type;
	$subelement = $element_type;

	// If we ask a resource form external module (instead of default path)
	if (preg_match('/^([^@]+)@([^@]+)$/i', $element_type, $regs)) {	// 'myobject@mymodule'
		$element = $subelement = $regs[1];
		$module = $regs[2];
	}

	// If we ask a resource for a string with an element and a subelement
	// Example 'project_task'
	if (preg_match('/^([^_]+)_([^_]+)/i', $element, $regs)) {	// 'myobject_mysubobject' with myobject=mymodule
		$module = $element = $regs[1];
		$subelement = $regs[2];
	}

	// For compat and To work with non standard path
	if ($element_type == ""action"") {
		$classpath = 'comm/action/class';
		$subelement = 'Actioncomm';
		$module = 'agenda';
	} elseif ($element_type == 'cronjob') {
		$classpath = 'cron/class';
		$module = 'cron';
	} elseif ($element_type == 'adherent_type') {
		$classpath = 'adherents/class';
		$classfile = 'adherent_type';
		$module = 'adherent';
		$subelement = 'adherent_type';
		$classname = 'AdherentType';
	} elseif ($element_type == 'bank_account') {
		$classpath = 'compta/bank/class';
		$module = 'banque';
		$classfile = 'account';
		$classname = 'Account';
	} elseif ($element_type == 'category') {
		$classpath = 'categories/class';
		$module = 'categorie';
		$subelement = 'categorie';
	} elseif ($element_type == 'contact') {
		$classpath = 'contact/class';
		$classfile = 'contact';
		$module = 'societe';
		$subelement = 'contact';
	} elseif ($element_type == 'stock') {
		$classpath = 'product/stock/class';
		$classfile = 'entrepot';
		$classname = 'Entrepot';
	} elseif ($element_type == 'project') {
		$classpath = 'projet/class';
		$module = 'projet';
	} elseif ($element_type == 'project_task') {
		$classpath = 'projet/class';
		$module = 'projet';
		$subelement = 'task';
	} elseif ($element_type == 'facture' || $element_type == 'invoice') {
		$classpath = 'compta/facture/class';
		$module = 'facture';
		$subelement = 'facture';
	} elseif ($element_type == 'commande' || $element_type == 'order') {
		$classpath = 'commande/class';
		$module = 'commande';
		$subelement = 'commande';
	} elseif ($element_type == 'propal') {
		$classpath = 'comm/propal/class';
	} elseif ($element_type == 'shipping') {
		$classpath = 'expedition/class';
		$classfile = 'expedition';
		$classname = 'Expedition';
		$module = 'expedition';
	} elseif ($element_type == 'supplier_proposal') {
		$classpath = 'supplier_proposal/class';
		$module = 'supplier_proposal';
		$element = 'supplierproposal';
		$classfile = 'supplier_proposal';
		$subelement = 'supplierproposal';
	} elseif ($element_type == 'shipping') {
		$classpath = 'expedition/class';
		$subelement = 'expedition';
		$module = 'expedition_bon';
	} elseif ($element_type == 'delivery') {
		$classpath = 'delivery/class';
		$subelement = 'delivery';
		$module = 'delivery_note';
	} elseif ($element_type == 'contract') {
		$classpath = 'contrat/class';
		$module = 'contrat';
		$subelement = 'contrat';
	} elseif ($element_type == 'mailing') {
		$classpath = 'comm/mailing/class';
		$module = 'mailing';
		$classfile = 'mailing';
		$classname = 'Mailing';
		$subelement = '';
	} elseif ($element_type == 'member') {
		$classpath = 'adherents/class';
		$module = 'adherent';
		$subelement = 'adherent';
	} elseif ($element_type == 'usergroup') {
		$classpath = 'user/class';
		$module = 'user';
	} elseif ($element_type == 'mo') {
		$classpath = 'mrp/class';
		$classfile = 'mo';
		$classname = 'Mo';
		$module = 'mrp';
		$subelement = '';
	} elseif ($element_type == 'cabinetmed_cons') {
		$classpath = 'cabinetmed/class';
		$module = 'cabinetmed';
		$subelement = 'cabinetmedcons';
	} elseif ($element_type == 'fichinter') {
		$classpath = 'fichinter/class';
		$module = 'ficheinter';
		$subelement = 'fichinter';
	} elseif ($element_type == 'dolresource' || $element_type == 'resource') {
		$classpath = 'resource/class';
		$module = 'resource';
		$subelement = 'dolresource';
	} elseif ($element_type == 'propaldet') {
		$classpath = 'comm/propal/class';
		$module = 'propal';
		$subelement = 'propaleligne';
	} elseif ($element_type == 'opensurvey_sondage') {
		$classpath = 'opensurvey/class';
		$module = 'opensurvey';
		$subelement = 'opensurveysondage';
	} elseif ($element_type == 'order_supplier') {
		$classpath = 'fourn/class';
		$module = 'fournisseur';
		$classfile = 'fournisseur.commande';
		$element = 'commande';
		$subelement = '';
		$classname = 'CommandeFournisseur';
	} elseif ($element_type == 'invoice_supplier') {
		$classpath = 'fourn/class';
		$module = 'fournisseur';
		$classfile = 'fournisseur.facture';
		$element = 'facture';
		$subelement = '';
		$classname = 'FactureFournisseur';
	} elseif ($element_type == ""service"") {
		$classpath = 'product/class';
		$subelement = 'product';
	} elseif ($element_type == 'salary') {
		$classpath = 'salaries/class';
		$module = 'salaries';
	} elseif ($element_type == 'productlot') {
		$module = 'productbatch';
		$classpath = 'product/stock/class';
		$classfile = 'productlot';
		$classname = 'Productlot';
		$element = 'productlot';
		$subelement = '';
	} elseif ($element_type == 'websitepage') {
		$classpath = 'website/class';
		$classfile = 'websitepage';
		$classname = 'Websitepage';
		$module = 'website';
		$subelement = 'websitepage';
	} elseif ($element_type == 'fiscalyear') {
		$classpath = 'core/class';
		$module = 'accounting';
		$subelement = 'fiscalyear';
	}

	if (empty($classfile)) {
		$classfile = strtolower($subelement);
	}
	if (empty($classname)) {
		$classname = ucfirst($subelement);
	}
	if (empty($classpath)) {
		$classpath = $module.'/class';
	}

	$element_properties = array(
		'module' => $module,
		'classpath' => $classpath,
		'element' => $element,
		'subelement' => $subelement,
		'classfile' => $classfile,
		'classname' => $classname
	);
	return $element_properties;
}

/**
 * Fetch an object from its id and element_type
 * Inclusion of classes is automatic
 *
 * @param	int     	$element_id 	Element id
 * @param	string  	$element_type 	Element type ('module' or 'myobject@mymodule' or 'mymodule_myobject')
 * @param	string     	$element_ref 	Element ref (Use this or element_id but not both)
 * @return 	int|object 					object || 0 || <0 if error
 */
function fetchObjectByElement($element_id, $element_type, $element_ref = '')
{
	global $db;

	$ret = 0;

	$element_prop = getElementProperties($element_type);
	//var_dump($element_prop);

	if (is_array($element_prop) && isModEnabled($element_prop['module'])) {
		dol_include_once('/'.$element_prop['classpath'].'/'.$element_prop['classfile'].'.class.php');

		if (class_exists($element_prop['classname'])) {
			$classname = $element_prop['classname'];
			$objecttmp = new $classname($db);
			$ret = $objecttmp->fetch($element_id, $element_ref);
			if ($ret >= 0) {
				if (empty($objecttmp->module)) {
					$objecttmp->module = $element_prop['module'];
				}

				return $objecttmp;
			}
		} else {
			return -1;
		}
	}

	return $ret;
}

/**
 * Return if a file can contains executable content
 *
 * @param   string  $filename       File name to test
 * @return  boolean                 True if yes, False if no
 */
function isAFileWithExecutableContent($filename)
{
	if (preg_match('/\.(htm|html|js|phar|php|php\d+|phtml|pht|pl|py|cgi|ksh|sh|shtml|bash|bat|cmd|wpk|exe|dmg)$/i', $filename)) {
		return true;
	}

	return false;
}

/**
 * Return the value of token currently saved into session with name 'newtoken'.
 * This token must be send by any POST as it will be used by next page for comparison with value in session.
 *
 * @since Dolibarr v10.0.7
 * @return  string
 */
function newToken()
{
	return empty($_SESSION['newtoken']) ? '' : $_SESSION['newtoken'];
}

/**
 * Return the value of token currently saved into session with name 'token'.
 * For ajax call, you must use this token as a parameter of the call into the js calling script (the called ajax php page must also set constant NOTOKENRENEWAL).
 *
 * @since Dolibarr v10.0.7
 * @return  string
 */
function currentToken()
{
	return isset($_SESSION['token']) ? $_SESSION['token'] : '';
}

/**
 * Return a random string to be used as a nonce value for js
 *
 * @return  string
 */
function getNonce()
{
	global $conf;

	if (empty($conf->cache['nonce'])) {
		$conf->cache['nonce'] = dolGetRandomBytes(8);
	}

	return $conf->cache['nonce'];
}


/**
 * Start a table with headers and a optinal clickable number (don't forget to use ""finishSimpleTable()"" after the last table row)
 *
 * @param string	$header		The first left header of the table (automatic translated)
 * @param string	$link		(optional) The link to a internal dolibarr page, when click on the number (without the first ""/"")
 * @param string	$arguments	(optional) Additional arguments for the link (e.g. ""search_status=0"")
 * @param integer	$emptyRows	(optional) The count of empty rows after the first header
 * @param integer	$number		(optional) The number that is shown right after the first header, when not set the link is shown on the right side of the header as ""FullList""
 * @return void
 *
 * @see finishSimpleTable()
 */
function startSimpleTable($header, $link = """", $arguments = """", $emptyRows = 0, $number = -1)
{
	global $langs;

	print '<div class=""div-table-responsive-no-min"">';
	print '<table class=""noborder centpercent"">';
	print '<tr class=""liste_titre"">';

	print $emptyRows < 1 ? '<th>' : '<th colspan=""'.($emptyRows + 1).'"">';

	print $langs->trans($header);

	// extra space between the first header and the number
	if ($number > -1) {
		print ' ';
	}

	if (!empty($link)) {
		if (!empty($arguments)) {
			print '<a href=""'.DOL_URL_ROOT.'/'.$link.'?'.$arguments.'"">';
		} else {
			print '<a href=""'.DOL_URL_ROOT.'/'.$link.'"">';
		}
	}

	if ($number > -1) {
		print '<span class=""badge"">'.$number.'</span>';
	}

	if (!empty($link)) {
		print '</a>';
	}

	print '</th>';

	if ($number < 0 && !empty($link)) {
		print '<th class=""right"">';

		if (!empty($arguments)) {
			print '<a class=""commonlink"" href=""'.DOL_URL_ROOT.'/'.$link.'?'.$arguments.'"">';
		} else {
			print '<a class=""commonlink"" href=""'.DOL_URL_ROOT.'/'.$link.'"">';
		}

		print $langs->trans(""FullList"");
		print '</a>';
		print '</th>';
	}

	print '</tr>';
}

/**
 * Add the correct HTML close tags for ""startSimpleTable(...)"" (use after the last table line)
 *
 * @param 	bool 	$addLineBreak	(optional) Add a extra line break after the complete table (\<br\>)
 * @return 	void
 *
 * @see startSimpleTable()
 */
function finishSimpleTable($addLineBreak = false)
{
	print '</table>';
	print '</div>';

	if ($addLineBreak) {
		print '<br>';
	}
}

/**
 * Add a summary line to the current open table (""None"", ""XMoreLines"" or ""Total xxx"")
 *
 * @param integer	$tableColumnCount		The complete count columns of the table
 * @param integer	$num					The count of the rows of the table, when it is zero (0) the ""$noneWord"" is shown instead
 * @param integer	$nbofloop				(optional)	The maximum count of rows thaht the table show (when it is zero (0) no summary line will show, expect ""$noneWord"" when $num === 0)
 * @param integer	$total					(optional)	The total value thaht is shown after when the table has minimum of one entire
 * @param string	$noneWord				(optional)	The word that is shown when the table has no entires ($num === 0)
 * @param boolean	$extraRightColumn		(optional)	Add a addtional column after the summary word and total number
 * @return void
 */
function addSummaryTableLine($tableColumnCount, $num, $nbofloop = 0, $total = 0, $noneWord = ""None"", $extraRightColumn = false)
{
	global $langs;

	if ($num === 0) {
		print '<tr class=""oddeven"">';
		print '<td colspan=""'.$tableColumnCount.'"" class=""opacitymedium"">'.$langs->trans($noneWord).'</td>';
		print '</tr>';
		return;
	}

	if ($nbofloop === 0) {
		// don't show a summary line
		return;
	}

	if ($num === 0) {
		$colspan = $tableColumnCount;
	} elseif ($num > $nbofloop) {
		$colspan = $tableColumnCount;
	} else {
		$colspan = $tableColumnCount - 1;
	}

	if ($extraRightColumn) {
		$colspan--;
	}

	print '<tr class=""liste_total"">';

	if ($nbofloop > 0 && $num > $nbofloop) {
		print '<td colspan=""'.$colspan.'"" class=""right"">'.$langs->trans(""XMoreLines"", ($num - $nbofloop)).'</td>';
	} else {
		print '<td colspan=""'.$colspan.'"" class=""right""> '.$langs->trans(""Total"").'</td>';
		print '<td class=""right"" width=""100"">'.price($total).'</td>';
	}

	if ($extraRightColumn) {
		print '<td></td>';
	}

	print '</tr>';
}

/**
 *  Return a file on output using a low memory. It can return very large files with no need of memory.
 *  WARNING: This close output buffers.
 *
 *  @param	string	$fullpath_original_file_osencoded		Full path of file to return.
 *  @param	int		$method									-1 automatic, 0=readfile, 1=fread, 2=stream_copy_to_stream
 *  @return void
 */
function readfileLowMemory($fullpath_original_file_osencoded, $method = -1)
{
	global $conf;

	if ($method == -1) {
		$method = 0;
		if (!empty($conf->global->MAIN_FORCE_READFILE_WITH_FREAD)) {
			$method = 1;
		}
		if (!empty($conf->global->MAIN_FORCE_READFILE_WITH_STREAM_COPY)) {
			$method = 2;
		}
	}

	// Be sure we don't have output buffering enabled to have readfile working correctly
	while (ob_get_level()) {
		ob_end_flush();
	}

	// Solution 0
	if ($method == 0) {
		readfile($fullpath_original_file_osencoded);
	} elseif ($method == 1) {
		// Solution 1
		$handle = fopen($fullpath_original_file_osencoded, ""rb"");
		while (!feof($handle)) {
			print fread($handle, 8192);
		}
		fclose($handle);
	} elseif ($method == 2) {
		// Solution 2
		$handle1 = fopen($fullpath_original_file_osencoded, ""rb"");
		$handle2 = fopen(""php://output"", ""wb"");
		stream_copy_to_stream($handle1, $handle2);
		fclose($handle1);
		fclose($handle2);
	}
}

/**
 * Create a button to copy $valuetocopy in the clipboard (for copy and paste feature).
 * Code that handle the click is inside core/js/lib_foot.js.php.
 *
 * @param 	string 	$valuetocopy 		The value to print
 * @param	int		$showonlyonhover	Show the copy-paste button only on hover
 * @param	string	$texttoshow			Replace the value to show with this text. Use 'none' to show no text (only the copy-paste picto)
 * @return 	string 						The string to print for the button
 */
function showValueWithClipboardCPButton($valuetocopy, $showonlyonhover = 1, $texttoshow = '')
{
	/*
	global $conf;

	if (!empty($conf->dol_no_mouse_hover)) {
		$showonlyonhover = 0;
	}*/

	$tag = 'span'; 	// Using div (like any style of type 'block') does not work when using the js copy code.
	if ($texttoshow === 'none') {
		$result = '<span class=""clipboardCP'.($showonlyonhover ? ' clipboardCPShowOnHover' : '').'""><'.$tag.' class=""clipboardCPValue hidewithsize"">'.dol_escape_htmltag($valuetocopy, 1, 1).'</'.$tag.'><span class=""clipboardCPValueToPrint""></span><span class=""clipboardCPButton far fa-clipboard opacitymedium paddingleft paddingright""></span><span class=""clipboardCPText""></span></span>';
	} elseif ($texttoshow) {
		$result = '<span class=""clipboardCP'.($showonlyonhover ? ' clipboardCPShowOnHover' : '').'""><'.$tag.' class=""clipboardCPValue hidewithsize"">'.dol_escape_htmltag($valuetocopy, 1, 1).'</'.$tag.'><span class=""clipboardCPValueToPrint"">'.dol_escape_htmltag($texttoshow, 1, 1).'</span><span class=""clipboardCPButton far fa-clipboard opacitymedium paddingleft paddingright""></span><span class=""clipboardCPText""></span></span>';
	} else {
		$result = '<span class=""clipboardCP'.($showonlyonhover ? ' clipboardCPShowOnHover' : '').'""><'.$tag.' class=""clipboardCPValue"">'.dol_escape_htmltag($valuetocopy, 1, 1).'</'.$tag.'><span class=""clipboardCPButton far fa-clipboard opacitymedium paddingleft paddingright""></span><span class=""clipboardCPText""></span></span>';
	}

	return $result;
}


/**
 * Decode an encode string. The string can be encoded in json format (recommended) or with serialize (avoid this)
 *
 * @param 	string	$stringtodecode		String to decode (json or serialize coded)
 * @return	mixed						The decoded object.
 */
function jsonOrUnserialize($stringtodecode)
{
	$result = json_decode($stringtodecode);
	if ($result === null) {
		$result = unserialize($stringtodecode);
	}

	return $result;
}


/**
 * forgeSQLFromUniversalSearchCriteria
 *
 * @param 	string		$filter		String with universal search string. Must be  (aaa:bbb:...) with aaa is a field name (with alias or not) and bbb is one of this operator '=', '<', '>', '<=', '>=', '!=', 'in', 'notin', 'like', 'notlike', 'is', 'isnot'.
 * @param	string		$error		Error message
 * @return	string					Return forged SQL string
 */
function forgeSQLFromUniversalSearchCriteria($filter, &$error = '')
{
	$regexstring = '\(([a-zA-Z0-9_\.]+:[<>!=insotlke]+:[^\(\)]+)\)';	// Must be  (aaa:bbb:...) with aaa is a field name (with alias or not) and bbb is one of this operator '=', '<', '>', '<=', '>=', '!=', 'in', 'notin', 'like', 'notlike', 'is', 'isnot'

	if (!dolCheckFilters($filter, $error)) {
		return '1 = 2';		// Bad balance of parenthesis, we force a SQL not found
	}

	// Test the filter syntax
	$t = preg_replace_callback('/'.$regexstring.'/i', 'dolForgeDummyCriteriaCallback', $filter);
	$t = str_replace(array('and','or','AND','OR',' '), '', $t);		// Remove the only strings allowed between each () criteria
	// If the string result contains something else than '()', the syntax was wrong
	if (preg_match('/[^\(\)]/', $t)) {
		$error = 'Bad syntax of the search string, filter criteria is invalidated';
		return 'Filter syntax error';		// Bad syntax of the search string, we force a SQL not found
	}

	return "" AND ("".preg_replace_callback('/'.$regexstring.'/i', 'dolForgeCriteriaCallback', $filter)."")"";
}

/**
 * Return if a $sqlfilters parameter has a valid balance of parenthesis
 *
 * @param	string  		$sqlfilters     sqlfilter string
 * @param	string			$error			Error message
 * @return 	boolean			   				True if valid, False if not valid ($error is filled with the reason in such a case)
 */
function dolCheckFilters($sqlfilters, &$error = '')
{
	//$regexstring='\(([^:\'\(\)]+:[^:\'\(\)]+:[^:\(\)]+)\)';
	//$tmp=preg_replace_all('/'.$regexstring.'/', '', $sqlfilters);
	$tmp = $sqlfilters;
	$i = 0; $nb = strlen($tmp);
	$counter = 0;
	while ($i < $nb) {
		if ($tmp[$i] == '(') {
			$counter++;
		}
		if ($tmp[$i] == ')') {
			$counter--;
		}
		if ($counter < 0) {
			$error = ""Wrond balance of parenthesis in sqlfilters="".$sqlfilters;
			dol_syslog($error, LOG_WARNING);
			return false;
		}
		$i++;
	}
	return true;
}

/**
 * Function to forge a SQL criteria from a Dolibarr filter syntax string.
 * This method is called by forgeSQLFromUniversalSearchCriteria()
 *
 * @param  array    $matches       Array of found string by regex search. Example: ""t.ref:like:'SO-%'"" or ""t.date_creation:<:'20160101'"" or ""t.nature:is:NULL""
 * @return string                  Forged criteria. Example: ""t.field like 'abc%'""
 */
function dolForgeDummyCriteriaCallback($matches)
{
	//dol_syslog(""Convert matches "".$matches[1]);
	if (empty($matches[1])) {
		return '';
	}
	$tmp = explode(':', $matches[1]);
	if (count($tmp) < 3) {
		return '';
	}

	return '()';	// An empty criteria
}

/**
 * Function to forge a SQL criteria from a Dolibarr filter syntax string.
 * This method is called by forgeSQLFromUniversalSearchCriteria()
 *
 * @param  array    $matches       	Array of found string by regex search.
 * 									Example: ""t.ref:like:'SO-%'"" or ""t.date_creation:<:'20160101'"" or ""t.date_creation:<:'2016-01-01 12:30:00'"" or ""t.nature:is:NULL""
 * @return string                  	Forged criteria. Example: ""t.field like 'abc%'""
 */
function dolForgeCriteriaCallback($matches)
{
	global $db;

	//dol_syslog(""Convert matches "".$matches[1]);
	if (empty($matches[1])) {
		return '';
	}
	$tmp = explode(':', $matches[1]);
	if (count($tmp) < 3) {
		return '';
	}

	$operand = preg_replace('/[^a-z0-9\._]/i', '', trim($tmp[0]));

	$operator = strtoupper(preg_replace('/[^a-z<>!=]/i', '', trim($tmp[1])));

	if ($operator == 'NOTLIKE') {
		$operator = 'NOT LIKE';
	}
	if ($operator == 'ISNOT') {
		$operator = 'IS NOT';
	}
	if ($operator == '!=') {
		$operator = '<>';
	}

	$tmpescaped = $tmp[2];
	$regbis = array();

	if ($operator == 'IN') {	// IN is allowed for list of ID or code only
		//if (!preg_match('/^\(.*\)$/', $tmpescaped)) {
			$tmpescaped = '('.$db->escape($db->sanitize($tmpescaped, 1, 0)).')';
		//} else {
		//	$tmpescaped = $db->escape($db->sanitize($tmpescaped, 1));
		//}
	} elseif ($operator == 'LIKE' || $operator == 'NOT LIKE') {
		if (preg_match('/^\'(.*)\'$/', $tmpescaped, $regbis)) {
			$tmpescaped = $regbis[1];
		}
		//$tmpescaped = ""'"".$db->escapeforlike($db->escape($regbis[1])).""'"";
		$tmpescaped = ""'"".$db->escape($tmpescaped).""'"";	// We do not escape the _ and % so the like will works
	} elseif (preg_match('/^\'(.*)\'$/', $tmpescaped, $regbis)) {
		$tmpescaped = ""'"".$db->escape($regbis[1]).""'"";
	} else {
		if (strtoupper($tmpescaped) == 'NULL') {
			$tmpescaped = 'NULL';
		} elseif (is_int($tmpescaped)) {
			$tmpescaped = (int) $tmpescaped;
		} else {
			$tmpescaped = (float) $tmpescaped;
		}
	}

	return $db->escape($operand).' '.strtoupper($operator).' '.$tmpescaped;
}


/**
 * Get timeline icon
 *
 * @param ActionComm $actionstatic actioncomm
 * @param array $histo histo
 * @param int $key key
 * @return string
 */
function getTimelineIcon($actionstatic, &$histo, $key)
{
	global $conf, $langs;
	$out = '<!-- timeline icon -->'.""\n"";
	$iconClass = 'fa fa-comments';
	$img_picto = '';
	$colorClass = '';
	$pictoTitle = '';

	if ($histo[$key]['percent'] == -1) {
		$colorClass = 'timeline-icon-not-applicble';
		$pictoTitle = $langs->trans('StatusNotApplicable');
	} elseif ($histo[$key]['percent'] == 0) {
		$colorClass = 'timeline-icon-todo';
		$pictoTitle = $langs->trans('StatusActionToDo').' (0%)';
	} elseif ($histo[$key]['percent'] > 0 && $histo[$key]['percent'] < 100) {
		$colorClass = 'timeline-icon-in-progress';
		$pictoTitle = $langs->trans('StatusActionInProcess').' ('.$histo[$key]['percent'].'%)';
	} elseif ($histo[$key]['percent'] >= 100) {
		$colorClass = 'timeline-icon-done';
		$pictoTitle = $langs->trans('StatusActionDone').' (100%)';
	}

	if ($actionstatic->code == 'AC_TICKET_CREATE') {
		$iconClass = 'fa fa-ticket';
	} elseif ($actionstatic->code == 'AC_TICKET_MODIFY') {
		$iconClass = 'fa fa-pencilxxx';
	} elseif (preg_match('/^TICKET_MSG/', $actionstatic->code)) {
		$iconClass = 'fa fa-comments';
	} elseif (preg_match('/^TICKET_MSG_PRIVATE/', $actionstatic->code)) {
		$iconClass = 'fa fa-mask';
	} elseif (!empty($conf->global->AGENDA_USE_EVENT_TYPE)) {
		if ($actionstatic->type_picto) {
			$img_picto = img_picto('', $actionstatic->type_picto);
		} else {
			if ($actionstatic->type_code == 'AC_RDV') {
				$iconClass = 'fa fa-handshake';
			} elseif ($actionstatic->type_code == 'AC_TEL') {
				$iconClass = 'fa fa-phone';
			} elseif ($actionstatic->type_code == 'AC_FAX') {
				$iconClass = 'fa fa-fax';
			} elseif ($actionstatic->type_code == 'AC_EMAIL') {
				$iconClass = 'fa fa-envelope';
			} elseif ($actionstatic->type_code == 'AC_INT') {
				$iconClass = 'fa fa-shipping-fast';
			} elseif ($actionstatic->type_code == 'AC_OTH_AUTO') {
				$iconClass = 'fa fa-robot';
			} elseif (!preg_match('/_AUTO/', $actionstatic->type_code)) {
				$iconClass = 'fa fa-robot';
			}
		}
	}

	$out .= '<i class=""'.$iconClass.' '.$colorClass.'"" title=""'.$pictoTitle.'"">'.$img_picto.'</i>'.""\n"";
	return $out;
}

/**
 * getActionCommEcmList
 *
 * @param	ActionComm		$object			Object ActionComm
 * @return 	array							Array of documents in index table
 */
function getActionCommEcmList($object)
{
	global $conf, $db;

	$documents = array();

	$sql = 'SELECT ecm.rowid as id, ecm.src_object_type, ecm.src_object_id, ecm.filepath, ecm.filename';
	$sql .= ' FROM '.MAIN_DB_PREFIX.'ecm_files ecm';
	$sql .= "" WHERE ecm.filepath = 'agenda/"".((int) $object->id).""'"";
	//$sql.= "" ecm.src_object_type = '"".$db->escape($object->element).""' AND ecm.src_object_id = "".((int) $object->id); // Old version didn't add object_type during upload
	$sql .= ' ORDER BY ecm.position ASC';

	$resql = $db->query($sql);
	if ($resql) {
		if ($db->num_rows($resql)) {
			while ($obj = $db->fetch_object($resql)) {
				$documents[$obj->id] = $obj;
			}
		}
	}

	return $documents;
}



/**
 *    	Show html area with actions in messaging format.
 *      Note: Global parameter $param must be defined.
 *
 * 		@param	Conf		       $conf		   Object conf
 * 		@param	Translate	       $langs		   Object langs
 * 		@param	DoliDB		       $db			   Object db
 * 		@param	mixed			   $filterobj	   Filter on object Adherent|Societe|Project|Product|CommandeFournisseur|Dolresource|Ticket|... to list events linked to an object
 * 		@param	Contact		       $objcon		   Filter on object contact to filter events on a contact
 *      @param  int			       $noprint        Return string but does not output it
 *      @param  string		       $actioncode     Filter on actioncode
 *      @param  string             $donetodo       Filter on event 'done' or 'todo' or ''=nofilter (all).
 *      @param  array              $filters        Filter on other fields
 *      @param  string             $sortfield      Sort field
 *      @param  string             $sortorder      Sort order
 *      @return	string|void				           Return html part or void if noprint is 1
 */
function show_actions_messaging($conf, $langs, $db, $filterobj, $objcon = '', $noprint = 0, $actioncode = '', $donetodo = 'done', $filters = array(), $sortfield = 'a.datep,a.id', $sortorder = 'DESC')
{
	global $user, $conf;
	global $form;

	global $param, $massactionbutton;

	dol_include_once('/comm/action/class/actioncomm.class.php');

	// Check parameters
	if (!is_object($filterobj) && !is_object($objcon)) {
		dol_print_error('', 'BadParameter');
	}

	$histo = array();
	$numaction = 0;
	$now = dol_now();

	$sortfield_list = explode(',', $sortfield);
	$sortfield_label_list = array('a.id' => 'id', 'a.datep' => 'dp', 'a.percent' => 'percent');
	$sortfield_new_list = array();
	foreach ($sortfield_list as $sortfield_value) {
		$sortfield_new_list[] = $sortfield_label_list[trim($sortfield_value)];
	}
	$sortfield_new = implode(',', $sortfield_new_list);

	if (isModEnabled('agenda')) {
		// Search histo on actioncomm
		if (is_object($objcon) && $objcon->id > 0) {
			$sql = ""SELECT DISTINCT a.id, a.label as label,"";
		} else {
			$sql = ""SELECT a.id, a.label as label,"";
		}
		$sql .= "" a.datep as dp,"";
		$sql .= "" a.note as message,"";
		$sql .= "" a.datep2 as dp2,"";
		$sql .= "" a.percent as percent, 'action' as type,"";
		$sql .= "" a.fk_element, a.elementtype,"";
		$sql .= "" a.fk_contact,"";
		$sql .= "" c.code as acode, c.libelle as alabel, c.picto as apicto,"";
		$sql .= "" u.rowid as user_id, u.login as user_login, u.photo as user_photo, u.firstname as user_firstname, u.lastname as user_lastname"";
		if (is_object($filterobj) && get_class($filterobj) == 'Societe') {
			$sql .= "", sp.lastname, sp.firstname"";
		} elseif (is_object($filterobj) && get_class($filterobj) == 'Adherent') {
			$sql .= "", m.lastname, m.firstname"";
		} elseif (is_object($filterobj) && get_class($filterobj) == 'CommandeFournisseur') {
			$sql .= "", o.ref"";
		} elseif (is_object($filterobj) && get_class($filterobj) == 'Product') {
			$sql .= "", o.ref"";
		} elseif (is_object($filterobj) && get_class($filterobj) == 'Ticket') {
			$sql .= "", o.ref"";
		} elseif (is_object($filterobj) && get_class($filterobj) == 'BOM') {
			$sql .= "", o.ref"";
		} elseif (is_object($filterobj) && get_class($filterobj) == 'Contrat') {
			$sql .= "", o.ref"";
		}
		$sql .= "" FROM "".MAIN_DB_PREFIX.""actioncomm as a"";
		$sql .= "" LEFT JOIN "".MAIN_DB_PREFIX.""user as u on u.rowid = a.fk_user_action"";
		$sql .= "" LEFT JOIN "".MAIN_DB_PREFIX.""c_actioncomm as c ON a.fk_action = c.id"";

		$force_filter_contact = false;
		if (is_object($objcon) && $objcon->id > 0) {
			$force_filter_contact = true;
			$sql .= "" INNER JOIN "".MAIN_DB_PREFIX.""actioncomm_resources as r ON a.id = r.fk_actioncomm"";
			$sql .= "" AND r.element_type = '"".$db->escape($objcon->table_element).""' AND r.fk_element = "".((int) $objcon->id);
		}

		if (is_object($filterobj) && get_class($filterobj) == 'Societe') {
			$sql .= "" LEFT JOIN "".MAIN_DB_PREFIX.""socpeople as sp ON a.fk_contact = sp.rowid"";
		} elseif (is_object($filterobj) && get_class($filterobj) == 'Dolresource') {
			$sql .= "" INNER JOIN "".MAIN_DB_PREFIX.""element_resources as er"";
			$sql .= "" ON er.resource_type = 'dolresource'"";
			$sql .= "" AND er.element_id = a.id"";
			$sql .= "" AND er.resource_id = "".((int) $filterobj->id);
		} elseif (is_object($filterobj) && get_class($filterobj) == 'Adherent') {
			$sql .= "", "".MAIN_DB_PREFIX.""adherent as m"";
		} elseif (is_object($filterobj) && get_class($filterobj) == 'CommandeFournisseur') {
			$sql .= "", "".MAIN_DB_PREFIX.""commande_fournisseur as o"";
		} elseif (is_object($filterobj) && get_class($filterobj) == 'Product') {
			$sql .= "", "".MAIN_DB_PREFIX.""product as o"";
		} elseif (is_object($filterobj) && get_class($filterobj) == 'Ticket') {
			$sql .= "", "".MAIN_DB_PREFIX.""ticket as o"";
		} elseif (is_object($filterobj) && get_class($filterobj) == 'BOM') {
			$sql .= "", "".MAIN_DB_PREFIX.""bom_bom as o"";
		} elseif (is_object($filterobj) && get_class($filterobj) == 'Contrat') {
			$sql .= "", "".MAIN_DB_PREFIX.""contrat as o"";
		}

		$sql .= "" WHERE a.entity IN ("".getEntity('agenda')."")"";
		if ($force_filter_contact === false) {
			if (is_object($filterobj) && in_array(get_class($filterobj), array('Societe', 'Client', 'Fournisseur')) && $filterobj->id) {
				$sql .= "" AND a.fk_soc = "".((int) $filterobj->id);
			} elseif (is_object($filterobj) && get_class($filterobj) == 'Project' && $filterobj->id) {
				$sql .= "" AND a.fk_project = "".((int) $filterobj->id);
			} elseif (is_object($filterobj) && get_class($filterobj) == 'Adherent') {
				$sql .= "" AND a.fk_element = m.rowid AND a.elementtype = 'member'"";
				if ($filterobj->id) {
					$sql .= "" AND a.fk_element = "".((int) $filterobj->id);
				}
			} elseif (is_object($filterobj) && get_class($filterobj) == 'CommandeFournisseur') {
				$sql .= "" AND a.fk_element = o.rowid AND a.elementtype = 'order_supplier'"";
				if ($filterobj->id) {
					$sql .= "" AND a.fk_element = "".((int) $filterobj->id);
				}
			} elseif (is_object($filterobj) && get_class($filterobj) == 'Product') {
				$sql .= "" AND a.fk_element = o.rowid AND a.elementtype = 'product'"";
				if ($filterobj->id) {
					$sql .= "" AND a.fk_element = "".((int) $filterobj->id);
				}
			} elseif (is_object($filterobj) && get_class($filterobj) == 'Ticket') {
				$sql .= "" AND a.fk_element = o.rowid AND a.elementtype = 'ticket'"";
				if ($filterobj->id) {
					$sql .= "" AND a.fk_element = "".((int) $filterobj->id);
				}
			} elseif (is_object($filterobj) && get_class($filterobj) == 'BOM') {
				$sql .= "" AND a.fk_element = o.rowid AND a.elementtype = 'bom'"";
				if ($filterobj->id) {
					$sql .= "" AND a.fk_element = "".((int) $filterobj->id);
				}
			} elseif (is_object($filterobj) && get_class($filterobj) == 'Contrat') {
				$sql .= "" AND a.fk_element = o.rowid AND a.elementtype = 'contract'"";
				if ($filterobj->id) {
					$sql .= "" AND a.fk_element = "".((int) $filterobj->id);
				}
			}
		}

		// Condition on actioncode
		if (!empty($actioncode)) {
			if (empty($conf->global->AGENDA_USE_EVENT_TYPE)) {
				if ($actioncode == 'AC_NON_AUTO') {
					$sql .= "" AND c.type != 'systemauto'"";
				} elseif ($actioncode == 'AC_ALL_AUTO') {
					$sql .= "" AND c.type = 'systemauto'"";
				} else {
					if ($actioncode == 'AC_OTH') {
						$sql .= "" AND c.type != 'systemauto'"";
					} elseif ($actioncode == 'AC_OTH_AUTO') {
						$sql .= "" AND c.type = 'systemauto'"";
					}
				}
			} else {
				if ($actioncode == 'AC_NON_AUTO') {
					$sql .= "" AND c.type != 'systemauto'"";
				} elseif ($actioncode == 'AC_ALL_AUTO') {
					$sql .= "" AND c.type = 'systemauto'"";
				} else {
					$sql .= "" AND c.code = '"".$db->escape($actioncode).""'"";
				}
			}
		}
		if ($donetodo == 'todo') {
			$sql .= "" AND ((a.percent >= 0 AND a.percent < 100) OR (a.percent = -1 AND a.datep > '"".$db->idate($now).""'))"";
		} elseif ($donetodo == 'done') {
			$sql .= "" AND (a.percent = 100 OR (a.percent = -1 AND a.datep <= '"".$db->idate($now).""'))"";
		}
		if (is_array($filters) && $filters['search_agenda_label']) {
			$sql .= natural_search('a.label', $filters['search_agenda_label']);
		}
	}

	// Add also event from emailings. TODO This should be replaced by an automatic event ? May be it's too much for very large emailing.
	if (isModEnabled('mailing') && !empty($objcon->email)
		&& (empty($actioncode) || $actioncode == 'AC_OTH_AUTO' || $actioncode == 'AC_EMAILING')) {
		$langs->load(""mails"");

		$sql2 = ""SELECT m.rowid as id, m.titre as label, mc.date_envoi as dp, mc.date_envoi as dp2, '100' as percent, 'mailing' as type"";
		$sql2 .= "", null as fk_element, '' as elementtype, null as contact_id"";
		$sql2 .= "", 'AC_EMAILING' as acode, '' as alabel, '' as apicto"";
		$sql2 .= "", u.rowid as user_id, u.login as user_login, u.photo as user_photo, u.firstname as user_firstname, u.lastname as user_lastname""; // User that valid action
		if (is_object($filterobj) && get_class($filterobj) == 'Societe') {
			$sql2 .= "", '' as lastname, '' as firstname"";
		} elseif (is_object($filterobj) && get_class($filterobj) == 'Adherent') {
			$sql2 .= "", '' as lastname, '' as firstname"";
		} elseif (is_object($filterobj) && get_class($filterobj) == 'CommandeFournisseur') {
			$sql2 .= "", '' as ref"";
		} elseif (is_object($filterobj) && get_class($filterobj) == 'Product') {
			$sql2 .= "", '' as ref"";
		} elseif (is_object($filterobj) && get_class($filterobj) == 'Ticket') {
			$sql2 .= "", '' as ref"";
		}
		$sql2 .= "" FROM "".MAIN_DB_PREFIX.""mailing as m, "".MAIN_DB_PREFIX.""mailing_cibles as mc, "".MAIN_DB_PREFIX.""user as u"";
		$sql2 .= "" WHERE mc.email = '"".$db->escape($objcon->email).""'""; // Search is done on email.
		$sql2 .= "" AND mc.statut = 1"";
		$sql2 .= "" AND u.rowid = m.fk_user_valid"";
		$sql2 .= "" AND mc.fk_mailing=m.rowid"";
	}

	if (!empty($sql) && !empty($sql2)) {
		$sql = $sql."" UNION "".$sql2;
	} elseif (empty($sql) && !empty($sql2)) {
		$sql = $sql2;
	}

	// TODO Add limit in nb of results
	if ($sql) {	// May not be defined if module Agenda is not enabled and mailing module disabled too
		$sql .= $db->order($sortfield_new, $sortorder);

		dol_syslog(""function.lib::show_actions_messaging"", LOG_DEBUG);
		$resql = $db->query($sql);
		if ($resql) {
			$i = 0;
			$num = $db->num_rows($resql);

			while ($i < $num) {
				$obj = $db->fetch_object($resql);

				if ($obj->type == 'action') {
					$contactaction = new ActionComm($db);
					$contactaction->id = $obj->id;
					$result = $contactaction->fetchResources();
					if ($result < 0) {
						dol_print_error($db);
						setEventMessage(""actions.lib::show_actions_messaging Error fetch ressource"", 'errors');
					}

					//if ($donetodo == 'todo') $sql.= "" AND ((a.percent >= 0 AND a.percent < 100) OR (a.percent = -1 AND a.datep > '"".$db->idate($now).""'))"";
					//elseif ($donetodo == 'done') $sql.= "" AND (a.percent = 100 OR (a.percent = -1 AND a.datep <= '"".$db->idate($now).""'))"";
					$tododone = '';
					if (($obj->percent >= 0 and $obj->percent < 100) || ($obj->percent == -1 && $obj->dp > $now)) {
						$tododone = 'todo';
					}

					$histo[$numaction] = array(
						'type'=>$obj->type,
						'tododone'=>$tododone,
						'id'=>$obj->id,
						'datestart'=>$db->jdate($obj->dp),
						'dateend'=>$db->jdate($obj->dp2),
						'note'=>$obj->label,
						'message'=>$obj->message,
						'percent'=>$obj->percent,

						'userid'=>$obj->user_id,
						'login'=>$obj->user_login,
						'userfirstname'=>$obj->user_firstname,
						'userlastname'=>$obj->user_lastname,
						'userphoto'=>$obj->user_photo,

						'contact_id'=>$obj->fk_contact,
						'socpeopleassigned' => $contactaction->socpeopleassigned,
						'lastname' => (empty($obj->lastname) ? '' : $obj->lastname),
						'firstname' => (empty($obj->firstname) ? '' : $obj->firstname),
						'fk_element'=>$obj->fk_element,
						'elementtype'=>$obj->elementtype,
						// Type of event
						'acode'=>$obj->acode,
						'alabel'=>$obj->alabel,
						'libelle'=>$obj->alabel, // deprecated
						'apicto'=>$obj->apicto
					);
				} else {
					$histo[$numaction] = array(
						'type'=>$obj->type,
						'tododone'=>'done',
						'id'=>$obj->id,
						'datestart'=>$db->jdate($obj->dp),
						'dateend'=>$db->jdate($obj->dp2),
						'note'=>$obj->label,
						'message'=>$obj->message,
						'percent'=>$obj->percent,
						'acode'=>$obj->acode,

						'userid'=>$obj->user_id,
						'login'=>$obj->user_login,
						'userfirstname'=>$obj->user_firstname,
						'userlastname'=>$obj->user_lastname,
						'userphoto'=>$obj->user_photo
					);
				}

				$numaction++;
				$i++;
			}
		} else {
			dol_print_error($db);
		}
	}

	// Set $out to show events
	$out = '';

	if (!isModEnabled('agenda')) {
		$langs->loadLangs(array(""admin"", ""errors""));
		$out = info_admin($langs->trans(""WarningModuleXDisabledSoYouMayMissEventHere"", $langs->transnoentitiesnoconv(""Module2400Name"")), 0, 0, 'warning');
	}

	if (isModEnabled('agenda') || (isModEnabled('mailing') && !empty($objcon->email))) {
		$delay_warning = $conf->global->MAIN_DELAY_ACTIONS_TODO * 24 * 60 * 60;

		require_once DOL_DOCUMENT_ROOT.'/comm/action/class/actioncomm.class.php';
		include_once DOL_DOCUMENT_ROOT.'/core/lib/functions2.lib.php';
		require_once DOL_DOCUMENT_ROOT.'/core/class/html.formactions.class.php';
		require_once DOL_DOCUMENT_ROOT.'/contact/class/contact.class.php';

		$formactions = new FormActions($db);

		$actionstatic = new ActionComm($db);
		$userstatic = new User($db);
		$contactstatic = new Contact($db);
		$userGetNomUrlCache = array();

		$out .= '<div class=""filters-container"" >';
		$out .= '<form name=""listactionsfilter"" class=""listactionsfilter"" action=""'.$_SERVER[""PHP_SELF""].'"" method=""POST"">';
		$out .= '<input type=""hidden"" name=""token"" value=""'.newToken().'"">';

		if ($objcon && get_class($objcon) == 'Contact' &&
			(is_null($filterobj) || get_class($filterobj) == 'Societe')) {
			$out .= '<input type=""hidden"" name=""id"" value=""'.$objcon->id.'"" />';
		} else {
			$out .= '<input type=""hidden"" name=""id"" value=""'.$filterobj->id.'"" />';
		}
		if ($filterobj && get_class($filterobj) == 'Societe') {
			$out .= '<input type=""hidden"" name=""socid"" value=""'.$filterobj->id.'"" />';
		}

		$out .= ""\n"";

		$out .= '<div class=""div-table-responsive-no-min"">';
		$out .= '<table class=""noborder borderbottom centpercent"">';

		$out .= '<tr class=""liste_titre"">';

		$out .= getTitleFieldOfList('Date', 0, $_SERVER[""PHP_SELF""], 'a.datep', '', $param, '', $sortfield, $sortorder, '').""\n"";

		$out .= '<th class=""liste_titre""><strong class=""hideonsmartphone"">'.$langs->trans(""Search"").' : </strong></th>';
		if ($donetodo) {
			$out .= '<th class=""liste_titre""></th>';
		}
		$out .= '<th class=""liste_titre"">';
		$out .= '<span class=""fas fa-square inline-block fawidth30"" style="" color: #ddd;"" title=""'.$langs->trans(""ActionType"").'""></span>';
		//$out .= img_picto($langs->trans(""Type""), 'type');
		$out .= $formactions->select_type_actions($actioncode, ""actioncode"", '', empty($conf->global->AGENDA_USE_EVENT_TYPE) ? 1 : -1, 0, 0, 1, 'minwidth200imp');
		$out .= '</th>';
		$out .= '<th class=""liste_titre maxwidth100onsmartphone"">';
		$out .= '<input type=""text"" class=""maxwidth100onsmartphone"" name=""search_agenda_label"" value=""'.$filters['search_agenda_label'].'"" placeholder=""'.$langs->trans(""Label"").'"">';
		$out .= '</th>';

		$out .= '<th class=""liste_titre width50 middle"">';
		$searchpicto = $form->showFilterAndCheckAddButtons($massactionbutton ? 1 : 0, 'checkforselect', 1);
		$out .= $searchpicto;
		$out .= '</th>';
		$out .= '</tr>';


		$out .= '</table>';

		$out .= '</form>';
		$out .= '</div>';

		$out .= ""\n"";

		$out .= '<ul class=""timeline"">';

		if ($donetodo) {
			$tmp = '';
			if (get_class($filterobj) == 'Societe') {
				$tmp .= '<a href=""'.DOL_URL_ROOT.'/comm/action/list.php?mode=show_list&socid='.$filterobj->id.'&status=done"">';
			}
			$tmp .= ($donetodo != 'done' ? $langs->trans(""ActionsToDoShort"") : '');
			$tmp .= ($donetodo != 'done' && $donetodo != 'todo' ? ' / ' : '');
			$tmp .= ($donetodo != 'todo' ? $langs->trans(""ActionsDoneShort"") : '');
			//$out.=$langs->trans(""ActionsToDoShort"").' / '.$langs->trans(""ActionsDoneShort"");
			if (get_class($filterobj) == 'Societe') {
				$tmp .= '</a>';
			}
			$out .= getTitleFieldOfList($tmp);
		}


		//require_once DOL_DOCUMENT_ROOT.'/comm/action/class/cactioncomm.class.php';
		//$caction=new CActionComm($db);
		//$arraylist=$caction->liste_array(1, 'code', '', (empty($conf->global->AGENDA_USE_EVENT_TYPE)?1:0), '', 1);

		$actualCycleDate = false;

		// Loop on each event to show it
		foreach ($histo as $key => $value) {
			$actionstatic->fetch($histo[$key]['id']); // TODO Do we need this, we already have a lot of data of line into $histo

			$actionstatic->type_picto = $histo[$key]['apicto'];
			$actionstatic->type_code = $histo[$key]['acode'];

			$url = DOL_URL_ROOT.'/comm/action/card.php?id='.$histo[$key]['id'];

			$tmpa = dol_getdate($histo[$key]['datestart'], false);
			if ($actualCycleDate !== $tmpa['year'].'-'.$tmpa['yday']) {
				$actualCycleDate = $tmpa['year'].'-'.$tmpa['yday'];
				$out .= '<!-- timeline time label -->';
				$out .= '<li class=""time-label"">';
				$out .= '<span class=""timeline-badge-date"">';
				$out .= dol_print_date($histo[$key]['datestart'], 'daytext', 'tzuserrel', $langs);
				$out .= '</span>';
				$out .= '</li>';
				$out .= '<!-- /.timeline-label -->';
			}


			$out .= '<!-- timeline item -->'.""\n"";
			$out .= '<li class=""timeline-code-'.strtolower($actionstatic->code).'"">';

			$out .= getTimelineIcon($actionstatic, $histo, $key);

			$out .= '<div class=""timeline-item"">'.""\n"";

			$out .= '<span class=""timeline-header-action"">';

			if (isset($histo[$key]['type']) && $histo[$key]['type'] == 'mailing') {
				$out .= '<a class=""timeline-btn"" href=""'.DOL_URL_ROOT.'/comm/mailing/card.php?id='.$histo[$key]['id'].'"">'.img_object($langs->trans(""ShowEMailing""), ""email"").' ';
				$out .= $histo[$key]['id'];
				$out .= '</a> ';
			} else {
				$out .= $actionstatic->getNomUrl(1, -1, 'valignmiddle').' ';
			}

			if ($user->hasRight('agenda', 'allactions', 'create') ||
				(($actionstatic->authorid == $user->id || $actionstatic->userownerid == $user->id) && !empty($user->rights->agenda->myactions->create))) {
				$out .= '<a class=""timeline-btn"" href=""'.DOL_MAIN_URL_ROOT.'/comm/action/card.php?action=edit&token='.newToken().'&id='.$actionstatic->id.'&backtopage='.urlencode($_SERVER[""PHP_SELF""].'?'.$param).'""><i class=""fa fa-pencil"" title=""'.$langs->trans(""Modify"").'"" ></i></a>';
			}

			$out .= '</span>';
			// Date
			$out .= '<span class=""time""><i class=""fa fa-clock-o""></i> ';
			$out .= dol_print_date($histo[$key]['datestart'], 'dayhour', 'tzuserrel');
			if ($histo[$key]['dateend'] && $histo[$key]['dateend'] != $histo[$key]['datestart']) {
				$tmpa = dol_getdate($histo[$key]['datestart'], true);
				$tmpb = dol_getdate($histo[$key]['dateend'], true);
				if ($tmpa['mday'] == $tmpb['mday'] && $tmpa['mon'] == $tmpb['mon'] && $tmpa['year'] == $tmpb['year']) {
					$out .= '-'.dol_print_date($histo[$key]['dateend'], 'hour', 'tzuserrel');
				} else {
					$out .= '-'.dol_print_date($histo[$key]['dateend'], 'dayhour', 'tzuserrel');
				}
			}
			$late = 0;
			if ($histo[$key]['percent'] == 0 && $histo[$key]['datestart'] && $histo[$key]['datestart'] < ($now - $delay_warning)) {
				$late = 1;
			}
			if ($histo[$key]['percent'] == 0 && !$histo[$key]['datestart'] && $histo[$key]['dateend'] && $histo[$key]['datestart'] < ($now - $delay_warning)) {
				$late = 1;
			}
			if ($histo[$key]['percent'] > 0 && $histo[$key]['percent'] < 100 && $histo[$key]['dateend'] && $histo[$key]['dateend'] < ($now - $delay_warning)) {
				$late = 1;
			}
			if ($histo[$key]['percent'] > 0 && $histo[$key]['percent'] < 100 && !$histo[$key]['dateend'] && $histo[$key]['datestart'] && $histo[$key]['datestart'] < ($now - $delay_warning)) {
				$late = 1;
			}
			if ($late) {
				$out .= img_warning($langs->trans(""Late"")).' ';
			}
			$out .= ""</span>\n"";

			// Ref
			$out .= '<h3 class=""timeline-header"">';

			// Author of event
			$out .= '<div class=""messaging-author inline-block"">';
			if ($histo[$key]['userid'] > 0) {
				if (!isset($userGetNomUrlCache[$histo[$key]['userid']])) { // is in cache ?
					$userstatic->fetch($histo[$key]['userid']);
					$userGetNomUrlCache[$histo[$key]['userid']] = $userstatic->getNomUrl(-1, '', 0, 0, 16, 0, 'firstelselast', '');
				}
				$out .= $userGetNomUrlCache[$histo[$key]['userid']];
			}
			$out .= '</div>';

			// Title
			$libelle = '';
			$out .= ' <div class=""messaging-title inline-block"">';

			if (preg_match('/^TICKET_MSG/', $actionstatic->code)) {
				$out .= $langs->trans('TicketNewMessage');
			} elseif (preg_match('/^TICKET_MSG_PRIVATE/', $actionstatic->code)) {
				$out .= $langs->trans('TicketNewMessage').' <em>('.$langs->trans('Private').')</em>';
			} elseif (isset($histo[$key]['type'])) {
				if ($histo[$key]['type'] == 'action') {
					$transcode = $langs->transnoentitiesnoconv(""Action"".$histo[$key]['acode']);
					$libelle = ($transcode != ""Action"".$histo[$key]['acode'] ? $transcode : $histo[$key]['alabel']);
					$libelle = $histo[$key]['note'];
					$actionstatic->id = $histo[$key]['id'];
					$out .= dol_escape_htmltag(dol_trunc($libelle, 120));
				} elseif ($histo[$key]['type'] == 'mailing') {
					$out .= '<a href=""'.DOL_URL_ROOT.'/comm/mailing/card.php?id='.$histo[$key]['id'].'"">'.img_object($langs->trans(""ShowEMailing""), ""email"").' ';
					$transcode = $langs->transnoentitiesnoconv(""Action"".$histo[$key]['acode']);
					$libelle = ($transcode != ""Action"".$histo[$key]['acode'] ? $transcode : 'Send mass mailing');
					$out .= dol_escape_htmltag(dol_trunc($libelle, 120));
				} else {
					$libelle .= $histo[$key]['note'];
					$out .= dol_escape_htmltag(dol_trunc($libelle, 120));
				}
			}

			$out .= '</div>';

			$out .= '</h3>';

			if (!empty($histo[$key]['message'] && $histo[$key]['message'] != $libelle)
				&& $actionstatic->code != 'AC_TICKET_CREATE'
				&& $actionstatic->code != 'AC_TICKET_MODIFY'
			) {
				$out .= '<div class=""timeline-body"">';
				$out .= $histo[$key]['message'];
				$out .= '</div>';
			}

			// Timeline footer
			$footer = '';

			// Contact for this action
			if (isset($histo[$key]['socpeopleassigned']) && is_array($histo[$key]['socpeopleassigned']) && count($histo[$key]['socpeopleassigned']) > 0) {
				$contactList = '';
				foreach ($histo[$key]['socpeopleassigned'] as $cid => $Tab) {
					$contact = new Contact($db);
					$result = $contact->fetch($cid);

					if ($result < 0) {
						dol_print_error($db, $contact->error);
					}

					if ($result > 0) {
						$contactList .= !empty($contactList) ? ', ' : '';
						$contactList .= $contact->getNomUrl(1);
						if (isset($histo[$key]['acode']) && $histo[$key]['acode'] == 'AC_TEL') {
							if (!empty($contact->phone_pro)) {
								$contactList .= '('.dol_print_phone($contact->phone_pro).')';
							}
						}
					}
				}

				$footer .= $langs->trans('ActionOnContact').' : '.$contactList;
			} elseif (empty($objcon->id) && isset($histo[$key]['contact_id']) && $histo[$key]['contact_id'] > 0) {
				$contact = new Contact($db);
				$result = $contact->fetch($histo[$key]['contact_id']);

				if ($result < 0) {
					dol_print_error($db, $contact->error);
				}

				if ($result > 0) {
					$footer .= $contact->getNomUrl(1);
					if (isset($histo[$key]['acode']) && $histo[$key]['acode'] == 'AC_TEL') {
						if (!empty($contact->phone_pro)) {
							$footer .= '('.dol_print_phone($contact->phone_pro).')';
						}
					}
				}
			}

			$documents = getActionCommEcmList($actionstatic);
			if (!empty($documents)) {
				$footer .= '<div class=""timeline-documents-container"">';
				foreach ($documents as $doc) {
					$footer .= '<span id=""document_'.$doc->id.'"" class=""timeline-documents"" ';
					$footer .= ' data-id=""'.$doc->id.'"" ';
					$footer .= ' data-path=""'.$doc->filepath.'""';
					$footer .= ' data-filename=""'.dol_escape_htmltag($doc->filename).'"" ';
					$footer .= '>';

					$filePath = DOL_DATA_ROOT.'/'.$doc->filepath.'/'.$doc->filename;
					$mime = dol_mimetype($filePath);
					$file = $actionstatic->id.'/'.$doc->filename;
					$thumb = $actionstatic->id.'/thumbs/'.substr($doc->filename, 0, strrpos($doc->filename, '.')).'_mini'.substr($doc->filename, strrpos($doc->filename, '.'));
					$doclink = dol_buildpath('document.php', 1).'?modulepart=actions&attachment=0&file='.urlencode($file).'&entity='.$conf->entity;
					$viewlink = dol_buildpath('viewimage.php', 1).'?modulepart=actions&file='.urlencode($thumb).'&entity='.$conf->entity;

					$mimeAttr = ' mime=""'.$mime.'"" ';
					$class = '';
					if (in_array($mime, array('image/png', 'image/jpeg', 'application/pdf'))) {
						$class .= ' documentpreview';
					}

					$footer .= '<a href=""'.$doclink.'"" class=""btn-link '.$class.'"" target=""_blank"" rel=""noopener noreferrer"" '.$mimeAttr.' >';
					$footer .= img_mime($filePath).' '.$doc->filename;
					$footer .= '</a>';

					$footer .= '</span>';
				}
				$footer .= '</div>';
			}

			if (!empty($footer)) {
				$out .= '<div class=""timeline-footer"">'.$footer.'</div>';
			}

			$out .= '</div>'.""\n""; // end timeline-item

			$out .= '</li>';
			$out .= '<!-- END timeline item -->';

			$i++;
		}

		$out .= ""</ul>\n"";

		if (empty($histo)) {
			$out .= '<span class=""opacitymedium"">'.$langs->trans(""NoRecordFound"").'</span>';
		}
	}

	if ($noprint) {
		return $out;
	} else {
		print $out;
	}
}

/**
 * Helper function that combines values of a dolibarr DatePicker (such as Form::selectDate) for year, month, day (and
 * optionally hour, minute, second) fields to return a timestamp.
 *
 * @param string $prefix Prefix used to build the date selector (for instance using Form::selectDate)
 * @param string $hourTime  'getpost' to include hour, minute, second values from the HTTP request, 'XX:YY:ZZ' to set
 *                          hour, minute, second respectively (for instance '23:59:59')
 * @param string $gm Passed to dol_mktime
 * @return int|string  Date as a timestamp, '' or false if error
 */
function GETPOSTDATE($prefix, $hourTime = '', $gm = 'auto')
{
	if ($hourTime === 'getpost') {
		$hour   = GETPOSTINT($prefix . 'hour');
		$minute = GETPOSTINT($prefix . 'minute');
		$second = GETPOSTINT($prefix . 'second');
	} elseif (preg_match('/^(\d\d):(\d\d):(\d\d)$/', $hourTime, $m)) {
		$hour   = intval($m[1]);
		$minute = intval($m[2]);
		$second = intval($m[3]);
	} else {
		$hour = $minute = $second = 0;
	}
	// normalize out of range values
	$hour = min($hour, 23);
	$minute = min($minute, 59);
	$second = min($second, 59);
	return dol_mktime($hour, $minute, $second, GETPOSTINT($prefix . 'month'), GETPOSTINT($prefix . 'day'), GETPOSTINT($prefix . 'year'), $gm);
}

/**
 * Helper function that combines values of a dolibarr DatePicker (such as Form::selectDate) for year, month, day (and
 * optionally hour, minute, second) fields to return a a portion of URL reproducing the values from the current HTTP
 * request.
 *
 * @param string $prefix Prefix used to build the date selector (for instance using Form::selectDate)
 * @param int $timestamp If null, the timestamp will be created from request data
 * @param bool $hourTime If timestamp is null, will be passed to GETPOSTDATE to construct the timestamp
 * @param bool $gm If timestamp is null, will be passed to GETPOSTDATE to construct the timestamp
 * @return string Portion of URL with query parameters for the specified date
 */
function buildParamDate($prefix, $timestamp = null, $hourTime = '', $gm = 'auto')
{
	if ($timestamp === null) $timestamp = GETPOSTDATE($prefix, $hourTime, $gm);
	$TParam = array(
		$prefix . 'day'   => intval(dol_print_date($timestamp, '%d')),
		$prefix . 'month' => intval(dol_print_date($timestamp, '%m')),
		$prefix . 'year'  => intval(dol_print_date($timestamp, '%Y')),
	);
	if ($hourTime === 'getpost' || ($timestamp !== null && dol_print_date($timestamp, '%H:%M:%S') !== '00:00:00')) {
		$TParam = array_merge($TParam, array(
			$prefix . 'hour'   => intval(dol_print_date($timestamp, '%H')),
			$prefix . 'minute' => intval(dol_print_date($timestamp, '%M')),
			$prefix . 'second' => intval(dol_print_date($timestamp, '%S'))
		));
	}

	return '&' . http_build_query($TParam);
}
",1
"    public function getUploadDestinationDirectory(){
        return files_get_upload_dir($this->user_id);
    }",1
"function ShiftType_name_render(ShiftType $shifttype)
{
    if (auth()->can('shifttypes')) {
        return '<a href=""' . shifttype_link($shifttype) . '"">' . htmlspecialchars($shifttype->name) . '</a>';
    }
    return $shifttype->name;
}",0
"    private function insertSession($key, $data, $lastAccessed, $expiry)
    {
        //$this->log->debug('Session insert');

        $sql = '
          INSERT INTO `session` (session_id, session_data, session_expiration, lastaccessed, userid, isexpired, useragent, remoteaddr)
            VALUES (:session_id, :session_data, :session_expiration, :lastAccessed, :userId, :expired, :useragent, :remoteaddr)
        ';

        $params = [
            'session_id' => $key,
            'session_data' => $data,
            'session_expiration' => $expiry,
            'lastAccessed' => Carbon::createFromTimestamp($lastAccessed)->format(DateFormatHelper::getSystemFormat()),
            'userId' => $this->userId,
            'expired' => ($this->expired) ? 1 : 0,
            'useragent' => substr($_SERVER['HTTP_USER_AGENT'], 0, 253),
            'remoteaddr' => $this->getIp()
        ];

        $this->getDb()->update($sql, $params);
    }",1
"function list_devices(Illuminate\Http\Request $request)
{
    // This will return a list of devices

    $order = $request->get('order');
    $type = $request->get('type');
    $query = $request->get('query');
    $param = [];

    if (preg_match('/^([a-z_]+)(?: (desc|asc))?$/i', $order, $matches)) {
        $order = ""d.`$matches[1]` "" . ($matches[2] ?? 'ASC');
    } else {",0
"    public function extractOverflow() {
        if ($this->isCoalesced()) {
            $endPoint  = $this->getPayloadLength();
            $endPoint += $this->getPayloadStartingByte();

            if ($this->bytesRecvd > $endPoint) {
                $overflow   = substr($this->data, $endPoint);
                $this->data = substr($this->data, 0, $endPoint);

                return $overflow;
            }
        }

        return '';
    }",0
"                $that->closeError('Idle timeout');
            });
        }
    }",0
"            foreach ($privileges as $privilege) {
                $privileges_html[] = $privilege['name'];
            }",1
"    public function store(Request $request, FlasherInterface $flasher)
    {
        $this->validate($request, [
            'name' => 'required|string|unique:device_groups',
            'type' => 'required|in:dynamic,static',
            'devices' => 'array|required_if:type,static',
            'devices.*' => 'integer',
            'rules' => 'json|required_if:type,dynamic',
        ]);

        $deviceGroup = DeviceGroup::make($request->only(['name', 'desc', 'type']));
        $deviceGroup->rules = json_decode($request->rules);
        $deviceGroup->save();

        if ($request->type == 'static') {
            $deviceGroup->devices()->sync($request->devices);
        }

        $flasher->addSuccess(__('Device Group :name created', ['name' => $deviceGroup->name]));

        return redirect()->route('device-groups.index');
    }",1
"            . ($angeltype->pivot->supporter ? icon('patch-check') : '') . $angeltype->name
            . '</a>';
    }",1
"    public function getCacheDir()
    {
        return parent::getCacheDir() . \ltrim('/' . $this->appContext);
    }",0
"        foreach ($attachmentList as $attachment) {
            $html .= sprintf(
                '<li><i class=""fa fa-%s"" aria-hidden=""true""></i> <a href=""%s"">%s</a></li>',
                $this->mapMimeTypeToIcon($attachment->getMimeType()),
                $attachment->buildUrl(),
                $attachment->getFilename()
            );
        }",1
"    public function __construct(ProcessHandlerRegistry $registry, Security $security)
    {
        $this->registry = $registry;
        $this->security = $security;
    }",1
"        $title = ((array) $options)[0];
        $menu[] = toolbar_item_link(page_link_to($menu_page), '', $title, $menu_page == $page);
    }",1
"    public function getinvalidEmails()
    {
        return [
            ['test'],
            ['test@.de'],
            ['@example'],
            ['@example.de'],
            ['@.'],
            [' @foo.de'],
            ['@foo.'],
            ['foo@ .de'],
            ['foo@bar. '],
        ];
    }",1
"	protected function RenderEditionTools(WebPage $oPage, DashboardLayoutUIBlock $oDashboard, $aExtraParams)
	{
		$oPage->add_linked_script(utils::GetAbsoluteUrlAppRoot().'js/jquery.iframe-transport.js');
		$oPage->add_linked_script(utils::GetAbsoluteUrlAppRoot().'js/jquery.fileupload.js');
		$sId = utils::Sanitize($this->GetId(), '', 'element_identifier');

		$sMenuTogglerId = ""ibo-dashboard-menu-toggler-{$sId}"";
		$sPopoverMenuId = ""ibo-dashboard-menu-popover-{$sId}"";
		$sName = 'UI:Dashboard:Actions';

		$bFromDashboardPage = isset($aExtraParams['from_dashboard_page']) ? isset($aExtraParams['from_dashboard_page']) : false;
		if ($bFromDashboardPage) {
			if (!($oPage instanceof iTopWebPage)) {
				// TODO 3.0 change the menu
				return;
			}
			$oToolbar = $oPage->GetTopBarLayout()->GetToolbar();
		} else {
			$oToolbar = $oDashboard->GetToolbar();
		}
		$oActionButton = ButtonUIBlockFactory::MakeIconAction('fas fa-ellipsis-v', Dict::S($sName), $sName, '', false, $sMenuTogglerId)
			->AddCSSClass('ibo-top-bar--toolbar-dashboard-menu-toggler')
			->AddCSSClass('ibo-action-button');

		$oToolbar->AddSubBlock($oActionButton);

		$aActions = array();
		$sFile = addslashes($this->sDefinitionFile);
		$sJSExtraParams = json_encode($aExtraParams);
		if ($this->HasCustomDashboard()) {
			$oEdit = new JSPopupMenuItem('UI:Dashboard:Edit', Dict::S('UI:Dashboard:EditCustom'), ""return EditDashboard('{$this->sId}', '$sFile', $sJSExtraParams)"");
			$aActions[$oEdit->GetUID()] = $oEdit->GetMenuItem();
			$oRevert = new JSPopupMenuItem('UI:Dashboard:RevertConfirm', Dict::S('UI:Dashboard:DeleteCustom'),
				""if (confirm('"".addslashes(Dict::S('UI:Dashboard:RevertConfirm')).""')) return RevertDashboard('{$this->sId}', $sJSExtraParams); else return false"");
			$aActions[$oRevert->GetUID()] = $oRevert->GetMenuItem();
		} else {
			$oEdit = new JSPopupMenuItem('UI:Dashboard:Edit', Dict::S('UI:Dashboard:CreateCustom'), ""return EditDashboard('{$this->sId}', '$sFile', $sJSExtraParams)"");
			$aActions[$oEdit->GetUID()] = $oEdit->GetMenuItem();
		}


		utils::GetPopupMenuItems($oPage, iPopupMenuExtension::MENU_DASHBOARD_ACTIONS, $this, $aActions);

		$oActionsMenu = $oPage->GetPopoverMenu($sPopoverMenuId, $aActions)
			->SetTogglerJSSelector(""#$sMenuTogglerId"")
			->SetContainer(PopoverMenu::ENUM_CONTAINER_BODY);

		$oToolbar->AddSubBlock($oActionButton)
			->AddSubBlock($oActionsMenu);

		$sReloadURL = $this->GetReloadURL();
		$oPage->add_script(
			<<<EOF
function EditDashboard(sId, sDashboardFile, aExtraParams)
{
	$.post(GetAbsoluteUrlAppRoot()+'pages/ajax.render.php', {operation: 'dashboard_editor', id: sId, file: sDashboardFile, extra_params: aExtraParams, reload_url: '$sReloadURL'},
		function(data)
		{
			$('body').append(data);
		}
	);
	return false;
}
function RevertDashboard(sId, aExtraParams)
{
	$.post(GetAbsoluteUrlAppRoot()+'pages/ajax.render.php', {operation: 'revert_dashboard', dashboard_id: sId, extra_params: aExtraParams, reload_url: '$sReloadURL'},
		function(data)
		{
			location.reload();
		}
	);
	return false;
}
EOF
		);
	}",1
"    public static function register($protocol = 'sftp')
    {
        if (in_array($protocol, stream_get_wrappers(), true)) {
            return false;
        }
        return stream_wrapper_register($protocol, get_called_class());
    }",0
"        foreach ([-1, ""-1"", [-1], [""-1""]] as $value) {
            yield [
                'entity_restrict' => $value,
                'active_entities' => [0, 1, 2, 3],
                'result'          => is_array($value) ? [-1] : -1,
            ];
        }",0
"    public function serializedProvider() {
        return array(
            array(
                '_sf2_attributes|a:2:{s:5:""hello"";s:5:""world"";s:4:""last"";i:1332872102;}_sf2_flashes|a:0:{}'
              , array(
                    '_sf2_attributes' => array(
                        'hello' => 'world'
                      , 'last'  => 1332872102
                    )
                  , '_sf2_flashes' => array()
                )
            )
        );
    }",0
"	public function __set($strKey, $varValue)
	{
		switch ($strKey)
		{
			case 'maxlength':
				if ($varValue > 0)
				{
					$this->arrAttributes['maxlength'] = $varValue;
				}
				break;

			case 'mandatory':
				if ($varValue)
				{
					$this->arrAttributes['required'] = 'required';
				}
				else
				{
					unset($this->arrAttributes['required']);
				}
				parent::__set($strKey, $varValue);
				break;

			case 'options':
				$this->arrUnits = StringUtil::deserialize($varValue);
				break;

			default:
				parent::__set($strKey, $varValue);
				break;
		}
	}",1
"    public function tools_podcast_export()
    {
        echo sprintf(
            __('This export complements the existing %sWordPress export tool%s. It contains all relevant podcast data to enable you to move from this WordPress instance to another. Step by step:', 'podlove-podcasting-plugin-for-wordpress'),
            '<a href=""'.admin_url('export.php').'"">',
            '</a>'
        ); ?>
		<ol>
			<li>
				<?php echo sprintf(
            __('Go to the %sWordPress export tool%s and export all data.', 'podlove-podcasting-plugin-for-wordpress'),
            '<a href=""'.admin_url('export.php').'"">',
            '</a>'
        ); ?>
			</li>
			<li><?php echo __('Import this file to your new WordPress instance.', 'podlove-podcasting-plugin-for-wordpress'); ?></li>
			<li><?php echo __('Use the button below to export the podcast data file.', 'podlove-podcasting-plugin-for-wordpress'); ?></li>
			<li><?php echo __('In your new WordPress instance, import that file.', 'podlove-podcasting-plugin-for-wordpress'); ?></li>
		</ol>

		<a href=""?podlove_export=1"" class=""button""><?php echo __('Export Podcast Data', 'podlove-podcasting-plugin-for-wordpress'); ?></a>
		<?php
    }",1
"    public function convertToInternal(array $p)
    {
        if (empty($p)) {
            return [clone $this->zero, clone $this->one];
        }

        if (isset($p[1])) {
            return $p;
        }

        $p[1] = clone $this->one;

        return $p;
    }",0
"        foreach ($this->headers as $name => $values) {
            $name = $this->capitalizeHeaderName($name);

            if ($name === 'Set-Cookie') {
                $cookies = is_array($values) ? $values : [$values];
            } else {
                // Make sure the values are never arrays
                // because API Gateway v2 does not support multi-value headers
                $headers[$name] = is_array($values) ? end($values) : $values;
            }
        }",1
"function shifttype_controller()
{
    $request = request();
    if (!$request->has('shifttype_id')) {
        throw_redirect(page_link_to('shifttypes'));
    }
    $shifttype = ShiftType::findOrFail($request->input('shifttype_id'));

    return [
        $shifttype->name,
        ShiftType_view($shifttype),
    ];
}",1
"                foreach($row as $field) {

                    if(is_null($field)) {
                        
                        $fieldData .= "" NULL,"";

                    } elseif( is_numeric($field) ) {

                        $fieldData .= "" "".$field."","";

                    } else {
                        
                        $fieldData .= "" '"". $conn->real_escape_string($field) .""',"";

                    }

                }",1
"    public function testRender()
    {
        $kernel = self::bootKernel();
        /** @var Environment $twig */
        $twig = self::getContainer()->get('twig');
        $stack = self::getContainer()->get('request_stack');
        $request = new Request();
        $request->setLocale('en');
        $stack->push($request);

        $sut = new HtmlRenderer(
            $twig,
            new EventDispatcher(),
            $this->createMock(ProjectStatisticService::class),
            $this->createMock(ActivityStatisticService::class)
        );

        $response = $this->render($sut);

        $content = $response->getContent();

        $this->assertStringContainsString('>1:50<', $content);
    }",1
"            . page_link_to('angeltypes', ['action' => 'view', 'angeltype_id' => $user_angeltype->angel_type_id])
            . '"">' . $user_angeltype->angelType->name
            . ' (+' . $user_angeltype->count . ')'
            . '</a>';
    }

    $count = $unconfirmed_user_angeltypes->count();
    return
        _e(
            'There is %d unconfirmed angeltype.',
            'There are %d unconfirmed angeltypes.',
            $count,
            [$count]
        )
        . ' ' . __('Angel types which need approvals:')
        . ' ' . join(', ', $unconfirmed_links);
}",1
"    public function onError(ConnectionInterface $conn, \Exception $e) {
        $this->app->onError($conn, $e);
    }",0
"    private static function initialize_static_variables()
    {
        if (!self::$oidsLoaded) {
            ASN1::loadOIDs([
                'md2' => '1.2.840.113549.2.2',
                'md4' => '1.2.840.113549.2.4',
                'md5' => '1.2.840.113549.2.5',
                'id-sha1' => '1.3.14.3.2.26',
                'id-sha256' => '2.16.840.1.101.3.4.2.1',
                'id-sha384' => '2.16.840.1.101.3.4.2.2',
                'id-sha512' => '2.16.840.1.101.3.4.2.3',
                'id-sha224' => '2.16.840.1.101.3.4.2.4',
                'id-sha512/224' => '2.16.840.1.101.3.4.2.5',
                'id-sha512/256' => '2.16.840.1.101.3.4.2.6',

                'id-mgf1' => '1.2.840.113549.1.1.8'
            ]);
            self::$oidsLoaded = true;
        }
    }",0
"    public static function setModulo($instanceID, BigInteger $modulo)
    {
        static::$modulo[$instanceID] = $modulo;
    }",0
"    public function __construct()
    {
        $this->setModulo(new BigInteger('E95E4A5F737059DC60DFC7AD95B3D8139515620F', 16));
        $this->setCoefficients(
            new BigInteger('340E7BE2A280EB74E2BE61BADA745D97E8F7C300', 16),
            new BigInteger('1E589A8595423412134FAA2DBDEC95C8D8675E58', 16)
        );
        $this->setBasePoint(
            new BigInteger('BED5AF16EA3F6A4F62938C4631EB5AF7BDBCDBC3', 16),
            new BigInteger('1667CB477A1A8EC338F94741669C976316DA6321', 16)
        );
        $this->setOrder(new BigInteger('E95E4A5F737059DC60DF5991D45029409E60FC09', 16));
    }",0
"function ShiftEntry_create_view_admin(
    Shift $shift,
    Room $room,
    AngelType $angeltype,
    $angeltypes_select,
    $signup_user,
    $users_select
) {
    $start = $shift->start->format(__('Y-m-d H:i'));
    return page_with_title(
        ShiftEntry_create_title() . ': ' . $shift->shiftType->name
        . ' <small title=""' . $start . '"" data-countdown-ts=""' . $shift->start->timestamp . '"">%c</small>',
        [
            Shift_view_header($shift, $room),
            info(__('Do you want to sign up the following user for this shift?'), true),
            form([
                form_select('angeltype_id', __('Angeltype'), $angeltypes_select, $angeltype->id),
                form_select('user_id', __('User'), $users_select, $signup_user->id),
                form_submit('submit', icon('check-lg') . __('Save')),
            ]),
        ]
    );
}",1
"    public function plugin_git_settings_additional_webhooks(array $params) //phpcs:ignore PSR1.Methods.CamelCapsMethodName.NotCamelCaps
    {
        if ($this->isAllowed($params['repository']->getProjectId())) {
            $xzibit = new GitWebhooksSettingsEnhancer(
                new Hook\HookDao(),
                new LogFactory(
                    new JobDao(),
                    new ProjectJobDao(),
                    new GitRepositoryFactory(
                        new GitDao(),
                        ProjectManager::instance()
                    )
                ),
                $this->getCSRF(),
                self::getJenkinsServerFactory(),
                Codendi_HTMLPurifier::instance(),
                new \Tuleap\Sanitizer\URISanitizer(new Valid_HTTPURI()),
            );
            $xzibit->pimp($params);
        }
    }",0
"	public function field_type_disconnect_button(
		$field,
		$escaped_value,
		$object_id,
		$object_type,
		$field_type_object
	) {
		printf(
			'<a href=""%s"">%s</a>',
			htmlspecialchars( admin_url( 'admin.php?page=ssc_options&disconnect_simpleshop=1' ), ENT_QUOTES ),
			__( 'Disconnect SimpleShop', 'simpleshop-cz' )
		);
	}",1
"    protected function jacobianAddPoint(array $p, array $q)
    {
        list($x1, $y1, $z1) = $p;
        list($x2, $y2, $z2) = $q;

        $z12 = $z1->multiply($z1);
        $z22 = $z2->multiply($z2);

        $u1 = $x1->multiply($z22);
        $u2 = $x2->multiply($z12);
        $s1 = $y1->multiply($z22->multiply($z2));
        $s2 = $y2->multiply($z12->multiply($z1));
        if ($u1->equals($u2)) {
            if (!$s1->equals($s2)) {
                return [];
            } else {
                return $this->doublePoint($p);
            }
        }
        $h = $u2->subtract($u1);
        $r = $s2->subtract($s1);
        $h2 = $h->multiply($h);
        $h3 = $h2->multiply($h);
        $v = $u1->multiply($h2);
        $x3 = $r->multiply($r)->subtract($h3)->subtract($v->multiply($this->two));
        $y3 = $r->multiply(
            $v->subtract($x3)
        )->subtract(
            $s1->multiply($h3)
        );
        $z3 = $h->multiply($z1)->multiply($z2);
        return [$x3, $y3, $z3];
    }",0
"            $shifty = ['k' => 0, 'm' => 10, 'g' => 20];",0
"    private function rsavp1($s)
    {
        if ($s->compare(self::$zero) < 0 || $s->compare($this->modulus) > 0) {
            return false;
        }
        return $this->exponentiate($s);
    }",0
"                $template->addJSFromContext('wysiwyg/redactor/files/plugins/'.$plugin.'/'.$plugin.'.js');
            }

            if (in_array('clips', $this->options['plugins'])){
                $this->options['clipsUrl'] = href_to('wysiwyg/redactor/files/plugins/clips/index.html');
            }
        }

        if($this->lang !== 'en'){
            $template->addJSFromContext('wysiwyg/redactor/files/lang/'.$this->lang.'.js');
        }

        ob_start(); ?>

        <script>
            var redactor_global_options = {};
            function init_redactor (dom_id){
                var imperavi_options = {};
                if(redactor_global_options.hasOwnProperty('field_'+dom_id)){
                    imperavi_options = redactor_global_options['field_'+dom_id];
                } else if(redactor_global_options.hasOwnProperty('default')) {
                    imperavi_options = redactor_global_options.default;
                }
                icms.files.url_delete = '<?php echo href_to('files', 'delete'); ?>';
                imperavi_options.imageDeleteCallback = function (element){
                    if(confirm('<?php echo LANG_PARSER_IMAGE_DELETE; ?>')){
                        icms.files.deleteByPath($(element).attr('src'));
                    }
                };
                $('#'+dom_id).redactor(imperavi_options);
                icms.forms.addWysiwygsInsertPool(dom_id, function(field_element, text){
                    $('#'+field_element).redactor('set', text);
                    $('#'+field_element).redactor('focus');
                });
                icms.forms.addWysiwygsAddPool(dom_id, function(field_element, text){
                    $('#'+field_element).redactor('insertHtml', text);
                });
            }
        </script>

        <?php $template->addBottom(ob_get_clean());

        self::$redactor_loaded = true;

    }",1
"            . ($angeltype->pivot->supporter ? icon('patch-check') : '') . htmlspecialchars($angeltype->name)
            . '</a>';
    }",0
"	public function load_esi_block() {
		/**
		 * Validate if is a legal ESI req
		 * @since 2.9.6
		 */
		if ( empty( $_GET[ '_hash' ] ) || $this->_gen_esi_md5( $_GET ) != $_GET[ '_hash' ] ) {
			Debug2::debug( '[ESI] ❌ Failed to validate _hash' );
			return;
		}

		$params = $this->_parse_esi_param();

		if ( defined( 'LSCWP_LOG' ) ) {
			$logInfo = '[ESI] ⭕ ';
			if( ! empty( $params[ self::PARAM_NAME ] ) ) {
				$logInfo .= ' Name: ' . $params[ self::PARAM_NAME ] . ' ----- ';
			}
			$logInfo .= ' [ID] ' . LSCACHE_IS_ESI;
			Debug2::debug( $logInfo );
		}

		if ( ! empty( $params[ '_ls_silence' ] ) ) {
			! defined( 'LSCACHE_ESI_SILENCE' ) && define( 'LSCACHE_ESI_SILENCE', true );
		}

		/**
		 * Buffer needs to be JSON format
		 * @since  2.9.4
		 */
		if ( ! empty( $params[ 'is_json' ] ) ) {
			add_filter( 'litespeed_is_json', '__return_true' );
		}

		Tag::add( rtrim( Tag::TYPE_ESI, '.' ) );
		Tag::add( Tag::TYPE_ESI . LSCACHE_IS_ESI );

		// Debug2::debug(var_export($params, true ));

		/**
		 * Handle default cache control 'private,no-vary' for sub_esi_block() 	@ticket #923505
		 *
		 * @since  2.2.3
		 */
		if ( ! empty( $_GET[ '_control' ] ) ) {
			$control = explode( ',', $_GET[ '_control' ] );
			if ( in_array( 'private', $control ) ) {
				Control::set_private();
			}

			if ( in_array( 'no-vary', $control ) ) {
				Control::set_no_vary();
			}
		}

		do_action('litespeed_esi_load-' . LSCACHE_IS_ESI, $params);
	}",1
"    public function disableRemoteUpload() {
        $this->allow_remote = false; return $this;
    }",1
"    public function __construct(\SessionHandlerInterface $handler) {
        parent::__construct($handler);

        $this->saveHandlerName = 'user';
        $this->_sessionName    = ini_get('session.name');
    }",0
"	public function esi_template( $template ) {
		// Check if is an ESI request
		if ( defined( 'LSCACHE_IS_ESI' ) ) {
			Debug2::debug( '[ESI] calling template' );

			return LSCWP_DIR . 'tpl/esi.tpl.php';
		}
		$this->_register_not_esi_actions();
		return $template;
	}",1
"    protected function unsetCodeVerifier() {
        $this->unsetSessionKey('openid_connect_code_verifier');
    }",0
"    public function setModulo(BigInteger $modulo)
    {
        $this->modulo = $modulo;
        $this->factory = new PrimeField($modulo);
        $this->zero = $this->factory->newInteger(new BigInteger());
        $this->one = $this->factory->newInteger(new BigInteger(1));
    }",0
"    public function setMethod(string $method)
    {
        $this->method = null;
        $this->server->set('REQUEST_METHOD', $method);
    }",0
"		function read_gps_location($file)
		{
			if (is_file($file)) {
				$exif = exif_read_data($file);
				if (
					isset($exif['GPSLatitude']) && isset($exif['GPSLongitude']) &&
					isset($exif['GPSLatitudeRef']) && isset($exif['GPSLongitudeRef']) &&
					in_array($exif['GPSLatitudeRef'], array('E', 'W', 'N', 'S')) && in_array($exif['GPSLongitudeRef'], array('E', 'W', 'N', 'S'))
				) {

					$GPSLatitudeRef	 = strtolower(trim($exif['GPSLatitudeRef']));
					$GPSLongitudeRef = strtolower(trim($exif['GPSLongitudeRef']));

					$lat_degrees_a = explode('/', $exif['GPSLatitude'][0]);
					$lat_minutes_a = explode('/', $exif['GPSLatitude'][1]);
					$lat_seconds_a = explode('/', $exif['GPSLatitude'][2]);
					$lon_degrees_a = explode('/', $exif['GPSLongitude'][0]);
					$lon_minutes_a = explode('/', $exif['GPSLongitude'][1]);
					$lon_seconds_a = explode('/', $exif['GPSLongitude'][2]);

					$lat_degrees = $lat_degrees_a[0] / $lat_degrees_a[1];
					$lat_minutes = $lat_minutes_a[0] / $lat_minutes_a[1];
					$lat_seconds = $lat_seconds_a[0] / $lat_seconds_a[1];
					$lon_degrees = $lon_degrees_a[0] / $lon_degrees_a[1];
					$lon_minutes = $lon_minutes_a[0] / $lon_minutes_a[1];
					$lon_seconds = $lon_seconds_a[0] / $lon_seconds_a[1];

					$lat = (float) $lat_degrees + ((($lat_minutes * 60) + ($lat_seconds)) / 3600);
					$lon = (float) $lon_degrees + ((($lon_minutes * 60) + ($lon_seconds)) / 3600);

					// If the latitude is South, make it negative
					// If the longitude is west, make it negative
					$GPSLatitudeRef	 == 's' ? $lat *= -1 : '';
					$GPSLongitudeRef == 'w' ? $lon *= -1 : '';

					return array(
						'lat' => $lat,
						'lon' => $lon
					);
				}
			}
			return false;
		}",1
"function form_text_placeholder($name, $placeholder, $value, $disabled = false)
{
    $disabled = $disabled ? ' disabled=""disabled""' : '';
    return form_element(
        '',
        '<input class=""form-control"" id=""form_' . $name . '"" type=""text"" name=""' . $name
        . '"" value=""' . htmlspecialchars((string) $value) . '"" placeholder=""' . $placeholder
        . '"" ' . $disabled . '/>'
    );
}",1
"	public static function hasNote(array $attributes)
	{
		return !empty($attributes['fields']['custom_notes']);
	}",1
"function AngelTypes_render_contact_info(AngelType $angeltype)
{
    $info = [
        __('Name')   => [$angeltype->contact_name, $angeltype->contact_name],
        __('DECT')   => config('enable_dect') ? [sprintf('<a href=""tel:%s"">%1$s</a>', $angeltype->contact_dect), $angeltype->contact_dect] : null,
        __('E-Mail') => [sprintf('<a href=""mailto:%s"">%1$s</a>', $angeltype->contact_email), $angeltype->contact_email],
    ];
    $contactInfo = [];
    foreach ($info as $name => $data) {
        if (!empty($data[1])) {
            $contactInfo[$name] = $data[0];
        }
    }

    return heading(__('Contact'), 3) . description($contactInfo);
}",1
"  function privWriteCentralFileHeader(&$p_header)
  {
    $v_result=1;

    // TBC
    //for(reset($p_header); $key = key($p_header); next($p_header)) {
    //}

    // ----- Transform UNIX mtime to DOS format mdate/mtime
    $v_date = getdate($p_header['mtime']);
    $v_mtime = ($v_date['hours']<<11) + ($v_date['minutes']<<5) + $v_date['seconds']/2;
    $v_mdate = (($v_date['year']-1980)<<9) + ($v_date['mon']<<5) + $v_date['mday'];


    // ----- Packed data
    $v_binary_data = pack(""VvvvvvvVVVvvvvvVV"", 0x02014b50,
	                      $p_header['version'], $p_header['version_extracted'],
                          $p_header['flag'], $p_header['compression'],
						  $v_mtime, $v_mdate, $p_header['crc'],
                          $p_header['compressed_size'], $p_header['size'],
                          strlen($p_header['stored_filename']),
						  $p_header['extra_len'], $p_header['comment_len'],
                          $p_header['disk'], $p_header['internal'],
						  $p_header['external'], $p_header['offset']);

    // ----- Write the 42 bytes of the header in the zip file
    fputs($this->zip_fd, $v_binary_data, 46);

    // ----- Write the variable fields
    if (strlen($p_header['stored_filename']) != 0)
    {
      fputs($this->zip_fd, $p_header['stored_filename'], strlen($p_header['stored_filename']));
    }
    if ($p_header['extra_len'] != 0)
    {
      fputs($this->zip_fd, $p_header['extra'], $p_header['extra_len']);
    }
    if ($p_header['comment_len'] != 0)
    {
      fputs($this->zip_fd, $p_header['comment'], $p_header['comment_len']);
    }

    // ----- Return
    return $v_result;
  }",1
"    private static function extractPointRFC4050(\DOMXPath $xpath, BaseCurve $curve)
    {
        $x = self::query($xpath, 'publickey/x');
        $y = self::query($xpath, 'publickey/y');
        if (!$x->length || !$x->item(0)->hasAttribute('Value')) {
            throw new \RuntimeException('Public Key / X coordinate not found');
        }
        if (!$y->length || !$y->item(0)->hasAttribute('Value')) {
            throw new \RuntimeException('Public Key / Y coordinate not found');
        }
        $point = [
            $curve->convertInteger(new BigInteger($x->item(0)->getAttribute('Value'))),
            $curve->convertInteger(new BigInteger($y->item(0)->getAttribute('Value')))
        ];
        if (!$curve->verifyPoint($point)) {
            throw new \RuntimeException('Unable to verify that point exists on curve');
        }
        return $point;
    }",0
"function basil_the_title( $before, $after ) {

    global $wp_query;

    if ( !in_the_loop() && is_search() ):
        if ( have_posts() ) :
            echo $before . sprintf( esc_html__('Search Results for: %s', 'basil' ), '<span>' . get_search_query() . '</span>' ) . $after;
        else :
            echo $before . esc_html__( 'Nothing Found', 'basil' ) . $after;
        endif;
    else:

        global $bx_options,$post;

        if ( empty($post) )
            return;

        $default_option = ( isset( $bx_options['basil_page_title'] ) ? $bx_options['basil_page_title'] : 'enabled' );
        $bx_page_settings = get_post_meta( $post->ID, '_basil_page_settings', true);
        $title_setting = ( isset( $bx_page_settings['title'] ) && $bx_page_settings['title'] ? $bx_page_settings['title'] : false );

        if ( !in_the_loop() && is_archive() ):
            if ( $title_setting == 'enabled' || !$title_setting && $default_option == 'enabled' ):
                the_archive_title( $before, $after );
            endif;
        elseif ( $title_setting == 'enabled' || !$title_setting && $default_option == 'enabled' ):
            the_title( $before, $after );
        endif;

    endif;
    return false;

}",1
"function html_input($type = 'text', $name = '', $value = '', $attributes = []) {

    if ($type === 'password') {
        $attributes['autocomplete'] = 'off';
    }
    $attributes['type']  = $type;
    $attributes['name']  = $name;
    $attributes['value'] = $value;

    return html_tag_short('input', $attributes, 'input form-control');
}",1
"    function onClose(ConnectionInterface $conn) {
        return $this->_component->onClose($conn);
    }",0
"        foreach ($item_collection as $artifact) {
            $artifacts[$artifact->getId()] = $artifact;
            $backlog_item_ids[]            = $artifact->getId();
        }",1
"					$phpunit->assertTrue($newUser->validatePassword('topsecret2018'));
					$phpunit->assertEmpty($oldUser->password());
					$calls++;
				}",1
"    private function mapRecordData(array $records)
    {
        return array_map(function ($record) {
            return $record->data;
        }, $records);
    }",0
"    public function __construct(
        AgileDashboard_BacklogItemDao $dao,
        Tracker_ArtifactFactory $artifact_factory,
        Planning_MilestoneFactory $milestone_factory,
        PlanningFactory $planning_factory,
        AgileDashboard_Milestone_Backlog_IBuildBacklogItemAndBacklogItemCollection $backlog_item_builder,
        RemainingEffortValueRetriever $remaining_effort_value_retriever,
        ArtifactsInExplicitBacklogDao $artifacts_in_explicit_backlog_dao,
        Tracker_Artifact_PriorityDao $artifact_priority_dao,
        private readonly RetrieveUserPermissionOnArtifacts $user_permission_on_artifacts_retriever,
    ) {
        $this->dao                               = $dao;
        $this->artifact_factory                  = $artifact_factory;
        $this->milestone_factory                 = $milestone_factory;
        $this->planning_factory                  = $planning_factory;
        $this->backlog_item_builder              = $backlog_item_builder;
        $this->remaining_effort_value_retriever  = $remaining_effort_value_retriever;
        $this->artifacts_in_explicit_backlog_dao = $artifacts_in_explicit_backlog_dao;
        $this->artifact_priority_dao             = $artifact_priority_dao;

        $this->open_and_closed_collection              = [];
        $this->open_closed_and_inconsistent_collection = [];
        $this->todo_collection                         = [];
        $this->done_collection                         = [];
    }",0
"    private function getUserRemover()
    {
        return new UserRemover(
            ProjectManager::instance(),
            EventManager::instance(),
            new ArtifactTypeFactory(false),
            new UserRemoverDao(),
            UserManager::instance(),
            new ProjectHistoryDao(),
            new UGroupManager()
        );
    }",1
"    public function getFingerprint($algorithm = 'md5')
    {
        $type = self::validatePlugin('Keys', 'OpenSSH', 'savePublicKey');
        if ($type === false) {
            return false;
        }
        $key = $this->toString('OpenSSH', ['binary' => true]);
        if ($key === false) {
            return false;
        }
        switch ($algorithm) {
            case 'sha256':
                $hash = new Hash('sha256');
                $base = base64_encode($hash->hash($key));
                return substr($base, 0, strlen($base) - 1);
            case 'md5':
                return substr(chunk_split(md5($key), 2, ':'), 0, -1);
            default:
                return false;
        }
    }",0
"	public static function profile_pic_remove() {
		check_ajax_referer( 'user_registration_profile_picture_remove_nonce', 'security' );
		$nonce = isset( $_REQUEST['security'] ) ? sanitize_text_field( wp_unslash( $_REQUEST['security'] ) ) : false;

		$flag = wp_verify_nonce( $nonce, 'user_registration_profile_picture_remove_nonce' );

		if ( true != $flag || is_wp_error( $flag ) ) {
			wp_send_json_error(
				array(
					'message' => __( 'Nonce error, please reload.', 'user-registration' ),
				)
			);
		}

		$attachment_id = isset( $_POST['attachment_id'] ) ? intval( wp_unslash( $_POST['attachment_id'] ) ) : '';

		if ( file_exists( get_attached_file( $attachment_id ) ) && ! unlink( get_attached_file( $attachment_id ) ) ) {
			wp_send_json_error(
				array(
					'message' => esc_html__( 'File cannot be removed', 'user-registration' ),
				)
			);
		}

		$user_id = get_current_user_id();

		if ( $user_id > 0 ) {
			update_user_meta( $user_id, 'user_registration_profile_pic_url', '' );
		}

		wp_send_json_success(
			array(
				'message' => __( 'User profile picture removed successfully', 'user-registration' ),
			)
		);
	}",1
"    protected function doHttpRequest($verb = ""get"", $relative_uri = """", $params = [])
    {
        if (!empty($relative_uri)) {
            $params['headers']['Content-Type'] = ""application/json"";
        }
        if (isset($params['multipart'])) {
           // Guzzle lib will automatically push the correct Content-type
            unset($params['headers']['Content-Type']);
        }
        $verb = strtolower($verb);
        if (in_array($verb, ['get', 'post', 'delete', 'put', 'options', 'patch'])) {
            try {
                return $this->http_client->{$verb}(
                    $this->base_uri . $relative_uri,
                    $params
                );
            } catch (\Throwable $e) {
                throw $e;
            }
        }
    }",1
"    public function testCallErrorWithTopic() {
        $callId = uniqid();
        $uri    = 'http://example.com/end/point';

        $this->mock->expects($this->once())->method('send')->with(json_encode(array(4, $callId, $uri, '')));

        $this->conn->callError($callId, new Topic($uri));
    }",0
"function user_edit_vouchers_controller()
{
    $user = auth()->user();
    $request = request();

    if ($request->has('user_id')) {
        $user_source = User::find($request->input('user_id'));
    } else {
        $user_source = $user;
    }

    if (
        (!auth()->can('admin_user') && !auth()->can('voucher.edit'))
        || !config('enable_voucher')
    ) {
        throw_redirect(page_link_to());
    }

    if ($request->hasPostData('submit')) {
        $valid = true;

        $vouchers = '';
        if (
            $request->has('vouchers')
            && test_request_int('vouchers')
            && trim($request->input('vouchers')) >= 0
        ) {
            $vouchers = trim($request->input('vouchers'));
        } else {
            $valid = false;
            error(__('Please enter a valid number of vouchers.'));
        }

        if ($valid) {
            $user_source->state->got_voucher = $vouchers;
            $user_source->state->save();

            success(__('Saved the number of vouchers.'));
            engelsystem_log(User_Nick_render($user_source, true) . ': ' . sprintf(
                'Got %s vouchers',
                $user_source->state->got_voucher
            ));

            throw_redirect(user_link($user_source->id));
        }
    }

    return [
        sprintf(__('%s\'s vouchers'), $user_source->displayName),
        User_edit_vouchers_view($user_source),
    ];
}",1
"    public function __construct($environment, $debug, $suluContext = self::CONTEXT_ADMIN)
    {
        parent::__construct($environment, $debug, $suluContext);
    }",1
"    public function set(string $type, string|array $messages)
    {
        $this->flashes['new'][$type] = (array) $messages;
    }",0
"	protected function validator($varInput)
	{
		foreach ($varInput as $k=>$v)
		{
			if ($k != 'unit')
			{
				$varInput[$k] = parent::validator($v);
			}
		}

		return $varInput;
	}",1
"function success($msg, $immediately = false)
{
    return alert(NotificationType::MESSAGE, $msg, $immediately);
}",1
"    public function testgetPendingMessages()
    {
        $di = new \Pimple\Container();

        $sessionMock = $this->getMockBuilder('\Box_Session')->disableOriginalConstructor()->getMock();
        $sessionMock->expects($this->atLeastOnce())
            ->method('get')
            ->with('pending_messages')
            ->willReturn(array());

        $di['session'] = $sessionMock;

        $this->service->setDi($di);
        $result = $this->service->getPendingMessages();
        $this->assertIsArray($result);
    }",1
"    public static function encodeLength($length)
    {
        if ($length <= 0x7F) {
            return chr($length);
        }

        $temp = ltrim(pack('N', $length), chr(0));
        return pack('Ca*', 0x80 | strlen($temp), $temp);
    }",0
"    public static function createRequestForQuery(Query $query)
    {
        $request = new Message();
        $request->id = self::generateId();
        $request->rd = true;
        $request->questions[] = $query;

        return $request;
    }",0
"	function checkPassword($user_login, $user_password) {
		global $fmdb, $__FM_CONFIG, $fm_name;
		
		if (empty($user_login) || empty($user_password)) return false;
		
		/** Built-in authentication */
		$fm_db_version = getOption('fm_db_version');
		$auth_method = ($fm_db_version >= 18) ? getOption('auth_method') : true;
		if ($auth_method) {
			/** Use Builtin Auth when Default Auth Method is LDAP but user is defined with 'facileManager/Builtin' */
			$result = $fmdb->query(""SELECT * FROM `fm_users` WHERE `user_login` = '$user_login' and `user_auth_type`=1 and `user_status`='active'"");
			if (is_array($fmdb->last_result) && $fmdb->last_result[0]->user_login == $user_login) {
				$auth_method = 1;
			}

			/** Builtin Authentication */
			if ($auth_method == 1) {
				if ($fm_db_version >= 18) {
					$result = $fmdb->get_results(""SELECT * FROM `fm_users` WHERE `user_status`='active' AND `user_auth_type`=1 AND `user_template_only`='no' AND `user_login`='$user_login'"");
				} else {
					/** Old auth */
					$result = $fmdb->get_results(""SELECT * FROM `fm_users` WHERE `user_status`='active' AND `user_login`='$user_login' AND `user_password`='$user_password'"");
				}
				if (!$fmdb->num_rows) {
					return false;
				} else {
					$user = $fmdb->last_result[0];
					
					/** Check password */
					if ($user->user_password[0] == '*') {
						/** Old MySQL hashing that needs to change */
						if ($user->user_password != '*' . strtoupper(sha1(sha1($user_password, true)))) {
							return false;
						}
						resetPassword($user_login, $user_password);
					} else {
						/** PHP hashing */
						if (!password_verify($user_password, $user->user_password)) {
							return false;
						}
					}
					
					/** Enforce password change? */
					if ($fm_db_version >= 15) {
						if ($user->user_force_pwd_change == 'yes') {
							$pwd_reset_query = ""SELECT * FROM `fm_pwd_resets` WHERE `pwd_login`={$user->user_id} ORDER BY `pwd_timestamp` LIMIT 1"";
							$fmdb->get_results($pwd_reset_query);
							if ($fmdb->num_rows) {
								$reset = $fmdb->last_result[0];
								return array($reset->pwd_id, $user_login);
							}
						}
					}
			
					$this->setSession($user);

					return true;
				}
			/** LDAP Authentication */
			} else {
				return $this->doLDAPAuth($user_login, $_POST['password']);
			}
		}
		
		return false;
	}",1
"                        \set_error_handler(function ($_, $error) use (&$errno, &$errstr) {
                            // Match errstr from PHP's warning message.
                            // fwrite(): send of 1 bytes failed with errno=111 Connection refused
                            \preg_match('/errno=(\d+) (.+)/', $error, $m);
                            $errno = isset($m[1]) ? (int) $m[1] : 0;
                            $errstr = isset($m[2]) ? $m[2] : $error;
                        });",0
"				$this->nonce_action( $action );
			}
		}

		add_action( 'litespeed_nonce', array( $this, 'nonce_action' ) );
	}",1
"    public function onCall(ConnectionInterface $conn, $id, $topic, array $params) {
        $this->app->onCall($conn, $id, $this->getTopic($topic), $params);
    }",0
"        foreach ($values as $key => $value) {
            try {
                $field = $form->getFieldByHandle($key);

                // Prevent users using long-hand Twig `{{` to prevent injection execution. Only an issue for 
                if (is_string($value)) {
                    $value = str_replace(['{{', '}}', '{%', '%}'], ['{', '}', '', ''], $value);
                }

                if ($field) {
                    // Store any visibly disabled fields against the form to apply later
                    if ($field->visibility === 'disabled') {
                        $disabledValues[$key] = $value;
                    }
                    
                    // Ensure that the field has a chance to populate the default value correctly
                    $field->populateValue($value);

                    // If forcing, set the value every time this is called
                    if ($force && $submission) {
                        // The value will be normalised already as the `defaulValue`
                        $submission->setFieldValue($field->handle, $field->defaultValue);
                    }
                }
            } catch (Throwable $e) {
                Formie::error('Error populating form values for “{key}”. Template error: “{message}” {file}:{line}', [
                    'key' => $key,
                    'message' => $e->getMessage(),
                    'file' => $e->getFile(),
                    'line' => $e->getLine(),
                ]);

                continue;
            }
        }",1
"    public function count() {
        return $this->subscribers->count();
    }",0
"	public function callParsedown($string)
	{
		$pd = new Parsedown();
		return $pd->line($string);
	}",1
"    public function __construct() {
        $this->upload_errors = array(
            UPLOAD_ERR_OK         => LANG_UPLOAD_ERR_OK,
            UPLOAD_ERR_INI_SIZE   => sprintf(LANG_UPLOAD_ERR_INI_SIZE, $this->getMaxUploadSize()),
            UPLOAD_ERR_FORM_SIZE  => LANG_UPLOAD_ERR_FORM_SIZE,
            UPLOAD_ERR_PARTIAL    => LANG_UPLOAD_ERR_PARTIAL,
            UPLOAD_ERR_NO_FILE    => LANG_UPLOAD_ERR_NO_FILE,
            UPLOAD_ERR_NO_TMP_DIR => LANG_UPLOAD_ERR_NO_TMP_DIR,
            UPLOAD_ERR_CANT_WRITE => LANG_UPLOAD_ERR_CANT_WRITE,
            UPLOAD_ERR_EXTENSION  => LANG_UPLOAD_ERR_EXTENSION
        );
        $this->user_id = cmsUser::getInstance()->id;
        $this->site_cfg = cmsConfig::getInstance();
    }",1
"    protected function newConn() {
        return new WampConnection($this->getMock('\\Ratchet\\ConnectionInterface'));
    }",0
"			$userRootShow = _get($GLOBALS,'isRoot') && $GLOBALS['config'][""ADMIN_ALLOW_SOURCE""];
			if(!$userRootShow){
				if( !$pathInfo['auth'] || $pathInfo['auth']['authValue'] == 0){ // 放过-1; 打开通路;
					continue;// 没有权限;
				}
			}
			
			// 没有子文件夹; 则获取是否有子部门;
			// if( !$pathInfo['hasFolder'] && !$pathInfo['hasFile'] ){
			if( !$pathInfo['hasFolder'] ){
				$groupInfo = Model('Group')->getInfo($groupID);
				$pathInfo['hasFolder']  = $groupInfo ? $groupInfo['hasChildren']:false;
			}
			$result[] = $pathInfo;
		}
		// pr($result,$groupSource,$group,$groupArray);exit;
		return $result;
	}",1
"  function render(&$table, $value, $row, $column, $selected = false) {
    global $user;
    $showNotes = $user->isOptionEnabled('week_notes');

    $field_name = $table->getValueAt($row,$column)['control_id']; // Our text field names (and ids) are like x_y (row_column).
    $field = new TextField($field_name);
    // Disable control if the date is locked.
    global $lockedDays;
    if ($lockedDays[$column])
      $field->setEnabled(false);
    $field->setFormName($table->getFormName());
    $field->setStyle('width: 60px;'); // TODO: need to style everything properly, eventually.
    // Provide visual separation for new entry row.
    $rowToSeparate = $showNotes ? 1 : 0;
    if ($rowToSeparate == $row) {
      $field->setStyle('width: 60px; margin-bottom: 40px');
    }
    if ($showNotes) {
      if (0 == $row % 2) {
        $field->setValue($table->getValueAt($row,$column)['duration']); // Duration for even rows.
      } else {
        $field->setValue($table->getValueAt($row,$column)['note']);     // Comment for odd rows.
        $field->setTitle(htmlspecialchars($table->getValueAt($row,$column)['note'])); // Tooltip to help view the entire comment.
      }
    } else {
      $field->setValue($table->getValueAt($row,$column)['duration']);
      // $field->setTitle($table->getValueAt($row,$column)['note']); // Tooltip to see comment. TODO - value not available.
    }
    // Disable control when time entry mode is TYPE_START_FINISH and there is no value in control
    // because we can't supply start and finish times in week view - there are no fields for them.
    if (!$field->getValue() && TYPE_START_FINISH == $user->getRecordType()) {
        $field->setEnabled(false);
    }
    $this->setValue($field->getHtml());
    return $this->toString();
  }",0
"            $ext = pack('n', $this->defPayLen);
            $this->secondByte = 126;
        }

        $this->data       = chr($this->firstByte) . chr($this->secondByte) . $ext . $payload;
        $this->bytesRecvd = 2 + strlen($ext) + $this->defPayLen;
    }",0
"    public function start($attributes)
    {
        $height = $this->document->getHeight();
        $width = $this->document->getWidth();
        $this->y = $height;

        if (isset($attributes['x'])) {
            $this->x = $this->convertSize($attributes['x'], $width);
        }
        if (isset($attributes['y'])) {
            $this->y = $height - $this->convertSize($attributes['y'], $height);
        }

        if (isset($attributes['width'])) {
            $this->width = $this->convertSize($attributes['width'], $width);
        }
        if (isset($attributes['height'])) {
            $this->height = $this->convertSize($attributes['height'], $height);
        }

        if (isset($attributes['xlink:href'])) {
            $this->href = $attributes['xlink:href'];
        }

        if (isset($attributes['href'])) {
            $this->href = $attributes['href'];
        }

        $this->document->getSurface()->transform(1, 0, 0, -1, 0, $height);

        if (\strtolower(\substr($this->href, 0, 7)) === ""phar://"" || ($this->document->allowExternalReferences === false && \strtolower(\substr($this->href, 0, 5) !== ""data:""))) {
            return;
        }

        $this->document->getSurface()->drawImage($this->href, $this->x, $this->y, $this->width, $this->height);
    }",1
"    public function __construct()
    {
        // same as secp128r1
        $this->setModulo(new BigInteger('FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFF', 16));
        $this->setCoefficients(
            new BigInteger('D6031998D1B3BBFEBF59CC9BBFF9AEE1', 16),
            new BigInteger('5EEEFCA380D02919DC2C6558BB6D8A5D', 16)
        );
        $this->setBasePoint(
            new BigInteger('7B6AA5D85E572983E6FB32A7CDEBC140', 16),
            new BigInteger('27B6916A894D3AEE7106FE805FC34B44', 16)
        );
        $this->setOrder(new BigInteger('3FFFFFFF7FFFFFFFBE0024720613B5A3', 16));
    }",0
"	public function compileTemplateSource(\Smarty\Template $template, \Smarty\Compiler\Template $parent_compiler = null) {
		try {
			// save template object in compiler class
			$this->template = $template;
			if ($this->smarty->debugging) {
				$this->smarty->getDebug()->start_compile($this->template);
			}
			$this->parent_compiler = $parent_compiler ? $parent_compiler : $this;

			if (empty($template->getCompiled()->nocache_hash)) {
				$template->getCompiled()->nocache_hash = $this->nocache_hash;
			} else {
				$this->nocache_hash = $template->getCompiled()->nocache_hash;
			}
			$this->caching = $template->caching;

			// flag for nocache sections
			$this->nocache = false;
			$this->tag_nocache = false;
			// reset has nocache code flag
			$this->template->getCompiled()->setNocacheCode(false);

			$this->has_variable_string = false;
			$this->prefix_code = [];
			// add file dependency
			if ($this->template->getSource()->handler->checkTimestamps()) {
				$this->parent_compiler->getTemplate()->getCompiled()->file_dependency[$this->template->getSource()->uid] =
					[
						$this->template->getSource()->getResourceName(),
						$this->template->getSource()->getTimeStamp(),
						$this->template->getSource()->type,
					];
			}
			// get template source
			if (!empty($this->template->getSource()->components)) {
				// we have array of inheritance templates by extends: resource
				// generate corresponding source code sequence
				$_content =
					ExtendsTag::extendsSourceArrayCode($this->template);
			} else {
				// get template source
				$_content = $this->template->getSource()->getContent();
			}
			$_compiled_code = $this->smarty->runPostFilters(
				$this->doCompile(
					$this->smarty->runPreFilters($_content, $this->template),
					true
				),
				$this->template
			);
		} catch (\Exception $e) {
			if ($this->smarty->debugging) {
				$this->smarty->getDebug()->end_compile($this->template);
			}
			$this->_tag_stack = [];
			// free memory
			$this->parent_compiler = null;
			$this->template = null;
			$this->parser = null;
			throw $e;
		}
		if ($this->smarty->debugging) {
			$this->smarty->getDebug()->end_compile($this->template);
		}
		$this->parent_compiler = null;
		$this->parser = null;
		return $_compiled_code;
	}",1
"    public function getMagicData()
    {
        return $this->magicData;
    }",0
"    public function addressProvider() {
        return array(
            array('127.0.0.1', '127.0.0.1')
          , array('localhost', 'localhost')
          , array('fe80::1%lo0', 'fe80::1%lo0')
          , array('127.0.0.1', '127.0.0.1:6392')
        );
    }",0
"        foreach (['ftp', 'http', 'https', 'phar', 'whateverstream'] as $scheme) {
            yield [
                'path'                  => $scheme . '://path/to/whatever/file',
                'restricted_directory'  => null,
                'is_safe'               => false, // path using scheme is never considered to be safe
            ];

            yield [
                'path'                  => $scheme . '://path/to/whatever/file',
                'restricted_directory'  => $scheme . '://path/to/whatever',
                'is_safe'               => false, // path using scheme is never considered to be safe
            ];
        }",0
"	public function accessTokenGet(){
		if(!Session::get('kodUser')){
			show_json('user not login!',ERROR_CODE_LOGOUT);
		}
		show_json($this->accessToken(),true);
	}",1
"    public function __construct(
        private readonly StationRequestRepository $requestRepo
    ) {
    }",1
"	public function maybe_disconnect_simpleshop() {
		if ( ! wp_verify_nonce( $_GET['_wpnonce'] ) ) {
			return;
		}

		if ( ! isset( $_GET['disconnect_simpleshop'] ) || $_GET['disconnect_simpleshop'] !== '1' ) {
			return;
		}

		// Unset only API keys, leave the other settings saved
		$options = get_option( $this->key );
		unset( $options['ssc_api_email'] );
		unset( $options['ssc_api_key'] );

		// Set valid API keys to false
		update_option( 'ssc_valid_api_keys', 0 );

		// Update the SS options
		update_option( $this->key, $options );
	}",0
"    public function getEntryGroupLabel()
    {
        return $this->site->getSiteName();
    }",1
"            static function (?NodeInterface $node, string $name) use ($nodes, $names) {
                return $node === null && !in_array($name, $names, true)
                    || $node !== null && !in_array($node, $nodes, true);
            },",1
"		$name = db_fetch_cell_prepared('SELECT name
			FROM snmp_query
			WHERE id = ?',
			array($host_group_data_array[1]));

		$name = html_escape($name);
		$host_group_data_name = '<strong>' . __('Graph Template:') . '</strong> ' . (empty($host_group_data_array[1]) ? __('Non Query Based') : $name);",0
"	public function testCustomerFtpsAddNoMoreResources()
	{
		global $admin_userdata;

		// get customer
		$json_result = Customers::getLocal($admin_userdata, array(
			'loginname' => 'test1'
		))->get();
		$customer_userdata = json_decode($json_result, true)['data']; //

		$customer_userdata['ftps_used'] = 100;

		$this->expectExceptionCode(406);
		$this->expectExceptionMessage('No more resources available');
		$json_result = Ftps::getLocal($customer_userdata)->add();
	}",1
"        foreach ($array as $key => $value) {
            $lines .= str_repeat('    ', $level);
            $lines .= is_int($key) ? $key . ' => ' : '\'' . $key . '\' => ';

            if (is_array($value)) {
                if (!empty($value)) {
                    $lines .= $this->dumpToPhpCode($value, $level);
                } else {
                    $lines .= ""array(),\n"";
                }
            } elseif ($key === 'install_path' && is_string($value)) {
                if ($this->filesystem->isAbsolutePath($value)) {
                    $lines .= var_export($value, true) . "",\n"";
                } else {
                    $lines .= ""__DIR__ . "" . var_export('/' . $value, true) . "",\n"";
                }
            } else {
                $lines .= var_export($value, true) . "",\n"";
            }
        }",1
"    public function __construct(
        Dispatcher $events,
        SessionAuthenticator $authenticator,
        Rememberer $rememberer,
        Factory $view,
        UrlGenerator $url
    ) {
        $this->events = $events;
        $this->authenticator = $authenticator;
        $this->rememberer = $rememberer;
        $this->view = $view;
        $this->url = $url;
    }",1
"    public function sentAssetAcceptanceReminder($acceptanceId = null)
    {
        $this->authorize('reports.view');

        if (!$acceptance = CheckoutAcceptance::pending()->find($acceptanceId)) {
            // Redirect to the unaccepted assets report page with error
            return redirect()->route('reports/unaccepted_assets')->with('error', trans('general.bad_data'));
        }
        $assetItem = $acceptance->checkoutable;

        if (is_null($acceptance->created_at)){
            return redirect()->route('reports/unaccepted_assets')->with('error', trans('general.bad_data'));
        } else {
            $logItem_res = $assetItem->checkouts()->where('created_at', '=', $acceptance->created_at)->get();
            if ($logItem_res->isEmpty()){
                return redirect()->route('reports/unaccepted_assets')->with('error', trans('general.bad_data'));
            }
            $logItem = $logItem_res[0];
        }

        if(!$assetItem->assignedTo->locale){
            Notification::locale(Setting::getSettings()->locale)->send(
                $assetItem->assignedTo,
                new CheckoutAssetNotification($assetItem, $assetItem->assignedTo, $logItem->user, $acceptance, $logItem->note)
            );
        } else {
            Notification::send(
                $assetItem->assignedTo,
                new CheckoutAssetNotification($assetItem, $assetItem->assignedTo, $logItem->user, $acceptance, $logItem->note)
            );
        }

        return redirect()->route('reports/unaccepted_assets')->with('success', trans('admin/reports/general.reminder_sent'));
    }",1
"    function validateURL($url)
    {
        if (!is_array($this->currentCert) || !isset($this->currentCert['tbsCertificate'])) {
            return false;
        }

        $components = parse_url($url);
        if (!isset($components['host'])) {
            return false;
        }

        if ($names = $this->getExtension('id-ce-subjectAltName')) {
            foreach ($names as $name) {
                foreach ($name as $key => $value) {
                    $value = str_replace(array('.', '*'), array('\.', '[^.]*'), $value);
                    switch ($key) {
                        case 'dNSName':
                            /* From RFC2818 ""HTTP over TLS"":

                               If a subjectAltName extension of type dNSName is present, that MUST
                               be used as the identity. Otherwise, the (most specific) Common Name
                               field in the Subject field of the certificate MUST be used. Although
                               the use of the Common Name is existing practice, it is deprecated and
                               Certification Authorities are encouraged to use the dNSName instead. */
                            if (preg_match('#^' . $value . '$#', $components['host'])) {
                                return true;
                            }
                            break;
                        case 'iPAddress':
                            /* From RFC2818 ""HTTP over TLS"":

                               In some cases, the URI is specified as an IP address rather than a
                               hostname. In this case, the iPAddress subjectAltName must be present
                               in the certificate and must exactly match the IP in the URI. */
                            if (preg_match('#(?:\d{1-3}\.){4}#', $components['host'] . '.') && preg_match('#^' . $value . '$#', $components['host'])) {
                                return true;
                            }
                    }
                }
            }
            return false;
        }

        if ($value = $this->getDNProp('id-at-commonName')) {
            $value = str_replace(array('.', '*'), array('\.', '[^.]*'), $value[0]);
            return preg_match('#^' . $value . '$#', $components['host']);
        }

        return false;
    }",1
"    public function __construct(array $allowedMethods, string $message = '', int $code = 0, \Throwable $previous = null)
    {
        $this->allowedMethods = array_map('strtoupper', $allowedMethods);

        parent::__construct($message, $code, $previous);
    }",0
"    public function render(Shift $shift, $needed_angeltypes, $shift_entries, $user)
    {
        $info_text = '';
        if ($shift->title != '') {
            $info_text = icon('info-circle') . $shift->title . '<br>';
        }
        list($shift_signup_state, $shifts_row) = $this->renderShiftNeededAngeltypes(
            $shift,
            $needed_angeltypes,
            $shift_entries,
            $user
        );

        $class = $this->classForSignupState($shift_signup_state);

        $blocks = ceil(($shift->end->timestamp - $shift->start->timestamp) / ShiftCalendarRenderer::SECONDS_PER_ROW);
        $blocks = max(1, $blocks);

        $room = $shift->room;

        return [
            $blocks,
            div(
                'shift-card"" style=""height: '
                . ($blocks * ShiftCalendarRenderer::BLOCK_HEIGHT - ShiftCalendarRenderer::MARGIN)
                . 'px;',
                div(
                    'shift card bg-' . $class,
                    [
                        $this->renderShiftHead($shift, $class, $shift_signup_state->getFreeEntries()),
                        div('card-body ' . $this->classBg(), [
                            $info_text,
                            Room_name_render($room),
                        ]),
                        $shifts_row,
                    ]
                )
            ),",1
"    public function handle(EventMessage $event)
    {
        //This Handler will print the incoming message.
        echo ""Message Received from :"". $event->getFrom()."" \n"";
        if ($event->getContentEncoding()=='base64'){

            echo base64_decode($event->getContent());
            }
        else{
            echo 'Unrecognized encoding - printing message in this encoding :  ' ;
            $event->getContentEncoding();
            echo '\n Message:  ' ;
            $event->getContent();
            }



    }",0
"            \call_user_func($timer->getCallback(), $timer);

            // re-schedule if this is a periodic timer and it has not been cancelled explicitly already
            if ($timer->isPeriodic() && isset($this->timers[$id])) {
                $this->schedule[$id] = $timer->getInterval() + $time;
                $this->sorted = false;
            } else {
                unset($this->timers[$id], $this->schedule[$id]);
            }
        }",0
"    public function setCookie(Cookie $cookie)
    {
        $this->cookies[$cookie->getDomain()][$cookie->getPath()][$cookie->getName()] = $cookie;
        $this->headerNames['set-cookie'] = 'Set-Cookie';
    }",0
"    public function save_unavailability()
    {
        try
        {
            // Check privileges
            $unavailability = request('unavailability');

            $required_permissions = ( ! isset($unavailability['id']))
                ? can('add', PRIV_APPOINTMENTS)
                : can('edit', PRIV_APPOINTMENTS);

            if ( ! $required_permissions)
            {
                throw new RuntimeException('You do not have the required permissions for this task.');
            }

            $provider = $this->providers_model->find($unavailability['id_users_provider']);

            $unavailability_id = $this->unavailabilities_model->save($unavailability);

            $unavailability = $this->unavailabilities_model->find($unavailability_id);

            $this->synchronization->sync_unavailability_saved($unavailability, $provider);

            $this->webhooks_client->trigger(WEBHOOK_UNAVAILABILITY_SAVE, $unavailability);

            json_response([
                'success' => TRUE,
                'warnings' => $warnings ?? []
            ]);
        }
        catch (Throwable $e)
        {
            json_exception($e);
        }
    }",1
"    public function __construct(
        ?bool $graphqlShowDocs
    ) {
        $this->graphqlShowDocs = $graphqlShowDocs;
    }",0
"    public function getById($sessionId)
    {
        $session = $this->query(null, ['sessionId' => $sessionId]);

        if (count($session) <= 0)
            throw new NotFoundException();

        return $session[0];
    }",1
"    public function getDestContext()
    {
        return $this->getKey('DestContext');
    }",0
"            $jsFileInclude .= htmlentities($_POST['js_keys'][$i]) . ':' . '""' . htmlentities($_POST['js_values'][$i]) . '"",' . ""\n"";
            $prevFile = $jsFile;
            $i++;
        }
        $jsFileInclude .= ""};"";
        savefile($jsFile, $jsFileInclude);
    }",1
"	public function load_widget_block( $params ) {
		// global $wp_widget_factory;
		// $widget = $wp_widget_factory->widgets[ $params[ self::PARAM_NAME ] ];
		$option = $params[ self::PARAM_INSTANCE ];
		$option = $option[ Base::OPTION_NAME ];

		// Since we only reach here via esi, safe to assume setting exists.
		$ttl = $option[ self::WIDGET_O_TTL ];
		defined( 'LSCWP_LOG' ) && Debug2::debug( 'ESI widget render: name ' . $params[ self::PARAM_NAME ] . ', id ' . $params[ self::PARAM_ID ] . ', ttl ' . $ttl );
		if ( $ttl == 0 ) {
			Control::set_nocache( 'ESI Widget time to live set to 0' );
		}
		else {
			Control::set_custom_ttl( $ttl );

			if ( $option[ self::WIDGET_O_ESIENABLE ] == Base::VAL_ON2 ) {
				Control::set_private();
			}
			Control::set_no_vary();
			Tag::add( Tag::TYPE_WIDGET . $params[ self::PARAM_ID ] );
		}
		the_widget( $params[ self::PARAM_NAME ], $params[ self::PARAM_INSTANCE ], $params[ self::PARAM_ARGS ] );
	}",1
"            $route->setPath('/'.$prefix.$route->getPath());
            $route->addDefaults($defaults);
            $route->addRequirements($requirements);
        }",0
"    public function generatePage(int $code, string $message)
    {
        $error = $this->getCodeInfo($code);
        $error['message'] ??= __trans('Uh-oh! You\'ve received a generic error message: :errorMessage', [':errorMessage' => '<code>' . $message . '</code>']);

        $page = '
        <!DOCTYPE html>
        <html>
            <head>
            <title>FOSSBilling Error | ' . $error['title'] . '</title>
            <style>
            body {
                background-color: #222;
                color: #fff;
                font-family: -apple-system, BlinkMacSystemFont, ""Segoe UI"", Roboto, Helvetica, Arial, sans-serif, ""Apple Color Emoji"", ""Segoe UI Emoji"", ""Segoe UI Symbol"";
                font-size: 16px;
                line-height: 1.5;
                margin: 0;
                padding: 0;
                text-align: left;
            }

            .container {
                display: flex;
                justify-content: center;
                align-items: center;
                height: 100vh;
            }

            .error-container {
                width: 75%;
                background-color: #313131;
                border-radius: 25px;
                padding: 1%;
            }

            .error-title {
                font-size: 3.75rem;
                font-weight: 600;
                margin-bottom: 0px;
            }

            .error-code {
                font-size: 1rem;
                font-weight: 200;
                margin: 0px;
            }

            .error-category {
                font-size: 1rem;
                font-weight: 200;
                margin: 0px;
            }

            .error-message {
                font-size: 1.25rem;
                margin-bottom: 30px;
                line-height: 1.8;
            }

            code {
                background-color: #f2f2f2;
                color: #333;
                border-radius: 3px;
            }

            .footer {
                color: #fff;
                padding: 5px;
                text-align: center;
                font-size: 14px;
            }

            .footer a {
                color: #fff;
                text-decoration: none;
                margin: 0 10px;
            }

            .footer a:hover {
                text-decoration: underline;
            }

            a {
                color: #3291ff;
            }

            a:visited {
                color: inherit;
                text-decoration: none;
            }

            a:hover {
                text-decoration: underline;
            }

            .button {
                background-color: #3291ff;
                border: none;
                color: #fff;
                padding: 10px 20px;
                border-radius: 5px;
                font-size: 15px;
                cursor: pointer;
                transition: all 0.3s ease;
                text-decoration: none;
            }

            .button:hover {
                background-color: #3d9dff;
                text-decoration: none;
            }

            </style>
            </head>
            <body>
                <div class=""container"">
                <div class=""error-container"">
                    <p class=""error-title"">' . $error['title'] . '</p>
                    <p class=""error-code"">' . __trans('Error Code: #:number', [':number' => $code]) . '</p>
                    <p class=""error-category"">' . __trans('Component: :category', [':category' => $error['category']]) . '</p>
                    <p class=""error-message"" id=""specialized"">' . $error['message'] . '</p>
                    <p class=""error-message"" id=""original"" style=""display: none;"">' . $message . '</p>

                    <div class=""link-container"">
                        <button id=""toggle"" class=""button"" onclick=""toggle()"">' . __trans(""Show original message"") . '</button>
                        <a class=""button"" target=""_blank"" href=""' . $error['link']['href'] . '"">' . $error['link']['label'] . '</a>
                    </div>

                    <div class=""footer"" style=""clear:both"">
                        <hr>
                        <p>Powered By FOSSBilling</p>
                        <p>
                            <a href=""https://github.com/fossbilling/fossbilling"">Source code</a> |
                            <a href=""https://fossbilling.org/discord"">Discord</a> |
                            <a href=""https://fossbilling.org/docs"">Documentation</a> |
                            <a href=""https://forum.fossbilling.com/"">Forum</a> |
                            <a href=""https://opencollective.com/FOSSBilling"">Donate</a>
                        </p>
                    </div>
                </div>
                </div>
                <script>
                    function toggle() {
                        var og = document.getElementById(""original"");
                        var specialized = document.getElementById(""specialized"");

                        if (og.style.display === ""none"") {
                            og.style.display = ""block"";
                            specialized.style.display = ""none"";
                            document.querySelector(""#toggle"").innerHTML = ""' . __trans(""Show specialized message"") . '"";
                        } else {
                            og.style.display = ""none"";
                            specialized.style.display = ""block"";
                            document.querySelector(""#toggle"").innerHTML = ""' . __trans(""Show original message"") . '"";
                        }
                    }
                </script>
            </body>
        </html>';
        echo $page;
        die();
    }",1
"    public function __construct($timeout)
    {
        parent::__construct('WaitEvent');
        $this->setKey('Timeout', (int)$timeout);
    }",0
"    public function testControllerOnOpen() {
        $controller = $this->getMockBuilder('\Ratchet\WebSocket\WsServer')->disableOriginalConstructor()->getMock();
        $this->_matcher->expects($this->any())->method('match')->will($this->returnValue(array('_controller' => $controller)));
        $this->_router->onOpen($this->_conn, $this->_req);

        $expectedConn = new \PHPUnit_Framework_Constraint_IsInstanceOf('\Ratchet\ConnectionInterface');
        $controller->expects($this->once())->method('onOpen')->with($expectedConn, $this->_req);

        $this->_matcher->expects($this->any())->method('match')->will($this->returnValue(array('_controller' => $controller)));
        $this->_router->onOpen($this->_conn, $this->_req);
    }",0
                            $prf = ['algorithm' => 'id-hmacWithSHA1'];,0
"    public function replace(array $inputs = [])
    {
        $this->parameters = [];
        $this->add($inputs);
    }",0
"    public function applyGridFilter(cmsGrid $grid, $filter) {

        $grid->applyGridFilter($this, $filter);

        return $this;
    }",1
"    public function resizeImage($source_file, $size){

        $dest_dir  = $this->getUploadDestinationDirectory();
        $dest_ext  = pathinfo($source_file, PATHINFO_EXTENSION);
        $dest_name = $this->getFileName($dest_dir, $dest_ext);

        $dest_file = $dest_dir . $dest_name;

        if (!isset($size['height'])) { $size['height'] = 0; }
        if (!isset($size['quality'])) { $size['quality'] = 90; }

        if (img_resize($source_file, $dest_file, $size['width'], $size['height'], $size['is_square'], $size['quality'])) {

            return str_replace($this->site_cfg->upload_path, '', $dest_file);

        }

        return false;

    }",1
"    public function setUp() {
        if (!extension_loaded('PDO') || !extension_loaded('pdo_sqlite')) {
            return $this->markTestSkipped('Session test requires PDO and pdo_sqlite');
        }

        $schema = <<<SQL
CREATE TABLE `sessions` (
    `sess_id` VARBINARY(128) NOT NULL PRIMARY KEY,
    `sess_data` BLOB NOT NULL,
    `sess_time` INTEGER UNSIGNED NOT NULL,
    `sess_lifetime` MEDIUMINT NOT NULL
);
SQL;
        $this->_pathToDB = tempnam(sys_get_temp_dir(), 'SQ3');;
        $dsn = 'sqlite:' . $this->_pathToDB;

        $pdo = new \PDO($dsn);
        $pdo->setAttribute(\PDO::ATTR_ERRMODE, \PDO::ERRMODE_EXCEPTION);
        $pdo->exec($schema);
        $pdo = null;

        $sessionHandler = new PdoSessionHandler($dsn);
        $serializer = new PhpHandler();
        $this->_virtualSessionStorage = new VirtualSessionStorage($sessionHandler, 'foobar', $serializer);
        $this->_virtualSessionStorage->registerBag(new FlashBag());
        $this->_virtualSessionStorage->registerBag(new AttributeBag());
    }",0
